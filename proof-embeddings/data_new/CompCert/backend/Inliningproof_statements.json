{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Inliningproof.v","fileSamples":[{"statement":"(prog tprog : program) (H : transf_program prog = OK tprog) : match_prog prog tprog.","conclusion":"match_prog prog tprog","hypotheses":"(prog tprog : program) (H : transf_program prog = OK tprog)","proofString":"eapply match_transform_partial_program_contextual; eauto."},{"statement":"(cu : program) (f f' : fundef) (H : transf_fundef (funenv_program cu) f = OK f') : funsig f' = funsig f.","conclusion":"funsig f' = funsig f","hypotheses":"(cu : program) (f f' : fundef) (H : transf_fundef (funenv_program cu) f = OK f')","proofString":"destruct f; Errors.monadInv H.\nexploit transf_function_spec; eauto.\nintros SP; inv SP.\nauto.\nauto."},{"statement":"(cu : program) (f x : function) (EQ : transf_function (funenv_program cu) f = OK x) : funsig (Internal x) = funsig (Internal f).","conclusion":"funsig (Internal x) = funsig (Internal f)","hypotheses":"(cu : program) (f x : function) (EQ : transf_function (funenv_program cu) f = OK x)","proofString":"exploit transf_function_spec; eauto.\nintros SP; inv SP.\nauto."},{"statement":"(cu : program) (f x : function) (EQ : transf_function (funenv_program cu) f = OK x) : tr_function cu f x -> funsig (Internal x) = funsig (Internal f).","conclusion":"tr_function cu f x -> funsig (Internal x) = funsig (Internal f)","hypotheses":"(cu : program) (f x : function) (EQ : transf_function (funenv_program cu) f = OK x)","proofString":"intros SP; inv SP.\nauto."},{"statement":"(cu : program) (f x : function) (EQ : transf_function (funenv_program cu) f = OK x) (fenv : funenv) (ctx : context) (H : fenv_compat cu fenv) (H0 : tr_funbody fenv (fn_stacksize x) ctx f (fn_code x)) (H1 : dstk ctx = 0) (H2 : retinfo ctx = None) (H3 : fn_sig x = fn_sig f) (H4 : fn_params x = sregs ctx (fn_params f)) (H5 : fn_entrypoint x = spc ctx (fn_entrypoint f)) (H6 : 0 <= fn_stacksize x < Ptrofs.max_unsigned) : funsig (Internal x) = funsig (Internal f).","conclusion":"funsig (Internal x) = funsig (Internal f)","hypotheses":"(cu : program) (f x : function) (EQ : transf_function (funenv_program cu) f = OK x) (fenv : funenv) (ctx : context) (H : fenv_compat cu fenv) (H0 : tr_funbody fenv (fn_stacksize x) ctx f (fn_code x)) (H1 : dstk ctx = 0) (H2 : retinfo ctx = None) (H3 : fn_sig x = fn_sig f) (H4 : fn_params x = sregs ctx (fn_params f)) (H5 : fn_entrypoint x = spc ctx (fn_entrypoint f)) (H6 : 0 <= fn_stacksize x < Ptrofs.max_unsigned)","proofString":"auto."},{"statement":"(cu : program) (e : external_function) : funsig (External e) = funsig (External e).","conclusion":"funsig (External e) = funsig (External e)","hypotheses":"(cu : program) (e : external_function)","proofString":"auto."},{"statement":"(ctx : context) (r : reg) (r' : positive) (H : Plt r' (dreg ctx)) : sreg ctx r <> r'.","conclusion":"sreg ctx r <> r'","hypotheses":"(ctx : context) (r : reg) (r' : positive) (H : Plt r' (dreg ctx))","proofString":"zify.\nunfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(ctx : context) (r : reg) (r' : positive) (H : Plt r' (dreg ctx)) (cstr : 0 < Z.pos r') (cstr0 : 0 < Z.pos (sreg ctx r)) : Z.pos (sreg ctx r) <> Z.pos r'.","conclusion":"Z.pos (sreg ctx r) <> Z.pos r'","hypotheses":"(ctx : context) (r : reg) (r' : positive) (H : Plt r' (dreg ctx)) (cstr : 0 < Z.pos r') (cstr0 : 0 < Z.pos (sreg ctx r))","proofString":"unfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(ctx : context) (r : reg) (r' : positive) (H : Plt r' (dreg ctx)) (cstr : 0 < Z.pos r') (cstr0 : 0 < Z.pos (sreg ctx r)) : Z.pos r + Z.pos (dreg ctx) - 1 <> Z.pos r'.","conclusion":"Z.pos r + Z.pos (dreg ctx) - 1 <> Z.pos r'","hypotheses":"(ctx : context) (r : reg) (r' : positive) (H : Plt r' (dreg ctx)) (cstr : 0 < Z.pos r') (cstr0 : 0 < Z.pos (sreg ctx r))","proofString":"extlia."},{"statement":"(ctx1 ctx2 : context) (r1 : positive) (r2 : reg) (H : context_below ctx1 ctx2) (H0 : Ple r1 (mreg ctx1)) : sreg ctx1 r1 <> sreg ctx2 r2.","conclusion":"sreg ctx1 r1 <> sreg ctx2 r2","hypotheses":"(ctx1 ctx2 : context) (r1 : positive) (r2 : reg) (H : context_below ctx1 ctx2) (H0 : Ple r1 (mreg ctx1))","proofString":"red in H.\nzify.\nunfold sreg; rewrite ! shiftpos_eq.\nextlia."},{"statement":"(ctx1 ctx2 : context) (r1 : positive) (r2 : reg) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r1 (mreg ctx1)) : sreg ctx1 r1 <> sreg ctx2 r2.","conclusion":"sreg ctx1 r1 <> sreg ctx2 r2","hypotheses":"(ctx1 ctx2 : context) (r1 : positive) (r2 : reg) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r1 (mreg ctx1))","proofString":"zify.\nunfold sreg; rewrite ! shiftpos_eq.\nextlia."},{"statement":"(ctx1 ctx2 : context) (r1 : positive) (r2 : reg) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r1 (mreg ctx1)) (cstr : 0 < Z.pos (sreg ctx2 r2)) (cstr0 : 0 < Z.pos (sreg ctx1 r1)) : Z.pos (sreg ctx1 r1) <> Z.pos (sreg ctx2 r2).","conclusion":"Z.pos (sreg ctx1 r1) <> Z.pos (sreg ctx2 r2)","hypotheses":"(ctx1 ctx2 : context) (r1 : positive) (r2 : reg) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r1 (mreg ctx1)) (cstr : 0 < Z.pos (sreg ctx2 r2)) (cstr0 : 0 < Z.pos (sreg ctx1 r1))","proofString":"unfold sreg; rewrite ! shiftpos_eq.\nextlia."},{"statement":"(ctx1 ctx2 : context) (r1 : positive) (r2 : reg) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r1 (mreg ctx1)) (cstr : 0 < Z.pos (sreg ctx2 r2)) (cstr0 : 0 < Z.pos (sreg ctx1 r1)) : Z.pos r1 + Z.pos (dreg ctx1) - 1 <> Z.pos r2 + Z.pos (dreg ctx2) - 1.","conclusion":"Z.pos r1 + Z.pos (dreg ctx1) - 1 <> Z.pos r2 + Z.pos (dreg ctx2) - 1","hypotheses":"(ctx1 ctx2 : context) (r1 : positive) (r2 : reg) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r1 (mreg ctx1)) (cstr : 0 < Z.pos (sreg ctx2 r2)) (cstr0 : 0 < Z.pos (sreg ctx1 r1))","proofString":"extlia."},{"statement":"(ctx1 ctx2 : context) (r : positive) (H : context_below ctx1 ctx2) (H0 : Ple r (mreg ctx1)) : Plt (sreg ctx1 r) (dreg ctx2).","conclusion":"Plt (sreg ctx1 r) (dreg ctx2)","hypotheses":"(ctx1 ctx2 : context) (r : positive) (H : context_below ctx1 ctx2) (H0 : Ple r (mreg ctx1))","proofString":"red in H.\nunfold Plt; zify.\nunfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(ctx1 ctx2 : context) (r : positive) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r (mreg ctx1)) : Plt (sreg ctx1 r) (dreg ctx2).","conclusion":"Plt (sreg ctx1 r) (dreg ctx2)","hypotheses":"(ctx1 ctx2 : context) (r : positive) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r (mreg ctx1))","proofString":"unfold Plt; zify.\nunfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(ctx1 ctx2 : context) (r : positive) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r (mreg ctx1)) (cstr : 0 < Z.pos (dreg ctx2)) (cstr0 : 0 < Z.pos (sreg ctx1 r)) : Z.pos (sreg ctx1 r) < Z.pos (dreg ctx2).","conclusion":"Z.pos (sreg ctx1 r) < Z.pos (dreg ctx2)","hypotheses":"(ctx1 ctx2 : context) (r : positive) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r (mreg ctx1)) (cstr : 0 < Z.pos (dreg ctx2)) (cstr0 : 0 < Z.pos (sreg ctx1 r))","proofString":"unfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(ctx1 ctx2 : context) (r : positive) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r (mreg ctx1)) (cstr : 0 < Z.pos (dreg ctx2)) (cstr0 : 0 < Z.pos (sreg ctx1 r)) : Z.pos r + Z.pos (dreg ctx1) - 1 < Z.pos (dreg ctx2).","conclusion":"Z.pos r + Z.pos (dreg ctx1) - 1 < Z.pos (dreg ctx2)","hypotheses":"(ctx1 ctx2 : context) (r : positive) (H : Ple (dreg ctx1 + mreg ctx1) (dreg ctx2)) (H0 : Ple r (mreg ctx1)) (cstr : 0 < Z.pos (dreg ctx2)) (cstr0 : 0 < Z.pos (sreg ctx1 r))","proofString":"extlia."},{"statement":"(p q : positive) : {Plt p q} + {Ple q p}.","conclusion":"{Plt p q} + {Ple q p}","hypotheses":"(p q : positive)","proofString":"destruct (plt p q).\nleft; auto.\nright; extlia."},{"statement":"(p q : positive) (p0 : Plt p q) : {Plt p q} + {Ple q p}.","conclusion":"{Plt p q} + {Ple q p}","hypotheses":"(p q : positive) (p0 : Plt p q)","proofString":"left; auto."},{"statement":"(p q : positive) (n : ~ Plt p q) : {Plt p q} + {Ple q p}.","conclusion":"{Plt p q} + {Ple q p}","hypotheses":"(p q : positive) (n : ~ Plt p q)","proofString":"right; extlia."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs') : val_reg_charact F ctx rs' rs # r r.","conclusion":"val_reg_charact F ctx rs' rs # r r","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs')","proofString":"destruct H as [A B].\ndestruct (Plt_Ple_dec (mreg ctx) r).\nleft.\nrewrite B; auto.\nright.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) : val_reg_charact F ctx rs' rs # r r.","conclusion":"val_reg_charact F ctx rs' rs # r r","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef)","proofString":"destruct (Plt_Ple_dec (mreg ctx) r).\nleft.\nrewrite B; auto.\nright.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (p : Plt (mreg ctx) r) : val_reg_charact F ctx rs' rs # r r.","conclusion":"val_reg_charact F ctx rs' rs # r r","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (p : Plt (mreg ctx) r)","proofString":"left.\nrewrite B; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (p : Plt (mreg ctx) r) : Plt (mreg ctx) r /\\ rs # r = Vundef.","conclusion":"Plt (mreg ctx) r /\\ rs # r = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (p : Plt (mreg ctx) r)","proofString":"rewrite B; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (p : Ple r (mreg ctx)) : val_reg_charact F ctx rs' rs # r r.","conclusion":"val_reg_charact F ctx rs' rs # r r","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (p : Ple r (mreg ctx))","proofString":"right.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (p : Ple r (mreg ctx)) : Ple r (mreg ctx) /\\ Val.inject F rs # r rs' # (sreg ctx r).","conclusion":"Ple r (mreg ctx) /\\ Val.inject F rs # r rs' # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (A : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (B : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (p : Ple r (mreg ctx))","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (a : positive) (rl : list positive) (IHrl : agree_regs F ctx rs rs' ->\nlist_forall2 (val_reg_charact F ctx rs') rs ## rl rl) (H : agree_regs F ctx rs rs') : val_reg_charact F ctx rs' rs # a a.","conclusion":"val_reg_charact F ctx rs' rs # a a","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (a : positive) (rl : list positive) (IHrl : agree_regs F ctx rs rs' ->\nlist_forall2 (val_reg_charact F ctx rs') rs ## rl rl) (H : agree_regs F ctx rs rs')","proofString":"apply agree_val_reg_gen; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs') : Val.inject F rs # r rs' # (sreg ctx r).","conclusion":"Val.inject F rs # r rs' # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs')","proofString":"exploit agree_val_reg_gen; eauto.\ninstantiate (1 := r).\nintros [[A B] | [A B]].\nrewrite B; auto.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs') : val_reg_charact F ctx rs' rs # r r -> Val.inject F rs # r rs' # (sreg ctx r).","conclusion":"val_reg_charact F ctx rs' rs # r r -> Val.inject F rs # r rs' # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs')","proofString":"intros [[A B] | [A B]].\nrewrite B; auto.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs') (A : Plt (mreg ctx) r) (B : rs # r = Vundef) : Val.inject F rs # r rs' # (sreg ctx r).","conclusion":"Val.inject F rs # r rs' # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs') (A : Plt (mreg ctx) r) (B : rs # r = Vundef)","proofString":"rewrite B; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs') (A : Ple r (mreg ctx)) (B : Val.inject F rs # r rs' # (sreg ctx r)) : Val.inject F rs # r rs' # (sreg ctx r).","conclusion":"Val.inject F rs # r rs' # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : agree_regs F ctx rs rs') (A : Ple r (mreg ctx)) (B : Val.inject F rs # r rs' # (sreg ctx r))","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (H : agree_regs F ctx rs rs') : Val.inject_list F nil nil.","conclusion":"Val.inject_list F nil nil","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (H : agree_regs F ctx rs rs')","proofString":"constructor."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (a : positive) (rl : list positive) (IHrl : agree_regs F ctx rs rs' -> Val.inject_list F rs ## rl rs' ## (sregs ctx rl)) (H : agree_regs F ctx rs rs') : Val.inject_list F (rs # a :: rs ## rl)\n  (rs' # (sreg ctx a) :: rs' ## (sregs ctx rl)).","conclusion":"Val.inject_list F (rs # a :: rs ## rl)\n  (rs' # (sreg ctx a) :: rs' ## (sregs ctx rl))","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (a : positive) (rl : list positive) (IHrl : agree_regs F ctx rs rs' -> Val.inject_list F rs ## rl rs' ## (sregs ctx rl)) (H : agree_regs F ctx rs rs')","proofString":"constructor; auto.\napply agree_val_reg; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (a : positive) (rl : list positive) (IHrl : agree_regs F ctx rs rs' -> Val.inject_list F rs ## rl rs' ## (sregs ctx rl)) (H : agree_regs F ctx rs rs') : Val.inject F rs # a rs' # (sreg ctx a).","conclusion":"Val.inject F rs # a rs' # (sreg ctx a)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (a : positive) (rl : list positive) (IHrl : agree_regs F ctx rs rs' -> Val.inject_list F rs ## rl rs' ## (sregs ctx rl)) (H : agree_regs F ctx rs rs')","proofString":"apply agree_val_reg; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : (forall r0 : positive,\n Ple r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef)) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) : (forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- v) # r0 (rs' # (sreg ctx r) <- v') # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- v) # r0 = Vundef).","conclusion":"(forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- v) # r0 (rs' # (sreg ctx r) <- v') # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- v) # r0 = Vundef)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : (forall r0 : positive,\n Ple r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef)) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx))","proofString":"destruct H.\nsplit; intros.\nrepeat rewrite Regmap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nrewrite peq_true.\nauto.\nrewrite peq_false.\nauto.\napply shiftpos_diff; auto.\nrewrite Regmap.gso.\nauto.\nextlia."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H2 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) : (forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- v) # r0 (rs' # (sreg ctx r) <- v') # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- v) # r0 = Vundef).","conclusion":"(forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- v) # r0 (rs' # (sreg ctx r) <- v') # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- v) # r0 = Vundef)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H2 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx))","proofString":"split; intros.\nrepeat rewrite Regmap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nrewrite peq_true.\nauto.\nrewrite peq_false.\nauto.\napply shiftpos_diff; auto.\nrewrite Regmap.gso.\nauto.\nextlia."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) : Val.inject F (rs # r <- v) # r0 (rs' # (sreg ctx r) <- v') # (sreg ctx r0).","conclusion":"Val.inject F (rs # r <- v) # r0 (rs' # (sreg ctx r) <- v') # (sreg ctx r0)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx))","proofString":"repeat rewrite Regmap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nrewrite peq_true.\nauto.\nrewrite peq_false.\nauto.\napply shiftpos_diff; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) : Val.inject F (if peq r0 r then v else rs # r0)\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0)).","conclusion":"Val.inject F (if peq r0 r then v else rs # r0)\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0))","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx))","proofString":"destruct (peq r0 r).\nsubst r0.\nrewrite peq_true.\nauto.\nrewrite peq_false.\nauto.\napply shiftpos_diff; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) (e : r0 = r) : Val.inject F v\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0)).","conclusion":"Val.inject F v\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0))","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) (e : r0 = r)","proofString":"subst r0.\nrewrite peq_true.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H2 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : Val.inject F v v') (H1 H3 : Ple r (mreg ctx)) : Val.inject F v\n  (if peq (sreg ctx r) (sreg ctx r) then v' else rs' # (sreg ctx r)).","conclusion":"Val.inject F v\n  (if peq (sreg ctx r) (sreg ctx r) then v' else rs' # (sreg ctx r))","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H2 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : Val.inject F v v') (H1 H3 : Ple r (mreg ctx))","proofString":"rewrite peq_true.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H2 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : Val.inject F v v') (H1 H3 : Ple r (mreg ctx)) : Val.inject F v v'.","conclusion":"Val.inject F v v'","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H2 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : Val.inject F v v') (H1 H3 : Ple r (mreg ctx))","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) (n : r0 <> r) : Val.inject F rs # r0\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0)).","conclusion":"Val.inject F rs # r0\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0))","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) (n : r0 <> r)","proofString":"rewrite peq_false.\nauto.\napply shiftpos_diff; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) (n : r0 <> r) : Val.inject F rs # r0 rs' # (sreg ctx r0).","conclusion":"Val.inject F rs # r0 rs' # (sreg ctx r0)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) (n : r0 <> r)","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) (n : r0 <> r) : sreg ctx r0 <> sreg ctx r.","conclusion":"sreg ctx r0 <> sreg ctx r","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Ple r0 (mreg ctx)) (n : r0 <> r)","proofString":"apply shiftpos_diff; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Plt (mreg ctx) r0) : (rs # r <- v) # r0 = Vundef.","conclusion":"(rs # r <- v) # r0 = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Plt (mreg ctx) r0)","proofString":"rewrite Regmap.gso.\nauto.\nextlia."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Plt (mreg ctx) r0) : rs # r0 = Vundef.","conclusion":"rs # r0 = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Plt (mreg ctx) r0)","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Plt (mreg ctx) r0) : r0 <> r.","conclusion":"r0 <> r","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H2 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (H0 : Val.inject F v v') (H1 : Ple r (mreg ctx)) (r0 : positive) (H3 : Plt (mreg ctx) r0)","proofString":"extlia."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : (forall r0 : positive,\n Ple r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef)) : (forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- Vundef) # r0\n   (rs' # (sreg ctx r) <- v') # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- Vundef) # r0 = Vundef).","conclusion":"(forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- Vundef) # r0\n   (rs' # (sreg ctx r) <- v') # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- Vundef) # r0 = Vundef)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : (forall r0 : positive,\n Ple r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef))","proofString":"destruct H.\nsplit; intros.\nrepeat rewrite Regmap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nrewrite peq_true.\nauto.\nrewrite peq_false.\nauto.\napply shiftpos_diff; auto.\nrewrite Regmap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) : (forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- Vundef) # r0\n   (rs' # (sreg ctx r) <- v') # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- Vundef) # r0 = Vundef).","conclusion":"(forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- Vundef) # r0\n   (rs' # (sreg ctx r) <- v') # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- Vundef) # r0 = Vundef)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef)","proofString":"split; intros.\nrepeat rewrite Regmap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nrewrite peq_true.\nauto.\nrewrite peq_false.\nauto.\napply shiftpos_diff; auto.\nrewrite Regmap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) : Val.inject F (rs # r <- Vundef) # r0\n  (rs' # (sreg ctx r) <- v') # (sreg ctx r0).","conclusion":"Val.inject F (rs # r <- Vundef) # r0\n  (rs' # (sreg ctx r) <- v') # (sreg ctx r0)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx))","proofString":"repeat rewrite Regmap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nrewrite peq_true.\nauto.\nrewrite peq_false.\nauto.\napply shiftpos_diff; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) : Val.inject F (if peq r0 r then Vundef else rs # r0)\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0)).","conclusion":"Val.inject F (if peq r0 r then Vundef else rs # r0)\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0))","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx))","proofString":"destruct (peq r0 r).\nsubst r0.\nrewrite peq_true.\nauto.\nrewrite peq_false.\nauto.\napply shiftpos_diff; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (e : r0 = r) : Val.inject F Vundef\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0)).","conclusion":"Val.inject F Vundef\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0))","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (e : r0 = r)","proofString":"subst r0.\nrewrite peq_true.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H1 : Ple r (mreg ctx)) : Val.inject F Vundef\n  (if peq (sreg ctx r) (sreg ctx r) then v' else rs' # (sreg ctx r)).","conclusion":"Val.inject F Vundef\n  (if peq (sreg ctx r) (sreg ctx r) then v' else rs' # (sreg ctx r))","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H1 : Ple r (mreg ctx))","proofString":"rewrite peq_true.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H1 : Ple r (mreg ctx)) : Val.inject F Vundef v'.","conclusion":"Val.inject F Vundef v'","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H1 : Ple r (mreg ctx))","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (n : r0 <> r) : Val.inject F rs # r0\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0)).","conclusion":"Val.inject F rs # r0\n  (if peq (sreg ctx r0) (sreg ctx r) then v' else rs' # (sreg ctx r0))","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (n : r0 <> r)","proofString":"rewrite peq_false.\nauto.\napply shiftpos_diff; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (n : r0 <> r) : Val.inject F rs # r0 rs' # (sreg ctx r0).","conclusion":"Val.inject F rs # r0 rs' # (sreg ctx r0)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (n : r0 <> r)","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (n : r0 <> r) : sreg ctx r0 <> sreg ctx r.","conclusion":"sreg ctx r0 <> sreg ctx r","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (n : r0 <> r)","proofString":"apply shiftpos_diff; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Plt (mreg ctx) r0) : (rs # r <- Vundef) # r0 = Vundef.","conclusion":"(rs # r <- Vundef) # r0 = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Plt (mreg ctx) r0)","proofString":"rewrite Regmap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Plt (mreg ctx) r0) : (if peq r0 r then Vundef else rs # r0) = Vundef.","conclusion":"(if peq r0 r then Vundef else rs # r0) = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (v' : val) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Plt (mreg ctx) r0)","proofString":"destruct (peq r0 r); auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : (forall r0 : positive,\n Ple r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef)) : (forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- Vundef) # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- Vundef) # r0 = Vundef).","conclusion":"(forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- Vundef) # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- Vundef) # r0 = Vundef)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : (forall r0 : positive,\n Ple r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef))","proofString":"destruct H.\nsplit; intros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nauto.\nauto.\nrewrite Regmap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) : (forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- Vundef) # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- Vundef) # r0 = Vundef).","conclusion":"(forall r0 : positive,\n Ple r0 (mreg ctx) ->\n Val.inject F (rs # r <- Vundef) # r0 rs' # (sreg ctx r0)) /\\\n(forall r0 : positive, Plt (mreg ctx) r0 -> (rs # r <- Vundef) # r0 = Vundef)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef)","proofString":"split; intros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nauto.\nauto.\nrewrite Regmap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) : Val.inject F (rs # r <- Vundef) # r0 rs' # (sreg ctx r0).","conclusion":"Val.inject F (rs # r <- Vundef) # r0 rs' # (sreg ctx r0)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx))","proofString":"rewrite Regmap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nauto.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) : Val.inject F (if peq r0 r then Vundef else rs # r0) rs' # (sreg ctx r0).","conclusion":"Val.inject F (if peq r0 r then Vundef else rs # r0) rs' # (sreg ctx r0)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx))","proofString":"destruct (peq r0 r).\nsubst r0.\nauto.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (e : r0 = r) : Val.inject F Vundef rs' # (sreg ctx r0).","conclusion":"Val.inject F Vundef rs' # (sreg ctx r0)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (e : r0 = r)","proofString":"subst r0.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H1 : Ple r (mreg ctx)) : Val.inject F Vundef rs' # (sreg ctx r).","conclusion":"Val.inject F Vundef rs' # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs' # (sreg ctx r0)) (H0 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H1 : Ple r (mreg ctx))","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (n : r0 <> r) : Val.inject F rs # r0 rs' # (sreg ctx r0).","conclusion":"Val.inject F rs # r0 rs' # (sreg ctx r0)","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Ple r0 (mreg ctx)) (n : r0 <> r)","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Plt (mreg ctx) r0) : (rs # r <- Vundef) # r0 = Vundef.","conclusion":"(rs # r <- Vundef) # r0 = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Plt (mreg ctx) r0)","proofString":"rewrite Regmap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Plt (mreg ctx) r0) : (if peq r0 r then Vundef else rs # r0) = Vundef.","conclusion":"(if peq r0 r then Vundef else rs # r0) = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs rs' : regset) (r : positive) (H : forall r1 : positive,\nPle r1 (mreg ctx) -> Val.inject F rs # r1 rs' # (sreg ctx r1)) (H0 : forall r1 : positive, Plt (mreg ctx) r1 -> rs # r1 = Vundef) (r0 : positive) (H1 : Plt (mreg ctx) r0)","proofString":"destruct (peq r0 r); auto."},{"statement":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : (forall r : positive,\n Ple r (mreg ctx) -> Val.inject F rs # r rs1 # (sreg ctx r)) /\\\n(forall r : positive, Plt (mreg ctx) r -> rs # r = Vundef)) (H0 : forall r : positive,\nPle (dreg ctx) r -> Plt r (dreg ctx + mreg ctx) -> rs2 # r = rs1 # r) : (forall r : positive,\n Ple r (mreg ctx) -> Val.inject F rs # r rs2 # (sreg ctx r)) /\\\n(forall r : positive, Plt (mreg ctx) r -> rs # r = Vundef).","conclusion":"(forall r : positive,\n Ple r (mreg ctx) -> Val.inject F rs # r rs2 # (sreg ctx r)) /\\\n(forall r : positive, Plt (mreg ctx) r -> rs # r = Vundef)","hypotheses":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : (forall r : positive,\n Ple r (mreg ctx) -> Val.inject F rs # r rs1 # (sreg ctx r)) /\\\n(forall r : positive, Plt (mreg ctx) r -> rs # r = Vundef)) (H0 : forall r : positive,\nPle (dreg ctx) r -> Plt r (dreg ctx + mreg ctx) -> rs2 # r = rs1 # r)","proofString":"destruct H.\nsplit; intros.\nrewrite H0.\nauto.\napply shiftpos_above.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nextlia.\napply H1; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r : positive,\nPle r (mreg ctx) -> Val.inject F rs # r rs1 # (sreg ctx r)) (H1 : forall r : positive, Plt (mreg ctx) r -> rs # r = Vundef) (H0 : forall r : positive,\nPle (dreg ctx) r -> Plt r (dreg ctx + mreg ctx) -> rs2 # r = rs1 # r) : (forall r : positive,\n Ple r (mreg ctx) -> Val.inject F rs # r rs2 # (sreg ctx r)) /\\\n(forall r : positive, Plt (mreg ctx) r -> rs # r = Vundef).","conclusion":"(forall r : positive,\n Ple r (mreg ctx) -> Val.inject F rs # r rs2 # (sreg ctx r)) /\\\n(forall r : positive, Plt (mreg ctx) r -> rs # r = Vundef)","hypotheses":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r : positive,\nPle r (mreg ctx) -> Val.inject F rs # r rs1 # (sreg ctx r)) (H1 : forall r : positive, Plt (mreg ctx) r -> rs # r = Vundef) (H0 : forall r : positive,\nPle (dreg ctx) r -> Plt r (dreg ctx + mreg ctx) -> rs2 # r = rs1 # r)","proofString":"split; intros.\nrewrite H0.\nauto.\napply shiftpos_above.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nextlia.\napply H1; auto."},{"statement":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Ple r (mreg ctx)) : Val.inject F rs # r rs2 # (sreg ctx r).","conclusion":"Val.inject F rs # r rs2 # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Ple r (mreg ctx))","proofString":"rewrite H0.\nauto.\napply shiftpos_above.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nextlia."},{"statement":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Ple r (mreg ctx)) : Val.inject F rs # r rs1 # (sreg ctx r).","conclusion":"Val.inject F rs # r rs1 # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Ple r (mreg ctx))","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Ple r (mreg ctx)) : Ple (dreg ctx) (sreg ctx r).","conclusion":"Ple (dreg ctx) (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Ple r (mreg ctx))","proofString":"apply shiftpos_above."},{"statement":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Ple r (mreg ctx)) : Plt (sreg ctx r) (dreg ctx + mreg ctx).","conclusion":"Plt (sreg ctx r) (dreg ctx + mreg ctx)","hypotheses":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Ple r (mreg ctx))","proofString":"eapply Pos.lt_le_trans.\napply shiftpos_below.\nextlia."},{"statement":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Plt (mreg ctx) r) : rs # r = Vundef.","conclusion":"rs # r = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs rs1 : regset) (rs2 : Regmap.t val) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs # r0 rs1 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs # r0 = Vundef) (H0 : forall r0 : positive,\nPle (dreg ctx) r0 -> Plt r0 (dreg ctx + mreg ctx) -> rs2 # r0 = rs1 # r0) (r : positive) (H2 : Plt (mreg ctx) r)","proofString":"apply H1; auto."},{"statement":"(F : meminj) (ctx : context) (rs1 rs2 : regset) (F' : meminj) (H : agree_regs F ctx rs1 rs2) (H0 : inject_incr F F') : agree_regs F' ctx rs1 rs2.","conclusion":"agree_regs F' ctx rs1 rs2","hypotheses":"(F : meminj) (ctx : context) (rs1 rs2 : regset) (F' : meminj) (H : agree_regs F ctx rs1 rs2) (H0 : inject_incr F F')","proofString":"destruct H.\nsplit; intros.\neauto.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs1 rs2 : regset) (F' : meminj) (H : forall r : positive,\nPle r (mreg ctx) -> Val.inject F rs1 # r rs2 # (sreg ctx r)) (H1 : forall r : positive, Plt (mreg ctx) r -> rs1 # r = Vundef) (H0 : inject_incr F F') : agree_regs F' ctx rs1 rs2.","conclusion":"agree_regs F' ctx rs1 rs2","hypotheses":"(F : meminj) (ctx : context) (rs1 rs2 : regset) (F' : meminj) (H : forall r : positive,\nPle r (mreg ctx) -> Val.inject F rs1 # r rs2 # (sreg ctx r)) (H1 : forall r : positive, Plt (mreg ctx) r -> rs1 # r = Vundef) (H0 : inject_incr F F')","proofString":"split; intros.\neauto.\nauto."},{"statement":"(F : meminj) (ctx : context) (rs1 rs2 : regset) (F' : meminj) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs1 # r0 rs2 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs1 # r0 = Vundef) (H0 : inject_incr F F') (r : positive) (H2 : Ple r (mreg ctx)) : Val.inject F' rs1 # r rs2 # (sreg ctx r).","conclusion":"Val.inject F' rs1 # r rs2 # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs1 rs2 : regset) (F' : meminj) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs1 # r0 rs2 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs1 # r0 = Vundef) (H0 : inject_incr F F') (r : positive) (H2 : Ple r (mreg ctx))","proofString":"eauto."},{"statement":"(F : meminj) (ctx : context) (rs1 rs2 : regset) (F' : meminj) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs1 # r0 rs2 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs1 # r0 = Vundef) (H0 : inject_incr F F') (r : positive) (H2 : Plt (mreg ctx) r) : rs1 # r = Vundef.","conclusion":"rs1 # r = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs1 rs2 : regset) (F' : meminj) (H : forall r0 : positive,\nPle r0 (mreg ctx) -> Val.inject F rs1 # r0 rs2 # (sreg ctx r0)) (H1 : forall r0 : positive, Plt (mreg ctx) r0 -> rs1 # r0 = Vundef) (H0 : inject_incr F F') (r : positive) (H2 : Plt (mreg ctx) r)","proofString":"auto."},{"statement":"(F : meminj) (ctx : context) (rs : regset) (r : positive) (H : Ple r (mreg ctx)) : Val.inject F (Regmap.init Vundef) # r rs # (sreg ctx r).","conclusion":"Val.inject F (Regmap.init Vundef) # r rs # (sreg ctx r)","hypotheses":"(F : meminj) (ctx : context) (rs : regset) (r : positive) (H : Ple r (mreg ctx))","proofString":"rewrite Regmap.gi; auto."},{"statement":"(F : meminj) (ctx : context) (rs : regset) (r : positive) (H : Plt (mreg ctx) r) : (Regmap.init Vundef) # r = Vundef.","conclusion":"(Regmap.init Vundef) # r = Vundef","hypotheses":"(F : meminj) (ctx : context) (rs : regset) (r : positive) (H : Plt (mreg ctx) r)","proofString":"rewrite Regmap.gi; auto."},{"statement":"(F : meminj) (ctx : context) (vl vl' : list val) (H : Val.inject_list F vl vl') (H0 : forall r : positive, False -> Ple r (mreg ctx)) : agree_regs F ctx (Regmap.init Vundef) (Regmap.init Vundef).","conclusion":"agree_regs F ctx (Regmap.init Vundef) (Regmap.init Vundef)","hypotheses":"(F : meminj) (ctx : context) (vl vl' : list val) (H : Val.inject_list F vl vl') (H0 : forall r : positive, False -> Ple r (mreg ctx))","proofString":"apply agree_regs_init."},{"statement":"(F : meminj) (ctx : context) (a : positive) (rl : list positive) (IHrl : forall vl0 vl'0 : list val,\nVal.inject_list F vl0 vl'0 ->\n(forall r : positive, In r rl -> Ple r (mreg ctx)) ->\nagree_regs F ctx (init_regs vl0 rl) (init_regs vl'0 (sregs ctx rl))) (vl vl' : list val) (H : Val.inject_list F vl vl') (H0 : forall r : positive, a = r \\/ In r rl -> Ple r (mreg ctx)) : agree_regs F ctx\n  match vl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs rl) # a <- v1\n  end\n  match vl' with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs (sregs ctx rl)) # (sreg ctx a) <- v1\n  end.","conclusion":"agree_regs F ctx\n  match vl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs rl) # a <- v1\n  end\n  match vl' with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs (sregs ctx rl)) # (sreg ctx a) <- v1\n  end","hypotheses":"(F : meminj) (ctx : context) (a : positive) (rl : list positive) (IHrl : forall vl0 vl'0 : list val,\nVal.inject_list F vl0 vl'0 ->\n(forall r : positive, In r rl -> Ple r (mreg ctx)) ->\nagree_regs F ctx (init_regs vl0 rl) (init_regs vl'0 (sregs ctx rl))) (vl vl' : list val) (H : Val.inject_list F vl vl') (H0 : forall r : positive, a = r \\/ In r rl -> Ple r (mreg ctx))","proofString":"inv H.\napply agree_regs_init.\napply agree_set_reg; auto."},{"statement":"(F : meminj) (ctx : context) (a : positive) (rl : list positive) (IHrl : forall vl vl' : list val,\nVal.inject_list F vl vl' ->\n(forall r : positive, In r rl -> Ple r (mreg ctx)) ->\nagree_regs F ctx (init_regs vl rl) (init_regs vl' (sregs ctx rl))) (H0 : forall r : positive, a = r \\/ In r rl -> Ple r (mreg ctx)) : agree_regs F ctx (Regmap.init Vundef) (Regmap.init Vundef).","conclusion":"agree_regs F ctx (Regmap.init Vundef) (Regmap.init Vundef)","hypotheses":"(F : meminj) (ctx : context) (a : positive) (rl : list positive) (IHrl : forall vl vl' : list val,\nVal.inject_list F vl vl' ->\n(forall r : positive, In r rl -> Ple r (mreg ctx)) ->\nagree_regs F ctx (init_regs vl rl) (init_regs vl' (sregs ctx rl))) (H0 : forall r : positive, a = r \\/ In r rl -> Ple r (mreg ctx))","proofString":"apply agree_regs_init."},{"statement":"(F : meminj) (ctx : context) (a : positive) (rl : list positive) (IHrl : forall vl vl' : list val,\nVal.inject_list F vl vl' ->\n(forall r : positive, In r rl -> Ple r (mreg ctx)) ->\nagree_regs F ctx (init_regs vl rl) (init_regs vl' (sregs ctx rl))) (H0 : forall r : positive, a = r \\/ In r rl -> Ple r (mreg ctx)) (v v' : val) (vl0 vl'0 : list val) (H1 : Val.inject F v v') (H2 : Val.inject_list F vl0 vl'0) : agree_regs F ctx (init_regs vl0 rl) # a <- v\n  (init_regs vl'0 (sregs ctx rl)) # (sreg ctx a) <- v'.","conclusion":"agree_regs F ctx (init_regs vl0 rl) # a <- v\n  (init_regs vl'0 (sregs ctx rl)) # (sreg ctx a) <- v'","hypotheses":"(F : meminj) (ctx : context) (a : positive) (rl : list positive) (IHrl : forall vl vl' : list val,\nVal.inject_list F vl vl' ->\n(forall r : positive, In r rl -> Ple r (mreg ctx)) ->\nagree_regs F ctx (init_regs vl rl) (init_regs vl' (sregs ctx rl))) (H0 : forall r : positive, a = r \\/ In r rl -> Ple r (mreg ctx)) (v v' : val) (vl0 vl'0 : list val) (H1 : Val.inject F v v') (H2 : Val.inject_list F vl0 vl'0)","proofString":"apply agree_set_reg; auto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (rsrcs : list reg) (vl : list val) (pc1 pc2 : node) (rs1 : regset) (H0 : tr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) nil pc2) (H1 : forall r : reg, False -> Ple r (mreg ctx2)) (H2 : list_forall2 (val_reg_charact F ctx1 rs1) vl rsrcs) : exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (Regmap.init Vundef) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r).","conclusion":"exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (Regmap.init Vundef) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (rsrcs : list reg) (vl : list val) (pc1 pc2 : node) (rs1 : regset) (H0 : tr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) nil pc2) (H1 : forall r : reg, False -> Ple r (mreg ctx2)) (H2 : list_forall2 (val_reg_charact F ctx1 rs1) vl rsrcs)","proofString":"inv H0.\nexists rs1; split.\napply star_refl.\nsplit.\napply agree_regs_init.\nauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs0 : list reg) (vl0 : list val) (pc0 pc3 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs0) (sregs ctx2 rdsts) pc3 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl0 rsrcs0 ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc3 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl0 rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (rsrcs : list reg) (vl : list val) (pc1 pc2 : node) (rs1 : regset) (H0 : tr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sreg ctx2 a :: sregs ctx2 rdsts)\n  pc2) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : list_forall2 (val_reg_charact F ctx1 rs1) vl rsrcs) : exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2\n    match vl with\n    | nil => Regmap.init Vundef\n    | v1 :: vs => (init_regs vs rdsts) # a <- v1\n    end rs2 /\\ (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r).","conclusion":"exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2\n    match vl with\n    | nil => Regmap.init Vundef\n    | v1 :: vs => (init_regs vs rdsts) # a <- v1\n    end rs2 /\\ (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs0 : list reg) (vl0 : list val) (pc0 pc3 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs0) (sregs ctx2 rdsts) pc3 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl0 rsrcs0 ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc3 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl0 rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (rsrcs : list reg) (vl : list val) (pc1 pc2 : node) (rs1 : regset) (H0 : tr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sreg ctx2 a :: sregs ctx2 rdsts)\n  pc2) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : list_forall2 (val_reg_charact F ctx1 rs1) vl rsrcs)","proofString":"inv H2.\ninv H0.\nexists rs1; split.\napply star_refl.\nsplit.\napply agree_regs_init.\nauto.\nsimpl in H0.\ninv H0.\nexploit IHrdsts; eauto.\nintros [rs2 [A [B C]]].\nexists (rs2#(sreg ctx2 a) <- (rs2#(sreg ctx1 b1))).\nsplit.\neapply star_right.\neauto.\neapply exec_Iop; eauto.\ntraceEq.\nsplit.\ndestruct H3 as [[P Q] | [P Q]].\nsubst a1.\neapply agree_set_reg_undef; eauto.\neapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto.\nintros.\nrewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto.\ndestruct H2; discriminate."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc3 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc3 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc3 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (H0 : tr_moves (fn_code f) pc1 (sregs ctx1 nil) (sreg ctx2 a :: sregs ctx2 rdsts)\n  pc2) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) : exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (Regmap.init Vundef) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r).","conclusion":"exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (Regmap.init Vundef) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc3 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc3 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc3 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (H0 : tr_moves (fn_code f) pc1 (sregs ctx1 nil) (sreg ctx2 a :: sregs ctx2 rdsts)\n  pc2) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2))","proofString":"inv H0.\nexists rs1; split.\napply star_refl.\nsplit.\napply agree_regs_init.\nauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil) : exists rs2 : regset,\n  star step tge (State stk f sp pc2 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (Regmap.init Vundef) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r).","conclusion":"exists rs2 : regset,\n  star step tge (State stk f sp pc2 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (Regmap.init Vundef) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil)","proofString":"exists rs1; split.\napply star_refl.\nsplit.\napply agree_regs_init.\nauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil) : star step tge (State stk f sp pc2 rs1 m) E0 (State stk f sp pc2 rs1 m).","conclusion":"star step tge (State stk f sp pc2 rs1 m) E0 (State stk f sp pc2 rs1 m)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil)","proofString":"apply star_refl."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil) : agree_regs F ctx2 (Regmap.init Vundef) rs1 /\\\n(forall r : positive, Plt r (dreg ctx2) -> rs1 # r = rs1 # r).","conclusion":"agree_regs F ctx2 (Regmap.init Vundef) rs1 /\\\n(forall r : positive, Plt r (dreg ctx2) -> rs1 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil)","proofString":"split.\napply agree_regs_init.\nauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil) : agree_regs F ctx2 (Regmap.init Vundef) rs1.","conclusion":"agree_regs F ctx2 (Regmap.init Vundef) rs1","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil)","proofString":"apply agree_regs_init."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil) : forall r : positive, Plt r (dreg ctx2) -> rs1 # r = rs1 # r.","conclusion":"forall r : positive, Plt r (dreg ctx2) -> rs1 # r = rs1 # r","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (H2 : sregs ctx1 nil = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil)","proofString":"auto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc3 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc3 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc3 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H0 : tr_moves (fn_code f) pc1 (sregs ctx1 (b1 :: bl))\n  (sreg ctx2 a :: sregs ctx2 rdsts) pc2) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) : exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r).","conclusion":"exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc3 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc3 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc3 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H0 : tr_moves (fn_code f) pc1 (sregs ctx1 (b1 :: bl))\n  (sreg ctx2 a :: sregs ctx2 rdsts) pc2) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl)","proofString":"simpl in H0.\ninv H0.\nexploit IHrdsts; eauto.\nintros [rs2 [A [B C]]].\nexists (rs2#(sreg ctx2 a) <- (rs2#(sreg ctx1 b1))).\nsplit.\neapply star_right.\neauto.\neapply exec_Iop; eauto.\ntraceEq.\nsplit.\ndestruct H3 as [[P Q] | [P Q]].\nsubst a1.\neapply agree_set_reg_undef; eauto.\neapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto.\nintros.\nrewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto.\ndestruct H2; discriminate."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc3 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc3 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc3 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H0 : tr_moves (fn_code f) pc1 (sreg ctx1 b1 :: sregs ctx1 bl)\n  (sreg ctx2 a :: sregs ctx2 rdsts) pc2) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) : exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r).","conclusion":"exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc3 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc3 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc3 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H0 : tr_moves (fn_code f) pc1 (sreg ctx1 b1 :: sregs ctx1 bl)\n  (sreg ctx2 a :: sregs ctx2 rdsts) pc2) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl)","proofString":"inv H0.\nexploit IHrdsts; eauto.\nintros [rs2 [A [B C]]].\nexists (rs2#(sreg ctx2 a) <- (rs2#(sreg ctx1 b1))).\nsplit.\neapply star_right.\neauto.\neapply exec_Iop; eauto.\ntraceEq.\nsplit.\ndestruct H3 as [[P Q] | [P Q]].\nsubst a1.\neapply agree_set_reg_undef; eauto.\neapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto.\nintros.\nrewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto.\ndestruct H2; discriminate."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) : exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r).","conclusion":"exists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2))","proofString":"exploit IHrdsts; eauto.\nintros [rs2 [A [B C]]].\nexists (rs2#(sreg ctx2 a) <- (rs2#(sreg ctx1 b1))).\nsplit.\neapply star_right.\neauto.\neapply exec_Iop; eauto.\ntraceEq.\nsplit.\ndestruct H3 as [[P Q] | [P Q]].\nsubst a1.\neapply agree_set_reg_undef; eauto.\neapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto.\nintros.\nrewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) : (exists rs2 : regset,\n   star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m) /\\\n   agree_regs F ctx2 (init_regs al rdsts) rs2 /\\\n   (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)) ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r).","conclusion":"(exists rs2 : regset,\n   star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m) /\\\n   agree_regs F ctx2 (init_regs al rdsts) rs2 /\\\n   (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)) ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2))","proofString":"intros [rs2 [A [B C]]].\nexists (rs2#(sreg ctx2 a) <- (rs2#(sreg ctx1 b1))).\nsplit.\neapply star_right.\neauto.\neapply exec_Iop; eauto.\ntraceEq.\nsplit.\ndestruct H3 as [[P Q] | [P Q]].\nsubst a1.\neapply agree_set_reg_undef; eauto.\neapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto.\nintros.\nrewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : exists rs0 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs0 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs0 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs0 # r = rs1 # r).","conclusion":"exists rs0 : regset,\n  star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc2 rs0 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs0 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs0 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"exists (rs2#(sreg ctx2 a) <- (rs2#(sreg ctx1 b1))).\nsplit.\neapply star_right.\neauto.\neapply exec_Iop; eauto.\ntraceEq.\nsplit.\ndestruct H3 as [[P Q] | [P Q]].\nsubst a1.\neapply agree_set_reg_undef; eauto.\neapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto.\nintros.\nrewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : star step tge (State stk f sp pc1 rs1 m) E0\n  (State stk f sp pc2 rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)) m) /\\\nagree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)) /\\\n(forall r : positive,\n Plt r (dreg ctx2) ->\n (rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))) # r = rs1 # r).","conclusion":"star step tge (State stk f sp pc1 rs1 m) E0\n  (State stk f sp pc2 rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)) m) /\\\nagree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)) /\\\n(forall r : positive,\n Plt r (dreg ctx2) ->\n (rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))) # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"split.\neapply star_right.\neauto.\neapply exec_Iop; eauto.\ntraceEq.\nsplit.\ndestruct H3 as [[P Q] | [P Q]].\nsubst a1.\neapply agree_set_reg_undef; eauto.\neapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto.\nintros.\nrewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : star step tge (State stk f sp pc1 rs1 m) E0\n  (State stk f sp pc2 rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)) m).","conclusion":"star step tge (State stk f sp pc1 rs1 m) E0\n  (State stk f sp pc2 rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)) m)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"eapply star_right.\neauto.\neapply exec_Iop; eauto.\ntraceEq."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : agree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)) /\\\n(forall r : positive,\n Plt r (dreg ctx2) ->\n (rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))) # r = rs1 # r).","conclusion":"agree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)) /\\\n(forall r : positive,\n Plt r (dreg ctx2) ->\n (rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))) # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"split.\ndestruct H3 as [[P Q] | [P Q]].\nsubst a1.\neapply agree_set_reg_undef; eauto.\neapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto.\nintros.\nrewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : agree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)).","conclusion":"agree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"destruct H3 as [[P Q] | [P Q]].\nsubst a1.\neapply agree_set_reg_undef; eauto.\neapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (P : Plt (mreg ctx1) b1) (Q : a1 = Vundef) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : agree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)).","conclusion":"agree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (P : Plt (mreg ctx1) b1) (Q : a1 = Vundef) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"subst a1.\neapply agree_set_reg_undef; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (al : list val) (P : Plt (mreg ctx1) b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : agree_regs F ctx2 (init_regs al rdsts) # a <- Vundef\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)).","conclusion":"agree_regs F ctx2 (init_regs al rdsts) # a <- Vundef\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (al : list val) (P : Plt (mreg ctx1) b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"eapply agree_set_reg_undef; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (P : Ple b1 (mreg ctx1)) (Q : Val.inject F a1 rs1 # (sreg ctx1 b1)) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : agree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1)).","conclusion":"agree_regs F ctx2 (init_regs al rdsts) # a <- a1\n  rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (P : Ple b1 (mreg ctx1)) (Q : Val.inject F a1 rs1 # (sreg ctx1 b1)) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"eapply agree_set_reg; eauto.\nrewrite C; auto.\napply context_below_lt; auto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (P : Ple b1 (mreg ctx1)) (Q : Val.inject F a1 rs1 # (sreg ctx1 b1)) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : Val.inject F a1 rs2 # (sreg ctx1 b1).","conclusion":"Val.inject F a1 rs2 # (sreg ctx1 b1)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (P : Ple b1 (mreg ctx1)) (Q : Val.inject F a1 rs1 # (sreg ctx1 b1)) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"rewrite C; auto.\napply context_below_lt; auto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (P : Ple b1 (mreg ctx1)) (Q : Val.inject F a1 rs1 # (sreg ctx1 b1)) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : Plt (sreg ctx1 b1) (dreg ctx2).","conclusion":"Plt (sreg ctx1 b1) (dreg ctx2)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (P : Ple b1 (mreg ctx1)) (Q : Val.inject F a1 rs1 # (sreg ctx1 b1)) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"apply context_below_lt; auto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r) : forall r : positive,\nPlt r (dreg ctx2) ->\n(rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))) # r = rs1 # r.","conclusion":"forall r : positive,\nPlt r (dreg ctx2) ->\n(rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))) # r = rs1 # r","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs3 # r = rs0 # r)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","proofString":"intros.\nrewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r0 : reg, In r0 rdsts -> Ple r0 (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r0 : positive, Plt r0 (dreg ctx2) -> rs3 # r0 = rs0 # r0)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r0 : reg, a = r0 \\/ In r0 rdsts -> Ple r0 (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r0 : positive, Plt r0 (dreg ctx2) -> rs2 # r0 = rs1 # r0) (r : positive) (H0 : Plt r (dreg ctx2)) : (rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))) # r = rs1 # r.","conclusion":"(rs2 # (sreg ctx2 a) <- (rs2 # (sreg ctx1 b1))) # r = rs1 # r","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r0 : reg, In r0 rdsts -> Ple r0 (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r0 : positive, Plt r0 (dreg ctx2) -> rs3 # r0 = rs0 # r0)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r0 : reg, a = r0 \\/ In r0 rdsts -> Ple r0 (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r0 : positive, Plt r0 (dreg ctx2) -> rs2 # r0 = rs1 # r0) (r : positive) (H0 : Plt r (dreg ctx2))","proofString":"rewrite Regmap.gso.\nauto.\napply not_eq_sym.\neapply sreg_below_diff; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r0 : reg, In r0 rdsts -> Ple r0 (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r0 : positive, Plt r0 (dreg ctx2) -> rs3 # r0 = rs0 # r0)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r0 : reg, a = r0 \\/ In r0 rdsts -> Ple r0 (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r0 : positive, Plt r0 (dreg ctx2) -> rs2 # r0 = rs1 # r0) (r : positive) (H0 : Plt r (dreg ctx2)) : rs2 # r = rs1 # r.","conclusion":"rs2 # r = rs1 # r","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r0 : reg, In r0 rdsts -> Ple r0 (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r0 : positive, Plt r0 (dreg ctx2) -> rs3 # r0 = rs0 # r0)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r0 : reg, a = r0 \\/ In r0 rdsts -> Ple r0 (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r0 : positive, Plt r0 (dreg ctx2) -> rs2 # r0 = rs1 # r0) (r : positive) (H0 : Plt r (dreg ctx2))","proofString":"auto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r0 : reg, In r0 rdsts -> Ple r0 (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r0 : positive, Plt r0 (dreg ctx2) -> rs3 # r0 = rs0 # r0)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r0 : reg, a = r0 \\/ In r0 rdsts -> Ple r0 (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r0 : positive, Plt r0 (dreg ctx2) -> rs2 # r0 = rs1 # r0) (r : positive) (H0 : Plt r (dreg ctx2)) : r <> sreg ctx2 a.","conclusion":"r <> sreg ctx2 a","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r0 : reg, In r0 rdsts -> Ple r0 (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r0 : positive, Plt r0 (dreg ctx2) -> rs3 # r0 = rs0 # r0)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r0 : reg, a = r0 \\/ In r0 rdsts -> Ple r0 (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r0 : positive, Plt r0 (dreg ctx2) -> rs2 # r0 = rs1 # r0) (r : positive) (H0 : Plt r (dreg ctx2))","proofString":"apply not_eq_sym.\neapply sreg_below_diff; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r0 : reg, In r0 rdsts -> Ple r0 (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r0 : positive, Plt r0 (dreg ctx2) -> rs3 # r0 = rs0 # r0)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r0 : reg, a = r0 \\/ In r0 rdsts -> Ple r0 (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r0 : positive, Plt r0 (dreg ctx2) -> rs2 # r0 = rs1 # r0) (r : positive) (H0 : Plt r (dreg ctx2)) : sreg ctx2 a <> r.","conclusion":"sreg ctx2 a <> r","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc0 pc4 : node) (rs0 : regset),\ntr_moves (fn_code f) pc0 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc4 ->\n(forall r0 : reg, In r0 rdsts -> Ple r0 (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs3 : regset,\n  star step tge (State stk f sp pc0 rs0 m) E0 (State stk f sp pc4 rs3 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs3 /\\\n  (forall r0 : positive, Plt r0 (dreg ctx2) -> rs3 # r0 = rs0 # r0)) (pc1 pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r0 : reg, a = r0 \\/ In r0 rdsts -> Ple r0 (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (pc3 : node) (H10 : tr_moves (fn_code f) pc1 (sregs ctx1 bl) (sregs ctx2 rdsts) pc3) (H11 : (fn_code f) ! pc3 = Some (Iop Omove (sreg ctx1 b1 :: nil) (sreg ctx2 a) pc2)) (rs2 : regset) (A : star step tge (State stk f sp pc1 rs1 m) E0 (State stk f sp pc3 rs2 m)) (B : agree_regs F ctx2 (init_regs al rdsts) rs2) (C : forall r0 : positive, Plt r0 (dreg ctx2) -> rs2 # r0 = rs1 # r0) (r : positive) (H0 : Plt r (dreg ctx2))","proofString":"eapply sreg_below_diff; eauto."},{"statement":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (H2 : sreg ctx1 b1 :: sregs ctx1 bl = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil) : exists rs2 : regset,\n  star step tge (State stk f sp pc2 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r).","conclusion":"exists rs2 : regset,\n  star step tge (State stk f sp pc2 rs1 m) E0 (State stk f sp pc2 rs2 m) /\\\n  agree_regs F ctx2 (init_regs al rdsts) # a <- a1 rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs1 # r)","hypotheses":"(F : meminj) (stk : list stackframe) (f : function) (sp : val) (m : mem) (ctx1 ctx2 : context) (H : context_below ctx1 ctx2) (a : reg) (rdsts : list reg) (IHrdsts : forall (rsrcs : list reg) (vl : list val) (pc1 pc0 : node) (rs0 : regset),\ntr_moves (fn_code f) pc1 (sregs ctx1 rsrcs) (sregs ctx2 rdsts) pc0 ->\n(forall r : reg, In r rdsts -> Ple r (mreg ctx2)) ->\nlist_forall2 (val_reg_charact F ctx1 rs0) vl rsrcs ->\nexists rs2 : regset,\n  star step tge (State stk f sp pc1 rs0 m) E0 (State stk f sp pc0 rs2 m) /\\\n  agree_regs F ctx2 (init_regs vl rdsts) rs2 /\\\n  (forall r : positive, Plt r (dreg ctx2) -> rs2 # r = rs0 # r)) (pc2 : node) (rs1 : regset) (b1 : reg) (bl : list reg) (H1 : forall r : reg, a = r \\/ In r rdsts -> Ple r (mreg ctx2)) (a1 : val) (al : list val) (H3 : val_reg_charact F ctx1 rs1 a1 b1) (H4 : list_forall2 (val_reg_charact F ctx1 rs1) al bl) (H2 : sreg ctx1 b1 :: sregs ctx1 bl = nil \\/ sreg ctx2 a :: sregs ctx2 rdsts = nil)","proofString":"destruct H2; discriminate."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b : block) (delta ofs0 : Z),\nF1 b = Some (sp, delta) ->\nMem.perm m1 b ofs0 Max Nonempty ->\nlo <= ofs0 + delta < hi ->\nF b = Some (sp, delta) /\\ Mem.perm m b ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) : loc_private F1 m1 m1' sp ofs.","conclusion":"loc_private F1 m1 m1' sp ofs","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b : block) (delta ofs0 : Z),\nF1 b = Some (sp, delta) ->\nMem.perm m1 b ofs0 Max Nonempty ->\nlo <= ofs0 + delta < hi ->\nF b = Some (sp, delta) /\\ Mem.perm m b ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi)","proofString":"exploit H; eauto.\nintros [A B].\nsplit; auto.\nintros; red; intros.\nexploit H0; eauto.\nlia.\nintros [P Q].\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b : block) (delta ofs0 : Z),\nF1 b = Some (sp, delta) ->\nMem.perm m1 b ofs0 Max Nonempty ->\nlo <= ofs0 + delta < hi ->\nF b = Some (sp, delta) /\\ Mem.perm m b ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) : loc_private F m m' sp ofs -> loc_private F1 m1 m1' sp ofs.","conclusion":"loc_private F m m' sp ofs -> loc_private F1 m1 m1' sp ofs","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b : block) (delta ofs0 : Z),\nF1 b = Some (sp, delta) ->\nMem.perm m1 b ofs0 Max Nonempty ->\nlo <= ofs0 + delta < hi ->\nF b = Some (sp, delta) /\\ Mem.perm m b ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi)","proofString":"intros [A B].\nsplit; auto.\nintros; red; intros.\nexploit H0; eauto.\nlia.\nintros [P Q].\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b : block) (delta ofs0 : Z),\nF1 b = Some (sp, delta) ->\nMem.perm m1 b ofs0 Max Nonempty ->\nlo <= ofs0 + delta < hi ->\nF b = Some (sp, delta) /\\ Mem.perm m b ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m b (ofs - delta) Max Nonempty) : loc_private F1 m1 m1' sp ofs.","conclusion":"loc_private F1 m1 m1' sp ofs","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b : block) (delta ofs0 : Z),\nF1 b = Some (sp, delta) ->\nMem.perm m1 b ofs0 Max Nonempty ->\nlo <= ofs0 + delta < hi ->\nF b = Some (sp, delta) /\\ Mem.perm m b ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m b (ofs - delta) Max Nonempty)","proofString":"split; auto.\nintros; red; intros.\nexploit H0; eauto.\nlia.\nintros [P Q].\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b : block) (delta ofs0 : Z),\nF1 b = Some (sp, delta) ->\nMem.perm m1 b ofs0 Max Nonempty ->\nlo <= ofs0 + delta < hi ->\nF b = Some (sp, delta) /\\ Mem.perm m b ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m b (ofs - delta) Max Nonempty) : forall (b : block) (delta : Z),\nF1 b = Some (sp, delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty.","conclusion":"forall (b : block) (delta : Z),\nF1 b = Some (sp, delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b : block) (delta ofs0 : Z),\nF1 b = Some (sp, delta) ->\nMem.perm m1 b ofs0 Max Nonempty ->\nlo <= ofs0 + delta < hi ->\nF b = Some (sp, delta) /\\ Mem.perm m b ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m b (ofs - delta) Max Nonempty)","proofString":"intros; red; intros.\nexploit H0; eauto.\nlia.\nintros [P Q].\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b0 : block) (delta0 ofs0 : Z),\nF1 b0 = Some (sp, delta0) ->\nMem.perm m1 b0 ofs0 Max Nonempty ->\nlo <= ofs0 + delta0 < hi ->\nF b0 = Some (sp, delta0) /\\ Mem.perm m b0 ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H3 : F1 b = Some (sp, delta)) (H4 : Mem.perm m1 b (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b0 : block) (delta0 ofs0 : Z),\nF1 b0 = Some (sp, delta0) ->\nMem.perm m1 b0 ofs0 Max Nonempty ->\nlo <= ofs0 + delta0 < hi ->\nF b0 = Some (sp, delta0) /\\ Mem.perm m b0 ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H3 : F1 b = Some (sp, delta)) (H4 : Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"exploit H0; eauto.\nlia.\nintros [P Q].\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b0 : block) (delta0 ofs0 : Z),\nF1 b0 = Some (sp, delta0) ->\nMem.perm m1 b0 ofs0 Max Nonempty ->\nlo <= ofs0 + delta0 < hi ->\nF b0 = Some (sp, delta0) /\\ Mem.perm m b0 ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H3 : F1 b = Some (sp, delta)) (H4 : Mem.perm m1 b (ofs - delta) Max Nonempty) : lo <= ofs - delta + delta < hi.","conclusion":"lo <= ofs - delta + delta < hi","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b0 : block) (delta0 ofs0 : Z),\nF1 b0 = Some (sp, delta0) ->\nMem.perm m1 b0 ofs0 Max Nonempty ->\nlo <= ofs0 + delta0 < hi ->\nF b0 = Some (sp, delta0) /\\ Mem.perm m b0 ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H3 : F1 b = Some (sp, delta)) (H4 : Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b0 : block) (delta0 ofs0 : Z),\nF1 b0 = Some (sp, delta0) ->\nMem.perm m1 b0 ofs0 Max Nonempty ->\nlo <= ofs0 + delta0 < hi ->\nF b0 = Some (sp, delta0) /\\ Mem.perm m b0 ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H3 : F1 b = Some (sp, delta)) (H4 : Mem.perm m1 b (ofs - delta) Max Nonempty) : F b = Some (sp, delta) /\\ Mem.perm m b (ofs - delta) Max Nonempty -> False.","conclusion":"F b = Some (sp, delta) /\\ Mem.perm m b (ofs - delta) Max Nonempty -> False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b0 : block) (delta0 ofs0 : Z),\nF1 b0 = Some (sp, delta0) ->\nMem.perm m1 b0 ofs0 Max Nonempty ->\nlo <= ofs0 + delta0 < hi ->\nF b0 = Some (sp, delta0) /\\ Mem.perm m b0 ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H3 : F1 b = Some (sp, delta)) (H4 : Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"intros [P Q].\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b0 : block) (delta0 ofs0 : Z),\nF1 b0 = Some (sp, delta0) ->\nMem.perm m1 b0 ofs0 Max Nonempty ->\nlo <= ofs0 + delta0 < hi ->\nF b0 = Some (sp, delta0) /\\ Mem.perm m b0 ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H3 : F1 b = Some (sp, delta)) (H4 : Mem.perm m1 b (ofs - delta) Max Nonempty) (P : F b = Some (sp, delta)) (Q : Mem.perm m b (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (F1 : block -> option (block * Z)) (m1 m1' : mem) (H : range_private F m m' sp lo hi) (H0 : forall (b0 : block) (delta0 ofs0 : Z),\nF1 b0 = Some (sp, delta0) ->\nMem.perm m1 b0 ofs0 Max Nonempty ->\nlo <= ofs0 + delta0 < hi ->\nF b0 = Some (sp, delta0) /\\ Mem.perm m b0 ofs0 Max Nonempty) (H1 : forall ofs0 : Z,\nMem.perm m' sp ofs0 Cur Freeable -> Mem.perm m1' sp ofs0 Cur Freeable) (ofs : Z) (H2 : lo <= ofs < hi) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H3 : F1 b = Some (sp, delta)) (H4 : Mem.perm m1 b (ofs - delta) Max Nonempty) (P : F b = Some (sp, delta)) (Q : Mem.perm m b (ofs - delta) Max Nonempty)","proofString":"eelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (H : range_private F m m' sp lo hi) (ofs : Z) (H0 : lo <= ofs < hi) : Mem.perm m' sp ofs Cur Freeable.","conclusion":"Mem.perm m' sp ofs Cur Freeable","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (lo hi : Z) (H : range_private F m m' sp lo hi) (ofs : Z) (H0 : lo <= ofs < hi)","proofString":"eapply H; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) : loc_private F1 m1 m' sp' ofs.","conclusion":"loc_private F1 m1 m' sp' ofs","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi)","proofString":"exploit (H ofs).\ngeneralize (Z.le_max_r sz 0).\nlia.\nintros [A B].\nsplit; auto.\nintros; red; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b sp); intros.\nsubst b.\nrewrite H1 in H4; inv H4.\nrewrite Zmax_spec in H3.\ndestruct (zlt 0 sz); lia.\nrewrite H2 in H4; auto.\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) : base <= ofs < hi.","conclusion":"base <= ofs < hi","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi)","proofString":"generalize (Z.le_max_r sz 0).\nlia."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) : 0 <= Z.max sz 0 -> base <= ofs < hi.","conclusion":"0 <= Z.max sz 0 -> base <= ofs < hi","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi)","proofString":"lia."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) : loc_private F m m' sp' ofs -> loc_private F1 m1 m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs -> loc_private F1 m1 m' sp' ofs","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi)","proofString":"intros [A B].\nsplit; auto.\nintros; red; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b sp); intros.\nsubst b.\nrewrite H1 in H4; inv H4.\nrewrite Zmax_spec in H3.\ndestruct (zlt 0 sz); lia.\nrewrite H2 in H4; auto.\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp', delta) -> ~ Mem.perm m b (ofs - delta) Max Nonempty) : loc_private F1 m1 m' sp' ofs.","conclusion":"loc_private F1 m1 m' sp' ofs","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp', delta) -> ~ Mem.perm m b (ofs - delta) Max Nonempty)","proofString":"split; auto.\nintros; red; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b sp); intros.\nsubst b.\nrewrite H1 in H4; inv H4.\nrewrite Zmax_spec in H3.\ndestruct (zlt 0 sz); lia.\nrewrite H2 in H4; auto.\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp', delta) -> ~ Mem.perm m b (ofs - delta) Max Nonempty) : forall (b : block) (delta : Z),\nF1 b = Some (sp', delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty.","conclusion":"forall (b : block) (delta : Z),\nF1 b = Some (sp', delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp', delta) -> ~ Mem.perm m b (ofs - delta) Max Nonempty)","proofString":"intros; red; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b sp); intros.\nsubst b.\nrewrite H1 in H4; inv H4.\nrewrite Zmax_spec in H3.\ndestruct (zlt 0 sz); lia.\nrewrite H2 in H4; auto.\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F1 b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F1 b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"exploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b sp); intros.\nsubst b.\nrewrite H1 in H4; inv H4.\nrewrite Zmax_spec in H3.\ndestruct (zlt 0 sz); lia.\nrewrite H2 in H4; auto.\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F1 b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) : (if eq_block b sp\n then 0 <= ofs - delta < sz\n else Mem.perm m b (ofs - delta) Max Nonempty) -> False.","conclusion":"(if eq_block b sp\n then 0 <= ofs - delta < sz\n else Mem.perm m b (ofs - delta) Max Nonempty) -> False","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F1 b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"destruct (eq_block b sp); intros.\nsubst b.\nrewrite H1 in H4; inv H4.\nrewrite Zmax_spec in H3.\ndestruct (zlt 0 sz); lia.\nrewrite H2 in H4; auto.\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F1 b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) (e : b = sp) (H6 : 0 <= ofs - delta < sz) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F1 b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) (e : b = sp) (H6 : 0 <= ofs - delta < sz)","proofString":"subst b.\nrewrite H1 in H4; inv H4.\nrewrite Zmax_spec in H3.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) -> ~ Mem.perm m b (ofs - delta0) Max Nonempty) (delta : Z) (H5 : Mem.perm m1 sp (ofs - delta) Max Nonempty) (H4 : F1 sp = Some (sp', delta)) (H6 : 0 <= ofs - delta < sz) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) -> ~ Mem.perm m b (ofs - delta0) Max Nonempty) (delta : Z) (H5 : Mem.perm m1 sp (ofs - delta) Max Nonempty) (H4 : F1 sp = Some (sp', delta)) (H6 : 0 <= ofs - delta < sz)","proofString":"rewrite H1 in H4; inv H4.\nrewrite Zmax_spec in H3.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (delta : Z) (H : range_private F m m' sp' delta hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', delta)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : delta + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) -> ~ Mem.perm m b (ofs - delta0) Max Nonempty) (H5 : Mem.perm m1 sp (ofs - delta) Max Nonempty) (H6 : 0 <= ofs - delta < sz) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (delta : Z) (H : range_private F m m' sp' delta hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', delta)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : delta + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) -> ~ Mem.perm m b (ofs - delta0) Max Nonempty) (H5 : Mem.perm m1 sp (ofs - delta) Max Nonempty) (H6 : 0 <= ofs - delta < sz)","proofString":"rewrite Zmax_spec in H3.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (delta : Z) (H : range_private F m m' sp' delta hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', delta)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : delta + (if zlt 0 sz then sz else 0) <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) -> ~ Mem.perm m b (ofs - delta0) Max Nonempty) (H5 : Mem.perm m1 sp (ofs - delta) Max Nonempty) (H6 : 0 <= ofs - delta < sz) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (delta : Z) (H : range_private F m m' sp' delta hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', delta)) (H2 : forall b : block, b <> sp -> F1 b = F b) (ofs : Z) (H3 : delta + (if zlt 0 sz then sz else 0) <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) -> ~ Mem.perm m b (ofs - delta0) Max Nonempty) (H5 : Mem.perm m1 sp (ofs - delta) Max Nonempty) (H6 : 0 <= ofs - delta < sz)","proofString":"destruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F1 b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) (n : b <> sp) (H6 : Mem.perm m b (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F1 b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) (n : b <> sp) (H6 : Mem.perm m b (ofs - delta) Max Nonempty)","proofString":"rewrite H2 in H4; auto.\neelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) (n : b <> sp) (H6 : Mem.perm m b (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp' : block) (base hi sz : Z) (m1 : Mem.mem') (sp : block) (F1 : block -> option (block * Z)) (H : range_private F m m' sp' base hi) (H0 : Mem.alloc m 0 sz = (m1, sp)) (H1 : F1 sp = Some (sp', base)) (H2 : forall b0 : block, b0 <> sp -> F1 b0 = F b0) (ofs : Z) (H3 : base + Z.max sz 0 <= ofs < hi) (A : Mem.perm m' sp' ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp', delta0) -> ~ Mem.perm m b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H4 : F b = Some (sp', delta)) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) (n : b <> sp) (H6 : Mem.perm m b (ofs - delta) Max Nonempty)","proofString":"eelim B; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) : loc_private F m1 m' sp ofs.","conclusion":"loc_private F m1 m' sp ofs","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi)","proofString":"destruct (zlt ofs (base + Z.max sz 0)) as [z|z].\nred; split.\nreplace ofs with ((ofs - base) + base) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\nintros; red; intros.\ndestruct (eq_block b b0).\nsubst b0.\nrewrite H1 in H4; inv H4.\neelim Mem.perm_free_2; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neauto.\ninstantiate (1 := ofs - base).\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\neapply Mem.perm_free_3; eauto.\nintros [A | A].\ncongruence.\nlia.\nexploit (H ofs).\nlia.\nintros [A B].\nsplit.\nauto.\nintros; red; intros.\neelim B; eauto.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) : loc_private F m1 m' sp ofs.","conclusion":"loc_private F m1 m' sp ofs","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0)","proofString":"red; split.\nreplace ofs with ((ofs - base) + base) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\nintros; red; intros.\ndestruct (eq_block b b0).\nsubst b0.\nrewrite H1 in H4; inv H4.\neelim Mem.perm_free_2; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neauto.\ninstantiate (1 := ofs - base).\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\neapply Mem.perm_free_3; eauto.\nintros [A | A].\ncongruence.\nlia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) : Mem.perm m' sp ofs Cur Freeable.","conclusion":"Mem.perm m' sp ofs Cur Freeable","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0)","proofString":"replace ofs with ((ofs - base) + base) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) : Mem.perm m' sp (ofs - base + base) Cur Freeable.","conclusion":"Mem.perm m' sp (ofs - base + base) Cur Freeable","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0)","proofString":"eapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) : Mem.perm m b (ofs - base) Cur Freeable.","conclusion":"Mem.perm m b (ofs - base) Cur Freeable","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0)","proofString":"eapply Mem.free_range_perm; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) : 0 <= ofs - base < sz.","conclusion":"0 <= ofs - base < sz","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0)","proofString":"rewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + (if zlt 0 sz then sz else 0)) : 0 <= ofs - base < sz.","conclusion":"0 <= ofs - base < sz","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + (if zlt 0 sz then sz else 0))","proofString":"destruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) : forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty.","conclusion":"forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0)","proofString":"intros; red; intros.\ndestruct (eq_block b b0).\nsubst b0.\nrewrite H1 in H4; inv H4.\neelim Mem.perm_free_2; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neauto.\ninstantiate (1 := ofs - base).\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\neapply Mem.perm_free_3; eauto.\nintros [A | A].\ncongruence.\nlia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty)","proofString":"destruct (eq_block b b0).\nsubst b0.\nrewrite H1 in H4; inv H4.\neelim Mem.perm_free_2; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neauto.\ninstantiate (1 := ofs - base).\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\neapply Mem.perm_free_3; eauto.\nintros [A | A].\ncongruence.\nlia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (e : b = b0) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (e : b = b0)","proofString":"subst b0.\nrewrite H1 in H4; inv H4.\neelim Mem.perm_free_2; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (delta : Z) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) (H4 : F b = Some (sp, delta)) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (delta : Z) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) (H4 : F b = Some (sp, delta))","proofString":"rewrite H1 in H4; inv H4.\neelim Mem.perm_free_2; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (sz hi : Z) (b : block) (m1 : mem) (delta : Z) (H : range_private F m m' sp (delta + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, delta)) (H2 : Mem.inject F m m') (ofs : Z) (z : ofs < delta + Z.max sz 0) (H3 : delta <= ofs < hi) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (sz hi : Z) (b : block) (m1 : mem) (delta : Z) (H : range_private F m m' sp (delta + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, delta)) (H2 : Mem.inject F m m') (ofs : Z) (z : ofs < delta + Z.max sz 0) (H3 : delta <= ofs < hi) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"eelim Mem.perm_free_2; eauto.\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (sz hi : Z) (b : block) (m1 : mem) (delta : Z) (H : range_private F m m' sp (delta + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, delta)) (H2 : Mem.inject F m m') (ofs : Z) (z : ofs < delta + Z.max sz 0) (H3 : delta <= ofs < hi) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) : 0 <= ofs - delta < sz.","conclusion":"0 <= ofs - delta < sz","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (sz hi : Z) (b : block) (m1 : mem) (delta : Z) (H : range_private F m m' sp (delta + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, delta)) (H2 : Mem.inject F m m') (ofs : Z) (z : ofs < delta + Z.max sz 0) (H3 : delta <= ofs < hi) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"rewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (sz hi : Z) (b : block) (m1 : mem) (delta : Z) (H : range_private F m m' sp (delta + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, delta)) (H2 : Mem.inject F m m') (ofs : Z) (z : ofs < delta + (if zlt 0 sz then sz else 0)) (H3 : delta <= ofs < hi) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty) : 0 <= ofs - delta < sz.","conclusion":"0 <= ofs - delta < sz","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (sz hi : Z) (b : block) (m1 : mem) (delta : Z) (H : range_private F m m' sp (delta + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, delta)) (H2 : Mem.inject F m m') (ofs : Z) (z : ofs < delta + (if zlt 0 sz then sz else 0)) (H3 : delta <= ofs < hi) (H5 : Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"destruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0)","proofString":"exploit Mem.mi_no_overlap; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neauto.\ninstantiate (1 := ofs - base).\nrewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia.\neapply Mem.perm_free_3; eauto.\nintros [A | A].\ncongruence.\nlia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0) : 0 <= ofs - base < sz.","conclusion":"0 <= ofs - base < sz","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0)","proofString":"rewrite Zmax_spec in z.\ndestruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + (if zlt 0 sz then sz else 0)) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0) : 0 <= ofs - base < sz.","conclusion":"0 <= ofs - base < sz","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + (if zlt 0 sz then sz else 0)) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0)","proofString":"destruct (zlt 0 sz); lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0) (A : sp <> sp) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0) (A : sp <> sp)","proofString":"congruence."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0) (A : ofs - base + base <> ofs - delta + delta) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs < base + Z.max sz 0) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (n : b <> b0) (A : ofs - base + base <> ofs - delta + delta)","proofString":"lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) : loc_private F m1 m' sp ofs.","conclusion":"loc_private F m1 m' sp ofs","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0)","proofString":"exploit (H ofs).\nlia.\nintros [A B].\nsplit.\nauto.\nintros; red; intros.\neelim B; eauto.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) : base + Z.max sz 0 <= ofs < hi.","conclusion":"base + Z.max sz 0 <= ofs < hi","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0)","proofString":"lia."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) : loc_private F m m' sp ofs -> loc_private F m1 m' sp ofs.","conclusion":"loc_private F m m' sp ofs -> loc_private F m1 m' sp ofs","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0)","proofString":"intros [A B].\nsplit.\nauto.\nintros; red; intros.\neelim B; eauto.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m b0 (ofs - delta) Max Nonempty) : loc_private F m1 m' sp ofs.","conclusion":"loc_private F m1 m' sp ofs","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m b0 (ofs - delta) Max Nonempty)","proofString":"split.\nauto.\nintros; red; intros.\neelim B; eauto.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m b0 (ofs - delta) Max Nonempty) : Mem.perm m' sp ofs Cur Freeable.","conclusion":"Mem.perm m' sp ofs Cur Freeable","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m b0 (ofs - delta) Max Nonempty)","proofString":"auto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m b0 (ofs - delta) Max Nonempty) : forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty.","conclusion":"forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp, delta) -> ~ Mem.perm m b0 (ofs - delta) Max Nonempty)","proofString":"intros; red; intros.\neelim B; eauto.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b1 : block) (delta0 : Z),\nF b1 = Some (sp, delta0) -> ~ Mem.perm m b1 (ofs - delta0) Max Nonempty) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b1 : block) (delta0 : Z),\nF b1 = Some (sp, delta0) -> ~ Mem.perm m b1 (ofs - delta0) Max Nonempty) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty)","proofString":"eelim B; eauto.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b1 : block) (delta0 : Z),\nF b1 = Some (sp, delta0) -> ~ Mem.perm m b1 (ofs - delta0) Max Nonempty) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) : Mem.perm m b0 (ofs - delta) Max Nonempty.","conclusion":"Mem.perm m b0 (ofs - delta) Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (sp : block) (base sz hi : Z) (b : block) (m1 : mem) (H : range_private F m m' sp (base + Z.max sz 0) hi) (H0 : Mem.free m b 0 sz = Some m1) (H1 : F b = Some (sp, base)) (H2 : Mem.inject F m m') (ofs : Z) (H3 : base <= ofs < hi) (z : ofs >= base + Z.max sz 0) (A : Mem.perm m' sp ofs Cur Freeable) (B : forall (b1 : block) (delta0 : Z),\nF b1 = Some (sp, delta0) -> ~ Mem.perm m b1 (ofs - delta0) Max Nonempty) (b0 : block) (delta : Z) (H4 : F b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) : range_private F' m2 m2' sp base hi.","conclusion":"range_private F' m2 m2' sp base hi","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp)","proofString":"red; intros.\nexploit RP; eauto.\nintros [A B].\nsplit.\neapply Mem.perm_unchanged_on; eauto.\nintros.\nred in SEP.\ndestruct (F b) as [[sp1 delta1] |] eqn:?.\nexploit INCR; eauto.\nintros EQ; rewrite H0 in EQ; inv EQ.\nred; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence.\nexploit SEP; eauto.\ntauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) : loc_private F' m2 m2' sp ofs.","conclusion":"loc_private F' m2 m2' sp ofs","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi)","proofString":"exploit RP; eauto.\nintros [A B].\nsplit.\neapply Mem.perm_unchanged_on; eauto.\nintros.\nred in SEP.\ndestruct (F b) as [[sp1 delta1] |] eqn:?.\nexploit INCR; eauto.\nintros EQ; rewrite H0 in EQ; inv EQ.\nred; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence.\nexploit SEP; eauto.\ntauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) : loc_private F m1 m1' sp ofs -> loc_private F' m2 m2' sp ofs.","conclusion":"loc_private F m1 m1' sp ofs -> loc_private F' m2 m2' sp ofs","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi)","proofString":"intros [A B].\nsplit.\neapply Mem.perm_unchanged_on; eauto.\nintros.\nred in SEP.\ndestruct (F b) as [[sp1 delta1] |] eqn:?.\nexploit INCR; eauto.\nintros EQ; rewrite H0 in EQ; inv EQ.\nred; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence.\nexploit SEP; eauto.\ntauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty) : loc_private F' m2 m2' sp ofs.","conclusion":"loc_private F' m2 m2' sp ofs","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"split.\neapply Mem.perm_unchanged_on; eauto.\nintros.\nred in SEP.\ndestruct (F b) as [[sp1 delta1] |] eqn:?.\nexploit INCR; eauto.\nintros EQ; rewrite H0 in EQ; inv EQ.\nred; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence.\nexploit SEP; eauto.\ntauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty) : Mem.perm m2' sp ofs Cur Freeable.","conclusion":"Mem.perm m2' sp ofs Cur Freeable","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"eapply Mem.perm_unchanged_on; eauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty) : forall (b : block) (delta : Z),\nF' b = Some (sp, delta) -> ~ Mem.perm m2 b (ofs - delta) Max Nonempty.","conclusion":"forall (b : block) (delta : Z),\nF' b = Some (sp, delta) -> ~ Mem.perm m2 b (ofs - delta) Max Nonempty","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b : block) (delta : Z),\nF b = Some (sp, delta) -> ~ Mem.perm m1 b (ofs - delta) Max Nonempty)","proofString":"intros.\nred in SEP.\ndestruct (F b) as [[sp1 delta1] |] eqn:?.\nexploit INCR; eauto.\nintros EQ; rewrite H0 in EQ; inv EQ.\nred; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence.\nexploit SEP; eauto.\ntauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) : ~ Mem.perm m2 b (ofs - delta) Max Nonempty.","conclusion":"~ Mem.perm m2 b (ofs - delta) Max Nonempty","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : inject_separated F F' m1 m1') (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta))","proofString":"red in SEP.\ndestruct (F b) as [[sp1 delta1] |] eqn:?.\nexploit INCR; eauto.\nintros EQ; rewrite H0 in EQ; inv EQ.\nred; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence.\nexploit SEP; eauto.\ntauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) : ~ Mem.perm m2 b (ofs - delta) Max Nonempty.","conclusion":"~ Mem.perm m2 b (ofs - delta) Max Nonempty","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta))","proofString":"destruct (F b) as [[sp1 delta1] |] eqn:?.\nexploit INCR; eauto.\nintros EQ; rewrite H0 in EQ; inv EQ.\nred; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence.\nexploit SEP; eauto.\ntauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) (sp1 : block) (delta1 : Z) (Heqo : F b = Some (sp1, delta1)) : ~ Mem.perm m2 b (ofs - delta) Max Nonempty.","conclusion":"~ Mem.perm m2 b (ofs - delta) Max Nonempty","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) (sp1 : block) (delta1 : Z) (Heqo : F b = Some (sp1, delta1))","proofString":"exploit INCR; eauto.\nintros EQ; rewrite H0 in EQ; inv EQ.\nred; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) (sp1 : block) (delta1 : Z) (Heqo : F b = Some (sp1, delta1)) : F' b = Some (sp1, delta1) -> ~ Mem.perm m2 b (ofs - delta) Max Nonempty.","conclusion":"F' b = Some (sp1, delta1) -> ~ Mem.perm m2 b (ofs - delta) Max Nonempty","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) (sp1 : block) (delta1 : Z) (Heqo : F b = Some (sp1, delta1))","proofString":"intros EQ; rewrite H0 in EQ; inv EQ.\nred; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) : ~ Mem.perm m2 b (ofs - delta1) Max Nonempty.","conclusion":"~ Mem.perm m2 b (ofs - delta1) Max Nonempty","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1))","proofString":"red; intros; eelim B; eauto.\neapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty) : Mem.perm m1 b (ofs - delta1) Max Nonempty.","conclusion":"Mem.perm m1 b (ofs - delta1) Max Nonempty","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty)","proofString":"eapply PERM; eauto.\nred.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty) : Mem.valid_block m1 b.","conclusion":"Mem.valid_block m1 b","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty)","proofString":"red.\ndestruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty) : Plt b (Mem.nextblock m1).","conclusion":"Plt b (Mem.nextblock m1)","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty)","proofString":"destruct (plt b (Mem.nextblock m1)); auto.\nexploit Mem.mi_freeblocks; eauto.\ncongruence."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty) (n : ~ Plt b (Mem.nextblock m1)) : Plt b (Mem.nextblock m1).","conclusion":"Plt b (Mem.nextblock m1)","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty) (n : ~ Plt b (Mem.nextblock m1))","proofString":"exploit Mem.mi_freeblocks; eauto.\ncongruence."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty) (n : ~ Plt b (Mem.nextblock m1)) : F b = None -> Plt b (Mem.nextblock m1).","conclusion":"F b = None -> Plt b (Mem.nextblock m1)","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (base hi : Z) (sp1 : block) (RP : range_private F m1 m1' sp1 base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp1) (ofs : Z) (H : base <= ofs < hi) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp1, delta) -> ~ Mem.perm m1 b0 (ofs - delta) Max Nonempty) (A : Mem.perm m1' sp1 ofs Cur Freeable) (b : block) (delta1 : Z) (H0 : F' b = Some (sp1, delta1)) (Heqo : F b = Some (sp1, delta1)) (H1 : Mem.perm m2 b (ofs - delta1) Max Nonempty) (n : ~ Plt b (Mem.nextblock m1))","proofString":"congruence."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) (Heqo : F b = None) : ~ Mem.perm m2 b (ofs - delta) Max Nonempty.","conclusion":"~ Mem.perm m2 b (ofs - delta) Max Nonempty","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) (Heqo : F b = None)","proofString":"exploit SEP; eauto.\ntauto."},{"statement":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) (Heqo : F b = None) : ~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' sp ->\n~ Mem.perm m2 b (ofs - delta) Max Nonempty.","conclusion":"~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' sp ->\n~ Mem.perm m2 b (ofs - delta) Max Nonempty","hypotheses":"(F F' : meminj) (m1 m2 m1' m2' : mem) (sp : block) (base hi : Z) (RP : range_private F m1 m1' sp base hi) (PERM : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (UNCH : Mem.unchanged_on (loc_out_of_reach F m1) m1' m2') (INJ : Mem.inject F m1 m1') (INCR : inject_incr F F') (SEP : forall (b1 b2 : block) (delta0 : Z),\nF b1 = None ->\nF' b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (VB : Mem.valid_block m1' sp) (ofs : Z) (H : base <= ofs < hi) (A : Mem.perm m1' sp ofs Cur Freeable) (B : forall (b0 : block) (delta0 : Z),\nF b0 = Some (sp, delta0) -> ~ Mem.perm m1 b0 (ofs - delta0) Max Nonempty) (b : block) (delta : Z) (H0 : F' b = Some (sp, delta)) (Heqo : F b = None)","proofString":"tauto."},{"statement":"(ros : reg + ident) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : find_function ge ros rs = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) : exists (cu : program) (fd' : fundef),\n  find_function tge (sros ctx ros) rs' = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog.","conclusion":"exists (cu : program) (fd' : fundef),\n  find_function tge (sros ctx ros) rs' = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog","hypotheses":"(ros : reg + ident) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : find_function ge ros rs = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound)","proofString":"destruct ros as [r | id]; simpl in *.\nassert (EQ: rs'#(sreg ctx r) = rs#r).\nexploit Genv.find_funct_inv; eauto.\nintros [b EQ].\nassert (A: Val.inject F rs#r rs'#(sreg ctx r)).\neapply agree_val_reg; eauto.\nrewrite EQ in A; inv A.\ninv H1.\nrewrite DOMAIN in H5.\ninv H5.\nauto.\napply FUNCTIONS with fd.\nrewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto.\nrewrite EQ.\neapply functions_translated; eauto.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id); try discriminate.\neapply function_ptr_translated; eauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) : exists (cu : program) (fd' : fundef),\n  Genv.find_funct tge rs' # (sreg ctx r) = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog.","conclusion":"exists (cu : program) (fd' : fundef),\n  Genv.find_funct tge rs' # (sreg ctx r) = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound)","proofString":"assert (EQ: rs'#(sreg ctx r) = rs#r).\nexploit Genv.find_funct_inv; eauto.\nintros [b EQ].\nassert (A: Val.inject F rs#r rs'#(sreg ctx r)).\neapply agree_val_reg; eauto.\nrewrite EQ in A; inv A.\ninv H1.\nrewrite DOMAIN in H5.\ninv H5.\nauto.\napply FUNCTIONS with fd.\nrewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto.\nrewrite EQ.\neapply functions_translated; eauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) : rs' # (sreg ctx r) = rs # r.","conclusion":"rs' # (sreg ctx r) = rs # r","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound)","proofString":"exploit Genv.find_funct_inv; eauto.\nintros [b EQ].\nassert (A: Val.inject F rs#r rs'#(sreg ctx r)).\neapply agree_val_reg; eauto.\nrewrite EQ in A; inv A.\ninv H1.\nrewrite DOMAIN in H5.\ninv H5.\nauto.\napply FUNCTIONS with fd.\nrewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) : (exists b : block, rs # r = Vptr b Ptrofs.zero) ->\nrs' # (sreg ctx r) = rs # r.","conclusion":"(exists b : block, rs # r = Vptr b Ptrofs.zero) ->\nrs' # (sreg ctx r) = rs # r","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound)","proofString":"intros [b EQ].\nassert (A: Val.inject F rs#r rs'#(sreg ctx r)).\neapply agree_val_reg; eauto.\nrewrite EQ in A; inv A.\ninv H1.\nrewrite DOMAIN in H5.\ninv H5.\nauto.\napply FUNCTIONS with fd.\nrewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) : rs' # (sreg ctx r) = rs # r.","conclusion":"rs' # (sreg ctx r) = rs # r","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (b : block) (EQ : rs # r = Vptr b Ptrofs.zero)","proofString":"assert (A: Val.inject F rs#r rs'#(sreg ctx r)).\neapply agree_val_reg; eauto.\nrewrite EQ in A; inv A.\ninv H1.\nrewrite DOMAIN in H5.\ninv H5.\nauto.\napply FUNCTIONS with fd.\nrewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) : Val.inject F rs # r rs' # (sreg ctx r).","conclusion":"Val.inject F rs # r rs' # (sreg ctx r)","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (b : block) (EQ : rs # r = Vptr b Ptrofs.zero)","proofString":"eapply agree_val_reg; eauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (A : Val.inject F rs # r rs' # (sreg ctx r)) : rs' # (sreg ctx r) = rs # r.","conclusion":"rs' # (sreg ctx r) = rs # r","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (A : Val.inject F rs # r rs' # (sreg ctx r))","proofString":"rewrite EQ in A; inv A.\ninv H1.\nrewrite DOMAIN in H5.\ninv H5.\nauto.\napply FUNCTIONS with fd.\nrewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs # r.","conclusion":"Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs # r","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r))","proofString":"inv H1.\nrewrite DOMAIN in H5.\ninv H5.\nauto.\napply FUNCTIONS with fd.\nrewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs # r.","conclusion":"Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs # r","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound)","proofString":"rewrite DOMAIN in H5.\ninv H5.\nauto.\napply FUNCTIONS with fd.\nrewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : Some (b, 0) = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs # r.","conclusion":"Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs # r","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : Some (b, 0) = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound)","proofString":"inv H5.\nauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b2 : block) (EQ : rs # r = Vptr b2 Ptrofs.zero) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) = rs' # (sreg ctx r)) (DOMAIN : forall b : positive, Plt b bound -> F b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nF b1 = Some (b0, delta) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) = rs # r.","conclusion":"Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) = rs # r","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b2 : block) (EQ : rs # r = Vptr b2 Ptrofs.zero) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) = rs' # (sreg ctx r)) (DOMAIN : forall b : positive, Plt b bound -> F b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nF b1 = Some (b0, delta) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b = Some fd0 -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound)","proofString":"auto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) : Plt b bound.","conclusion":"Plt b bound","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound)","proofString":"apply FUNCTIONS with fd.\nrewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) : Genv.find_funct_ptr ge b = Some fd.","conclusion":"Genv.find_funct_ptr ge b = Some fd","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound)","proofString":"rewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H.\nauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : agree_regs F ctx rs rs') (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) : Genv.find_funct_ptr ge b = Some fd.","conclusion":"Genv.find_funct_ptr ge b = Some fd","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : agree_regs F ctx rs rs') (EQ : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : F b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs' # (sreg ctx r)) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nF b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound)","proofString":"auto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (EQ : rs' # (sreg ctx r) = rs # r) : exists (cu : program) (fd' : fundef),\n  Genv.find_funct tge rs' # (sreg ctx r) = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog.","conclusion":"exists (cu : program) (fd' : fundef),\n  Genv.find_funct tge rs' # (sreg ctx r) = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (EQ : rs' # (sreg ctx r) = rs # r)","proofString":"rewrite EQ.\neapply functions_translated; eauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (EQ : rs' # (sreg ctx r) = rs # r) : exists (cu : program) (fd' : fundef),\n  Genv.find_funct tge rs # r = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog.","conclusion":"exists (cu : program) (fd' : fundef),\n  Genv.find_funct tge rs # r = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : Genv.find_funct ge rs # r = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) (EQ : rs' # (sreg ctx r) = rs # r)","proofString":"eapply functions_translated; eauto."},{"statement":"(id : ident) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) : exists (cu : program) (fd' : fundef),\n  match Genv.find_symbol tge id with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog.","conclusion":"exists (cu : program) (fd' : fundef),\n  match Genv.find_symbol tge id with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog","hypotheses":"(id : ident) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound)","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id); try discriminate.\neapply function_ptr_translated; eauto."},{"statement":"(id : ident) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) : exists (cu : program) (fd' : fundef),\n  match Genv.find_symbol ge id with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog.","conclusion":"exists (cu : program) (fd' : fundef),\n  match Genv.find_symbol ge id with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog","hypotheses":"(id : ident) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound : block) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound)","proofString":"destruct (Genv.find_symbol ge id); try discriminate.\neapply function_ptr_translated; eauto."},{"statement":"(id : ident) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound) : exists (cu : program) (fd' : fundef),\n  Genv.find_funct_ptr tge b = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog.","conclusion":"exists (cu : program) (fd' : fundef),\n  Genv.find_funct_ptr tge b = Some fd' /\\\n  transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog","hypotheses":"(id : ident) (rs : regset) (fd : fundef) (F : meminj) (ctx : context) (rs' : regset) (bound b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : agree_regs F ctx rs rs') (H1 : match_globalenvs F bound)","proofString":"eapply function_ptr_translated; eauto."},{"statement":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (H0 : find_function ge (inr id) rs = Some fd) (H1 : fenv ! id = Some f) : fd = Internal f.","conclusion":"fd = Internal f","hypotheses":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (H0 : find_function ge (inr id) rs = Some fd) (H1 : fenv ! id = Some f)","proofString":"apply H in H1.\napply Genv.find_def_symbol in H1.\ndestruct H1 as (b & A & B).\nsimpl in H0.\nunfold ge, fundef in H0.\nrewrite A in H0.\nrewrite <- Genv.find_funct_ptr_iff in B.\ncongruence."},{"statement":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (H0 : find_function ge (inr id) rs = Some fd) (H1 : (prog_defmap prog) ! id = Some (Gfun (Internal f))) : fd = Internal f.","conclusion":"fd = Internal f","hypotheses":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (H0 : find_function ge (inr id) rs = Some fd) (H1 : (prog_defmap prog) ! id = Some (Gfun (Internal f)))","proofString":"apply Genv.find_def_symbol in H1.\ndestruct H1 as (b & A & B).\nsimpl in H0.\nunfold ge, fundef in H0.\nrewrite A in H0.\nrewrite <- Genv.find_funct_ptr_iff in B.\ncongruence."},{"statement":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (H0 : match Genv.find_symbol (Genv.globalenv prog) id with\n| Some b0 => Genv.find_funct_ptr (Genv.globalenv prog) b0\n| None => None\nend = Some fd) (b : block) (A : Genv.find_symbol (Genv.globalenv prog) id = Some b) (B : Genv.find_def (Genv.globalenv prog) b = Some (Gfun (Internal f))) : fd = Internal f.","conclusion":"fd = Internal f","hypotheses":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (H0 : match Genv.find_symbol (Genv.globalenv prog) id with\n| Some b0 => Genv.find_funct_ptr (Genv.globalenv prog) b0\n| None => None\nend = Some fd) (b : block) (A : Genv.find_symbol (Genv.globalenv prog) id = Some b) (B : Genv.find_def (Genv.globalenv prog) b = Some (Gfun (Internal f)))","proofString":"rewrite A in H0.\nrewrite <- Genv.find_funct_ptr_iff in B.\ncongruence."},{"statement":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (b : block) (H0 : Genv.find_funct_ptr (Genv.globalenv prog) b = Some fd) (A : Genv.find_symbol (Genv.globalenv prog) id = Some b) (B : Genv.find_def (Genv.globalenv prog) b = Some (Gfun (Internal f))) : fd = Internal f.","conclusion":"fd = Internal f","hypotheses":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (b : block) (H0 : Genv.find_funct_ptr (Genv.globalenv prog) b = Some fd) (A : Genv.find_symbol (Genv.globalenv prog) id = Some b) (B : Genv.find_def (Genv.globalenv prog) b = Some (Gfun (Internal f)))","proofString":"rewrite <- Genv.find_funct_ptr_iff in B.\ncongruence."},{"statement":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (b : block) (H0 : Genv.find_funct_ptr (Genv.globalenv prog) b = Some fd) (A : Genv.find_symbol (Genv.globalenv prog) id = Some b) (B : Genv.find_funct_ptr (Genv.globalenv prog) b = Some (Internal f)) : fd = Internal f.","conclusion":"fd = Internal f","hypotheses":"(fenv : funenv) (id : ident) (rs : regset) (fd : fundef) (f : function) (H : fenv_compat prog fenv) (b : block) (H0 : Genv.find_funct_ptr (Genv.globalenv prog) b = Some fd) (A : Genv.find_symbol (Genv.globalenv prog) id = Some b) (B : Genv.find_funct_ptr (Genv.globalenv prog) b = Some (Internal f))","proofString":"congruence."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') : forall (a : builtin_arg positive) (v : val),\neval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a v ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a) v' /\\ \n  Val.inject F v v'.","conclusion":"forall (a : builtin_arg positive) (v : val),\neval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a v ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a) v' /\\ \n  Val.inject F v v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m')","proofString":"induction 1; simpl.\nexists rs'#(sreg ctx x); split.\nconstructor.\neapply agree_val_reg; eauto.\neconstructor; eauto with barg.\neconstructor; eauto with barg.\neconstructor; eauto with barg.\neconstructor; eauto with barg.\nexploit Mem.loadv_inject; eauto.\ninstantiate (1 := Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))).\nsimpl.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto.\nintros (v' & A & B).\nexists v'; split; auto.\nconstructor.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto.\neconstructor; split.\nconstructor.\nsimpl.\neconstructor; eauto.\nrewrite ! Ptrofs.add_zero_l; auto.\nassert (Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)).\nunfold Senv.symbol_address; simpl; unfold Genv.symbol_address.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ninv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto.\nexploit Mem.loadv_inject; eauto.\nintros (v' & A & B).\nexists v'; eauto with barg.\neconstructor; split.\nconstructor.\nunfold Senv.symbol_address; simpl; unfold Genv.symbol_address.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ninv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto.\ndestruct IHeval_builtin_arg1 as (v1' & A1 & B1).\ndestruct IHeval_builtin_arg2 as (v2' & A2 & B2).\neconstructor; split.\neauto with barg.\napply Val.longofwords_inject; auto.\ndestruct IHeval_builtin_arg1 as (v1' & A1 & B1).\ndestruct IHeval_builtin_arg2 as (v2' & A2 & B2).\neconstructor; split.\neauto with barg.\ndestruct Archi.ptr64; auto using Val.add_inject, Val.addl_inject."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (x : positive) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA (sreg ctx x)) v' /\\ \n  Val.inject F rs # x v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA (sreg ctx x)) v' /\\ \n  Val.inject F rs # x v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (x : positive)","proofString":"exists rs'#(sreg ctx x); split.\nconstructor.\neapply agree_val_reg; eauto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (x : positive) : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (BA (sreg ctx x)) rs' # (sreg ctx x).","conclusion":"eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (BA (sreg ctx x)) rs' # (sreg ctx x)","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (x : positive)","proofString":"constructor."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (x : positive) : Val.inject F rs # x rs' # (sreg ctx x).","conclusion":"Val.inject F rs # x rs' # (sreg ctx x)","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (x : positive)","proofString":"eapply agree_val_reg; eauto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (n : int) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_int n) v' /\\ Val.inject F (Vint n) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_int n) v' /\\ Val.inject F (Vint n) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (n : int)","proofString":"econstructor; eauto with barg."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (n : int64) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_long n) v' /\\ Val.inject F (Vlong n) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_long n) v' /\\ Val.inject F (Vlong n) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (n : int64)","proofString":"econstructor; eauto with barg."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (n : Floats.float) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_float n) v' /\\ Val.inject F (Vfloat n) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_float n) v' /\\ Val.inject F (Vfloat n) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (n : Floats.float)","proofString":"econstructor; eauto with barg."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (n : Floats.float32) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_single n) v' /\\ \n  Val.inject F (Vsingle n) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_single n) v' /\\ \n  Val.inject F (Vsingle n) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (n : Floats.float32)","proofString":"econstructor; eauto with barg."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_loadstack chunk (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) v' /\\\n  Val.inject F v v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_loadstack chunk (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) v' /\\\n  Val.inject F v v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v)","proofString":"exploit Mem.loadv_inject; eauto.\ninstantiate (1 := Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))).\nsimpl.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto.\nintros (v' & A & B).\nexists v'; split; auto.\nconstructor.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : Val.inject F (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs)\n  (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))).","conclusion":"Val.inject F (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs)\n  (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx))))","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v)","proofString":"simpl.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : Val.inject F (Vptr sp (Ptrofs.add Ptrofs.zero ofs))\n  (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))).","conclusion":"Val.inject F (Vptr sp (Ptrofs.add Ptrofs.zero ofs))\n  (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx))))","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v)","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : Ptrofs.add ofs (Ptrofs.repr (dstk ctx)) =\nPtrofs.add (Ptrofs.add Ptrofs.zero ofs) (Ptrofs.repr (dstk ctx)).","conclusion":"Ptrofs.add ofs (Ptrofs.repr (dstk ctx)) =\nPtrofs.add (Ptrofs.add Ptrofs.zero ofs) (Ptrofs.repr (dstk ctx))","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v)","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) =\nSome v') (B : Val.inject F v v') : exists v'0 : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_loadstack chunk (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) v'0 /\\\n  Val.inject F v v'0.","conclusion":"exists v'0 : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_loadstack chunk (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) v'0 /\\\n  Val.inject F v v'0","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) =\nSome v') (B : Val.inject F v v')","proofString":"exists v'; split; auto.\nconstructor.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) =\nSome v') (B : Val.inject F v v') : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'\n  (BA_loadstack chunk (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) v'.","conclusion":"eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'\n  (BA_loadstack chunk (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) =\nSome v') (B : Val.inject F v v')","proofString":"constructor.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) =\nSome v') (B : Val.inject F v v') : Mem.loadv chunk m'\n  (Val.offset_ptr (Vptr sp' Ptrofs.zero)\n     (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) = \nSome v'.","conclusion":"Mem.loadv chunk m'\n  (Val.offset_ptr (Vptr sp' Ptrofs.zero)\n     (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) = \nSome v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) =\nSome v') (B : Val.inject F v v')","proofString":"simpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) =\nSome v') (B : Val.inject F v v') : Mem.load chunk m' sp'\n  (Ptrofs.unsigned\n     (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr (dstk ctx))))) =\nSome v'.","conclusion":"Mem.load chunk m' sp'\n  (Ptrofs.unsigned\n     (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr (dstk ctx))))) =\nSome v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Vptr sp' (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) =\nSome v') (B : Val.inject F v v')","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (ofs : ptrofs) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_addrstack (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) v' /\\\n  Val.inject F (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_addrstack (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))) v' /\\\n  Val.inject F (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (ofs : ptrofs)","proofString":"econstructor; split.\nconstructor.\nsimpl.\neconstructor; eauto.\nrewrite ! Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (ofs : ptrofs) : Val.inject F (Vptr sp (Ptrofs.add Ptrofs.zero ofs))\n  (Vptr sp'\n     (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr (dstk ctx))))).","conclusion":"Val.inject F (Vptr sp (Ptrofs.add Ptrofs.zero ofs))\n  (Vptr sp'\n     (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr (dstk ctx)))))","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (ofs : ptrofs)","proofString":"econstructor; eauto.\nrewrite ! Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (ofs : ptrofs) : Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr (dstk ctx))) =\nPtrofs.add (Ptrofs.add Ptrofs.zero ofs) (Ptrofs.repr (dstk ctx)).","conclusion":"Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr (dstk ctx))) =\nPtrofs.add (Ptrofs.add Ptrofs.zero ofs) (Ptrofs.repr (dstk ctx))","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (ofs : ptrofs)","proofString":"rewrite ! Ptrofs.add_zero_l; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  Val.inject F v v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  Val.inject F v v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v)","proofString":"assert (Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)).\nunfold Senv.symbol_address; simpl; unfold Genv.symbol_address.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ninv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto.\nexploit Mem.loadv_inject; eauto.\nintros (v' & A & B).\nexists v'; eauto with barg."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) : Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs).","conclusion":"Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v)","proofString":"unfold Senv.symbol_address; simpl; unfold Genv.symbol_address.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ninv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) : Val.inject F\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol tge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","conclusion":"Val.inject F\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol tge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v)","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ninv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) : Val.inject F\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","conclusion":"Val.inject F\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v)","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ninv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (b : block) (FS : Genv.find_symbol ge id = Some b) : Val.inject F (Vptr b ofs) (Vptr b ofs).","conclusion":"Val.inject F (Vptr b ofs) (Vptr b ofs)","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (b : block) (FS : Genv.find_symbol ge id = Some b)","proofString":"inv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (b : block) (FS : Genv.find_symbol ge id = Some b) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) : Val.inject F (Vptr b ofs) (Vptr b ofs).","conclusion":"Val.inject F (Vptr b ofs) (Vptr b ofs)","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (b : block) (FS : Genv.find_symbol ge id = Some b) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound)","proofString":"econstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (H0 : Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  Val.inject F v v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  Val.inject F v v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (H0 : Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs))","proofString":"exploit Mem.loadv_inject; eauto.\nintros (v' & A & B).\nexists v'; eauto with barg."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (H0 : Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)) : (exists v2 : val,\n   Mem.loadv chunk m' (Senv.symbol_address tge id ofs) = Some v2 /\\\n   Val.inject F v v2) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  Val.inject F v v'.","conclusion":"(exists v2 : val,\n   Mem.loadv chunk m' (Senv.symbol_address tge id ofs) = Some v2 /\\\n   Val.inject F v v2) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  Val.inject F v v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (H0 : Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs))","proofString":"intros (v' & A & B).\nexists v'; eauto with barg."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (H0 : Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)) (v' : val) (A : Mem.loadv chunk m' (Senv.symbol_address tge id ofs) = Some v') (B : Val.inject F v v') : exists v'0 : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v'0 /\\\n  Val.inject F v v'0.","conclusion":"exists v'0 : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v'0 /\\\n  Val.inject F v v'0","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (H0 : Val.inject F (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)) (v' : val) (A : Mem.loadv chunk m' (Senv.symbol_address tge id ofs) = Some v') (B : Val.inject F v v')","proofString":"exists v'; eauto with barg."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_addrglobal id ofs) v' /\\\n  Val.inject F (Senv.symbol_address ge id ofs) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_addrglobal id ofs) v' /\\\n  Val.inject F (Senv.symbol_address ge id ofs) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs)","proofString":"econstructor; split.\nconstructor.\nunfold Senv.symbol_address; simpl; unfold Genv.symbol_address.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ninv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs) : Val.inject F\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol tge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","conclusion":"Val.inject F\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol tge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs)","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ninv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs) : Val.inject F\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","conclusion":"Val.inject F\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs)","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ninv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs) (b : block) (FS : Genv.find_symbol ge id = Some b) : Val.inject F (Vptr b ofs) (Vptr b ofs).","conclusion":"Val.inject F (Vptr b ofs) (Vptr b ofs)","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs) (b : block) (FS : Genv.find_symbol ge id = Some b)","proofString":"inv MG.\neconstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs) (b : block) (FS : Genv.find_symbol ge id = Some b) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) : Val.inject F (Vptr b ofs) (Vptr b ofs).","conclusion":"Val.inject F (Vptr b ofs) (Vptr b ofs)","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (id : ident) (ofs : ptrofs) (b : block) (FS : Genv.find_symbol ge id = Some b) (DOMAIN : forall b0 : positive, Plt b0 bound -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound)","proofString":"econstructor.\neauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx hi) v' /\\ \n  Val.inject F vhi v') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx lo) v' /\\ \n  Val.inject F vlo v') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_splitlong (sbuiltinarg ctx hi) (sbuiltinarg ctx lo)) v' /\\\n  Val.inject F (Val.longofwords vhi vlo) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_splitlong (sbuiltinarg ctx hi) (sbuiltinarg ctx lo)) v' /\\\n  Val.inject F (Val.longofwords vhi vlo) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx hi) v' /\\ \n  Val.inject F vhi v') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx lo) v' /\\ \n  Val.inject F vlo v')","proofString":"destruct IHeval_builtin_arg1 as (v1' & A1 & B1).\ndestruct IHeval_builtin_arg2 as (v2' & A2 & B2).\neconstructor; split.\neauto with barg.\napply Val.longofwords_inject; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx hi) v1') (B1 : Val.inject F vhi v1') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx lo) v' /\\ \n  Val.inject F vlo v') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_splitlong (sbuiltinarg ctx hi) (sbuiltinarg ctx lo)) v' /\\\n  Val.inject F (Val.longofwords vhi vlo) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_splitlong (sbuiltinarg ctx hi) (sbuiltinarg ctx lo)) v' /\\\n  Val.inject F (Val.longofwords vhi vlo) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx hi) v1') (B1 : Val.inject F vhi v1') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx lo) v' /\\ \n  Val.inject F vlo v')","proofString":"destruct IHeval_builtin_arg2 as (v2' & A2 & B2).\neconstructor; split.\neauto with barg.\napply Val.longofwords_inject; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx hi) v1') (B1 : Val.inject F vhi v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx lo) v2') (B2 : Val.inject F vlo v2') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_splitlong (sbuiltinarg ctx hi) (sbuiltinarg ctx lo)) v' /\\\n  Val.inject F (Val.longofwords vhi vlo) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_splitlong (sbuiltinarg ctx hi) (sbuiltinarg ctx lo)) v' /\\\n  Val.inject F (Val.longofwords vhi vlo) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx hi) v1') (B1 : Val.inject F vhi v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx lo) v2') (B2 : Val.inject F vlo v2')","proofString":"econstructor; split.\neauto with barg.\napply Val.longofwords_inject; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (IHeval_builtin_arg1 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v' /\\ \n  Val.inject F v1 v') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a2) v' /\\ \n  Val.inject F v2 v') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_addptr (sbuiltinarg ctx a1) (sbuiltinarg ctx a2)) v' /\\\n  Val.inject F (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_addptr (sbuiltinarg ctx a1) (sbuiltinarg ctx a2)) v' /\\\n  Val.inject F (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (IHeval_builtin_arg1 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v' /\\ \n  Val.inject F v1 v') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a2) v' /\\ \n  Val.inject F v2 v')","proofString":"destruct IHeval_builtin_arg1 as (v1' & A1 & B1).\ndestruct IHeval_builtin_arg2 as (v2' & A2 & B2).\neconstructor; split.\neauto with barg.\ndestruct Archi.ptr64; auto using Val.add_inject, Val.addl_inject."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v1') (B1 : Val.inject F v1 v1') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a2) v' /\\ \n  Val.inject F v2 v') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_addptr (sbuiltinarg ctx a1) (sbuiltinarg ctx a2)) v' /\\\n  Val.inject F (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_addptr (sbuiltinarg ctx a1) (sbuiltinarg ctx a2)) v' /\\\n  Val.inject F (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v1') (B1 : Val.inject F v1 v1') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a2) v' /\\ \n  Val.inject F v2 v')","proofString":"destruct IHeval_builtin_arg2 as (v2' & A2 & B2).\neconstructor; split.\neauto with barg.\ndestruct Archi.ptr64; auto using Val.add_inject, Val.addl_inject."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v1') (B1 : Val.inject F v1 v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a2) v2') (B2 : Val.inject F v2 v2') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_addptr (sbuiltinarg ctx a1) (sbuiltinarg ctx a2)) v' /\\\n  Val.inject F (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (BA_addptr (sbuiltinarg ctx a1) (sbuiltinarg ctx a2)) v' /\\\n  Val.inject F (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (MG : match_globalenvs F bound) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (MI : Mem.inject F m m') (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v1') (B1 : Val.inject F v1 v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a2) v2') (B2 : Val.inject F v2 v2')","proofString":"econstructor; split.\neauto with barg.\ndestruct Archi.ptr64; auto using Val.add_inject, Val.addl_inject."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m') : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' nil vl' /\\ Val.inject_list F nil vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' nil vl' /\\ Val.inject_list F nil vl'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m')","proofString":"exists (@nil val); split; constructor."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m') (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F bl vl') : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (sbuiltinarg ctx a1 :: map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (sbuiltinarg ctx a1 :: map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F (b1 :: bl) vl'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m') (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F bl vl')","proofString":"exploit tr_builtin_arg; eauto.\nintros (v1' & A & B).\ndestruct IHlist_forall2 as (vl' & C & D).\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m') (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F bl vl') : (exists v' : val,\n   eval_builtin_arg tge (fun r : positive => rs' # r) \n     (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v' /\\ \n   Val.inject F b1 v') ->\nexists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (sbuiltinarg ctx a1 :: map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F (b1 :: bl) vl'.","conclusion":"(exists v' : val,\n   eval_builtin_arg tge (fun r : positive => rs' # r) \n     (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v' /\\ \n   Val.inject F b1 v') ->\nexists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (sbuiltinarg ctx a1 :: map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F (b1 :: bl) vl'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m') (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F bl vl')","proofString":"intros (v1' & A & B).\ndestruct IHlist_forall2 as (vl' & C & D).\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m') (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F bl vl') (v1' : val) (A : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v1') (B : Val.inject F b1 v1') : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (sbuiltinarg ctx a1 :: map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (sbuiltinarg ctx a1 :: map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F (b1 :: bl) vl'","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m') (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (map (sbuiltinarg ctx) al) vl' /\\\n  Val.inject_list F bl vl') (v1' : val) (A : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v1') (B : Val.inject F b1 v1')","proofString":"destruct IHlist_forall2 as (vl' & C & D).\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m') (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (vl' : list val) (C : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (map (sbuiltinarg ctx) al) vl') (D : Val.inject_list F bl vl') (v1' : val) (A : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v1') (B : Val.inject F b1 v1') : exists vl'0 : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (sbuiltinarg ctx a1 :: map (sbuiltinarg ctx) al) vl'0 /\\\n  Val.inject_list F (b1 :: bl) vl'0.","conclusion":"exists vl'0 : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m'\n    (sbuiltinarg ctx a1 :: map (sbuiltinarg ctx) al) vl'0 /\\\n  Val.inject_list F (b1 :: bl) vl'0","hypotheses":"(F : meminj) (bound : block) (ctx : context) (rs rs' : regset) (sp sp' : block) (m m' : mem) (H : match_globalenvs F bound) (H0 : agree_regs F ctx rs rs') (H1 : F sp = Some (sp', dstk ctx)) (H2 : Mem.inject F m m') (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (vl' : list val) (C : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (map (sbuiltinarg ctx) al) vl') (D : Val.inject_list F bl vl') (v1' : val) (A : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (sbuiltinarg ctx a1) v1') (B : Val.inject F b1 v1')","proofString":"exists (v1' :: vl'); split; constructor; auto."},{"statement":"(b : block) (H : match_globalenvs F b) : meminj_preserves_globals ge F.","conclusion":"meminj_preserves_globals ge F","hypotheses":"(b : block) (H : match_globalenvs F b)","proofString":"inv H.\nred.\nsplit.\neauto.\nsplit.\neauto.\nintros.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b) : meminj_preserves_globals ge F.","conclusion":"meminj_preserves_globals ge F","hypotheses":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b)","proofString":"red.\nsplit.\neauto.\nsplit.\neauto.\nintros.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b) : (forall (id : ident) (b0 : block),\n Genv.find_symbol ge id = Some b0 -> F b0 = Some (b0, 0)) /\\\n(forall (b0 : block) (gv : globvar unit),\n Genv.find_var_info ge b0 = Some gv -> F b0 = Some (b0, 0)) /\\\n(forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\n Genv.find_var_info ge b2 = Some gv -> F b1 = Some (b2, delta) -> b2 = b1).","conclusion":"(forall (id : ident) (b0 : block),\n Genv.find_symbol ge id = Some b0 -> F b0 = Some (b0, 0)) /\\\n(forall (b0 : block) (gv : globvar unit),\n Genv.find_var_info ge b0 = Some gv -> F b0 = Some (b0, 0)) /\\\n(forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\n Genv.find_var_info ge b2 = Some gv -> F b1 = Some (b2, delta) -> b2 = b1)","hypotheses":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b)","proofString":"split.\neauto.\nsplit.\neauto.\nintros.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b) : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> F b0 = Some (b0, 0).","conclusion":"forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> F b0 = Some (b0, 0)","hypotheses":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b)","proofString":"eauto."},{"statement":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b) : (forall (b0 : block) (gv : globvar unit),\n Genv.find_var_info ge b0 = Some gv -> F b0 = Some (b0, 0)) /\\\n(forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\n Genv.find_var_info ge b2 = Some gv -> F b1 = Some (b2, delta) -> b2 = b1).","conclusion":"(forall (b0 : block) (gv : globvar unit),\n Genv.find_var_info ge b0 = Some gv -> F b0 = Some (b0, 0)) /\\\n(forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\n Genv.find_var_info ge b2 = Some gv -> F b1 = Some (b2, delta) -> b2 = b1)","hypotheses":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b)","proofString":"split.\neauto.\nintros.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b) : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> F b0 = Some (b0, 0).","conclusion":"forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> F b0 = Some (b0, 0)","hypotheses":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b)","proofString":"eauto."},{"statement":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b) : forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\nGenv.find_var_info ge b2 = Some gv -> F b1 = Some (b2, delta) -> b2 = b1.","conclusion":"forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\nGenv.find_var_info ge b2 = Some gv -> F b1 = Some (b2, delta) -> b2 = b1","hypotheses":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nF b1 = Some (b2, delta) -> Plt b2 b -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 b)","proofString":"intros.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nF b0 = Some (b3, delta0) -> Plt b3 b -> b0 = b3) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv0 : globvar unit),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 b) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : F b1 = Some (b2, delta)) : b2 = b1.","conclusion":"b2 = b1","hypotheses":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nF b0 = Some (b3, delta0) -> Plt b3 b -> b0 = b3) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv0 : globvar unit),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 b) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : F b1 = Some (b2, delta))","proofString":"symmetry.\neapply IMAGE; eauto."},{"statement":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nF b0 = Some (b3, delta0) -> Plt b3 b -> b0 = b3) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv0 : globvar unit),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 b) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : F b1 = Some (b2, delta)) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(b : block) (DOMAIN : forall b0 : positive, Plt b0 b -> F b0 = Some (b0, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nF b0 = Some (b3, delta0) -> Plt b3 b -> b0 = b3) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 b) (FUNCTIONS : forall (b0 : block) (fd : fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 b) (VARINFOS : forall (b0 : block) (gv0 : globvar unit),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 b) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : F b1 = Some (b2, delta))","proofString":"eapply IMAGE; eauto."},{"statement":"(stk stk' : list stackframe) (f : function) (ctx : context) (sp : block) (rs' : regset) (H : match_stacks_inside F m m' stk stk' f ctx sp rs') : meminj_preserves_globals ge F.","conclusion":"meminj_preserves_globals ge F","hypotheses":"(stk stk' : list stackframe) (f : function) (ctx : context) (sp : block) (rs' : regset) (H : match_stacks_inside F m m' stk stk' f ctx sp rs')","proofString":"exploit match_stacks_inside_globalenvs; eauto.\nintros [b A].\neapply match_globalenvs_preserves_globals; eauto."},{"statement":"(stk stk' : list stackframe) (f : function) (ctx : context) (sp : block) (rs' : regset) (H : match_stacks_inside F m m' stk stk' f ctx sp rs') : (exists b : block, match_globalenvs F b) -> meminj_preserves_globals ge F.","conclusion":"(exists b : block, match_globalenvs F b) -> meminj_preserves_globals ge F","hypotheses":"(stk stk' : list stackframe) (f : function) (ctx : context) (sp : block) (rs' : regset) (H : match_stacks_inside F m m' stk stk' f ctx sp rs')","proofString":"intros [b A].\neapply match_globalenvs_preserves_globals; eauto."},{"statement":"(stk stk' : list stackframe) (f : function) (ctx : context) (sp : block) (rs' : regset) (H : match_stacks_inside F m m' stk stk' f ctx sp rs') (b : block) (A : match_globalenvs F b) : meminj_preserves_globals ge F.","conclusion":"meminj_preserves_globals ge F","hypotheses":"(stk stk' : list stackframe) (f : function) (ctx : context) (sp : block) (rs' : regset) (H : match_stacks_inside F m m' stk stk' f ctx sp rs') (b : block) (A : match_globalenvs F b)","proofString":"eapply match_globalenvs_preserves_globals; eauto."},{"statement":"(stk stk' : list stackframe) (bound : block) (bound1 : positive) (H : match_stacks F m m' stk stk' bound) (H0 : Ple bound bound1) : match_stacks F m m' stk stk' bound1.","conclusion":"match_stacks F m m' stk stk' bound1","hypotheses":"(stk stk' : list stackframe) (bound : block) (bound1 : positive) (H : match_stacks F m m' stk stk' bound) (H0 : Ple bound bound1)","proofString":"inv H.\napply match_stacks_nil with bound0.\nauto.\neapply Ple_trans; eauto.\neapply match_stacks_cons; eauto.\neapply Pos.lt_le_trans; eauto.\neapply match_stacks_untailcall; eauto.\neapply Pos.lt_le_trans; eauto."},{"statement":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (bound0 : block) (MG : match_globalenvs F bound0) (BELOW : Ple bound0 bound) : match_stacks F m m' nil nil bound1.","conclusion":"match_stacks F m m' nil nil bound1","hypotheses":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (bound0 : block) (MG : match_globalenvs F bound0) (BELOW : Ple bound0 bound)","proofString":"apply match_stacks_nil with bound0.\nauto.\neapply Ple_trans; eauto."},{"statement":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (bound0 : block) (MG : match_globalenvs F bound0) (BELOW : Ple bound0 bound) : match_globalenvs F bound0.","conclusion":"match_globalenvs F bound0","hypotheses":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (bound0 : block) (MG : match_globalenvs F bound0) (BELOW : Ple bound0 bound)","proofString":"auto."},{"statement":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (bound0 : block) (MG : match_globalenvs F bound0) (BELOW : Ple bound0 bound) : Ple bound0 bound1.","conclusion":"Ple bound0 bound1","hypotheses":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (bound0 : block) (MG : match_globalenvs F bound0) (BELOW : Ple bound0 bound)","proofString":"eapply Ple_trans; eauto."},{"statement":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' stk0 stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' bound) : match_stacks F m m' (Stackframe res f (Vptr sp Ptrofs.zero) pc rs :: stk0)\n  (Stackframe (sreg ctx res) f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs'\n   :: stk'0) bound1.","conclusion":"match_stacks F m m' (Stackframe res f (Vptr sp Ptrofs.zero) pc rs :: stk0)\n  (Stackframe (sreg ctx res) f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs'\n   :: stk'0) bound1","hypotheses":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' stk0 stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' bound)","proofString":"eapply match_stacks_cons; eauto.\neapply Pos.lt_le_trans; eauto."},{"statement":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' stk0 stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' bound) : Plt sp' bound1.","conclusion":"Plt sp' bound1","hypotheses":"(bound : block) (bound1 : positive) (H0 : Ple bound bound1) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' stk0 stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' bound)","proofString":"eapply Pos.lt_le_trans; eauto."},{"statement":"(stk : list stackframe) (bound : block) (bound1 : positive) (H0 : Ple bound bound1) (res : reg) (f' : function) (sp' : block) (rpc : node) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (MS : match_stacks_inside F m m' stk stk'0 f' ctx sp' rs') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RET : retinfo ctx = Some (rpc, res)) (BELOW : Plt sp' bound) : match_stacks F m m' stk\n  (Stackframe res f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0) bound1.","conclusion":"match_stacks F m m' stk\n  (Stackframe res f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0) bound1","hypotheses":"(stk : list stackframe) (bound : block) (bound1 : positive) (H0 : Ple bound bound1) (res : reg) (f' : function) (sp' : block) (rpc : node) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (MS : match_stacks_inside F m m' stk stk'0 f' ctx sp' rs') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RET : retinfo ctx = Some (rpc, res)) (BELOW : Plt sp' bound)","proofString":"eapply match_stacks_untailcall; eauto.\neapply Pos.lt_le_trans; eauto."},{"statement":"(stk : list stackframe) (bound : block) (bound1 : positive) (H0 : Ple bound bound1) (res : reg) (f' : function) (sp' : block) (rpc : node) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (MS : match_stacks_inside F m m' stk stk'0 f' ctx sp' rs') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RET : retinfo ctx = Some (rpc, res)) (BELOW : Plt sp' bound) : Plt sp' bound1.","conclusion":"Plt sp' bound1","hypotheses":"(stk : list stackframe) (bound : block) (bound1 : positive) (H0 : Ple bound bound1) (res : reg) (f' : function) (sp' : block) (rpc : node) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (MS : match_stacks_inside F m m' stk stk'0 f' ctx sp' rs') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RET : retinfo ctx = Some (rpc, res)) (BELOW : Plt sp' bound)","proofString":"eapply Pos.lt_le_trans; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') : match_stacks_inside F m m' stk stk' f' ctx sp' rs' # (sreg ctx r) <- v.","conclusion":"match_stacks_inside F m m' stk stk' f' ctx sp' rs' # (sreg ctx r) <- v","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs')","proofString":"eapply match_stacks_inside_invariant; eauto.\nintros.\napply Regmap.gso.\nzify.\nunfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') : forall r0 : positive,\nPlt r0 (dreg ctx) -> (rs' # (sreg ctx r) <- v) # r0 = rs' # r0.","conclusion":"forall r0 : positive,\nPlt r0 (dreg ctx) -> (rs' # (sreg ctx r) <- v) # r0 = rs' # r0","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs')","proofString":"intros.\napply Regmap.gso.\nzify.\nunfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (r0 : positive) (H0 : Plt r0 (dreg ctx)) : (rs' # (sreg ctx r) <- v) # r0 = rs' # r0.","conclusion":"(rs' # (sreg ctx r) <- v) # r0 = rs' # r0","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (r0 : positive) (H0 : Plt r0 (dreg ctx))","proofString":"apply Regmap.gso.\nzify.\nunfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (r0 : positive) (H0 : Plt r0 (dreg ctx)) : r0 <> sreg ctx r.","conclusion":"r0 <> sreg ctx r","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (r0 : positive) (H0 : Plt r0 (dreg ctx))","proofString":"zify.\nunfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (r0 : positive) (H0 : Plt r0 (dreg ctx)) (cstr : 0 < Z.pos r0) (cstr0 : 0 < Z.pos (sreg ctx r)) : Z.pos r0 <> Z.pos (sreg ctx r).","conclusion":"Z.pos r0 <> Z.pos (sreg ctx r)","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (r0 : positive) (H0 : Plt r0 (dreg ctx)) (cstr : 0 < Z.pos r0) (cstr0 : 0 < Z.pos (sreg ctx r))","proofString":"unfold sreg; rewrite shiftpos_eq.\nextlia."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (r0 : positive) (H0 : Plt r0 (dreg ctx)) (cstr : 0 < Z.pos r0) (cstr0 : 0 < Z.pos (sreg ctx r)) : Z.pos r0 <> Z.pos r + Z.pos (dreg ctx) - 1.","conclusion":"Z.pos r0 <> Z.pos r + Z.pos (dreg ctx) - 1","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (r : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (r0 : positive) (H0 : Plt r0 (dreg ctx)) (cstr : 0 < Z.pos r0) (cstr0 : 0 < Z.pos (sreg ctx r))","proofString":"extlia."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (res : builtin_res reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') : match_stacks_inside F m m' stk stk' f' ctx sp'\n  (regmap_setres (sbuiltinres ctx res) v rs').","conclusion":"match_stacks_inside F m m' stk stk' f' ctx sp'\n  (regmap_setres (sbuiltinres ctx res) v rs')","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (res : builtin_res reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs')","proofString":"destruct res; simpl; auto.\napply match_stacks_inside_set_reg; auto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (x : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') : match_stacks_inside F m m' stk stk' f' ctx sp' rs' # (sreg ctx x) <- v.","conclusion":"match_stacks_inside F m m' stk stk' f' ctx sp' rs' # (sreg ctx x) <- v","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (x : reg) (v : val) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs')","proofString":"apply match_stacks_inside_set_reg; auto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m1 : mem) (chunk' : memory_chunk) (b' : block) (ofs' : Z) (v' : val) (m1' : mem) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (H0 : Mem.store chunk m b ofs v = Some m1) (H1 : Mem.store chunk' m' b' ofs' v' = Some m1') : match_stacks_inside F m1 m1' stk stk' f' ctx sp' rs'.","conclusion":"match_stacks_inside F m1 m1' stk stk' f' ctx sp' rs'","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m1 : mem) (chunk' : memory_chunk) (b' : block) (ofs' : Z) (v' : val) (m1' : mem) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (H0 : Mem.store chunk m b ofs v = Some m1) (H1 : Mem.store chunk' m' b' ofs' v' = Some m1')","proofString":"eapply match_stacks_inside_invariant; eauto with mem."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) : match_stacks_inside F1 m1 m' stk stk' f' ctx sp' rs'.","conclusion":"match_stacks_inside F1 m1 m' stk stk' f' ctx sp' rs'","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx)","proofString":"eapply match_stacks_inside_base; eauto.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite H1 in H4; inv H4.\neelim Plt_strict; eauto.\nrewrite H2 in H4; auto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b1 b); intros; auto.\nsubst b1.\nrewrite H1 in H4.\ninv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) : match_stacks F1 m1 m' stk stk' sp'.","conclusion":"match_stacks F1 m1 m' stk stk' sp'","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx)","proofString":"eapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite H1 in H4; inv H4.\neelim Plt_strict; eauto.\nrewrite H2 in H4; auto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b1 b); intros; auto.\nsubst b1.\nrewrite H1 in H4.\ninv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) : forall (b1 b2 : block) (delta0 : Z),\nF1 b1 = Some (b2, delta0) -> Plt b2 sp' -> F b1 = Some (b2, delta0).","conclusion":"forall (b1 b2 : block) (delta0 : Z),\nF1 b1 = Some (b2, delta0) -> Plt b2 sp' -> F b1 = Some (b2, delta0)","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx)","proofString":"intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite H1 in H4; inv H4.\neelim Plt_strict; eauto.\nrewrite H2 in H4; auto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') : F b1 = Some (b2, delta0).","conclusion":"F b1 = Some (b2, delta0)","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp')","proofString":"destruct (eq_block b1 b).\nsubst b1.\nrewrite H1 in H4; inv H4.\neelim Plt_strict; eauto.\nrewrite H2 in H4; auto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (e : b1 = b) : F b1 = Some (b2, delta0).","conclusion":"F b1 = Some (b2, delta0)","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (e : b1 = b)","proofString":"subst b1.\nrewrite H1 in H4; inv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) (b2 : block) (delta0 : Z) (H4 : F1 b = Some (b2, delta0)) (H5 : Plt b2 sp') : F b = Some (b2, delta0).","conclusion":"F b = Some (b2, delta0)","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) (b2 : block) (delta0 : Z) (H4 : F1 b = Some (b2, delta0)) (H5 : Plt b2 sp')","proofString":"rewrite H1 in H4; inv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (rs' : regset) (b2 : block) (MS : match_stacks F m m' stk stk' b2) (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (delta0 : Z) (H1 : F1 b = Some (b2, delta0)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta0 >= dstk ctx) (H5 : Plt b2 b2) : F b = Some (b2, delta0).","conclusion":"F b = Some (b2, delta0)","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (rs' : regset) (b2 : block) (MS : match_stacks F m m' stk stk' b2) (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (delta0 : Z) (H1 : F1 b = Some (b2, delta0)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta0 >= dstk ctx) (H5 : Plt b2 b2)","proofString":"eelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (n : b1 <> b) : F b1 = Some (b2, delta0).","conclusion":"F b1 = Some (b2, delta0)","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (n : b1 <> b)","proofString":"rewrite H2 in H4; auto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) : forall (b1 b2 : block) (delta0 ofs : Z),\nF1 b1 = Some (b2, delta0) ->\nPlt b2 sp' ->\nMem.perm m1 b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty.","conclusion":"forall (b1 b2 : block) (delta0 ofs : Z),\nF1 b1 = Some (b2, delta0) ->\nPlt b2 sp' ->\nMem.perm m1 b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx)","proofString":"intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b1 b); intros; auto.\nsubst b1.\nrewrite H1 in H4.\ninv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 ofs : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b1 ofs Max Nonempty) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 ofs : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b1 ofs Max Nonempty)","proofString":"exploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b1 b); intros; auto.\nsubst b1.\nrewrite H1 in H4.\ninv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 ofs : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b1 ofs Max Nonempty) : (if eq_block b1 b then 0 <= ofs < sz else Mem.perm m b1 ofs Max Nonempty) ->\nMem.perm m b1 ofs Max Nonempty.","conclusion":"(if eq_block b1 b then 0 <= ofs < sz else Mem.perm m b1 ofs Max Nonempty) ->\nMem.perm m b1 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 ofs : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b1 ofs Max Nonempty)","proofString":"destruct (eq_block b1 b); intros; auto.\nsubst b1.\nrewrite H1 in H4.\ninv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 ofs : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b1 ofs Max Nonempty) (e : b1 = b) (H7 : 0 <= ofs < sz) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b0 : block, b0 <> b -> F1 b0 = F b0) (H3 : delta >= dstk ctx) (b1 b2 : block) (delta0 ofs : Z) (H4 : F1 b1 = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b1 ofs Max Nonempty) (e : b1 = b) (H7 : 0 <= ofs < sz)","proofString":"subst b1.\nrewrite H1 in H4.\ninv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) (b2 : block) (delta0 ofs : Z) (H4 : F1 b = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b ofs Max Nonempty) (H7 : 0 <= ofs < sz) : Mem.perm m b ofs Max Nonempty.","conclusion":"Mem.perm m b ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) (b2 : block) (delta0 ofs : Z) (H4 : F1 b = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b ofs Max Nonempty) (H7 : 0 <= ofs < sz)","proofString":"rewrite H1 in H4.\ninv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) (b2 : block) (delta0 ofs : Z) (H4 : Some (sp', delta) = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b ofs Max Nonempty) (H7 : 0 <= ofs < sz) : Mem.perm m b ofs Max Nonempty.","conclusion":"Mem.perm m b ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (H1 : F1 b = Some (sp', delta)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta >= dstk ctx) (b2 : block) (delta0 ofs : Z) (H4 : Some (sp', delta) = Some (b2, delta0)) (H5 : Plt b2 sp') (H6 : Mem.perm m1 b ofs Max Nonempty) (H7 : 0 <= ofs < sz)","proofString":"inv H4.\neelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (rs' : regset) (b2 : block) (MS : match_stacks F m m' stk stk' b2) (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (delta0 : Z) (H1 : F1 b = Some (b2, delta0)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta0 >= dstk ctx) (ofs : Z) (H5 : Plt b2 b2) (H6 : Mem.perm m1 b ofs Max Nonempty) (H7 : 0 <= ofs < sz) : Mem.perm m b ofs Max Nonempty.","conclusion":"Mem.perm m b ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (rs' : regset) (b2 : block) (MS : match_stacks F m m' stk stk' b2) (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (H : Mem.alloc m 0 sz = (m1, b)) (H0 : inject_incr F F1) (delta0 : Z) (H1 : F1 b = Some (b2, delta0)) (H2 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H3 : delta0 >= dstk ctx) (ofs : Z) (H5 : Plt b2 b2) (H6 : Mem.perm m1 b ofs Max Nonempty) (H7 : 0 <= ofs < sz)","proofString":"eelim Plt_strict; eauto."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) : match_stacks_inside F1 m1 m'\n  (Stackframe res f (Vptr sp Ptrofs.zero) pc rs :: stk) stk' f' ctx sp' rs'.","conclusion":"match_stacks_inside F1 m1 m'\n  (Stackframe res f (Vptr sp Ptrofs.zero) pc rs :: stk) stk' f' ctx sp' rs'","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx)","proofString":"eapply match_stacks_inside_inlined; eauto.\neapply IHmatch_stacks_inside; eauto.\ndestruct SBELOW.\nlia.\neapply agree_regs_incr; eauto.\neapply range_private_invariant; eauto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b0 b); intros.\nsubst b0.\nrewrite H2 in H5; inv H5.\nexfalso; extlia.\nrewrite H3 in H5; auto."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) : match_stacks_inside F1 m1 m' stk stk' f' ctx' sp' rs'.","conclusion":"match_stacks_inside F1 m1 m' stk stk' f' ctx' sp' rs'","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx)","proofString":"eapply IHmatch_stacks_inside; eauto.\ndestruct SBELOW.\nlia."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) : delta >= dstk ctx'.","conclusion":"delta >= dstk ctx'","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx)","proofString":"destruct SBELOW.\nlia."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (H5 : mstk ctx' >= 0) (H6 : dstk ctx' + mstk ctx' <= dstk ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) : delta >= dstk ctx'.","conclusion":"delta >= dstk ctx'","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (H5 : mstk ctx' >= 0) (H6 : dstk ctx' + mstk ctx' <= dstk ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx)","proofString":"lia."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) : agree_regs F1 ctx' rs rs'.","conclusion":"agree_regs F1 ctx' rs rs'","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx)","proofString":"eapply agree_regs_incr; eauto."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) : range_private F1 m1 m' sp' (dstk ctx' + mstk ctx') (dstk ctx).","conclusion":"range_private F1 m1 m' sp' (dstk ctx' + mstk ctx') (dstk ctx)","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx)","proofString":"eapply range_private_invariant; eauto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b0 b); intros.\nsubst b0.\nrewrite H2 in H5; inv H5.\nexfalso; extlia.\nrewrite H3 in H5; auto."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) : forall (b0 : block) (delta0 ofs : Z),\nF1 b0 = Some (sp', delta0) ->\nMem.perm m1 b0 ofs Max Nonempty ->\ndstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx ->\nF b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty.","conclusion":"forall (b0 : block) (delta0 ofs : Z),\nF1 b0 = Some (sp', delta0) ->\nMem.perm m1 b0 ofs Max Nonempty ->\ndstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx ->\nF b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta0 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta0) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta0 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx)","proofString":"intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b0 b); intros.\nsubst b0.\nrewrite H2 in H5; inv H5.\nexfalso; extlia.\nrewrite H3 in H5; auto."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b1 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b1) ->\ninject_incr F F0 ->\nF0 b1 = Some (sp', delta1) ->\n(forall b2 : block, b2 <> b1 -> F0 b2 = F b2) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (b0 : block) (delta0 ofs : Z) (H5 : F1 b0 = Some (sp', delta0)) (H6 : Mem.perm m1 b0 ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) : F b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty.","conclusion":"F b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b1 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b1) ->\ninject_incr F F0 ->\nF0 b1 = Some (sp', delta1) ->\n(forall b2 : block, b2 <> b1 -> F0 b2 = F b2) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (b0 : block) (delta0 ofs : Z) (H5 : F1 b0 = Some (sp', delta0)) (H6 : Mem.perm m1 b0 ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx)","proofString":"exploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b0 b); intros.\nsubst b0.\nrewrite H2 in H5; inv H5.\nexfalso; extlia.\nrewrite H3 in H5; auto."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b1 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b1) ->\ninject_incr F F0 ->\nF0 b1 = Some (sp', delta1) ->\n(forall b2 : block, b2 <> b1 -> F0 b2 = F b2) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (b0 : block) (delta0 ofs : Z) (H5 : F1 b0 = Some (sp', delta0)) (H6 : Mem.perm m1 b0 ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) : (if eq_block b0 b then 0 <= ofs < sz else Mem.perm m b0 ofs Max Nonempty) ->\nF b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty.","conclusion":"(if eq_block b0 b then 0 <= ofs < sz else Mem.perm m b0 ofs Max Nonempty) ->\nF b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b1 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b1) ->\ninject_incr F F0 ->\nF0 b1 = Some (sp', delta1) ->\n(forall b2 : block, b2 <> b1 -> F0 b2 = F b2) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (b0 : block) (delta0 ofs : Z) (H5 : F1 b0 = Some (sp', delta0)) (H6 : Mem.perm m1 b0 ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx)","proofString":"destruct (eq_block b0 b); intros.\nsubst b0.\nrewrite H2 in H5; inv H5.\nexfalso; extlia.\nrewrite H3 in H5; auto."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b1 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b1) ->\ninject_incr F F0 ->\nF0 b1 = Some (sp', delta1) ->\n(forall b2 : block, b2 <> b1 -> F0 b2 = F b2) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (b0 : block) (delta0 ofs : Z) (H5 : F1 b0 = Some (sp', delta0)) (H6 : Mem.perm m1 b0 ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) (e : b0 = b) (H8 : 0 <= ofs < sz) : F b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty.","conclusion":"F b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b1 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b1) ->\ninject_incr F F0 ->\nF0 b1 = Some (sp', delta1) ->\n(forall b2 : block, b2 <> b1 -> F0 b2 = F b2) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (b0 : block) (delta0 ofs : Z) (H5 : F1 b0 = Some (sp', delta0)) (H6 : Mem.perm m1 b0 ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) (e : b0 = b) (H8 : 0 <= ofs < sz)","proofString":"subst b0.\nrewrite H2 in H5; inv H5.\nexfalso; extlia."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta1) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (delta0 ofs : Z) (H6 : Mem.perm m1 b ofs Max Nonempty) (H5 : F1 b = Some (sp', delta0)) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) (H8 : 0 <= ofs < sz) : F b = Some (sp', delta0) /\\ Mem.perm m b ofs Max Nonempty.","conclusion":"F b = Some (sp', delta0) /\\ Mem.perm m b ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta1) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (delta0 ofs : Z) (H6 : Mem.perm m1 b ofs Max Nonempty) (H5 : F1 b = Some (sp', delta0)) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) (H8 : 0 <= ofs < sz)","proofString":"rewrite H2 in H5; inv H5.\nexfalso; extlia."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (delta0 : Z) (H2 : F1 b = Some (sp', delta0)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta0 >= dstk ctx) (ofs : Z) (H6 : Mem.perm m1 b ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) (H8 : 0 <= ofs < sz) : F b = Some (sp', delta0) /\\ Mem.perm m b ofs Max Nonempty.","conclusion":"F b = Some (sp', delta0) /\\ Mem.perm m b ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b0 : block) (F0 : meminj) (delta : Z),\nMem.alloc m 0 sz0 = (m0, b0) ->\ninject_incr F F0 ->\nF0 b0 = Some (sp', delta) ->\n(forall b1 : block, b1 <> b0 -> F0 b1 = F b1) ->\ndelta >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (delta0 : Z) (H2 : F1 b = Some (sp', delta0)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta0 >= dstk ctx) (ofs : Z) (H6 : Mem.perm m1 b ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) (H8 : 0 <= ofs < sz)","proofString":"exfalso; extlia."},{"statement":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b1 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b1) ->\ninject_incr F F0 ->\nF0 b1 = Some (sp', delta1) ->\n(forall b2 : block, b2 <> b1 -> F0 b2 = F b2) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (b0 : block) (delta0 ofs : Z) (H5 : F1 b0 = Some (sp', delta0)) (H6 : Mem.perm m1 b0 ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) (n : b0 <> b) (H8 : Mem.perm m b0 ofs Max Nonempty) : F b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty.","conclusion":"F b0 = Some (sp', delta0) /\\ Mem.perm m b0 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (res : positive) (f : function) (sp : block) (pc : node) (rs : regset) (stk stk' : list stackframe) (f' : function) (fenv : funenv) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (H : match_stacks_inside F m m' stk stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (IHmatch_stacks_inside : forall (sz0 : Z) (m0 : Mem.mem') (b1 : block) (F0 : meminj) (delta1 : Z),\nMem.alloc m 0 sz0 = (m0, b1) ->\ninject_incr F F0 ->\nF0 b1 = Some (sp', delta1) ->\n(forall b2 : block, b2 <> b1 -> F0 b2 = F b2) ->\ndelta1 >= dstk ctx' -> match_stacks_inside F0 m0 m' stk stk' f' ctx' sp' rs') (sz : Z) (m1 : Mem.mem') (b : block) (F1 : meminj) (delta : Z) (H0 : Mem.alloc m 0 sz = (m1, b)) (H1 : inject_incr F F1) (H2 : F1 b = Some (sp', delta)) (H3 : forall b1 : block, b1 <> b -> F1 b1 = F b1) (H4 : delta >= dstk ctx) (b0 : block) (delta0 ofs : Z) (H5 : F1 b0 = Some (sp', delta0)) (H6 : Mem.perm m1 b0 ofs Max Nonempty) (H7 : dstk ctx' + mstk ctx' <= ofs + delta0 < dstk ctx) (n : b0 <> b) (H8 : Mem.perm m b0 ofs Max Nonempty)","proofString":"rewrite H3 in H5; auto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp b : block) (lo hi : Z) (m1 : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m b lo hi = Some m1) : match_stacks F m1 m' stk stk' sp.","conclusion":"match_stacks F m1 m' stk stk' sp","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp b : block) (lo hi : Z) (m1 : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m b lo hi = Some m1)","proofString":"eapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp b : block) (lo hi : Z) (m1 : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m b lo hi = Some m1) : forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPlt b2 sp ->\nMem.perm m1 b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty.","conclusion":"forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPlt b2 sp ->\nMem.perm m1 b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp b : block) (lo hi : Z) (m1 : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m b lo hi = Some m1)","proofString":"intros.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp b : block) (lo hi : Z) (m1 : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m b lo hi = Some m1) (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H2 : Plt b2 sp) (H3 : Mem.perm m1 b1 ofs Max Nonempty) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp b : block) (lo hi : Z) (m1 : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m b lo hi = Some m1) (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H2 : Plt b2 sp) (H3 : Mem.perm m1 b1 ofs Max Nonempty)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1') : match_stacks F m m1' stk stk' sp.","conclusion":"match_stacks F m m1' stk stk' sp","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1')","proofString":"eapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1') : forall (b : positive) (ofs : Z),\nPlt b sp -> Mem.perm m' b ofs Cur Freeable -> Mem.perm m1' b ofs Cur Freeable.","conclusion":"forall (b : positive) (ofs : Z),\nPlt b sp -> Mem.perm m' b ofs Cur Freeable -> Mem.perm m1' b ofs Cur Freeable","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1')","proofString":"intros.\neapply Mem.perm_free_1; eauto with ordered_type."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1') (b : positive) (ofs : Z) (H1 : Plt b sp) (H2 : Mem.perm m' b ofs Cur Freeable) : Mem.perm m1' b ofs Cur Freeable.","conclusion":"Mem.perm m1' b ofs Cur Freeable","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1') (b : positive) (ofs : Z) (H1 : Plt b sp) (H2 : Mem.perm m' b ofs Cur Freeable)","proofString":"eapply Mem.perm_free_1; eauto with ordered_type."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1') : forall (b : positive) (ofs : Z) (k : perm_kind) (p : permission),\nPlt b sp -> Mem.perm m1' b ofs k p -> Mem.perm m' b ofs k p.","conclusion":"forall (b : positive) (ofs : Z) (k : perm_kind) (p : permission),\nPlt b sp -> Mem.perm m1' b ofs k p -> Mem.perm m' b ofs k p","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1')","proofString":"intros.\neapply Mem.perm_free_3; eauto."},{"statement":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1') (b : positive) (ofs : Z) (k : perm_kind) (p : permission) (H1 : Plt b sp) (H2 : Mem.perm m1' b ofs k p) : Mem.perm m' b ofs k p.","conclusion":"Mem.perm m' b ofs k p","hypotheses":"(F : meminj) (m m' : mem) (stk stk' : list stackframe) (sp : block) (lo hi : Z) (m1' : mem) (H : match_stacks F m m' stk stk' sp) (H0 : Mem.free m' sp lo hi = Some m1') (b : positive) (ofs : Z) (k : perm_kind) (p : permission) (H1 : Plt b sp) (H2 : Mem.perm m1' b ofs k p)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(sz n : Z) (H : (min_alignment sz | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) : (align_chunk chunk | n).","conclusion":"(align_chunk chunk | n)","hypotheses":"(sz n : Z) (H : (min_alignment sz | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz)","proofString":"unfold min_alignment in H.\nassert (2 <= sz -> (2 | n)).\nintros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nauto.\ndestruct (zle sz 4).\napply Z.divide_trans with 4; auto.\nexists 2; auto.\napply Z.divide_trans with 8; auto.\nexists 4; auto.\nassert (4 <= sz -> (4 | n)).\nintros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nauto.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nassert (8 <= sz -> (8 | n)).\nintros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nextlia.\nauto.\ndestruct chunk; simpl in *; auto using Z.divide_1_l.\napply H2; lia.\napply H2; lia."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) : (align_chunk chunk | n).","conclusion":"(align_chunk chunk | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz)","proofString":"assert (2 <= sz -> (2 | n)).\nintros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nauto.\ndestruct (zle sz 4).\napply Z.divide_trans with 4; auto.\nexists 2; auto.\napply Z.divide_trans with 8; auto.\nexists 4; auto.\nassert (4 <= sz -> (4 | n)).\nintros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nauto.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nassert (8 <= sz -> (8 | n)).\nintros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nextlia.\nauto.\ndestruct chunk; simpl in *; auto using Z.divide_1_l.\napply H2; lia.\napply H2; lia."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) : 2 <= sz -> (2 | n).","conclusion":"2 <= sz -> (2 | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz)","proofString":"intros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nauto.\ndestruct (zle sz 4).\napply Z.divide_trans with 4; auto.\nexists 2; auto.\napply Z.divide_trans with 8; auto.\nexists 4; auto."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz) : (2 | n).","conclusion":"(2 | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz)","proofString":"destruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nauto.\ndestruct (zle sz 4).\napply Z.divide_trans with 4; auto.\nexists 2; auto.\napply Z.divide_trans with 8; auto.\nexists 4; auto."},{"statement":"(sz n : Z) (l : sz <= 1) (H : (1 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz) : (2 | n).","conclusion":"(2 | n)","hypotheses":"(sz n : Z) (l : sz <= 1) (H : (1 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz)","proofString":"extlia."},{"statement":"(sz n : Z) (g : sz > 1) (H : (if zle sz 2 then 2 else if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz) : (2 | n).","conclusion":"(2 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (H : (if zle sz 2 then 2 else if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz)","proofString":"destruct (zle sz 2).\nauto.\ndestruct (zle sz 4).\napply Z.divide_trans with 4; auto.\nexists 2; auto.\napply Z.divide_trans with 8; auto.\nexists 4; auto."},{"statement":"(sz n : Z) (g : sz > 1) (l : sz <= 2) (H : (2 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz) : (2 | n).","conclusion":"(2 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (l : sz <= 2) (H : (2 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz)","proofString":"auto."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (H : (if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz) : (2 | n).","conclusion":"(2 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (H : (if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz)","proofString":"destruct (zle sz 4).\napply Z.divide_trans with 4; auto.\nexists 2; auto.\napply Z.divide_trans with 8; auto.\nexists 4; auto."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (l : sz <= 4) (H : (4 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz) : (2 | n).","conclusion":"(2 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (l : sz <= 4) (H : (4 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz)","proofString":"apply Z.divide_trans with 4; auto.\nexists 2; auto."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (l : sz <= 4) (H : (4 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz) : (2 | 4).","conclusion":"(2 | 4)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (l : sz <= 4) (H : (4 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz)","proofString":"exists 2; auto."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz) : (2 | n).","conclusion":"(2 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz)","proofString":"apply Z.divide_trans with 8; auto.\nexists 4; auto."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz) : (2 | 8).","conclusion":"(2 | 8)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz)","proofString":"exists 4; auto."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) : (align_chunk chunk | n).","conclusion":"(align_chunk chunk | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n))","proofString":"assert (4 <= sz -> (4 | n)).\nintros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nauto.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nassert (8 <= sz -> (8 | n)).\nintros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nextlia.\nauto.\ndestruct chunk; simpl in *; auto using Z.divide_1_l.\napply H2; lia.\napply H2; lia."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) : 4 <= sz -> (4 | n).","conclusion":"4 <= sz -> (4 | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n))","proofString":"intros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nauto.\napply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz) : (4 | n).","conclusion":"(4 | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz)","proofString":"destruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nauto.\napply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(sz n : Z) (l : sz <= 1) (H : (1 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz) : (4 | n).","conclusion":"(4 | n)","hypotheses":"(sz n : Z) (l : sz <= 1) (H : (1 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz)","proofString":"extlia."},{"statement":"(sz n : Z) (g : sz > 1) (H : (if zle sz 2 then 2 else if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz) : (4 | n).","conclusion":"(4 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (H : (if zle sz 2 then 2 else if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz)","proofString":"destruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nauto.\napply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(sz n : Z) (g : sz > 1) (l : sz <= 2) (H : (2 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz) : (4 | n).","conclusion":"(4 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (l : sz <= 2) (H : (2 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz)","proofString":"extlia."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (H : (if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz) : (4 | n).","conclusion":"(4 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (H : (if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz)","proofString":"destruct (zle sz 4).\nauto.\napply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (l : sz <= 4) (H : (4 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz) : (4 | n).","conclusion":"(4 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (l : sz <= 4) (H : (4 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz)","proofString":"auto."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz) : (4 | n).","conclusion":"(4 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz)","proofString":"apply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz) : (4 | 8).","conclusion":"(4 | 8)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz)","proofString":"exists 2; auto."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) : (align_chunk chunk | n).","conclusion":"(align_chunk chunk | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n))","proofString":"assert (8 <= sz -> (8 | n)).\nintros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nextlia.\nauto.\ndestruct chunk; simpl in *; auto using Z.divide_1_l.\napply H2; lia.\napply H2; lia."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) : 8 <= sz -> (8 | n).","conclusion":"8 <= sz -> (8 | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n))","proofString":"intros.\ndestruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nextlia.\nauto."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz) : (8 | n).","conclusion":"(8 | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz)","proofString":"destruct (zle sz 1).\nextlia.\ndestruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nextlia.\nauto."},{"statement":"(sz n : Z) (l : sz <= 1) (H : (1 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz) : (8 | n).","conclusion":"(8 | n)","hypotheses":"(sz n : Z) (l : sz <= 1) (H : (1 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz)","proofString":"extlia."},{"statement":"(sz n : Z) (g : sz > 1) (H : (if zle sz 2 then 2 else if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz) : (8 | n).","conclusion":"(8 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (H : (if zle sz 2 then 2 else if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz)","proofString":"destruct (zle sz 2).\nextlia.\ndestruct (zle sz 4).\nextlia.\nauto."},{"statement":"(sz n : Z) (g : sz > 1) (l : sz <= 2) (H : (2 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz) : (8 | n).","conclusion":"(8 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (l : sz <= 2) (H : (2 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz)","proofString":"extlia."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (H : (if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz) : (8 | n).","conclusion":"(8 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (H : (if zle sz 4 then 4 else 8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz)","proofString":"destruct (zle sz 4).\nextlia.\nauto."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (l : sz <= 4) (H : (4 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz) : (8 | n).","conclusion":"(8 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (l : sz <= 4) (H : (4 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz)","proofString":"extlia."},{"statement":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz) : (8 | n).","conclusion":"(8 | n)","hypotheses":"(sz n : Z) (g : sz > 1) (g0 : sz > 2) (g1 : sz > 4) (H : (8 | n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz)","proofString":"auto."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz -> (8 | n)) : (align_chunk chunk | n).","conclusion":"(align_chunk chunk | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (chunk : memory_chunk) (H0 : size_chunk chunk <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz -> (8 | n))","proofString":"destruct chunk; simpl in *; auto using Z.divide_1_l.\napply H2; lia.\napply H2; lia."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (H0 : 8 <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz -> (8 | n)) : (4 | n).","conclusion":"(4 | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (H0 : 8 <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz -> (8 | n))","proofString":"apply H2; lia."},{"statement":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (H0 : 8 <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz -> (8 | n)) : (4 | n).","conclusion":"(4 | n)","hypotheses":"(sz n : Z) (H : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8\n| n)) (H0 : 8 <= sz) (H1 : 2 <= sz -> (2 | n)) (H2 : 4 <= sz -> (4 | n)) (H3 : 8 <= sz -> (8 | n))","proofString":"apply H2; lia."},{"statement":"(n amount : Z) (H : amount > 0) (H0 : (amount | n)) : align n amount = n.","conclusion":"align n amount = n","hypotheses":"(n amount : Z) (H : amount > 0) (H0 : (amount | n))","proofString":"destruct H0 as [p EQ].\nsubst n.\nunfold align.\ndecEq.\napply Zdiv_unique with (b := amount - 1).\nlia.\nlia."},{"statement":"(n amount : Z) (H : amount > 0) (p : Z) (EQ : n = p * amount) : align n amount = n.","conclusion":"align n amount = n","hypotheses":"(n amount : Z) (H : amount > 0) (p : Z) (EQ : n = p * amount)","proofString":"subst n.\nunfold align.\ndecEq.\napply Zdiv_unique with (b := amount - 1).\nlia.\nlia."},{"statement":"(amount : Z) (H : amount > 0) (p : Z) : align (p * amount) amount = p * amount.","conclusion":"align (p * amount) amount = p * amount","hypotheses":"(amount : Z) (H : amount > 0) (p : Z)","proofString":"unfold align.\ndecEq.\napply Zdiv_unique with (b := amount - 1).\nlia.\nlia."},{"statement":"(amount : Z) (H : amount > 0) (p : Z) : (p * amount + amount - 1) / amount * amount = p * amount.","conclusion":"(p * amount + amount - 1) / amount * amount = p * amount","hypotheses":"(amount : Z) (H : amount > 0) (p : Z)","proofString":"decEq.\napply Zdiv_unique with (b := amount - 1).\nlia.\nlia."},{"statement":"(amount : Z) (H : amount > 0) (p : Z) : (p * amount + amount - 1) / amount = p.","conclusion":"(p * amount + amount - 1) / amount = p","hypotheses":"(amount : Z) (H : amount > 0) (p : Z)","proofString":"apply Zdiv_unique with (b := amount - 1).\nlia.\nlia."},{"statement":"(amount : Z) (H : amount > 0) (p : Z) : p * amount + amount - 1 = p * amount + (amount - 1).","conclusion":"p * amount + amount - 1 = p * amount + (amount - 1)","hypotheses":"(amount : Z) (H : amount > 0) (p : Z)","proofString":"lia."},{"statement":"(amount : Z) (H : amount > 0) (p : Z) : 0 <= amount - 1 < amount.","conclusion":"0 <= amount - 1 < amount","hypotheses":"(amount : Z) (H : amount > 0) (p : Z)","proofString":"lia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) : match_stacks_inside F m m' stk stk' f' ctx' sp' rs'.","conclusion":"match_stacks_inside F m m' stk stk' f' ctx' sp' rs'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H : match_stacks_inside F m m' stk stk' f' ctx sp' rs') (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f'))","proofString":"inv H.\neapply match_stacks_inside_base; eauto.\ncongruence.\nrewrite H1.\nrewrite DSTK.\napply align_unchanged.\napply min_alignment_pos.\napply Z.divide_0_r.\nassert (dstk ctx <= dstk ctx').\nrewrite H1.\napply align_le.\napply min_alignment_pos.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply H3.\ninv H4.\nextlia.\ncongruence.\nunfold context_below in *.\nextlia.\nunfold context_stack_call in *.\nlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : match_stacks_inside F m m' stk stk' f' ctx' sp' rs'.","conclusion":"match_stacks_inside F m m' stk stk' f' ctx' sp' rs'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"eapply match_stacks_inside_base; eauto.\ncongruence.\nrewrite H1.\nrewrite DSTK.\napply align_unchanged.\napply min_alignment_pos.\napply Z.divide_0_r."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : retinfo ctx' = None.","conclusion":"retinfo ctx' = None","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"congruence."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : dstk ctx' = 0.","conclusion":"dstk ctx' = 0","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"rewrite H1.\nrewrite DSTK.\napply align_unchanged.\napply min_alignment_pos.\napply Z.divide_0_r."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : align (dstk ctx) (min_alignment (fn_stacksize f)) = 0.","conclusion":"align (dstk ctx) (min_alignment (fn_stacksize f)) = 0","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"rewrite DSTK.\napply align_unchanged.\napply min_alignment_pos.\napply Z.divide_0_r."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : align 0 (min_alignment (fn_stacksize f)) = 0.","conclusion":"align 0 (min_alignment (fn_stacksize f)) = 0","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"apply align_unchanged.\napply min_alignment_pos.\napply Z.divide_0_r."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : min_alignment (fn_stacksize f) > 0.","conclusion":"min_alignment (fn_stacksize f) > 0","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"apply min_alignment_pos."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : (min_alignment (fn_stacksize f) | 0).","conclusion":"(min_alignment (fn_stacksize f) | 0)","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (MS : match_stacks F m m' stk stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"apply Z.divide_0_r."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) : match_stacks_inside F m m'\n  (Stackframe res f0 (Vptr sp Ptrofs.zero) pc rs :: stk0) stk' f' ctx' sp'\n  rs'.","conclusion":"match_stacks_inside F m m'\n  (Stackframe res f0 (Vptr sp Ptrofs.zero) pc rs :: stk0) stk' f' ctx' sp'\n  rs'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx)","proofString":"assert (dstk ctx <= dstk ctx').\nrewrite H1.\napply align_le.\napply min_alignment_pos.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply H3.\ninv H4.\nextlia.\ncongruence.\nunfold context_below in *.\nextlia.\nunfold context_stack_call in *.\nlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) : dstk ctx <= dstk ctx'.","conclusion":"dstk ctx <= dstk ctx'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx)","proofString":"rewrite H1.\napply align_le.\napply min_alignment_pos."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) : dstk ctx <= align (dstk ctx) (min_alignment (fn_stacksize f)).","conclusion":"dstk ctx <= align (dstk ctx) (min_alignment (fn_stacksize f))","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx)","proofString":"apply align_le.\napply min_alignment_pos."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) : min_alignment (fn_stacksize f) > 0.","conclusion":"min_alignment (fn_stacksize f) > 0","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx)","proofString":"apply min_alignment_pos."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') : match_stacks_inside F m m'\n  (Stackframe res f0 (Vptr sp Ptrofs.zero) pc rs :: stk0) stk' f' ctx' sp'\n  rs'.","conclusion":"match_stacks_inside F m m'\n  (Stackframe res f0 (Vptr sp Ptrofs.zero) pc rs :: stk0) stk' f' ctx' sp'\n  rs'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx')","proofString":"eapply match_stacks_inside_inlined; eauto.\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply H3.\ninv H4.\nextlia.\ncongruence.\nunfold context_below in *.\nextlia.\nunfold context_stack_call in *.\nlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx').","conclusion":"range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx')","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx')","proofString":"red; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply H3.\ninv H4.\nextlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx') : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx')","proofString":"destruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply H3.\ninv H4.\nextlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx') (l : ofs < dstk ctx) : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx') (l : ofs < dstk ctx)","proofString":"apply PAD; lia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx') (g : ofs >= dstk ctx) : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx') (g : ofs >= dstk ctx)","proofString":"apply H3.\ninv H4.\nextlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx') (g : ofs >= dstk ctx) : dstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx <= ofs < fn_stacksize f'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx') (g : ofs >= dstk ctx)","proofString":"inv H4.\nextlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx') (g : ofs >= dstk ctx) (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx')) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx' pc0 i (fn_code f')) (H8 : mstk ctx' = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx')) (H10 : dstk ctx' >= 0) (H11 : dstk ctx' + mstk ctx' <= fn_stacksize f') : dstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx <= ofs < fn_stacksize f'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') (ofs : Z) (H5 : dstk ctx'0 + mstk ctx'0 <= ofs < dstk ctx') (g : ofs >= dstk ctx) (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx')) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx' pc0 i (fn_code f')) (H8 : mstk ctx' = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx')) (H10 : dstk ctx' >= 0) (H11 : dstk ctx' + mstk ctx' <= fn_stacksize f')","proofString":"extlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') : retinfo ctx' = Some (spc ctx'0 pc, sreg ctx'0 res).","conclusion":"retinfo ctx' = Some (spc ctx'0 pc, sreg ctx'0 res)","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx')","proofString":"congruence."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') : context_below ctx'0 ctx'.","conclusion":"context_below ctx'0 ctx'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx')","proofString":"unfold context_below in *.\nextlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : Ple (dreg ctx + mreg ctx) (dreg ctx')) (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : Ple (dreg ctx'0 + mreg ctx'0) (dreg ctx)) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') : Ple (dreg ctx'0 + mreg ctx'0) (dreg ctx').","conclusion":"Ple (dreg ctx'0 + mreg ctx'0) (dreg ctx')","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : Ple (dreg ctx + mreg ctx) (dreg ctx')) (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : Ple (dreg ctx'0 + mreg ctx'0) (dreg ctx)) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx')","proofString":"extlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx') : context_stack_call ctx'0 ctx'.","conclusion":"context_stack_call ctx'0 ctx'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : context_stack_call ctx'0 ctx) (H : dstk ctx <= dstk ctx')","proofString":"unfold context_stack_call in *.\nlia."},{"statement":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : mstk ctx'0 >= 0 /\\ dstk ctx'0 + mstk ctx'0 <= dstk ctx) (H : dstk ctx <= dstk ctx') : mstk ctx'0 >= 0 /\\ dstk ctx'0 + mstk ctx'0 <= dstk ctx'.","conclusion":"mstk ctx'0 >= 0 /\\ dstk ctx'0 + mstk ctx'0 <= dstk ctx'","hypotheses":"(fenv : funenv) (F : meminj) (m m' : mem) (stk' : list stackframe) (f' : function) (ctx : context) (sp' : block) (rs' : regset) (ctx' : context) (f : function) (H0 : context_below ctx ctx') (H1 : context_stack_tailcall ctx f ctx') (H2 : retinfo ctx' = retinfo ctx) (H3 : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (H4 : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (res : positive) (f0 : function) (sp : block) (pc : node) (rs : regset) (stk0 : list stackframe) (fenv0 : funenv) (ctx'0 : context) (MS : match_stacks_inside F m m' stk0 stk' f' ctx'0 sp' rs') (COMPAT : fenv_compat prog fenv0) (FB : tr_funbody fenv0 (fn_stacksize f') ctx'0 f0 (fn_code f')) (AG : agree_regs F ctx'0 rs rs') (SP : F sp = Some (sp', dstk ctx'0)) (PAD : range_private F m m' sp' (dstk ctx'0 + mstk ctx'0) (dstk ctx)) (RES : Ple res (mreg ctx'0)) (RET : retinfo ctx = Some (spc ctx'0 pc, sreg ctx'0 res)) (BELOW : context_below ctx'0 ctx) (SBELOW : mstk ctx'0 >= 0 /\\ dstk ctx'0 + mstk ctx'0 <= dstk ctx) (H : dstk ctx <= dstk ctx')","proofString":"lia."},{"statement":"(fenv : funenv) (sz : Z) (cts : context) (f : function) (c : code) (pc : positive) (i : instruction) (H : tr_funbody fenv sz cts f c) (H0 : (fn_code f) ! pc = Some i) : tr_instr fenv sz cts pc i c.","conclusion":"tr_instr fenv sz cts pc i c","hypotheses":"(fenv : funenv) (sz : Z) (cts : context) (f : function) (c : code) (pc : positive) (i : instruction) (H : tr_funbody fenv sz cts f c) (H0 : (fn_code f) ! pc = Some i)","proofString":"inv H.\neauto."},{"statement":"(fenv : funenv) (sz : Z) (cts : context) (f : function) (c : code) (pc : positive) (i : instruction) (H0 : (fn_code f) ! pc = Some i) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg cts)) (H2 : forall (pc0 : positive) (i0 : instruction),\n(fn_code f) ! pc0 = Some i0 -> tr_instr fenv sz cts pc0 i0 c) (H3 : mstk cts = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk cts)) (H5 : dstk cts >= 0) (H6 : dstk cts + mstk cts <= sz) : tr_instr fenv sz cts pc i c.","conclusion":"tr_instr fenv sz cts pc i c","hypotheses":"(fenv : funenv) (sz : Z) (cts : context) (f : function) (c : code) (pc : positive) (i : instruction) (H0 : (fn_code f) ! pc = Some i) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg cts)) (H2 : forall (pc0 : positive) (i0 : instruction),\n(fn_code f) ! pc0 = Some i0 -> tr_instr fenv sz cts pc0 i0 c) (H3 : mstk cts = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk cts)) (H5 : dstk cts >= 0) (H6 : dstk cts + mstk cts <= sz)","proofString":"eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : tr_instr fenv (fn_stacksize f') ctx pc (Inop pc') (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Inop pc') (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros TR; inv TR.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H3 : (fn_code f') ! (spc ctx pc) = Some (Inop (spc ctx pc'))) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H3 : (fn_code f') ! (spc ctx pc) = Some (Inop (spc ctx pc')))","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nexploit eval_operation_inject.\neapply match_stacks_inside_globals; eauto.\neexact SP.\ninstantiate (2 := rs##args).\ninstantiate (1 := rs'##(sregs ctx args)).\neapply agree_val_regs; eauto.\neexact MINJ.\neauto.\nfold (sop ctx op).\nintros [v' [A B]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nerewrite eval_operation_preserved; eauto.\nexact symbols_preserved.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : tr_instr fenv (fn_stacksize f') ctx pc (Iop op args res pc') (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Iop op args res pc') (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros TR; inv TR.\nexploit eval_operation_inject.\neapply match_stacks_inside_globals; eauto.\neexact SP.\ninstantiate (2 := rs##args).\ninstantiate (1 := rs'##(sregs ctx args)).\neapply agree_val_regs; eauto.\neexact MINJ.\neauto.\nfold (sop ctx op).\nintros [v' [A B]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nerewrite eval_operation_preserved; eauto.\nexact symbols_preserved.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc')))","proofString":"exploit eval_operation_inject.\neapply match_stacks_inside_globals; eauto.\neexact SP.\ninstantiate (2 := rs##args).\ninstantiate (1 := rs'##(sregs ctx args)).\neapply agree_val_regs; eauto.\neexact MINJ.\neauto.\nfold (sop ctx op).\nintros [v' [A B]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nerewrite eval_operation_preserved; eauto.\nexact symbols_preserved.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) : Val.inject_list F rs ## args rs' ## (sregs ctx args).","conclusion":"Val.inject_list F rs ## args rs' ## (sregs ctx args)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc')))","proofString":"eapply agree_val_regs; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) : (exists v2 : val,\n   eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op)\n     rs' ## (sregs ctx args) m' = Some v2 /\\ Val.inject F v v2) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists v2 : val,\n   eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op)\n     rs' ## (sregs ctx args) m' = Some v2 /\\ Val.inject F v v2) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc')))","proofString":"intros [v' [A B]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nerewrite eval_operation_preserved; eauto.\nexact symbols_preserved.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op) \n  rs' ## (sregs ctx args) m' = Some v') (B : Val.inject F v v') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op) \n  rs' ## (sregs ctx args) m' = Some v') (B : Val.inject F v v')","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nerewrite eval_operation_preserved; eauto.\nexact symbols_preserved.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op) \n  rs' ## (sregs ctx args) m' = Some v') (B : Val.inject F v v') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op) \n  rs' ## (sregs ctx args) m' = Some v') (B : Val.inject F v v')","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op) \n  rs' ## (sregs ctx args) m' = Some v') (B : Val.inject F v v') : match_stacks_inside F m m' s stk' f' ctx sp' rs' # (sreg ctx res) <- v'.","conclusion":"match_stacks_inside F m m' s stk' f' ctx sp' rs' # (sreg ctx res) <- v'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op) \n  rs' ## (sregs ctx args) m' = Some v') (B : Val.inject F v v')","proofString":"apply match_stacks_inside_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op) \n  rs' ## (sregs ctx args) m' = Some v') (B : Val.inject F v v') : agree_regs F ctx rs # res <- v rs' # (sreg ctx res) <- v'.","conclusion":"agree_regs F ctx rs # res <- v rs' # (sreg ctx res) <- v'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : Ple res (mreg ctx)) (H9 : (fn_code f') ! (spc ctx pc) =\nSome (Iop (sop ctx op) (sregs ctx args) (sreg ctx res) (spc ctx pc'))) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero) (sop ctx op) \n  rs' ## (sregs ctx args) m' = Some v') (B : Val.inject F v v')","proofString":"apply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nexploit eval_addressing_inject.\neapply match_stacks_inside_globals; eauto.\neexact SP.\ninstantiate (2 := rs##args).\ninstantiate (1 := rs'##(sregs ctx args)).\neapply agree_val_regs; eauto.\neauto.\nfold (saddr ctx addr).\nintros [a' [P Q]].\nexploit Mem.loadv_inject; eauto.\nintros [v' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : tr_instr fenv (fn_stacksize f') ctx pc (Iload chunk addr args dst pc')\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Iload chunk addr args dst pc')\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros TR; inv TR.\nexploit eval_addressing_inject.\neapply match_stacks_inside_globals; eauto.\neexact SP.\ninstantiate (2 := rs##args).\ninstantiate (1 := rs'##(sregs ctx args)).\neapply agree_val_regs; eauto.\neauto.\nfold (saddr ctx addr).\nintros [a' [P Q]].\nexploit Mem.loadv_inject; eauto.\nintros [v' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc')))","proofString":"exploit eval_addressing_inject.\neapply match_stacks_inside_globals; eauto.\neexact SP.\ninstantiate (2 := rs##args).\ninstantiate (1 := rs'##(sregs ctx args)).\neapply agree_val_regs; eauto.\neauto.\nfold (saddr ctx addr).\nintros [a' [P Q]].\nexploit Mem.loadv_inject; eauto.\nintros [v' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) : Val.inject_list F rs ## args rs' ## (sregs ctx args).","conclusion":"Val.inject_list F rs ## args rs' ## (sregs ctx args)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc')))","proofString":"eapply agree_val_regs; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) : (exists v2 : val,\n   eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n     rs' ## (sregs ctx args) = Some v2 /\\ Val.inject F a v2) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists v2 : val,\n   eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n     rs' ## (sregs ctx args) = Some v2 /\\ Val.inject F a v2) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc')))","proofString":"intros [a' [P Q]].\nexploit Mem.loadv_inject; eauto.\nintros [v' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a')","proofString":"exploit Mem.loadv_inject; eauto.\nintros [v' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') : (exists v2 : val, Mem.loadv chunk m' a' = Some v2 /\\ Val.inject F v v2) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists v2 : val, Mem.loadv chunk m' a' = Some v2 /\\ Val.inject F v v2) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a')","proofString":"intros [v' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v')","proofString":"assert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a'.","conclusion":"eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v')","proofString":"rewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) =\neval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args).","conclusion":"eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) =\neval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v')","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v')","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a')","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') : match_stacks_inside F m m' s stk' f' ctx sp' rs' # (sreg ctx dst) <- v'.","conclusion":"match_stacks_inside F m m' s stk' f' ctx sp' rs' # (sreg ctx dst) <- v'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a')","proofString":"apply match_stacks_inside_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') : agree_regs F ctx rs # dst <- v rs' # (sreg ctx dst) <- v'.","conclusion":"agree_regs F ctx rs # dst <- v rs' # (sreg ctx dst) <- v'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : Ple dst (mreg ctx)) (H11 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Iload chunk (saddr ctx addr) (sregs ctx args) (sreg ctx dst) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') (Q : Val.inject F a a') (v' : val) (U : Mem.loadv chunk m' a' = Some v') (V : Val.inject F v v') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a')","proofString":"apply agree_set_reg; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nexploit eval_addressing_inject.\neapply match_stacks_inside_globals; eauto.\neexact SP.\ninstantiate (2 := rs##args).\ninstantiate (1 := rs'##(sregs ctx args)).\neapply agree_val_regs; eauto.\neauto.\nfold saddr.\nintros [a' [P Q]].\nexploit Mem.storev_mapped_inject; eauto.\neapply agree_val_reg; eauto.\nintros [m1' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Istore; eauto.\ndestruct a; simpl in H1; try discriminate.\ndestruct a'; simpl in U; try discriminate.\neconstructor; eauto.\neapply match_stacks_inside_store; eauto.\neapply Mem.store_valid_block_1; eauto.\neapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto.\nintros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : tr_instr fenv (fn_stacksize f') ctx pc (Istore chunk addr args src pc')\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Istore chunk addr args src pc')\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros TR; inv TR.\nexploit eval_addressing_inject.\neapply match_stacks_inside_globals; eauto.\neexact SP.\ninstantiate (2 := rs##args).\ninstantiate (1 := rs'##(sregs ctx args)).\neapply agree_val_regs; eauto.\neauto.\nfold saddr.\nintros [a' [P Q]].\nexploit Mem.storev_mapped_inject; eauto.\neapply agree_val_reg; eauto.\nintros [m1' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Istore; eauto.\ndestruct a; simpl in H1; try discriminate.\ndestruct a'; simpl in U; try discriminate.\neconstructor; eauto.\neapply match_stacks_inside_store; eauto.\neapply Mem.store_valid_block_1; eauto.\neapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto.\nintros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc')))","proofString":"exploit eval_addressing_inject.\neapply match_stacks_inside_globals; eauto.\neexact SP.\ninstantiate (2 := rs##args).\ninstantiate (1 := rs'##(sregs ctx args)).\neapply agree_val_regs; eauto.\neauto.\nfold saddr.\nintros [a' [P Q]].\nexploit Mem.storev_mapped_inject; eauto.\neapply agree_val_reg; eauto.\nintros [m1' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Istore; eauto.\ndestruct a; simpl in H1; try discriminate.\ndestruct a'; simpl in U; try discriminate.\neconstructor; eauto.\neapply match_stacks_inside_store; eauto.\neapply Mem.store_valid_block_1; eauto.\neapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto.\nintros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) : Val.inject_list F rs ## args rs' ## (sregs ctx args).","conclusion":"Val.inject_list F rs ## args rs' ## (sregs ctx args)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc')))","proofString":"eapply agree_val_regs; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) : (exists v2 : val,\n   eval_addressing ge (Vptr sp' Ptrofs.zero)\n     (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\n   Some v2 /\\ Val.inject F a v2) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists v2 : val,\n   eval_addressing ge (Vptr sp' Ptrofs.zero)\n     (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\n   Some v2 /\\ Val.inject F a v2) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc')))","proofString":"intros [a' [P Q]].\nexploit Mem.storev_mapped_inject; eauto.\neapply agree_val_reg; eauto.\nintros [m1' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Istore; eauto.\ndestruct a; simpl in H1; try discriminate.\ndestruct a'; simpl in U; try discriminate.\neconstructor; eauto.\neapply match_stacks_inside_store; eauto.\neapply Mem.store_valid_block_1; eauto.\neapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto.\nintros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a')","proofString":"exploit Mem.storev_mapped_inject; eauto.\neapply agree_val_reg; eauto.\nintros [m1' [U V]].\nassert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Istore; eauto.\ndestruct a; simpl in H1; try discriminate.\ndestruct a'; simpl in U; try discriminate.\neconstructor; eauto.\neapply match_stacks_inside_store; eauto.\neapply Mem.store_valid_block_1; eauto.\neapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto.\nintros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1')","proofString":"assert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').\nrewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Istore; eauto.\ndestruct a; simpl in H1; try discriminate.\ndestruct a'; simpl in U; try discriminate.\neconstructor; eauto.\neapply match_stacks_inside_store; eauto.\neapply Mem.store_valid_block_1; eauto.\neapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto.\nintros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a'.","conclusion":"eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1')","proofString":"rewrite <- P.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) =\neval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args).","conclusion":"eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) =\neval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1')","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1')","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F a a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a')","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Istore; eauto.\ndestruct a; simpl in H1; try discriminate.\ndestruct a'; simpl in U; try discriminate.\neconstructor; eauto.\neapply match_stacks_inside_store; eauto.\neapply Mem.store_valid_block_1; eauto.\neapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto.\nintros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F (Vptr b i) a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a') : match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc') rs' m1').","conclusion":"match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc') rs' m1')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (a' : val) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) = \nSome a') (Q : Val.inject F (Vptr b i) a') (m1' : mem) (U : Mem.storev chunk m'0 a' rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some a')","proofString":"destruct a'; simpl in U; try discriminate.\neconstructor; eauto.\neapply match_stacks_inside_store; eauto.\neapply Mem.store_valid_block_1; eauto.\neapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto.\nintros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) : match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc') rs' m1').","conclusion":"match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc') rs' m1')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0))","proofString":"econstructor; eauto.\neapply match_stacks_inside_store; eauto.\neapply Mem.store_valid_block_1; eauto.\neapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto.\nintros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) : match_stacks_inside F m' m1' s stk' f' ctx sp' rs'.","conclusion":"match_stacks_inside F m' m1' s stk' f' ctx sp' rs'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0))","proofString":"eapply match_stacks_inside_store; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) : Mem.valid_block m1' sp'.","conclusion":"Mem.valid_block m1' sp'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0))","proofString":"eapply Mem.store_valid_block_1; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) : range_private F m' m1' sp' (dstk ctx + mstk ctx) (fn_stacksize f').","conclusion":"range_private F m' m1' sp' (dstk ctx + mstk ctx) (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0))","proofString":"eapply range_private_invariant; eauto.\nintros; split; auto.\neapply Mem.perm_store_2; eauto.\nintros; eapply Mem.perm_store_1; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) : forall (b1 : block) (delta ofs : Z),\nF b1 = Some (sp', delta) ->\nMem.perm m' b1 ofs Max Nonempty ->\ndstk ctx + mstk ctx <= ofs + delta < fn_stacksize f' ->\nF b1 = Some (sp', delta) /\\ Mem.perm m b1 ofs Max Nonempty.","conclusion":"forall (b1 : block) (delta ofs : Z),\nF b1 = Some (sp', delta) ->\nMem.perm m' b1 ofs Max Nonempty ->\ndstk ctx + mstk ctx <= ofs + delta < fn_stacksize f' ->\nF b1 = Some (sp', delta) /\\ Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0))","proofString":"intros; split; auto.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) (b1 : block) (delta ofs : Z) (H3 : F b1 = Some (sp', delta)) (H4 : Mem.perm m' b1 ofs Max Nonempty) (H5 : dstk ctx + mstk ctx <= ofs + delta < fn_stacksize f') : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) (b1 : block) (delta ofs : Z) (H3 : F b1 = Some (sp', delta)) (H4 : Mem.perm m' b1 ofs Max Nonempty) (H5 : dstk ctx + mstk ctx <= ofs + delta < fn_stacksize f')","proofString":"eapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) : forall ofs : Z,\nMem.perm m'0 sp' ofs Cur Freeable -> Mem.perm m1' sp' ofs Cur Freeable.","conclusion":"forall ofs : Z,\nMem.perm m'0 sp' ofs Cur Freeable -> Mem.perm m1' sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0))","proofString":"intros; eapply Mem.perm_store_1; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) : forall ofs : Z,\nMem.perm m1' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'.","conclusion":"forall ofs : Z,\nMem.perm m1' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0))","proofString":"intros.\neapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) (ofs : Z) (H3 : Mem.perm m1' sp' ofs Max Nonempty) : 0 <= ofs <= fn_stacksize f'.","conclusion":"0 <= ofs <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) (ofs : Z) (H3 : Mem.perm m1' sp' ofs Max Nonempty)","proofString":"eapply SSZ2.\neapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) (ofs : Z) (H3 : Mem.perm m1' sp' ofs Max Nonempty) : Mem.perm m'0 sp' ofs Max Nonempty.","conclusion":"Mem.perm m'0 sp' ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Istore chunk (saddr ctx addr) (sregs ctx args) \n     (sreg ctx src) (spc ctx pc'))) (b0 : block) (i0 : ptrofs) (P : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (shift_stack_addressing (dstk ctx) addr) rs' ## (sregs ctx args) =\nSome (Vptr b0 i0)) (Q : Val.inject F (Vptr b i) (Vptr b0 i0)) (m1' : mem) (U : Mem.store chunk m'0 b0 (Ptrofs.unsigned i0) rs' # (sreg ctx src) = Some m1') (V : Mem.inject F m' m1') (H2 : eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr)\n  rs' ## (sregs ctx args) = Some (Vptr b0 i0)) (ofs : Z) (H3 : Mem.perm m1' sp' ofs Max Nonempty)","proofString":"eapply Mem.perm_store_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit match_stacks_inside_globalenvs; eauto.\nintros [bound G].\nexploit find_function_agree; eauto.\nintros (cu & fd' & A & B & C).\nexploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_cons; eauto.\neapply agree_val_regs; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists b : block, match_globalenvs F b) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists b : block, match_globalenvs F b) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros [bound G].\nexploit find_function_agree; eauto.\nintros (cu & fd' & A & B & C).\nexploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_cons; eauto.\neapply agree_val_regs; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound)","proofString":"exploit find_function_agree; eauto.\nintros (cu & fd' & A & B & C).\nexploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_cons; eauto.\neapply agree_val_regs; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) : (exists (cu : program) (fd' : fundef),\n   find_function tge (sros ctx ros) rs' = Some fd' /\\\n   transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists (cu : program) (fd' : fundef),\n   find_function tge (sros ctx ros) rs' = Some fd' /\\\n   transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound)","proofString":"intros (cu & fd' & A & B & C).\nexploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_cons; eauto.\neapply agree_val_regs; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog)","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_cons; eauto.\neapply agree_val_regs; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) : tr_instr fenv (fn_stacksize f') ctx pc (Icall (funsig fd) ros args res pc')\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Icall (funsig fd) ros args res pc')\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog)","proofString":"intros TR; inv TR.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_cons; eauto.\neapply agree_val_regs; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H9 : Ple res (mreg ctx)) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Icall (funsig fd) (sros ctx ros) (sregs ctx args) \n     (sreg ctx res) (spc ctx pc'))) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H9 : Ple res (mreg ctx)) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Icall (funsig fd) (sros ctx ros) (sregs ctx args) \n     (sreg ctx res) (spc ctx pc')))","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_cons; eauto.\neapply agree_val_regs; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H9 : Ple res (mreg ctx)) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Icall (funsig fd) (sros ctx ros) (sregs ctx args) \n     (sreg ctx res) (spc ctx pc'))) : funsig fd' = funsig fd.","conclusion":"funsig fd' = funsig fd","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H9 : Ple res (mreg ctx)) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Icall (funsig fd) (sros ctx ros) (sregs ctx args) \n     (sreg ctx res) (spc ctx pc')))","proofString":"eapply sig_function_translated; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H9 : Ple res (mreg ctx)) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Icall (funsig fd) (sros ctx ros) (sregs ctx args) \n     (sreg ctx res) (spc ctx pc'))) : match_stacks F m m' (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n  (Stackframe (sreg ctx res) f' (Vptr sp' Ptrofs.zero) (spc ctx pc') rs'\n   :: stk') (Mem.nextblock m').","conclusion":"match_stacks F m m' (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n  (Stackframe (sreg ctx res) f' (Vptr sp' Ptrofs.zero) (spc ctx pc') rs'\n   :: stk') (Mem.nextblock m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H9 : Ple res (mreg ctx)) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Icall (funsig fd) (sros ctx ros) (sregs ctx args) \n     (sreg ctx res) (spc ctx pc')))","proofString":"eapply match_stacks_cons; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H9 : Ple res (mreg ctx)) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Icall (funsig fd) (sros ctx ros) (sregs ctx args) \n     (sreg ctx res) (spc ctx pc'))) : Val.inject_list F rs ## args rs' ## (sregs ctx args).","conclusion":"Val.inject_list F rs ## args rs' ## (sregs ctx args)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H9 : Ple res (mreg ctx)) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Icall (funsig fd) (sros ctx ros) (sregs ctx args) \n     (sreg ctx res) (spc ctx pc')))","proofString":"eapply agree_val_regs; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (id : positive) (H0 : find_function ge (inr id) rs = Some fd) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr id) args res pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (f0 : function) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (id : positive) (H0 : find_function ge (inr id) rs = Some fd) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr id) args res pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (f0 : function) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"assert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (id : positive) (H0 : find_function ge (inr id) rs = Some fd) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr id) args res pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (f0 : function) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (EQ : fd = Internal f0) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n      rs ## args m) < measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m) (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (id : positive) (H0 : find_function ge (inr id) rs = Some fd) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr id) args res pc')) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (f0 : function) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (EQ : fd = Internal f0)","proofString":"subst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (Internal f0) rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n      (Internal f0) rs ## args m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (Internal f0) rs ## args m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (Internal f0) rs ## args m) S2') \\/\n(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n      (Internal f0) rs ## args m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (Internal f0) rs ## args m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"right; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : (measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n      (Internal f0) rs ## args m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat.","conclusion":"(measure\n   (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n      (Internal f0) rs ## args m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"simpl; lia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : E0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (Internal f0) rs ## args m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"E0 = E0 /\\\nmatch_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (Internal f0) rs ## args m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"split.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : E0 = E0.","conclusion":"E0 = E0","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : match_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (Internal f0) rs ## args m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"match_states\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (Internal f0) rs ## args m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"econstructor; eauto.\neapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia.\napply agree_val_regs_gen; auto.\nred; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : match_stacks_inside F m m'\n  (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) stk' f' ctx' sp' rs'.","conclusion":"match_stacks_inside F m m'\n  (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) stk' f' ctx' sp' rs'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"eapply match_stacks_inside_inlined; eauto.\nred; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : range_private F m m' sp' (dstk ctx + mstk ctx) (dstk ctx').","conclusion":"range_private F m m' sp' (dstk ctx + mstk ctx) (dstk ctx')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"red; intros.\napply PRIV.\ninv H13.\ndestruct H16.\nextlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (ofs : Z) (H1 : dstk ctx + mstk ctx <= ofs < dstk ctx') : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (ofs : Z) (H1 : dstk ctx + mstk ctx <= ofs < dstk ctx')","proofString":"apply PRIV.\ninv H13.\ndestruct H16.\nextlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (ofs : Z) (H1 : dstk ctx + mstk ctx <= ofs < dstk ctx') : dstk ctx + mstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx + mstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (ofs : Z) (H1 : dstk ctx + mstk ctx <= ofs < dstk ctx')","proofString":"inv H13.\ndestruct H16.\nextlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (ofs : Z) (H1 : dstk ctx + mstk ctx <= ofs < dstk ctx') (H2 : forall r : reg, In r (fn_params f0) -> Ple r (mreg ctx')) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f0) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx' pc0 i (fn_code f')) (H4 : mstk ctx' = Z.max (fn_stacksize f0) 0) (H5 : (min_alignment (fn_stacksize f0) | dstk ctx')) (H9 : dstk ctx' >= 0) (H10 : dstk ctx' + mstk ctx' <= fn_stacksize f') : dstk ctx + mstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx + mstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (ofs : Z) (H1 : dstk ctx + mstk ctx <= ofs < dstk ctx') (H2 : forall r : reg, In r (fn_params f0) -> Ple r (mreg ctx')) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f0) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx' pc0 i (fn_code f')) (H4 : mstk ctx' = Z.max (fn_stacksize f0) 0) (H5 : (min_alignment (fn_stacksize f0) | dstk ctx')) (H9 : dstk ctx' >= 0) (H10 : dstk ctx' + mstk ctx' <= fn_stacksize f')","proofString":"destruct H16.\nextlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H12 : mstk ctx >= 0) (H13 : dstk ctx + mstk ctx <= dstk ctx') (ofs : Z) (H1 : dstk ctx + mstk ctx <= ofs < dstk ctx') (H2 : forall r : reg, In r (fn_params f0) -> Ple r (mreg ctx')) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f0) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx' pc0 i (fn_code f')) (H4 : mstk ctx' = Z.max (fn_stacksize f0) 0) (H5 : (min_alignment (fn_stacksize f0) | dstk ctx')) (H9 : dstk ctx' >= 0) (H10 : dstk ctx' + mstk ctx' <= fn_stacksize f') : dstk ctx + mstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx + mstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H12 : mstk ctx >= 0) (H13 : dstk ctx + mstk ctx <= dstk ctx') (ofs : Z) (H1 : dstk ctx + mstk ctx <= ofs < dstk ctx') (H2 : forall r : reg, In r (fn_params f0) -> Ple r (mreg ctx')) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f0) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx' pc0 i (fn_code f')) (H4 : mstk ctx' = Z.max (fn_stacksize f0) 0) (H5 : (min_alignment (fn_stacksize f0) | dstk ctx')) (H9 : dstk ctx' >= 0) (H10 : dstk ctx' + mstk ctx' <= fn_stacksize f')","proofString":"extlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : list_forall2 (val_reg_charact F ctx rs') rs ## args args.","conclusion":"list_forall2 (val_reg_charact F ctx rs') rs ## args args","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"apply agree_val_regs_gen; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') : range_private F m m' sp' (dstk ctx') (fn_stacksize f').","conclusion":"range_private F m m' sp' (dstk ctx') (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx')","proofString":"red; intros; apply PRIV.\ndestruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f') : dstk ctx + mstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx + mstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H16 : context_stack_call ctx ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f')","proofString":"destruct H16.\nlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H2 : mstk ctx >= 0) (H3 : dstk ctx + mstk ctx <= dstk ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f') : dstk ctx + mstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx + mstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (args : list reg) (res : reg) (pc' : node) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Icall (funsig (Internal f0)) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (pc1 : node) (ctx' : context) (H6 : Ple res (mreg ctx)) (H7 : fenv ! id = Some f0) (H8 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H11 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H13 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H14 : retinfo ctx' = Some (spc ctx pc', sreg ctx res)) (H15 : context_below ctx ctx') (H2 : mstk ctx >= 0) (H3 : dstk ctx + mstk ctx <= dstk ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f')","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit match_stacks_inside_globalenvs; eauto.\nintros [bound G].\nexploit find_function_agree; eauto.\nintros (cu & fd' & A & B & C).\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\neapply range_private_free_left; eauto.\ninv FB.\nrewrite <- H4.\nauto.\nexploit tr_funbody_inv; eauto.\nintros TR; inv TR.\ninv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_untailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\neapply agree_val_regs; eauto.\neapply Mem.free_left_inject; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists b : block, match_globalenvs F b) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists b : block, match_globalenvs F b) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros [bound G].\nexploit find_function_agree; eauto.\nintros (cu & fd' & A & B & C).\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\neapply range_private_free_left; eauto.\ninv FB.\nrewrite <- H4.\nauto.\nexploit tr_funbody_inv; eauto.\nintros TR; inv TR.\ninv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_untailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\neapply agree_val_regs; eauto.\neapply Mem.free_left_inject; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound)","proofString":"exploit find_function_agree; eauto.\nintros (cu & fd' & A & B & C).\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\neapply range_private_free_left; eauto.\ninv FB.\nrewrite <- H4.\nauto.\nexploit tr_funbody_inv; eauto.\nintros TR; inv TR.\ninv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_untailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\neapply agree_val_regs; eauto.\neapply Mem.free_left_inject; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) : (exists (cu : program) (fd' : fundef),\n   find_function tge (sros ctx ros) rs' = Some fd' /\\\n   transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists (cu : program) (fd' : fundef),\n   find_function tge (sros ctx ros) rs' = Some fd' /\\\n   transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound)","proofString":"intros (cu & fd' & A & B & C).\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\neapply range_private_free_left; eauto.\ninv FB.\nrewrite <- H4.\nauto.\nexploit tr_funbody_inv; eauto.\nintros TR; inv TR.\ninv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_untailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\neapply agree_val_regs; eauto.\neapply Mem.free_left_inject; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog)","proofString":"assert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\neapply range_private_free_left; eauto.\ninv FB.\nrewrite <- H4.\nauto.\nexploit tr_funbody_inv; eauto.\nintros TR; inv TR.\ninv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_untailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\neapply agree_val_regs; eauto.\neapply Mem.free_left_inject; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f').","conclusion":"range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog)","proofString":"eapply range_private_free_left; eauto.\ninv FB.\nrewrite <- H4.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) : range_private F m m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f').","conclusion":"range_private F m m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog)","proofString":"inv FB.\nrewrite <- H4.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : dstk ctx + mstk ctx <= fn_stacksize f') : range_private F m m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f').","conclusion":"range_private F m m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"rewrite <- H4.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : dstk ctx + mstk ctx <= fn_stacksize f') : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f').","conclusion":"range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f'))","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\ninv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_untailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\neapply agree_val_regs; eauto.\neapply Mem.free_left_inject; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) : tr_instr fenv (fn_stacksize f') ctx pc (Itailcall (funsig fd) ros args)\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Itailcall (funsig fd) ros args)\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f'))","proofString":"intros TR; inv TR.\ninv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_untailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\neapply agree_val_regs; eauto.\neapply Mem.free_left_inject; eauto.\nassert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None)","proofString":"inv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"assert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : {m1' : mem | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}.","conclusion":"{m1' : mem | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"apply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : Mem.range_perm m'0 sp' 0 (fn_stacksize f') Cur Freeable.","conclusion":"Mem.range_perm m'0 sp' 0 (fn_stacksize f') Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"red; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') : Mem.perm m'0 sp' ofs Cur Freeable.","conclusion":"Mem.perm m'0 sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f')","proofString":"destruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\nextlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f) : Mem.perm m'0 sp' ofs Cur Freeable.","conclusion":"Mem.perm m'0 sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f)","proofString":"replace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f) : Mem.perm m'0 sp' (ofs + dstk ctx) Cur Freeable.","conclusion":"Mem.perm m'0 sp' (ofs + dstk ctx) Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f)","proofString":"eapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f) : Mem.perm m stk ofs Cur Freeable.","conclusion":"Mem.perm m stk ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f)","proofString":"eapply Mem.free_range_perm; eauto.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f) : 0 <= ofs < fn_stacksize f.","conclusion":"0 <= ofs < fn_stacksize f","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f)","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) : Mem.perm m'0 sp' ofs Cur Freeable.","conclusion":"Mem.perm m'0 sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f)","proofString":"inv FB.\neapply range_private_perms; eauto.\nextlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H5 : mstk ctx = Z.max (fn_stacksize f) 0) (H6 : (min_alignment (fn_stacksize f) | dstk ctx)) (H7 : dstk ctx >= 0) (H10 : dstk ctx + mstk ctx <= fn_stacksize f') : Mem.perm m'0 sp' ofs Cur Freeable.","conclusion":"Mem.perm m'0 sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H5 : mstk ctx = Z.max (fn_stacksize f) 0) (H6 : (min_alignment (fn_stacksize f) | dstk ctx)) (H7 : dstk ctx >= 0) (H10 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"eapply range_private_perms; eauto.\nextlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H5 : mstk ctx = Z.max (fn_stacksize f) 0) (H6 : (min_alignment (fn_stacksize f) | dstk ctx)) (H7 : dstk ctx >= 0) (H10 : dstk ctx + mstk ctx <= fn_stacksize f') : dstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H5 : mstk ctx = Z.max (fn_stacksize f) 0) (H6 : (min_alignment (fn_stacksize f) | dstk ctx)) (H7 : dstk ctx >= 0) (H10 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"extlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (X : {m1' : mem | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (X : {m1' : mem | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'})","proofString":"destruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\neapply agree_val_regs; eauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : funsig fd' = funsig fd.","conclusion":"funsig fd' = funsig fd","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"eapply sig_function_translated; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPlt b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty.","conclusion":"forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPlt b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"intros.\neapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Plt b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Plt b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : forall (b : positive) (ofs : Z),\nPlt b sp' ->\nMem.perm m'0 b ofs Cur Freeable -> Mem.perm m1' b ofs Cur Freeable.","conclusion":"forall (b : positive) (ofs : Z),\nPlt b sp' ->\nMem.perm m'0 b ofs Cur Freeable -> Mem.perm m1' b ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"intros.\neapply Mem.perm_free_1; eauto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b : positive) (ofs : Z) (H1 : Plt b sp') (H3 : Mem.perm m'0 b ofs Cur Freeable) : Mem.perm m1' b ofs Cur Freeable.","conclusion":"Mem.perm m1' b ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b : positive) (ofs : Z) (H1 : Plt b sp') (H3 : Mem.perm m'0 b ofs Cur Freeable)","proofString":"eapply Mem.perm_free_1; eauto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : forall (b : positive) (ofs : Z) (k : perm_kind) (p : permission),\nPlt b sp' -> Mem.perm m1' b ofs k p -> Mem.perm m'0 b ofs k p.","conclusion":"forall (b : positive) (ofs : Z) (k : perm_kind) (p : permission),\nPlt b sp' -> Mem.perm m1' b ofs k p -> Mem.perm m'0 b ofs k p","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"intros.\neapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b : positive) (ofs : Z) (k : perm_kind) (p : permission) (H1 : Plt b sp') (H3 : Mem.perm m1' b ofs k p) : Mem.perm m'0 b ofs k p.","conclusion":"Mem.perm m'0 b ofs k p","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b : positive) (ofs : Z) (k : perm_kind) (p : permission) (H1 : Plt b sp') (H3 : Mem.perm m1' b ofs k p)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : Ple sp' (Mem.nextblock m1').","conclusion":"Ple sp' (Mem.nextblock m1')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"erewrite Mem.nextblock_free; eauto.\nred in VB; extlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : Ple sp' (Mem.nextblock m'0).","conclusion":"Ple sp' (Mem.nextblock m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"red in VB; extlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : Mem.inject F m' m'0.","conclusion":"Mem.inject F m' m'0","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"eapply Mem.free_left_inject; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nF b1 = Some (sp', delta) ->\nMem.perm m' b1 ofs k p -> 0 <= ofs + delta < fn_stacksize f' -> False.","conclusion":"forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nF b1 = Some (sp', delta) ->\nMem.perm m' b1 ofs k p -> 0 <= ofs + delta < fn_stacksize f' -> False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"intros.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f')","proofString":"rewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f')","proofString":"exploit (PRIV' (ofs + delta)).\nlia.\nintros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') : 0 <= ofs + delta < fn_stacksize f'.","conclusion":"0 <= ofs + delta < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f')","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') : loc_private F m' m'0 sp' (ofs + delta) -> False.","conclusion":"loc_private F m' m'0 sp' (ofs + delta) -> False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f')","proofString":"intros [P Q].\neelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (P : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (Q : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (P : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (Q : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty)","proofString":"eelim Q; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (P : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (Q : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty) : Mem.perm m' b1 (ofs + delta - delta) Max Nonempty.","conclusion":"Mem.perm m' b1 (ofs + delta - delta) Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (P : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (Q : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty)","proofString":"replace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (P : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (Q : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty) : Mem.perm m' b1 ofs Max Nonempty.","conclusion":"Mem.perm m' b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (P : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (Q : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty)","proofString":"apply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (P : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (Q : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty) : Mem.perm m' b1 ofs k Nonempty.","conclusion":"Mem.perm m' b1 ofs k Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Itailcall (funsig fd) (sros ctx ros) (sregs ctx args))) (H9 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (P : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (Q : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty)","proofString":"apply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res)) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res))","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neapply match_stacks_untailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\neapply agree_val_regs; eauto.\neapply Mem.free_left_inject; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res)) : funsig fd' = funsig fd.","conclusion":"funsig fd' = funsig fd","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res))","proofString":"eapply sig_function_translated; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res)) : match_stacks_inside F m' m'0 s stk' f' ctx sp' rs'.","conclusion":"match_stacks_inside F m' m'0 s stk' f' ctx sp' rs'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res))","proofString":"eapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res)) : forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPle b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty.","conclusion":"forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPle b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res))","proofString":"intros.\neapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res)) (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Ple b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx ros) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (res : reg) (s0 : node) (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icall (funsig fd) (sros ctx ros) (sregs ctx args) res s0)) (H9 : retinfo ctx = Some (s0, res)) (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Ple b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (fd : fundef) (m' : mem) (id : positive) (H0 : find_function ge (inr id) rs = Some fd) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr id) args)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (f0 : function) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (fd : fundef) (m' : mem) (id : positive) (H0 : find_function ge (inr id) rs = Some fd) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr id) args)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (f0 : function) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx')","proofString":"assert (EQ: fd = Internal f0) by (eapply find_inlined_function; eauto).\nsubst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (fd : fundef) (m' : mem) (id : positive) (H0 : find_function ge (inr id) rs = Some fd) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr id) args)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (f0 : function) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (EQ : fd = Internal f0) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s fd rs ## args m') S2') \\/\n(measure (Callstate s fd rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s fd rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (fd : fundef) (m' : mem) (id : positive) (H0 : find_function ge (inr id) rs = Some fd) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr id) args)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) fd = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (f0 : function) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (EQ : fd = Internal f0)","proofString":"subst fd.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s (Internal f0) rs ## args m') S2') \\/\n(measure (Callstate s (Internal f0) rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s (Internal f0) rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\ match_states (Callstate s (Internal f0) rs ## args m') S2') \\/\n(measure (Callstate s (Internal f0) rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s (Internal f0) rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx')","proofString":"right; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') : (measure (Callstate s (Internal f0) rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat.","conclusion":"(measure (Callstate s (Internal f0) rs ## args m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx')","proofString":"simpl; lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') : E0 = E0 /\\\nmatch_states (Callstate s (Internal f0) rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"E0 = E0 /\\\nmatch_states (Callstate s (Internal f0) rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx')","proofString":"split.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') : E0 = E0.","conclusion":"E0 = E0","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx')","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') : match_states (Callstate s (Internal f0) rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"match_states (Callstate s (Internal f0) rs ## args m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx')","proofString":"econstructor; eauto.\neapply match_stacks_inside_inlined_tailcall; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\napply agree_val_regs_gen; auto.\neapply Mem.free_left_inject; eauto.\nred; intros; apply PRIV'.\nassert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') : match_stacks_inside F m' m'0 s stk' f' ctx sp' rs'.","conclusion":"match_stacks_inside F m' m'0 s stk' f' ctx sp' rs'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx')","proofString":"eapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') : forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPle b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty.","conclusion":"forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPle b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx')","proofString":"intros.\neapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Ple b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Ple b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f') : dstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f')","proofString":"assert (dstk ctx <= dstk ctx').\nred in H14; rewrite H14.\napply align_le.\napply min_alignment_pos.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f') : dstk ctx <= dstk ctx'.","conclusion":"dstk ctx <= dstk ctx'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f')","proofString":"red in H14; rewrite H14.\napply align_le.\napply min_alignment_pos."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : dstk ctx' = align (dstk ctx) (min_alignment (fn_stacksize f0))) (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f') : dstk ctx <= align (dstk ctx) (min_alignment (fn_stacksize f0)).","conclusion":"dstk ctx <= align (dstk ctx) (min_alignment (fn_stacksize f0))","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : dstk ctx' = align (dstk ctx) (min_alignment (fn_stacksize f0))) (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f')","proofString":"apply align_le.\napply min_alignment_pos."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : dstk ctx' = align (dstk ctx) (min_alignment (fn_stacksize f0))) (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f') : min_alignment (fn_stacksize f0) > 0.","conclusion":"min_alignment (fn_stacksize f0) > 0","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : dstk ctx' = align (dstk ctx) (min_alignment (fn_stacksize f0))) (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f')","proofString":"apply min_alignment_pos."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f') (H3 : dstk ctx <= dstk ctx') : dstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (args : list reg) (m' : mem) (id : positive) (f0 : function) (H : (fn_code f) ! pc = Some (Itailcall (funsig (Internal f0)) (inr id) args)) (H0 : find_function ge (inr id) rs = Some (Internal f0)) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (bound : block) (G : match_globalenvs F bound) (cu : program) (fd' : fundef) (A : find_function tge (sros ctx (inr id)) rs' = Some fd') (B : transf_fundef (funenv_program cu) (Internal f0) = OK fd') (C : linkorder cu prog) (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) (pc1 : node) (ctx' : context) (H5 : fenv ! id = Some f0) (H6 : (fn_code f') ! (spc ctx pc) = Some (Inop pc1)) (H7 : tr_moves (fn_code f') pc1 (sregs ctx args) (sregs ctx' (fn_params f0))\n  (spc ctx' (fn_entrypoint f0))) (H8 : tr_funbody fenv (fn_stacksize f') ctx' f0 (fn_code f')) (H11 : retinfo ctx' = retinfo ctx) (H13 : context_below ctx ctx') (H14 : context_stack_tailcall ctx f0 ctx') (ofs : Z) (H1 : dstk ctx' <= ofs < fn_stacksize f') (H3 : dstk ctx <= dstk ctx')","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nexploit match_stacks_inside_globalenvs; eauto.\nintros [bound MG].\nexploit tr_builtin_args; eauto.\nintros (vargs' & P & Q).\nexploit external_call_mem_inject; eauto.\neapply match_stacks_inside_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ibuiltin; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_inside_set_res.\neapply match_stacks_inside_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\neauto.\nauto.\ndestruct res; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.\nauto.\nauto.\neapply external_call_valid_block; eauto.\neapply range_private_extcall; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\nintros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : tr_instr fenv (fn_stacksize f') ctx pc (Ibuiltin ef args res pc')\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Ibuiltin ef args res pc')\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros TR; inv TR.\nexploit match_stacks_inside_globalenvs; eauto.\nintros [bound MG].\nexploit tr_builtin_args; eauto.\nintros (vargs' & P & Q).\nexploit external_call_mem_inject; eauto.\neapply match_stacks_inside_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ibuiltin; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_inside_set_res.\neapply match_stacks_inside_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\neauto.\nauto.\ndestruct res; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.\nauto.\nauto.\neapply external_call_valid_block; eauto.\neapply range_private_extcall; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\nintros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc')))","proofString":"exploit match_stacks_inside_globalenvs; eauto.\nintros [bound MG].\nexploit tr_builtin_args; eauto.\nintros (vargs' & P & Q).\nexploit external_call_mem_inject; eauto.\neapply match_stacks_inside_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ibuiltin; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_inside_set_res.\neapply match_stacks_inside_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\neauto.\nauto.\ndestruct res; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.\nauto.\nauto.\neapply external_call_valid_block; eauto.\neapply range_private_extcall; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\nintros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) : (exists b : block, match_globalenvs F b) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists b : block, match_globalenvs F b) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc')))","proofString":"intros [bound MG].\nexploit tr_builtin_args; eauto.\nintros (vargs' & P & Q).\nexploit external_call_mem_inject; eauto.\neapply match_stacks_inside_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ibuiltin; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_inside_set_res.\neapply match_stacks_inside_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\neauto.\nauto.\ndestruct res; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.\nauto.\nauto.\neapply external_call_valid_block; eauto.\neapply range_private_extcall; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\nintros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound)","proofString":"exploit tr_builtin_args; eauto.\nintros (vargs' & P & Q).\nexploit external_call_mem_inject; eauto.\neapply match_stacks_inside_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ibuiltin; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_inside_set_res.\neapply match_stacks_inside_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\neauto.\nauto.\ndestruct res; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.\nauto.\nauto.\neapply external_call_valid_block; eauto.\neapply range_private_extcall; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\nintros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) : (exists vl' : list val,\n   eval_builtin_args tge (fun r : positive => rs' # r) \n     (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vl' /\\\n   Val.inject_list F vargs vl') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists vl' : list val,\n   eval_builtin_args tge (fun r : positive => rs' # r) \n     (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vl' /\\\n   Val.inject_list F vargs vl') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound)","proofString":"intros (vargs' & P & Q).\nexploit external_call_mem_inject; eauto.\neapply match_stacks_inside_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ibuiltin; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_inside_set_res.\neapply match_stacks_inside_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\neauto.\nauto.\ndestruct res; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.\nauto.\nauto.\neapply external_call_valid_block; eauto.\neapply range_private_extcall; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\nintros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs')","proofString":"exploit external_call_mem_inject; eauto.\neapply match_stacks_inside_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ibuiltin; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_inside_set_res.\neapply match_stacks_inside_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\neauto.\nauto.\ndestruct res; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.\nauto.\nauto.\neapply external_call_valid_block; eauto.\neapply range_private_extcall; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\nintros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') : meminj_preserves_globals ge F.","conclusion":"meminj_preserves_globals ge F","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs')","proofString":"eapply match_stacks_inside_globals; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') : (exists (f'0 : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge vargs' m'0 t vres' m2' /\\\n   Val.inject f'0 vres vres' /\\\n   Mem.inject f'0 m' m2' /\\\n   Mem.unchanged_on (loc_unmapped F) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach F m) m'0 m2' /\\\n   inject_incr F f'0 /\\ inject_separated F f'0 m m'0) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists (f'0 : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge vargs' m'0 t vres' m2' /\\\n   Val.inject f'0 vres vres' /\\\n   Mem.inject f'0 m' m2' /\\\n   Mem.unchanged_on (loc_unmapped F) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach F m) m'0 m2' /\\\n   inject_incr F f'0 /\\ inject_separated F f'0 m m'0) ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs')","proofString":"intros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ibuiltin; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_inside_set_res.\neapply match_stacks_inside_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\neauto.\nauto.\ndestruct res; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.\nauto.\nauto.\neapply external_call_valid_block; eauto.\neapply range_private_extcall; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\nintros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(measure\n   (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Ibuiltin; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_inside_set_res.\neapply match_stacks_inside_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\neauto.\nauto.\ndestruct res; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.\nauto.\nauto.\neapply external_call_valid_block; eauto.\neapply range_private_extcall; eauto.\nintros; eapply external_call_max_perm; eauto.\nauto.\nintros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"apply senv_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m b -> Mem.perm m' b ofs Max p -> Mem.perm m b ofs Max p.","conclusion":"forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m b -> Mem.perm m' b ofs Max p -> Mem.perm m b ofs Max p","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"intros; eapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m'0 b -> Mem.perm m1' b ofs Max p -> Mem.perm m'0 b ofs Max p.","conclusion":"forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m'0 b -> Mem.perm m1' b ofs Max p -> Mem.perm m'0 b ofs Max p","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"intros; eapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : Mem.valid_block m1' sp'.","conclusion":"Mem.valid_block m1' sp'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"eapply external_call_valid_block; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m b -> Mem.perm m' b ofs Max p -> Mem.perm m b ofs Max p.","conclusion":"forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m b -> Mem.perm m' b ofs Max p -> Mem.perm m b ofs Max p","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"intros; eapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : 0 <= fn_stacksize f' < Ptrofs.max_unsigned.","conclusion":"0 <= fn_stacksize f' < Ptrofs.max_unsigned","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : forall ofs : Z,\nMem.perm m1' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'.","conclusion":"forall ofs : Z,\nMem.perm m1' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"intros.\napply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) (ofs : Z) (H2 : Mem.perm m1' sp' ofs Max Nonempty) : 0 <= ofs <= fn_stacksize f'.","conclusion":"0 <= ofs <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) (ofs : Z) (H2 : Mem.perm m1' sp' ofs Max Nonempty)","proofString":"apply SSZ2.\neapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) (ofs : Z) (H2 : Mem.perm m1' sp' ofs Max Nonempty) : Mem.perm m'0 sp' ofs Max Nonempty.","conclusion":"Mem.perm m'0 sp' ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H9 : match res with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend) (H10 : (fn_code f') ! (spc ctx pc) =\nSome\n  (Ibuiltin ef (map (sbuiltinarg ctx) args) (sbuiltinres ctx res)\n     (spc ctx pc'))) (bound : block) (MG : match_globalenvs F bound) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m'0 (map (sbuiltinarg ctx) args) vargs') (Q : Val.inject_list F vargs vargs') (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge vargs' m'0 t v1 m1') (B : Val.inject F1 vres v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) (ofs : Z) (H2 : Mem.perm m1' sp' ofs Max Nonempty)","proofString":"eapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nassert (eval_condition cond rs'##(sregs ctx args) m' = Some b).\neapply eval_condition_inject; eauto.\neapply agree_val_regs; eauto.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icond; eauto.\ndestruct b; econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : tr_instr fenv (fn_stacksize f') ctx pc (Icond cond args ifso ifnot)\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Icond cond args ifso ifnot)\n  (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros TR; inv TR.\nassert (eval_condition cond rs'##(sregs ctx args) m' = Some b).\neapply eval_condition_inject; eauto.\neapply agree_val_regs; eauto.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icond; eauto.\ndestruct b; econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icond cond (sregs ctx args) (spc ctx ifso) (spc ctx ifnot))) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icond cond (sregs ctx args) (spc ctx ifso) (spc ctx ifnot)))","proofString":"assert (eval_condition cond rs'##(sregs ctx args) m' = Some b).\neapply eval_condition_inject; eauto.\neapply agree_val_regs; eauto.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Icond; eauto.\ndestruct b; econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icond cond (sregs ctx args) (spc ctx ifso) (spc ctx ifnot))) : eval_condition cond rs' ## (sregs ctx args) m' = Some b.","conclusion":"eval_condition cond rs' ## (sregs ctx args) m' = Some b","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icond cond (sregs ctx args) (spc ctx ifso) (spc ctx ifnot)))","proofString":"eapply eval_condition_inject; eauto.\neapply agree_val_regs; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icond cond (sregs ctx args) (spc ctx ifso) (spc ctx ifnot))) : Val.inject_list F rs ## args rs' ## (sregs ctx args).","conclusion":"Val.inject_list F rs ## args rs' ## (sregs ctx args)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icond cond (sregs ctx args) (spc ctx ifso) (spc ctx ifnot)))","proofString":"eapply agree_val_regs; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icond cond (sregs ctx args) (spc ctx ifso) (spc ctx ifnot))) (H1 : eval_condition cond rs' ## (sregs ctx args) m' = Some b) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H8 : (fn_code f') ! (spc ctx pc) =\nSome (Icond cond (sregs ctx args) (spc ctx ifso) (spc ctx ifnot))) (H1 : eval_condition cond rs' ## (sregs ctx args) m' = Some b)","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Icond; eauto.\ndestruct b; econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\nassert (Val.inject F rs#arg rs'#(sreg ctx arg)).\neapply agree_val_reg; eauto.\nrewrite H0 in H2; inv H2.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ijumptable; eauto.\nrewrite list_nth_z_map.\nrewrite H1.\nsimpl; reflexivity.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : tr_instr fenv (fn_stacksize f') ctx pc (Ijumptable arg tbl) (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Ijumptable arg tbl) (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros TR; inv TR.\nassert (Val.inject F rs#arg rs'#(sreg ctx arg)).\neapply agree_val_reg; eauto.\nrewrite H0 in H2; inv H2.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ijumptable; eauto.\nrewrite list_nth_z_map.\nrewrite H1.\nsimpl; reflexivity.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H7 : (fn_code f') ! (spc ctx pc) =\nSome (Ijumptable (sreg ctx arg) (map (spc ctx) tbl))) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H7 : (fn_code f') ! (spc ctx pc) =\nSome (Ijumptable (sreg ctx arg) (map (spc ctx) tbl)))","proofString":"assert (Val.inject F rs#arg rs'#(sreg ctx arg)).\neapply agree_val_reg; eauto.\nrewrite H0 in H2; inv H2.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ijumptable; eauto.\nrewrite list_nth_z_map.\nrewrite H1.\nsimpl; reflexivity.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H7 : (fn_code f') ! (spc ctx pc) =\nSome (Ijumptable (sreg ctx arg) (map (spc ctx) tbl))) : Val.inject F rs # arg rs' # (sreg ctx arg).","conclusion":"Val.inject F rs # arg rs' # (sreg ctx arg)","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H7 : (fn_code f') ! (spc ctx pc) =\nSome (Ijumptable (sreg ctx arg) (map (spc ctx) tbl)))","proofString":"eapply agree_val_reg; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H7 : (fn_code f') ! (spc ctx pc) =\nSome (Ijumptable (sreg ctx arg) (map (spc ctx) tbl))) (H2 : Val.inject F rs # arg rs' # (sreg ctx arg)) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H7 : (fn_code f') ! (spc ctx pc) =\nSome (Ijumptable (sreg ctx arg) (map (spc ctx) tbl))) (H2 : Val.inject F rs # arg rs' # (sreg ctx arg))","proofString":"rewrite H0 in H2; inv H2.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ijumptable; eauto.\nrewrite list_nth_z_map.\nrewrite H1.\nsimpl; reflexivity.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H7 : (fn_code f') ! (spc ctx pc) =\nSome (Ijumptable (sreg ctx arg) (map (spc ctx) tbl))) (H5 : Vint n = rs' # (sreg ctx arg)) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')\n     E0 S2' /\\ match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) <\n measure (State s f (Vptr sp0 Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m')","hypotheses":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m' s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H7 : (fn_code f') ! (spc ctx pc) =\nSome (Ijumptable (sreg ctx arg) (map (spc ctx) tbl))) (H5 : Vint n = rs' # (sreg ctx arg))","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Ijumptable; eauto.\nrewrite list_nth_z_map.\nrewrite H1.\nsimpl; reflexivity.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit tr_funbody_inv; eauto.\nintros TR; inv TR.\ninv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\ngeneralize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\ninversion FB; subst.\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\nrewrite H8 in PRIV.\neapply range_private_free_left; eauto.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_left_inject; eauto.\ninv FB.\nrewrite H4 in PRIV.\neapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : tr_instr fenv (fn_stacksize f') ctx pc (Ireturn or) (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"tr_instr fenv (fn_stacksize f') ctx pc (Ireturn or) (fn_code f') ->\n(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros TR; inv TR.\ninv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\ngeneralize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\ninversion FB; subst.\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\nrewrite H8 in PRIV.\neapply range_private_free_left; eauto.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_left_inject; eauto.\ninv FB.\nrewrite H4 in PRIV.\neapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None)","proofString":"inv MS0; try congruence.\nassert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\ngeneralize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\ninversion FB; subst.\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\nrewrite H8 in PRIV.\neapply range_private_free_left; eauto.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"assert (X: { m1' | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}).\napply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\ngeneralize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia.\ndestruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\ninversion FB; subst.\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\nrewrite H8 in PRIV.\neapply range_private_free_left; eauto.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : {m1' : mem | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}.","conclusion":"{m1' : mem | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"apply Mem.range_perm_free.\nred; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\ngeneralize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) : Mem.range_perm m'0 sp' 0 (fn_stacksize f') Cur Freeable.","conclusion":"Mem.range_perm m'0 sp' 0 (fn_stacksize f') Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0)","proofString":"red; intros.\ndestruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\ngeneralize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') : Mem.perm m'0 sp' ofs Cur Freeable.","conclusion":"Mem.perm m'0 sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f')","proofString":"destruct (zlt ofs f.(fn_stacksize)).\nreplace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia.\ninv FB.\neapply range_private_perms; eauto.\ngeneralize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f) : Mem.perm m'0 sp' ofs Cur Freeable.","conclusion":"Mem.perm m'0 sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f)","proofString":"replace ofs with (ofs + dstk ctx) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f) : Mem.perm m'0 sp' (ofs + dstk ctx) Cur Freeable.","conclusion":"Mem.perm m'0 sp' (ofs + dstk ctx) Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f)","proofString":"eapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f) : Mem.perm m stk ofs Cur Freeable.","conclusion":"Mem.perm m stk ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f)","proofString":"eapply Mem.free_range_perm; eauto.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f) : 0 <= ofs < fn_stacksize f.","conclusion":"0 <= ofs < fn_stacksize f","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (l : ofs < fn_stacksize f)","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) : Mem.perm m'0 sp' ofs Cur Freeable.","conclusion":"Mem.perm m'0 sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f)","proofString":"inv FB.\neapply range_private_perms; eauto.\ngeneralize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : dstk ctx + mstk ctx <= fn_stacksize f') : Mem.perm m'0 sp' ofs Cur Freeable.","conclusion":"Mem.perm m'0 sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"eapply range_private_perms; eauto.\ngeneralize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : dstk ctx + mstk ctx <= fn_stacksize f') : dstk ctx + mstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx + mstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"generalize (Zmax_spec (fn_stacksize f) 0).\ndestruct (zlt 0 (fn_stacksize f)); lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : dstk ctx + mstk ctx <= fn_stacksize f') : Z.max (fn_stacksize f) 0 =\n(if zlt 0 (fn_stacksize f) then fn_stacksize f else 0) ->\ndstk ctx + mstk ctx <= ofs < fn_stacksize f'.","conclusion":"Z.max (fn_stacksize f) 0 =\n(if zlt 0 (fn_stacksize f) then fn_stacksize f else 0) ->\ndstk ctx + mstk ctx <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (ofs : Z) (H1 : 0 <= ofs < fn_stacksize f') (g : ofs >= fn_stacksize f) (H3 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H4 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"destruct (zlt 0 (fn_stacksize f)); lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (X : {m1' : mem | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'}) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (X : {m1' : mem | Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1'})","proofString":"destruct X as [m1' FREE].\nleft; econstructor; split.\neapply plus_one.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\ninversion FB; subst.\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\nrewrite H8 in PRIV.\neapply range_private_free_left; eauto.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\neapply match_stacks_bound with (bound := sp').\neapply match_stacks_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\nintros.\neapply Mem.perm_free_1; eauto with ordered_type.\nintros.\neapply Mem.perm_free_3; eauto.\nerewrite Mem.nextblock_free; eauto.\nred in VB; extlia.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\ninversion FB; subst.\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\nrewrite H8 in PRIV.\neapply range_private_free_left; eauto.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPlt b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty.","conclusion":"forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPlt b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"intros.\neapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Plt b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Plt b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : forall (b : positive) (ofs : Z),\nPlt b sp' ->\nMem.perm m'0 b ofs Cur Freeable -> Mem.perm m1' b ofs Cur Freeable.","conclusion":"forall (b : positive) (ofs : Z),\nPlt b sp' ->\nMem.perm m'0 b ofs Cur Freeable -> Mem.perm m1' b ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"intros.\neapply Mem.perm_free_1; eauto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b : positive) (ofs : Z) (H1 : Plt b sp') (H3 : Mem.perm m'0 b ofs Cur Freeable) : Mem.perm m1' b ofs Cur Freeable.","conclusion":"Mem.perm m1' b ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b : positive) (ofs : Z) (H1 : Plt b sp') (H3 : Mem.perm m'0 b ofs Cur Freeable)","proofString":"eapply Mem.perm_free_1; eauto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : forall (b : positive) (ofs : Z) (k : perm_kind) (p : permission),\nPlt b sp' -> Mem.perm m1' b ofs k p -> Mem.perm m'0 b ofs k p.","conclusion":"forall (b : positive) (ofs : Z) (k : perm_kind) (p : permission),\nPlt b sp' -> Mem.perm m1' b ofs k p -> Mem.perm m'0 b ofs k p","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"intros.\neapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b : positive) (ofs : Z) (k : perm_kind) (p : permission) (H1 : Plt b sp') (H3 : Mem.perm m1' b ofs k p) : Mem.perm m'0 b ofs k p.","conclusion":"Mem.perm m'0 b ofs k p","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b : positive) (ofs : Z) (k : perm_kind) (p : permission) (H1 : Plt b sp') (H3 : Mem.perm m1' b ofs k p)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : Ple sp' (Mem.nextblock m1').","conclusion":"Ple sp' (Mem.nextblock m1')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"erewrite Mem.nextblock_free; eauto.\nred in VB; extlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : Ple sp' (Mem.nextblock m'0).","conclusion":"Ple sp' (Mem.nextblock m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"red in VB; extlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (r : reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn (Some r))) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) (Some r)))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : Val.inject F rs # r rs' # (sreg ctx r).","conclusion":"Val.inject F rs # r rs' # (sreg ctx r)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (r : reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn (Some r))) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) (Some r)))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"apply agree_val_reg; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) None))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : Val.inject F Vundef Vundef.","conclusion":"Val.inject F Vundef Vundef","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) None))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : Mem.inject F m' m'0.","conclusion":"Mem.inject F m' m'0","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"eapply Mem.free_left_inject; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nF b1 = Some (sp', delta) ->\nMem.perm m' b1 ofs k p -> 0 <= ofs + delta < fn_stacksize f' -> False.","conclusion":"forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nF b1 = Some (sp', delta) ->\nMem.perm m' b1 ofs k p -> 0 <= ofs + delta < fn_stacksize f' -> False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1')","proofString":"intros.\ninversion FB; subst.\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\nrewrite H8 in PRIV.\neapply range_private_free_left; eauto.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f')","proofString":"inversion FB; subst.\nassert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\nrewrite H8 in PRIV.\neapply range_private_free_left; eauto.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"assert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).\nrewrite H8 in PRIV.\neapply range_private_free_left; eauto.\nrewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f').","conclusion":"range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"rewrite H8 in PRIV.\neapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f').","conclusion":"range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"eapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f'))","proofString":"rewrite DSTK in PRIV'.\nexploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f'))","proofString":"exploit (PRIV' (ofs + delta)).\nlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) : 0 <= ofs + delta < fn_stacksize f'.","conclusion":"0 <= ofs + delta < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f'))","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) : loc_private F m' m'0 sp' (ofs + delta) -> False.","conclusion":"loc_private F m' m'0 sp' (ofs + delta) -> False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f'))","proofString":"intros [A B].\neelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (A : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (A : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty)","proofString":"eelim B; eauto.\nreplace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (A : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty) : Mem.perm m' b1 (ofs + delta - delta) Max Nonempty.","conclusion":"Mem.perm m' b1 (ofs + delta - delta) Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (A : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty)","proofString":"replace (ofs + delta - delta) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (A : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty) : Mem.perm m' b1 ofs Max Nonempty.","conclusion":"Mem.perm m' b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (A : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty)","proofString":"apply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (A : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty) : Mem.perm m' b1 ofs k Nonempty.","conclusion":"Mem.perm m' b1 ofs k Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H2 : (fn_code f') ! (spc ctx pc) = Some (Ireturn (option_map (sreg ctx) or))) (H5 : retinfo ctx = None) (MS : match_stacks F m m'0 s stk' sp') (RET : retinfo ctx = None) (DSTK : dstk ctx = 0) (m1' : mem) (FREE : Mem.free m'0 sp' 0 (fn_stacksize f') = Some m1') (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : F b1 = Some (sp', delta)) (H3 : Mem.perm m' b1 ofs k p) (H4 : 0 <= ofs + delta < fn_stacksize f') (H6 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H7 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H8 : mstk ctx = Z.max (fn_stacksize f) 0) (H9 : (min_alignment (fn_stacksize f) | dstk ctx)) (H10 : dstk ctx >= 0) (H11 : dstk ctx + mstk ctx <= fn_stacksize f') (PRIV' : range_private F m' m'0 sp' 0 (fn_stacksize f')) (A : Mem.perm m'0 sp' (ofs + delta) Cur Freeable) (B : forall (b : block) (delta0 : Z),\nF b = Some (sp', delta0) ->\n~ Mem.perm m' b (ofs + delta - delta0) Max Nonempty)","proofString":"apply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)\n     E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"right.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_left_inject; eauto.\ninv FB.\nrewrite H4 in PRIV.\neapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) : (measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"split.\nsimpl.\nlia.\nsplit.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_left_inject; eauto.\ninv FB.\nrewrite H4 in PRIV.\neapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) : (measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat.","conclusion":"(measure (Returnstate s (regmap_optget or Vundef rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) pc rs m))%nat","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"simpl.\nlia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) : (0 < 1)%nat.","conclusion":"(0 < 1)%nat","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) : E0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"E0 = E0 /\\\nmatch_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"split.\nauto.\neconstructor; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_left_inject; eauto.\ninv FB.\nrewrite H4 in PRIV.\neapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) : E0 = E0.","conclusion":"E0 = E0","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) : match_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0).","conclusion":"match_states (Returnstate s (regmap_optget or Vundef rs) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"econstructor; eauto.\neapply match_stacks_inside_invariant; eauto.\nintros.\neapply Mem.perm_free_3; eauto.\ndestruct or; simpl.\napply agree_val_reg; auto.\nauto.\neapply Mem.free_left_inject; eauto.\ninv FB.\nrewrite H4 in PRIV.\neapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) : forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPle b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty.","conclusion":"forall (b1 b2 : block) (delta ofs : Z),\nF b1 = Some (b2, delta) ->\nPle b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"intros.\neapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Ple b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) (b1 b2 : block) (delta ofs : Z) (H1 : F b1 = Some (b2, delta)) (H3 : Ple b2 sp') (H4 : Mem.perm m' b1 ofs Max Nonempty)","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (r : reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn (Some r))) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx (Some r) rinfo)) (H5 : retinfo ctx = Some rinfo) : Val.inject F rs # r rs' # (sreg ctx r).","conclusion":"Val.inject F rs # r rs' # (sreg ctx r)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (r : reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn (Some r))) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx (Some r) rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"apply agree_val_reg; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx None rinfo)) (H5 : retinfo ctx = Some rinfo) : Vundef = Vundef.","conclusion":"Vundef = Vundef","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx None rinfo)) (H5 : retinfo ctx = Some rinfo)","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H6 : (min_alignment (fn_stacksize f) | dstk ctx)) (H7 : dstk ctx >= 0) (H8 : dstk ctx + mstk ctx <= fn_stacksize f') : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f').","conclusion":"range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H6 : (min_alignment (fn_stacksize f) | dstk ctx)) (H7 : dstk ctx >= 0) (H8 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"rewrite H4 in PRIV.\neapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H6 : (min_alignment (fn_stacksize f) | dstk ctx)) (H7 : dstk ctx >= 0) (H8 : dstk ctx + mstk ctx <= fn_stacksize f') : range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f').","conclusion":"range_private F m' m'0 sp' (dstk ctx) (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx : context) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (AG : agree_regs F ctx rs rs') (SP : F stk = Some (sp', dstk ctx)) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (rinfo : node * reg) (H2 : (fn_code f') ! (spc ctx pc) = Some (inline_return ctx or rinfo)) (H5 : retinfo ctx = Some rinfo) (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H3 : forall (pc0 : positive) (i : instruction),\n(fn_code f) ! pc0 = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc0 i (fn_code f')) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H6 : (min_alignment (fn_stacksize f) | dstk ctx)) (H7 : dstk ctx >= 0) (H8 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"eapply range_private_free_left; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m') (Callstate stk' fd' args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0)","proofString":"assert (A: exists f', tr_function cunit f f' /\\ fd' = Internal f').\nErrors.monadInv FD.\nexists x.\nsplit; auto.\neapply transf_function_spec; eauto.\ndestruct A as [f' [TR1 EQ]].\nassert (TR: tr_function prog f f').\neapply tr_function_linkorder; eauto.\ninversion TR; subst.\nexploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\ninstantiate (1 := fn_stacksize f').\ninv H2.\nextlia.\nintros [F' [m1' [sp' [A [B [C [D E]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_internal; eauto.\nrewrite H5; eauto using Val.has_argtype_list_inject.\nrewrite H7.\neconstructor.\ninstantiate (1 := F').\napply match_stacks_inside_base.\nassert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).\nrewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type.\nauto.\nauto.\nauto.\neauto.\nauto.\nrewrite H6.\napply agree_regs_init_regs.\neauto.\nauto.\ninv H2; auto.\ncongruence.\nauto.\neapply Mem.valid_new_block; eauto.\nred; intros.\nsplit.\neapply Mem.perm_alloc_2; eauto.\ninv H2; extlia.\nintros; red; intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto.\nauto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\nrewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) : exists f' : function, tr_function cunit f f' /\\ fd' = Internal f'.","conclusion":"exists f' : function, tr_function cunit f f' /\\ fd' = Internal f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0)","proofString":"Errors.monadInv FD.\nexists x.\nsplit; auto.\neapply transf_function_spec; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (x : function) (EQ : transf_function (funenv_program cunit) f = OK x) : exists f' : function, tr_function cunit f f' /\\ Internal x = Internal f'.","conclusion":"exists f' : function, tr_function cunit f f' /\\ Internal x = Internal f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (x : function) (EQ : transf_function (funenv_program cunit) f = OK x)","proofString":"exists x.\nsplit; auto.\neapply transf_function_spec; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (x : function) (EQ : transf_function (funenv_program cunit) f = OK x) : tr_function cunit f x /\\ Internal x = Internal x.","conclusion":"tr_function cunit f x /\\ Internal x = Internal x","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (x : function) (EQ : transf_function (funenv_program cunit) f = OK x)","proofString":"split; auto.\neapply transf_function_spec; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (x : function) (EQ : transf_function (funenv_program cunit) f = OK x) : tr_function cunit f x.","conclusion":"tr_function cunit f x","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (x : function) (EQ : transf_function (funenv_program cunit) f = OK x)","proofString":"eapply transf_function_spec; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (A : exists f' : function, tr_function cunit f f' /\\ fd' = Internal f') : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m') (Callstate stk' fd' args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (A : exists f' : function, tr_function cunit f f' /\\ fd' = Internal f')","proofString":"destruct A as [f' [TR1 EQ]].\nassert (TR: tr_function prog f f').\neapply tr_function_linkorder; eauto.\ninversion TR; subst.\nexploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\ninstantiate (1 := fn_stacksize f').\ninv H2.\nextlia.\nintros [F' [m1' [sp' [A [B [C [D E]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_internal; eauto.\nrewrite H5; eauto using Val.has_argtype_list_inject.\nrewrite H7.\neconstructor.\ninstantiate (1 := F').\napply match_stacks_inside_base.\nassert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).\nrewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type.\nauto.\nauto.\nauto.\neauto.\nauto.\nrewrite H6.\napply agree_regs_init_regs.\neauto.\nauto.\ninv H2; auto.\ncongruence.\nauto.\neapply Mem.valid_new_block; eauto.\nred; intros.\nsplit.\neapply Mem.perm_alloc_2; eauto.\ninv H2; extlia.\nintros; red; intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto.\nauto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\nrewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (f' : function) (TR1 : tr_function cunit f f') (EQ : fd' = Internal f') : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m') (Callstate stk' fd' args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (f' : function) (TR1 : tr_function cunit f f') (EQ : fd' = Internal f')","proofString":"assert (TR: tr_function prog f f').\neapply tr_function_linkorder; eauto.\ninversion TR; subst.\nexploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\ninstantiate (1 := fn_stacksize f').\ninv H2.\nextlia.\nintros [F' [m1' [sp' [A [B [C [D E]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_internal; eauto.\nrewrite H5; eauto using Val.has_argtype_list_inject.\nrewrite H7.\neconstructor.\ninstantiate (1 := F').\napply match_stacks_inside_base.\nassert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).\nrewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type.\nauto.\nauto.\nauto.\neauto.\nauto.\nrewrite H6.\napply agree_regs_init_regs.\neauto.\nauto.\ninv H2; auto.\ncongruence.\nauto.\neapply Mem.valid_new_block; eauto.\nred; intros.\nsplit.\neapply Mem.perm_alloc_2; eauto.\ninv H2; extlia.\nintros; red; intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto.\nauto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\nrewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (f' : function) (TR1 : tr_function cunit f f') (EQ : fd' = Internal f') : tr_function prog f f'.","conclusion":"tr_function prog f f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (f' : function) (TR1 : tr_function cunit f f') (EQ : fd' = Internal f')","proofString":"eapply tr_function_linkorder; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (f' : function) (TR1 : tr_function cunit f f') (EQ : fd' = Internal f') (TR : tr_function prog f f') : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m') (Callstate stk' fd' args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (f' : function) (TR1 : tr_function cunit f f') (EQ : fd' = Internal f') (TR : tr_function prog f f')","proofString":"inversion TR; subst.\nexploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\ninstantiate (1 := fn_stacksize f').\ninv H2.\nextlia.\nintros [F' [m1' [sp' [A [B [C [D E]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_internal; eauto.\nrewrite H5; eauto using Val.has_argtype_list_inject.\nrewrite H7.\neconstructor.\ninstantiate (1 := F').\napply match_stacks_inside_base.\nassert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).\nrewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type.\nauto.\nauto.\nauto.\neauto.\nauto.\nrewrite H6.\napply agree_regs_init_regs.\neauto.\nauto.\ninv H2; auto.\ncongruence.\nauto.\neapply Mem.valid_new_block; eauto.\nred; intros.\nsplit.\neapply Mem.perm_alloc_2; eauto.\ninv H2; extlia.\nintros; red; intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto.\nauto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\nrewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' (Internal f') args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (Callstate stk' (Internal f') args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' (Internal f') args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (Callstate stk' (Internal f') args' m'0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned)","proofString":"exploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\ninstantiate (1 := fn_stacksize f').\ninv H2.\nextlia.\nintros [F' [m1' [sp' [A [B [C [D E]]]]]]].\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_internal; eauto.\nrewrite H5; eauto using Val.has_argtype_list_inject.\nrewrite H7.\neconstructor.\ninstantiate (1 := F').\napply match_stacks_inside_base.\nassert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).\nrewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type.\nauto.\nauto.\nauto.\neauto.\nauto.\nrewrite H6.\napply agree_regs_init_regs.\neauto.\nauto.\ninv H2; auto.\ncongruence.\nauto.\neapply Mem.valid_new_block; eauto.\nred; intros.\nsplit.\neapply Mem.perm_alloc_2; eauto.\ninv H2; extlia.\nintros; red; intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto.\nauto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\nrewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) : fn_stacksize f <= fn_stacksize f'.","conclusion":"fn_stacksize f <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned)","proofString":"inv H2.\nextlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (H9 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H10 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H11 : mstk ctx = Z.max (fn_stacksize f) 0) (H12 : (min_alignment (fn_stacksize f) | dstk ctx)) (H13 : dstk ctx >= 0) (H14 : dstk ctx + mstk ctx <= fn_stacksize f') : fn_stacksize f <= fn_stacksize f'.","conclusion":"fn_stacksize f <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (H9 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H10 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H11 : mstk ctx = Z.max (fn_stacksize f) 0) (H12 : (min_alignment (fn_stacksize f) | dstk ctx)) (H13 : dstk ctx >= 0) (H14 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"extlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' (Internal f') args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (Callstate stk' (Internal f') args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' (Internal f') args' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (Callstate stk' (Internal f') args' m'0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_function_internal; eauto.\nrewrite H5; eauto using Val.has_argtype_list_inject.\nrewrite H7.\neconstructor.\ninstantiate (1 := F').\napply match_stacks_inside_base.\nassert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).\nrewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type.\nauto.\nauto.\nauto.\neauto.\nauto.\nrewrite H6.\napply agree_regs_init_regs.\neauto.\nauto.\ninv H2; auto.\ncongruence.\nauto.\neapply Mem.valid_new_block; eauto.\nred; intros.\nsplit.\neapply Mem.perm_alloc_2; eauto.\ninv H2; extlia.\nintros; red; intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto.\nauto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\nrewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : Val.has_argtype_list args' (sig_args (fn_sig f')).","conclusion":"Val.has_argtype_list args' (sig_args (fn_sig f'))","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"rewrite H5; eauto using Val.has_argtype_list_inject."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : match_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f))\n     (init_regs args' (fn_params f')) m1').","conclusion":"match_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f))\n     (init_regs args' (fn_params f')) m1')","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"econstructor.\ninstantiate (1 := F').\napply match_stacks_inside_base.\nassert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).\nrewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type.\nauto.\nauto.\nauto.\neauto.\nauto.\nrewrite H6.\napply agree_regs_init_regs.\neauto.\nauto.\ninv H2; auto.\ncongruence.\nauto.\neapply Mem.valid_new_block; eauto.\nred; intros.\nsplit.\neapply Mem.perm_alloc_2; eauto.\ninv H2; extlia.\nintros; red; intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto.\nauto.\nintros.\nexploit Mem.perm_alloc_inv; eauto.\nrewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : match_stacks_inside F' m' m1' s stk' f' ctx sp'\n  (init_regs args' (fn_params f')).","conclusion":"match_stacks_inside F' m' m1' s stk' f' ctx sp'\n  (init_regs args' (fn_params f'))","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"apply match_stacks_inside_base.\nassert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).\nrewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type.\nauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : match_stacks F' m' m1' s stk' sp'.","conclusion":"match_stacks F' m' m1' s stk' sp'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"assert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).\nrewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) : match_stacks F' m' m1' s stk' sp'.","conclusion":"match_stacks F' m' m1' s stk' sp'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0)","proofString":"rewrite <- SP in MS0.\neapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) : match_stacks F' m' m1' s stk' sp'.","conclusion":"match_stacks F' m' m1' s stk' sp'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0)","proofString":"eapply match_stacks_invariant; eauto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nintros.\neapply Mem.perm_alloc_1; eauto.\nintros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) : forall (b1 b2 : block) (delta : Z),\nF' b1 = Some (b2, delta) -> Plt b2 sp' -> F b1 = Some (b2, delta).","conclusion":"forall (b1 b2 : block) (delta : Z),\nF' b1 = Some (b2, delta) -> Plt b2 sp' -> F b1 = Some (b2, delta)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0)","proofString":"intros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp') : F b1 = Some (b2, delta).","conclusion":"F b1 = Some (b2, delta)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp')","proofString":"destruct (eq_block b1 stk).\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto.\nrewrite E in H9; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp') (e : b1 = stk) : F b1 = Some (b2, delta).","conclusion":"F b1 = Some (b2, delta)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp') (e : b1 = stk)","proofString":"subst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b2 : block) (delta : Z) (H9 : F' stk = Some (b2, delta)) (H10 : Plt b2 sp') : F stk = Some (b2, delta).","conclusion":"F stk = Some (b2, delta)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b2 : block) (delta : Z) (H9 : F' stk = Some (b2, delta)) (H10 : Plt b2 sp')","proofString":"rewrite D in H9; inv H9.\neelim Plt_strict; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', Mem.nextblock m'0)) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (Mem.nextblock m'0, 0)) (E : forall b : block, b <> stk -> F' b = F b) (H10 : Plt (Mem.nextblock m'0) (Mem.nextblock m'0)) : F stk = Some (Mem.nextblock m'0, 0).","conclusion":"F stk = Some (Mem.nextblock m'0, 0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', Mem.nextblock m'0)) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (Mem.nextblock m'0, 0)) (E : forall b : block, b <> stk -> F' b = F b) (H10 : Plt (Mem.nextblock m'0) (Mem.nextblock m'0))","proofString":"eelim Plt_strict; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp') (n : b1 <> stk) : F b1 = Some (b2, delta).","conclusion":"F b1 = Some (b2, delta)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp') (n : b1 <> stk)","proofString":"rewrite E in H9; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) : forall (b1 b2 : block) (delta ofs : Z),\nF' b1 = Some (b2, delta) ->\nPlt b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty.","conclusion":"forall (b1 b2 : block) (delta ofs : Z),\nF' b1 = Some (b2, delta) ->\nPlt b2 sp' ->\nMem.perm m' b1 ofs Max Nonempty -> Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0)","proofString":"intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta ofs : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp') (H11 : Mem.perm m' b1 ofs Max Nonempty) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta ofs : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp') (H11 : Mem.perm m' b1 ofs Max Nonempty)","proofString":"exploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b1 stk); intros; auto.\nsubst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta ofs : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp') (H11 : Mem.perm m' b1 ofs Max Nonempty) (e : b1 = stk) (H12 : 0 <= ofs < fn_stacksize f) : Mem.perm m b1 ofs Max Nonempty.","conclusion":"Mem.perm m b1 ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b1 b2 : block) (delta ofs : Z) (H9 : F' b1 = Some (b2, delta)) (H10 : Plt b2 sp') (H11 : Mem.perm m' b1 ofs Max Nonempty) (e : b1 = stk) (H12 : 0 <= ofs < fn_stacksize f)","proofString":"subst b1.\nrewrite D in H9; inv H9.\neelim Plt_strict; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b2 : block) (delta ofs : Z) (H9 : F' stk = Some (b2, delta)) (H10 : Plt b2 sp') (H11 : Mem.perm m' stk ofs Max Nonempty) (H12 : 0 <= ofs < fn_stacksize f) : Mem.perm m stk ofs Max Nonempty.","conclusion":"Mem.perm m stk ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) (b2 : block) (delta ofs : Z) (H9 : F' stk = Some (b2, delta)) (H10 : Plt b2 sp') (H11 : Mem.perm m' stk ofs Max Nonempty) (H12 : 0 <= ofs < fn_stacksize f)","proofString":"rewrite D in H9; inv H9.\neelim Plt_strict; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', Mem.nextblock m'0)) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (Mem.nextblock m'0, 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H10 : Plt (Mem.nextblock m'0) (Mem.nextblock m'0)) (H11 : Mem.perm m' stk ofs Max Nonempty) (H12 : 0 <= ofs < fn_stacksize f) : Mem.perm m stk ofs Max Nonempty.","conclusion":"Mem.perm m stk ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', Mem.nextblock m'0)) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (Mem.nextblock m'0, 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H10 : Plt (Mem.nextblock m'0) (Mem.nextblock m'0)) (H11 : Mem.perm m' stk ofs Max Nonempty) (H12 : 0 <= ofs < fn_stacksize f)","proofString":"eelim Plt_strict; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) : forall (b : positive) (ofs : Z),\nPlt b sp' ->\nMem.perm m'0 b ofs Cur Freeable -> Mem.perm m1' b ofs Cur Freeable.","conclusion":"forall (b : positive) (ofs : Z),\nPlt b sp' ->\nMem.perm m'0 b ofs Cur Freeable -> Mem.perm m1' b ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0)","proofString":"intros.\neapply Mem.perm_alloc_1; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (SP : sp' = Mem.nextblock m'0) (b : positive) (ofs : Z) (H9 : Plt b sp') (H10 : Mem.perm m'0 b ofs Cur Freeable) : Mem.perm m1' b ofs Cur Freeable.","conclusion":"Mem.perm m1' b ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (SP : sp' = Mem.nextblock m'0) (b : positive) (ofs : Z) (H9 : Plt b sp') (H10 : Mem.perm m'0 b ofs Cur Freeable)","proofString":"eapply Mem.perm_alloc_1; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0) : forall (b : positive) (ofs : Z) (k : perm_kind) (p : permission),\nPlt b sp' -> Mem.perm m1' b ofs k p -> Mem.perm m'0 b ofs k p.","conclusion":"forall (b : positive) (ofs : Z) (k : perm_kind) (p : permission),\nPlt b sp' -> Mem.perm m1' b ofs k p -> Mem.perm m'0 b ofs k p","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (SP : sp' = Mem.nextblock m'0)","proofString":"intros.\nexploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (SP : sp' = Mem.nextblock m'0) (b : positive) (ofs : Z) (k : perm_kind) (p : permission) (H9 : Plt b sp') (H10 : Mem.perm m1' b ofs k p) : Mem.perm m'0 b ofs k p.","conclusion":"Mem.perm m'0 b ofs k p","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (sp' : block) (MS0 : match_stacks F m m'0 s stk' sp') (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (SP : sp' = Mem.nextblock m'0) (b : positive) (ofs : Z) (k : perm_kind) (p : permission) (H9 : Plt b sp') (H10 : Mem.perm m1' b ofs k p)","proofString":"exploit Mem.perm_alloc_inv.\neexact A.\neauto.\nrewrite dec_eq_false; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : retinfo ctx = None.","conclusion":"retinfo ctx = None","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : dstk ctx = 0.","conclusion":"dstk ctx = 0","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : agree_regs F' ctx (init_regs args (fn_params f))\n  (init_regs args' (sregs ctx (fn_params f))).","conclusion":"agree_regs F' ctx (init_regs args (fn_params f))\n  (init_regs args' (sregs ctx (fn_params f)))","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"apply agree_regs_init_regs.\neauto.\nauto.\ninv H2; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : Val.inject_list F' args args'.","conclusion":"Val.inject_list F' args args'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : forall r : positive, In r (fn_params f) -> Ple r (mreg ctx).","conclusion":"forall r : positive, In r (fn_params f) -> Ple r (mreg ctx)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"auto.\ninv H2; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : forall r : positive, In r (fn_params f) -> Ple r (mreg ctx).","conclusion":"forall r : positive, In r (fn_params f) -> Ple r (mreg ctx)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"inv H2; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : Mem.valid_block m1' sp'.","conclusion":"Mem.valid_block m1' sp'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"eapply Mem.valid_new_block; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') : loc_private F' m' m1' sp' ofs.","conclusion":"loc_private F' m' m1' sp' ofs","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f')","proofString":"split.\neapply Mem.perm_alloc_2; eauto.\ninv H2; extlia.\nintros; red; intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') : Mem.perm m1' sp' ofs Cur Freeable.","conclusion":"Mem.perm m1' sp' ofs Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f')","proofString":"eapply Mem.perm_alloc_2; eauto.\ninv H2; extlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') : 0 <= ofs < fn_stacksize f'.","conclusion":"0 <= ofs < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f')","proofString":"inv H2; extlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') : forall (b : block) (delta : Z),\nF' b = Some (sp', delta) -> ~ Mem.perm m' b (ofs - delta) Max Nonempty.","conclusion":"forall (b : block) (delta : Z),\nF' b = Some (sp', delta) -> ~ Mem.perm m' b (ofs - delta) Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f')","proofString":"intros; red; intros.\nexploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (b : block) (delta : Z) (H10 : F' b = Some (sp', delta)) (H11 : Mem.perm m' b (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (b : block) (delta : Z) (H10 : F' b = Some (sp', delta)) (H11 : Mem.perm m' b (ofs - delta) Max Nonempty)","proofString":"exploit Mem.perm_alloc_inv.\neexact H0.\neauto.\ndestruct (eq_block b stk); intros.\nsubst.\nrewrite D in H10; inv H10.\ninv H2; extlia.\nrewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (b : block) (delta : Z) (H10 : F' b = Some (sp', delta)) (H11 : Mem.perm m' b (ofs - delta) Max Nonempty) (e : b = stk) (H12 : 0 <= ofs - delta < fn_stacksize f) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (b : block) (delta : Z) (H10 : F' b = Some (sp', delta)) (H11 : Mem.perm m' b (ofs - delta) Max Nonempty) (e : b = stk) (H12 : 0 <= ofs - delta < fn_stacksize f)","proofString":"subst.\nrewrite D in H10; inv H10.\ninv H2; extlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (delta : Z) (H11 : Mem.perm m' stk (ofs - delta) Max Nonempty) (H10 : F' stk = Some (sp', delta)) (H12 : 0 <= ofs - delta < fn_stacksize f) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (delta : Z) (H11 : Mem.perm m' stk (ofs - delta) Max Nonempty) (H10 : F' stk = Some (sp', delta)) (H12 : 0 <= ofs - delta < fn_stacksize f)","proofString":"rewrite D in H10; inv H10.\ninv H2; extlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (H12 : 0 <= ofs - 0 < fn_stacksize f) (H11 : Mem.perm m' stk (ofs - 0) Max Nonempty) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (H12 : 0 <= ofs - 0 < fn_stacksize f) (H11 : Mem.perm m' stk (ofs - 0) Max Nonempty)","proofString":"inv H2; extlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (b : block) (delta : Z) (H10 : F' b = Some (sp', delta)) (H11 : Mem.perm m' b (ofs - delta) Max Nonempty) (n : b <> stk) (H12 : Mem.perm m b (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (b : block) (delta : Z) (H10 : F' b = Some (sp', delta)) (H11 : Mem.perm m' b (ofs - delta) Max Nonempty) (n : b <> stk) (H12 : Mem.perm m b (ofs - delta) Max Nonempty)","proofString":"rewrite E in H10; auto.\neelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (b : block) (delta : Z) (H10 : F b = Some (sp', delta)) (H11 : Mem.perm m' b (ofs - delta) Max Nonempty) (n : b <> stk) (H12 : Mem.perm m b (ofs - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b0 : block, b0 <> stk -> F' b0 = F b0) (ofs : Z) (H9 : dstk ctx + mstk ctx <= ofs < fn_stacksize f') (b : block) (delta : Z) (H10 : F b = Some (sp', delta)) (H11 : Mem.perm m' b (ofs - delta) Max Nonempty) (n : b <> stk) (H12 : Mem.perm m b (ofs - delta) Max Nonempty)","proofString":"eelim Mem.fresh_block_alloc.\neexact A.\neapply Mem.mi_mappedblocks; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : 0 <= fn_stacksize f' < Ptrofs.max_unsigned.","conclusion":"0 <= fn_stacksize f' < Ptrofs.max_unsigned","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) : forall ofs : Z,\nMem.perm m1' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'.","conclusion":"forall ofs : Z,\nMem.perm m1' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b)","proofString":"intros.\nexploit Mem.perm_alloc_inv; eauto.\nrewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : Mem.perm m1' sp' ofs Max Nonempty) : 0 <= ofs <= fn_stacksize f'.","conclusion":"0 <= ofs <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : Mem.perm m1' sp' ofs Max Nonempty)","proofString":"exploit Mem.perm_alloc_inv; eauto.\nrewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : Mem.perm m1' sp' ofs Max Nonempty) : (if eq_block sp' sp'\n then 0 <= ofs < fn_stacksize f'\n else Mem.perm m'0 sp' ofs Max Nonempty) -> 0 <= ofs <= fn_stacksize f'.","conclusion":"(if eq_block sp' sp'\n then 0 <= ofs < fn_stacksize f'\n else Mem.perm m'0 sp' ofs Max Nonempty) -> 0 <= ofs <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : Mem.perm m1' sp' ofs Max Nonempty)","proofString":"rewrite dec_eq_true.\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : Mem.perm m1' sp' ofs Max Nonempty) : 0 <= ofs < fn_stacksize f' -> 0 <= ofs <= fn_stacksize f'.","conclusion":"0 <= ofs < fn_stacksize f' -> 0 <= ofs <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (f' : function) (FD : transf_fundef (funenv_program cunit) (Internal f) = OK (Internal f')) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (TR1 : tr_function cunit f f') (TR : tr_function prog f f') (fenv : funenv) (ctx : context) (H1 : fenv_compat prog fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (F' : meminj) (m1' : Mem.mem') (sp' : block) (A : Mem.alloc m'0 0 (fn_stacksize f') = (m1', sp')) (B : Mem.inject F' m' m1') (C : inject_incr F F') (D : F' stk = Some (sp', 0)) (E : forall b : block, b <> stk -> F' b = F b) (ofs : Z) (H9 : Mem.perm m1' sp' ofs Max Nonempty)","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"inversion FB; subst.\nexploit Mem.alloc_left_mapped_inject.\neauto.\neauto.\ninstantiate (1 := sp').\nauto.\ninstantiate (1 := dstk ctx).\ngeneralize (Z.le_max_r (fn_stacksize f) 0).\nlia.\nintros.\nright.\nexploit SSZ2; eauto with mem.\ninv FB; lia.\nintros.\napply Mem.perm_cur.\napply Mem.perm_implies with Freeable; auto with mem.\neapply range_private_perms; eauto.\nextlia.\nreplace (fn_stacksize f - 0) with (fn_stacksize f) by lia.\ninv FB.\napply min_alignment_sound; auto.\nintros.\nexploit (PRIV (ofs + delta')); eauto.\nextlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta' - delta') with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nintros [F' [A [B [C D]]]].\nexploit tr_moves_init_regs; eauto.\nintros [rs'' [P [Q R]]].\nleft; econstructor; split.\neapply plus_left.\neapply exec_Inop; eauto.\neexact P.\ntraceEq.\neconstructor.\neapply match_stacks_inside_alloc_left; eauto.\neapply match_stacks_inside_invariant; eauto.\nlia.\neauto.\nauto.\napply agree_regs_incr with F; auto.\nauto.\nauto.\nauto.\nrewrite H3.\neapply range_private_alloc_left; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"exploit Mem.alloc_left_mapped_inject.\neauto.\neauto.\ninstantiate (1 := sp').\nauto.\ninstantiate (1 := dstk ctx).\ngeneralize (Z.le_max_r (fn_stacksize f) 0).\nlia.\nintros.\nright.\nexploit SSZ2; eauto with mem.\ninv FB; lia.\nintros.\napply Mem.perm_cur.\napply Mem.perm_implies with Freeable; auto with mem.\neapply range_private_perms; eauto.\nextlia.\nreplace (fn_stacksize f - 0) with (fn_stacksize f) by lia.\ninv FB.\napply min_alignment_sound; auto.\nintros.\nexploit (PRIV (ofs + delta')); eauto.\nextlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta' - delta') with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\nintros [F' [A [B [C D]]]].\nexploit tr_moves_init_regs; eauto.\nintros [rs'' [P [Q R]]].\nleft; econstructor; split.\neapply plus_left.\neapply exec_Inop; eauto.\neexact P.\ntraceEq.\neconstructor.\neapply match_stacks_inside_alloc_left; eauto.\neapply match_stacks_inside_invariant; eauto.\nlia.\neauto.\nauto.\napply agree_regs_incr with F; auto.\nauto.\nauto.\nauto.\nrewrite H3.\neapply range_private_alloc_left; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') : Mem.valid_block m'0 sp'.","conclusion":"Mem.valid_block m'0 sp'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') : 0 <= dstk ctx <= Ptrofs.max_unsigned.","conclusion":"0 <= dstk ctx <= Ptrofs.max_unsigned","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"generalize (Z.le_max_r (fn_stacksize f) 0).\nlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') : 0 <= Z.max (fn_stacksize f) 0 -> 0 <= dstk ctx <= Ptrofs.max_unsigned.","conclusion":"0 <= Z.max (fn_stacksize f) 0 -> 0 <= dstk ctx <= Ptrofs.max_unsigned","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : Mem.perm m'0 sp' ofs k p) : dstk ctx = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned.","conclusion":"dstk ctx = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : Mem.perm m'0 sp' ofs k p)","proofString":"right.\nexploit SSZ2; eauto with mem.\ninv FB; lia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : Mem.perm m'0 sp' ofs k p) : 0 <= ofs < Ptrofs.max_unsigned.","conclusion":"0 <= ofs < Ptrofs.max_unsigned","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : Mem.perm m'0 sp' ofs k p)","proofString":"exploit SSZ2; eauto with mem.\ninv FB; lia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : Mem.perm m'0 sp' ofs k p) : 0 <= ofs <= fn_stacksize f' -> 0 <= ofs < Ptrofs.max_unsigned.","conclusion":"0 <= ofs <= fn_stacksize f' -> 0 <= ofs < Ptrofs.max_unsigned","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : Mem.perm m'0 sp' ofs k p)","proofString":"inv FB; lia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : 0 <= ofs < fn_stacksize f) : Mem.perm m'0 sp' (ofs + dstk ctx) k p.","conclusion":"Mem.perm m'0 sp' (ofs + dstk ctx) k p","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : 0 <= ofs < fn_stacksize f)","proofString":"apply Mem.perm_cur.\napply Mem.perm_implies with Freeable; auto with mem.\neapply range_private_perms; eauto.\nextlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : 0 <= ofs < fn_stacksize f) : Mem.perm m'0 sp' (ofs + dstk ctx) Cur p.","conclusion":"Mem.perm m'0 sp' (ofs + dstk ctx) Cur p","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : 0 <= ofs < fn_stacksize f)","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\neapply range_private_perms; eauto.\nextlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : 0 <= ofs < fn_stacksize f) : Mem.perm m'0 sp' (ofs + dstk ctx) Cur Freeable.","conclusion":"Mem.perm m'0 sp' (ofs + dstk ctx) Cur Freeable","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : 0 <= ofs < fn_stacksize f)","proofString":"eapply range_private_perms; eauto.\nextlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : 0 <= ofs < fn_stacksize f) : dstk ctx <= ofs + dstk ctx < fn_stacksize f'.","conclusion":"dstk ctx <= ofs + dstk ctx < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (ofs : Z) (k : perm_kind) (p : permission) (H7 : 0 <= ofs < fn_stacksize f)","proofString":"extlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') : Mem.inj_offset_aligned (dstk ctx) (fn_stacksize f).","conclusion":"Mem.inj_offset_aligned (dstk ctx) (fn_stacksize f)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"inv FB.\napply min_alignment_sound; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (H7 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H8 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H9 : mstk ctx = Z.max (fn_stacksize f) 0) (H10 : (min_alignment (fn_stacksize f) | dstk ctx)) (H11 : dstk ctx >= 0) (H12 : dstk ctx + mstk ctx <= fn_stacksize f') : Mem.inj_offset_aligned (dstk ctx) (fn_stacksize f).","conclusion":"Mem.inj_offset_aligned (dstk ctx) (fn_stacksize f)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (H7 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H8 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H9 : mstk ctx = Z.max (fn_stacksize f) 0) (H10 : (min_alignment (fn_stacksize f) | dstk ctx)) (H11 : dstk ctx >= 0) (H12 : dstk ctx + mstk ctx <= fn_stacksize f')","proofString":"apply min_alignment_sound; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx)","proofString":"exploit (PRIV (ofs + delta')); eauto.\nextlia.\nintros [A B].\neelim B; eauto.\nreplace (ofs + delta' - delta') with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) : dstk ctx <= ofs + delta' < fn_stacksize f'.","conclusion":"dstk ctx <= ofs + delta' < fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx)","proofString":"extlia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) : loc_private F m m'0 sp' (ofs + delta') -> False.","conclusion":"loc_private F m m'0 sp' (ofs + delta') -> False","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx)","proofString":"intros [A B].\neelim B; eauto.\nreplace (ofs + delta' - delta') with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) (A : Mem.perm m'0 sp' (ofs + delta') Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp', delta) ->\n~ Mem.perm m b0 (ofs + delta' - delta) Max Nonempty) : False.","conclusion":"False","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) (A : Mem.perm m'0 sp' (ofs + delta') Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp', delta) ->\n~ Mem.perm m b0 (ofs + delta' - delta) Max Nonempty)","proofString":"eelim B; eauto.\nreplace (ofs + delta' - delta') with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) (A : Mem.perm m'0 sp' (ofs + delta') Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp', delta) ->\n~ Mem.perm m b0 (ofs + delta' - delta) Max Nonempty) : Mem.perm m b (ofs + delta' - delta') Max Nonempty.","conclusion":"Mem.perm m b (ofs + delta' - delta') Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) (A : Mem.perm m'0 sp' (ofs + delta') Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp', delta) ->\n~ Mem.perm m b0 (ofs + delta' - delta) Max Nonempty)","proofString":"replace (ofs + delta' - delta') with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) (A : Mem.perm m'0 sp' (ofs + delta') Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp', delta) ->\n~ Mem.perm m b0 (ofs + delta' - delta) Max Nonempty) : Mem.perm m b ofs Max Nonempty.","conclusion":"Mem.perm m b ofs Max Nonempty","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) (A : Mem.perm m'0 sp' (ofs + delta') Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp', delta) ->\n~ Mem.perm m b0 (ofs + delta' - delta) Max Nonempty)","proofString":"apply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) (A : Mem.perm m'0 sp' (ofs + delta') Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp', delta) ->\n~ Mem.perm m b0 (ofs + delta' - delta) Max Nonempty) : Mem.perm m b ofs k Nonempty.","conclusion":"Mem.perm m b ofs k Nonempty","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m'0 sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H7 : F b = Some (sp', delta')) (H8 : Mem.perm m b ofs k p) (H9 : 0 + dstk ctx <= ofs + delta' < fn_stacksize f + dstk ctx) (A : Mem.perm m'0 sp' (ofs + delta') Cur Freeable) (B : forall (b0 : block) (delta : Z),\nF b0 = Some (sp', delta) ->\n~ Mem.perm m b0 (ofs + delta' - delta) Max Nonempty)","proofString":"apply Mem.perm_implies with p; auto with mem."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n      (init_regs args (fn_params f)) m') <\n measure (Callstate s (Internal f) args m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m'0)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b)","proofString":"exploit tr_moves_init_regs; eauto.\nintros [rs'' [P [Q R]]].\nleft; econstructor; split.\neapply plus_left.\neapply exec_Inop; eauto.\neexact P.\ntraceEq.\neconstructor.\neapply match_stacks_inside_alloc_left; eauto.\neapply match_stacks_inside_invariant; eauto.\nlia.\neauto.\nauto.\napply agree_regs_incr with F; auto.\nauto.\nauto.\nauto.\nrewrite H3.\neapply range_private_alloc_left; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r) : match_stacks_inside F m m'0 s stk' f' ctx sp' rs''.","conclusion":"match_stacks_inside F m m'0 s stk' f' ctx sp' rs''","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r)","proofString":"eapply match_stacks_inside_invariant; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r) : dstk ctx >= dstk ctx.","conclusion":"dstk ctx >= dstk ctx","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r)","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r) : Mem.valid_block m'0 sp'.","conclusion":"Mem.valid_block m'0 sp'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r)","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r) : range_private F' m' m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f').","conclusion":"range_private F' m' m'0 sp' (dstk ctx + Z.max (fn_stacksize f) 0)\n  (fn_stacksize f')","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r)","proofString":"eapply range_private_alloc_left; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r) : 0 <= fn_stacksize f' < Ptrofs.max_unsigned.","conclusion":"0 <= fn_stacksize f' < Ptrofs.max_unsigned","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r)","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r) : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'.","conclusion":"forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m'0 : mem) (F : meminj) (fenv : funenv) (ctx ctx' : context) (pc' : positive) (pc1' : node) (rargs : list reg) (MS0 : match_stacks_inside F m m'0 s stk' f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (BELOW : context_below ctx' ctx) (NOP : (fn_code f') ! pc' = Some (Inop pc1')) (MOVES : tr_moves (fn_code f') pc1' (sregs ctx' rargs) (sregs ctx (fn_params f))\n  (spc ctx (fn_entrypoint f))) (VINJ : list_forall2 (val_reg_charact F ctx' rs') args rargs) (MINJ : Mem.inject F m m'0) (VB : Mem.valid_block m'0 sp') (PRIV : range_private F m m'0 sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m'0 sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (H1 : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)) (H2 : forall (pc : positive) (i : instruction),\n(fn_code f) ! pc = Some i ->\ntr_instr fenv (fn_stacksize f') ctx pc i (fn_code f')) (H3 : mstk ctx = Z.max (fn_stacksize f) 0) (H4 : (min_alignment (fn_stacksize f) | dstk ctx)) (H5 : dstk ctx >= 0) (H6 : dstk ctx + mstk ctx <= fn_stacksize f') (F' : meminj) (A : Mem.inject F' m' m'0) (B : inject_incr F F') (C : F' stk = Some (sp', dstk ctx)) (D : forall b : block, b <> stk -> F' b = F b) (rs'' : regset) (P : star step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc1' rs' m'0) E0\n  (State stk' f' (Vptr sp' Ptrofs.zero) (spc ctx (fn_entrypoint f)) rs'' m'0)) (Q : agree_regs F ctx (init_regs args (fn_params f)) rs'') (R : forall r : positive, Plt r (dreg ctx) -> rs'' # r = rs' # r)","proofString":"auto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0)","proofString":"exploit match_stacks_globalenvs; eauto.\nintros [bound MG].\nexploit external_call_mem_inject; eauto.\neapply match_globalenvs_preserves_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nsimpl in FD.\ninv FD.\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_bound with (Mem.nextblock m'0).\neapply match_stacks_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nextlia.\neapply external_call_nextblock; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) : (exists b : block, match_globalenvs F b) ->\n(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0).","conclusion":"(exists b : block, match_globalenvs F b) ->\n(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0)","proofString":"intros [bound MG].\nexploit external_call_mem_inject; eauto.\neapply match_globalenvs_preserves_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nsimpl in FD.\ninv FD.\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_bound with (Mem.nextblock m'0).\neapply match_stacks_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nextlia.\neapply external_call_nextblock; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound)","proofString":"exploit external_call_mem_inject; eauto.\neapply match_globalenvs_preserves_globals; eauto.\nintros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nsimpl in FD.\ninv FD.\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_bound with (Mem.nextblock m'0).\neapply match_stacks_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nextlia.\neapply external_call_nextblock; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) : meminj_preserves_globals ge F.","conclusion":"meminj_preserves_globals ge F","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound)","proofString":"eapply match_globalenvs_preserves_globals; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) : (exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge args' m'0 t vres' m2' /\\\n   Val.inject f' res vres' /\\\n   Mem.inject f' m' m2' /\\\n   Mem.unchanged_on (loc_unmapped F) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach F m) m'0 m2' /\\\n   inject_incr F f' /\\ inject_separated F f' m m'0) ->\n(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0).","conclusion":"(exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge args' m'0 t vres' m2' /\\\n   Val.inject f' res vres' /\\\n   Mem.inject f' m' m2' /\\\n   Mem.unchanged_on (loc_unmapped F) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach F m) m'0 m2' /\\\n   inject_incr F f' /\\ inject_separated F f' m m'0) ->\n(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound)","proofString":"intros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].\nsimpl in FD.\ninv FD.\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_bound with (Mem.nextblock m'0).\neapply match_stacks_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nextlia.\neapply external_call_nextblock; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : transf_fundef (funenv_program cunit) (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"simpl in FD.\ninv FD.\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_bound with (Mem.nextblock m'0).\neapply match_stacks_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nextlia.\neapply external_call_nextblock; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : OK (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' fd' args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\ match_states (Returnstate s res m') (Callstate stk' fd' args' m'0)","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (fd' : fundef) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (FD : OK (External ef) = OK fd') (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"inv FD.\nleft; econstructor; split.\neapply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_bound with (Mem.nextblock m'0).\neapply match_stacks_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nextlia.\neapply external_call_nextblock; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : (exists S2' : RTL.state,\n   plus step tge (Callstate stk' (External ef) args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\\nmatch_states (Returnstate s res m') (Callstate stk' (External ef) args' m'0).","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Callstate stk' (External ef) args' m'0) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(measure (Returnstate s res m') < measure (Callstate s (External ef) args m))%nat /\\\nt = E0 /\\\nmatch_states (Returnstate s res m') (Callstate stk' (External ef) args' m'0)","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor.\neapply match_stacks_bound with (Mem.nextblock m'0).\neapply match_stacks_extcall with (F1 := F) (F2 := F1) (m1 := m) (m1' := m'0); eauto.\nintros; eapply external_call_max_perm; eauto.\nintros; eapply external_call_max_perm; eauto.\nextlia.\neapply external_call_nextblock; eauto.\nauto.\nauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"apply senv_preserved."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m b -> Mem.perm m' b ofs Max p -> Mem.perm m b ofs Max p.","conclusion":"forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m b -> Mem.perm m' b ofs Max p -> Mem.perm m b ofs Max p","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"intros; eapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m'0 b -> Mem.perm m1' b ofs Max p -> Mem.perm m'0 b ofs Max p.","conclusion":"forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m'0 b -> Mem.perm m1' b ofs Max p -> Mem.perm m'0 b ofs Max p","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"intros; eapply external_call_max_perm; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : Ple (Mem.nextblock m'0) (Mem.nextblock m'0).","conclusion":"Ple (Mem.nextblock m'0) (Mem.nextblock m'0)","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"extlia."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0) : Ple (Mem.nextblock m'0) (Mem.nextblock m1').","conclusion":"Ple (Mem.nextblock m'0) (Mem.nextblock m1')","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (args' : list val) (m'0 : mem) (cunit : program) (F : meminj) (MS0 : match_stacks F m m'0 s stk' (Mem.nextblock m'0)) (LINK : linkorder cunit prog) (VINJ : Val.inject_list F args args') (MINJ : Mem.inject F m m'0) (bound : block) (MG : match_globalenvs F bound) (F1 : meminj) (v1 : val) (m1' : mem) (A : external_call ef ge args' m'0 t v1 m1') (B : Val.inject F1 res v1) (C : Mem.inject F1 m' m1') (D : Mem.unchanged_on (loc_unmapped F) m m') (E : Mem.unchanged_on (loc_out_of_reach F m) m'0 m1') (J : inject_incr F F1) (K : inject_separated F F1 m m'0)","proofString":"eapply external_call_nextblock; eauto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (v' : val) (m' : mem) (F : meminj) (MS0 : match_stacks F m m' (Stackframe res f sp pc rs :: s) stk' (Mem.nextblock m')) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') : (exists S2' : RTL.state,\n   plus step tge (Returnstate stk' v' m') E0 S2' /\\\n   match_states (State s f sp pc rs # res <- vres m) S2') \\/\n(measure (State s f sp pc rs # res <- vres m) <\n measure (Returnstate (Stackframe res f sp pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc rs # res <- vres m) (Returnstate stk' v' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (Returnstate stk' v' m') E0 S2' /\\\n   match_states (State s f sp pc rs # res <- vres m) S2') \\/\n(measure (State s f sp pc rs # res <- vres m) <\n measure (Returnstate (Stackframe res f sp pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc rs # res <- vres m) (Returnstate stk' v' m')","hypotheses":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (v' : val) (m' : mem) (F : meminj) (MS0 : match_stacks F m m' (Stackframe res f sp pc rs :: s) stk' (Mem.nextblock m')) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m')","proofString":"inv MS0.\nleft; econstructor; split.\neapply plus_one.\neapply exec_return.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto.\ninv MS; try congruence.\nrewrite RET in RET0; inv RET0.\nleft; econstructor; split.\neapply plus_one.\neapply exec_return.\neapply match_regular_states.\neapply match_stacks_inside_set_reg; eauto.\neauto.\nauto.\napply agree_set_reg; auto.\nauto.\nauto.\nauto.\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply PRIV; lia.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (sp0 : block) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' s stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' (Mem.nextblock m')) : (exists S2' : RTL.state,\n   plus step tge\n     (Returnstate\n        (Stackframe (sreg ctx res) f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs'\n         :: stk'0) v' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (Returnstate\n     (Stackframe (sreg ctx res) f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs'\n      :: stk'0) v' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge\n     (Returnstate\n        (Stackframe (sreg ctx res) f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs'\n         :: stk'0) v' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (Returnstate\n     (Stackframe (sreg ctx res) f' (Vptr sp' Ptrofs.zero) (spc ctx pc) rs'\n      :: stk'0) v' m')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (sp0 : block) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' s stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' (Mem.nextblock m'))","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_return.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (sp0 : block) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' s stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' (Mem.nextblock m')) : match_stacks_inside F m m' s stk'0 f' ctx sp' rs' # (sreg ctx res) <- v'.","conclusion":"match_stacks_inside F m m' s stk'0 f' ctx sp' rs' # (sreg ctx res) <- v'","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (sp0 : block) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' s stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' (Mem.nextblock m'))","proofString":"apply match_stacks_inside_set_reg; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (sp0 : block) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' s stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' (Mem.nextblock m')) : agree_regs F ctx rs # res <- vres rs' # (sreg ctx res) <- v'.","conclusion":"agree_regs F ctx rs # res <- vres rs' # (sreg ctx res) <- v'","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (sp0 : block) (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (fenv : funenv) (ctx : context) (MS : match_stacks_inside F m m' s stk'0 f' ctx sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (AG : agree_regs F ctx rs rs') (SP : F sp0 = Some (sp', dstk ctx)) (PRIV : range_private F m m' sp' (dstk ctx + mstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RES : Ple res (mreg ctx)) (BELOW : Plt sp' (Mem.nextblock m'))","proofString":"apply agree_set_reg; auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (res0 : reg) (f' : function) (sp' : block) (rpc : node) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (MS : match_stacks_inside F m m' (Stackframe res f sp pc rs :: s) stk'0 f' ctx sp'\n  rs') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RET : retinfo ctx = Some (rpc, res0)) (BELOW : Plt sp' (Mem.nextblock m')) : (exists S2' : RTL.state,\n   plus step tge\n     (Returnstate\n        (Stackframe res0 f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0) v' m')\n     E0 S2' /\\ match_states (State s f sp pc rs # res <- vres m) S2') \\/\n(measure (State s f sp pc rs # res <- vres m) <\n measure (Returnstate (Stackframe res f sp pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc rs # res <- vres m)\n  (Returnstate (Stackframe res0 f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0)\n     v' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge\n     (Returnstate\n        (Stackframe res0 f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0) v' m')\n     E0 S2' /\\ match_states (State s f sp pc rs # res <- vres m) S2') \\/\n(measure (State s f sp pc rs # res <- vres m) <\n measure (Returnstate (Stackframe res f sp pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc rs # res <- vres m)\n  (Returnstate (Stackframe res0 f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0)\n     v' m')","hypotheses":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (res0 : reg) (f' : function) (sp' : block) (rpc : node) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (MS : match_stacks_inside F m m' (Stackframe res f sp pc rs :: s) stk'0 f' ctx sp'\n  rs') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RET : retinfo ctx = Some (rpc, res0)) (BELOW : Plt sp' (Mem.nextblock m'))","proofString":"inv MS; try congruence.\nrewrite RET in RET0; inv RET0.\nleft; econstructor; split.\neapply plus_one.\neapply exec_return.\neapply match_regular_states.\neapply match_stacks_inside_set_reg; eauto.\neauto.\nauto.\napply agree_set_reg; auto.\nauto.\nauto.\nauto.\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply PRIV; lia.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (res0 : reg) (f' : function) (sp' : block) (rpc : node) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RET : retinfo ctx = Some (rpc, res0)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (ctx' : context) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) : (exists S2' : RTL.state,\n   plus step tge\n     (Returnstate\n        (Stackframe res0 f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0) v' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (Returnstate (Stackframe res0 f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0)\n     v' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge\n     (Returnstate\n        (Stackframe res0 f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0) v' m')\n     E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (Returnstate (Stackframe res0 f' (Vptr sp' Ptrofs.zero) rpc rs' :: stk'0)\n     v' m')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (res0 : reg) (f' : function) (sp' : block) (rpc : node) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (RET : retinfo ctx = Some (rpc, res0)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (ctx' : context) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx)","proofString":"rewrite RET in RET0; inv RET0.\nleft; econstructor; split.\neapply plus_one.\neapply exec_return.\neapply match_regular_states.\neapply match_stacks_inside_set_reg; eauto.\neauto.\nauto.\napply agree_set_reg; auto.\nauto.\nauto.\nauto.\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply PRIV; lia.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) : (exists S2' : RTL.state,\n   plus step tge\n     (Returnstate\n        (Stackframe (sreg ctx' res) f' (Vptr sp' Ptrofs.zero) \n           (spc ctx' pc) rs' :: stk'0) v' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (Returnstate\n     (Stackframe (sreg ctx' res) f' (Vptr sp' Ptrofs.zero) (spc ctx' pc) rs'\n      :: stk'0) v' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge\n     (Returnstate\n        (Stackframe (sreg ctx' res) f' (Vptr sp' Ptrofs.zero) \n           (spc ctx' pc) rs' :: stk'0) v' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (Returnstate\n     (Stackframe (sreg ctx' res) f' (Vptr sp' Ptrofs.zero) (spc ctx' pc) rs'\n      :: stk'0) v' m')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx)","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_return.\neapply match_regular_states.\neapply match_stacks_inside_set_reg; eauto.\neauto.\nauto.\napply agree_set_reg; auto.\nauto.\nauto.\nauto.\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply PRIV; lia.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) : Mem.valid_block m' sp'.","conclusion":"Mem.valid_block m' sp'","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx)","proofString":"auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f')","proofString":"destruct (zlt ofs (dstk ctx)).\napply PAD; lia.\napply PRIV; lia."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (l : ofs < dstk ctx) : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (l : ofs < dstk ctx)","proofString":"apply PAD; lia."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (g : ofs >= dstk ctx) : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (g : ofs >= dstk ctx)","proofString":"apply PRIV; lia."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) : 0 <= fn_stacksize f' < Ptrofs.max_unsigned.","conclusion":"0 <= fn_stacksize f' < Ptrofs.max_unsigned","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx)","proofString":"auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'.","conclusion":"forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f'","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (v' : val) (m' : mem) (F : meminj) (VINJ : Val.inject F vres v') (MINJ : Mem.inject F m m') (f' : function) (sp' : block) (rs' : regset) (stk'0 : list stackframe) (ctx : context) (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (ctx' : context) (RET : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : Plt sp' (Mem.nextblock m')) (sp0 : block) (fenv : funenv) (MS0 : match_stacks_inside F m m' s stk'0 f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (BELOW0 : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx)","proofString":"auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (MS0 : match_stacks_inside F m m' (Stackframe res f sp pc rs :: s) stk' f' ctx sp'\n  rs') (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f sp pc rs # res <- vres m) S2') \\/\n(measure (State s f sp pc rs # res <- vres m) <\n measure (Returnstate (Stackframe res f sp pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f sp pc rs # res <- vres m) S2') \\/\n(measure (State s f sp pc rs # res <- vres m) <\n measure (Returnstate (Stackframe res f sp pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m')","hypotheses":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (MS0 : match_stacks_inside F m m' (Stackframe res f sp pc rs :: s) stk' f' ctx sp'\n  rs') (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"inv MS0; try congruence.\nrewrite RET0 in RET; inv RET.\nunfold inline_return in AT.\nassert (PRIV': range_private F m m' sp' (dstk ctx' + mstk ctx') f'.(fn_stacksize)).\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD.\nlia.\napply PRIV.\nlia.\ndestruct or.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nsimpl.\nreflexivity.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto.\nsubst vres.\napply agree_set_reg_undef'; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (ctx' : context) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (ctx' : context) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx)","proofString":"rewrite RET0 in RET; inv RET.\nunfold inline_return in AT.\nassert (PRIV': range_private F m m' sp' (dstk ctx' + mstk ctx') f'.(fn_stacksize)).\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD.\nlia.\napply PRIV.\nlia.\ndestruct or.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nsimpl.\nreflexivity.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto.\nsubst vres.\napply agree_set_reg_undef'; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' = Some (inline_return ctx or (spc ctx' pc, sreg ctx' res))) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' = Some (inline_return ctx or (spc ctx' pc, sreg ctx' res))) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx)","proofString":"unfold inline_return in AT.\nassert (PRIV': range_private F m m' sp' (dstk ctx' + mstk ctx') f'.(fn_stacksize)).\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD.\nlia.\napply PRIV.\nlia.\ndestruct or.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nsimpl.\nreflexivity.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto.\nsubst vres.\napply agree_set_reg_undef'; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx)","proofString":"assert (PRIV': range_private F m m' sp' (dstk ctx' + mstk ctx') f'.(fn_stacksize)).\nred; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD.\nlia.\napply PRIV.\nlia.\ndestruct or.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nsimpl.\nreflexivity.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto.\nsubst vres.\napply agree_set_reg_undef'; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f').","conclusion":"range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx)","proofString":"red; intros.\ndestruct (zlt ofs (dstk ctx)).\napply PAD.\nlia.\napply PRIV.\nlia."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f')","proofString":"destruct (zlt ofs (dstk ctx)).\napply PAD.\nlia.\napply PRIV.\nlia."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (l : ofs < dstk ctx) : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (l : ofs < dstk ctx)","proofString":"apply PAD.\nlia."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (l : ofs < dstk ctx) : dstk ctx' + mstk ctx' <= ofs < dstk ctx.","conclusion":"dstk ctx' + mstk ctx' <= ofs < dstk ctx","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (l : ofs < dstk ctx)","proofString":"lia."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (g : ofs >= dstk ctx) : loc_private F m m' sp' ofs.","conclusion":"loc_private F m m' sp' ofs","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (g : ofs >= dstk ctx)","proofString":"apply PRIV.\nlia."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (g : ofs >= dstk ctx) : dstk ctx <= ofs < fn_stacksize f'.","conclusion":"dstk ctx <= ofs < fn_stacksize f'","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs0 : Z,\nMem.perm m' sp' ofs0 Max Nonempty -> 0 <= ofs0 <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (ofs : Z) (H : dstk ctx' + mstk ctx' <= ofs < fn_stacksize f') (g : ofs >= dstk ctx)","proofString":"lia."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f')) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome\n  match or with\n  | Some r => Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc)\n  | None => Inop (spc ctx' pc)\n  end) (VINJ : match or with\n| Some r => Val.inject F vres rs' # (sreg ctx r)\n| None => vres = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f'))","proofString":"destruct or.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nsimpl.\nreflexivity.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto.\nleft; econstructor; split.\neapply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto.\nsubst vres.\napply agree_set_reg_undef'; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (r : reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome (Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc))) (VINJ : Val.inject F vres rs' # (sreg ctx r)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f')) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (r : reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome (Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc))) (VINJ : Val.inject F vres rs' # (sreg ctx r)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f'))","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Iop; eauto.\nsimpl.\nreflexivity.\neconstructor; eauto.\napply match_stacks_inside_set_reg; auto.\napply agree_set_reg; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (r : reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome (Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc))) (VINJ : Val.inject F vres rs' # (sreg ctx r)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f')) : match_stacks_inside F m m' s stk' f' ctx' sp'\n  rs' # (sreg ctx' res) <- (rs' # (sreg ctx r)).","conclusion":"match_stacks_inside F m m' s stk' f' ctx' sp'\n  rs' # (sreg ctx' res) <- (rs' # (sreg ctx r))","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (r : reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome (Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc))) (VINJ : Val.inject F vres rs' # (sreg ctx r)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f'))","proofString":"apply match_stacks_inside_set_reg; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (r : reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome (Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc))) (VINJ : Val.inject F vres rs' # (sreg ctx r)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f')) : agree_regs F ctx' rs # res <- vres\n  rs' # (sreg ctx' res) <- (rs' # (sreg ctx r)).","conclusion":"agree_regs F ctx' rs # res <- vres\n  rs' # (sreg ctx' res) <- (rs' # (sreg ctx r))","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (r : reg) (ctx' : context) (AT : (fn_code f') ! pc' =\nSome (Iop Omove (sreg ctx r :: nil) (sreg ctx' res) (spc ctx' pc))) (VINJ : Val.inject F vres rs' # (sreg ctx r)) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f'))","proofString":"apply agree_set_reg; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (ctx' : context) (AT : (fn_code f') ! pc' = Some (Inop (spc ctx' pc))) (VINJ : vres = Vundef) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f')) : (exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m').","conclusion":"(exists S2' : RTL.state,\n   plus step tge (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(measure (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) <\n measure\n   (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n  (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m')","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (ctx' : context) (AT : (fn_code f') ! pc' = Some (Inop (spc ctx' pc))) (VINJ : vres = Vundef) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f'))","proofString":"left; econstructor; split.\neapply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto.\nsubst vres.\napply agree_set_reg_undef'; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (ctx' : context) (AT : (fn_code f') ! pc' = Some (Inop (spc ctx' pc))) (VINJ : vres = Vundef) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f')) : agree_regs F ctx' rs # res <- vres rs'.","conclusion":"agree_regs F ctx' rs # res <- vres rs'","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (ctx' : context) (AT : (fn_code f') ! pc' = Some (Inop (spc ctx' pc))) (VINJ : vres = Vundef) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f'))","proofString":"subst vres.\napply agree_set_reg_undef'; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (ctx' : context) (AT : (fn_code f') ! pc' = Some (Inop (spc ctx' pc))) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f')) : agree_regs F ctx' rs # res <- Vundef rs'.","conclusion":"agree_regs F ctx' rs # res <- Vundef rs'","hypotheses":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (ctx' : context) (AT : (fn_code f') ! pc' = Some (Inop (spc ctx' pc))) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (sp0 : block) (fenv : funenv) (MS : match_stacks_inside F m m' s stk' f' ctx' sp' rs') (COMPAT : fenv_compat prog fenv) (FB : tr_funbody fenv (fn_stacksize f') ctx' f (fn_code f')) (AG : agree_regs F ctx' rs rs') (SP : F sp0 = Some (sp', dstk ctx')) (PAD : range_private F m m' sp' (dstk ctx' + mstk ctx') (dstk ctx)) (RES : Ple res (mreg ctx')) (RET0 : retinfo ctx = Some (spc ctx' pc, sreg ctx' res)) (BELOW : context_below ctx' ctx) (SBELOW : context_stack_call ctx' ctx) (PRIV' : range_private F m m' sp' (dstk ctx' + mstk ctx') (fn_stacksize f'))","proofString":"apply agree_set_reg_undef'; auto."},{"statement":"(st1 : RTL.state) (H : initial_state prog st1) : exists st2 : RTL.state, initial_state tprog st2 /\\ match_states st1 st2.","conclusion":"exists st2 : RTL.state, initial_state tprog st2 /\\ match_states st1 st2","hypotheses":"(st1 : RTL.state) (H : initial_state prog st1)","proofString":"inv H.\nexploit function_ptr_translated; eauto.\nintros (cu & tf & FIND & TR & LINK).\nexists (Callstate nil tf nil m0); split.\neconstructor; eauto.\neapply (Genv.init_mem_match TRANSF); eauto.\nrewrite symbols_preserved.\nreplace (prog_main tprog) with (prog_main prog).\nauto.\nsymmetry; eapply match_program_main; eauto.\nrewrite <- H3.\neapply sig_function_translated; eauto.\neconstructor; eauto.\ninstantiate (1 := Mem.flat_inj (Mem.nextblock m0)).\napply match_stacks_nil with (Mem.nextblock m0).\nconstructor; intros.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\nunfold Mem.flat_inj in H.\ndestruct (plt b1 (Mem.nextblock m0)); congruence.\neapply Genv.find_symbol_not_fresh; eauto.\neapply Genv.find_funct_ptr_not_fresh; eauto.\neapply Genv.find_var_info_not_fresh; eauto.\napply Ple_refl.\neapply Genv.initmem_inject; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) : Genv.init_mem tprog = Some m0.","conclusion":"Genv.init_mem tprog = Some m0","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog)","proofString":"eapply (Genv.init_mem_match TRANSF); eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) : prog_main prog = prog_main tprog.","conclusion":"prog_main prog = prog_main tprog","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog)","proofString":"symmetry; eapply match_program_main; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) : funsig tf = signature_main.","conclusion":"funsig tf = signature_main","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog)","proofString":"rewrite <- H3.\neapply sig_function_translated; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) : funsig tf = funsig f.","conclusion":"funsig tf = funsig f","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog)","proofString":"eapply sig_function_translated; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) : match_states (Callstate nil f nil m0) (Callstate nil tf nil m0).","conclusion":"match_states (Callstate nil f nil m0) (Callstate nil tf nil m0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog)","proofString":"econstructor; eauto.\ninstantiate (1 := Mem.flat_inj (Mem.nextblock m0)).\napply match_stacks_nil with (Mem.nextblock m0).\nconstructor; intros.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\nunfold Mem.flat_inj in H.\ndestruct (plt b1 (Mem.nextblock m0)); congruence.\neapply Genv.find_symbol_not_fresh; eauto.\neapply Genv.find_funct_ptr_not_fresh; eauto.\neapply Genv.find_var_info_not_fresh; eauto.\napply Ple_refl.\neapply Genv.initmem_inject; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) : match_stacks (Mem.flat_inj (Mem.nextblock m0)) m0 m0 nil nil\n  (Mem.nextblock m0).","conclusion":"match_stacks (Mem.flat_inj (Mem.nextblock m0)) m0 m0 nil nil\n  (Mem.nextblock m0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog)","proofString":"apply match_stacks_nil with (Mem.nextblock m0).\nconstructor; intros.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\nunfold Mem.flat_inj in H.\ndestruct (plt b1 (Mem.nextblock m0)); congruence.\neapply Genv.find_symbol_not_fresh; eauto.\neapply Genv.find_funct_ptr_not_fresh; eauto.\neapply Genv.find_var_info_not_fresh; eauto.\napply Ple_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) : match_globalenvs (Mem.flat_inj (Mem.nextblock m0)) (Mem.nextblock m0).","conclusion":"match_globalenvs (Mem.flat_inj (Mem.nextblock m0)) (Mem.nextblock m0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog)","proofString":"constructor; intros.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\nunfold Mem.flat_inj in H.\ndestruct (plt b1 (Mem.nextblock m0)); congruence.\neapply Genv.find_symbol_not_fresh; eauto.\neapply Genv.find_funct_ptr_not_fresh; eauto.\neapply Genv.find_var_info_not_fresh; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b0 : positive) (H : Plt b0 (Mem.nextblock m0)) : Mem.flat_inj (Mem.nextblock m0) b0 = Some (b0, 0).","conclusion":"Mem.flat_inj (Mem.nextblock m0) b0 = Some (b0, 0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b0 : positive) (H : Plt b0 (Mem.nextblock m0))","proofString":"unfold Mem.flat_inj.\napply pred_dec_true; auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b0 : positive) (H : Plt b0 (Mem.nextblock m0)) : (if plt b0 (Mem.nextblock m0) then Some (b0, 0) else None) = Some (b0, 0).","conclusion":"(if plt b0 (Mem.nextblock m0) then Some (b0, 0) else None) = Some (b0, 0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b0 : positive) (H : Plt b0 (Mem.nextblock m0))","proofString":"apply pred_dec_true; auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b1 b2 : block) (delta : Z) (H : Mem.flat_inj (Mem.nextblock m0) b1 = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0)) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b1 b2 : block) (delta : Z) (H : Mem.flat_inj (Mem.nextblock m0) b1 = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0))","proofString":"unfold Mem.flat_inj in H.\ndestruct (plt b1 (Mem.nextblock m0)); congruence."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b1 b2 : block) (delta : Z) (H : (if plt b1 (Mem.nextblock m0) then Some (b1, 0) else None) = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0)) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b1 b2 : block) (delta : Z) (H : (if plt b1 (Mem.nextblock m0) then Some (b1, 0) else None) = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0))","proofString":"destruct (plt b1 (Mem.nextblock m0)); congruence."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (id : ident) (b0 : block) (H : Genv.find_symbol ge id = Some b0) : Plt b0 (Mem.nextblock m0).","conclusion":"Plt b0 (Mem.nextblock m0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (id : ident) (b0 : block) (H : Genv.find_symbol ge id = Some b0)","proofString":"eapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b0 : block) (fd : fundef) (H : Genv.find_funct_ptr ge b0 = Some fd) : Plt b0 (Mem.nextblock m0).","conclusion":"Plt b0 (Mem.nextblock m0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b0 : block) (fd : fundef) (H : Genv.find_funct_ptr ge b0 = Some fd)","proofString":"eapply Genv.find_funct_ptr_not_fresh; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b0 : block) (gv : globvar unit) (H : Genv.find_var_info ge b0 = Some gv) : Plt b0 (Mem.nextblock m0).","conclusion":"Plt b0 (Mem.nextblock m0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) (b0 : block) (gv : globvar unit) (H : Genv.find_var_info ge b0 = Some gv)","proofString":"eapply Genv.find_var_info_not_fresh; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog) : Ple (Mem.nextblock m0) (Mem.nextblock m0).","conclusion":"Ple (Mem.nextblock m0) (Mem.nextblock m0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (cu : program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef (funenv_program cu) f = OK tf) (LINK : linkorder cu prog)","proofString":"apply Ple_refl."},{"statement":"(st1 st2 : RTL.state) (r : int) (H : match_states st1 st2) (H0 : final_state st1 r) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st1 st2 : RTL.state) (r : int) (H : match_states st1 st2) (H0 : final_state st1 r)","proofString":"inv H0.\ninv H.\nexploit match_stacks_empty; eauto.\nintros EQ; subst.\ninv VINJ.\nconstructor.\nexploit match_stacks_inside_empty; eauto.\nintros [A B].\ncongruence."},{"statement":"(st2 : RTL.state) (r : int) (m : mem) (H : match_states (Returnstate nil (Vint r) m) st2) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st2 : RTL.state) (r : int) (m : mem) (H : match_states (Returnstate nil (Vint r) m) st2)","proofString":"inv H.\nexploit match_stacks_empty; eauto.\nintros EQ; subst.\ninv VINJ.\nconstructor.\nexploit match_stacks_inside_empty; eauto.\nintros [A B].\ncongruence."},{"statement":"(r : int) (m : mem) (stk' : list stackframe) (v' : val) (m' : mem) (F : meminj) (MS : match_stacks F m m' nil stk' (Mem.nextblock m')) (VINJ : Val.inject F (Vint r) v') (MINJ : Mem.inject F m m') : final_state (Returnstate stk' v' m') r.","conclusion":"final_state (Returnstate stk' v' m') r","hypotheses":"(r : int) (m : mem) (stk' : list stackframe) (v' : val) (m' : mem) (F : meminj) (MS : match_stacks F m m' nil stk' (Mem.nextblock m')) (VINJ : Val.inject F (Vint r) v') (MINJ : Mem.inject F m m')","proofString":"exploit match_stacks_empty; eauto.\nintros EQ; subst.\ninv VINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (stk' : list stackframe) (v' : val) (m' : mem) (F : meminj) (MS : match_stacks F m m' nil stk' (Mem.nextblock m')) (VINJ : Val.inject F (Vint r) v') (MINJ : Mem.inject F m m') : stk' = nil -> final_state (Returnstate stk' v' m') r.","conclusion":"stk' = nil -> final_state (Returnstate stk' v' m') r","hypotheses":"(r : int) (m : mem) (stk' : list stackframe) (v' : val) (m' : mem) (F : meminj) (MS : match_stacks F m m' nil stk' (Mem.nextblock m')) (VINJ : Val.inject F (Vint r) v') (MINJ : Mem.inject F m m')","proofString":"intros EQ; subst.\ninv VINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (v' : val) (m' : mem) (F : meminj) (MS : match_stacks F m m' nil nil (Mem.nextblock m')) (VINJ : Val.inject F (Vint r) v') (MINJ : Mem.inject F m m') : final_state (Returnstate nil v' m') r.","conclusion":"final_state (Returnstate nil v' m') r","hypotheses":"(r : int) (m : mem) (v' : val) (m' : mem) (F : meminj) (MS : match_stacks F m m' nil nil (Mem.nextblock m')) (VINJ : Val.inject F (Vint r) v') (MINJ : Mem.inject F m m')","proofString":"inv VINJ.\nconstructor."},{"statement":"(r : int) (m m' : mem) (F : meminj) (MS : match_stacks F m m' nil nil (Mem.nextblock m')) (MINJ : Mem.inject F m m') : final_state (Returnstate nil (Vint r) m') r.","conclusion":"final_state (Returnstate nil (Vint r) m') r","hypotheses":"(r : int) (m m' : mem) (F : meminj) (MS : match_stacks F m m' nil nil (Mem.nextblock m')) (MINJ : Mem.inject F m m')","proofString":"constructor."},{"statement":"(r : int) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (MS : match_stacks_inside F m m' nil stk' f' ctx sp' rs') (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r0 => Val.inject F (Vint r) rs' # (sreg ctx r0)\n| None => Vint r = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : final_state (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') r.","conclusion":"final_state (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') r","hypotheses":"(r : int) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (MS : match_stacks_inside F m m' nil stk' f' ctx sp' rs') (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r0 => Val.inject F (Vint r) rs' # (sreg ctx r0)\n| None => Vint r = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"exploit match_stacks_inside_empty; eauto.\nintros [A B].\ncongruence."},{"statement":"(r : int) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (MS : match_stacks_inside F m m' nil stk' f' ctx sp' rs') (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r0 => Val.inject F (Vint r) rs' # (sreg ctx r0)\n| None => Vint r = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') : stk' = nil /\\ retinfo ctx = None ->\nfinal_state (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') r.","conclusion":"stk' = nil /\\ retinfo ctx = None ->\nfinal_state (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') r","hypotheses":"(r : int) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (MS : match_stacks_inside F m m' nil stk' f' ctx sp' rs') (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r0 => Val.inject F (Vint r) rs' # (sreg ctx r0)\n| None => Vint r = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f')","proofString":"intros [A B].\ncongruence."},{"statement":"(r : int) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (MS : match_stacks_inside F m m' nil stk' f' ctx sp' rs') (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r0 => Val.inject F (Vint r) rs' # (sreg ctx r0)\n| None => Vint r = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (A : stk' = nil) (B : retinfo ctx = None) : final_state (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') r.","conclusion":"final_state (State stk' f' (Vptr sp' Ptrofs.zero) pc' rs' m') r","hypotheses":"(r : int) (m : mem) (stk' : list stackframe) (f' : function) (sp' : block) (rs' : regset) (m' : mem) (F : meminj) (ctx : context) (pc' : positive) (or : option reg) (rinfo : node * reg) (MS : match_stacks_inside F m m' nil stk' f' ctx sp' rs') (RET : retinfo ctx = Some rinfo) (AT : (fn_code f') ! pc' = Some (inline_return ctx or rinfo)) (VINJ : match or with\n| Some r0 => Val.inject F (Vint r) rs' # (sreg ctx r0)\n| None => Vint r = Vundef\nend) (MINJ : Mem.inject F m m') (VB : Mem.valid_block m' sp') (PRIV : range_private F m m' sp' (dstk ctx) (fn_stacksize f')) (SSZ1 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) (SSZ2 : forall ofs : Z,\nMem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= fn_stacksize f') (A : stk' = nil) (B : retinfo ctx = None)","proofString":"congruence."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id","hypotheses":"","proofString":"apply senv_preserved."}]}