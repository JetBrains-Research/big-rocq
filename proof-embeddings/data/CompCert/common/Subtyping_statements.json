{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Subtyping.v","fileSamples":[{"statement":"(lo hi : T.t) (s : T.sub lo hi) : T.weight hi - T.weight lo < T.max_weight + 1.","proofString":"generalize (T.weight_range hi); lia."},{"statement":"(lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (H : T.sub lo2 lo1) (H0 : T.sub hi1 hi2) (H1 : lo1 <> lo2 \\/ hi1 <> hi2) : T.weight hi1 - T.weight lo1 < T.weight hi2 - T.weight lo2.","proofString":"generalize (T.weight_sub _ _ s1) (T.weight_sub _ _ s2) (T.weight_sub _ _ H) (T.weight_sub _ _ H0); intros.\ndestruct H1.\nassert (T.weight lo2 < T.weight lo1) by (apply T.weight_sub_strict; auto).\nlia.\nassert (T.weight hi1 < T.weight hi2) by (apply T.weight_sub_strict; auto).\nlia."},{"statement":"(lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (H : T.sub lo2 lo1) (H0 : T.sub hi1 hi2) (H1 : lo1 <> lo2 \\/ hi1 <> hi2) (H2 : T.weight lo1 <= T.weight hi1) (H3 : T.weight lo2 <= T.weight hi2) (H4 : T.weight lo2 <= T.weight lo1) (H5 : T.weight hi1 <= T.weight hi2) : T.weight hi1 - T.weight lo1 < T.weight hi2 - T.weight lo2.","proofString":"destruct H1.\nassert (T.weight lo2 < T.weight lo1) by (apply T.weight_sub_strict; auto).\nlia.\nassert (T.weight hi1 < T.weight hi2) by (apply T.weight_sub_strict; auto).\nlia."},{"statement":"(lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (H : T.sub lo2 lo1) (H0 : T.sub hi1 hi2) (H1 : lo1 <> lo2) (H2 : T.weight lo1 <= T.weight hi1) (H3 : T.weight lo2 <= T.weight hi2) (H4 : T.weight lo2 <= T.weight lo1) (H5 : T.weight hi1 <= T.weight hi2) : T.weight hi1 - T.weight lo1 < T.weight hi2 - T.weight lo2.","proofString":"assert (T.weight lo2 < T.weight lo1) by (apply T.weight_sub_strict; auto).\nlia."},{"statement":"(lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (H : T.sub lo2 lo1) (H0 : T.sub hi1 hi2) (H1 : lo1 <> lo2) (H2 : T.weight lo1 <= T.weight hi1) (H3 : T.weight lo2 <= T.weight hi2) (H4 : T.weight lo2 <= T.weight lo1) (H5 : T.weight hi1 <= T.weight hi2) (H6 : T.weight lo2 < T.weight lo1) : T.weight hi1 - T.weight lo1 < T.weight hi2 - T.weight lo2.","proofString":"lia."},{"statement":"(lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (H : T.sub lo2 lo1) (H0 : T.sub hi1 hi2) (H1 : hi1 <> hi2) (H2 : T.weight lo1 <= T.weight hi1) (H3 : T.weight lo2 <= T.weight hi2) (H4 : T.weight lo2 <= T.weight lo1) (H5 : T.weight hi1 <= T.weight hi2) : T.weight hi1 - T.weight lo1 < T.weight hi2 - T.weight lo2.","proofString":"assert (T.weight hi1 < T.weight hi2) by (apply T.weight_sub_strict; auto).\nlia."},{"statement":"(lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (H : T.sub lo2 lo1) (H0 : T.sub hi1 hi2) (H1 : hi1 <> hi2) (H2 : T.weight lo1 <= T.weight hi1) (H3 : T.weight lo2 <= T.weight hi2) (H4 : T.weight lo2 <= T.weight lo1) (H5 : T.weight hi1 <= T.weight hi2) (H6 : T.weight hi1 < T.weight hi2) : T.weight hi1 - T.weight lo1 < T.weight hi2 - T.weight lo2.","proofString":"lia."},{"statement":"(b1 b2 : PTree.tree bounds) (H : forall r : positive, weight_bounds b1 ! r <= weight_bounds b2 ! r) : 0 <= 0.","proofString":"lia."},{"statement":"(b1 b2 : PTree.tree bounds) (H : forall r : positive, weight_bounds b1 ! r <= weight_bounds b2 ! r) (a : constraint) (q : list constraint) (IHq : weight_constraints b1 q <= weight_constraints b2 q) : weight_constraints b1 q + weight_bounds b1 ! (fst a) +\nweight_bounds b1 ! (snd a) <=\nweight_constraints b2 q + weight_bounds b2 ! (fst a) +\nweight_bounds b2 ! (snd a).","proofString":"generalize (H (fst a)) (H (snd a)); lia."},{"statement":"(e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : OK (e, changed) = OK (e', changed')) : (forall r : positive,\n weight_bounds (te_typ e') ! r <= weight_bounds (te_typ e) ! r) /\\\nweight_constraints (te_typ e') (te_sub e') +\n(if changed' && negb changed then 1 else 0) <=\nweight_constraints (te_typ e) (te_sub e) + 0.","proofString":"inv H.\nsplit.\nintros; lia.\nreplace (changed' && negb changed') with false.\nlia.\ndestruct changed'; auto."},{"statement":"(e' : typenv) (changed' : bool) : (forall r : positive,\n weight_bounds (te_typ e') ! r <= weight_bounds (te_typ e') ! r) /\\\nweight_constraints (te_typ e') (te_sub e') +\n(if changed' && negb changed' then 1 else 0) <=\nweight_constraints (te_typ e') (te_sub e') + 0.","proofString":"split.\nintros; lia.\nreplace (changed' && negb changed') with false.\nlia.\ndestruct changed'; auto."},{"statement":"(e' : typenv) (changed' : bool) : forall r : positive,\nweight_bounds (te_typ e') ! r <= weight_bounds (te_typ e') ! r.","proofString":"intros; lia."},{"statement":"(e' : typenv) (changed' : bool) : weight_constraints (te_typ e') (te_sub e') +\n(if changed' && negb changed' then 1 else 0) <=\nweight_constraints (te_typ e') (te_sub e') + 0.","proofString":"replace (changed' && negb changed') with false.\nlia.\ndestruct changed'; auto."},{"statement":"(e' : typenv) (changed' : bool) : weight_constraints (te_typ e') (te_sub e') + 0 <=\nweight_constraints (te_typ e') (te_sub e') + 0.","proofString":"lia."},{"statement":"(e' : typenv) (changed' : bool) : false = changed' && negb changed'.","proofString":"destruct changed'; auto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\n(forall r0 : positive,\n weight_bounds (te_typ e'0) ! r0 <= weight_bounds (te_typ e0) ! r0) /\\\nweight_constraints (te_typ e'0) (te_sub e'0) +\n(if changed'0 && negb changed0 then 1 else 0) <=\nweight_constraints (te_typ e0) (te_sub e0) + weight_constraints (te_typ e0) q) (e : typenv) (changed : bool) (e' : typenv) (changed' changed1 : bool) (e1 : typenv) (EQ : type_move e r1 r2 = OK (changed1, e1)) (EQ0 : solve_rec e1 (changed || changed1) q = OK (e', changed')) (A : te_sub e1 = te_sub e \\/ te_sub e1 = (r1, r2) :: te_sub e) (B : forall r0 : positive,\nweight_bounds (te_typ e1) ! r0 <= weight_bounds (te_typ e) ! r0) (C : changed1 = true ->\nweight_bounds (te_typ e1) ! r1 + weight_bounds (te_typ e1) ! r2 <\nweight_bounds (te_typ e) ! r1 + weight_bounds (te_typ e) ! r2) (D : forall r0 : positive,\nweight_bounds (te_typ e') ! r0 <= weight_bounds (te_typ e1) ! r0) (E : weight_constraints (te_typ e') (te_sub e') +\n(if changed' && negb (changed || changed1) then 1 else 0) <=\nweight_constraints (te_typ e1) (te_sub e1) + weight_constraints (te_typ e1) q) (r : positive) (P : weight_constraints (te_typ e1) (te_sub e) <=\nweight_constraints (te_typ e) (te_sub e)) : weight_constraints (te_typ e1) (te_sub e1) <=\nweight_constraints (te_typ e1) (te_sub e) + weight_bounds (te_typ e1) ! r1 +\nweight_bounds (te_typ e1) ! r2.","proofString":"destruct A as [Q|Q]; rewrite Q.\nlia.\nsimpl.\nlia."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\n(forall r0 : positive,\n weight_bounds (te_typ e'0) ! r0 <= weight_bounds (te_typ e0) ! r0) /\\\nweight_constraints (te_typ e'0) (te_sub e'0) +\n(if changed'0 && negb changed0 then 1 else 0) <=\nweight_constraints (te_typ e0) (te_sub e0) + weight_constraints (te_typ e0) q) (e : typenv) (changed : bool) (e' : typenv) (changed' changed1 : bool) (e1 : typenv) (EQ : type_move e r1 r2 = OK (changed1, e1)) (EQ0 : solve_rec e1 (changed || changed1) q = OK (e', changed')) (Q : te_sub e1 = te_sub e) (B : forall r0 : positive,\nweight_bounds (te_typ e1) ! r0 <= weight_bounds (te_typ e) ! r0) (C : changed1 = true ->\nweight_bounds (te_typ e1) ! r1 + weight_bounds (te_typ e1) ! r2 <\nweight_bounds (te_typ e) ! r1 + weight_bounds (te_typ e) ! r2) (D : forall r0 : positive,\nweight_bounds (te_typ e') ! r0 <= weight_bounds (te_typ e1) ! r0) (E : weight_constraints (te_typ e') (te_sub e') +\n(if changed' && negb (changed || changed1) then 1 else 0) <=\nweight_constraints (te_typ e1) (te_sub e1) + weight_constraints (te_typ e1) q) (r : positive) (P : weight_constraints (te_typ e1) (te_sub e) <=\nweight_constraints (te_typ e) (te_sub e)) : weight_constraints (te_typ e1) (te_sub e) <=\nweight_constraints (te_typ e1) (te_sub e) + weight_bounds (te_typ e1) ! r1 +\nweight_bounds (te_typ e1) ! r2.","proofString":"lia."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\n(forall r0 : positive,\n weight_bounds (te_typ e'0) ! r0 <= weight_bounds (te_typ e0) ! r0) /\\\nweight_constraints (te_typ e'0) (te_sub e'0) +\n(if changed'0 && negb changed0 then 1 else 0) <=\nweight_constraints (te_typ e0) (te_sub e0) + weight_constraints (te_typ e0) q) (e : typenv) (changed : bool) (e' : typenv) (changed' changed1 : bool) (e1 : typenv) (EQ : type_move e r1 r2 = OK (changed1, e1)) (EQ0 : solve_rec e1 (changed || changed1) q = OK (e', changed')) (Q : te_sub e1 = (r1, r2) :: te_sub e) (B : forall r0 : positive,\nweight_bounds (te_typ e1) ! r0 <= weight_bounds (te_typ e) ! r0) (C : changed1 = true ->\nweight_bounds (te_typ e1) ! r1 + weight_bounds (te_typ e1) ! r2 <\nweight_bounds (te_typ e) ! r1 + weight_bounds (te_typ e) ! r2) (D : forall r0 : positive,\nweight_bounds (te_typ e') ! r0 <= weight_bounds (te_typ e1) ! r0) (E : weight_constraints (te_typ e') (te_sub e') +\n(if changed' && negb (changed || changed1) then 1 else 0) <=\nweight_constraints (te_typ e1) (te_sub e1) + weight_constraints (te_typ e1) q) (r : positive) (P : weight_constraints (te_typ e1) (te_sub e) <=\nweight_constraints (te_typ e) (te_sub e)) : weight_constraints (te_typ e1) ((r1, r2) :: te_sub e) <=\nweight_constraints (te_typ e1) (te_sub e) + weight_bounds (te_typ e1) ! r1 +\nweight_bounds (te_typ e1) ! r2.","proofString":"simpl.\nlia."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\n(forall r0 : positive,\n weight_bounds (te_typ e'0) ! r0 <= weight_bounds (te_typ e0) ! r0) /\\\nweight_constraints (te_typ e'0) (te_sub e'0) +\n(if changed'0 && negb changed0 then 1 else 0) <=\nweight_constraints (te_typ e0) (te_sub e0) + weight_constraints (te_typ e0) q) (e : typenv) (changed : bool) (e' : typenv) (changed' changed1 : bool) (e1 : typenv) (EQ : type_move e r1 r2 = OK (changed1, e1)) (EQ0 : solve_rec e1 (changed || changed1) q = OK (e', changed')) (Q : te_sub e1 = (r1, r2) :: te_sub e) (B : forall r0 : positive,\nweight_bounds (te_typ e1) ! r0 <= weight_bounds (te_typ e) ! r0) (C : changed1 = true ->\nweight_bounds (te_typ e1) ! r1 + weight_bounds (te_typ e1) ! r2 <\nweight_bounds (te_typ e) ! r1 + weight_bounds (te_typ e) ! r2) (D : forall r0 : positive,\nweight_bounds (te_typ e') ! r0 <= weight_bounds (te_typ e1) ! r0) (E : weight_constraints (te_typ e') (te_sub e') +\n(if changed' && negb (changed || changed1) then 1 else 0) <=\nweight_constraints (te_typ e1) (te_sub e1) + weight_constraints (te_typ e1) q) (r : positive) (P : weight_constraints (te_typ e1) (te_sub e) <=\nweight_constraints (te_typ e) (te_sub e)) : weight_constraints (te_typ e1) (te_sub e) + weight_bounds (te_typ e1) ! r1 +\nweight_bounds (te_typ e1) ! r2 <=\nweight_constraints (te_typ e1) (te_sub e) + weight_bounds (te_typ e1) ! r1 +\nweight_bounds (te_typ e1) ! r2.","proofString":"lia."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\n(forall r0 : positive,\n weight_bounds (te_typ e'0) ! r0 <= weight_bounds (te_typ e0) ! r0) /\\\nweight_constraints (te_typ e'0) (te_sub e'0) +\n(if changed'0 && negb changed0 then 1 else 0) <=\nweight_constraints (te_typ e0) (te_sub e0) + weight_constraints (te_typ e0) q) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (e1 : typenv) (EQ : type_move e r1 r2 = OK (true, e1)) (EQ0 : solve_rec e1 (changed || true) q = OK (e', changed')) (A : te_sub e1 = te_sub e \\/ te_sub e1 = (r1, r2) :: te_sub e) (B : forall r0 : positive,\nweight_bounds (te_typ e1) ! r0 <= weight_bounds (te_typ e) ! r0) (C : true = true ->\nweight_bounds (te_typ e1) ! r1 + weight_bounds (te_typ e1) ! r2 <\nweight_bounds (te_typ e) ! r1 + weight_bounds (te_typ e) ! r2) (D : forall r0 : positive,\nweight_bounds (te_typ e') ! r0 <= weight_bounds (te_typ e1) ! r0) (ch1 : nat) (E : weight_constraints (te_typ e') (te_sub e') + ch1 <=\nweight_constraints (te_typ e1) (te_sub e1) + weight_constraints (te_typ e1) q) (r : positive) (P : weight_constraints (te_typ e1) (te_sub e) <=\nweight_constraints (te_typ e) (te_sub e)) (Q : weight_constraints (te_typ e1) (te_sub e1) <=\nweight_constraints (te_typ e1) (te_sub e) + weight_bounds (te_typ e1) ! r1 +\nweight_bounds (te_typ e1) ! r2) (R : weight_constraints (te_typ e1) q <= weight_constraints (te_typ e) q) (ch2 : nat) : (if changed' && negb changed then 1 else 0) <=\n(if changed' && negb (changed || true) then 1 else 0) + 1.","proofString":"rewrite orb_true_r.\nsimpl.\nrewrite andb_false_r.\ndestruct (changed' && negb changed); lia."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\n(forall r0 : positive,\n weight_bounds (te_typ e'0) ! r0 <= weight_bounds (te_typ e0) ! r0) /\\\nweight_constraints (te_typ e'0) (te_sub e'0) +\n(if changed'0 && negb changed0 then 1 else 0) <=\nweight_constraints (te_typ e0) (te_sub e0) + weight_constraints (te_typ e0) q) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (e1 : typenv) (EQ : type_move e r1 r2 = OK (true, e1)) (EQ0 : solve_rec e1 (changed || true) q = OK (e', changed')) (A : te_sub e1 = te_sub e \\/ te_sub e1 = (r1, r2) :: te_sub e) (B : forall r0 : positive,\nweight_bounds (te_typ e1) ! r0 <= weight_bounds (te_typ e) ! r0) (C : true = true ->\nweight_bounds (te_typ e1) ! r1 + weight_bounds (te_typ e1) ! r2 <\nweight_bounds (te_typ e) ! r1 + weight_bounds (te_typ e) ! r2) (D : forall r0 : positive,\nweight_bounds (te_typ e') ! r0 <= weight_bounds (te_typ e1) ! r0) (ch1 : nat) (E : weight_constraints (te_typ e') (te_sub e') + ch1 <=\nweight_constraints (te_typ e1) (te_sub e1) + weight_constraints (te_typ e1) q) (r : positive) (P : weight_constraints (te_typ e1) (te_sub e) <=\nweight_constraints (te_typ e) (te_sub e)) (Q : weight_constraints (te_typ e1) (te_sub e1) <=\nweight_constraints (te_typ e1) (te_sub e) + weight_bounds (te_typ e1) ! r1 +\nweight_bounds (te_typ e1) ! r2) (R : weight_constraints (te_typ e1) q <= weight_constraints (te_typ e) q) (ch2 : nat) : (if changed' && negb changed then 1 else 0) <=\n(if changed' && negb true then 1 else 0) + 1.","proofString":"simpl.\nrewrite andb_false_r.\ndestruct (changed' && negb changed); lia."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\n(forall r0 : positive,\n weight_bounds (te_typ e'0) ! r0 <= weight_bounds (te_typ e0) ! r0) /\\\nweight_constraints (te_typ e'0) (te_sub e'0) +\n(if changed'0 && negb changed0 then 1 else 0) <=\nweight_constraints (te_typ e0) (te_sub e0) + weight_constraints (te_typ e0) q) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (e1 : typenv) (EQ : type_move e r1 r2 = OK (true, e1)) (EQ0 : solve_rec e1 (changed || true) q = OK (e', changed')) (A : te_sub e1 = te_sub e \\/ te_sub e1 = (r1, r2) :: te_sub e) (B : forall r0 : positive,\nweight_bounds (te_typ e1) ! r0 <= weight_bounds (te_typ e) ! r0) (C : true = true ->\nweight_bounds (te_typ e1) ! r1 + weight_bounds (te_typ e1) ! r2 <\nweight_bounds (te_typ e) ! r1 + weight_bounds (te_typ e) ! r2) (D : forall r0 : positive,\nweight_bounds (te_typ e') ! r0 <= weight_bounds (te_typ e1) ! r0) (ch1 : nat) (E : weight_constraints (te_typ e') (te_sub e') + ch1 <=\nweight_constraints (te_typ e1) (te_sub e1) + weight_constraints (te_typ e1) q) (r : positive) (P : weight_constraints (te_typ e1) (te_sub e) <=\nweight_constraints (te_typ e) (te_sub e)) (Q : weight_constraints (te_typ e1) (te_sub e1) <=\nweight_constraints (te_typ e1) (te_sub e) + weight_bounds (te_typ e1) ! r1 +\nweight_bounds (te_typ e1) ! r2) (R : weight_constraints (te_typ e1) q <= weight_constraints (te_typ e) q) (ch2 : nat) : (if changed' && negb changed then 1 else 0) <=\n(if changed' && false then 1 else 0) + 1.","proofString":"rewrite andb_false_r.\ndestruct (changed' && negb changed); lia."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\n(forall r0 : positive,\n weight_bounds (te_typ e'0) ! r0 <= weight_bounds (te_typ e0) ! r0) /\\\nweight_constraints (te_typ e'0) (te_sub e'0) +\n(if changed'0 && negb changed0 then 1 else 0) <=\nweight_constraints (te_typ e0) (te_sub e0) + weight_constraints (te_typ e0) q) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (e1 : typenv) (EQ : type_move e r1 r2 = OK (true, e1)) (EQ0 : solve_rec e1 (changed || true) q = OK (e', changed')) (A : te_sub e1 = te_sub e \\/ te_sub e1 = (r1, r2) :: te_sub e) (B : forall r0 : positive,\nweight_bounds (te_typ e1) ! r0 <= weight_bounds (te_typ e) ! r0) (C : true = true ->\nweight_bounds (te_typ e1) ! r1 + weight_bounds (te_typ e1) ! r2 <\nweight_bounds (te_typ e) ! r1 + weight_bounds (te_typ e) ! r2) (D : forall r0 : positive,\nweight_bounds (te_typ e') ! r0 <= weight_bounds (te_typ e1) ! r0) (ch1 : nat) (E : weight_constraints (te_typ e') (te_sub e') + ch1 <=\nweight_constraints (te_typ e1) (te_sub e1) + weight_constraints (te_typ e1) q) (r : positive) (P : weight_constraints (te_typ e1) (te_sub e) <=\nweight_constraints (te_typ e) (te_sub e)) (Q : weight_constraints (te_typ e1) (te_sub e1) <=\nweight_constraints (te_typ e1) (te_sub e) + weight_bounds (te_typ e1) ! r1 +\nweight_bounds (te_typ e1) ! r2) (R : weight_constraints (te_typ e1) q <= weight_constraints (te_typ e) q) (ch2 : nat) : (if changed' && negb changed then 1 else 0) <= 0 + 1.","proofString":"destruct (changed' && negb changed); lia."},{"statement":"(te : typassign) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (PTree.empty bounds) ! x = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"rewrite PTree.gempty in H; discriminate."},{"statement":"(te : typassign) (x y : positive) (H : False) : T.sub (te x) (te y).","proofString":"contradiction."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub ty hi) (e0 : lo = T.lub lo ty) (H0 : satisf te e') : satisf te e'.","proofString":"destruct H0 as [P Q]; split; auto; intros."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (H0 : satisf te\n  {|\n    te_typ :=\n      PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty)) (te_typ e);\n    te_sub := te_sub e\n  |}) : satisf te e.","proofString":"destruct H0 as [P Q]; split; auto; intros.\neapply P; simpl.\nrewrite PTree.gso; eauto.\ncongruence."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x1 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive,\nIn (x1, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty))\n           (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x1) (te y)) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e) ! x0 = Some (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"eapply P; simpl.\nrewrite PTree.gso; eauto.\ncongruence."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x1 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive,\nIn (x1, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty))\n           (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x1) (te y)) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e) ! x0 = Some (B lo hi s)) : x0 <> x.","proofString":"congruence."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub ty hi) (e0 : lo = T.lub lo ty) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub ty (te x).","proofString":"apply T.sub_trans with lo.\nrewrite e0.\neapply T.lub_right; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub ty hi) (e0 : lo = T.lub lo ty) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub ty lo.","proofString":"rewrite e0.\neapply T.lub_right; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub ty hi) (e0 : lo = T.lub lo ty) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub ty (T.lub lo ty).","proofString":"eapply T.lub_right; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub ty hi) (e0 : lo = T.lub lo ty) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub lo (te x).","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (n : lo <> T.lub lo ty) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s))\n           (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) : T.sub ty (te x).","proofString":"apply T.sub_trans with (T.lub lo ty).\neapply T.lub_right; eauto.\neapply (P x).\nsimpl.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (n : lo <> T.lub lo ty) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s))\n           (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) : T.sub ty (T.lub lo ty).","proofString":"eapply T.lub_right; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (n : lo <> T.lub lo ty) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s))\n           (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) : T.sub (T.lub lo ty) (te x).","proofString":"eapply (P x).\nsimpl.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e e' : typenv) (E : (te_typ e) ! x = None) (H : OK\n  {|\n    te_typ :=\n      PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty)) (te_typ e);\n    te_sub := te_sub e\n  |} = OK e') (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub ty (te x).","proofString":"inv H.\neapply (P x); simpl.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty))\n           (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x0) (te y)) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) : T.sub ty (te x).","proofString":"eapply (P x); simpl.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (e' : typenv) (H0 : satisf te e') : list_forall2 T.sub nil nil.","proofString":"constructor."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl0 : list T.t) (e0 e'0 : typenv),\ntype_defs e0 xl tyl0 = OK e'0 ->\nsatisf te e'0 -> list_forall2 T.sub tyl0 (map te xl)) (t : T.t) (tyl : list T.t) (e e' : typenv) (H0 : satisf te e') (x : typenv) (EQ : type_def e a t = OK x) (EQ0 : type_defs x xl tyl = OK e') : list_forall2 T.sub (t :: tyl) (te a :: map te xl).","proofString":"constructor; eauto.\neapply type_def_sound; eauto with ty."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl0 : list T.t) (e0 e'0 : typenv),\ntype_defs e0 xl tyl0 = OK e'0 ->\nsatisf te e'0 -> list_forall2 T.sub tyl0 (map te xl)) (t : T.t) (tyl : list T.t) (e e' : typenv) (H0 : satisf te e') (x : typenv) (EQ : type_def e a t = OK x) (EQ0 : type_defs x xl tyl = OK e') : T.sub t (te a).","proofString":"eapply type_def_sound; eauto with ty."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub lo ty) (e0 : hi = T.glb hi ty) (H0 : satisf te e') : satisf te e'.","proofString":"destruct H0 as [P Q]; split; auto; intros."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (H0 : satisf te\n  {|\n    te_typ :=\n      PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n    te_sub := te_sub e\n  |}) : satisf te e.","proofString":"destruct H0 as [P Q]; split; auto; intros.\neapply P; simpl.\nrewrite PTree.gso; eauto.\ncongruence."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x1 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive,\nIn (x1, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x1) (te y)) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e) ! x0 = Some (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"eapply P; simpl.\nrewrite PTree.gso; eauto.\ncongruence."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x1 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive,\nIn (x1, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x1) (te y)) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e) ! x0 = Some (B lo hi s)) : x0 <> x.","proofString":"congruence."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub lo ty) (e0 : hi = T.glb hi ty) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub (te x) ty.","proofString":"apply T.sub_trans with hi.\neapply P; eauto.\nrewrite e0.\neapply T.glb_right; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub lo ty) (e0 : hi = T.glb hi ty) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub (te x) hi.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub lo ty) (e0 : hi = T.glb hi ty) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub hi ty.","proofString":"rewrite e0.\neapply T.glb_right; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e' : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e') ! x = Some (B lo hi s1)) (s : T.sub lo ty) (e0 : hi = T.glb hi ty) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub (T.glb hi ty) ty.","proofString":"eapply T.glb_right; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (n : hi <> T.glb hi ty) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s))\n           (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) : T.sub (te x) ty.","proofString":"apply T.sub_trans with (T.glb hi ty).\neapply (P x).\nsimpl.\nrewrite PTree.gss; eauto.\neapply T.glb_right; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (n : hi <> T.glb hi ty) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s))\n           (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) : T.sub (te x) (T.glb hi ty).","proofString":"eapply (P x).\nsimpl.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (n : hi <> T.glb hi ty) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s))\n           (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) : T.sub (T.glb hi ty) ty.","proofString":"eapply T.glb_right; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e e' : typenv) (E : (te_typ e) ! x = None) (H : OK\n  {|\n    te_typ :=\n      PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n    te_sub := te_sub e\n  |} = OK e') (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e') -> T.sub (te x0) (te y)) : T.sub (te x) ty.","proofString":"inv H.\neapply (P x); simpl.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (x : positive) (ty : T.t) (e : typenv) (E : (te_typ e) ! x = None) (Q : forall x0 y : positive,\nIn (x0, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n       te_sub := te_sub e\n     |}) -> T.sub (te x0) (te y)) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n     te_sub := te_sub e\n   |}) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) : T.sub (te x) ty.","proofString":"eapply (P x); simpl.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (e' : typenv) (H0 : satisf te e') : list_forall2 T.sub nil nil.","proofString":"constructor."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl0 : list T.t) (e0 e'0 : typenv),\ntype_uses e0 xl tyl0 = OK e'0 ->\nsatisf te e'0 -> list_forall2 T.sub (map te xl) tyl0) (t : T.t) (tyl : list T.t) (e e' : typenv) (H0 : satisf te e') (x : typenv) (EQ : type_use e a t = OK x) (EQ0 : type_uses x xl tyl = OK e') : list_forall2 T.sub (te a :: map te xl) (t :: tyl).","proofString":"constructor; eauto.\neapply type_use_sound; eauto with ty."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl0 : list T.t) (e0 e'0 : typenv),\ntype_uses e0 xl tyl0 = OK e'0 ->\nsatisf te e'0 -> list_forall2 T.sub (map te xl) tyl0) (t : T.t) (tyl : list T.t) (e e' : typenv) (H0 : satisf te e') (x : typenv) (EQ : type_use e a t = OK x) (EQ0 : type_uses x xl tyl = OK e') : T.sub (te a) t.","proofString":"eapply type_use_sound; eauto with ty."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some (B lo1 hi1 s1) =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 s2) =>\n          if T.sub_dec hi1 lo2\n          then OK (false, e)\n          else\n           match T.sub_dec lo1 hi2 with\n           | left s =>\n               if T.eq lo2 (T.lub lo1 lo2)\n               then\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (false,\n                    {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r1\n                          (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n               else\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (PTree.set r1\n                             (B lo1 (T.glb hi1 hi2)\n                                (T.glb_max hi1 hi2 lo1 s1 s)) \n                             (te_typ e));\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n           | right _ =>\n               Error\n                 (MSG \"ill-typed move from \"\n                  :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n           end\n      | None =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 _) =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n      end\n  end) = OK (changed, e')) (H0 : satisf te e') : satisf te e.","proofString":"destruct H0 as [P Q].\ndestruct (peq r1 r2).\ninv H; split; auto.\ndestruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\ndestruct (T.sub_dec hi1 lo2).\ninv H; split; auto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\nsplit; auto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gso; eauto.\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite ! PTree.gso; eauto.\ninv H; simpl in *.\nsplit; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi1 lo1); auto with coqlib.\ninv H; simpl in *.\nsplit; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi2 lo2); auto with coqlib.\ninv H; simpl in *.\nsplit; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some (B lo1 hi1 s1) =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 s2) =>\n          if T.sub_dec hi1 lo2\n          then OK (false, e)\n          else\n           match T.sub_dec lo1 hi2 with\n           | left s =>\n               if T.eq lo2 (T.lub lo1 lo2)\n               then\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (false,\n                    {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r1\n                          (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n               else\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (PTree.set r1\n                             (B lo1 (T.glb hi1 hi2)\n                                (T.glb_max hi1 hi2 lo1 s1 s)) \n                             (te_typ e));\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n           | right _ =>\n               Error\n                 (MSG \"ill-typed move from \"\n                  :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n           end\n      | None =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 _) =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n      end\n  end) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"destruct (peq r1 r2).\ninv H; split; auto.\ndestruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\ndestruct (T.sub_dec hi1 lo2).\ninv H; split; auto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\nsplit; auto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gso; eauto.\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite ! PTree.gso; eauto.\ninv H; simpl in *.\nsplit; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi1 lo1); auto with coqlib.\ninv H; simpl in *.\nsplit; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi2 lo2); auto with coqlib.\ninv H; simpl in *.\nsplit; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (e0 : r1 = r2) (H : OK (false, e) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"inv H; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (H : match (te_typ e) ! r1 with\n| Some (B lo1 hi1 s1) =>\n    match (te_typ e) ! r2 with\n    | Some (B lo2 hi2 s2) =>\n        if T.sub_dec hi1 lo2\n        then OK (false, e)\n        else\n         match T.sub_dec lo1 hi2 with\n         | left s =>\n             if T.eq lo2 (T.lub lo1 lo2)\n             then\n              if T.eq hi1 (T.glb hi1 hi2)\n              then\n               OK\n                 (false,\n                  {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n              else\n               OK\n                 (true,\n                  {|\n                    te_typ :=\n                      PTree.set r1\n                        (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                        (te_typ e);\n                    te_sub := (r1, r2) :: te_sub e\n                  |})\n             else\n              if T.eq hi1 (T.glb hi1 hi2)\n              then\n               OK\n                 (true,\n                  {|\n                    te_typ :=\n                      PTree.set r2\n                        (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                        (te_typ e);\n                    te_sub := (r1, r2) :: te_sub e\n                  |})\n              else\n               OK\n                 (true,\n                  {|\n                    te_typ :=\n                      PTree.set r2\n                        (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                        (PTree.set r1\n                           (B lo1 (T.glb hi1 hi2)\n                              (T.glb_max hi1 hi2 lo1 s1 s)) \n                           (te_typ e));\n                    te_sub := (r1, r2) :: te_sub e\n                  |})\n         | right _ =>\n             Error\n               (MSG \"ill-typed move from \"\n                :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n         end\n    | None =>\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                 (te_typ e);\n             te_sub :=\n               if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n           |})\n    end\n| None =>\n    match (te_typ e) ! r2 with\n    | Some (B lo2 hi2 _) =>\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                 (te_typ e);\n             te_sub :=\n               if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n           |})\n    | None =>\n        OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n    end\nend = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"destruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\ndestruct (T.sub_dec hi1 lo2).\ninv H; split; auto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\nsplit; auto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gso; eauto.\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite ! PTree.gso; eauto.\ninv H; simpl in *.\nsplit; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi1 lo1); auto with coqlib.\ninv H; simpl in *.\nsplit; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi2 lo2); auto with coqlib.\ninv H; simpl in *.\nsplit; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (H : (if T.sub_dec hi1 lo2\n then OK (false, e)\n else\n  match T.sub_dec lo1 hi2 with\n  | left s =>\n      if T.eq lo2 (T.lub lo1 lo2)\n      then\n       if T.eq hi1 (T.glb hi1 hi2)\n       then\n        OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n       else\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r1\n                 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                 (te_typ e);\n             te_sub := (r1, r2) :: te_sub e\n           |})\n      else\n       if T.eq hi1 (T.glb hi1 hi2)\n       then\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2\n                 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                 (te_typ e);\n             te_sub := (r1, r2) :: te_sub e\n           |})\n       else\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2\n                 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                 (PTree.set r1\n                    (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                    (te_typ e));\n             te_sub := (r1, r2) :: te_sub e\n           |})\n  | right _ =>\n      Error\n        (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n  end) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"destruct (T.sub_dec hi1 lo2).\ninv H; split; auto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\nsplit; auto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gso; eauto.\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite ! PTree.gso; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi1 lo2) (H : OK (false, e) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"inv H; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (H : match T.sub_dec lo1 hi2 with\n| left s =>\n    if T.eq lo2 (T.lub lo1 lo2)\n    then\n     if T.eq hi1 (T.glb hi1 hi2)\n     then\n      OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n     else\n      OK\n        (true,\n         {|\n           te_typ :=\n             PTree.set r1\n               (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n               (te_typ e);\n           te_sub := (r1, r2) :: te_sub e\n         |})\n    else\n     if T.eq hi1 (T.glb hi1 hi2)\n     then\n      OK\n        (true,\n         {|\n           te_typ :=\n             PTree.set r2\n               (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n               (te_typ e);\n           te_sub := (r1, r2) :: te_sub e\n         |})\n     else\n      OK\n        (true,\n         {|\n           te_typ :=\n             PTree.set r2\n               (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n               (PTree.set r1\n                  (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                  (te_typ e));\n           te_sub := (r1, r2) :: te_sub e\n         |})\n| right _ =>\n    Error\n      (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\nend = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"destruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\nsplit; auto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gso; eauto.\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite ! PTree.gso; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (H : (if T.eq lo2 (T.lub lo1 lo2)\n then\n  if T.eq hi1 (T.glb hi1 hi2)\n  then OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n  else\n   OK\n     (true,\n      {|\n        te_typ :=\n          PTree.set r1 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n            (te_typ e);\n        te_sub := (r1, r2) :: te_sub e\n      |})\n else\n  if T.eq hi1 (T.glb hi1 hi2)\n  then\n   OK\n     (true,\n      {|\n        te_typ :=\n          PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n            (te_typ e);\n        te_sub := (r1, r2) :: te_sub e\n      |})\n  else\n   OK\n     (true,\n      {|\n        te_typ :=\n          PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n            (PTree.set r1\n               (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n               (te_typ e));\n        te_sub := (r1, r2) :: te_sub e\n      |})) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"set (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\nsplit; auto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsubst e'; simpl in *.\nsplit; auto.\nintros.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite PTree.gso; eauto.\nsplit; auto.\nintros.\ndestruct (peq x r1).\nsubst x.\nrewrite E1 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r1).\nrewrite PTree.gso; eauto.\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.glb hi1 hi2); auto.\neapply T.glb_left; eauto.\ndestruct (peq x r2).\nsubst x.\nrewrite E2 in H.\ninjection H; intros; subst lo0 hi0.\nexploit (P r2).\nrewrite PTree.gss; eauto.\nintuition.\napply T.sub_trans with (T.lub lo1 lo2); auto.\neapply T.lub_right; eauto.\neapply P.\nrewrite ! PTree.gso; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (lo : T.t) (hi : T.t) (e0 : lo2 = lo) (e1 : hi1 = hi) (P : forall (x : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x = Some (B lo0 hi0 s0) -> T.sub lo0 (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) (H1 : false = changed) (H2 : {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |} = e') : satisf te e.","proofString":"subst e'; simpl in *.\nsplit; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (lo : T.t) (hi : T.t) (e0 : lo2 = lo) (e1 : hi1 = hi) (Q : forall x y : positive,\n(r1, r2) = (x, y) \\/ In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x = Some (B lo0 hi0 s0) -> T.sub lo0 (te x) /\\ T.sub (te x) hi0) (H1 : false = changed) : satisf te e.","proofString":"split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (H : OK\n  (true,\n   {|\n     te_typ :=\n       PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n         (te_typ e);\n     te_sub := if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n   |}) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"inv H; simpl in *.\nsplit; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi1 lo1); auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive,\nIn (x, y) (if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) : satisf te e.","proofString":"split; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi1 lo1); auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (Q : forall x0 y : positive,\nIn (x0, y) (if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e) ! x = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"eapply P.\nrewrite PTree.gso; eauto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (Q : forall x0 y : positive,\nIn (x0, y) (if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e) ! x = Some (B lo hi s)) : x <> r2.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (Q : forall x0 y0 : positive,\nIn (x0, y0) (if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x0) (te y0)) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (x y : positive) (H : In (x, y) (te_sub e)) : T.sub (te x) (te y).","proofString":"apply Q.\ndestruct (T.sub_dec hi1 lo1); auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (Q : forall x0 y0 : positive,\nIn (x0, y0) (if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x0) (te y0)) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (x y : positive) (H : In (x, y) (te_sub e)) : In (x, y) (if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e).","proofString":"destruct (T.sub_dec hi1 lo1); auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (H : OK\n  (true,\n   {|\n     te_typ :=\n       PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n         (te_typ e);\n     te_sub := if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n   |}) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"inv H; simpl in *.\nsplit; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi2 lo2); auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (Q : forall x y : positive,\nIn (x, y) (if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e)) ! x =\nSome (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) : satisf te e.","proofString":"split; intros.\neapply P.\nrewrite PTree.gso; eauto.\ncongruence.\napply Q.\ndestruct (T.sub_dec hi2 lo2); auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (Q : forall x0 y : positive,\nIn (x0, y) (if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e))\n! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e) ! x = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"eapply P.\nrewrite PTree.gso; eauto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (Q : forall x0 y : positive,\nIn (x0, y) (if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x0) (te y)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e))\n! x0 = Some (B lo0 hi0 s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e) ! x = Some (B lo hi s)) : x <> r1.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (Q : forall x0 y0 : positive,\nIn (x0, y0) (if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x0) (te y0)) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e))\n! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (x y : positive) (H : In (x, y) (te_sub e)) : T.sub (te x) (te y).","proofString":"apply Q.\ndestruct (T.sub_dec hi2 lo2); auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (Q : forall x0 y0 : positive,\nIn (x0, y0) (if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x0) (te y0)) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e))\n! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (x y : positive) (H : In (x, y) (te_sub e)) : In (x, y) (if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e).","proofString":"destruct (T.sub_dec hi2 lo2); auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) (H : OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |}) =\nOK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : satisf te e.","proofString":"inv H; simpl in *.\nsplit; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive,\n(r1, r2) = (x, y) \\/ In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) : satisf te e.","proofString":"split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some (B lo1 hi1 s1) =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 s2) =>\n          if T.sub_dec hi1 lo2\n          then OK (false, e)\n          else\n           match T.sub_dec lo1 hi2 with\n           | left s =>\n               if T.eq lo2 (T.lub lo1 lo2)\n               then\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (false,\n                    {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r1\n                          (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n               else\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (PTree.set r1\n                             (B lo1 (T.glb hi1 hi2)\n                                (T.glb_max hi1 hi2 lo1 s1 s)) \n                             (te_typ e));\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n           | right _ =>\n               Error\n                 (MSG \"ill-typed move from \"\n                  :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n           end\n      | None =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 _) =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n      end\n  end) = OK (changed, e')) (H0 : satisf te e') : T.sub (te r1) (te r2).","proofString":"destruct H0 as [P Q].\ndestruct (peq r1 r2).\nsubst r2.\napply T.sub_refl.\ndestruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\ndestruct (T.sub_dec hi1 lo2).\ninv H.\napply T.sub_trans with hi1.\neapply P; eauto.\napply T.sub_trans with lo2; auto.\neapply P; eauto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\napply Q; auto.\ninv H; simpl in *.\ndestruct (T.sub_dec hi1 lo1).\napply T.sub_trans with hi1.\neapply P; eauto.\nrewrite PTree.gso; eauto.\napply T.sub_trans with lo1; auto.\neapply P.\nrewrite PTree.gss; eauto.\nauto with coqlib.\ninv H; simpl in *.\ndestruct (T.sub_dec hi2 lo2).\napply T.sub_trans with hi2.\neapply P.\nrewrite PTree.gss; eauto.\napply T.sub_trans with lo2; auto.\neapply P.\nrewrite PTree.gso; eauto.\nauto with coqlib.\ninv H.\nsimpl in Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some (B lo1 hi1 s1) =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 s2) =>\n          if T.sub_dec hi1 lo2\n          then OK (false, e)\n          else\n           match T.sub_dec lo1 hi2 with\n           | left s =>\n               if T.eq lo2 (T.lub lo1 lo2)\n               then\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (false,\n                    {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r1\n                          (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n               else\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (PTree.set r1\n                             (B lo1 (T.glb hi1 hi2)\n                                (T.glb_max hi1 hi2 lo1 s1 s)) \n                             (te_typ e));\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n           | right _ =>\n               Error\n                 (MSG \"ill-typed move from \"\n                  :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n           end\n      | None =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 _) =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n      end\n  end) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"destruct (peq r1 r2).\nsubst r2.\napply T.sub_refl.\ndestruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\ndestruct (T.sub_dec hi1 lo2).\ninv H.\napply T.sub_trans with hi1.\neapply P; eauto.\napply T.sub_trans with lo2; auto.\neapply P; eauto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\napply Q; auto.\ninv H; simpl in *.\ndestruct (T.sub_dec hi1 lo1).\napply T.sub_trans with hi1.\neapply P; eauto.\nrewrite PTree.gso; eauto.\napply T.sub_trans with lo1; auto.\neapply P.\nrewrite PTree.gss; eauto.\nauto with coqlib.\ninv H; simpl in *.\ndestruct (T.sub_dec hi2 lo2).\napply T.sub_trans with hi2.\neapply P.\nrewrite PTree.gss; eauto.\napply T.sub_trans with lo2; auto.\neapply P.\nrewrite PTree.gso; eauto.\nauto with coqlib.\ninv H.\nsimpl in Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (e0 : r1 = r2) (H : OK (false, e) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"subst r2.\napply T.sub_refl."},{"statement":"(te : typassign) (e : typenv) (r1 : positive) (e' : typenv) (changed : bool) (H : OK (false, e) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r1).","proofString":"apply T.sub_refl."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (H : match (te_typ e) ! r1 with\n| Some (B lo1 hi1 s1) =>\n    match (te_typ e) ! r2 with\n    | Some (B lo2 hi2 s2) =>\n        if T.sub_dec hi1 lo2\n        then OK (false, e)\n        else\n         match T.sub_dec lo1 hi2 with\n         | left s =>\n             if T.eq lo2 (T.lub lo1 lo2)\n             then\n              if T.eq hi1 (T.glb hi1 hi2)\n              then\n               OK\n                 (false,\n                  {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n              else\n               OK\n                 (true,\n                  {|\n                    te_typ :=\n                      PTree.set r1\n                        (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                        (te_typ e);\n                    te_sub := (r1, r2) :: te_sub e\n                  |})\n             else\n              if T.eq hi1 (T.glb hi1 hi2)\n              then\n               OK\n                 (true,\n                  {|\n                    te_typ :=\n                      PTree.set r2\n                        (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                        (te_typ e);\n                    te_sub := (r1, r2) :: te_sub e\n                  |})\n              else\n               OK\n                 (true,\n                  {|\n                    te_typ :=\n                      PTree.set r2\n                        (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                        (PTree.set r1\n                           (B lo1 (T.glb hi1 hi2)\n                              (T.glb_max hi1 hi2 lo1 s1 s)) \n                           (te_typ e));\n                    te_sub := (r1, r2) :: te_sub e\n                  |})\n         | right _ =>\n             Error\n               (MSG \"ill-typed move from \"\n                :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n         end\n    | None =>\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                 (te_typ e);\n             te_sub :=\n               if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n           |})\n    end\n| None =>\n    match (te_typ e) ! r2 with\n    | Some (B lo2 hi2 _) =>\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                 (te_typ e);\n             te_sub :=\n               if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n           |})\n    | None =>\n        OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n    end\nend = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"destruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\ndestruct (T.sub_dec hi1 lo2).\ninv H.\napply T.sub_trans with hi1.\neapply P; eauto.\napply T.sub_trans with lo2; auto.\neapply P; eauto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\napply Q; auto.\ninv H; simpl in *.\ndestruct (T.sub_dec hi1 lo1).\napply T.sub_trans with hi1.\neapply P; eauto.\nrewrite PTree.gso; eauto.\napply T.sub_trans with lo1; auto.\neapply P.\nrewrite PTree.gss; eauto.\nauto with coqlib.\ninv H; simpl in *.\ndestruct (T.sub_dec hi2 lo2).\napply T.sub_trans with hi2.\neapply P.\nrewrite PTree.gss; eauto.\napply T.sub_trans with lo2; auto.\neapply P.\nrewrite PTree.gso; eauto.\nauto with coqlib.\ninv H.\nsimpl in Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (H : (if T.sub_dec hi1 lo2\n then OK (false, e)\n else\n  match T.sub_dec lo1 hi2 with\n  | left s =>\n      if T.eq lo2 (T.lub lo1 lo2)\n      then\n       if T.eq hi1 (T.glb hi1 hi2)\n       then\n        OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n       else\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r1\n                 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                 (te_typ e);\n             te_sub := (r1, r2) :: te_sub e\n           |})\n      else\n       if T.eq hi1 (T.glb hi1 hi2)\n       then\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2\n                 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                 (te_typ e);\n             te_sub := (r1, r2) :: te_sub e\n           |})\n       else\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2\n                 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                 (PTree.set r1\n                    (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                    (te_typ e));\n             te_sub := (r1, r2) :: te_sub e\n           |})\n  | right _ =>\n      Error\n        (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n  end) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"destruct (T.sub_dec hi1 lo2).\ninv H.\napply T.sub_trans with hi1.\neapply P; eauto.\napply T.sub_trans with lo2; auto.\neapply P; eauto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\napply Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi1 lo2) (H : OK (false, e) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"inv H.\napply T.sub_trans with hi1.\neapply P; eauto.\napply T.sub_trans with lo2; auto.\neapply P; eauto."},{"statement":"(te : typassign) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e') ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e') ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi1 lo2) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"apply T.sub_trans with hi1.\neapply P; eauto.\napply T.sub_trans with lo2; auto.\neapply P; eauto."},{"statement":"(te : typassign) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e') ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e') ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi1 lo2) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) hi1.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e') ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e') ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi1 lo2) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub hi1 (te r2).","proofString":"apply T.sub_trans with lo2; auto.\neapply P; eauto."},{"statement":"(te : typassign) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e') ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e') ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi1 lo2) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub lo2 (te r2).","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (H : match T.sub_dec lo1 hi2 with\n| left s =>\n    if T.eq lo2 (T.lub lo1 lo2)\n    then\n     if T.eq hi1 (T.glb hi1 hi2)\n     then\n      OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n     else\n      OK\n        (true,\n         {|\n           te_typ :=\n             PTree.set r1\n               (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n               (te_typ e);\n           te_sub := (r1, r2) :: te_sub e\n         |})\n    else\n     if T.eq hi1 (T.glb hi1 hi2)\n     then\n      OK\n        (true,\n         {|\n           te_typ :=\n             PTree.set r2\n               (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n               (te_typ e);\n           te_sub := (r1, r2) :: te_sub e\n         |})\n     else\n      OK\n        (true,\n         {|\n           te_typ :=\n             PTree.set r2\n               (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n               (PTree.set r1\n                  (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                  (te_typ e));\n           te_sub := (r1, r2) :: te_sub e\n         |})\n| right _ =>\n    Error\n      (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\nend = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"destruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\napply Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (H : (if T.eq lo2 (T.lub lo1 lo2)\n then\n  if T.eq hi1 (T.glb hi1 hi2)\n  then OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n  else\n   OK\n     (true,\n      {|\n        te_typ :=\n          PTree.set r1 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n            (te_typ e);\n        te_sub := (r1, r2) :: te_sub e\n      |})\n else\n  if T.eq hi1 (T.glb hi1 hi2)\n  then\n   OK\n     (true,\n      {|\n        te_typ :=\n          PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n            (te_typ e);\n        te_sub := (r1, r2) :: te_sub e\n      |})\n  else\n   OK\n     (true,\n      {|\n        te_typ :=\n          PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n            (PTree.set r1\n               (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n               (te_typ e));\n        te_sub := (r1, r2) :: te_sub e\n      |})) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"set (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); monadInv H; simpl in *.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\nsubst e'; simpl in *.\napply Q; auto.\napply Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (lo : T.t) (hi : T.t) (e0 : lo2 = lo) (e1 : hi1 = hi) (P : forall (x : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e') ! x = Some (B lo0 hi0 s0) -> T.sub lo0 (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) (H1 : false = changed) (H2 : {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |} = e') : T.sub (te r1) (te r2).","proofString":"subst e'; simpl in *.\napply Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (lo : T.t) (hi : T.t) (e0 : lo2 = lo) (e1 : hi1 = hi) (Q : forall x y : positive,\n(r1, r2) = (x, y) \\/ In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x = Some (B lo0 hi0 s0) -> T.sub lo0 (te x) /\\ T.sub (te x) hi0) (H1 : false = changed) : T.sub (te r1) (te r2).","proofString":"apply Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (H : OK\n  (true,\n   {|\n     te_typ :=\n       PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n         (te_typ e);\n     te_sub := if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n   |}) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"inv H; simpl in *.\ndestruct (T.sub_dec hi1 lo1).\napply T.sub_trans with hi1.\neapply P; eauto.\nrewrite PTree.gso; eauto.\napply T.sub_trans with lo1; auto.\neapply P.\nrewrite PTree.gss; eauto.\nauto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive,\nIn (x, y) (if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub (te r1) (te r2).","proofString":"destruct (T.sub_dec hi1 lo1).\napply T.sub_trans with hi1.\neapply P; eauto.\nrewrite PTree.gso; eauto.\napply T.sub_trans with lo1; auto.\neapply P.\nrewrite PTree.gss; eauto.\nauto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (s : T.sub hi1 lo1) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub (te r1) (te r2).","proofString":"apply T.sub_trans with hi1.\neapply P; eauto.\nrewrite PTree.gso; eauto.\napply T.sub_trans with lo1; auto.\neapply P.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (s : T.sub hi1 lo1) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub (te r1) hi1.","proofString":"eapply P; eauto.\nrewrite PTree.gso; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (s : T.sub hi1 lo1) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub hi1 (te r2).","proofString":"apply T.sub_trans with lo1; auto.\neapply P.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (s : T.sub hi1 lo1) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub lo1 (te r2).","proofString":"eapply P.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (n0 : ~ T.sub hi1 lo1) (Q : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub (te r1) (te r2).","proofString":"auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (H : OK\n  (true,\n   {|\n     te_typ :=\n       PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n         (te_typ e);\n     te_sub := if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n   |}) = OK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"inv H; simpl in *.\ndestruct (T.sub_dec hi2 lo2).\napply T.sub_trans with hi2.\neapply P.\nrewrite PTree.gss; eauto.\napply T.sub_trans with lo2; auto.\neapply P.\nrewrite PTree.gso; eauto.\nauto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (Q : forall x y : positive,\nIn (x, y) (if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e) ->\nT.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e)) ! x =\nSome (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub (te r1) (te r2).","proofString":"destruct (T.sub_dec hi2 lo2).\napply T.sub_trans with hi2.\neapply P.\nrewrite PTree.gss; eauto.\napply T.sub_trans with lo2; auto.\neapply P.\nrewrite PTree.gso; eauto.\nauto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi2 lo2) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e)) ! x =\nSome (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub (te r1) (te r2).","proofString":"apply T.sub_trans with hi2.\neapply P.\nrewrite PTree.gss; eauto.\napply T.sub_trans with lo2; auto.\neapply P.\nrewrite PTree.gso; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi2 lo2) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e)) ! x =\nSome (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub (te r1) hi2.","proofString":"eapply P.\nrewrite PTree.gss; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi2 lo2) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e)) ! x =\nSome (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub hi2 (te r2).","proofString":"apply T.sub_trans with lo2; auto.\neapply P.\nrewrite PTree.gso; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi2 lo2) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e)) ! x =\nSome (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub lo2 (te r2).","proofString":"eapply P.\nrewrite PTree.gso; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi2 lo2) (Q : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e)) ! x =\nSome (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub (te r1) (te r2).","proofString":"auto with coqlib."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (e' : typenv) (changed : bool) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) (H : OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |}) =\nOK (changed, e')) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e') ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e') -> T.sub (te x) (te y)) : T.sub (te r1) (te r2).","proofString":"inv H.\nsimpl in Q; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) (Q : forall x y : positive,\nIn (x, y) (te_sub {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |}) ->\nT.sub (te x) (te y)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |}) ! x =\nSome (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) : T.sub (te r1) (te r2).","proofString":"simpl in Q; auto."},{"statement":"(te : typassign) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : OK (e, changed) = OK (e', changed')) (H0 : satisf te e') : satisf te e.","proofString":"inv H.\nauto."},{"statement":"(te : typassign) (e' : typenv) (changed' : bool) (H0 : satisf te e') : satisf te e'.","proofString":"auto."},{"statement":"(te : typassign) (a : constraint) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nsatisf te e'0 -> satisf te e0) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : (let (r1, r2) := a in\n do (changed1, e1)<- type_move e r1 r2; solve_rec e1 (changed || changed1) q) =\nOK (e', changed')) (H0 : satisf te e') : satisf te e.","proofString":"destruct a as [r1 r2]; monadInv H.\neauto with ty."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nsatisf te e'0 -> satisf te e0) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H0 : satisf te e') (x : bool) (x0 : typenv) (EQ : type_move e r1 r2 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : satisf te e.","proofString":"eauto with ty."},{"statement":"(te : typassign) (r1 r2 : positive) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : OK (e, changed) = OK (e', changed')) (H0 : False) (H1 : satisf te e') : T.sub (te r1) (te r2).","proofString":"contradiction."},{"statement":"(te : typassign) (r1 r2 : positive) (a : constraint) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> T.sub (te r1) (te r2)) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : (let (r0, r3) := a in\n do (changed1, e1)<- type_move e r0 r3; solve_rec e1 (changed || changed1) q) =\nOK (e', changed')) (H0 : a = (r1, r2) \\/ In (r1, r2) q) (H1 : satisf te e') : T.sub (te r1) (te r2).","proofString":"destruct a as [r3 r4]; monadInv H.\ndestruct H0.\ninv H.\neapply type_move_sound; eauto.\neapply solve_rec_incr; eauto.\neapply IHq; eauto with ty."},{"statement":"(te : typassign) (r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> T.sub (te r1) (te r2)) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H0 : (r3, r4) = (r1, r2) \\/ In (r1, r2) q) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : type_move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : T.sub (te r1) (te r2).","proofString":"destruct H0.\ninv H.\neapply type_move_sound; eauto.\neapply solve_rec_incr; eauto.\neapply IHq; eauto with ty."},{"statement":"(te : typassign) (r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> T.sub (te r1) (te r2)) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : (r3, r4) = (r1, r2)) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : type_move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : T.sub (te r1) (te r2).","proofString":"inv H.\neapply type_move_sound; eauto.\neapply solve_rec_incr; eauto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> T.sub (te r1) (te r2)) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : type_move e r1 r2 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : T.sub (te r1) (te r2).","proofString":"eapply type_move_sound; eauto.\neapply solve_rec_incr; eauto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> T.sub (te r1) (te r2)) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : type_move e r1 r2 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : satisf te x0.","proofString":"eapply solve_rec_incr; eauto."},{"statement":"(te : typassign) (r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv) (changed'0 : bool),\nsolve_rec e0 changed0 q = OK (e'0, changed'0) ->\nIn (r1, r2) q -> satisf te e'0 -> T.sub (te r1) (te r2)) (e : typenv) (changed : bool) (e' : typenv) (changed' : bool) (H : In (r1, r2) q) (H1 : satisf te e') (x : bool) (x0 : typenv) (EQ : type_move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', changed')) : T.sub (te r1) (te r2).","proofString":"eapply IHq; eauto with ty."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (H : (if peq r1 r2\n then OK (false, e)\n else\n  match (te_typ e) ! r1 with\n  | Some (B lo1 hi1 s1) =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 s2) =>\n          if T.sub_dec hi1 lo2\n          then OK (false, e)\n          else\n           match T.sub_dec lo1 hi2 with\n           | left s =>\n               if T.eq lo2 (T.lub lo1 lo2)\n               then\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (false,\n                    {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r1\n                          (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n               else\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (PTree.set r1\n                             (B lo1 (T.glb hi1 hi2)\n                                (T.glb_max hi1 hi2 lo1 s1 s)) \n                             (te_typ e));\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n           | right _ =>\n               Error\n                 (MSG \"ill-typed move from \"\n                  :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n           end\n      | None =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 _) =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n      end\n  end) = OK (false, e')) : te_typ e' = te_typ e /\\ T.sub (makeassign e r1) (makeassign e r2).","proofString":"destruct (peq r1 r2).\ninv H.\nsplit; auto.\napply T.sub_refl.\nunfold makeassign;  destruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\ndestruct (T.sub_dec hi1 lo2).\ninv H.\nsplit; auto.\neapply T.sub_trans; eauto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); try discriminate.\nmonadInv H.\nsplit; auto.\nrewrite e0.\nunfold lo.\neapply T.lub_left; eauto.\ndiscriminate.\ndiscriminate.\ninv H.\nsplit; auto.\napply T.sub_refl."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (e0 : r1 = r2) (H : OK (false, e) = OK (false, e')) : te_typ e' = te_typ e /\\ T.sub (makeassign e r1) (makeassign e r2).","proofString":"inv H.\nsplit; auto.\napply T.sub_refl."},{"statement":"(r2 : positive) (e' : typenv) : te_typ e' = te_typ e' /\\ T.sub (makeassign e' r2) (makeassign e' r2).","proofString":"split; auto.\napply T.sub_refl."},{"statement":"(r2 : positive) (e' : typenv) : T.sub (makeassign e' r2) (makeassign e' r2).","proofString":"apply T.sub_refl."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (H : match (te_typ e) ! r1 with\n| Some (B lo1 hi1 s1) =>\n    match (te_typ e) ! r2 with\n    | Some (B lo2 hi2 s2) =>\n        if T.sub_dec hi1 lo2\n        then OK (false, e)\n        else\n         match T.sub_dec lo1 hi2 with\n         | left s =>\n             if T.eq lo2 (T.lub lo1 lo2)\n             then\n              if T.eq hi1 (T.glb hi1 hi2)\n              then\n               OK\n                 (false,\n                  {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n              else\n               OK\n                 (true,\n                  {|\n                    te_typ :=\n                      PTree.set r1\n                        (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                        (te_typ e);\n                    te_sub := (r1, r2) :: te_sub e\n                  |})\n             else\n              if T.eq hi1 (T.glb hi1 hi2)\n              then\n               OK\n                 (true,\n                  {|\n                    te_typ :=\n                      PTree.set r2\n                        (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                        (te_typ e);\n                    te_sub := (r1, r2) :: te_sub e\n                  |})\n              else\n               OK\n                 (true,\n                  {|\n                    te_typ :=\n                      PTree.set r2\n                        (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                        (PTree.set r1\n                           (B lo1 (T.glb hi1 hi2)\n                              (T.glb_max hi1 hi2 lo1 s1 s)) \n                           (te_typ e));\n                    te_sub := (r1, r2) :: te_sub e\n                  |})\n         | right _ =>\n             Error\n               (MSG \"ill-typed move from \"\n                :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n         end\n    | None =>\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                 (te_typ e);\n             te_sub :=\n               if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n           |})\n    end\n| None =>\n    match (te_typ e) ! r2 with\n    | Some (B lo2 hi2 _) =>\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                 (te_typ e);\n             te_sub :=\n               if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n           |})\n    | None =>\n        OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n    end\nend = OK (false, e')) : te_typ e' = te_typ e /\\ T.sub (makeassign e r1) (makeassign e r2).","proofString":"unfold makeassign;  destruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\ndestruct (T.sub_dec hi1 lo2).\ninv H.\nsplit; auto.\neapply T.sub_trans; eauto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); try discriminate.\nmonadInv H.\nsplit; auto.\nrewrite e0.\nunfold lo.\neapply T.lub_left; eauto.\ndiscriminate.\ndiscriminate.\ninv H.\nsplit; auto.\napply T.sub_refl."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (H : (if T.sub_dec hi1 lo2\n then OK (false, e)\n else\n  match T.sub_dec lo1 hi2 with\n  | left s =>\n      if T.eq lo2 (T.lub lo1 lo2)\n      then\n       if T.eq hi1 (T.glb hi1 hi2)\n       then\n        OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n       else\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r1\n                 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                 (te_typ e);\n             te_sub := (r1, r2) :: te_sub e\n           |})\n      else\n       if T.eq hi1 (T.glb hi1 hi2)\n       then\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2\n                 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                 (te_typ e);\n             te_sub := (r1, r2) :: te_sub e\n           |})\n       else\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2\n                 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                 (PTree.set r1\n                    (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                    (te_typ e));\n             te_sub := (r1, r2) :: te_sub e\n           |})\n  | right _ =>\n      Error\n        (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n  end) = OK (false, e')) : te_typ e' = te_typ e /\\ T.sub lo1 lo2.","proofString":"destruct (T.sub_dec hi1 lo2).\ninv H.\nsplit; auto.\neapply T.sub_trans; eauto.\ndestruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); try discriminate.\nmonadInv H.\nsplit; auto.\nrewrite e0.\nunfold lo.\neapply T.lub_left; eauto."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi1 lo2) (H : OK (false, e) = OK (false, e')) : te_typ e' = te_typ e /\\ T.sub lo1 lo2.","proofString":"inv H.\nsplit; auto.\neapply T.sub_trans; eauto."},{"statement":"(r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e') ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e') ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi1 lo2) : te_typ e' = te_typ e' /\\ T.sub lo1 lo2.","proofString":"split; auto.\neapply T.sub_trans; eauto."},{"statement":"(r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e') ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e') ! r2 = Some (B lo2 hi2 s2)) (s : T.sub hi1 lo2) : T.sub lo1 lo2.","proofString":"eapply T.sub_trans; eauto."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (H : match T.sub_dec lo1 hi2 with\n| left s =>\n    if T.eq lo2 (T.lub lo1 lo2)\n    then\n     if T.eq hi1 (T.glb hi1 hi2)\n     then\n      OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n     else\n      OK\n        (true,\n         {|\n           te_typ :=\n             PTree.set r1\n               (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n               (te_typ e);\n           te_sub := (r1, r2) :: te_sub e\n         |})\n    else\n     if T.eq hi1 (T.glb hi1 hi2)\n     then\n      OK\n        (true,\n         {|\n           te_typ :=\n             PTree.set r2\n               (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n               (te_typ e);\n           te_sub := (r1, r2) :: te_sub e\n         |})\n     else\n      OK\n        (true,\n         {|\n           te_typ :=\n             PTree.set r2\n               (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n               (PTree.set r1\n                  (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                  (te_typ e));\n           te_sub := (r1, r2) :: te_sub e\n         |})\n| right _ =>\n    Error\n      (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\nend = OK (false, e')) : te_typ e' = te_typ e /\\ T.sub lo1 lo2.","proofString":"destruct (T.sub_dec lo1 hi2); try discriminate.\nset (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); try discriminate.\nmonadInv H.\nsplit; auto.\nrewrite e0.\nunfold lo.\neapply T.lub_left; eauto."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (H : (if T.eq lo2 (T.lub lo1 lo2)\n then\n  if T.eq hi1 (T.glb hi1 hi2)\n  then OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n  else\n   OK\n     (true,\n      {|\n        te_typ :=\n          PTree.set r1 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n            (te_typ e);\n        te_sub := (r1, r2) :: te_sub e\n      |})\n else\n  if T.eq hi1 (T.glb hi1 hi2)\n  then\n   OK\n     (true,\n      {|\n        te_typ :=\n          PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n            (te_typ e);\n        te_sub := (r1, r2) :: te_sub e\n      |})\n  else\n   OK\n     (true,\n      {|\n        te_typ :=\n          PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n            (PTree.set r1\n               (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n               (te_typ e));\n        te_sub := (r1, r2) :: te_sub e\n      |})) = OK (false, e')) : te_typ e' = te_typ e /\\ T.sub lo1 lo2.","proofString":"set (lo := T.lub lo1 lo2) in *.\nset (hi := T.glb hi1 hi2) in *.\ndestruct (T.eq lo2 lo); destruct (T.eq hi1 hi); try discriminate.\nmonadInv H.\nsplit; auto.\nrewrite e0.\nunfold lo.\neapply T.lub_left; eauto."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (lo : T.t) (hi : T.t) (e0 : lo2 = lo) (e1 : hi1 = hi) (H1 : {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |} = e') : T.sub lo1 (T.lub lo1 lo2).","proofString":"eapply T.lub_left; eauto."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (H : OK\n  (true,\n   {|\n     te_typ :=\n       PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n         (te_typ e);\n     te_sub := if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n   |}) = OK (false, e')) : te_typ e' = te_typ e /\\ T.sub lo1 T.default.","proofString":"discriminate."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (H : OK\n  (true,\n   {|\n     te_typ :=\n       PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n         (te_typ e);\n     te_sub := if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n   |}) = OK (false, e')) : te_typ e' = te_typ e /\\ T.sub T.default lo2.","proofString":"discriminate."},{"statement":"(e : typenv) (r1 r2 : positive) (e' : typenv) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) (H : OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |}) =\nOK (false, e')) : te_typ e' = te_typ e /\\ T.sub T.default T.default.","proofString":"inv H.\nsplit; auto.\napply T.sub_refl."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) : te_typ {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |} = te_typ e /\\\nT.sub T.default T.default.","proofString":"split; auto.\napply T.sub_refl."},{"statement":"(e : typenv) (r1 r2 : positive) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) : T.sub T.default T.default.","proofString":"apply T.sub_refl."},{"statement":"(r1 r2 : positive) (e : typenv) (changed : bool) (e' : typenv) (H : OK (e, changed) = OK (e', false)) : changed = false /\\ (False -> T.sub (makeassign e r1) (makeassign e r2)).","proofString":"inv H.\ntauto."},{"statement":"(r1 r2 : positive) (e' : typenv) : false = false /\\ (False -> T.sub (makeassign e' r1) (makeassign e' r2)).","proofString":"tauto."},{"statement":"(r1 r2 : positive) (a : constraint) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv),\nsolve_rec e0 changed0 q = OK (e'0, false) ->\nchanged0 = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e : typenv) (changed : bool) (e' : typenv) (H : (let (r0, r3) := a in\n do (changed1, e1)<- type_move e r0 r3; solve_rec e1 (changed || changed1) q) =\nOK (e', false)) : changed = false /\\\n(a = (r1, r2) \\/ In (r1, r2) q -> T.sub (makeassign e r1) (makeassign e r2)).","proofString":"destruct a as [r3 r4]; monadInv H.\nexploit IHq; eauto.\nintros [P Q].\ndestruct changed; try discriminate.\ndestruct x; try discriminate.\nexploit type_move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv),\nsolve_rec e0 changed0 q = OK (e'0, false) ->\nchanged0 = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e : typenv) (changed : bool) (e' : typenv) (x : bool) (x0 : typenv) (EQ : type_move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', false)) : changed = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q ->\n T.sub (makeassign e r1) (makeassign e r2)).","proofString":"exploit IHq; eauto.\nintros [P Q].\ndestruct changed; try discriminate.\ndestruct x; try discriminate.\nexploit type_move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv),\nsolve_rec e0 changed0 q = OK (e'0, false) ->\nchanged0 = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e : typenv) (changed : bool) (e' : typenv) (x : bool) (x0 : typenv) (EQ : type_move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', false)) : changed || x = false /\\\n(In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) ->\nchanged = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q ->\n T.sub (makeassign e r1) (makeassign e r2)).","proofString":"intros [P Q].\ndestruct changed; try discriminate.\ndestruct x; try discriminate.\nexploit type_move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed0 : bool) (e'0 : typenv),\nsolve_rec e0 changed0 q = OK (e'0, false) ->\nchanged0 = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e : typenv) (changed : bool) (e' : typenv) (x : bool) (x0 : typenv) (EQ : type_move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (changed || x) q = OK (e', false)) (P : changed || x = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) : changed = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q ->\n T.sub (makeassign e r1) (makeassign e r2)).","proofString":"destruct changed; try discriminate.\ndestruct x; try discriminate.\nexploit type_move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' : typenv) (x : bool) (x0 : typenv) (EQ : type_move e r3 r4 = OK (x, x0)) (EQ0 : solve_rec x0 (false || x) q = OK (e', false)) (P : false || x = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) : false = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q ->\n T.sub (makeassign e r1) (makeassign e r2)).","proofString":"destruct x; try discriminate.\nexploit type_move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' x0 : typenv) (EQ : type_move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) : false = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q ->\n T.sub (makeassign e r1) (makeassign e r2)).","proofString":"exploit type_move_false; eauto.\nintros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' x0 : typenv) (EQ : type_move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) : te_typ x0 = te_typ e /\\ T.sub (makeassign e r3) (makeassign e r4) ->\nfalse = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q ->\n T.sub (makeassign e r1) (makeassign e r2)).","proofString":"intros [U V].\nsplit.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' x0 : typenv) (EQ : type_move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) (U : te_typ x0 = te_typ e) (V : T.sub (makeassign e r3) (makeassign e r4)) : false = false /\\\n((r3, r4) = (r1, r2) \\/ In (r1, r2) q ->\n T.sub (makeassign e r1) (makeassign e r2)).","proofString":"split.\nauto.\nintros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' x0 : typenv) (EQ : type_move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) (U : te_typ x0 = te_typ e) (V : T.sub (makeassign e r3) (makeassign e r4)) : false = false.","proofString":"auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' x0 : typenv) (EQ : type_move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) (U : te_typ x0 = te_typ e) (V : T.sub (makeassign e r3) (makeassign e r4)) : (r3, r4) = (r1, r2) \\/ In (r1, r2) q ->\nT.sub (makeassign e r1) (makeassign e r2).","proofString":"intros [A|A].\ninv A.\nauto.\nexploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' x0 : typenv) (EQ : type_move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) (U : te_typ x0 = te_typ e) (V : T.sub (makeassign e r3) (makeassign e r4)) (A : (r3, r4) = (r1, r2)) : T.sub (makeassign e r1) (makeassign e r2).","proofString":"inv A.\nauto."},{"statement":"(r1 r2 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' x0 : typenv) (EQ : type_move e r1 r2 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) (U : te_typ x0 = te_typ e) (V : T.sub (makeassign e r1) (makeassign e r2)) : T.sub (makeassign e r1) (makeassign e r2).","proofString":"auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' x0 : typenv) (EQ : type_move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) (U : te_typ x0 = te_typ e) (V : T.sub (makeassign e r3) (makeassign e r4)) (A : In (r1, r2) q) : T.sub (makeassign e r1) (makeassign e r2).","proofString":"exploit Q; auto.\nunfold makeassign; rewrite U; auto."},{"statement":"(r1 r2 r3 r4 : positive) (q : list constraint) (IHq : forall (e0 : typenv) (changed : bool) (e'0 : typenv),\nsolve_rec e0 changed q = OK (e'0, false) ->\nchanged = false /\\\n(In (r1, r2) q -> T.sub (makeassign e0 r1) (makeassign e0 r2))) (e e' x0 : typenv) (EQ : type_move e r3 r4 = OK (false, x0)) (EQ0 : solve_rec x0 (false || false) q = OK (e', false)) (P : false || false = false) (Q : In (r1, r2) q -> T.sub (makeassign x0 r1) (makeassign x0 r2)) (U : te_typ x0 = te_typ e) (V : T.sub (makeassign e r3) (makeassign e r4)) (A : In (r1, r2) q) : T.sub (makeassign x0 r1) (makeassign x0 r2) ->\nT.sub (makeassign e r1) (makeassign e r2).","proofString":"unfold makeassign; rewrite U; auto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', false)) (e'0 : typenv) (H : OK e = OK e'0) (H0 : satisf te e'0) : satisf te e.","proofString":"inv H.\nauto."},{"statement":"(te : typassign) (e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_sub := nil |} false (te_sub e'0) =\nOK (e', false)) (H0 : satisf te e'0) : satisf te e'0.","proofString":"auto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf te e'1 -> satisf te e') (e'0 : typenv) (H : solve_constraints e' = OK e'0) (H0 : satisf te e'0) : satisf te e.","proofString":"exploit solve_rec_incr; eauto.\nintros [A B].\nsplit; auto.\nintros; eapply solve_rec_sound; eauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf te e'1 -> satisf te e') (e'0 : typenv) (H : solve_constraints e' = OK e'0) (H0 : satisf te e'0) : satisf te {| te_typ := te_typ e; te_sub := nil |} -> satisf te e.","proofString":"intros [A B].\nsplit; auto.\nintros; eapply solve_rec_sound; eauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf te e'1 -> satisf te e') (e'0 : typenv) (H : solve_constraints e' = OK e'0) (H0 : satisf te e'0) (A : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ {| te_typ := te_typ e; te_sub := nil |}) ! x =\nSome (SubSolver.B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (B : forall x y : positive,\nIn (x, y) (te_sub {| te_typ := te_typ e; te_sub := nil |}) ->\nT.sub (te x) (te y)) : satisf te e.","proofString":"split; auto.\nintros; eapply solve_rec_sound; eauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf te e'1 -> satisf te e') (e'0 : typenv) (H : solve_constraints e' = OK e'0) (H0 : satisf te e'0) (A : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ {| te_typ := te_typ e; te_sub := nil |}) ! x =\nSome (SubSolver.B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (B : forall x y : positive,\nIn (x, y) (te_sub {| te_typ := te_typ e; te_sub := nil |}) ->\nT.sub (te x) (te y)) : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y).","proofString":"intros; eapply solve_rec_sound; eauto."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nError msg) (e' : typenv) (H : Error msg = OK e') (H0 : satisf te e') : satisf te e.","proofString":"discriminate."},{"statement":"(e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', false)) (e'0 : typenv) (H : OK e = OK e'0) : satisf (makeassign e'0) e'0.","proofString":"inv H.\nsplit; intros.\nunfold makeassign; rewrite H.\nsplit; auto with ty.\nexploit solve_rec_false.\neauto.\nintros [A B].\neapply B; eauto."},{"statement":"(e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_sub := nil |} false (te_sub e'0) =\nOK (e', false)) : satisf (makeassign e'0) e'0.","proofString":"split; intros.\nunfold makeassign; rewrite H.\nsplit; auto with ty.\nexploit solve_rec_false.\neauto.\nintros [A B].\neapply B; eauto."},{"statement":"(e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_sub := nil |} false (te_sub e'0) =\nOK (e', false)) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e'0) ! x = Some (B lo hi s)) : T.sub lo (makeassign e'0 x) /\\ T.sub (makeassign e'0 x) hi.","proofString":"unfold makeassign; rewrite H.\nsplit; auto with ty."},{"statement":"(e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_sub := nil |} false (te_sub e'0) =\nOK (e', false)) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (te_typ e'0) ! x = Some (B lo hi s)) : T.sub lo lo /\\ T.sub lo hi.","proofString":"split; auto with ty."},{"statement":"(e' e'0 : typenv) (e0 : solve_rec {| te_typ := te_typ e'0; te_sub := nil |} false (te_sub e'0) =\nOK (e', false)) (x y : positive) (H : In (x, y) (te_sub e'0)) : T.sub (makeassign e'0 x) (makeassign e'0 y).","proofString":"exploit solve_rec_false.\neauto.\nintros [A B].\neapply B; eauto."},{"statement":"(e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : forall e'1 : typenv,\nsolve_constraints e' = OK e'1 -> satisf (makeassign e'1) e'1) (e'0 : typenv) (H : solve_constraints e' = OK e'0) : satisf (makeassign e'0) e'0.","proofString":"eauto."},{"statement":"(e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nError msg) (e' : typenv) (H : Error msg = OK e') : satisf (makeassign e') e'.","proofString":"discriminate."},{"statement":"(e : typenv) (te : typassign) (H : (do e' <- solve_constraints e; OK (makeassign e')) = OK te) : satisf te e.","proofString":"monadInv H.\neapply solve_constraints_incr.\neauto.\neapply solve_constraints_sound; eauto."},{"statement":"(e x : typenv) (EQ : solve_constraints e = OK x) : satisf (makeassign x) e.","proofString":"eapply solve_constraints_incr.\neauto.\neapply solve_constraints_sound; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : T.sub ty (te x)) : exists e' : typenv,\n  match (te_typ e) ! x with\n  | Some (B lo hi s1) =>\n      match T.sub_dec ty hi with\n      | left s2 =>\n          if T.eq lo (T.lub lo ty)\n          then OK e\n          else\n           OK\n             {|\n               te_typ :=\n                 PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s2))\n                   (te_typ e);\n               te_sub := te_sub e\n             |}\n      | right _ => Error (MSG \"bad definition of variable \" :: POS x :: nil)\n      end\n  | None =>\n      OK\n        {|\n          te_typ :=\n            PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty))\n              (te_typ e);\n          te_sub := te_sub e\n        |}\n  end = OK e' /\\ satisf te e'.","proofString":"destruct H as [P Q].\ndestruct (te_typ e)!x as [[lo hi s1]|] eqn:E.\ndestruct (T.sub_dec ty hi).\ndestruct (T.eq lo (T.lub lo ty)).\nexists e; split; auto.\nsplit; auto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.lub_min; eauto.\neapply P; eauto.\nelim n.\napply T.sub_trans with (te x); auto.\neapply P; eauto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.high_bound_majorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) : exists e' : typenv,\n  match (te_typ e) ! x with\n  | Some (B lo hi s1) =>\n      match T.sub_dec ty hi with\n      | left s2 =>\n          if T.eq lo (T.lub lo ty)\n          then OK e\n          else\n           OK\n             {|\n               te_typ :=\n                 PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s2))\n                   (te_typ e);\n               te_sub := te_sub e\n             |}\n      | right _ => Error (MSG \"bad definition of variable \" :: POS x :: nil)\n      end\n  | None =>\n      OK\n        {|\n          te_typ :=\n            PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty))\n              (te_typ e);\n          te_sub := te_sub e\n        |}\n  end = OK e' /\\ satisf te e'.","proofString":"destruct (te_typ e)!x as [[lo hi s1]|] eqn:E.\ndestruct (T.sub_dec ty hi).\ndestruct (T.eq lo (T.lub lo ty)).\nexists e; split; auto.\nsplit; auto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.lub_min; eauto.\neapply P; eauto.\nelim n.\napply T.sub_trans with (te x); auto.\neapply P; eauto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.high_bound_majorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) : exists e' : typenv,\n  match T.sub_dec ty hi with\n  | left s2 =>\n      if T.eq lo (T.lub lo ty)\n      then OK e\n      else\n       OK\n         {|\n           te_typ :=\n             PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s2))\n               (te_typ e);\n           te_sub := te_sub e\n         |}\n  | right _ => Error (MSG \"bad definition of variable \" :: POS x :: nil)\n  end = OK e' /\\ satisf te e'.","proofString":"destruct (T.sub_dec ty hi).\ndestruct (T.eq lo (T.lub lo ty)).\nexists e; split; auto.\nsplit; auto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.lub_min; eauto.\neapply P; eauto.\nelim n.\napply T.sub_trans with (te x); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) : exists e' : typenv,\n  (if T.eq lo (T.lub lo ty)\n   then OK e\n   else\n    OK\n      {|\n        te_typ :=\n          PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s))\n            (te_typ e);\n        te_sub := te_sub e\n      |}) = OK e' /\\ satisf te e'.","proofString":"destruct (T.eq lo (T.lub lo ty)).\nexists e; split; auto.\nsplit; auto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.lub_min; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (e0 : lo = T.lub lo ty) : exists e' : typenv, OK e = OK e' /\\ satisf te e'.","proofString":"exists e; split; auto.\nsplit; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (e0 : lo = T.lub lo ty) : satisf te e.","proofString":"split; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (n : lo <> T.lub lo ty) : exists e' : typenv,\n  OK\n    {|\n      te_typ :=\n        PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s)) (te_typ e);\n      te_sub := te_sub e\n    |} = OK e' /\\ satisf te e'.","proofString":"econstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.lub_min; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (n : lo <> T.lub lo ty) : satisf te\n  {|\n    te_typ :=\n      PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s)) (te_typ e);\n    te_sub := te_sub e\n  |}.","proofString":"split; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.lub_min; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo1 hi1 : T.t) (s2 : T.sub lo1 hi1),\n(te_typ e) ! x1 = Some (B lo1 hi1 s2) ->\nT.sub lo1 (te x1) /\\ T.sub (te x1) hi1) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (n : lo <> T.lub lo ty) (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0) (H : (PTree.set x (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s)) (te_typ e)) ! x0 =\nSome (B lo0 hi0 s0)) : T.sub lo0 (te x0) /\\ T.sub (te x0) hi0.","proofString":"rewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.lub_min; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo1 hi1 : T.t) (s2 : T.sub lo1 hi1),\n(te_typ e) ! x1 = Some (B lo1 hi1 s2) ->\nT.sub lo1 (te x1) /\\ T.sub (te x1) hi1) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (n : lo <> T.lub lo ty) (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0) (H : (if peq x0 x\n then Some (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s))\n else (te_typ e) ! x0) = Some (B lo0 hi0 s0)) : T.sub lo0 (te x0) /\\ T.sub (te x0) hi0.","proofString":"destruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.lub_min; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo1 hi1 : T.t) (s2 : T.sub lo1 hi1),\n(te_typ e) ! x1 = Some (B lo1 hi1 s2) ->\nT.sub lo1 (te x1) /\\ T.sub (te x1) hi1) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (n : lo <> T.lub lo ty) (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0) (e0 : x0 = x) (H : Some (B (T.lub lo ty) hi (T.lub_min lo ty hi s1 s)) = Some (B lo0 hi0 s0)) : T.sub lo0 (te x0) /\\ T.sub (te x0) hi0.","proofString":"inv H.\nexploit P; eauto.\nintuition.\neapply T.lub_min; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi : T.t) (s2 : T.sub lo0 hi),\n(te_typ e) ! x0 = Some (B lo0 hi s2) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi0 : T.t) (s : T.sub ty hi0) (s1 : T.sub lo hi0) (E : (te_typ e) ! x = Some (B lo hi0 s1)) (n : lo <> T.lub lo ty) (s0 : T.sub (T.lub lo ty) hi0) : T.sub (T.lub lo ty) (te x) /\\ T.sub (te x) hi0.","proofString":"exploit P; eauto.\nintuition.\neapply T.lub_min; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi : T.t) (s2 : T.sub lo0 hi),\n(te_typ e) ! x0 = Some (B lo0 hi s2) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi0 : T.t) (s : T.sub ty hi0) (s1 : T.sub lo hi0) (E : (te_typ e) ! x = Some (B lo hi0 s1)) (n : lo <> T.lub lo ty) (s0 : T.sub (T.lub lo ty) hi0) : T.sub lo (te x) /\\ T.sub (te x) hi0 ->\nT.sub (T.lub lo ty) (te x) /\\ T.sub (te x) hi0.","proofString":"intuition.\neapply T.lub_min; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi : T.t) (s2 : T.sub lo0 hi),\n(te_typ e) ! x0 = Some (B lo0 hi s2) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi0 : T.t) (s : T.sub ty hi0) (s1 : T.sub lo hi0) (E : (te_typ e) ! x = Some (B lo hi0 s1)) (n : lo = T.lub lo ty -> False) (s0 : T.sub (T.lub lo ty) hi0) (H1 : T.sub lo (te x)) (H2 : T.sub (te x) hi0) : T.sub (T.lub lo ty) (te x).","proofString":"eapply T.lub_min; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo1 hi1 : T.t) (s2 : T.sub lo1 hi1),\n(te_typ e) ! x1 = Some (B lo1 hi1 s2) ->\nT.sub lo1 (te x1) /\\ T.sub (te x1) hi1) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub ty hi) (n : lo <> T.lub lo ty) (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0) (n0 : x0 <> x) (H : (te_typ e) ! x0 = Some (B lo0 hi0 s0)) : T.sub lo0 (te x0) /\\ T.sub (te x0) hi0.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (n : ~ T.sub ty hi) : exists e' : typenv,\n  Error (MSG \"bad definition of variable \" :: POS x :: nil) = OK e' /\\\n  satisf te e'.","proofString":"elim n.\napply T.sub_trans with (te x); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (n : ~ T.sub ty hi) : T.sub ty hi.","proofString":"apply T.sub_trans with (te x); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (n : ~ T.sub ty hi) : T.sub (te x) hi.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (E : (te_typ e) ! x = None) : exists e' : typenv,\n  OK\n    {|\n      te_typ :=\n        PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty)) (te_typ e);\n      te_sub := te_sub e\n    |} = OK e' /\\ satisf te e'.","proofString":"econstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.high_bound_majorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub ty (te x)) (E : (te_typ e) ! x = None) : satisf te\n  {|\n    te_typ :=\n      PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty)) (te_typ e);\n    te_sub := te_sub e\n  |}.","proofString":"split; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.high_bound_majorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x1 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub ty (te x)) (E : (te_typ e) ! x = None) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (PTree.set x (B ty (T.high_bound ty) (T.high_bound_sub ty)) (te_typ e)) ! x0 =\nSome (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"rewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.high_bound_majorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x1 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub ty (te x)) (E : (te_typ e) ! x = None) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (if peq x0 x\n then Some (B ty (T.high_bound ty) (T.high_bound_sub ty))\n else (te_typ e) ! x0) = Some (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"destruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.high_bound_majorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x1 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub ty (te x)) (E : (te_typ e) ! x = None) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (e0 : x0 = x) (H : Some (B ty (T.high_bound ty) (T.high_bound_sub ty)) = Some (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"inv H.\nsplit; auto.\napply T.high_bound_majorant; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (P : forall (x0 : positive) (lo0 hi : T.t) (s0 : T.sub lo0 hi),\n(te_typ e) ! x0 = Some (B lo0 hi s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (lo : T.t) (H0 : T.sub lo (te x)) (E : (te_typ e) ! x = None) (s : T.sub lo (T.high_bound lo)) : T.sub lo (te x) /\\ T.sub (te x) (T.high_bound lo).","proofString":"split; auto.\napply T.high_bound_majorant; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (P : forall (x0 : positive) (lo0 hi : T.t) (s0 : T.sub lo0 hi),\n(te_typ e) ! x0 = Some (B lo0 hi s0) -> T.sub lo0 (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (lo : T.t) (H0 : T.sub lo (te x)) (E : (te_typ e) ! x = None) (s : T.sub lo (T.high_bound lo)) : T.sub (te x) (T.high_bound lo).","proofString":"apply T.high_bound_majorant; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x1 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub ty (te x)) (E : (te_typ e) ! x = None) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (n : x0 <> x) (H : (te_typ e) ! x0 = Some (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (H : satisf te e) : exists e' : typenv, OK e = OK e' /\\ satisf te e'.","proofString":"econstructor; eauto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub tyl (map te xl) ->\nexists e' : typenv, type_defs e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (a1 : T.t) (al : list T.t) (H4 : T.sub a1 (te a)) (H5 : list_forall2 T.sub al (map te xl)) : exists e' : typenv,\n  (do e1 <- type_def e a a1; type_defs e1 xl al) = OK e' /\\ satisf te e'.","proofString":"exploit (type_def_complete te e a a1); auto.\nintros (e1 & P & Q).\nexploit (IHxl al e1); auto.\nintros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub tyl (map te xl) ->\nexists e' : typenv, type_defs e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (a1 : T.t) (al : list T.t) (H4 : T.sub a1 (te a)) (H5 : list_forall2 T.sub al (map te xl)) : (exists e' : typenv, type_def e a a1 = OK e' /\\ satisf te e') ->\nexists e' : typenv,\n  (do e1 <- type_def e a a1; type_defs e1 xl al) = OK e' /\\ satisf te e'.","proofString":"intros (e1 & P & Q).\nexploit (IHxl al e1); auto.\nintros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub tyl (map te xl) ->\nexists e' : typenv, type_defs e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (a1 : T.t) (al : list T.t) (H4 : T.sub a1 (te a)) (H5 : list_forall2 T.sub al (map te xl)) (e1 : typenv) (P : type_def e a a1 = OK e1) (Q : satisf te e1) : exists e' : typenv,\n  (do e0 <- type_def e a a1; type_defs e0 xl al) = OK e' /\\ satisf te e'.","proofString":"exploit (IHxl al e1); auto.\nintros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub tyl (map te xl) ->\nexists e' : typenv, type_defs e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (a1 : T.t) (al : list T.t) (H4 : T.sub a1 (te a)) (H5 : list_forall2 T.sub al (map te xl)) (e1 : typenv) (P : type_def e a a1 = OK e1) (Q : satisf te e1) : (exists e' : typenv, type_defs e1 xl al = OK e' /\\ satisf te e') ->\nexists e' : typenv,\n  (do e0 <- type_def e a a1; type_defs e0 xl al) = OK e' /\\ satisf te e'.","proofString":"intros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub tyl (map te xl) ->\nexists e' : typenv, type_defs e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (a1 : T.t) (al : list T.t) (H4 : T.sub a1 (te a)) (H5 : list_forall2 T.sub al (map te xl)) (e1 : typenv) (P : type_def e a a1 = OK e1) (Q : satisf te e1) (e2 : typenv) (U : type_defs e1 xl al = OK e2) (V : satisf te e2) : exists e' : typenv,\n  (do e0 <- type_def e a a1; type_defs e0 xl al) = OK e' /\\ satisf te e'.","proofString":"exists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub tyl (map te xl) ->\nexists e' : typenv, type_defs e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (a1 : T.t) (al : list T.t) (H4 : T.sub a1 (te a)) (H5 : list_forall2 T.sub al (map te xl)) (e1 : typenv) (P : type_def e a a1 = OK e1) (Q : satisf te e1) (e2 : typenv) (U : type_defs e1 xl al = OK e2) (V : satisf te e2) : (do e0 <- type_def e a a1; type_defs e0 xl al) = OK e2.","proofString":"rewrite P; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (H : satisf te e) (H0 : T.sub (te x) ty) : exists e' : typenv,\n  match (te_typ e) ! x with\n  | Some (B lo hi s1) =>\n      match T.sub_dec lo ty with\n      | left s2 =>\n          if T.eq hi (T.glb hi ty)\n          then OK e\n          else\n           OK\n             {|\n               te_typ :=\n                 PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s2))\n                   (te_typ e);\n               te_sub := te_sub e\n             |}\n      | right _ => Error (MSG \"bad use of variable \" :: POS x :: nil)\n      end\n  | None =>\n      OK\n        {|\n          te_typ :=\n            PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty))\n              (te_typ e);\n          te_sub := te_sub e\n        |}\n  end = OK e' /\\ satisf te e'.","proofString":"destruct H as [P Q].\ndestruct (te_typ e)!x as [[lo hi s1]|] eqn:E.\ndestruct (T.sub_dec lo ty).\ndestruct (T.eq hi (T.glb hi ty)).\nexists e; split; auto.\nsplit; auto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.glb_max; eauto.\neapply P; eauto.\nelim n.\napply T.sub_trans with (te x); auto.\neapply P; eauto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.low_bound_minorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) : exists e' : typenv,\n  match (te_typ e) ! x with\n  | Some (B lo hi s1) =>\n      match T.sub_dec lo ty with\n      | left s2 =>\n          if T.eq hi (T.glb hi ty)\n          then OK e\n          else\n           OK\n             {|\n               te_typ :=\n                 PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s2))\n                   (te_typ e);\n               te_sub := te_sub e\n             |}\n      | right _ => Error (MSG \"bad use of variable \" :: POS x :: nil)\n      end\n  | None =>\n      OK\n        {|\n          te_typ :=\n            PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty))\n              (te_typ e);\n          te_sub := te_sub e\n        |}\n  end = OK e' /\\ satisf te e'.","proofString":"destruct (te_typ e)!x as [[lo hi s1]|] eqn:E.\ndestruct (T.sub_dec lo ty).\ndestruct (T.eq hi (T.glb hi ty)).\nexists e; split; auto.\nsplit; auto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.glb_max; eauto.\neapply P; eauto.\nelim n.\napply T.sub_trans with (te x); auto.\neapply P; eauto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.low_bound_minorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) : exists e' : typenv,\n  match T.sub_dec lo ty with\n  | left s2 =>\n      if T.eq hi (T.glb hi ty)\n      then OK e\n      else\n       OK\n         {|\n           te_typ :=\n             PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s2))\n               (te_typ e);\n           te_sub := te_sub e\n         |}\n  | right _ => Error (MSG \"bad use of variable \" :: POS x :: nil)\n  end = OK e' /\\ satisf te e'.","proofString":"destruct (T.sub_dec lo ty).\ndestruct (T.eq hi (T.glb hi ty)).\nexists e; split; auto.\nsplit; auto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.glb_max; eauto.\neapply P; eauto.\nelim n.\napply T.sub_trans with (te x); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) : exists e' : typenv,\n  (if T.eq hi (T.glb hi ty)\n   then OK e\n   else\n    OK\n      {|\n        te_typ :=\n          PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s))\n            (te_typ e);\n        te_sub := te_sub e\n      |}) = OK e' /\\ satisf te e'.","proofString":"destruct (T.eq hi (T.glb hi ty)).\nexists e; split; auto.\nsplit; auto.\neconstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.glb_max; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (e0 : hi = T.glb hi ty) : exists e' : typenv, OK e = OK e' /\\ satisf te e'.","proofString":"exists e; split; auto.\nsplit; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (e0 : hi = T.glb hi ty) : satisf te e.","proofString":"split; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (n : hi <> T.glb hi ty) : exists e' : typenv,\n  OK\n    {|\n      te_typ :=\n        PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s)) (te_typ e);\n      te_sub := te_sub e\n    |} = OK e' /\\ satisf te e'.","proofString":"econstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.glb_max; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (n : hi <> T.glb hi ty) : satisf te\n  {|\n    te_typ :=\n      PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s)) (te_typ e);\n    te_sub := te_sub e\n  |}.","proofString":"split; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.glb_max; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo1 hi1 : T.t) (s2 : T.sub lo1 hi1),\n(te_typ e) ! x1 = Some (B lo1 hi1 s2) ->\nT.sub lo1 (te x1) /\\ T.sub (te x1) hi1) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (n : hi <> T.glb hi ty) (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0) (H : (PTree.set x (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s)) (te_typ e)) ! x0 =\nSome (B lo0 hi0 s0)) : T.sub lo0 (te x0) /\\ T.sub (te x0) hi0.","proofString":"rewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.glb_max; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo1 hi1 : T.t) (s2 : T.sub lo1 hi1),\n(te_typ e) ! x1 = Some (B lo1 hi1 s2) ->\nT.sub lo1 (te x1) /\\ T.sub (te x1) hi1) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (n : hi <> T.glb hi ty) (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0) (H : (if peq x0 x\n then Some (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s))\n else (te_typ e) ! x0) = Some (B lo0 hi0 s0)) : T.sub lo0 (te x0) /\\ T.sub (te x0) hi0.","proofString":"destruct (peq x0 x).\ninv H.\nexploit P; eauto.\nintuition.\neapply T.glb_max; eauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo1 hi1 : T.t) (s2 : T.sub lo1 hi1),\n(te_typ e) ! x1 = Some (B lo1 hi1 s2) ->\nT.sub lo1 (te x1) /\\ T.sub (te x1) hi1) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (n : hi <> T.glb hi ty) (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0) (e0 : x0 = x) (H : Some (B lo (T.glb hi ty) (T.glb_max hi ty lo s1 s)) = Some (B lo0 hi0 s0)) : T.sub lo0 (te x0) /\\ T.sub (te x0) hi0.","proofString":"inv H.\nexploit P; eauto.\nintuition.\neapply T.glb_max; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo hi0 : T.t) (s2 : T.sub lo hi0),\n(te_typ e) ! x0 = Some (B lo hi0 s2) -> T.sub lo (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (hi lo0 : T.t) (s : T.sub lo0 ty) (s1 : T.sub lo0 hi) (E : (te_typ e) ! x = Some (B lo0 hi s1)) (n : hi <> T.glb hi ty) (s0 : T.sub lo0 (T.glb hi ty)) : T.sub lo0 (te x) /\\ T.sub (te x) (T.glb hi ty).","proofString":"exploit P; eauto.\nintuition.\neapply T.glb_max; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo hi0 : T.t) (s2 : T.sub lo hi0),\n(te_typ e) ! x0 = Some (B lo hi0 s2) -> T.sub lo (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (hi lo0 : T.t) (s : T.sub lo0 ty) (s1 : T.sub lo0 hi) (E : (te_typ e) ! x = Some (B lo0 hi s1)) (n : hi <> T.glb hi ty) (s0 : T.sub lo0 (T.glb hi ty)) : T.sub lo0 (te x) /\\ T.sub (te x) hi ->\nT.sub lo0 (te x) /\\ T.sub (te x) (T.glb hi ty).","proofString":"intuition.\neapply T.glb_max; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo hi0 : T.t) (s2 : T.sub lo hi0),\n(te_typ e) ! x0 = Some (B lo hi0 s2) -> T.sub lo (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (hi lo0 : T.t) (s : T.sub lo0 ty) (s1 : T.sub lo0 hi) (E : (te_typ e) ! x = Some (B lo0 hi s1)) (n : hi = T.glb hi ty -> False) (s0 : T.sub lo0 (T.glb hi ty)) (H1 : T.sub lo0 (te x)) (H2 : T.sub (te x) hi) : T.sub (te x) (T.glb hi ty).","proofString":"eapply T.glb_max; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo1 hi1 : T.t) (s2 : T.sub lo1 hi1),\n(te_typ e) ! x1 = Some (B lo1 hi1 s2) ->\nT.sub lo1 (te x1) /\\ T.sub (te x1) hi1) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (s : T.sub lo ty) (n : hi <> T.glb hi ty) (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0) (n0 : x0 <> x) (H : (te_typ e) ! x0 = Some (B lo0 hi0 s0)) : T.sub lo0 (te x0) /\\ T.sub (te x0) hi0.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (n : ~ T.sub lo ty) : exists e' : typenv,\n  Error (MSG \"bad use of variable \" :: POS x :: nil) = OK e' /\\ satisf te e'.","proofString":"elim n.\napply T.sub_trans with (te x); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (n : ~ T.sub lo ty) : T.sub lo ty.","proofString":"apply T.sub_trans with (te x); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (lo hi : T.t) (s1 : T.sub lo hi) (E : (te_typ e) ! x = Some (B lo hi s1)) (n : ~ T.sub lo ty) : T.sub lo (te x).","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (E : (te_typ e) ! x = None) : exists e' : typenv,\n  OK\n    {|\n      te_typ :=\n        PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n      te_sub := te_sub e\n    |} = OK e' /\\ satisf te e'.","proofString":"econstructor; split; eauto.\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.low_bound_minorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (H0 : T.sub (te x) ty) (E : (te_typ e) ! x = None) : satisf te\n  {|\n    te_typ :=\n      PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e);\n    te_sub := te_sub e\n  |}.","proofString":"split; simpl; auto; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.low_bound_minorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x1 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub (te x) ty) (E : (te_typ e) ! x = None) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (PTree.set x (B (T.low_bound ty) ty (T.low_bound_sub ty)) (te_typ e)) ! x0 =\nSome (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"rewrite PTree.gsspec in H.\ndestruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.low_bound_minorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x1 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub (te x) ty) (E : (te_typ e) ! x = None) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (H : (if peq x0 x\n then Some (B (T.low_bound ty) ty (T.low_bound_sub ty))\n else (te_typ e) ! x0) = Some (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"destruct (peq x0 x).\ninv H.\nsplit; auto.\napply T.low_bound_minorant; auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x1 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub (te x) ty) (E : (te_typ e) ! x = None) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (e0 : x0 = x) (H : Some (B (T.low_bound ty) ty (T.low_bound_sub ty)) = Some (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"inv H.\nsplit; auto.\napply T.low_bound_minorant; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (P : forall (x0 : positive) (lo hi0 : T.t) (s0 : T.sub lo hi0),\n(te_typ e) ! x0 = Some (B lo hi0 s0) -> T.sub lo (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (hi : T.t) (s : T.sub (T.low_bound hi) hi) (H0 : T.sub (te x) hi) (E : (te_typ e) ! x = None) : T.sub (T.low_bound hi) (te x) /\\ T.sub (te x) hi.","proofString":"split; auto.\napply T.low_bound_minorant; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (P : forall (x0 : positive) (lo hi0 : T.t) (s0 : T.sub lo hi0),\n(te_typ e) ! x0 = Some (B lo hi0 s0) -> T.sub lo (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (hi : T.t) (s : T.sub (T.low_bound hi) hi) (H0 : T.sub (te x) hi) (E : (te_typ e) ! x = None) : T.sub (T.low_bound hi) (te x).","proofString":"apply T.low_bound_minorant; auto."},{"statement":"(te : typassign) (e : typenv) (x : positive) (ty : T.t) (P : forall (x1 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x1 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x1) /\\ T.sub (te x1) hi0) (Q : forall x1 y : positive, In (x1, y) (te_sub e) -> T.sub (te x1) (te y)) (H0 : T.sub (te x) ty) (E : (te_typ e) ! x = None) (x0 : positive) (lo hi : T.t) (s : T.sub lo hi) (n : x0 <> x) (H : (te_typ e) ! x0 = Some (B lo hi s)) : T.sub lo (te x0) /\\ T.sub (te x0) hi.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (H : satisf te e) : exists e' : typenv, OK e = OK e' /\\ satisf te e'.","proofString":"econstructor; eauto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub (map te xl) tyl ->\nexists e' : typenv, type_uses e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (b1 : T.t) (bl : list T.t) (H3 : T.sub (te a) b1) (H5 : list_forall2 T.sub (map te xl) bl) : exists e' : typenv,\n  (do e1 <- type_use e a b1; type_uses e1 xl bl) = OK e' /\\ satisf te e'.","proofString":"exploit (type_use_complete te e a b1); auto.\nintros (e1 & P & Q).\nexploit (IHxl bl e1); auto.\nintros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub (map te xl) tyl ->\nexists e' : typenv, type_uses e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (b1 : T.t) (bl : list T.t) (H3 : T.sub (te a) b1) (H5 : list_forall2 T.sub (map te xl) bl) : (exists e' : typenv, type_use e a b1 = OK e' /\\ satisf te e') ->\nexists e' : typenv,\n  (do e1 <- type_use e a b1; type_uses e1 xl bl) = OK e' /\\ satisf te e'.","proofString":"intros (e1 & P & Q).\nexploit (IHxl bl e1); auto.\nintros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub (map te xl) tyl ->\nexists e' : typenv, type_uses e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (b1 : T.t) (bl : list T.t) (H3 : T.sub (te a) b1) (H5 : list_forall2 T.sub (map te xl) bl) (e1 : typenv) (P : type_use e a b1 = OK e1) (Q : satisf te e1) : exists e' : typenv,\n  (do e0 <- type_use e a b1; type_uses e0 xl bl) = OK e' /\\ satisf te e'.","proofString":"exploit (IHxl bl e1); auto.\nintros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub (map te xl) tyl ->\nexists e' : typenv, type_uses e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (b1 : T.t) (bl : list T.t) (H3 : T.sub (te a) b1) (H5 : list_forall2 T.sub (map te xl) bl) (e1 : typenv) (P : type_use e a b1 = OK e1) (Q : satisf te e1) : (exists e' : typenv, type_uses e1 xl bl = OK e' /\\ satisf te e') ->\nexists e' : typenv,\n  (do e0 <- type_use e a b1; type_uses e0 xl bl) = OK e' /\\ satisf te e'.","proofString":"intros (e2 & U & V).\nexists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub (map te xl) tyl ->\nexists e' : typenv, type_uses e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (b1 : T.t) (bl : list T.t) (H3 : T.sub (te a) b1) (H5 : list_forall2 T.sub (map te xl) bl) (e1 : typenv) (P : type_use e a b1 = OK e1) (Q : satisf te e1) (e2 : typenv) (U : type_uses e1 xl bl = OK e2) (V : satisf te e2) : exists e' : typenv,\n  (do e0 <- type_use e a b1; type_uses e0 xl bl) = OK e' /\\ satisf te e'.","proofString":"exists e2; split; auto.\nrewrite P; auto."},{"statement":"(te : typassign) (a : positive) (xl : list positive) (IHxl : forall (tyl : list T.t) (e0 : typenv),\nsatisf te e0 ->\nlist_forall2 T.sub (map te xl) tyl ->\nexists e' : typenv, type_uses e0 xl tyl = OK e' /\\ satisf te e') (e : typenv) (H : satisf te e) (b1 : T.t) (bl : list T.t) (H3 : T.sub (te a) b1) (H5 : list_forall2 T.sub (map te xl) bl) (e1 : typenv) (P : type_use e a b1 = OK e1) (Q : satisf te e1) (e2 : typenv) (U : type_uses e1 xl bl = OK e2) (V : satisf te e2) : (do e0 <- type_use e a b1; type_uses e0 xl bl) = OK e2.","proofString":"rewrite P; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) : exists (changed : bool) (e' : typenv),\n  (if peq r1 r2\n   then OK (false, e)\n   else\n    match (te_typ e) ! r1 with\n    | Some (B lo1 hi1 s1) =>\n        match (te_typ e) ! r2 with\n        | Some (B lo2 hi2 s2) =>\n            if T.sub_dec hi1 lo2\n            then OK (false, e)\n            else\n             match T.sub_dec lo1 hi2 with\n             | left s =>\n                 if T.eq lo2 (T.lub lo1 lo2)\n                 then\n                  if T.eq hi1 (T.glb hi1 hi2)\n                  then\n                   OK\n                     (false,\n                      {|\n                        te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e\n                      |})\n                  else\n                   OK\n                     (true,\n                      {|\n                        te_typ :=\n                          PTree.set r1\n                            (B lo1 (T.glb hi1 hi2)\n                               (T.glb_max hi1 hi2 lo1 s1 s)) \n                            (te_typ e);\n                        te_sub := (r1, r2) :: te_sub e\n                      |})\n                 else\n                  if T.eq hi1 (T.glb hi1 hi2)\n                  then\n                   OK\n                     (true,\n                      {|\n                        te_typ :=\n                          PTree.set r2\n                            (B (T.lub lo1 lo2) hi2\n                               (T.lub_min lo1 lo2 hi2 s s2)) \n                            (te_typ e);\n                        te_sub := (r1, r2) :: te_sub e\n                      |})\n                  else\n                   OK\n                     (true,\n                      {|\n                        te_typ :=\n                          PTree.set r2\n                            (B (T.lub lo1 lo2) hi2\n                               (T.lub_min lo1 lo2 hi2 s s2))\n                            (PTree.set r1\n                               (B lo1 (T.glb hi1 hi2)\n                                  (T.glb_max hi1 hi2 lo1 s1 s)) \n                               (te_typ e));\n                        te_sub := (r1, r2) :: te_sub e\n                      |})\n             | right _ =>\n                 Error\n                   (MSG \"ill-typed move from \"\n                    :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n             end\n        | None =>\n            OK\n              (true,\n               {|\n                 te_typ :=\n                   PTree.set r2\n                     (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                     (te_typ e);\n                 te_sub :=\n                   if T.sub_dec hi1 lo1\n                   then te_sub e\n                   else (r1, r2) :: te_sub e\n               |})\n        end\n    | None =>\n        match (te_typ e) ! r2 with\n        | Some (B lo2 hi2 _) =>\n            OK\n              (true,\n               {|\n                 te_typ :=\n                   PTree.set r1\n                     (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                     (te_typ e);\n                 te_sub :=\n                   if T.sub_dec hi2 lo2\n                   then te_sub e\n                   else (r1, r2) :: te_sub e\n               |})\n        | None =>\n            OK\n              (false,\n               {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n        end\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"elim H; intros P Q.\nassert (Q': forall x y, In (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)).\nintros.\ndestruct H1; auto.\ncongruence.\ndestruct (peq r1 r2).\neconstructor; econstructor; eauto.\ndestruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\nexploit (P r1); eauto.\nintros [L1 U1].\nexploit (P r2); eauto.\nintros [L2 U2].\ndestruct (T.sub_dec hi1 lo2).\neconstructor; econstructor; eauto.\ndestruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto.\neconstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi1 lo1); auto.\neconstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi2 lo2); auto.\neconstructor; econstructor; split; eauto; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) : exists (changed : bool) (e' : typenv),\n  (if peq r1 r2\n   then OK (false, e)\n   else\n    match (te_typ e) ! r1 with\n    | Some (B lo1 hi1 s1) =>\n        match (te_typ e) ! r2 with\n        | Some (B lo2 hi2 s2) =>\n            if T.sub_dec hi1 lo2\n            then OK (false, e)\n            else\n             match T.sub_dec lo1 hi2 with\n             | left s =>\n                 if T.eq lo2 (T.lub lo1 lo2)\n                 then\n                  if T.eq hi1 (T.glb hi1 hi2)\n                  then\n                   OK\n                     (false,\n                      {|\n                        te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e\n                      |})\n                  else\n                   OK\n                     (true,\n                      {|\n                        te_typ :=\n                          PTree.set r1\n                            (B lo1 (T.glb hi1 hi2)\n                               (T.glb_max hi1 hi2 lo1 s1 s)) \n                            (te_typ e);\n                        te_sub := (r1, r2) :: te_sub e\n                      |})\n                 else\n                  if T.eq hi1 (T.glb hi1 hi2)\n                  then\n                   OK\n                     (true,\n                      {|\n                        te_typ :=\n                          PTree.set r2\n                            (B (T.lub lo1 lo2) hi2\n                               (T.lub_min lo1 lo2 hi2 s s2)) \n                            (te_typ e);\n                        te_sub := (r1, r2) :: te_sub e\n                      |})\n                  else\n                   OK\n                     (true,\n                      {|\n                        te_typ :=\n                          PTree.set r2\n                            (B (T.lub lo1 lo2) hi2\n                               (T.lub_min lo1 lo2 hi2 s s2))\n                            (PTree.set r1\n                               (B lo1 (T.glb hi1 hi2)\n                                  (T.glb_max hi1 hi2 lo1 s1 s)) \n                               (te_typ e));\n                        te_sub := (r1, r2) :: te_sub e\n                      |})\n             | right _ =>\n                 Error\n                   (MSG \"ill-typed move from \"\n                    :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n             end\n        | None =>\n            OK\n              (true,\n               {|\n                 te_typ :=\n                   PTree.set r2\n                     (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                     (te_typ e);\n                 te_sub :=\n                   if T.sub_dec hi1 lo1\n                   then te_sub e\n                   else (r1, r2) :: te_sub e\n               |})\n        end\n    | None =>\n        match (te_typ e) ! r2 with\n        | Some (B lo2 hi2 _) =>\n            OK\n              (true,\n               {|\n                 te_typ :=\n                   PTree.set r1\n                     (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                     (te_typ e);\n                 te_sub :=\n                   if T.sub_dec hi2 lo2\n                   then te_sub e\n                   else (r1, r2) :: te_sub e\n               |})\n        | None =>\n            OK\n              (false,\n               {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n        end\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"assert (Q': forall x y, In (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)).\nintros.\ndestruct H1; auto.\ncongruence.\ndestruct (peq r1 r2).\neconstructor; econstructor; eauto.\ndestruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\nexploit (P r1); eauto.\nintros [L1 U1].\nexploit (P r2); eauto.\nintros [L2 U2].\ndestruct (T.sub_dec hi1 lo2).\neconstructor; econstructor; eauto.\ndestruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto.\neconstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi1 lo1); auto.\neconstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi2 lo2); auto.\neconstructor; econstructor; split; eauto; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y).","proofString":"intros.\ndestruct H1; auto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y0 : positive, In (x0, y0) (te_sub e) -> T.sub (te x0) (te y0)) (x y : positive) (H1 : In (x, y) ((r1, r2) :: te_sub e)) : T.sub (te x) (te y).","proofString":"destruct H1; auto.\ncongruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x0 = Some (B lo hi s) -> T.sub lo (te x0) /\\ T.sub (te x0) hi) (Q : forall x0 y0 : positive, In (x0, y0) (te_sub e) -> T.sub (te x0) (te y0)) (x y : positive) (H1 : (r1, r2) = (x, y)) : T.sub (te x) (te y).","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) : exists (changed : bool) (e' : typenv),\n  (if peq r1 r2\n   then OK (false, e)\n   else\n    match (te_typ e) ! r1 with\n    | Some (B lo1 hi1 s1) =>\n        match (te_typ e) ! r2 with\n        | Some (B lo2 hi2 s2) =>\n            if T.sub_dec hi1 lo2\n            then OK (false, e)\n            else\n             match T.sub_dec lo1 hi2 with\n             | left s =>\n                 if T.eq lo2 (T.lub lo1 lo2)\n                 then\n                  if T.eq hi1 (T.glb hi1 hi2)\n                  then\n                   OK\n                     (false,\n                      {|\n                        te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e\n                      |})\n                  else\n                   OK\n                     (true,\n                      {|\n                        te_typ :=\n                          PTree.set r1\n                            (B lo1 (T.glb hi1 hi2)\n                               (T.glb_max hi1 hi2 lo1 s1 s)) \n                            (te_typ e);\n                        te_sub := (r1, r2) :: te_sub e\n                      |})\n                 else\n                  if T.eq hi1 (T.glb hi1 hi2)\n                  then\n                   OK\n                     (true,\n                      {|\n                        te_typ :=\n                          PTree.set r2\n                            (B (T.lub lo1 lo2) hi2\n                               (T.lub_min lo1 lo2 hi2 s s2)) \n                            (te_typ e);\n                        te_sub := (r1, r2) :: te_sub e\n                      |})\n                  else\n                   OK\n                     (true,\n                      {|\n                        te_typ :=\n                          PTree.set r2\n                            (B (T.lub lo1 lo2) hi2\n                               (T.lub_min lo1 lo2 hi2 s s2))\n                            (PTree.set r1\n                               (B lo1 (T.glb hi1 hi2)\n                                  (T.glb_max hi1 hi2 lo1 s1 s)) \n                               (te_typ e));\n                        te_sub := (r1, r2) :: te_sub e\n                      |})\n             | right _ =>\n                 Error\n                   (MSG \"ill-typed move from \"\n                    :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n             end\n        | None =>\n            OK\n              (true,\n               {|\n                 te_typ :=\n                   PTree.set r2\n                     (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                     (te_typ e);\n                 te_sub :=\n                   if T.sub_dec hi1 lo1\n                   then te_sub e\n                   else (r1, r2) :: te_sub e\n               |})\n        end\n    | None =>\n        match (te_typ e) ! r2 with\n        | Some (B lo2 hi2 _) =>\n            OK\n              (true,\n               {|\n                 te_typ :=\n                   PTree.set r1\n                     (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                     (te_typ e);\n                 te_sub :=\n                   if T.sub_dec hi2 lo2\n                   then te_sub e\n                   else (r1, r2) :: te_sub e\n               |})\n        | None =>\n            OK\n              (false,\n               {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n        end\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"destruct (peq r1 r2).\neconstructor; econstructor; eauto.\ndestruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\nexploit (P r1); eauto.\nintros [L1 U1].\nexploit (P r2); eauto.\nintros [L2 U2].\ndestruct (T.sub_dec hi1 lo2).\neconstructor; econstructor; eauto.\ndestruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto.\neconstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi1 lo1); auto.\neconstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi2 lo2); auto.\neconstructor; econstructor; split; eauto; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (e0 : r1 = r2) : exists (changed : bool) (e' : typenv),\n  OK (false, e) = OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) : exists (changed : bool) (e' : typenv),\n  match (te_typ e) ! r1 with\n  | Some (B lo1 hi1 s1) =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 s2) =>\n          if T.sub_dec hi1 lo2\n          then OK (false, e)\n          else\n           match T.sub_dec lo1 hi2 with\n           | left s =>\n               if T.eq lo2 (T.lub lo1 lo2)\n               then\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (false,\n                    {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r1\n                          (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n               else\n                if T.eq hi1 (T.glb hi1 hi2)\n                then\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (te_typ e);\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n                else\n                 OK\n                   (true,\n                    {|\n                      te_typ :=\n                        PTree.set r2\n                          (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                          (PTree.set r1\n                             (B lo1 (T.glb hi1 hi2)\n                                (T.glb_max hi1 hi2 lo1 s1 s)) \n                             (te_typ e));\n                      te_sub := (r1, r2) :: te_sub e\n                    |})\n           | right _ =>\n               Error\n                 (MSG \"ill-typed move from \"\n                  :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n           end\n      | None =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      end\n  | None =>\n      match (te_typ e) ! r2 with\n      | Some (B lo2 hi2 _) =>\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n                   (te_typ e);\n               te_sub :=\n                 if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n             |})\n      | None =>\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n      end\n  end = OK (changed, e') /\\ satisf te e'.","proofString":"destruct (te_typ e)!r1 as [[lo1 hi1 s1]|] eqn:E1;  destruct (te_typ e)!r2 as [[lo2 hi2 s2]|] eqn:E2.\nexploit (P r1); eauto.\nintros [L1 U1].\nexploit (P r2); eauto.\nintros [L2 U2].\ndestruct (T.sub_dec hi1 lo2).\neconstructor; econstructor; eauto.\ndestruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto.\neconstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi1 lo1); auto.\neconstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi2 lo2); auto.\neconstructor; econstructor; split; eauto; split; auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) : exists (changed : bool) (e' : typenv),\n  (if T.sub_dec hi1 lo2\n   then OK (false, e)\n   else\n    match T.sub_dec lo1 hi2 with\n    | left s =>\n        if T.eq lo2 (T.lub lo1 lo2)\n        then\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1\n                   (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n        else\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (PTree.set r1\n                      (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                      (te_typ e));\n               te_sub := (r1, r2) :: te_sub e\n             |})\n    | right _ =>\n        Error\n          (MSG \"ill-typed move from \"\n           :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"exploit (P r1); eauto.\nintros [L1 U1].\nexploit (P r2); eauto.\nintros [L2 U2].\ndestruct (T.sub_dec hi1 lo2).\neconstructor; econstructor; eauto.\ndestruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) : T.sub lo1 (te r1) /\\ T.sub (te r1) hi1 ->\nexists (changed : bool) (e' : typenv),\n  (if T.sub_dec hi1 lo2\n   then OK (false, e)\n   else\n    match T.sub_dec lo1 hi2 with\n    | left s =>\n        if T.eq lo2 (T.lub lo1 lo2)\n        then\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1\n                   (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n        else\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (PTree.set r1\n                      (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                      (te_typ e));\n               te_sub := (r1, r2) :: te_sub e\n             |})\n    | right _ =>\n        Error\n          (MSG \"ill-typed move from \"\n           :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"intros [L1 U1].\nexploit (P r2); eauto.\nintros [L2 U2].\ndestruct (T.sub_dec hi1 lo2).\neconstructor; econstructor; eauto.\ndestruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) : exists (changed : bool) (e' : typenv),\n  (if T.sub_dec hi1 lo2\n   then OK (false, e)\n   else\n    match T.sub_dec lo1 hi2 with\n    | left s =>\n        if T.eq lo2 (T.lub lo1 lo2)\n        then\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1\n                   (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n        else\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (PTree.set r1\n                      (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                      (te_typ e));\n               te_sub := (r1, r2) :: te_sub e\n             |})\n    | right _ =>\n        Error\n          (MSG \"ill-typed move from \"\n           :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"exploit (P r2); eauto.\nintros [L2 U2].\ndestruct (T.sub_dec hi1 lo2).\neconstructor; econstructor; eauto.\ndestruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) : T.sub lo2 (te r2) /\\ T.sub (te r2) hi2 ->\nexists (changed : bool) (e' : typenv),\n  (if T.sub_dec hi1 lo2\n   then OK (false, e)\n   else\n    match T.sub_dec lo1 hi2 with\n    | left s =>\n        if T.eq lo2 (T.lub lo1 lo2)\n        then\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1\n                   (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n        else\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (PTree.set r1\n                      (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                      (te_typ e));\n               te_sub := (r1, r2) :: te_sub e\n             |})\n    | right _ =>\n        Error\n          (MSG \"ill-typed move from \"\n           :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"intros [L2 U2].\ndestruct (T.sub_dec hi1 lo2).\neconstructor; econstructor; eauto.\ndestruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) : exists (changed : bool) (e' : typenv),\n  (if T.sub_dec hi1 lo2\n   then OK (false, e)\n   else\n    match T.sub_dec lo1 hi2 with\n    | left s =>\n        if T.eq lo2 (T.lub lo1 lo2)\n        then\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r1\n                   (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n        else\n         if T.eq hi1 (T.glb hi1 hi2)\n         then\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (te_typ e);\n               te_sub := (r1, r2) :: te_sub e\n             |})\n         else\n          OK\n            (true,\n             {|\n               te_typ :=\n                 PTree.set r2\n                   (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                   (PTree.set r1\n                      (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                      (te_typ e));\n               te_sub := (r1, r2) :: te_sub e\n             |})\n    | right _ =>\n        Error\n          (MSG \"ill-typed move from \"\n           :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n    end) = OK (changed, e') /\\ satisf te e'.","proofString":"destruct (T.sub_dec hi1 lo2).\neconstructor; econstructor; eauto.\ndestruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (s : T.sub hi1 lo2) : exists (changed : bool) (e' : typenv),\n  OK (false, e) = OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) : exists (changed : bool) (e' : typenv),\n  match T.sub_dec lo1 hi2 with\n  | left s =>\n      if T.eq lo2 (T.lub lo1 lo2)\n      then\n       if T.eq hi1 (T.glb hi1 hi2)\n       then\n        OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n       else\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r1\n                 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                 (te_typ e);\n             te_sub := (r1, r2) :: te_sub e\n           |})\n      else\n       if T.eq hi1 (T.glb hi1 hi2)\n       then\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2\n                 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                 (te_typ e);\n             te_sub := (r1, r2) :: te_sub e\n           |})\n       else\n        OK\n          (true,\n           {|\n             te_typ :=\n               PTree.set r2\n                 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n                 (PTree.set r1\n                    (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                    (te_typ e));\n             te_sub := (r1, r2) :: te_sub e\n           |})\n  | right _ =>\n      Error\n        (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil)\n  end = OK (changed, e') /\\ satisf te e'.","proofString":"destruct (T.sub_dec lo1 hi2).\ndestruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nelim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s0 : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s0) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) : exists (changed : bool) (e' : typenv),\n  (if T.eq lo2 (T.lub lo1 lo2)\n   then\n    if T.eq hi1 (T.glb hi1 hi2)\n    then OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |})\n    else\n     OK\n       (true,\n        {|\n          te_typ :=\n            PTree.set r1 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n              (te_typ e);\n          te_sub := (r1, r2) :: te_sub e\n        |})\n   else\n    if T.eq hi1 (T.glb hi1 hi2)\n    then\n     OK\n       (true,\n        {|\n          te_typ :=\n            PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n              (te_typ e);\n          te_sub := (r1, r2) :: te_sub e\n        |})\n    else\n     OK\n       (true,\n        {|\n          te_typ :=\n            PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n              (PTree.set r1\n                 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n                 (te_typ e));\n          te_sub := (r1, r2) :: te_sub e\n        |})) = OK (changed, e') /\\ satisf te e'.","proofString":"destruct (T.eq lo2 (T.lub lo1 lo2)); destruct (T.eq hi1 (T.glb hi1 hi2));  econstructor; econstructor; split; eauto; split; auto; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto.\nrewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (e0 : lo2 = T.lub lo1 lo2) (n1 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (H1 : (PTree.set r1 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s)) (te_typ e))\n! x = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (e0 : lo2 = T.lub lo1 lo2) (n1 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (H1 : (if peq x r1\n then Some (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n else (te_typ e) ! x) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"destruct (peq x r1).\nclear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (e0 : lo2 = T.lub lo1 lo2) (n1 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (e1 : x = r1) (H1 : Some (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s)) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"clear e0.\ninv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (e1 : x = r1) (H1 : Some (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s)) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"inv H1.\nsplit; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s3 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s3) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo hi2) (n1 : hi1 <> T.glb hi1 hi2) (s0 : T.sub lo (T.glb hi1 hi2)) : T.sub lo (te r1) /\\ T.sub (te r1) (T.glb hi1 hi2).","proofString":"split; auto.\napply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s3 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s3) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo hi2) (n1 : hi1 <> T.glb hi1 hi2) (s0 : T.sub lo (T.glb hi1 hi2)) : T.sub (te r1) (T.glb hi1 hi2).","proofString":"apply T.glb_max.\nauto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s3 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s3) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo hi2) (n1 : hi1 <> T.glb hi1 hi2) (s0 : T.sub lo (T.glb hi1 hi2)) : T.sub (te r1) hi1.","proofString":"auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s3 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s3) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo hi2) (n1 : hi1 <> T.glb hi1 hi2) (s0 : T.sub lo (T.glb hi1 hi2)) : T.sub (te r1) hi2.","proofString":"apply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (e0 : lo2 = T.lub lo1 lo2) (n1 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (n2 : x <> r1) (H1 : (te_typ e) ! x = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (e0 : hi1 = T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (H1 : (PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2)) (te_typ e))\n! x = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (e0 : hi1 = T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (H1 : (if peq x r2\n then Some (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n else (te_typ e) ! x) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"destruct (peq x r2).\nclear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (e0 : hi1 = T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (e1 : x = r2) (H1 : Some (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2)) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"clear e0.\ninv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (e1 : x = r2) (H1 : Some (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2)) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"inv H1.\nsplit; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s3 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s3) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi : T.t) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi) (n1 : lo2 <> T.lub lo1 lo2) (s0 : T.sub (T.lub lo1 lo2) hi) : T.sub (T.lub lo1 lo2) (te r2) /\\ T.sub (te r2) hi.","proofString":"split; auto.\napply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s3 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s3) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi : T.t) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi) (n1 : lo2 <> T.lub lo1 lo2) (s0 : T.sub (T.lub lo1 lo2) hi) : T.sub (T.lub lo1 lo2) (te r2).","proofString":"apply T.lub_min.\napply T.sub_trans with (te r1); auto.\nauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s3 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s3) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi : T.t) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi) (n1 : lo2 <> T.lub lo1 lo2) (s0 : T.sub (T.lub lo1 lo2) hi) : T.sub lo1 (te r2).","proofString":"apply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s3 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s3) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi : T.t) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi) (n1 : lo2 <> T.lub lo1 lo2) (s0 : T.sub (T.lub lo1 lo2) hi) : T.sub lo2 (te r2).","proofString":"auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (e0 : hi1 = T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (n2 : x <> r2) (H1 : (te_typ e) ! x = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (n2 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (H1 : (PTree.set r2 (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n   (PTree.set r1 (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n      (te_typ e))) ! x = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"rewrite ! PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (n2 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (H1 : (if peq x r2\n then Some (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2))\n else\n  if peq x r1\n  then Some (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n  else (te_typ e) ! x) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"destruct (peq x r2).\ninv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto.\ndestruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (n2 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (e0 : x = r2) (H1 : Some (B (T.lub lo1 lo2) hi2 (T.lub_min lo1 lo2 hi2 s s2)) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"inv H1.\nsplit; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s3 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s3) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi : T.t) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi) (n1 : lo2 <> T.lub lo1 lo2) (n2 : hi1 <> T.glb hi1 hi) (s0 : T.sub (T.lub lo1 lo2) hi) : T.sub (T.lub lo1 lo2) (te r2) /\\ T.sub (te r2) hi.","proofString":"split; auto.\napply T.lub_min; auto.\napply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s3 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s3) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi : T.t) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi) (n1 : lo2 <> T.lub lo1 lo2) (n2 : hi1 <> T.glb hi1 hi) (s0 : T.sub (T.lub lo1 lo2) hi) : T.sub (T.lub lo1 lo2) (te r2).","proofString":"apply T.lub_min; auto.\napply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s3 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s3) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi : T.t) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi) (n1 : lo2 <> T.lub lo1 lo2) (n2 : hi1 <> T.glb hi1 hi) (s0 : T.sub (T.lub lo1 lo2) hi) : T.sub lo1 (te r2).","proofString":"apply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (n2 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (n3 : x <> r2) (H1 : (if peq x r1\n then Some (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s))\n else (te_typ e) ! x) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"destruct (peq x r1).\ninv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (n2 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (n3 : x <> r2) (e0 : x = r1) (H1 : Some (B lo1 (T.glb hi1 hi2) (T.glb_max hi1 hi2 lo1 s1 s)) = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"inv H1.\nsplit; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s3 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s3) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (n1 : lo2 <> T.lub lo lo2) (s : T.sub lo hi2) (n2 : hi1 <> T.glb hi1 hi2) (s0 : T.sub lo (T.glb hi1 hi2)) (n3 : r1 <> r2) : T.sub lo (te r1) /\\ T.sub (te r1) (T.glb hi1 hi2).","proofString":"split; auto.\napply T.glb_max; auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s3 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s3) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (n1 : lo2 <> T.lub lo lo2) (s : T.sub lo hi2) (n2 : hi1 <> T.glb hi1 hi2) (s0 : T.sub lo (T.glb hi1 hi2)) (n3 : r1 <> r2) : T.sub (te r1) (T.glb hi1 hi2).","proofString":"apply T.glb_max; auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s3 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s3) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (n1 : lo2 <> T.lub lo lo2) (s : T.sub lo hi2) (n2 : hi1 <> T.glb hi1 hi2) (s0 : T.sub lo (T.glb hi1 hi2)) (n3 : r1 <> r2) : T.sub (te r1) hi2.","proofString":"apply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s3 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s3) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (s : T.sub lo1 hi2) (n1 : lo2 <> T.lub lo1 lo2) (n2 : hi1 <> T.glb hi1 hi2) (x : positive) (lo hi : T.t) (s0 : T.sub lo hi) (n3 : x <> r2) (n4 : x <> r1) (H1 : (te_typ e) ! x = Some (B lo hi s0)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (n1 : ~ T.sub lo1 hi2) : exists (changed : bool) (e' : typenv),\n  Error (MSG \"ill-typed move from \" :: POS r1 :: MSG \" to \" :: POS r2 :: nil) =\n  OK (changed, e') /\\ satisf te e'.","proofString":"elim n1.\napply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (n1 : ~ T.sub lo1 hi2) : T.sub lo1 hi2.","proofString":"apply T.sub_trans with (te r1); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (L1 : T.sub lo1 (te r1)) (U1 : T.sub (te r1) hi1) (L2 : T.sub lo2 (te r2)) (U2 : T.sub (te r2) hi2) (n0 : ~ T.sub hi1 lo2) (n1 : ~ T.sub lo1 hi2) : T.sub (te r1) hi2.","proofString":"apply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) : exists (changed : bool) (e' : typenv),\n  OK\n    (true,\n     {|\n       te_typ :=\n         PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n           (te_typ e);\n       te_sub := if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n     |}) = OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi1 lo1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n         (te_typ e);\n     te_sub := if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n   |}) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H1 : (PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) (te_typ e))\n! x = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq x r2).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H1 : (if peq x r2\n then Some (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n else (te_typ e) ! x) = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"destruct (peq x r2).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (e0 : x = r2) (H1 : Some (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1)) = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"inv H1.\nexploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s0 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s0) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (E2 : (te_typ e) ! r2 = None) (s : T.sub lo (T.high_bound lo)) : T.sub lo (te r2) /\\ T.sub (te r2) (T.high_bound lo).","proofString":"exploit P; eauto.\nintuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s0 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s0) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (E2 : (te_typ e) ! r2 = None) (s : T.sub lo (T.high_bound lo)) : T.sub lo (te r1) /\\ T.sub (te r1) hi1 ->\nT.sub lo (te r2) /\\ T.sub (te r2) (T.high_bound lo).","proofString":"intuition.\napply T.sub_trans with (te r1); auto.\napply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s0 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s0) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 = r2 -> False) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (E2 : (te_typ e) ! r2 = None) (s : T.sub lo (T.high_bound lo)) (H2 : T.sub lo (te r1)) (H3 : T.sub (te r1) hi1) : T.sub lo (te r2).","proofString":"apply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s0 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s0) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 = r2 -> False) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (E2 : (te_typ e) ! r2 = None) (s : T.sub lo (T.high_bound lo)) (H2 : T.sub lo (te r1)) (H3 : T.sub (te r1) hi1) : T.sub (te r2) (T.high_bound lo).","proofString":"apply T.high_bound_majorant.\napply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo0 hi : T.t) (s0 : T.sub lo0 hi),\n(te_typ e) ! x = Some (B lo0 hi s0) -> T.sub lo0 (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 = r2 -> False) (hi1 lo : T.t) (s1 : T.sub lo hi1) (E1 : (te_typ e) ! r1 = Some (B lo hi1 s1)) (E2 : (te_typ e) ! r2 = None) (s : T.sub lo (T.high_bound lo)) (H2 : T.sub lo (te r1)) (H3 : T.sub (te r1) hi1) : T.sub lo (te r2).","proofString":"apply T.sub_trans with (te r1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (n0 : x <> r2) (H1 : (te_typ e) ! x = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (lo1 hi1 : T.t) (s1 : T.sub lo1 hi1) (E1 : (te_typ e) ! r1 = Some (B lo1 hi1 s1)) (E2 : (te_typ e) ! r2 = None) : forall x y : positive,\nIn (x, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set r2 (B lo1 (T.high_bound lo1) (T.high_bound_sub lo1))\n           (te_typ e);\n       te_sub := if T.sub_dec hi1 lo1 then te_sub e else (r1, r2) :: te_sub e\n     |}) -> T.sub (te x) (te y).","proofString":"destruct (T.sub_dec hi1 lo1); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) : exists (changed : bool) (e' : typenv),\n  OK\n    (true,\n     {|\n       te_typ :=\n         PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n           (te_typ e);\n       te_sub := if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n     |}) = OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; split; eauto; split.\nsimpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto.\ndestruct (T.sub_dec hi2 lo2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ\n   {|\n     te_typ :=\n       PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n         (te_typ e);\n     te_sub := if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n   |}) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H1 : (PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) (te_typ e)) ! x =\nSome (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq x r1).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (H1 : (if peq x r1\n then Some (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n else (te_typ e) ! x) = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"destruct (peq x r1).\ninv H1.\nexploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto.\neapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (e0 : x = r1) (H1 : Some (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2)) = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"inv H1.\nexploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s0 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s0) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi : T.t) (s : T.sub (T.low_bound hi) hi) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) : T.sub (T.low_bound hi) (te r1) /\\ T.sub (te r1) hi.","proofString":"exploit P; eauto.\nintuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s0 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s0) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi : T.t) (s : T.sub (T.low_bound hi) hi) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) : T.sub lo2 (te r2) /\\ T.sub (te r2) hi ->\nT.sub (T.low_bound hi) (te r1) /\\ T.sub (te r1) hi.","proofString":"intuition.\napply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s0 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s0) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 = r2 -> False) (E1 : (te_typ e) ! r1 = None) (lo2 hi : T.t) (s : T.sub (T.low_bound hi) hi) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (H2 : T.sub lo2 (te r2)) (H3 : T.sub (te r2) hi) : T.sub (T.low_bound hi) (te r1).","proofString":"apply T.low_bound_minorant.\napply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s0 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s0) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 = r2 -> False) (E1 : (te_typ e) ! r1 = None) (lo2 hi : T.t) (s : T.sub (T.low_bound hi) hi) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (H2 : T.sub lo2 (te r2)) (H3 : T.sub (te r2) hi) : T.sub (te r1) hi.","proofString":"apply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi0 : T.t) (s0 : T.sub lo hi0),\n(te_typ e) ! x = Some (B lo hi0 s0) -> T.sub lo (te x) /\\ T.sub (te x) hi0) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 = r2 -> False) (E1 : (te_typ e) ! r1 = None) (lo2 hi : T.t) (s : T.sub (T.low_bound hi) hi) (s2 : T.sub lo2 hi) (E2 : (te_typ e) ! r2 = Some (B lo2 hi s2)) (H2 : T.sub lo2 (te r2)) (H3 : T.sub (te r2) hi) : T.sub (te r1) hi.","proofString":"apply T.sub_trans with (te r2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x0 : positive) (lo0 hi0 : T.t) (s0 : T.sub lo0 hi0),\n(te_typ e) ! x0 = Some (B lo0 hi0 s0) ->\nT.sub lo0 (te x0) /\\ T.sub (te x0) hi0) (Q : forall x0 y : positive, In (x0, y) (te_sub e) -> T.sub (te x0) (te y)) (Q' : forall x0 y : positive,\nIn (x0, y) ((r1, r2) :: te_sub e) -> T.sub (te x0) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) (x : positive) (lo hi : T.t) (s : T.sub lo hi) (n0 : x <> r1) (H1 : (te_typ e) ! x = Some (B lo hi s)) : T.sub lo (te x) /\\ T.sub (te x) hi.","proofString":"eapply P; eauto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (lo2 hi2 : T.t) (s2 : T.sub lo2 hi2) (E2 : (te_typ e) ! r2 = Some (B lo2 hi2 s2)) : forall x y : positive,\nIn (x, y)\n  (te_sub\n     {|\n       te_typ :=\n         PTree.set r1 (B (T.low_bound hi2) hi2 (T.low_bound_sub hi2))\n           (te_typ e);\n       te_sub := if T.sub_dec hi2 lo2 then te_sub e else (r1, r2) :: te_sub e\n     |}) -> T.sub (te x) (te y).","proofString":"destruct (T.sub_dec hi2 lo2); auto."},{"statement":"(te : typassign) (e : typenv) (r1 r2 : positive) (H : satisf te e) (H0 : T.sub (te r1) (te r2)) (P : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (Q : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) (Q' : forall x y : positive,\nIn (x, y) ((r1, r2) :: te_sub e) -> T.sub (te x) (te y)) (n : r1 <> r2) (E1 : (te_typ e) ! r1 = None) (E2 : (te_typ e) ! r2 = None) : exists (changed : bool) (e' : typenv),\n  OK (false, {| te_typ := te_typ e; te_sub := (r1, r2) :: te_sub e |}) =\n  OK (changed, e') /\\ satisf te e'.","proofString":"econstructor; econstructor; split; eauto; split; auto."},{"statement":"(te : typassign) (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r1 r2 : positive, False -> T.sub (te r1) (te r2)) : exists (e' : typenv) (changed' : bool),\n  OK (e, changed) = OK (e', changed') /\\ satisf te e'.","proofString":"econstructor; econstructor; eauto."},{"statement":"(te : typassign) (a : positive * positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r1 r2 : positive, In (r1, r2) q -> T.sub (te r1) (te r2)) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r1 r2 : positive,\na = (r1, r2) \\/ In (r1, r2) q -> T.sub (te r1) (te r2)) : exists (e' : typenv) (changed' : bool),\n  (let (r1, r2) := a in\n   do (changed1, e1)<- type_move e r1 r2;\n   solve_rec e1 (changed || changed1) q) = OK (e', changed') /\\ \n  satisf te e'.","proofString":"destruct a as [r1 r2].\nexploit (type_move_complete te e r1 r2); auto.\nintros (changed1 & e1 & A & B).\nexploit (IHq e1 (changed || changed1)); auto.\nintros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> T.sub (te r3) (te r4)) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> T.sub (te r0) (te r3)) : exists (e' : typenv) (changed' : bool),\n  (do (changed1, e1)<- type_move e r1 r2;\n   solve_rec e1 (changed || changed1) q) = OK (e', changed') /\\ \n  satisf te e'.","proofString":"exploit (type_move_complete te e r1 r2); auto.\nintros (changed1 & e1 & A & B).\nexploit (IHq e1 (changed || changed1)); auto.\nintros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> T.sub (te r3) (te r4)) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> T.sub (te r0) (te r3)) : (exists (changed0 : bool) (e' : typenv),\n   type_move e r1 r2 = OK (changed0, e') /\\ satisf te e') ->\nexists (e' : typenv) (changed' : bool),\n  (do (changed1, e1)<- type_move e r1 r2;\n   solve_rec e1 (changed || changed1) q) = OK (e', changed') /\\ \n  satisf te e'.","proofString":"intros (changed1 & e1 & A & B).\nexploit (IHq e1 (changed || changed1)); auto.\nintros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> T.sub (te r3) (te r4)) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> T.sub (te r0) (te r3)) (changed1 : bool) (e1 : typenv) (A : type_move e r1 r2 = OK (changed1, e1)) (B : satisf te e1) : exists (e' : typenv) (changed' : bool),\n  (do (changed0, e0)<- type_move e r1 r2;\n   solve_rec e0 (changed || changed0) q) = OK (e', changed') /\\ \n  satisf te e'.","proofString":"exploit (IHq e1 (changed || changed1)); auto.\nintros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> T.sub (te r3) (te r4)) ->\nexists (e' : typenv) (changed' : bool),\n  solve_rec e0 changed0 q = OK (e', changed') /\\ satisf te e') (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> T.sub (te r0) (te r3)) (changed1 : bool) (e1 : typenv) (A : type_move e r1 r2 = OK (changed1, e1)) (B : satisf te e1) : (exists (e' : typenv) (changed' : bool),\n   solve_rec e1 (changed || changed1) q = OK (e', changed') /\\ satisf te e') ->\nexists (e' : typenv) (changed' : bool),\n  (do (changed0, e0)<- type_move e r1 r2;\n   solve_rec e0 (changed || changed0) q) = OK (e', changed') /\\ \n  satisf te e'.","proofString":"intros (e' & changed' & C & D).\nexists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> T.sub (te r3) (te r4)) ->\nexists (e'0 : typenv) (changed'0 : bool),\n  solve_rec e0 changed0 q = OK (e'0, changed'0) /\\ satisf te e'0) (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> T.sub (te r0) (te r3)) (changed1 : bool) (e1 : typenv) (A : type_move e r1 r2 = OK (changed1, e1)) (B : satisf te e1) (e' : typenv) (changed' : bool) (C : solve_rec e1 (changed || changed1) q = OK (e', changed')) (D : satisf te e') : exists (e'0 : typenv) (changed'0 : bool),\n  (do (changed0, e0)<- type_move e r1 r2;\n   solve_rec e0 (changed || changed0) q) = OK (e'0, changed'0) /\\\n  satisf te e'0.","proofString":"exists e'; exists changed'.\nrewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (r1 r2 : positive) (q : list (positive * positive)) (IHq : forall (e0 : typenv) (changed0 : bool),\nsatisf te e0 ->\n(forall r3 r4 : positive, In (r3, r4) q -> T.sub (te r3) (te r4)) ->\nexists (e'0 : typenv) (changed'0 : bool),\n  solve_rec e0 changed0 q = OK (e'0, changed'0) /\\ satisf te e'0) (e : typenv) (changed : bool) (H : satisf te e) (H0 : forall r0 r3 : positive,\n(r1, r2) = (r0, r3) \\/ In (r0, r3) q -> T.sub (te r0) (te r3)) (changed1 : bool) (e1 : typenv) (A : type_move e r1 r2 = OK (changed1, e1)) (B : satisf te e1) (e' : typenv) (changed' : bool) (C : solve_rec e1 (changed || changed1) q = OK (e', changed')) (D : satisf te e') : (do (changed0, e0)<- type_move e r1 r2; solve_rec e0 (changed || changed0) q) =\nOK (e', changed') /\\ satisf te e'.","proofString":"rewrite A; simpl; rewrite C; auto."},{"statement":"(te : typassign) (e : typenv) : satisf te e ->\nexists e' : typenv, solve_constraints e = OK e' /\\ satisf te e'.","proofString":"functional induction (solve_constraints e); intros.\nexists e; auto.\nexploit (solve_rec_complete te (te_sub e) {| te_typ := te_typ e; te_sub := nil |} false).\ndestruct H; split; auto.\nsimpl; tauto.\ndestruct H; auto.\nintros (e1 & changed1 & P & Q).\napply IHr.\ncongruence.\nexploit (solve_rec_complete te (te_sub e) {| te_typ := te_typ e; te_sub := nil |} false).\ndestruct H; split; auto.\nsimpl; tauto.\ndestruct H; auto.\nintros (e1 & changed1 & P & Q).\ncongruence."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', false)) (H : satisf te e) : exists e'0 : typenv, OK e = OK e'0 /\\ satisf te e'0.","proofString":"exists e; auto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) : exists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0.","proofString":"exploit (solve_rec_complete te (te_sub e) {| te_typ := te_typ e; te_sub := nil |} false).\ndestruct H; split; auto.\nsimpl; tauto.\ndestruct H; auto.\nintros (e1 & changed1 & P & Q).\napply IHr.\ncongruence."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) : satisf te {| te_typ := te_typ e; te_sub := nil |}.","proofString":"destruct H; split; auto.\nsimpl; tauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (H0 : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) : forall x y : positive,\nIn (x, y) (te_sub {| te_typ := te_typ e; te_sub := nil |}) ->\nT.sub (te x) (te y).","proofString":"simpl; tauto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) : forall r1 r2 : positive, In (r1, r2) (te_sub e) -> T.sub (te r1) (te r2).","proofString":"destruct H; auto."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) : (exists (e'0 : typenv) (changed' : bool),\n   solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\n   OK (e'0, changed') /\\ satisf te e'0) ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0.","proofString":"intros (e1 & changed1 & P & Q).\napply IHr.\ncongruence."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) (e1 : typenv) (changed1 : bool) (P : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e1, changed1)) (Q : satisf te e1) : exists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0.","proofString":"apply IHr.\ncongruence."},{"statement":"(te : typassign) (e e' : typenv) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e', true)) (IHr : satisf te e' ->\nexists e'0 : typenv, solve_constraints e' = OK e'0 /\\ satisf te e'0) (H : satisf te e) (e1 : typenv) (changed1 : bool) (P : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e1, changed1)) (Q : satisf te e1) : satisf te e'.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nError msg) (H : satisf te e) : exists e' : typenv, Error msg = OK e' /\\ satisf te e'.","proofString":"exploit (solve_rec_complete te (te_sub e) {| te_typ := te_typ e; te_sub := nil |} false).\ndestruct H; split; auto.\nsimpl; tauto.\ndestruct H; auto.\nintros (e1 & changed1 & P & Q).\ncongruence."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nError msg) (H : satisf te e) : satisf te {| te_typ := te_typ e; te_sub := nil |}.","proofString":"destruct H; split; auto.\nsimpl; tauto."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nError msg) (H : forall (x : positive) (lo hi : T.t) (s : T.sub lo hi),\n(te_typ e) ! x = Some (B lo hi s) -> T.sub lo (te x) /\\ T.sub (te x) hi) (H0 : forall x y : positive, In (x, y) (te_sub e) -> T.sub (te x) (te y)) : forall x y : positive,\nIn (x, y) (te_sub {| te_typ := te_typ e; te_sub := nil |}) ->\nT.sub (te x) (te y).","proofString":"simpl; tauto."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nError msg) (H : satisf te e) : forall r1 r2 : positive, In (r1, r2) (te_sub e) -> T.sub (te r1) (te r2).","proofString":"destruct H; auto."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nError msg) (H : satisf te e) : (exists (e' : typenv) (changed' : bool),\n   solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\n   OK (e', changed') /\\ satisf te e') ->\nexists e' : typenv, Error msg = OK e' /\\ satisf te e'.","proofString":"intros (e1 & changed1 & P & Q).\ncongruence."},{"statement":"(te : typassign) (e : typenv) (msg : errmsg) (e0 : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nError msg) (H : satisf te e) (e1 : typenv) (changed1 : bool) (P : solve_rec {| te_typ := te_typ e; te_sub := nil |} false (te_sub e) =\nOK (e1, changed1)) (Q : satisf te e1) : exists e' : typenv, Error msg = OK e' /\\ satisf te e'.","proofString":"congruence."},{"statement":"(te : typassign) (e : typenv) (H : satisf te e) : exists te' : typassign, solve e = OK te'.","proofString":"unfold solve.\ndestruct (solve_constraints_complete te e H) as (e' & P & Q).\neconstructor.\nrewrite P.\nsimpl.\neauto."},{"statement":"(te : typassign) (e : typenv) (H : satisf te e) : exists te' : typassign,\n  (do e' <- solve_constraints e; OK (makeassign e')) = OK te'.","proofString":"destruct (solve_constraints_complete te e H) as (e' & P & Q).\neconstructor.\nrewrite P.\nsimpl.\neauto."},{"statement":"(te : typassign) (e : typenv) (H : satisf te e) (e' : typenv) (P : solve_constraints e = OK e') (Q : satisf te e') : exists te' : typassign,\n  (do e'0 <- solve_constraints e; OK (makeassign e'0)) = OK te'.","proofString":"econstructor.\nrewrite P.\nsimpl.\neauto."}]}