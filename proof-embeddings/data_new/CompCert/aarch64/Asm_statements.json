{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/Asm.v","fileSamples":[{"statement":"(x y : preg) (i i0 : ireg) : {i = i0} + {i <> i0}.","conclusion":"{i = i0} + {i <> i0}","hypotheses":"(x y : preg) (i i0 : ireg)","proofString":"apply ireg_eq."},{"statement":"(x y : preg) (f f0 : freg) : {f = f0} + {f <> f0}.","conclusion":"{f = f0} + {f <> f0}","hypotheses":"(x y : preg) (f f0 : freg)","proofString":"apply freg_eq."},{"statement":"(x y : preg) (c c0 : crbit) : {c = c0} + {c <> c0}.","conclusion":"{c = c0} + {c <> c0}","hypotheses":"(x y : preg) (c c0 : crbit)","proofString":"apply crbit_eq."},{"statement":"(lbl : label) (instr : instruction) : if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl.","conclusion":"if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl","hypotheses":"(lbl : label) (instr : instruction)","proofString":"destruct instr; simpl; try discriminate.\ndestruct (peq lbl lbl0); congruence."},{"statement":"(lbl lbl0 : label) : if if peq lbl lbl0 then true else false\nthen Plabel lbl0 = Plabel lbl\nelse Plabel lbl0 <> Plabel lbl.","conclusion":"if if peq lbl lbl0 then true else false\nthen Plabel lbl0 = Plabel lbl\nelse Plabel lbl0 <> Plabel lbl","hypotheses":"(lbl lbl0 : label)","proofString":"destruct (peq lbl lbl0); congruence."},{"statement":"(rs : regset) (m : mem) : forall (sg : signature) (args1 args2 : list val),\nextcall_arguments rs m sg args1 ->\nextcall_arguments rs m sg args2 -> args1 = args2.","conclusion":"forall (sg : signature) (args1 args2 : list val),\nextcall_arguments rs m sg args1 ->\nextcall_arguments rs m sg args2 -> args1 = args2","hypotheses":"(rs : regset) (m : mem)","proofString":"assert (A: forall l v1 v2,             extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2).\nintros.\ninv H; inv H0; congruence.\nassert (B: forall p v1 v2,             extcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2).\nintros.\ninv H; inv H0.\neapply A; eauto.\nf_equal; eapply A; eauto.\nassert (C: forall ll vl1, list_forall2 (extcall_arg_pair rs m) ll vl1 ->             forall vl2, list_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2).\ninduction 1; intros vl2 EA; inv EA.\nauto.\nf_equal; eauto.\nintros.\neapply C; eauto."},{"statement":"(rs : regset) (m : mem) : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2.","conclusion":"forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2","hypotheses":"(rs : regset) (m : mem)","proofString":"intros.\ninv H; inv H0; congruence."},{"statement":"(rs : regset) (m : mem) (l : loc) (v1 v2 : val) (H : extcall_arg rs m l v1) (H0 : extcall_arg rs m l v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(rs : regset) (m : mem) (l : loc) (v1 v2 : val) (H : extcall_arg rs m l v1) (H0 : extcall_arg rs m l v2)","proofString":"inv H; inv H0; congruence."},{"statement":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) : forall (sg : signature) (args1 args2 : list val),\nextcall_arguments rs m sg args1 ->\nextcall_arguments rs m sg args2 -> args1 = args2.","conclusion":"forall (sg : signature) (args1 args2 : list val),\nextcall_arguments rs m sg args1 ->\nextcall_arguments rs m sg args2 -> args1 = args2","hypotheses":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2)","proofString":"assert (B: forall p v1 v2,             extcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2).\nintros.\ninv H; inv H0.\neapply A; eauto.\nf_equal; eapply A; eauto.\nassert (C: forall ll vl1, list_forall2 (extcall_arg_pair rs m) ll vl1 ->             forall vl2, list_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2).\ninduction 1; intros vl2 EA; inv EA.\nauto.\nf_equal; eauto.\nintros.\neapply C; eauto."},{"statement":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2.","conclusion":"forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2","hypotheses":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2)","proofString":"intros.\ninv H; inv H0.\neapply A; eauto.\nf_equal; eapply A; eauto."},{"statement":"(rs : regset) (m : mem) (A : forall (l : loc) (v0 v3 : val),\nextcall_arg rs m l v0 -> extcall_arg rs m l v3 -> v0 = v3) (p : rpair loc) (v1 v2 : val) (H : extcall_arg_pair rs m p v1) (H0 : extcall_arg_pair rs m p v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(rs : regset) (m : mem) (A : forall (l : loc) (v0 v3 : val),\nextcall_arg rs m l v0 -> extcall_arg rs m l v3 -> v0 = v3) (p : rpair loc) (v1 v2 : val) (H : extcall_arg_pair rs m p v1) (H0 : extcall_arg_pair rs m p v2)","proofString":"inv H; inv H0.\neapply A; eauto.\nf_equal; eapply A; eauto."},{"statement":"(rs : regset) (m : mem) (A : forall (l0 : loc) (v0 v3 : val),\nextcall_arg rs m l0 v0 -> extcall_arg rs m l0 v3 -> v0 = v3) (v1 v2 : val) (l : loc) (H1 : extcall_arg rs m l v1) (H2 : extcall_arg rs m l v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(rs : regset) (m : mem) (A : forall (l0 : loc) (v0 v3 : val),\nextcall_arg rs m l0 v0 -> extcall_arg rs m l0 v3 -> v0 = v3) (v1 v2 : val) (l : loc) (H1 : extcall_arg rs m l v1) (H2 : extcall_arg rs m l v2)","proofString":"eapply A; eauto."},{"statement":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (hi lo : loc) (vhi vlo : val) (H1 : extcall_arg rs m hi vhi) (H2 : extcall_arg rs m lo vlo) (vhi0 vlo0 : val) (H4 : extcall_arg rs m hi vhi0) (H6 : extcall_arg rs m lo vlo0) : Val.longofwords vhi vlo = Val.longofwords vhi0 vlo0.","conclusion":"Val.longofwords vhi vlo = Val.longofwords vhi0 vlo0","hypotheses":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (hi lo : loc) (vhi vlo : val) (H1 : extcall_arg rs m hi vhi) (H2 : extcall_arg rs m lo vlo) (vhi0 vlo0 : val) (H4 : extcall_arg rs m hi vhi0) (H6 : extcall_arg rs m lo vlo0)","proofString":"f_equal; eapply A; eauto."},{"statement":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2) : forall (sg : signature) (args1 args2 : list val),\nextcall_arguments rs m sg args1 ->\nextcall_arguments rs m sg args2 -> args1 = args2.","conclusion":"forall (sg : signature) (args1 args2 : list val),\nextcall_arguments rs m sg args1 ->\nextcall_arguments rs m sg args2 -> args1 = args2","hypotheses":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2)","proofString":"assert (C: forall ll vl1, list_forall2 (extcall_arg_pair rs m) ll vl1 ->             forall vl2, list_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2).\ninduction 1; intros vl2 EA; inv EA.\nauto.\nf_equal; eauto.\nintros.\neapply C; eauto."},{"statement":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2) : forall (ll : list (rpair loc)) (vl1 : list val),\nlist_forall2 (extcall_arg_pair rs m) ll vl1 ->\nforall vl2 : list val,\nlist_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2.","conclusion":"forall (ll : list (rpair loc)) (vl1 : list val),\nlist_forall2 (extcall_arg_pair rs m) ll vl1 ->\nforall vl2 : list val,\nlist_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2","hypotheses":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2)","proofString":"induction 1; intros vl2 EA; inv EA.\nauto.\nf_equal; eauto."},{"statement":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2) (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H : extcall_arg_pair rs m a1 b1) (H0 : list_forall2 (extcall_arg_pair rs m) al bl) (IHlist_forall2 : forall vl2 : list val,\nlist_forall2 (extcall_arg_pair rs m) al vl2 -> bl = vl2) (b0 : val) (bl0 : list val) (H3 : extcall_arg_pair rs m a1 b0) (H5 : list_forall2 (extcall_arg_pair rs m) al bl0) : b1 :: bl = b0 :: bl0.","conclusion":"b1 :: bl = b0 :: bl0","hypotheses":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2) (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H : extcall_arg_pair rs m a1 b1) (H0 : list_forall2 (extcall_arg_pair rs m) al bl) (IHlist_forall2 : forall vl2 : list val,\nlist_forall2 (extcall_arg_pair rs m) al vl2 -> bl = vl2) (b0 : val) (bl0 : list val) (H3 : extcall_arg_pair rs m a1 b0) (H5 : list_forall2 (extcall_arg_pair rs m) al bl0)","proofString":"f_equal; eauto."},{"statement":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2) (C : forall (ll : list (rpair loc)) (vl1 : list val),\nlist_forall2 (extcall_arg_pair rs m) ll vl1 ->\nforall vl2 : list val,\nlist_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2) : forall (sg : signature) (args1 args2 : list val),\nextcall_arguments rs m sg args1 ->\nextcall_arguments rs m sg args2 -> args1 = args2.","conclusion":"forall (sg : signature) (args1 args2 : list val),\nextcall_arguments rs m sg args1 ->\nextcall_arguments rs m sg args2 -> args1 = args2","hypotheses":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2) (C : forall (ll : list (rpair loc)) (vl1 : list val),\nlist_forall2 (extcall_arg_pair rs m) ll vl1 ->\nforall vl2 : list val,\nlist_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2)","proofString":"intros.\neapply C; eauto."},{"statement":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2) (C : forall (ll : list (rpair loc)) (vl1 : list val),\nlist_forall2 (extcall_arg_pair rs m) ll vl1 ->\nforall vl2 : list val,\nlist_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2) (sg : signature) (args1 args2 : list val) (H : extcall_arguments rs m sg args1) (H0 : extcall_arguments rs m sg args2) : args1 = args2.","conclusion":"args1 = args2","hypotheses":"(rs : regset) (m : mem) (A : forall (l : loc) (v1 v2 : val),\nextcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2) (B : forall (p : rpair loc) (v1 v2 : val),\nextcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2) (C : forall (ll : list (rpair loc)) (vl1 : list val),\nlist_forall2 (extcall_arg_pair rs m) ll vl1 ->\nforall vl2 : list val,\nlist_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2) (sg : signature) (args1 args2 : list val) (H : extcall_arguments rs m sg args1) (H0 : extcall_arguments rs m sg args2)","proofString":"eapply C; eauto."},{"statement":"(p : program) (rs : preg -> val) (m : mem) (b0 : block) (f0 : function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (Internal f0)) (ofs0 : ptrofs) (i0 : instruction) (H3 : find_instr (Ptrofs.unsigned ofs0) (fn_code f0) = Some i0) (H1 : rs PC = Vptr b0 ofs0) (rs'0 : regset) (m'0 : mem) (H4 : exec_instr (Genv.globalenv p) f0 i0 rs m = Next rs'0 m'0) : match_traces (Genv.globalenv p) E0 E0 /\\\n(E0 = E0 -> State rs'0 m'0 = State rs'0 m'0).","conclusion":"match_traces (Genv.globalenv p) E0 E0 /\\\n(E0 = E0 -> State rs'0 m'0 = State rs'0 m'0)","hypotheses":"(p : program) (rs : preg -> val) (m : mem) (b0 : block) (f0 : function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (Internal f0)) (ofs0 : ptrofs) (i0 : instruction) (H3 : find_instr (Ptrofs.unsigned ofs0) (fn_code f0) = Some i0) (H1 : rs PC = Vptr b0 ofs0) (rs'0 : regset) (m'0 : mem) (H4 : exec_instr (Genv.globalenv p) f0 i0 rs m = Next rs'0 m'0)","proofString":"split.\nconstructor.\nauto."},{"statement":"(p : program) (rs : preg -> val) (m : mem) (b0 : block) (f0 : function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (Internal f0)) (ofs0 : ptrofs) (i0 : instruction) (H3 : find_instr (Ptrofs.unsigned ofs0) (fn_code f0) = Some i0) (H1 : rs PC = Vptr b0 ofs0) (rs'0 : regset) (m'0 : mem) (H4 : exec_instr (Genv.globalenv p) f0 i0 rs m = Next rs'0 m'0) : match_traces (Genv.globalenv p) E0 E0.","conclusion":"match_traces (Genv.globalenv p) E0 E0","hypotheses":"(p : program) (rs : preg -> val) (m : mem) (b0 : block) (f0 : function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (Internal f0)) (ofs0 : ptrofs) (i0 : instruction) (H3 : find_instr (Ptrofs.unsigned ofs0) (fn_code f0) = Some i0) (H1 : rs PC = Vptr b0 ofs0) (rs'0 : regset) (m'0 : mem) (H4 : exec_instr (Genv.globalenv p) f0 i0 rs m = Next rs'0 m'0)","proofString":"constructor."},{"statement":"(p : program) (rs : preg -> val) (m : mem) (b0 : block) (f0 : function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (Internal f0)) (ofs0 : ptrofs) (i0 : instruction) (H3 : find_instr (Ptrofs.unsigned ofs0) (fn_code f0) = Some i0) (H1 : rs PC = Vptr b0 ofs0) (rs'0 : regset) (m'0 : mem) (H4 : exec_instr (Genv.globalenv p) f0 i0 rs m = Next rs'0 m'0) : E0 = E0 -> State rs'0 m'0 = State rs'0 m'0.","conclusion":"E0 = E0 -> State rs'0 m'0 = State rs'0 m'0","hypotheses":"(p : program) (rs : preg -> val) (m : mem) (b0 : block) (f0 : function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (Internal f0)) (ofs0 : ptrofs) (i0 : instruction) (H3 : find_instr (Ptrofs.unsigned ofs0) (fn_code f0) = Some i0) (H1 : rs PC = Vptr b0 ofs0) (rs'0 : regset) (m'0 : mem) (H4 : exec_instr (Genv.globalenv p) f0 i0 rs m = Next rs'0 m'0)","proofString":"auto."},{"statement":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (vargs : list val) (vres : val) (m' : mem) (b0 : block) (f0 : function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (Internal f0)) (ofs0 : ptrofs) (ef0 : external_function) (args0 : list (builtin_arg preg)) (res0 : builtin_res preg) (H3 : find_instr (Ptrofs.unsigned ofs0) (fn_code f0) =\nSome (Pbuiltin ef0 args0 res0)) (H1 : rs PC = Vptr b0 ofs0) (H4 : eval_builtin_args (Genv.globalenv p) rs (rs SP) m args0 vargs) (H5 : external_call ef0 (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H11 : external_call ef0 (Genv.globalenv p) vargs m t2 vres0 m'0) (H10 : eval_builtin_args (Genv.globalenv p) rs (rs SP) m args0 vargs) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0) : match_traces (Genv.globalenv p) t1 t2.","conclusion":"match_traces (Genv.globalenv p) t1 t2","hypotheses":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (vargs : list val) (vres : val) (m' : mem) (b0 : block) (f0 : function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (Internal f0)) (ofs0 : ptrofs) (ef0 : external_function) (args0 : list (builtin_arg preg)) (res0 : builtin_res preg) (H3 : find_instr (Ptrofs.unsigned ofs0) (fn_code f0) =\nSome (Pbuiltin ef0 args0 res0)) (H1 : rs PC = Vptr b0 ofs0) (H4 : eval_builtin_args (Genv.globalenv p) rs (rs SP) m args0 vargs) (H5 : external_call ef0 (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H11 : external_call ef0 (Genv.globalenv p) vargs m t2 vres0 m'0) (H10 : eval_builtin_args (Genv.globalenv p) rs (rs SP) m args0 vargs) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0)","proofString":"auto."},{"statement":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (args0 : list val) (res0 : val) (m'0 : mem) (H8 : external_call ef0 (Genv.globalenv p) args0 m t2 res0 m'0) (H9 : extcall_arguments rs m (ef_sig ef0) args0) : match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res0\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m'0).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res0\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m'0)","hypotheses":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (args0 : list val) (res0 : val) (m'0 : mem) (H8 : external_call ef0 (Genv.globalenv p) args0 m t2 res0 m'0) (H9 : extcall_arguments rs m (ef_sig ef0) args0)","proofString":"assert (args0 = args) by (eapply extcall_arguments_determ; eauto).\nsubst args0.\nexploit external_call_determ.\neexact H3.\neexact H8.\nintros [A B].\nsplit.\nauto.\nintros.\ndestruct B; auto.\nsubst.\nauto."},{"statement":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (args0 : list val) (res0 : val) (m'0 : mem) (H8 : external_call ef0 (Genv.globalenv p) args0 m t2 res0 m'0) (H9 : extcall_arguments rs m (ef_sig ef0) args0) (H : args0 = args) : match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res0\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m'0).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res0\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m'0)","hypotheses":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (args0 : list val) (res0 : val) (m'0 : mem) (H8 : external_call ef0 (Genv.globalenv p) args0 m t2 res0 m'0) (H9 : extcall_arguments rs m (ef_sig ef0) args0) (H : args0 = args)","proofString":"subst args0.\nexploit external_call_determ.\neexact H3.\neexact H8.\nintros [A B].\nsplit.\nauto.\nintros.\ndestruct B; auto.\nsubst.\nauto."},{"statement":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) : match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res0\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m'0).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res0\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m'0)","hypotheses":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0)","proofString":"exploit external_call_determ.\neexact H3.\neexact H8.\nintros [A B].\nsplit.\nauto.\nintros.\ndestruct B; auto.\nsubst.\nauto."},{"statement":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> res = res0 /\\ m' = m'0) : match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res0\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m'0).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\n State\n   (set_pair (loc_external_result (ef_sig ef0)) res0\n      (undef_caller_save_regs rs)) # PC <- (rs X30) m'0)","hypotheses":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> res = res0 /\\ m' = m'0)","proofString":"split.\nauto.\nintros.\ndestruct B; auto.\nsubst.\nauto."},{"statement":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> res = res0 /\\ m' = m'0) : match_traces (Genv.globalenv p) t1 t2.","conclusion":"match_traces (Genv.globalenv p) t1 t2","hypotheses":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> res = res0 /\\ m' = m'0)","proofString":"auto."},{"statement":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> res = res0 /\\ m' = m'0) : t1 = t2 ->\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0.","conclusion":"t1 = t2 ->\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0","hypotheses":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> res = res0 /\\ m' = m'0)","proofString":"intros.\ndestruct B; auto.\nsubst.\nauto."},{"statement":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> res = res0 /\\ m' = m'0) (H : t1 = t2) : State\n  (set_pair (loc_external_result (ef_sig ef0)) res\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0.","conclusion":"State\n  (set_pair (loc_external_result (ef_sig ef0)) res\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0","hypotheses":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> res = res0 /\\ m' = m'0) (H : t1 = t2)","proofString":"destruct B; auto.\nsubst.\nauto."},{"statement":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (H : t1 = t2) (H0 : res = res0) (H5 : m' = m'0) : State\n  (set_pair (loc_external_result (ef_sig ef0)) res\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0.","conclusion":"State\n  (set_pair (loc_external_result (ef_sig ef0)) res\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m' =\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0","hypotheses":"(p : program) (t1 t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (res : val) (m' : mem) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (H3 : external_call ef0 (Genv.globalenv p) args m t1 res m') (res0 : val) (m'0 : mem) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (H : t1 = t2) (H0 : res = res0) (H5 : m' = m'0)","proofString":"subst.\nauto."},{"statement":"(p : program) (t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (res0 : val) (m'0 : mem) (H3 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t2 t2) : State\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0 =\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0.","conclusion":"State\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0 =\nState\n  (set_pair (loc_external_result (ef_sig ef0)) res0\n     (undef_caller_save_regs rs)) # PC <- (rs X30) m'0","hypotheses":"(p : program) (t2 : trace) (rs : preg -> val) (m : mem) (args : list val) (b0 : block) (ef0 : external_function) (H2 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some (External ef0)) (H1 : rs PC = Vptr b0 Ptrofs.zero) (H4 : extcall_arguments rs m (ef_sig ef0) args) (res0 : val) (m'0 : mem) (H3 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (H9 : extcall_arguments rs m (ef_sig ef0) args) (H8 : external_call ef0 (Genv.globalenv p) args m t2 res0 m'0) (A : match_traces (Genv.globalenv p) t2 t2)","proofString":"auto."},{"statement":"(p : program) : single_events (semantics p).","conclusion":"single_events (semantics p)","hypotheses":"(p : program)","proofString":"red; intros.\ninv H; simpl.\nlia.\neapply external_call_trace_length; eauto.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (s : Smallstep.state (semantics p)) (t : trace) (s' : Smallstep.state (semantics p)) (H : Step (semantics p) s t s') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (s : Smallstep.state (semantics p)) (t : trace) (s' : Smallstep.state (semantics p)) (H : Step (semantics p) s t s')","proofString":"inv H; simpl.\nlia.\neapply external_call_trace_length; eauto.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (b : block) (ofs : ptrofs) (f : function) (i : instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : rs PC = Vptr b ofs) (H1 : Genv.find_funct_ptr (globalenv (semantics p)) b = Some (Internal f)) (H2 : find_instr (Ptrofs.unsigned ofs) (fn_code f) = Some i) (H3 : exec_instr (globalenv (semantics p)) f i rs m = Next rs' m') : (0 <= 1)%nat.","conclusion":"(0 <= 1)%nat","hypotheses":"(p : program) (b : block) (ofs : ptrofs) (f : function) (i : instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : rs PC = Vptr b ofs) (H1 : Genv.find_funct_ptr (globalenv (semantics p)) b = Some (Internal f)) (H2 : find_instr (Ptrofs.unsigned ofs) (fn_code f) = Some i) (H3 : exec_instr (globalenv (semantics p)) f i rs m = Next rs' m')","proofString":"lia."},{"statement":"(p : program) (t : trace) (b : block) (ofs : ptrofs) (f : function) (ef : external_function) (args : list (builtin_arg preg)) (res : builtin_res preg) (rs : preg -> val) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : rs PC = Vptr b ofs) (H1 : Genv.find_funct_ptr (globalenv (semantics p)) b = Some (Internal f)) (H2 : find_instr (Ptrofs.unsigned ofs) (fn_code f) = Some (Pbuiltin ef args res)) (H3 : eval_builtin_args (globalenv (semantics p)) rs (rs SP) m args vargs) (H4 : external_call ef (globalenv (semantics p)) vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (t : trace) (b : block) (ofs : ptrofs) (f : function) (ef : external_function) (args : list (builtin_arg preg)) (res : builtin_res preg) (rs : preg -> val) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : rs PC = Vptr b ofs) (H1 : Genv.find_funct_ptr (globalenv (semantics p)) b = Some (Internal f)) (H2 : find_instr (Ptrofs.unsigned ofs) (fn_code f) = Some (Pbuiltin ef args res)) (H3 : eval_builtin_args (globalenv (semantics p)) rs (rs SP) m args vargs) (H4 : external_call ef (globalenv (semantics p)) vargs m t vres m')","proofString":"eapply external_call_trace_length; eauto."},{"statement":"(p : program) (t : trace) (b : block) (ef : external_function) (args : list val) (res : val) (rs : preg -> val) (m m' : mem) (H0 : rs PC = Vptr b Ptrofs.zero) (H1 : Genv.find_funct_ptr (globalenv (semantics p)) b = Some (External ef)) (H2 : external_call ef (globalenv (semantics p)) args m t res m') (H3 : extcall_arguments rs m (ef_sig ef) args) : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (t : trace) (b : block) (ef : external_function) (args : list val) (res : val) (rs : preg -> val) (m m' : mem) (H0 : rs PC = Vptr b Ptrofs.zero) (H1 : Genv.find_funct_ptr (globalenv (semantics p)) b = Some (External ef)) (H2 : external_call ef (globalenv (semantics p)) args m t res m') (H3 : extcall_arguments rs m (ef_sig ef) args)","proofString":"eapply external_call_trace_length; eauto."},{"statement":"(p : program) (s1 s2 : state) (H : initial_state p s1) (H0 : initial_state p s2) : s1 = s2.","conclusion":"s1 = s2","hypotheses":"(p : program) (s1 s2 : state) (H : initial_state p s1) (H0 : initial_state p s2)","proofString":"inv H; inv H0.\nf_equal.\ncongruence."},{"statement":"(p : program) (m0 : mem) (ge : Genv.t fundef unit) (rs0 : PregEq.t -> val) (H1 : Genv.init_mem p = Some m0) (m1 : mem) (ge0 : Genv.t fundef unit) (rs1 : PregEq.t -> val) (H : Genv.init_mem p = Some m1) : m0 = m1.","conclusion":"m0 = m1","hypotheses":"(p : program) (m0 : mem) (ge : Genv.t fundef unit) (rs0 : PregEq.t -> val) (H1 : Genv.init_mem p = Some m0) (m1 : mem) (ge0 : Genv.t fundef unit) (rs1 : PregEq.t -> val) (H : Genv.init_mem p = Some m1)","proofString":"congruence."},{"statement":"(p : program) (s : state) (r : int) (H : final_state s r) : nostep step (Genv.globalenv p) s.","conclusion":"nostep step (Genv.globalenv p) s","hypotheses":"(p : program) (s : state) (r : int) (H : final_state s r)","proofString":"inv H.\nred; intros; red; intros.\ninv H; rewrite H0 in *; discriminate."},{"statement":"(p : program) (r : int) (rs : preg -> val) (m : mem) (H0 : rs PC = Vnullptr) (H1 : rs X0 = Vint r) : nostep step (Genv.globalenv p) (State rs m).","conclusion":"nostep step (Genv.globalenv p) (State rs m)","hypotheses":"(p : program) (r : int) (rs : preg -> val) (m : mem) (H0 : rs PC = Vnullptr) (H1 : rs X0 = Vint r)","proofString":"red; intros; red; intros.\ninv H; rewrite H0 in *; discriminate."},{"statement":"(p : program) (r : int) (rs : preg -> val) (m : mem) (H0 : rs PC = Vnullptr) (H1 : rs X0 = Vint r) (t : trace) (s' : state) (H : step (Genv.globalenv p) (State rs m) t s') : False.","conclusion":"False","hypotheses":"(p : program) (r : int) (rs : preg -> val) (m : mem) (H0 : rs PC = Vnullptr) (H1 : rs X0 = Vint r) (t : trace) (s' : state) (H : step (Genv.globalenv p) (State rs m) t s')","proofString":"inv H; rewrite H0 in *; discriminate."},{"statement":"(p : program) (s : state) (r1 r2 : int) (H : final_state s r1) (H0 : final_state s r2) : r1 = r2.","conclusion":"r1 = r2","hypotheses":"(p : program) (s : state) (r1 r2 : int) (H : final_state s r1) (H0 : final_state s r2)","proofString":"inv H; inv H0.\ncongruence."},{"statement":"(p : program) (r1 r2 : int) (rs : preg -> val) (m : mem) (H1 : rs PC = Vnullptr) (H2 : rs X0 = Vint r1) (H4 : rs PC = Vnullptr) (H6 : rs X0 = Vint r2) : r1 = r2.","conclusion":"r1 = r2","hypotheses":"(p : program) (r1 r2 : int) (rs : preg -> val) (m : mem) (H1 : rs PC = Vnullptr) (H2 : rs X0 = Vint r1) (H4 : rs PC = Vnullptr) (H6 : rs X0 = Vint r2)","proofString":"congruence."}]}