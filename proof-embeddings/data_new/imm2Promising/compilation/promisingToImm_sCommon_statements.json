{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/promising2ToImm/src/compilation/promisingToImm_sCommon.v","fileSamples":[{"statement":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) : exists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads x) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local').","conclusion":"exists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads x) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local')","hypotheses":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local))","proofString":"eauto."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) : forall (lang0 : language) (state : Language.state lang0) (local : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid\n    (Configuration.threads\n       {|\n         Configuration.threads :=\n           IdentMap.add tid\n             (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n             (Configuration.threads c1);\n         Configuration.sc := sc3;\n         Configuration.memory := memory3\n       |}) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local').","conclusion":"forall (lang0 : language) (state : Language.state lang0) (local : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid\n    (Configuration.threads\n       {|\n         Configuration.threads :=\n           IdentMap.add tid\n             (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n             (Configuration.threads c1);\n         Configuration.sc := sc3;\n         Configuration.memory := memory3\n       |}) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure)","proofString":"simpls.\nrewrite IdentMap.gss.\neauto."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) : forall (lang0 : language) (state : Language.state lang0) (local : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid\n    (IdentMap.add tid\n       (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n       (Configuration.threads c1)) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local').","conclusion":"forall (lang0 : language) (state : Language.state lang0) (local : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid\n    (IdentMap.add tid\n       (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n       (Configuration.threads c1)) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure)","proofString":"rewrite IdentMap.gss.\neauto."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) : forall (lang0 : language) (state : Language.state lang0) (local : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  Some (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local').","conclusion":"forall (lang0 : language) (state : Language.state lang0) (local : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  Some (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure)","proofString":"eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang : language) (state : Language.state lang) (local : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local')) (IHSTEPS2 : forall (lang : language) (state : Language.state lang) (local : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local')) : forall (lang : language) (state : Language.state lang) (local : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local').","conclusion":"forall (lang : language) (state : Language.state lang) (local : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local')","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang : language) (state : Language.state lang) (local : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local')) (IHSTEPS2 : forall (lang : language) (state : Language.state lang) (local : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local'))","proofString":"ins.\nedestruct IHSTEPS1; eauto.\ndesc.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')) (lang : language) (state : Language.state lang) (local : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) : exists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local').","conclusion":"exists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local')","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')) (lang : language) (state : Language.state lang) (local : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local))","proofString":"edestruct IHSTEPS1; eauto.\ndesc.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')) (lang : language) (state : Language.state lang) (local : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (x0 : language) (H : exists (state' : Language.state x0) (local' : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) x0 state', local')) : exists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local').","conclusion":"exists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state',\n     local')","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists (lang' : language) (state' : Language.state lang') \n(local' : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state',\n     local')) (lang : language) (state : Language.state lang) (local : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (x0 : language) (H : exists (state' : Language.state x0) (local' : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) x0 state', local'))","proofString":"desc.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists\n  (lang' : language) (state'0 : Language.state lang') \n(local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state'0,\n     local'0)) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists\n  (lang' : language) (state'0 : Language.state lang') \n(local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state'0,\n     local'0)) (lang : language) (state : Language.state lang) (local : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (x0 : language) (state' : Language.state x0) (local' : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) x0 state', local')) : exists\n  (lang' : language) (state'0 : Language.state lang') \n(local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state'0,\n     local'0).","conclusion":"exists\n  (lang' : language) (state'0 : Language.state lang') \n(local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) lang' state'0,\n     local'0)","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists\n  (lang' : language) (state'0 : Language.state lang') \n(local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state'0,\n     local'0)) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) (local0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nexists\n  (lang' : language) (state'0 : Language.state lang') \n(local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads z) =\n  Some\n    (existT (fun lang1 : language => Language.state lang1) lang' state'0,\n     local'0)) (lang : language) (state : Language.state lang) (local : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (x0 : language) (state' : Language.state x0) (local' : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) x0 state', local'))","proofString":"eapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local')) : lang = lang'.","conclusion":"lang = lang'","hypotheses":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local'))","proofString":"rewrite THREAD' in THREAD.\ninv THREAD."},{"statement":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : Some\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local') =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local')) : lang = lang'.","conclusion":"lang = lang'","hypotheses":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : Some\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local') =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local'))","proofString":"inv THREAD."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) : forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nIdentMap.find tid\n  (Configuration.threads\n     {|\n       Configuration.threads :=\n         IdentMap.add tid\n           (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n           (Configuration.threads c1);\n       Configuration.sc := sc3;\n       Configuration.memory := memory3\n     |}) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang' state', local') ->\nlang0 = lang'.","conclusion":"forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nIdentMap.find tid\n  (Configuration.threads\n     {|\n       Configuration.threads :=\n         IdentMap.add tid\n           (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n           (Configuration.threads c1);\n       Configuration.sc := sc3;\n       Configuration.memory := memory3\n     |}) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang' state', local') ->\nlang0 = lang'","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure)","proofString":"simpls.\nrewrite IdentMap.gss.\nins.\ndesf."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) : forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nIdentMap.find tid\n  (IdentMap.add tid\n     (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n     (Configuration.threads c1)) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang' state', local') ->\nlang0 = lang'.","conclusion":"forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nIdentMap.find tid\n  (IdentMap.add tid\n     (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n     (Configuration.threads c1)) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang' state', local') ->\nlang0 = lang'","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure)","proofString":"rewrite IdentMap.gss.\nins.\ndesf."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) : forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nSome (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang' state', local') ->\nlang0 = lang'.","conclusion":"forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nSome (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang' state', local') ->\nlang0 = lang'","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure)","proofString":"ins.\ndesf."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang1 : language => Language.state lang1) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (lang0 : language) (state : Language.state lang0) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local)) (THREAD' : Some (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang' state', local')) : lang0 = lang'.","conclusion":"lang0 = lang'","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang1 : language => Language.state lang1) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (lang0 : language) (state : Language.state lang0) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local)) (THREAD' : Some (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang' state', local'))","proofString":"desf."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local') ->\nlang = lang') (IHSTEPS2 : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local') ->\nlang = lang') : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local') ->\nlang = lang'.","conclusion":"forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local') ->\nlang = lang'","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local') ->\nlang = lang') (IHSTEPS2 : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (lang' : language) (state' : Language.state lang')\n  (local' : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local') ->\nlang = lang')","proofString":"ins.\nedestruct conf_steps_preserve_thread with (PC':=y); eauto.\ndesc.\netransitivity.\neapply IHSTEPS1; eauto.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'0 : Language.state lang'0)\n  (local'0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'0,\n   local'0) -> lang0 = lang'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'0 : Language.state lang'0)\n  (local'0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'0,\n   local'0) -> lang0 = lang'0) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local')) : lang = lang'.","conclusion":"lang = lang'","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'0 : Language.state lang'0)\n  (local'0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'0,\n   local'0) -> lang0 = lang'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'0 : Language.state lang'0)\n  (local'0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'0,\n   local'0) -> lang0 = lang'0) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local'))","proofString":"edestruct conf_steps_preserve_thread with (PC':=y); eauto.\ndesc.\netransitivity.\neapply IHSTEPS1; eauto.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'0 : Language.state lang'0)\n  (local'0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'0,\n   local'0) -> lang0 = lang'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'0 : Language.state lang'0)\n  (local'0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'0,\n   local'0) -> lang0 = lang'0) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local')) (x0 : language) (H : exists (state'0 : Language.state x0) (local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) x0 state'0,\n     local'0)) : lang = lang'.","conclusion":"lang = lang'","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'0 : Language.state lang'0)\n  (local'0 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'0,\n   local'0) -> lang0 = lang'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'0 : Language.state lang'0)\n  (local'0 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'0,\n   local'0) -> lang0 = lang'0) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local')) (x0 : language) (H : exists (state'0 : Language.state x0) (local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) x0 state'0,\n     local'0))","proofString":"desc.\netransitivity.\neapply IHSTEPS1; eauto.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'1 : Language.state lang'0)\n  (local'1 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'1,\n   local'1) -> lang0 = lang'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'1 : Language.state lang'0)\n  (local'1 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'1,\n   local'1) -> lang0 = lang'0) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local')) (x0 : language) (state'0 : Language.state x0) (local'0 : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) x0 state'0, local'0)) : lang = lang'.","conclusion":"lang = lang'","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'1 : Language.state lang'0)\n  (local'1 : Local.t),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'1,\n   local'1) -> lang0 = lang'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (lang'0 : language) (state'1 : Language.state lang'0)\n  (local'1 : Local.t),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang'0 state'1,\n   local'1) -> lang0 = lang'0) (lang : language) (state : Language.state lang) (local : Local.t) (lang' : language) (state' : Language.state lang') (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang' state', local')) (x0 : language) (state'0 : Language.state x0) (local'0 : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) x0 state'0, local'0))","proofString":"etransitivity.\neapply IHSTEPS1; eauto.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) : rtc (Thread.tau_step (lang:=lang)) ts ts'.","conclusion":"rtc (Thread.tau_step (lang:=lang)) ts ts'","hypotheses":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|})","proofString":"apply rtc_refl.\nrewrite TS, TS'.\nrewrite THREAD' in THREAD.\ninv THREAD."},{"statement":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) : ts = ts'.","conclusion":"ts = ts'","hypotheses":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|})","proofString":"rewrite TS, TS'.\nrewrite THREAD' in THREAD.\ninv THREAD."},{"statement":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) : {|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}.","conclusion":"{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}","hypotheses":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|})","proofString":"rewrite THREAD' in THREAD.\ninv THREAD."},{"statement":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : Some\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) : {|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}.","conclusion":"{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}","hypotheses":"(tid : Ident.t) (x : Configuration.t) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : Some\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|})","proofString":"inv THREAD."},{"statement":"(tid : Ident.t) (x y : Configuration.t) (pe : MachineEvent.t) (H : plain_step pe tid x y) (HH : pe = MachineEvent.silent) : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (state' : Language.state lang) \n  (local' : Local.t) (ts ts' : Thread.t lang),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang)) ts ts'.","conclusion":"forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (state' : Language.state lang) \n  (local' : Local.t) (ts ts' : Thread.t lang),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang)) ts ts'","hypotheses":"(tid : Ident.t) (x y : Configuration.t) (pe : MachineEvent.t) (H : plain_step pe tid x y) (HH : pe = MachineEvent.silent)","proofString":"destruct H.\nsimpls.\nrewrite IdentMap.gss.\nins.\ndesf.\neapply rtc_n1; eauto.\nred.\neconstructor.\neconstructor; eauto.\ndone."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) : forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (state' : Language.state lang0) \n  (local' : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nIdentMap.find tid\n  (Configuration.threads\n     {|\n       Configuration.threads :=\n         IdentMap.add tid\n           (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n           (Configuration.threads c1);\n       Configuration.sc := sc3;\n       Configuration.memory := memory3\n     |}) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc c1;\n  Thread.memory := Configuration.memory c1\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc :=\n    Configuration.sc\n      {|\n        Configuration.threads :=\n          IdentMap.add tid\n            (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n            (Configuration.threads c1);\n        Configuration.sc := sc3;\n        Configuration.memory := memory3\n      |};\n  Thread.memory :=\n    Configuration.memory\n      {|\n        Configuration.threads :=\n          IdentMap.add tid\n            (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n            (Configuration.threads c1);\n        Configuration.sc := sc3;\n        Configuration.memory := memory3\n      |}\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts'.","conclusion":"forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (state' : Language.state lang0) \n  (local' : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nIdentMap.find tid\n  (Configuration.threads\n     {|\n       Configuration.threads :=\n         IdentMap.add tid\n           (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n           (Configuration.threads c1);\n       Configuration.sc := sc3;\n       Configuration.memory := memory3\n     |}) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc c1;\n  Thread.memory := Configuration.memory c1\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc :=\n    Configuration.sc\n      {|\n        Configuration.threads :=\n          IdentMap.add tid\n            (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n            (Configuration.threads c1);\n        Configuration.sc := sc3;\n        Configuration.memory := memory3\n      |};\n  Thread.memory :=\n    Configuration.memory\n      {|\n        Configuration.threads :=\n          IdentMap.add tid\n            (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n            (Configuration.threads c1);\n        Configuration.sc := sc3;\n        Configuration.memory := memory3\n      |}\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts'","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent)","proofString":"simpls.\nrewrite IdentMap.gss.\nins.\ndesf.\neapply rtc_n1; eauto.\nred.\neconstructor.\neconstructor; eauto.\ndone."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) : forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (state' : Language.state lang0) \n  (local' : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nIdentMap.find tid\n  (IdentMap.add tid\n     (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n     (Configuration.threads c1)) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc c1;\n  Thread.memory := Configuration.memory c1\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := sc3;\n  Thread.memory := memory3\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts'.","conclusion":"forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (state' : Language.state lang0) \n  (local' : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nIdentMap.find tid\n  (IdentMap.add tid\n     (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n     (Configuration.threads c1)) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc c1;\n  Thread.memory := Configuration.memory c1\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := sc3;\n  Thread.memory := memory3\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts'","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent)","proofString":"rewrite IdentMap.gss.\nins.\ndesf.\neapply rtc_n1; eauto.\nred.\neconstructor.\neconstructor; eauto.\ndone."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) : forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (state' : Language.state lang0) \n  (local' : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nSome (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc c1;\n  Thread.memory := Configuration.memory c1\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := sc3;\n  Thread.memory := memory3\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts'.","conclusion":"forall (lang0 : language) (state : Language.state lang0) \n  (local : Local.t) (state' : Language.state lang0) \n  (local' : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local) ->\nSome (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc c1;\n  Thread.memory := Configuration.memory c1\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := sc3;\n  Thread.memory := memory3\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts'","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent)","proofString":"ins.\ndesf.\neapply rtc_n1; eauto.\nred.\neconstructor.\neconstructor; eauto.\ndone."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang1 : language => Language.state lang1) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) (lang0 : language) (state : Language.state lang0) (local : Local.t) (state' : Language.state lang0) (local' : Local.t) (ts ts' : Thread.t lang0) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local)) (THREAD' : Some (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc c1;\n  Thread.memory := Configuration.memory c1\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := sc3;\n  Thread.memory := memory3\n|}) : rtc (Thread.tau_step (lang:=lang0)) ts ts'.","conclusion":"rtc (Thread.tau_step (lang:=lang0)) ts ts'","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang1 : language => Language.state lang1) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) (lang0 : language) (state : Language.state lang0) (local : Local.t) (state' : Language.state lang0) (local' : Local.t) (ts ts' : Thread.t lang0) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state, local)) (THREAD' : Some (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc c1;\n  Thread.memory := Configuration.memory c1\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := sc3;\n  Thread.memory := memory3\n|})","proofString":"desf.\neapply rtc_n1; eauto.\nred.\neconstructor.\neconstructor; eauto.\ndone."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang0 : language) (st1 : Language.state lang0) (lc1 : Local.t) (e2 : Thread.t lang0) (sc3 : TimeMap.t) (memory3 : Memory.t) (STEPS : rtc (Thread.tau_step (lang:=lang0))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (local' : Local.t) (state' : Language.state lang0) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang : language => Language.state lang) lang0 st1, lc1)) : rtc (Thread.tau_step (lang:=lang0))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |}\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}.","conclusion":"rtc (Thread.tau_step (lang:=lang0))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |}\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang0 : language) (st1 : Language.state lang0) (lc1 : Local.t) (e2 : Thread.t lang0) (sc3 : TimeMap.t) (memory3 : Memory.t) (STEPS : rtc (Thread.tau_step (lang:=lang0))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (local' : Local.t) (state' : Language.state lang0) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang : language => Language.state lang) lang0 st1, lc1))","proofString":"eapply rtc_n1; eauto.\nred.\neconstructor.\neconstructor; eauto.\ndone."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang0 : language) (st1 : Language.state lang0) (lc1 : Local.t) (e2 : Thread.t lang0) (sc3 : TimeMap.t) (memory3 : Memory.t) (STEPS : rtc (Thread.tau_step (lang:=lang0))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (local' : Local.t) (state' : Language.state lang0) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang : language => Language.state lang) lang0 st1, lc1)) : Thread.tau_step e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}.","conclusion":"Thread.tau_step e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang0 : language) (st1 : Language.state lang0) (lc1 : Local.t) (e2 : Thread.t lang0) (sc3 : TimeMap.t) (memory3 : Memory.t) (STEPS : rtc (Thread.tau_step (lang:=lang0))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (local' : Local.t) (state' : Language.state lang0) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang : language => Language.state lang) lang0 st1, lc1))","proofString":"red.\neconstructor.\neconstructor; eauto.\ndone."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang0 : language) (st1 : Language.state lang0) (lc1 : Local.t) (e2 : Thread.t lang0) (sc3 : TimeMap.t) (memory3 : Memory.t) (STEPS : rtc (Thread.tau_step (lang:=lang0))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (local' : Local.t) (state' : Language.state lang0) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang : language => Language.state lang) lang0 st1, lc1)) : tau (Thread.step_allpf (lang:=lang0)) e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}.","conclusion":"tau (Thread.step_allpf (lang:=lang0)) e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}","hypotheses":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang0 : language) (st1 : Language.state lang0) (lc1 : Local.t) (e2 : Thread.t lang0) (sc3 : TimeMap.t) (memory3 : Memory.t) (STEPS : rtc (Thread.tau_step (lang:=lang0))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (local' : Local.t) (state' : Language.state lang0) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (HH : ThreadEvent.get_machine_event e = MachineEvent.silent) (THREAD : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang : language => Language.state lang) lang0 st1, lc1))","proofString":"econstructor.\neconstructor; eauto.\ndone."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (state' : Language.state lang) \n  (local' : Local.t) (ts ts' : Thread.t lang),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang)) ts ts') (IHSTEPS2 : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (state' : Language.state lang) \n  (local' : Local.t) (ts ts' : Thread.t lang),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang)) ts ts') : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (state' : Language.state lang) \n  (local' : Local.t) (ts ts' : Thread.t lang),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang)) ts ts'.","conclusion":"forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (state' : Language.state lang) \n  (local' : Local.t) (ts ts' : Thread.t lang),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang)) ts ts'","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (state' : Language.state lang) \n  (local' : Local.t) (ts ts' : Thread.t lang),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang)) ts ts') (IHSTEPS2 : forall (lang : language) (state : Language.state lang) \n  (local : Local.t) (state' : Language.state lang) \n  (local' : Local.t) (ts ts' : Thread.t lang),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local') ->\nts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang)) ts ts')","proofString":"ins.\nedestruct conf_steps_preserve_thread with (PC':=y); eauto.\ndesc.\nassert (x0 = lang); subst.\neapply conf_steps_preserve_lang; eauto.\netransitivity.\neapply IHSTEPS1; eauto.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'0 : Language.state lang0) \n  (local'0 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'0,\n   local'0) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts'0 =\n{|\n  Thread.state := state'0;\n  Thread.local := local'0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'0 : Language.state lang0) \n  (local'0 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'0,\n   local'0) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts'0 =\n{|\n  Thread.state := state'0;\n  Thread.local := local'0;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|}) : rtc (Thread.tau_step (lang:=lang)) ts ts'.","conclusion":"rtc (Thread.tau_step (lang:=lang)) ts ts'","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'0 : Language.state lang0) \n  (local'0 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'0,\n   local'0) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts'0 =\n{|\n  Thread.state := state'0;\n  Thread.local := local'0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'0 : Language.state lang0) \n  (local'0 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'0,\n   local'0) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts'0 =\n{|\n  Thread.state := state'0;\n  Thread.local := local'0;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|})","proofString":"edestruct conf_steps_preserve_thread with (PC':=y); eauto.\ndesc.\nassert (x0 = lang); subst.\neapply conf_steps_preserve_lang; eauto.\netransitivity.\neapply IHSTEPS1; eauto.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'0 : Language.state lang0) \n  (local'0 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'0,\n   local'0) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts'0 =\n{|\n  Thread.state := state'0;\n  Thread.local := local'0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'0 : Language.state lang0) \n  (local'0 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'0,\n   local'0) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts'0 =\n{|\n  Thread.state := state'0;\n  Thread.local := local'0;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|}) (x0 : language) (H : exists (state'0 : Language.state x0) (local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) x0 state'0,\n     local'0)) : rtc (Thread.tau_step (lang:=lang)) ts ts'.","conclusion":"rtc (Thread.tau_step (lang:=lang)) ts ts'","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'0 : Language.state lang0) \n  (local'0 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'0,\n   local'0) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts'0 =\n{|\n  Thread.state := state'0;\n  Thread.local := local'0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'0 : Language.state lang0) \n  (local'0 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'0,\n   local'0) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts'0 =\n{|\n  Thread.state := state'0;\n  Thread.local := local'0;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|}) (x0 : language) (H : exists (state'0 : Language.state x0) (local'0 : Local.t),\n  IdentMap.find tid (Configuration.threads y) =\n  Some\n    (existT (fun lang0 : language => Language.state lang0) x0 state'0,\n     local'0))","proofString":"desc.\nassert (x0 = lang); subst.\neapply conf_steps_preserve_lang; eauto.\netransitivity.\neapply IHSTEPS1; eauto.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts'0 =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts'0 =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|}) (x0 : language) (state'0 : Language.state x0) (local'0 : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) x0 state'0, local'0)) : rtc (Thread.tau_step (lang:=lang)) ts ts'.","conclusion":"rtc (Thread.tau_step (lang:=lang)) ts ts'","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts'0 =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts0 ts'0 : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts0 =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts'0 =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts0 ts'0) (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (ts ts' : Thread.t lang) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (TS : ts =\n{|\n  Thread.state := state;\n  Thread.local := local;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|}) (TS' : ts' =\n{|\n  Thread.state := state';\n  Thread.local := local';\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|}) (x0 : language) (state'0 : Language.state x0) (local'0 : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) x0 state'0, local'0))","proofString":"assert (x0 = lang); subst.\neapply conf_steps_preserve_lang; eauto.\netransitivity.\neapply IHSTEPS1; eauto.\neapply IHSTEPS2; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts') (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts' =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts') (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (x0 : language) (state'0 : Language.state x0) (local'0 : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) x0 state'0, local'0)) : x0 = lang.","conclusion":"x0 = lang","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts') (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts' =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts') (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (x0 : language) (state'0 : Language.state x0) (local'0 : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) x0 state'0, local'0))","proofString":"eapply conf_steps_preserve_lang; eauto."},{"statement":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts') (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts' =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts') (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (state'0 : Language.state lang) (local'0 : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state'0,\n   local'0)) : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := state;\n    Thread.local := local;\n    Thread.sc := Configuration.sc x;\n    Thread.memory := Configuration.memory x\n  |}\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := Configuration.sc z;\n    Thread.memory := Configuration.memory z\n  |}.","conclusion":"rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := state;\n    Thread.local := local;\n    Thread.sc := Configuration.sc x;\n    Thread.memory := Configuration.memory x\n  |}\n  {|\n    Thread.state := state';\n    Thread.local := local';\n    Thread.sc := Configuration.sc z;\n    Thread.memory := Configuration.memory z\n  |}","hypotheses":"(tid : Ident.t) (x y z : Configuration.t) (STEPS1 : (plain_step MachineEvent.silent tid)＊ x y) (STEPS2 : (plain_step MachineEvent.silent tid)＊ y z) (IHSTEPS1 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc x;\n  Thread.memory := Configuration.memory x\n|} ->\nts' =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts') (IHSTEPS2 : forall (lang0 : language) (state0 : Language.state lang0) \n  (local0 : Local.t) (state'1 : Language.state lang0) \n  (local'1 : Local.t) (ts ts' : Thread.t lang0),\nIdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state0, local0) ->\nIdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang1 : language => Language.state lang1) lang0 state'1,\n   local'1) ->\nts =\n{|\n  Thread.state := state0;\n  Thread.local := local0;\n  Thread.sc := Configuration.sc y;\n  Thread.memory := Configuration.memory y\n|} ->\nts' =\n{|\n  Thread.state := state'1;\n  Thread.local := local'1;\n  Thread.sc := Configuration.sc z;\n  Thread.memory := Configuration.memory z\n|} -> rtc (Thread.tau_step (lang:=lang0)) ts ts') (lang : language) (state : Language.state lang) (local : Local.t) (state' : Language.state lang) (local' : Local.t) (THREAD : IdentMap.find tid (Configuration.threads x) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state, local)) (THREAD' : IdentMap.find tid (Configuration.threads z) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state', local')) (state'0 : Language.state lang) (local'0 : Local.t) (H : IdentMap.find tid (Configuration.threads y) =\nSome\n  (existT (fun lang0 : language => Language.state lang0) lang state'0,\n   local'0))","proofString":"etransitivity.\neapply IHSTEPS1; eauto.\neapply IHSTEPS2; eauto."},{"statement":"(e : actid) (ACT : acts_set G e) (NINIT : ~ is_init e) : IdentMap.In (tid e) prog.","conclusion":"IdentMap.In (tid e) prog","hypotheses":"(e : actid) (ACT : acts_set G e) (NINIT : ~ is_init e)","proofString":"destruct PROG_EX as [HH OO].\ndestruct (HH e ACT) as [|AA]; [by desf|done]."},{"statement":"(e : actid) (ACT : acts_set G e) (NINIT : ~ is_init e) (HH : forall e0 : actid, acts_set G e0 -> is_init e0 \\/ IdentMap.In (tid e0) prog) (OO : forall (thread : IdentMap.key) (linstr : list Instr.t),\nSome linstr = IdentMap.find thread prog ->\nexists pe : execution,\n  thread_execution thread linstr pe /\\\n  thread_restricted_execution G thread pe) : IdentMap.In (tid e) prog.","conclusion":"IdentMap.In (tid e) prog","hypotheses":"(e : actid) (ACT : acts_set G e) (NINIT : ~ is_init e) (HH : forall e0 : actid, acts_set G e0 -> is_init e0 \\/ IdentMap.In (tid e0) prog) (OO : forall (thread : IdentMap.key) (linstr : list Instr.t),\nSome linstr = IdentMap.find thread prog ->\nexists pe : execution,\n  thread_execution thread linstr pe /\\\n  thread_restricted_execution G thread pe)","proofString":"destruct (HH e ACT) as [|AA]; [by desf|done]."},{"statement":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (IN : In (i, v) (IdentMap.elements (Configuration.threads PC))) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (map fst (IdentMap.elements (Configuration.threads PC)))\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x)\n     (map fst (IdentMap.elements (Configuration.threads PC')))) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x)\n     (map fst (IdentMap.elements (Configuration.threads PC)))).","conclusion":"length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x)\n     (map fst (IdentMap.elements (Configuration.threads PC')))) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x)\n     (map fst (IdentMap.elements (Configuration.threads PC))))","hypotheses":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (IN : In (i, v) (IdentMap.elements (Configuration.threads PC))) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (map fst (IdentMap.elements (Configuration.threads PC)))\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread')","proofString":"assert (L: forall l, length (filterP (fun x => ~ thread_is_terminal (Configuration.threads PC') x) l)          <= length (filterP (fun x => ~ thread_is_terminal (Configuration.threads PC) x) l)).\nclear - PTERMINAL; induction l; ins; desf; ins; eauto; try lia.\nexfalso; specialize (PTERMINAL a); tauto.\nrewrite SAMENUM.\napply in_split_perm in IN; desc; rewrite IN in SAMENUM; ins; rewrite <- SAMENUM; ins.\ndesf; ins.\nclear -L.\nspecialize (L (map fst l')).\nlia.\ndestruct v as ((lang,st),lc).\napply NNPP in n0.\napply n0 in FIND; ins."},{"statement":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (IN : In (i, v) (IdentMap.elements (Configuration.threads PC))) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (map fst (IdentMap.elements (Configuration.threads PC)))\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l).","conclusion":"forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)","hypotheses":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (IN : In (i, v) (IdentMap.elements (Configuration.threads PC))) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (map fst (IdentMap.elements (Configuration.threads PC)))\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread')","proofString":"clear - PTERMINAL; induction l; ins; desf; ins; eauto; try lia.\nexfalso; specialize (PTERMINAL a); tauto."},{"statement":"(PC PC' : Configuration.t) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (a : IdentMap.key) (l : list IdentMap.key) (IHl : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ thread_is_terminal (Configuration.threads PC') a) (n0 : ~ ~ thread_is_terminal (Configuration.threads PC) a) : S\n  (length\n     (filterP\n        (fun x : IdentMap.key =>\n         ~ thread_is_terminal (Configuration.threads PC') x) l)) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l).","conclusion":"S\n  (length\n     (filterP\n        (fun x : IdentMap.key =>\n         ~ thread_is_terminal (Configuration.threads PC') x) l)) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)","hypotheses":"(PC PC' : Configuration.t) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (a : IdentMap.key) (l : list IdentMap.key) (IHl : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ thread_is_terminal (Configuration.threads PC') a) (n0 : ~ ~ thread_is_terminal (Configuration.threads PC) a)","proofString":"exfalso; specialize (PTERMINAL a); tauto."},{"statement":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (IN : In (i, v) (IdentMap.elements (Configuration.threads PC))) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (map fst (IdentMap.elements (Configuration.threads PC)))\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x)\n     (map fst (IdentMap.elements (Configuration.threads PC')))) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x)\n     (map fst (IdentMap.elements (Configuration.threads PC)))).","conclusion":"length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x)\n     (map fst (IdentMap.elements (Configuration.threads PC')))) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x)\n     (map fst (IdentMap.elements (Configuration.threads PC))))","hypotheses":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (IN : In (i, v) (IdentMap.elements (Configuration.threads PC))) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (map fst (IdentMap.elements (Configuration.threads PC)))\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l))","proofString":"rewrite SAMENUM.\napply in_split_perm in IN; desc; rewrite IN in SAMENUM; ins; rewrite <- SAMENUM; ins.\ndesf; ins.\nclear -L.\nspecialize (L (map fst l')).\nlia.\ndestruct v as ((lang,st),lc).\napply NNPP in n0.\napply n0 in FIND; ins."},{"statement":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (IN : In (i, v) (IdentMap.elements (Configuration.threads PC))) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (map fst (IdentMap.elements (Configuration.threads PC)))\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x)\n     (map fst (IdentMap.elements (Configuration.threads PC')))) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x)\n     (map fst (IdentMap.elements (Configuration.threads PC')))).","conclusion":"length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x)\n     (map fst (IdentMap.elements (Configuration.threads PC')))) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x)\n     (map fst (IdentMap.elements (Configuration.threads PC'))))","hypotheses":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (IN : In (i, v) (IdentMap.elements (Configuration.threads PC))) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (map fst (IdentMap.elements (Configuration.threads PC)))\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l))","proofString":"apply in_split_perm in IN; desc; rewrite IN in SAMENUM; ins; rewrite <- SAMENUM; ins.\ndesf; ins.\nclear -L.\nspecialize (L (map fst l')).\nlia.\ndestruct v as ((lang,st),lc).\napply NNPP in n0.\napply n0 in FIND; ins."},{"statement":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (l' : list (IdentMap.Raw.key * ({lang : language & Language.state lang} * Local.t))) (IN : Permutation (IdentMap.elements (Configuration.threads PC)) ((i, v) :: l')) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (i :: map fst l')\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ ~ thread_is_terminal (Configuration.threads PC') i) (n0 : ~ thread_is_terminal (Configuration.threads PC) i) : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nS\n  (length\n     (filterP\n        (fun x : IdentMap.key =>\n         ~ thread_is_terminal (Configuration.threads PC) x) \n        (map fst l'))).","conclusion":"length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nS\n  (length\n     (filterP\n        (fun x : IdentMap.key =>\n         ~ thread_is_terminal (Configuration.threads PC) x) \n        (map fst l')))","hypotheses":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (l' : list (IdentMap.Raw.key * ({lang : language & Language.state lang} * Local.t))) (IN : Permutation (IdentMap.elements (Configuration.threads PC)) ((i, v) :: l')) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (i :: map fst l')\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ ~ thread_is_terminal (Configuration.threads PC') i) (n0 : ~ thread_is_terminal (Configuration.threads PC) i)","proofString":"clear -L.\nspecialize (L (map fst l')).\nlia."},{"statement":"(PC : Configuration.t) (l' : list (IdentMap.Raw.key * ({lang : language & Language.state lang} * Local.t))) (PC' : Configuration.t) (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nS\n  (length\n     (filterP\n        (fun x : IdentMap.key =>\n         ~ thread_is_terminal (Configuration.threads PC) x) \n        (map fst l'))).","conclusion":"length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nS\n  (length\n     (filterP\n        (fun x : IdentMap.key =>\n         ~ thread_is_terminal (Configuration.threads PC) x) \n        (map fst l')))","hypotheses":"(PC : Configuration.t) (l' : list (IdentMap.Raw.key * ({lang : language & Language.state lang} * Local.t))) (PC' : Configuration.t) (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l))","proofString":"specialize (L (map fst l')).\nlia."},{"statement":"(PC : Configuration.t) (l' : list (IdentMap.Raw.key * ({lang : language & Language.state lang} * Local.t))) (PC' : Configuration.t) (L : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) \n     (map fst l'))) : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nS\n  (length\n     (filterP\n        (fun x : IdentMap.key =>\n         ~ thread_is_terminal (Configuration.threads PC) x) \n        (map fst l'))).","conclusion":"length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nS\n  (length\n     (filterP\n        (fun x : IdentMap.key =>\n         ~ thread_is_terminal (Configuration.threads PC) x) \n        (map fst l')))","hypotheses":"(PC : Configuration.t) (l' : list (IdentMap.Raw.key * ({lang : language & Language.state lang} * Local.t))) (PC' : Configuration.t) (L : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) \n     (map fst l')))","proofString":"lia."},{"statement":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (l' : list (IdentMap.Raw.key * ({lang : language & Language.state lang} * Local.t))) (IN : Permutation (IdentMap.elements (Configuration.threads PC)) ((i, v) :: l')) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (i :: map fst l')\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ ~ thread_is_terminal (Configuration.threads PC') i) (n0 : ~ ~ thread_is_terminal (Configuration.threads PC) i) : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) \n     (map fst l')).","conclusion":"length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) \n     (map fst l'))","hypotheses":"(PC : Configuration.t) (i : IdentMap.Raw.key) (v : {lang : language & Language.state lang} * Local.t) (FIND : IdentMap.find i (Configuration.threads PC) = Some v) (Y : ~\n(Language.is_terminal (projT1 (fst v)) (projT2 (fst v)) /\\\n Local.is_terminal (snd v))) (l' : list (IdentMap.Raw.key * ({lang : language & Language.state lang} * Local.t))) (IN : Permutation (IdentMap.elements (Configuration.threads PC)) ((i, v) :: l')) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (i :: map fst l')\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ ~ thread_is_terminal (Configuration.threads PC') i) (n0 : ~ ~ thread_is_terminal (Configuration.threads PC) i)","proofString":"destruct v as ((lang,st),lc).\napply NNPP in n0.\napply n0 in FIND; ins."},{"statement":"(PC : Configuration.t) (i : IdentMap.Raw.key) (lang : language) (st : Language.state lang) (lc : Local.t) (FIND : IdentMap.find i (Configuration.threads PC) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st, lc)) (Y : ~\n(Language.is_terminal\n   (projT1\n      (fst\n         (existT (fun lang0 : language => Language.state lang0) lang st, lc)))\n   (projT2\n      (fst\n         (existT (fun lang0 : language => Language.state lang0) lang st, lc))) /\\\n Local.is_terminal\n   (snd (existT (fun lang0 : language => Language.state lang0) lang st, lc)))) (l' : list\n  (IdentMap.Raw.key * ({lang0 : language & Language.state lang0} * Local.t))) (IN : Permutation (IdentMap.elements (Configuration.threads PC))\n  ((i, (existT (fun lang0 : language => Language.state lang0) lang st, lc))\n   :: l')) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (i :: map fst l')\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ ~ thread_is_terminal (Configuration.threads PC') i) (n0 : ~ ~ thread_is_terminal (Configuration.threads PC) i) : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) \n     (map fst l')).","conclusion":"length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) \n     (map fst l'))","hypotheses":"(PC : Configuration.t) (i : IdentMap.Raw.key) (lang : language) (st : Language.state lang) (lc : Local.t) (FIND : IdentMap.find i (Configuration.threads PC) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st, lc)) (Y : ~\n(Language.is_terminal\n   (projT1\n      (fst\n         (existT (fun lang0 : language => Language.state lang0) lang st, lc)))\n   (projT2\n      (fst\n         (existT (fun lang0 : language => Language.state lang0) lang st, lc))) /\\\n Local.is_terminal\n   (snd (existT (fun lang0 : language => Language.state lang0) lang st, lc)))) (l' : list\n  (IdentMap.Raw.key * ({lang0 : language & Language.state lang0} * Local.t))) (IN : Permutation (IdentMap.elements (Configuration.threads PC))\n  ((i, (existT (fun lang0 : language => Language.state lang0) lang st, lc))\n   :: l')) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (i :: map fst l')\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ ~ thread_is_terminal (Configuration.threads PC') i) (n0 : ~ ~ thread_is_terminal (Configuration.threads PC) i)","proofString":"apply NNPP in n0.\napply n0 in FIND; ins."},{"statement":"(PC : Configuration.t) (i : IdentMap.Raw.key) (lang : language) (st : Language.state lang) (lc : Local.t) (FIND : IdentMap.find i (Configuration.threads PC) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st, lc)) (Y : ~\n(Language.is_terminal\n   (projT1\n      (fst\n         (existT (fun lang0 : language => Language.state lang0) lang st, lc)))\n   (projT2\n      (fst\n         (existT (fun lang0 : language => Language.state lang0) lang st, lc))) /\\\n Local.is_terminal\n   (snd (existT (fun lang0 : language => Language.state lang0) lang st, lc)))) (l' : list\n  (IdentMap.Raw.key * ({lang0 : language & Language.state lang0} * Local.t))) (IN : Permutation (IdentMap.elements (Configuration.threads PC))\n  ((i, (existT (fun lang0 : language => Language.state lang0) lang st, lc))\n   :: l')) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (i :: map fst l')\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ ~ thread_is_terminal (Configuration.threads PC') i) (n0 : thread_is_terminal (Configuration.threads PC) i) : length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) \n     (map fst l')).","conclusion":"length\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) \n     (map fst l')) <\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) \n     (map fst l'))","hypotheses":"(PC : Configuration.t) (i : IdentMap.Raw.key) (lang : language) (st : Language.state lang) (lc : Local.t) (FIND : IdentMap.find i (Configuration.threads PC) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st, lc)) (Y : ~\n(Language.is_terminal\n   (projT1\n      (fst\n         (existT (fun lang0 : language => Language.state lang0) lang st, lc)))\n   (projT2\n      (fst\n         (existT (fun lang0 : language => Language.state lang0) lang st, lc))) /\\\n Local.is_terminal\n   (snd (existT (fun lang0 : language => Language.state lang0) lang st, lc)))) (l' : list\n  (IdentMap.Raw.key * ({lang0 : language & Language.state lang0} * Local.t))) (IN : Permutation (IdentMap.elements (Configuration.threads PC))\n  ((i, (existT (fun lang0 : language => Language.state lang0) lang st, lc))\n   :: l')) (PC' : Configuration.t) (STEP : conf_step^? PC PC') (SAMENUM : Permutation (i :: map fst l')\n  (map fst (IdentMap.elements (Configuration.threads PC')))) (TERMINAL : thread_is_terminal (Configuration.threads PC') i) (PTERMINAL : forall thread' : IdentMap.key,\nthread_is_terminal (Configuration.threads PC) thread' ->\nthread_is_terminal (Configuration.threads PC') thread') (L : forall l : list IdentMap.key,\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC') x) l) <=\nlength\n  (filterP\n     (fun x : IdentMap.key =>\n      ~ thread_is_terminal (Configuration.threads PC) x) l)) (n : ~ ~ thread_is_terminal (Configuration.threads PC') i) (n0 : thread_is_terminal (Configuration.threads PC) i)","proofString":"apply n0 in FIND; ins."},{"statement":"(etc : trav_label -> Prop) (w : actid) (TCOH : tls_coherent G etc) (RCOH : reserve_coherent G etc) (IORDCOH : iord_coherent G sc etc) (RES : reserved etc ⊆₁ issued etc ∪₁ eq w) (w_ex_is_xacq : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (ISS'w : issuable G sc etc w) : reserved etc ∪₁ eq w\n⊆₁ reserved etc ∪₁ eq w ∪₁ dom_sb_S_rfrmw G etc (rfi G) (eq w).","conclusion":"reserved etc ∪₁ eq w\n⊆₁ reserved etc ∪₁ eq w ∪₁ dom_sb_S_rfrmw G etc (rfi G) (eq w)","hypotheses":"(etc : trav_label -> Prop) (w : actid) (TCOH : tls_coherent G etc) (RCOH : reserve_coherent G etc) (IORDCOH : iord_coherent G sc etc) (RES : reserved etc ⊆₁ issued etc ∪₁ eq w) (w_ex_is_xacq : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (ISS'w : issuable G sc etc w)","proofString":"basic_solver."},{"statement":"(etc : trav_label -> Prop) (w : actid) (TCOH : tls_coherent G etc) (RCOH : reserve_coherent G etc) (IORDCOH : iord_coherent G sc etc) (RES : reserved etc ⊆₁ issued etc ∪₁ eq w) (w_ex_is_xacq : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (ISS'w : issuable G sc etc w) : issued etc ∪₁ eq w ∪₁ eq w ∪₁ dom_sb_S_rfrmw G etc (rfi G) (eq w)\n⊆₁ issued etc ∪₁ eq w.","conclusion":"issued etc ∪₁ eq w ∪₁ eq w ∪₁ dom_sb_S_rfrmw G etc (rfi G) (eq w)\n⊆₁ issued etc ∪₁ eq w","hypotheses":"(etc : trav_label -> Prop) (w : actid) (TCOH : tls_coherent G etc) (RCOH : reserve_coherent G etc) (IORDCOH : iord_coherent G sc etc) (RES : reserved etc ⊆₁ issued etc ∪₁ eq w) (w_ex_is_xacq : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (ISS'w : issuable G sc etc w)","proofString":"rewrite dom_sb_S_rfrmw_issuable; auto.\nbasic_solver.\nrewrite RES.\napply set_subset_union_l.\nsplit; [| basic_solver].\napply issued_in_issuable; auto."},{"statement":"(etc : trav_label -> Prop) (w : actid) (TCOH : tls_coherent G etc) (RCOH : reserve_coherent G etc) (IORDCOH : iord_coherent G sc etc) (RES : reserved etc ⊆₁ issued etc ∪₁ eq w) (w_ex_is_xacq : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (ISS'w : issuable G sc etc w) : issued etc ∪₁ eq w ∪₁ eq w ∪₁ issued etc ⊆₁ issued etc ∪₁ eq w.","conclusion":"issued etc ∪₁ eq w ∪₁ eq w ∪₁ issued etc ⊆₁ issued etc ∪₁ eq w","hypotheses":"(etc : trav_label -> Prop) (w : actid) (TCOH : tls_coherent G etc) (RCOH : reserve_coherent G etc) (IORDCOH : iord_coherent G sc etc) (RES : reserved etc ⊆₁ issued etc ∪₁ eq w) (w_ex_is_xacq : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (ISS'w : issuable G sc etc w)","proofString":"basic_solver."},{"statement":"(etc : trav_label -> Prop) (w : actid) (TCOH : tls_coherent G etc) (RCOH : reserve_coherent G etc) (IORDCOH : iord_coherent G sc etc) (RES : reserved etc ⊆₁ issued etc ∪₁ eq w) (w_ex_is_xacq : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (ISS'w : issuable G sc etc w) : issued etc ⊆₁ issuable G sc etc.","conclusion":"issued etc ⊆₁ issuable G sc etc","hypotheses":"(etc : trav_label -> Prop) (w : actid) (TCOH : tls_coherent G etc) (RCOH : reserve_coherent G etc) (IORDCOH : iord_coherent G sc etc) (RES : reserved etc ⊆₁ issued etc ∪₁ eq w) (w_ex_is_xacq : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (ISS'w : issuable G sc etc w)","proofString":"apply issued_in_issuable; auto."}]}