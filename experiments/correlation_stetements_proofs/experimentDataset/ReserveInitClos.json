[{"statement":"Lemma reserve_init_clos_union a b :\n  reserve_init_clos (a ∪₁ b) ≡₁ reserve_init_clos a ∪₁ reserve_init_clos b.","proof":"clear.\nunfold reserve_init_clos.\nbasic_solver 10.\n"},{"statement":"Lemma reserve_init_clos_init_tls : reserve_init_clos (init_tls G) ≡₁ init_tls G.","proof":"clear.\nunfold reserve_init_clos, init_tls.\nrewrite !set_pair_union_l, !set_minus_union_l.\nsplit; unionL.\nall: try basic_solver.\n{\ndo 4 unionR left.\nunfold set_pair.\nunfolder.\nins.\ndo 2 desf.\n}\n{\ndo 3 unionR left.\nunfold set_pair.\nunfolder.\nins.\ndo 2 desf.\nright.\nsplits; eauto.\nintros HH; inv HH.\n}\nunionR left -> right.\nunfold set_pair, is_ta_propagate_to_G.\nunfolder.\nins.\ndo 2 desf.\nsplits; eauto.\nintros HH; inv HH.\n"},{"statement":"Lemma reserve_init_clos_tls_coherent\n  tc (TCOH : tls_coherent G tc) :\n  tls_coherent G (reserve_init_clos tc).","proof":"destruct TCOH as [AA BB].\nunfold reserve_init_clos.\nconstructor.\n{\nrewrite <- AA.\nunfold init_tls.\nclear.\nrewrite !set_pair_union_l.\nunfold set_pair, is_ta_propagate_to_G.\nunfolder.\nins.\ndesf; desf; ins; eauto 10.\nall: now left; split; [|intros HH; inv HH]; eauto 20.\n}\nunionL.\n{\ntransitivity tc; eauto with hahn.\nbasic_solver.\n}\nunionR left.\nunfold init_tls.\nrewrite !set_pair_union_l.\neauto with hahn.\n"},{"statement":"Lemma reserve_init_clos_sim_coherent\n  tc (SCOH : sim_coherent G tc) :\n  sim_coherent G (reserve_init_clos tc).","proof":"unfold reserve_init_clos.\nred.\nsplit.\n{\nunfold sim_clos.\neauto with hahn.\n}\nunfold sim_clos.\napply set_subset_union_l; split.\napply set_subset_union_l; split; eauto with hahn.\nall: unionR left.\nall: rewrite set_minusE at 2.\nall: apply set_subset_inter_r; split.\nall: try now (unfold rmw_clos, rel_clos, set_pair; unfolder; ins; do 2 desf).\nall: transitivity (sim_clos G tc); try now apply SCOH.\nall: unfold sim_clos.\n1: transitivity (rmw_clos G tc); eauto with hahn.\n2: transitivity (rel_clos G tc); eauto with hahn.\nall: unfold rmw_clos, rel_clos.\nall: apply set_pair_mori; eauto with hahn.\nall: autorewrite with cir_simplify.\nall: clear; basic_solver.\n"},{"statement":"Lemma reserve_init_clos_sim_clos_step_rt :\n  sim_clos_step G sc ⊆ reserve_init_clos ↓ (sim_clos_step G sc)^?.","proof":"clear.\nintros tc tc' STEP.\nred.\nclear -STEP.\ndestruct STEP as [[tll STEP] [SCOH SCOH']].\nunfold reserve_init_clos.\neapply isim_clos_step_fixed_reserve in STEP.\n{\ndestruct STEP as [EQ|STEP]; [now left; apply EQ|right].\nsplit.\n2: now split; apply reserve_init_clos_sim_coherent.\nexists tll; auto.\n}\nunfold set_pair.\nunfolder.\nins.\ndo 2 desf.\n"},{"statement":"Lemma reserve_init_clos_sim_clos_steps_rt :\n  (sim_clos_step G sc)^* ⊆ reserve_init_clos ↓ (sim_clos_step G sc)^*.","proof":"clear.\nrewrite reserve_init_clos_sim_clos_step_rt at 1.\nrewrite map_rel_crt.\nnow rewrite rt_of_cr.\n"}]