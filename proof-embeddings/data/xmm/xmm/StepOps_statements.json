{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/xmm/StepOps.v","fileSamples":[{"statement":"(m : actid -> actid) (INIT : fixset (fun a : actid => is_init a) m) (TID : m ↑₁ (E ∩₁ same_tid e) ≡₁ m ↑₁ E ∩₁ same_tid (m e)) : m ↑ ((fun a : actid => is_init a) ∪₁ E ∩₁ same_tid e) × eq e\n≡ ((fun a : actid => is_init a) ∪₁ m ↑₁ E ∩₁ same_tid (m e)) × eq (m e).","proofString":"rewrite !collect_rel_cross, set_collect_union,          set_collect_eq, TID, <- (fixset_set_fixpoint INIT).\nins."},{"statement":"(m : actid -> actid) (INIT : fixset (fun a : actid => is_init a) m) (TID : m ↑₁ (E ∩₁ same_tid e) ≡₁ m ↑₁ E ∩₁ same_tid (m e)) : ((fun a : actid => is_init a) ∪₁ m ↑₁ E ∩₁ same_tid (m e)) × eq (m e)\n≡ ((fun a : actid => is_init a) ∪₁ m ↑₁ E ∩₁ same_tid (m e)) × eq (m e).","proofString":"ins."},{"statement":"(m : actid -> actid) (w : option actid) : m ↑ eq_opt w × eq e ≡ eq_opt (option_map m w) × eq (m e).","proofString":"rewrite collect_rel_cross, set_collect_eq_opt.\napply cross_more; ins.\nunfold WCore.lab_is_r.\nbasic_solver."},{"statement":"(m : actid -> actid) (w : option actid) : eq_opt (option_map m w) × (m ↑₁ eq e) ≡ eq_opt (option_map m w) × eq (m e).","proofString":"apply cross_more; ins.\nunfold WCore.lab_is_r.\nbasic_solver."},{"statement":"(m : actid -> actid) (w : option actid) : m ↑₁ eq e ≡₁ eq (m e).","proofString":"unfold WCore.lab_is_r.\nbasic_solver."},{"statement":"(m : actid -> actid) (w : option actid) : m ↑₁ eq e ≡₁ eq (m e).","proofString":"basic_solver."},{"statement":"(m : actid -> actid) (R1 : actid -> Prop) : m ↑ eq e × R1 ≡ eq (m e) × (m ↑₁ R1).","proofString":"rewrite collect_rel_cross.\napply cross_more; ins.\nunfold WCore.lab_is_w.\nbasic_solver."},{"statement":"(m : actid -> actid) (R1 : actid -> Prop) : (m ↑₁ eq e) × (m ↑₁ R1) ≡ eq (m e) × (m ↑₁ R1).","proofString":"apply cross_more; ins.\nunfold WCore.lab_is_w.\nbasic_solver."},{"statement":"(m : actid -> actid) (R1 : actid -> Prop) : m ↑₁ eq e ≡₁ eq (m e).","proofString":"unfold WCore.lab_is_w.\nbasic_solver."},{"statement":"(m : actid -> actid) (R1 : actid -> Prop) : m ↑₁ eq e ≡₁ eq (m e).","proofString":"basic_solver."},{"statement":"(m : actid -> actid) (r : option actid) : m ↑ eq_opt r × eq e ≡ eq_opt (option_map m r) × eq (m e).","proofString":"rewrite collect_rel_cross, set_collect_eq_opt.\napply cross_more; ins.\nunfold WCore.lab_is_w.\nbasic_solver."},{"statement":"(m : actid -> actid) (r : option actid) : eq_opt (option_map m r) × (m ↑₁ eq e) ≡ eq_opt (option_map m r) × eq (m e).","proofString":"apply cross_more; ins.\nunfold WCore.lab_is_w.\nbasic_solver."},{"statement":"(m : actid -> actid) (r : option actid) : m ↑₁ eq e ≡₁ eq (m e).","proofString":"unfold WCore.lab_is_w.\nbasic_solver."},{"statement":"(m : actid -> actid) (r : option actid) : m ↑₁ eq e ≡₁ eq (m e).","proofString":"basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : sb ⨾ ⦗eq e⦘ ∪ WCore.sb_delta e E ⨾ ⦗eq e⦘ ≡ WCore.sb_delta e E.","proofString":"arewrite (sb ⨾ ⦗eq e⦘ ≡ ∅₂); [| basic_solver 11].\nunfold sb.\nenough (~E e) by basic_solver.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : sb ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"unfold sb.\nenough (~E e) by basic_solver.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘) ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"enough (~E e) by basic_solver.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ~ E e.","proofString":"apply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ sb' ⨾ ⦗eq e⦘.","proofString":"unfold sb.\nrewrite !seqA, (WCore.add_event_acts ADD).\narewrite (⦗E ∪₁ eq e⦘ ⨾ ⦗eq e⦘ ≡ ⦗eq e⦘).\nenough (NIN : ~E e) by basic_solver.\napply ADD.\nrewrite id_union, !seq_union_l.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nunfolder.\nins.\ndesf.\neapply ext_sb_irr; eauto.\nnow rewrite union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗eq e⦘.","proofString":"rewrite !seqA, (WCore.add_event_acts ADD).\narewrite (⦗E ∪₁ eq e⦘ ⨾ ⦗eq e⦘ ≡ ⦗eq e⦘).\nenough (NIN : ~E e) by basic_solver.\napply ADD.\nrewrite id_union, !seq_union_l.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nunfolder.\nins.\ndesf.\neapply ext_sb_irr; eauto.\nnow rewrite union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘ ⨾ ⦗eq e⦘.","proofString":"arewrite (⦗E ∪₁ eq e⦘ ⨾ ⦗eq e⦘ ≡ ⦗eq e⦘).\nenough (NIN : ~E e) by basic_solver.\napply ADD.\nrewrite id_union, !seq_union_l.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nunfolder.\nins.\ndesf.\neapply ext_sb_irr; eauto.\nnow rewrite union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗E ∪₁ eq e⦘ ⨾ ⦗eq e⦘ ≡ ⦗eq e⦘.","proofString":"enough (NIN : ~E e) by basic_solver.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ~ E e.","proofString":"apply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘.","proofString":"rewrite id_union, !seq_union_l.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nunfolder.\nins.\ndesf.\neapply ext_sb_irr; eauto.\nnow rewrite union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ ⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ∪ ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘.","proofString":"arewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nunfolder.\nins.\ndesf.\neapply ext_sb_irr; eauto.\nnow rewrite union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ⊆ ∅₂.","proofString":"unfolder.\nins.\ndesf.\neapply ext_sb_irr; eauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : forall x y : actid, e = x /\\ ext_sb x y /\\ e = y -> False.","proofString":"ins.\ndesf.\neapply ext_sb_irr; eauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (x y : actid) (H : e = x /\\ ext_sb x y /\\ e = y) : False.","proofString":"desf.\neapply ext_sb_irr; eauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (y : actid) (H0 : ext_sb y y) (ADD : WCore.add_event_gen X X' y l r R1 w W1 W2) : False.","proofString":"eapply ext_sb_irr; eauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ ⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ∪ ∅₂.","proofString":"now rewrite union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗E⦘ ≡ ⦗eq e⦘ ⨾ sb' ⨾ ⦗E⦘.","proofString":"unfold sb.\nrewrite (WCore.add_event_acts ADD).\nenough (NIN : ~E e) by basic_solver 11.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗E⦘ ≡ ⦗eq e⦘ ⨾ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗E⦘.","proofString":"rewrite (WCore.add_event_acts ADD).\nenough (NIN : ~E e) by basic_solver 11.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗E⦘ ≡ ⦗eq e⦘ ⨾ (⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘) ⨾ ⦗E⦘.","proofString":"enough (NIN : ~E e) by basic_solver 11.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ~ E e.","proofString":"apply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗eq e⦘ ⨾ sb' ⨾ ⦗E⦘ ≡ ∅₂.","proofString":"rewrite (WCore.add_event_sb ADD).\nunfold sb.\nenough (NIN : ~E e) by basic_solver 11.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗eq e⦘ ⨾ (sb ∪ WCore.sb_delta e E) ⨾ ⦗E⦘ ≡ ∅₂.","proofString":"unfold sb.\nenough (NIN : ~E e) by basic_solver 11.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ⦗eq e⦘ ⨾ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ∪ WCore.sb_delta e E) ⨾ ⦗E⦘ ≡ ∅₂.","proofString":"enough (NIN : ~E e) by basic_solver 11.\napply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : ~ E e.","proofString":"apply ADD."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : rf' ⨾ ⦗eq e⦘ ≡ WCore.rf_delta_R e w.","proofString":"rewrite (WCore.add_event_rf ADD), !seq_union_l.\narewrite (rf ⨾ ⦗eq e⦘ ≡ ∅₂).\nrewrite (wf_rfE WF).\nbasic_solver.\narewrite (WCore.rf_delta_W e R1 ⨾ ⦗eq e⦘ ≡ ∅₂); [| basic_solver 11].\nunfold WCore.rf_delta_W.\nrewrite <- cross_inter_r.\nenough (~ R1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_R1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : rf ⨾ ⦗eq e⦘ ∪ WCore.rf_delta_R e w ⨾ ⦗eq e⦘ ∪ WCore.rf_delta_W e R1 ⨾ ⦗eq e⦘\n≡ WCore.rf_delta_R e w.","proofString":"arewrite (rf ⨾ ⦗eq e⦘ ≡ ∅₂).\nrewrite (wf_rfE WF).\nbasic_solver.\narewrite (WCore.rf_delta_W e R1 ⨾ ⦗eq e⦘ ≡ ∅₂); [| basic_solver 11].\nunfold WCore.rf_delta_W.\nrewrite <- cross_inter_r.\nenough (~ R1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_R1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : rf ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"rewrite (wf_rfE WF).\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : (⦗E⦘ ⨾ rf ⨾ ⦗E⦘) ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ∅₂ ∪ WCore.rf_delta_R e w ⨾ ⦗eq e⦘ ∪ WCore.rf_delta_W e R1 ⨾ ⦗eq e⦘\n≡ WCore.rf_delta_R e w.","proofString":"arewrite (WCore.rf_delta_W e R1 ⨾ ⦗eq e⦘ ≡ ∅₂); [| basic_solver 11].\nunfold WCore.rf_delta_W.\nrewrite <- cross_inter_r.\nenough (~ R1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_R1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : WCore.rf_delta_W e R1 ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"unfold WCore.rf_delta_W.\nrewrite <- cross_inter_r.\nenough (~ R1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_R1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : eq e × R1 ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"rewrite <- cross_inter_r.\nenough (~ R1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_R1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : eq e × (R1 ∩₁ eq e) ≡ ∅₂.","proofString":"enough (~ R1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_R1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ~ R1 e.","proofString":"intro FALSO.\nnow apply (WCore.add_event_R1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) (FALSO : R1 e) : False.","proofString":"now apply (WCore.add_event_R1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ rf' ≡ WCore.rf_delta_W e R1.","proofString":"rewrite (WCore.add_event_rf ADD), !seq_union_r.\narewrite (⦗eq e⦘ ⨾ rf ≡ ∅₂).\nrewrite (wf_rfE WF).\nbasic_solver.\narewrite (⦗eq e⦘ ⨾ WCore.rf_delta_R e w ≡ ∅₂); [| basic_solver 11].\nunfold WCore.rf_delta_R.\nrewrite <- cross_inter_l.\nenough (~ eq_opt w e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_wE ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ rf ∪ ⦗eq e⦘ ⨾ WCore.rf_delta_R e w ∪ ⦗eq e⦘ ⨾ WCore.rf_delta_W e R1\n≡ WCore.rf_delta_W e R1.","proofString":"arewrite (⦗eq e⦘ ⨾ rf ≡ ∅₂).\nrewrite (wf_rfE WF).\nbasic_solver.\narewrite (⦗eq e⦘ ⨾ WCore.rf_delta_R e w ≡ ∅₂); [| basic_solver 11].\nunfold WCore.rf_delta_R.\nrewrite <- cross_inter_l.\nenough (~ eq_opt w e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_wE ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ rf ≡ ∅₂.","proofString":"rewrite (wf_rfE WF).\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ ⦗E⦘ ⨾ rf ⨾ ⦗E⦘ ≡ ∅₂.","proofString":"basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ∅₂ ∪ ⦗eq e⦘ ⨾ WCore.rf_delta_R e w ∪ ⦗eq e⦘ ⨾ WCore.rf_delta_W e R1\n≡ WCore.rf_delta_W e R1.","proofString":"arewrite (⦗eq e⦘ ⨾ WCore.rf_delta_R e w ≡ ∅₂); [| basic_solver 11].\nunfold WCore.rf_delta_R.\nrewrite <- cross_inter_l.\nenough (~ eq_opt w e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_wE ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ WCore.rf_delta_R e w ≡ ∅₂.","proofString":"unfold WCore.rf_delta_R.\nrewrite <- cross_inter_l.\nenough (~ eq_opt w e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_wE ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ eq_opt w × eq e ≡ ∅₂.","proofString":"rewrite <- cross_inter_l.\nenough (~ eq_opt w e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_wE ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : (eq e ∩₁ eq_opt w) × eq e ≡ ∅₂.","proofString":"enough (~ eq_opt w e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_wE ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ~ eq_opt w e.","proofString":"intro FALSO.\nnow apply (WCore.add_event_wE ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) (FALSO : eq_opt w e) : False.","proofString":"now apply (WCore.add_event_wE ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ co' ≡ eq e × W1.","proofString":"rewrite (WCore.add_event_co ADD), !seq_union_r.\narewrite (⦗eq e⦘ ⨾ co ≡ ∅₂).\nrewrite (wf_coE WF).\nbasic_solver.\nunfold WCore.co_delta.\nrewrite seq_union_r.\narewrite (⦗eq e⦘ ⨾ W2 × eq e ≡ ∅₂); [| clear; basic_solver 11].\nenough (~ W2 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W2E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ co ∪ ⦗eq e⦘ ⨾ WCore.co_delta e W1 W2 ≡ eq e × W1.","proofString":"arewrite (⦗eq e⦘ ⨾ co ≡ ∅₂).\nrewrite (wf_coE WF).\nbasic_solver.\nunfold WCore.co_delta.\nrewrite seq_union_r.\narewrite (⦗eq e⦘ ⨾ W2 × eq e ≡ ∅₂); [| clear; basic_solver 11].\nenough (~ W2 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W2E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ co ≡ ∅₂.","proofString":"rewrite (wf_coE WF).\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ ⦗E⦘ ⨾ co ⨾ ⦗E⦘ ≡ ∅₂.","proofString":"basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ∅₂ ∪ ⦗eq e⦘ ⨾ WCore.co_delta e W1 W2 ≡ eq e × W1.","proofString":"unfold WCore.co_delta.\nrewrite seq_union_r.\narewrite (⦗eq e⦘ ⨾ W2 × eq e ≡ ∅₂); [| clear; basic_solver 11].\nenough (~ W2 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W2E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ∅₂ ∪ ⦗eq e⦘ ⨾ (eq e × W1 ∪ W2 × eq e) ≡ eq e × W1.","proofString":"rewrite seq_union_r.\narewrite (⦗eq e⦘ ⨾ W2 × eq e ≡ ∅₂); [| clear; basic_solver 11].\nenough (~ W2 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W2E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ∅₂ ∪ (⦗eq e⦘ ⨾ eq e × W1 ∪ ⦗eq e⦘ ⨾ W2 × eq e) ≡ eq e × W1.","proofString":"arewrite (⦗eq e⦘ ⨾ W2 × eq e ≡ ∅₂); [| clear; basic_solver 11].\nenough (~ W2 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W2E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ⦗eq e⦘ ⨾ W2 × eq e ≡ ∅₂.","proofString":"enough (~ W2 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W2E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ~ W2 e.","proofString":"intro FALSO.\nnow apply (WCore.add_event_W2E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) (FALSO : W2 e) : False.","proofString":"now apply (WCore.add_event_W2E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : co' ⨾ ⦗eq e⦘ ≡ W2 × eq e.","proofString":"rewrite (WCore.add_event_co ADD), !seq_union_l.\narewrite (co ⨾ ⦗eq e⦘ ≡ ∅₂).\nrewrite (wf_coE WF).\nbasic_solver.\nunfold WCore.co_delta.\nrewrite seq_union_l.\narewrite (eq e × W1 ⨾ ⦗eq e⦘  ≡ ∅₂); [| clear; basic_solver 7].\nenough (~ W1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : co ⨾ ⦗eq e⦘ ∪ WCore.co_delta e W1 W2 ⨾ ⦗eq e⦘ ≡ W2 × eq e.","proofString":"arewrite (co ⨾ ⦗eq e⦘ ≡ ∅₂).\nrewrite (wf_coE WF).\nbasic_solver.\nunfold WCore.co_delta.\nrewrite seq_union_l.\narewrite (eq e × W1 ⨾ ⦗eq e⦘  ≡ ∅₂); [| clear; basic_solver 7].\nenough (~ W1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : co ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"rewrite (wf_coE WF).\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : (⦗E⦘ ⨾ co ⨾ ⦗E⦘) ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ∅₂ ∪ WCore.co_delta e W1 W2 ⨾ ⦗eq e⦘ ≡ W2 × eq e.","proofString":"unfold WCore.co_delta.\nrewrite seq_union_l.\narewrite (eq e × W1 ⨾ ⦗eq e⦘  ≡ ∅₂); [| clear; basic_solver 7].\nenough (~ W1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ∅₂ ∪ (eq e × W1 ∪ W2 × eq e) ⨾ ⦗eq e⦘ ≡ W2 × eq e.","proofString":"rewrite seq_union_l.\narewrite (eq e × W1 ⨾ ⦗eq e⦘  ≡ ∅₂); [| clear; basic_solver 7].\nenough (~ W1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ∅₂ ∪ (eq e × W1 ⨾ ⦗eq e⦘ ∪ W2 × eq e ⨾ ⦗eq e⦘) ≡ W2 × eq e.","proofString":"arewrite (eq e × W1 ⨾ ⦗eq e⦘  ≡ ∅₂); [| clear; basic_solver 7].\nenough (~ W1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : eq e × W1 ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"enough (~ W1 e) by basic_solver.\nintro FALSO.\nnow apply (WCore.add_event_W1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ~ W1 e.","proofString":"intro FALSO.\nnow apply (WCore.add_event_W1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) (FALSO : W1 e) : False.","proofString":"now apply (WCore.add_event_W1E ADD) in FALSO."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : eq e × W1 ∪ W2 × eq e ≡ WCore.co_delta e W1 W2.","proofString":"unfold WCore.co_delta.\nreflexivity."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) : eq e × W1 ∪ W2 × eq e ≡ eq e × W1 ∪ W2 × eq e.","proofString":"reflexivity."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : rmw' ⨾ ⦗eq e⦘ ≡ WCore.rmw_delta e r.","proofString":"rewrite (WCore.add_event_rmw ADD), !seq_union_l.\narewrite (rmw ⨾ ⦗eq e⦘ ≡ ∅₂).\nrewrite (wf_rmwE WF).\nbasic_solver.\nclear; basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : rmw ⨾ ⦗eq e⦘ ∪ WCore.rmw_delta e r ⨾ ⦗eq e⦘ ≡ WCore.rmw_delta e r.","proofString":"arewrite (rmw ⨾ ⦗eq e⦘ ≡ ∅₂).\nrewrite (wf_rmwE WF).\nbasic_solver.\nclear; basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : rmw ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"rewrite (wf_rmwE WF).\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : (⦗E⦘ ⨾ rmw ⨾ ⦗E⦘) ⨾ ⦗eq e⦘ ≡ ∅₂.","proofString":"basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (WF : Wf G) (ADD : WCore.add_event_gen X X' e l r R1 w W1 W2) (NOTIN : ~ E e) : ∅₂ ∪ WCore.rmw_delta e r ⨾ ⦗eq e⦘ ≡ WCore.rmw_delta e r.","proofString":"clear; basic_solver."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : rf' ⨾ ⦗E' \\₁ cmt⦘\n⊆ rf' ⨾ ⦗E' \\₁ cmt⦘ \\ same_tid ∪ (rf' ⨾ ⦗E' \\₁ cmt⦘) ∩ same_tid.","proofString":"clear.\nunfolder.\nins.\ndesf.\nsplits; tauto."},{"statement":"(cmt : actid -> Prop) : rf' ⨾ ⦗E' \\₁ cmt⦘\n⊆ rf' ⨾ ⦗E' \\₁ cmt⦘ \\ same_tid ∪ (rf' ⨾ ⦗E' \\₁ cmt⦘) ∩ same_tid.","proofString":"unfolder.\nins.\ndesf.\nsplits; tauto."},{"statement":"(cmt : actid -> Prop) : forall x y : actid,\nrf' x y /\\ E' y /\\ ~ cmt y ->\n(rf' x y /\\ E' y /\\ ~ cmt y) /\\ ~ same_tid x y \\/\n(rf' x y /\\ E' y /\\ ~ cmt y) /\\ same_tid x y.","proofString":"ins.\ndesf.\nsplits; tauto."},{"statement":"(cmt : actid -> Prop) (x y : actid) (H : rf' x y /\\ E' y /\\ ~ cmt y) : (rf' x y /\\ E' y /\\ ~ cmt y) /\\ ~ same_tid x y \\/\n(rf' x y /\\ E' y /\\ ~ cmt y) /\\ same_tid x y.","proofString":"desf.\nsplits; tauto."},{"statement":"(cmt : actid -> Prop) (x y : actid) (H : rf' x y) (H0 : E' y) (H1 : ~ cmt y) : (rf' x y /\\ E' y /\\ ~ cmt y) /\\ ~ same_tid x y \\/\n(rf' x y /\\ E' y /\\ ~ cmt y) /\\ same_tid x y.","proofString":"splits; tauto."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : rf' ⨾ ⦗E' \\₁ cmt⦘ \\ same_tid ∪ (rf' ⨾ ⦗E' \\₁ cmt⦘) ∩ same_tid\n⊆ tid ↓ thrdle ∪ (rf' ⨾ ⦗E' \\₁ cmt⦘) ∩ same_tid.","proofString":"apply union_mori; auto with hahn.\nrewrite (rf_sub_vf WF).\narewrite (vf' ⨾ ⦗E' \\₁ cmt⦘ ⊆ vf' ⨾ same_tid ⨾ ⦗E' \\₁ cmt⦘).\nunfold same_tid.\nbasic_solver 11.\nrewrite (WCore.surg_ncmt STAB).\nbasic_solver."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : rf' ⨾ ⦗E' \\₁ cmt⦘ \\ same_tid ⊆ tid ↓ thrdle.","proofString":"rewrite (rf_sub_vf WF).\narewrite (vf' ⨾ ⦗E' \\₁ cmt⦘ ⊆ vf' ⨾ same_tid ⨾ ⦗E' \\₁ cmt⦘).\nunfold same_tid.\nbasic_solver 11.\nrewrite (WCore.surg_ncmt STAB).\nbasic_solver."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : vf' ⨾ ⦗E' \\₁ cmt⦘ \\ same_tid ⊆ tid ↓ thrdle.","proofString":"arewrite (vf' ⨾ ⦗E' \\₁ cmt⦘ ⊆ vf' ⨾ same_tid ⨾ ⦗E' \\₁ cmt⦘).\nunfold same_tid.\nbasic_solver 11.\nrewrite (WCore.surg_ncmt STAB).\nbasic_solver."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : vf' ⨾ ⦗E' \\₁ cmt⦘ ⊆ vf' ⨾ same_tid ⨾ ⦗E' \\₁ cmt⦘.","proofString":"unfold same_tid.\nbasic_solver 11."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : vf' ⨾ ⦗E' \\₁ cmt⦘ ⊆ vf' ⨾ (fun x y : actid => tid x = tid y) ⨾ ⦗E' \\₁ cmt⦘.","proofString":"basic_solver 11."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : vf' ⨾ same_tid ⨾ ⦗E' \\₁ cmt⦘ \\ same_tid ⊆ tid ↓ thrdle.","proofString":"rewrite (WCore.surg_ncmt STAB).\nbasic_solver."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : (tid ↓ thrdle ∪ same_tid) \\ same_tid ⊆ tid ↓ thrdle.","proofString":"basic_solver."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : rf' ⊆ rf' ∩ sb' ∪ rf' \\ sb'.","proofString":"apply ri_union_re."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : (rf' ∩ sb' ∪ rf' \\ sb') ∩ same_tid ⊆ sb'.","proofString":"rewrite inter_union_l.\napply inclusion_union_l; [basic_solver |].\narewrite (rf' \\ sb' ⊆ rf' \\ ext_sb).\nrewrite (wf_rfE WF) at 1.\nunfold sb.\nunfolder.\nins.\ndesf.\nsplit; tauto.\nrewrite (no_rf_to_init WF).\nunfolder.\nintros x y.\ndestruct PeanoNat.Nat.lt_total      with (n := index x) (m := index y)        as [LT | [EQ | GT]].\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neauto.\nunfold index in EQ.\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto.\nins.\nassert (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y).\napply WF.\ndesf.\nassert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : rf' ∩ sb' ∩ same_tid ∪ (rf' \\ sb') ∩ same_tid ⊆ sb'.","proofString":"apply inclusion_union_l; [basic_solver |].\narewrite (rf' \\ sb' ⊆ rf' \\ ext_sb).\nrewrite (wf_rfE WF) at 1.\nunfold sb.\nunfolder.\nins.\ndesf.\nsplit; tauto.\nrewrite (no_rf_to_init WF).\nunfolder.\nintros x y.\ndestruct PeanoNat.Nat.lt_total      with (n := index x) (m := index y)        as [LT | [EQ | GT]].\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neauto.\nunfold index in EQ.\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto.\nins.\nassert (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y).\napply WF.\ndesf.\nassert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : (rf' \\ sb') ∩ same_tid ⊆ sb'.","proofString":"arewrite (rf' \\ sb' ⊆ rf' \\ ext_sb).\nrewrite (wf_rfE WF) at 1.\nunfold sb.\nunfolder.\nins.\ndesf.\nsplit; tauto.\nrewrite (no_rf_to_init WF).\nunfolder.\nintros x y.\ndestruct PeanoNat.Nat.lt_total      with (n := index x) (m := index y)        as [LT | [EQ | GT]].\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neauto.\nunfold index in EQ.\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto.\nins.\nassert (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y).\napply WF.\ndesf.\nassert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : rf' \\ sb' ⊆ rf' \\ ext_sb.","proofString":"rewrite (wf_rfE WF) at 1.\nunfold sb.\nunfolder.\nins.\ndesf.\nsplit; tauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘ \\ sb' ⊆ rf' \\ ext_sb.","proofString":"unfold sb.\nunfolder.\nins.\ndesf.\nsplit; tauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘ \\ ⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ⊆ rf' \\ ext_sb.","proofString":"unfolder.\nins.\ndesf.\nsplit; tauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : forall x y : actid,\n(E' x /\\ rf' x y /\\ E' y) /\\ ~ (E' x /\\ ext_sb x y /\\ E' y) ->\nrf' x y /\\ ~ ext_sb x y.","proofString":"ins.\ndesf.\nsplit; tauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (H : (E' x /\\ rf' x y /\\ E' y) /\\ ~ (E' x /\\ ext_sb x y /\\ E' y)) : rf' x y /\\ ~ ext_sb x y.","proofString":"desf.\nsplit; tauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (H : E' x) (H1 : rf' x y) (H2 : E' y) (H0 : ~ (E' x /\\ ext_sb x y /\\ E' y)) : rf' x y /\\ ~ ext_sb x y.","proofString":"split; tauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : (rf' \\ ext_sb) ∩ same_tid ⊆ sb'.","proofString":"rewrite (no_rf_to_init WF).\nunfolder.\nintros x y.\ndestruct PeanoNat.Nat.lt_total      with (n := index x) (m := index y)        as [LT | [EQ | GT]].\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neauto.\nunfold index in EQ.\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto.\nins.\nassert (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y).\napply WF.\ndesf.\nassert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : (rf' ⨾ ⦗fun x : actid => ~ is_init x⦘ \\ ext_sb) ∩ same_tid ⊆ sb'.","proofString":"unfolder.\nintros x y.\ndestruct PeanoNat.Nat.lt_total      with (n := index x) (m := index y)        as [LT | [EQ | GT]].\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neauto.\nunfold index in EQ.\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto.\nins.\nassert (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y).\napply WF.\ndesf.\nassert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') : forall x y : actid,\n((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y -> sb' x y.","proofString":"intros x y.\ndestruct PeanoNat.Nat.lt_total      with (n := index x) (m := index y)        as [LT | [EQ | GT]].\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neauto.\nunfold index in EQ.\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto.\nins.\nassert (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y).\napply WF.\ndesf.\nassert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y -> sb' x y.","proofString":"destruct PeanoNat.Nat.lt_total      with (n := index x) (m := index y)        as [LT | [EQ | GT]].\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neauto.\nunfold index in EQ.\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto.\nins.\nassert (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y).\napply WF.\ndesf.\nassert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (LT : index x < index y) : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y -> sb' x y.","proofString":"unfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (LT : index x < index y) : ((rf' x y /\\ ~ is_init y) /\\\n ~\n match x with\n | InitEvent _ =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent _ _ => True\n     end\n | ThreadEvent t i =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent t' i' => t = t' /\\ i < i'\n     end\n end) /\\ tid x = tid y ->\n(⦗E'⦘\n ⨾ (fun a b : actid =>\n    match a with\n    | InitEvent _ =>\n        match b with\n        | InitEvent _ => False\n        | ThreadEvent _ _ => True\n        end\n    | ThreadEvent t i =>\n        match b with\n        | InitEvent _ => False\n        | ThreadEvent t' i' => t = t' /\\ i < i'\n        end\n    end) ⨾ ⦗E'⦘) x y.","proofString":"unfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (LT : index x < index y) : ((rf' x y /\\ ~ is_init y) /\\\n ~\n match x with\n | InitEvent _ =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent _ _ => True\n     end\n | ThreadEvent t i =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent t' i' => t = t' /\\ i < i'\n     end\n end) /\\ tid x = tid y ->\nexists z : actid,\n  (x = z /\\ E' x) /\\\n  (exists z0 : actid,\n     match z with\n     | InitEvent _ =>\n         match z0 with\n         | InitEvent _ => False\n         | ThreadEvent _ _ => True\n         end\n     | ThreadEvent t i =>\n         match z0 with\n         | InitEvent _ => False\n         | ThreadEvent t' i' => t = t' /\\ i < i'\n         end\n     end /\\ z0 = y /\\ E' z0).","proofString":"ins.\nexfalso.\ndesf.\nins.\ndesf.\neauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (LT : index x < index y) (H : ((rf' x y /\\ ~ is_init y) /\\\n ~\n match x with\n | InitEvent _ =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent _ _ => True\n     end\n | ThreadEvent t i =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent t' i' => t = t' /\\ i < i'\n     end\n end) /\\ tid x = tid y) : exists z : actid,\n  (x = z /\\ E' x) /\\\n  (exists z0 : actid,\n     match z with\n     | InitEvent _ =>\n         match z0 with\n         | InitEvent _ => False\n         | ThreadEvent _ _ => True\n         end\n     | ThreadEvent t i =>\n         match z0 with\n         | InitEvent _ => False\n         | ThreadEvent t' i' => t = t' /\\ i < i'\n         end\n     end /\\ z0 = y /\\ E' z0).","proofString":"exfalso.\ndesf.\nins.\ndesf.\neauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (LT : index x < index y) (H : ((rf' x y /\\ ~ is_init y) /\\\n ~\n match x with\n | InitEvent _ =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent _ _ => True\n     end\n | ThreadEvent t i =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent t' i' => t = t' /\\ i < i'\n     end\n end) /\\ tid x = tid y) : False.","proofString":"desf.\nins.\ndesf.\neauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (thread : thread_id) (index : nat) (thread0 : thread_id) (index0 : nat) (LT : Events.index (ThreadEvent thread index) <\nEvents.index (ThreadEvent thread0 index0)) (H : rf' (ThreadEvent thread index) (ThreadEvent thread0 index0)) (H2 : ~ is_init (ThreadEvent thread0 index0)) (H1 : ~ (thread = thread0 /\\ index < index0)) (H0 : tid (ThreadEvent thread index) = tid (ThreadEvent thread0 index0)) : False.","proofString":"ins.\ndesf.\neauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (thread : thread_id) (index : nat) (thread0 : thread_id) (index0 : nat) (LT : index < index0) (H : rf' (ThreadEvent thread index) (ThreadEvent thread0 index0)) (H2 : ~ false) (H1 : ~ (thread = thread0 /\\ index < index0)) (H0 : thread = thread0) : False.","proofString":"desf.\neauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (index : nat) (thread0 : thread_id) (index0 : nat) (LT : index < index0) (H : rf' (ThreadEvent thread0 index) (ThreadEvent thread0 index0)) (H2 : ~ false) (H1 : ~ (thread0 = thread0 /\\ index < index0)) : False.","proofString":"eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (EQ : index x = index y) : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y -> sb' x y.","proofString":"unfold index in EQ.\nunfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (EQ : match x with\n| InitEvent _ => 0\n| ThreadEvent _ n => n\nend = match y with\n      | InitEvent _ => 0\n      | ThreadEvent _ n => n\n      end) : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y -> sb' x y.","proofString":"unfold sb, same_tid, ext_sb.\nunfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (EQ : match x with\n| InitEvent _ => 0\n| ThreadEvent _ n => n\nend = match y with\n      | InitEvent _ => 0\n      | ThreadEvent _ n => n\n      end) : ((rf' x y /\\ ~ is_init y) /\\\n ~\n match x with\n | InitEvent _ =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent _ _ => True\n     end\n | ThreadEvent t i =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent t' i' => t = t' /\\ i < i'\n     end\n end) /\\ tid x = tid y ->\n(⦗E'⦘\n ⨾ (fun a b : actid =>\n    match a with\n    | InitEvent _ =>\n        match b with\n        | InitEvent _ => False\n        | ThreadEvent _ _ => True\n        end\n    | ThreadEvent t i =>\n        match b with\n        | InitEvent _ => False\n        | ThreadEvent t' i' => t = t' /\\ i < i'\n        end\n    end) ⨾ ⦗E'⦘) x y.","proofString":"unfolder.\nins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (EQ : match x with\n| InitEvent _ => 0\n| ThreadEvent _ n => n\nend = match y with\n      | InitEvent _ => 0\n      | ThreadEvent _ n => n\n      end) : ((rf' x y /\\ ~ is_init y) /\\\n ~\n match x with\n | InitEvent _ =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent _ _ => True\n     end\n | ThreadEvent t i =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent t' i' => t = t' /\\ i < i'\n     end\n end) /\\ tid x = tid y ->\nexists z : actid,\n  (x = z /\\ E' x) /\\\n  (exists z0 : actid,\n     match z with\n     | InitEvent _ =>\n         match z0 with\n         | InitEvent _ => False\n         | ThreadEvent _ _ => True\n         end\n     | ThreadEvent t i =>\n         match z0 with\n         | InitEvent _ => False\n         | ThreadEvent t' i' => t = t' /\\ i < i'\n         end\n     end /\\ z0 = y /\\ E' z0).","proofString":"ins.\nexfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (EQ : match x with\n| InitEvent _ => 0\n| ThreadEvent _ n => n\nend = match y with\n      | InitEvent _ => 0\n      | ThreadEvent _ n => n\n      end) (H : ((rf' x y /\\ ~ is_init y) /\\\n ~\n match x with\n | InitEvent _ =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent _ _ => True\n     end\n | ThreadEvent t i =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent t' i' => t = t' /\\ i < i'\n     end\n end) /\\ tid x = tid y) : exists z : actid,\n  (x = z /\\ E' x) /\\\n  (exists z0 : actid,\n     match z with\n     | InitEvent _ =>\n         match z0 with\n         | InitEvent _ => False\n         | ThreadEvent _ _ => True\n         end\n     | ThreadEvent t i =>\n         match z0 with\n         | InitEvent _ => False\n         | ThreadEvent t' i' => t = t' /\\ i < i'\n         end\n     end /\\ z0 = y /\\ E' z0).","proofString":"exfalso.\ndesf.\nins.\ndesf.\neapply (rf_irr WF); eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (EQ : match x with\n| InitEvent _ => 0\n| ThreadEvent _ n => n\nend = match y with\n      | InitEvent _ => 0\n      | ThreadEvent _ n => n\n      end) (H : ((rf' x y /\\ ~ is_init y) /\\\n ~\n match x with\n | InitEvent _ =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent _ _ => True\n     end\n | ThreadEvent t i =>\n     match y with\n     | InitEvent _ => False\n     | ThreadEvent t' i' => t = t' /\\ i < i'\n     end\n end) /\\ tid x = tid y) : False.","proofString":"desf.\nins.\ndesf.\neapply (rf_irr WF); eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (thread thread0 : thread_id) (index : nat) (H : rf' (ThreadEvent thread index) (ThreadEvent thread0 index)) (H2 : ~ is_init (ThreadEvent thread0 index)) (H0 : tid (ThreadEvent thread index) = tid (ThreadEvent thread0 index)) (H1 : ~ (thread = thread0 /\\ index < index)) : False.","proofString":"ins.\ndesf.\neapply (rf_irr WF); eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (thread thread0 : thread_id) (index : nat) (H : rf' (ThreadEvent thread index) (ThreadEvent thread0 index)) (H2 : ~ false) (H0 : thread = thread0) (H1 : ~ (thread = thread0 /\\ index < index)) : False.","proofString":"desf.\neapply (rf_irr WF); eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (thread0 : thread_id) (index : nat) (H : rf' (ThreadEvent thread0 index) (ThreadEvent thread0 index)) (H2 : ~ false) (H1 : ~ (thread0 = thread0 /\\ index < index)) : False.","proofString":"eapply (rf_irr WF); eauto."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y -> sb' x y.","proofString":"ins.\nassert (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y).\napply WF.\ndesf.\nassert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) : sb' x y.","proofString":"assert (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y).\napply WF.\ndesf.\nassert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y.","proofString":"apply WF.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) : rf' x y.","proofString":"desf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y) : sb' x y.","proofString":"assert (SB : sb' y x).\nunfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf.\nexfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y) : sb' y x.","proofString":"unfolder in RFE.\nunfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : E' x /\\ rf' x y /\\ E' y) : sb' y x.","proofString":"unfold sb.\nunfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : E' x /\\ rf' x y /\\ E' y) : (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) y x.","proofString":"unfolder.\nsplits; desf.\nunfold same_tid, ext_sb in *.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : E' x /\\ rf' x y /\\ E' y) : E' y /\\ ext_sb y x /\\ E' x.","proofString":"splits; desf.\nunfold same_tid, ext_sb in *.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : rf' x y) (H2 : ~ is_init y) (H1 : ~ ext_sb x y) (H0 : same_tid x y) (RFE : E' x) (RFE0 : rf' x y) (RFE1 : E' y) : ext_sb y x.","proofString":"unfold same_tid, ext_sb in *.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : rf' x y) (H2 : ~ is_init y) (H1 : ~\nmatch x with\n| InitEvent _ =>\n    match y with\n    | InitEvent _ => False\n    | ThreadEvent _ _ => True\n    end\n| ThreadEvent t i =>\n    match y with\n    | InitEvent _ => False\n    | ThreadEvent t' i' => t = t' /\\ i < i'\n    end\nend) (H0 : tid x = tid y) (RFE : E' x) (RFE0 : rf' x y) (RFE1 : E' y) : match y with\n| InitEvent _ =>\n    match x with\n    | InitEvent _ => False\n    | ThreadEvent _ _ => True\n    end\n| ThreadEvent t i =>\n    match x with\n    | InitEvent _ => False\n    | ThreadEvent t' i' => t = t' /\\ i < i'\n    end\nend.","proofString":"desf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y) (SB : sb' y x) : sb' x y.","proofString":"exfalso.\napply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y) (SB : sb' y x) : False.","proofString":"apply (WCore.cons_coherence CONS) with y.\nexists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y) (SB : sb' y x) : (hb G' ⨾ (eco G')^?) y y.","proofString":"exists x.\nsplit; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y) (SB : sb' y x) : hb G' y x /\\ (eco G')^? x y.","proofString":"split; [now apply sb_in_hb |].\napply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y) (SB : sb' y x) : (eco G')^? x y.","proofString":"apply r_step, rf_in_eco.\ndesf."},{"statement":"(WF : Wf G') (CONS : WCore.is_cons G') (x y : actid) (GT : index y < index x) (H : ((rf' x y /\\ ~ is_init y) /\\ ~ ext_sb x y) /\\ same_tid x y) (RFE : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) x y) (SB : sb' y x) : rf' x y.","proofString":"desf."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (CONS : WCore.is_cons G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : tid ↓ thrdle ∪ (rf' ⨾ ⦗E' \\₁ cmt⦘) ∩ same_tid ⊆ tid ↓ thrdle ∪ sb'.","proofString":"rewrite seq_eqv_inter_lr.\nrewrite rfi_in_sb; auto.\nbasic_solver."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (CONS : WCore.is_cons G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : tid ↓ thrdle ∪ rf' ∩ same_tid ⨾ ⦗E' \\₁ cmt⦘ ⊆ tid ↓ thrdle ∪ sb'.","proofString":"rewrite rfi_in_sb; auto.\nbasic_solver."},{"statement":"(cmt : actid -> Prop) (thrdle : relation BinNums.positive) (WF : Wf G') (CONS : WCore.is_cons G') (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) : tid ↓ thrdle ∪ sb' ⨾ ⦗E' \\₁ cmt⦘ ⊆ tid ↓ thrdle ∪ sb'.","proofString":"basic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : dom_rel (⦗dtrmt⦘ ⨾ sb ⨾ ⦗dtrmt⦘) ⊆₁ dtrmt.","proofString":"clear.\nbasic_solver."},{"statement":"(dtrmt : actid -> Prop) : dom_rel (⦗dtrmt⦘ ⨾ sb ⨾ ⦗dtrmt⦘) ⊆₁ dtrmt.","proofString":"basic_solver."},{"statement":"(X'' : WCore.t) (cmt : actid -> Prop) (STEPS : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt X') X'' X') : acts_set (WCore.G X'') ⊆₁ E'.","proofString":"induction STEPS as [| X''' X'''' STEP STEPS IHSTEP]; auto.\nrewrite IHSTEP.\nred in STEP.\ndestruct STEP as (e' & l' & STEP).\nset (STEP' := WCore.gsg_add_step STEP).\nred in STEP'.\ndestruct STEP' as (r & R1 & w & W1 & W2 & STEP').\nrewrite (WCore.add_event_acts STEP').\nauto with hahn."},{"statement":"(X'' : WCore.t) (cmt : actid -> Prop) (X''' X'''' : WCore.t) (STEP : WCore.guided_step cmt X' X''' X'''') (STEPS : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt X') X'' X''') (IHSTEP : acts_set (WCore.G X'') ⊆₁ acts_set (WCore.G X''')) : acts_set (WCore.G X'') ⊆₁ acts_set (WCore.G X'''').","proofString":"rewrite IHSTEP.\nred in STEP.\ndestruct STEP as (e' & l' & STEP).\nset (STEP' := WCore.gsg_add_step STEP).\nred in STEP'.\ndestruct STEP' as (r & R1 & w & W1 & W2 & STEP').\nrewrite (WCore.add_event_acts STEP').\nauto with hahn."},{"statement":"(X'' : WCore.t) (cmt : actid -> Prop) (X''' X'''' : WCore.t) (STEP : WCore.guided_step cmt X' X''' X'''') (STEPS : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt X') X'' X''') (IHSTEP : acts_set (WCore.G X'') ⊆₁ acts_set (WCore.G X''')) : acts_set (WCore.G X''') ⊆₁ acts_set (WCore.G X'''').","proofString":"red in STEP.\ndestruct STEP as (e' & l' & STEP).\nset (STEP' := WCore.gsg_add_step STEP).\nred in STEP'.\ndestruct STEP' as (r & R1 & w & W1 & W2 & STEP').\nrewrite (WCore.add_event_acts STEP').\nauto with hahn."},{"statement":"(X'' : WCore.t) (cmt : actid -> Prop) (X''' X'''' : WCore.t) (STEP : exists (e0 : actid) (l0 : label),\n  WCore.guided_step_gen cmt X' X''' X'''' e0 l0) (STEPS : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt X') X'' X''') (IHSTEP : acts_set (WCore.G X'') ⊆₁ acts_set (WCore.G X''')) : acts_set (WCore.G X''') ⊆₁ acts_set (WCore.G X'''').","proofString":"destruct STEP as (e' & l' & STEP).\nset (STEP' := WCore.gsg_add_step STEP).\nred in STEP'.\ndestruct STEP' as (r & R1 & w & W1 & W2 & STEP').\nrewrite (WCore.add_event_acts STEP').\nauto with hahn."},{"statement":"(X'' : WCore.t) (cmt : actid -> Prop) (X''' X'''' : WCore.t) (e' : actid) (l' : label) (STEP : WCore.guided_step_gen cmt X' X''' X'''' e' l') (STEPS : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt X') X'' X''') (IHSTEP : acts_set (WCore.G X'') ⊆₁ acts_set (WCore.G X''')) : acts_set (WCore.G X''') ⊆₁ acts_set (WCore.G X'''').","proofString":"set (STEP' := WCore.gsg_add_step STEP).\nred in STEP'.\ndestruct STEP' as (r & R1 & w & W1 & W2 & STEP').\nrewrite (WCore.add_event_acts STEP').\nauto with hahn."},{"statement":"(X'' : WCore.t) (cmt : actid -> Prop) (X''' X'''' : WCore.t) (e' : actid) (l' : label) (STEP : WCore.guided_step_gen cmt X' X''' X'''' e' l') (STEPS : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt X') X'' X''') (IHSTEP : acts_set (WCore.G X'') ⊆₁ acts_set (WCore.G X''')) (STEP' : WCore.add_event X''' X'''' e' l') : acts_set (WCore.G X''') ⊆₁ acts_set (WCore.G X'''').","proofString":"red in STEP'.\ndestruct STEP' as (r & R1 & w & W1 & W2 & STEP').\nrewrite (WCore.add_event_acts STEP').\nauto with hahn."},{"statement":"(X'' : WCore.t) (cmt : actid -> Prop) (X''' X'''' : WCore.t) (e' : actid) (l' : label) (STEP : WCore.guided_step_gen cmt X' X''' X'''' e' l') (STEPS : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt X') X'' X''') (IHSTEP : acts_set (WCore.G X'') ⊆₁ acts_set (WCore.G X''')) (STEP' : exists\n  (r : option actid) (R1 : actid -> Prop) (w : option actid) \n(W1 W2 : actid -> Prop), WCore.add_event_gen X''' X'''' e' l' r R1 w W1 W2) : acts_set (WCore.G X''') ⊆₁ acts_set (WCore.G X'''').","proofString":"destruct STEP' as (r & R1 & w & W1 & W2 & STEP').\nrewrite (WCore.add_event_acts STEP').\nauto with hahn."},{"statement":"(X'' : WCore.t) (cmt : actid -> Prop) (X''' X'''' : WCore.t) (e' : actid) (l' : label) (STEP : WCore.guided_step_gen cmt X' X''' X'''' e' l') (STEPS : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt X') X'' X''') (IHSTEP : acts_set (WCore.G X'') ⊆₁ acts_set (WCore.G X''')) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (STEP' : WCore.add_event_gen X''' X'''' e' l' r R1 w W1 W2) : acts_set (WCore.G X''') ⊆₁ acts_set (WCore.G X'''').","proofString":"rewrite (WCore.add_event_acts STEP').\nauto with hahn."},{"statement":"(X'' : WCore.t) (cmt : actid -> Prop) (X''' X'''' : WCore.t) (e' : actid) (l' : label) (STEP : WCore.guided_step_gen cmt X' X''' X'''' e' l') (STEPS : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt X') X'' X''') (IHSTEP : acts_set (WCore.G X'') ⊆₁ acts_set (WCore.G X''')) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (STEP' : WCore.add_event_gen X''' X'''' e' l' r R1 w W1 W2) : acts_set (WCore.G X''') ⊆₁ acts_set (WCore.G X''') ∪₁ eq e'.","proofString":"auto with hahn."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : id ↑₁ dtrmt ⊆₁ E.","proofString":"rewrite set_collect_eq_dom     with (g := f).\nrewrite (WCore.dtrmt_cmt REXEC).\napply (WCore.reexec_embd_acts (WCore.reexec_embd_corr REXEC)).\nunfolder.\nunfold id.\nins.\nsymmetry.\nnow apply (WCore.dtrmt_fixed REXEC)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : f ↑₁ dtrmt ⊆₁ E.","proofString":"rewrite (WCore.dtrmt_cmt REXEC).\napply (WCore.reexec_embd_acts (WCore.reexec_embd_corr REXEC))."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : f ↑₁ cmt ⊆₁ E.","proofString":"apply (WCore.reexec_embd_acts (WCore.reexec_embd_corr REXEC))."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : eq_dom dtrmt id f.","proofString":"unfolder.\nunfold id.\nins.\nsymmetry.\nnow apply (WCore.dtrmt_fixed REXEC)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : forall x : actid, dtrmt x -> id x = f x.","proofString":"unfold id.\nins.\nsymmetry.\nnow apply (WCore.dtrmt_fixed REXEC)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : forall x : actid, dtrmt x -> x = f x.","proofString":"ins.\nsymmetry.\nnow apply (WCore.dtrmt_fixed REXEC)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) (x : actid) (DX : dtrmt x) : x = f x.","proofString":"symmetry.\nnow apply (WCore.dtrmt_fixed REXEC)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) (x : actid) (DX : dtrmt x) : f x = x.","proofString":"now apply (WCore.dtrmt_fixed REXEC)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : dtrmt ⊆₁ acts_set (WCore.G (WCore.X_start X dtrmt)).","proofString":"ins.\nrewrite set_inter_absorb_r; auto with hahn.\napply (rexec_dtrmt_in_start REXEC)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : dtrmt ⊆₁ dtrmt ∩₁ E.","proofString":"rewrite set_inter_absorb_r; auto with hahn.\napply (rexec_dtrmt_in_start REXEC)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : dtrmt ⊆₁ E.","proofString":"apply (rexec_dtrmt_in_start REXEC)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (REXEC : WCore.reexec_gen X X' f dtrmt cmt thrdle) : codom_rel (⦗dtrmt⦘ ⨾ immediate (nin_sb G') ⨾ ⦗dtrmt⦘) ⊆₁ dtrmt.","proofString":"clear.\nbasic_solver."},{"statement":"(dtrmt : actid -> Prop) : codom_rel (⦗dtrmt⦘ ⨾ immediate (nin_sb G') ⨾ ⦗dtrmt⦘) ⊆₁ dtrmt.","proofString":"basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : Wf G'.","proofString":"eapply add_event_wf; eauto using xgp_wf."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : (fun a : actid => is_init a) ⊆₁ E'.","proofString":"rewrite (WCore.add_event_acts STEP), (xgp_init PROP).\nauto with hahn."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : E ⊆₁ E ∪₁ eq e'.","proofString":"auto with hahn."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : rmw_dep' ≡ ∅₂.","proofString":"rewrite (WCore.add_event_rmw_dep STEP).\napply PROP."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : rmw_dep ≡ ∅₂.","proofString":"apply PROP."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : data' ≡ ∅₂.","proofString":"rewrite (WCore.add_event_data STEP).\napply PROP."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : data ≡ ∅₂.","proofString":"apply PROP."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : ctrl' ≡ ∅₂.","proofString":"rewrite (WCore.add_event_ctrl STEP).\napply PROP."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : ctrl ≡ ∅₂.","proofString":"apply PROP."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : addr' ≡ ∅₂.","proofString":"rewrite (WCore.add_event_addr STEP).\napply PROP."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : addr ≡ ∅₂.","proofString":"apply PROP."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : set_finite (E' \\₁ (fun a : actid => is_init a)).","proofString":"rewrite (WCore.add_event_acts STEP),            set_minus_union_l.\napply set_finite_union.\nsplit; [apply PROP|].\neapply set_finite_mori; eauto with hahn.\nred.\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : set_finite\n  (E \\₁ (fun a : actid => is_init a) ∪₁ eq e' \\₁ (fun a : actid => is_init a)).","proofString":"apply set_finite_union.\nsplit; [apply PROP|].\neapply set_finite_mori; eauto with hahn.\nred.\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : set_finite (E \\₁ (fun a : actid => is_init a)) /\\\nset_finite (eq e' \\₁ (fun a : actid => is_init a)).","proofString":"split; [apply PROP|].\neapply set_finite_mori; eauto with hahn.\nred.\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : set_finite (eq e' \\₁ (fun a : actid => is_init a)).","proofString":"eapply set_finite_mori; eauto with hahn.\nred.\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : E' ∩₁ (fun e0 : actid => tid e0 = tid_init) ⊆₁ (fun a : actid => is_init a).","proofString":"rewrite (WCore.add_event_acts STEP), set_inter_union_l.\nrewrite (xgp_init_tid PROP).\napply set_subset_union_l.\nsplit; [reflexivity |].\nunfolder.\nins.\ndesf.\nexfalso.\nnow apply (WCore.add_event_tid_e STEP)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : E ∩₁ (fun e0 : actid => tid e0 = tid_init)\n∪₁ eq e' ∩₁ (fun e0 : actid => tid e0 = tid_init)\n⊆₁ (fun a : actid => is_init a).","proofString":"rewrite (xgp_init_tid PROP).\napply set_subset_union_l.\nsplit; [reflexivity |].\nunfolder.\nins.\ndesf.\nexfalso.\nnow apply (WCore.add_event_tid_e STEP)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : (fun a : actid => is_init a)\n∪₁ eq e' ∩₁ (fun e0 : actid => tid e0 = tid_init)\n⊆₁ (fun a : actid => is_init a).","proofString":"apply set_subset_union_l.\nsplit; [reflexivity |].\nunfolder.\nins.\ndesf.\nexfalso.\nnow apply (WCore.add_event_tid_e STEP)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : (fun a : actid => is_init a) ⊆₁ (fun a : actid => is_init a) /\\\neq e' ∩₁ (fun e0 : actid => tid e0 = tid_init)\n⊆₁ (fun a : actid => is_init a).","proofString":"split; [reflexivity |].\nunfolder.\nins.\ndesf.\nexfalso.\nnow apply (WCore.add_event_tid_e STEP)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : eq e' ∩₁ (fun e0 : actid => tid e0 = tid_init)\n⊆₁ (fun a : actid => is_init a).","proofString":"unfolder.\nins.\ndesf.\nexfalso.\nnow apply (WCore.add_event_tid_e STEP)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : forall x : actid, e' = x /\\ tid x = tid_init -> is_init x.","proofString":"ins.\ndesf.\nexfalso.\nnow apply (WCore.add_event_tid_e STEP)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (e' : actid) (l' : label) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) (x : actid) (H : e' = x /\\ tid x = tid_init) : is_init x.","proofString":"desf.\nexfalso.\nnow apply (WCore.add_event_tid_e STEP)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (l' : label) (x : actid) (STEP : WCore.add_event_gen X X' x l' r R1 w W1 W2) (PROP : xmm_graph_proper G) (H0 : tid x = tid_init) : is_init x.","proofString":"exfalso.\nnow apply (WCore.add_event_tid_e STEP)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (l' : label) (x : actid) (STEP : WCore.add_event_gen X X' x l' r R1 w W1 W2) (PROP : xmm_graph_proper G) (H0 : tid x = tid_init) : False.","proofString":"now apply (WCore.add_event_tid_e STEP)."},{"statement":"(e' : actid) (l' : label) (STEP : exists\n  (r : option actid) (R1 : actid -> Prop) (w : option actid) \n(W1 W2 : actid -> Prop), WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : xmm_graph_proper G'.","proofString":"desf.\neauto using xmm_add_event_gen_proper."},{"statement":"(e' : actid) (l' : label) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (STEP : WCore.add_event_gen X X' e' l' r R1 w W1 W2) (PROP : xmm_graph_proper G) : xmm_graph_proper G'.","proofString":"eauto using xmm_add_event_gen_proper."},{"statement":"(XC : WCore.t) (cmt : actid -> Prop) (STEP : exists (e0 : actid) (l0 : label), WCore.guided_step_gen cmt XC X X' e0 l0) (PROP : xmm_graph_proper G) : xmm_graph_proper G'.","proofString":"desf.\napply (xmm_guided_step_gen_proper STEP); auto."},{"statement":"(XC : WCore.t) (cmt : actid -> Prop) (e0 : actid) (l0 : label) (STEP : WCore.guided_step_gen cmt XC X X' e0 l0) (PROP : xmm_graph_proper G) : xmm_graph_proper G'.","proofString":"apply (xmm_guided_step_gen_proper STEP); auto."},{"statement":"(XC : WCore.t) (cmt : actid -> Prop) (X1 X2 : WCore.t) (STEP : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt XC) X1 X2) (PROP : xmm_graph_proper (WCore.G X1)) : xmm_graph_proper (WCore.G X2).","proofString":"induction STEP as [ | X2 X3 STEP1 STEP2 IH].\nauto.\neapply xmm_guided_step_proper; eauto."},{"statement":"(XC : WCore.t) (cmt : actid -> Prop) (X1 : WCore.t) (PROP : xmm_graph_proper (WCore.G X1)) : xmm_graph_proper (WCore.G X1).","proofString":"auto."},{"statement":"(XC : WCore.t) (cmt : actid -> Prop) (X1 X2 X3 : WCore.t) (STEP1 : WCore.guided_step cmt XC X2 X3) (STEP2 : clos_refl_trans_n1 WCore.t (WCore.guided_step cmt XC) X1 X2) (PROP : xmm_graph_proper (WCore.G X1)) (IH : xmm_graph_proper (WCore.G X2)) : xmm_graph_proper (WCore.G X3).","proofString":"eapply xmm_guided_step_proper; eauto."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (PROP : xmm_graph_correct G) : rf_complete G' /\\ xmm_graph_proper G'.","proofString":"split; [apply STEP |].\neapply xmm_guided_step_proper_trans.\napply STEP.\nred in PROP.\ndestruct PROP as (RFC & PROP).\nconstructor; ins.\napply sub_WF with (G := G) (sc := ∅₂) (sc' := ∅₂).\nins.\nrewrite (WCore.dtrmt_init STEP).\nreflexivity.\napply PROP.\napply restrict_sub; [basic_solver |].\napply (rexec_dtrmt_in_start STEP).\nrewrite (WCore.dtrmt_init STEP).\nrewrite <- (rexec_dtrmt_in_start STEP).\nbasic_solver.\nrewrite (xgp_rmw_dep PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_data PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_ctrl PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_addr PROP).\nnow rewrite seq_false_l, seq_false_r.\neapply set_finite_mori; [| apply PROP].\nred.\nbasic_solver.\nrewrite <- (xgp_init_tid PROP).\nbasic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (PROP : xmm_graph_correct G) : xmm_graph_proper G'.","proofString":"eapply xmm_guided_step_proper_trans.\napply STEP.\nred in PROP.\ndestruct PROP as (RFC & PROP).\nconstructor; ins.\napply sub_WF with (G := G) (sc := ∅₂) (sc' := ∅₂).\nins.\nrewrite (WCore.dtrmt_init STEP).\nreflexivity.\napply PROP.\napply restrict_sub; [basic_solver |].\napply (rexec_dtrmt_in_start STEP).\nrewrite (WCore.dtrmt_init STEP).\nrewrite <- (rexec_dtrmt_in_start STEP).\nbasic_solver.\nrewrite (xgp_rmw_dep PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_data PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_ctrl PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_addr PROP).\nnow rewrite seq_false_l, seq_false_r.\neapply set_finite_mori; [| apply PROP].\nred.\nbasic_solver.\nrewrite <- (xgp_init_tid PROP).\nbasic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (PROP : rf_complete G /\\ xmm_graph_proper G) : xmm_graph_proper (WCore.G (WCore.X_start X dtrmt)).","proofString":"destruct PROP as (RFC & PROP).\nconstructor; ins.\napply sub_WF with (G := G) (sc := ∅₂) (sc' := ∅₂).\nins.\nrewrite (WCore.dtrmt_init STEP).\nreflexivity.\napply PROP.\napply restrict_sub; [basic_solver |].\napply (rexec_dtrmt_in_start STEP).\nrewrite (WCore.dtrmt_init STEP).\nrewrite <- (rexec_dtrmt_in_start STEP).\nbasic_solver.\nrewrite (xgp_rmw_dep PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_data PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_ctrl PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_addr PROP).\nnow rewrite seq_false_l, seq_false_r.\neapply set_finite_mori; [| apply PROP].\nred.\nbasic_solver.\nrewrite <- (xgp_init_tid PROP).\nbasic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : xmm_graph_proper (WCore.G (WCore.X_start X dtrmt)).","proofString":"constructor; ins.\napply sub_WF with (G := G) (sc := ∅₂) (sc' := ∅₂).\nins.\nrewrite (WCore.dtrmt_init STEP).\nreflexivity.\napply PROP.\napply restrict_sub; [basic_solver |].\napply (rexec_dtrmt_in_start STEP).\nrewrite (WCore.dtrmt_init STEP).\nrewrite <- (rexec_dtrmt_in_start STEP).\nbasic_solver.\nrewrite (xgp_rmw_dep PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_data PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_ctrl PROP).\nnow rewrite seq_false_l, seq_false_r.\nrewrite (xgp_addr PROP).\nnow rewrite seq_false_l, seq_false_r.\neapply set_finite_mori; [| apply PROP].\nred.\nbasic_solver.\nrewrite <- (xgp_init_tid PROP).\nbasic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : Wf (restrict G dtrmt).","proofString":"apply sub_WF with (G := G) (sc := ∅₂) (sc' := ∅₂).\nins.\nrewrite (WCore.dtrmt_init STEP).\nreflexivity.\napply PROP.\napply restrict_sub; [basic_solver |].\napply (rexec_dtrmt_in_start STEP)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : (fun a : actid => is_init a) ∩₁ E ⊆₁ acts_set (restrict G dtrmt).","proofString":"ins.\nrewrite (WCore.dtrmt_init STEP).\nreflexivity."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : (fun a : actid => is_init a) ∩₁ E ⊆₁ dtrmt ∩₁ E.","proofString":"rewrite (WCore.dtrmt_init STEP).\nreflexivity."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : dtrmt ∩₁ E ⊆₁ dtrmt ∩₁ E.","proofString":"reflexivity."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : Wf G.","proofString":"apply PROP."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : sub_execution G (restrict G dtrmt) ∅₂ ∅₂.","proofString":"apply restrict_sub; [basic_solver |].\napply (rexec_dtrmt_in_start STEP)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : dtrmt ⊆₁ E.","proofString":"apply (rexec_dtrmt_in_start STEP)."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : (fun a : actid => is_init a) ⊆₁ dtrmt ∩₁ E.","proofString":"rewrite (WCore.dtrmt_init STEP).\nrewrite <- (rexec_dtrmt_in_start STEP).\nbasic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : dtrmt ⊆₁ dtrmt ∩₁ E.","proofString":"rewrite <- (rexec_dtrmt_in_start STEP).\nbasic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : dtrmt ⊆₁ dtrmt ∩₁ dtrmt.","proofString":"basic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : ⦗dtrmt⦘ ⨾ rmw_dep ⨾ ⦗dtrmt⦘ ≡ ∅₂.","proofString":"rewrite (xgp_rmw_dep PROP).\nnow rewrite seq_false_l, seq_false_r."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : ⦗dtrmt⦘ ⨾ ∅₂ ⨾ ⦗dtrmt⦘ ≡ ∅₂.","proofString":"now rewrite seq_false_l, seq_false_r."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : ⦗dtrmt⦘ ⨾ data ⨾ ⦗dtrmt⦘ ≡ ∅₂.","proofString":"rewrite (xgp_data PROP).\nnow rewrite seq_false_l, seq_false_r."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : ⦗dtrmt⦘ ⨾ ∅₂ ⨾ ⦗dtrmt⦘ ≡ ∅₂.","proofString":"now rewrite seq_false_l, seq_false_r."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : ⦗dtrmt⦘ ⨾ ctrl ⨾ ⦗dtrmt⦘ ≡ ∅₂.","proofString":"rewrite (xgp_ctrl PROP).\nnow rewrite seq_false_l, seq_false_r."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : ⦗dtrmt⦘ ⨾ ∅₂ ⨾ ⦗dtrmt⦘ ≡ ∅₂.","proofString":"now rewrite seq_false_l, seq_false_r."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : ⦗dtrmt⦘ ⨾ addr ⨾ ⦗dtrmt⦘ ≡ ∅₂.","proofString":"rewrite (xgp_addr PROP).\nnow rewrite seq_false_l, seq_false_r."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : ⦗dtrmt⦘ ⨾ ∅₂ ⨾ ⦗dtrmt⦘ ≡ ∅₂.","proofString":"now rewrite seq_false_l, seq_false_r."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : set_finite (dtrmt ∩₁ E \\₁ (fun a : actid => is_init a)).","proofString":"eapply set_finite_mori; [| apply PROP].\nred.\nbasic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : flip set_subset (E \\₁ (fun a : actid => is_init a))\n  (dtrmt ∩₁ E \\₁ (fun a : actid => is_init a)).","proofString":"red.\nbasic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : dtrmt ∩₁ E \\₁ (fun a : actid => is_init a)\n⊆₁ E \\₁ (fun a : actid => is_init a).","proofString":"basic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : dtrmt ∩₁ E ∩₁ (fun e0 : actid => tid e0 = tid_init)\n⊆₁ (fun a : actid => is_init a).","proofString":"rewrite <- (xgp_init_tid PROP).\nbasic_solver."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (RFC : rf_complete G) (PROP : xmm_graph_proper G) : dtrmt ∩₁ E ∩₁ (fun e0 : actid => tid e0 = tid_init)\n⊆₁ E ∩₁ (fun e0 : actid => tid e0 = tid_init).","proofString":"basic_solver."},{"statement":"(e0 : actid) (l0 : label) (STEP : WCore.exec_inst X X' e0 l0) (PROP : xmm_graph_correct G) : xmm_graph_correct G'.","proofString":"eapply xmm_exec_correct; eauto."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (STEP : WCore.reexec X X' f dtrmt cmt) (PROP : xmm_graph_correct G) : xmm_graph_correct G'.","proofString":"red in STEP.\ndesf.\neapply xmm_rexec_gen_correct; eauto."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (STEP : exists thrdle : relation BinNums.positive,\n  WCore.reexec_gen X X' f dtrmt cmt thrdle) (PROP : xmm_graph_correct G) : xmm_graph_correct G'.","proofString":"desf.\neapply xmm_rexec_gen_correct; eauto."},{"statement":"(f : actid -> actid) (dtrmt cmt : actid -> Prop) (thrdle : relation BinNums.positive) (STEP : WCore.reexec_gen X X' f dtrmt cmt thrdle) (PROP : xmm_graph_correct G) : xmm_graph_correct G'.","proofString":"eapply xmm_rexec_gen_correct; eauto."},{"statement":"(X1 X2 : WCore.t) (STEPS : clos_trans_n1 WCore.t xmm_step X1 X2) (PROP : xmm_graph_correct (WCore.G X1)) : xmm_graph_correct (WCore.G X2).","proofString":"induction STEPS as [X_t STEP | X_t X_t' STEP STEPS SRC].\neapply xmm_step_correct; eauto.\neapply xmm_step_correct; eauto."},{"statement":"(X1 X_t : WCore.t) (STEP : xmm_step X1 X_t) (PROP : xmm_graph_correct (WCore.G X1)) : xmm_graph_correct (WCore.G X_t).","proofString":"eapply xmm_step_correct; eauto."},{"statement":"(X1 X_t X_t' : WCore.t) (STEP : xmm_step X_t X_t') (STEPS : clos_trans_n1 WCore.t xmm_step X1 X_t) (PROP : xmm_graph_correct (WCore.G X1)) (SRC : xmm_graph_correct (WCore.G X_t)) : xmm_graph_correct (WCore.G X_t').","proofString":"eapply xmm_step_correct; eauto."}]}