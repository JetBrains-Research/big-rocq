{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/xmm/src/xmm/AddEventWf.v","fileSamples":[{"statement":"(s : actid -> Prop) (IN : forall x : actid, s x -> loc' x = loc' e) : forall x y : actid, s x /\\ e = y -> same_loc' x y.","conclusion":"forall x y : actid, s x /\\ e = y -> same_loc' x y","hypotheses":"(s : actid -> Prop) (IN : forall x : actid, s x -> loc' x = loc' e)","proofString":"unfold same_loc.\nins.\ndesf.\neauto."},{"statement":"(s : actid -> Prop) (IN : forall x : actid, s x -> loc' x = loc' e) : forall x y : actid, s x /\\ e = y -> loc' x = loc' y.","conclusion":"forall x y : actid, s x /\\ e = y -> loc' x = loc' y","hypotheses":"(s : actid -> Prop) (IN : forall x : actid, s x -> loc' x = loc' e)","proofString":"ins.\ndesf.\neauto."},{"statement":"(s : actid -> Prop) (IN : forall x0 : actid, s x0 -> loc' x0 = loc' e) (x y : actid) (H : s x /\\ e = y) : loc' x = loc' y.","conclusion":"loc' x = loc' y","hypotheses":"(s : actid -> Prop) (IN : forall x0 : actid, s x0 -> loc' x0 = loc' e) (x y : actid) (H : s x /\\ e = y)","proofString":"desf.\neauto."},{"statement":"(s : actid -> Prop) (y : actid) (IN : forall x0 : actid, s x0 -> loc' x0 = loc' y) (x : actid) (H : s x) : loc' x = loc' y.","conclusion":"loc' x = loc' y","hypotheses":"(s : actid -> Prop) (y : actid) (IN : forall x0 : actid, s x0 -> loc' x0 = loc' y) (x : actid) (H : s x)","proofString":"eauto."},{"statement":"(A B : actid -> Prop) (SUB : A × B ⊆ (fun x y : actid => loc' x = loc' y)) : B × A ⊆ (fun x y : actid => loc' x = loc' y).","conclusion":"B × A ⊆ (fun x y : actid => loc' x = loc' y)","hypotheses":"(A B : actid -> Prop) (SUB : A × B ⊆ (fun x y : actid => loc' x = loc' y))","proofString":"unfolder in *.\nins.\ndesf.\nsymmetry.\neauto."},{"statement":"(A B : actid -> Prop) (SUB : forall x y : actid, A x /\\ B y -> loc' x = loc' y) : forall x y : actid, B x /\\ A y -> loc' x = loc' y.","conclusion":"forall x y : actid, B x /\\ A y -> loc' x = loc' y","hypotheses":"(A B : actid -> Prop) (SUB : forall x y : actid, A x /\\ B y -> loc' x = loc' y)","proofString":"ins.\ndesf.\nsymmetry.\neauto."},{"statement":"(A B : actid -> Prop) (SUB : forall x0 y0 : actid, A x0 /\\ B y0 -> loc' x0 = loc' y0) (x y : actid) (H : B x /\\ A y) : loc' x = loc' y.","conclusion":"loc' x = loc' y","hypotheses":"(A B : actid -> Prop) (SUB : forall x0 y0 : actid, A x0 /\\ B y0 -> loc' x0 = loc' y0) (x y : actid) (H : B x /\\ A y)","proofString":"desf.\nsymmetry.\neauto."},{"statement":"(A B : actid -> Prop) (SUB : forall x0 y0 : actid, A x0 /\\ B y0 -> loc' x0 = loc' y0) (x y : actid) (H : B x) (H0 : A y) : loc' x = loc' y.","conclusion":"loc' x = loc' y","hypotheses":"(A B : actid -> Prop) (SUB : forall x0 y0 : actid, A x0 /\\ B y0 -> loc' x0 = loc' y0) (x y : actid) (H : B x) (H0 : A y)","proofString":"symmetry.\neauto."},{"statement":"(A B : actid -> Prop) (SUB : forall x0 y0 : actid, A x0 /\\ B y0 -> loc' x0 = loc' y0) (x y : actid) (H : B x) (H0 : A y) : loc' y = loc' x.","conclusion":"loc' y = loc' x","hypotheses":"(A B : actid -> Prop) (SUB : forall x0 y0 : actid, A x0 /\\ B y0 -> loc' x0 = loc' y0) (x y : actid) (H : B x) (H0 : A y)","proofString":"eauto."},{"statement":"(A : Type) (B : Type) (f : A -> B) (s1 s2 : A -> Prop) (FUN : forall a b : A, s1 a /\\ s2 b -> f a = f b) : forall a b : A, s2 a /\\ s1 b -> f a = f b.","conclusion":"forall a b : A, s2 a /\\ s1 b -> f a = f b","hypotheses":"(A : Type) (B : Type) (f : A -> B) (s1 s2 : A -> Prop) (FUN : forall a b : A, s1 a /\\ s2 b -> f a = f b)","proofString":"ins.\ndesf.\nsymmetry.\neauto."},{"statement":"(A : Type) (B : Type) (f : A -> B) (s1 s2 : A -> Prop) (FUN : forall a0 b0 : A, s1 a0 /\\ s2 b0 -> f a0 = f b0) (a b : A) (H : s2 a /\\ s1 b) : f a = f b.","conclusion":"f a = f b","hypotheses":"(A : Type) (B : Type) (f : A -> B) (s1 s2 : A -> Prop) (FUN : forall a0 b0 : A, s1 a0 /\\ s2 b0 -> f a0 = f b0) (a b : A) (H : s2 a /\\ s1 b)","proofString":"desf.\nsymmetry.\neauto."},{"statement":"(A : Type) (B : Type) (f : A -> B) (s1 s2 : A -> Prop) (FUN : forall a0 b0 : A, s1 a0 /\\ s2 b0 -> f a0 = f b0) (a b : A) (H : s2 a) (H0 : s1 b) : f a = f b.","conclusion":"f a = f b","hypotheses":"(A : Type) (B : Type) (f : A -> B) (s1 s2 : A -> Prop) (FUN : forall a0 b0 : A, s1 a0 /\\ s2 b0 -> f a0 = f b0) (a b : A) (H : s2 a) (H0 : s1 b)","proofString":"symmetry.\neauto."},{"statement":"(A : Type) (B : Type) (f : A -> B) (s1 s2 : A -> Prop) (FUN : forall a0 b0 : A, s1 a0 /\\ s2 b0 -> f a0 = f b0) (a b : A) (H : s2 a) (H0 : s1 b) : f b = f a.","conclusion":"f b = f a","hypotheses":"(A : Type) (B : Type) (f : A -> B) (s1 s2 : A -> Prop) (FUN : forall a0 b0 : A, s1 a0 /\\ s2 b0 -> f a0 = f b0) (a b : A) (H : s2 a) (H0 : s1 b)","proofString":"eauto."},{"statement":"(r : relation actid) (SUB : r\n⊆ (fun x y : actid =>\n   match lab' x with\n   | Aload _ _ _ v | Astore _ _ _ v => Some v\n   | Afence _ => None\n   end =\n   match lab' y with\n   | Aload _ _ _ v | Astore _ _ _ v => Some v\n   | Afence _ => None\n   end)) : funeq\n  (fun a : actid =>\n   match lab' a with\n   | Aload _ _ _ v | Astore _ _ _ v => Some v\n   | Afence _ => None\n   end) r.","conclusion":"funeq\n  (fun a : actid =>\n   match lab' a with\n   | Aload _ _ _ v | Astore _ _ _ v => Some v\n   | Afence _ => None\n   end) r","hypotheses":"(r : relation actid) (SUB : r\n⊆ (fun x y : actid =>\n   match lab' x with\n   | Aload _ _ _ v | Astore _ _ _ v => Some v\n   | Afence _ => None\n   end =\n   match lab' y with\n   | Aload _ _ _ v | Astore _ _ _ v => Some v\n   | Afence _ => None\n   end))","proofString":"unfolder in *.\nins."},{"statement":"(r : relation actid) (SUB : forall x y : actid,\nr x y ->\nmatch lab' x with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab' y with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend) : forall a b : actid,\nr a b ->\nmatch lab' a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab' b with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"forall a b : actid,\nr a b ->\nmatch lab' a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab' b with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(r : relation actid) (SUB : forall x y : actid,\nr x y ->\nmatch lab' x with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab' y with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend)","proofString":"ins."}]}