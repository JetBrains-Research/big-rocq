{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Cstrategy.v","fileSamples":[{"statement":"(s s' : state) (H : safe s) (H0 : star Csem.step ge s E0 s') (s'0 : state) (H1 : star Csem.step ge s' E0 s'0) : (exists r : int, final_state s'0 r) \\/\n(exists (t : trace) (s'' : state), Csem.step ge s'0 t s'').","conclusion":"(exists r : int, final_state s'0 r) \\/\n(exists (t : trace) (s'' : state), Csem.step ge s'0 t s'')","hypotheses":"(s s' : state) (H : safe s) (H0 : star Csem.step ge s E0 s') (s'0 : state) (H1 : star Csem.step ge s' E0 s'0)","proofString":"eapply H.\neapply star_trans; eauto."},{"statement":"(s s' : state) (H : safe s) (H0 : star Csem.step ge s E0 s') (s'0 : state) (H1 : star Csem.step ge s' E0 s'0) : star Csem.step ge s E0 s'0.","conclusion":"star Csem.step ge s E0 s'0","hypotheses":"(s s' : state) (H : safe s) (H0 : star Csem.step ge s E0 s') (s'0 : state) (H1 : star Csem.step ge s' E0 s'0)","proofString":"eapply star_trans; eauto."},{"statement":"(s1 s2 : state) (t : trace) (s3 : state) (H : safe s1) (H0 : star Csem.step ge s1 E0 s2) (H1 : safe s2 -> star Csem.step ge s2 t s3) : star Csem.step ge s1 t s3.","conclusion":"star Csem.step ge s1 t s3","hypotheses":"(s1 s2 : state) (t : trace) (s3 : state) (H : safe s1) (H0 : star Csem.step ge s1 E0 s2) (H1 : safe s2 -> star Csem.step ge s2 t s3)","proofString":"eapply star_trans; eauto.\napply H1.\neapply safe_steps; eauto.\nauto."},{"statement":"(s1 s2 : state) (t : trace) (s3 : state) (H : safe s1) (H0 : star Csem.step ge s1 E0 s2) (H1 : safe s2 -> star Csem.step ge s2 t s3) : safe s2.","conclusion":"safe s2","hypotheses":"(s1 s2 : state) (t : trace) (s3 : state) (H : safe s1) (H0 : star Csem.step ge s1 E0 s2) (H1 : safe s2 -> star Csem.step ge s2 t s3)","proofString":"eapply safe_steps; eauto."},{"statement":"(s1 s2 : state) (t : trace) (s3 : state) (H : safe s1) (H0 : star Csem.step ge s1 E0 s2) (H1 : safe s2 -> plus Csem.step ge s2 t s3) : plus Csem.step ge s1 t s3.","conclusion":"plus Csem.step ge s1 t s3","hypotheses":"(s1 s2 : state) (t : trace) (s3 : state) (H : safe s1) (H0 : star Csem.step ge s1 E0 s2) (H1 : safe s2 -> plus Csem.step ge s2 t s3)","proofString":"eapply star_plus_trans; eauto.\napply H1.\neapply safe_steps; eauto.\nauto."},{"statement":"(s1 s2 : state) (t : trace) (s3 : state) (H : safe s1) (H0 : star Csem.step ge s1 E0 s2) (H1 : safe s2 -> plus Csem.step ge s2 t s3) : safe s2.","conclusion":"safe s2","hypotheses":"(s1 s2 : state) (t : trace) (s3 : state) (H : safe s1) (H0 : star Csem.step ge s1 E0 s2) (H1 : safe s2 -> plus Csem.step ge s2 t s3)","proofString":"eapply safe_steps; eauto."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) : imm_safe ge e K a m.","conclusion":"imm_safe ge e K a m","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C)","proofString":"destruct (classic (imm_safe ge e K a m)); auto.\ndestruct (H Stuckstate).\napply star_one.\nleft.\neconstructor; eauto.\ndestruct H2 as [r F].\ninv F.\ndestruct H2 as [t [s' S]].\ninv S.\ninv H2.\ninv H2."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) : imm_safe ge e K a m.","conclusion":"imm_safe ge e K a m","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m)","proofString":"destruct (H Stuckstate).\napply star_one.\nleft.\neconstructor; eauto.\ndestruct H2 as [r F].\ninv F.\ndestruct H2 as [t [s' S]].\ninv S.\ninv H2.\ninv H2."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) : star Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate.","conclusion":"star Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m)","proofString":"apply star_one.\nleft.\neconstructor; eauto."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) : Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate.","conclusion":"Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m)","proofString":"left.\neconstructor; eauto."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) : Csem.estep ge (ExprState f (C a) k e m) E0 Stuckstate.","conclusion":"Csem.estep ge (ExprState f (C a) k e m) E0 Stuckstate","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m)","proofString":"econstructor; eauto."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (H2 : exists r : int, final_state Stuckstate r) : imm_safe ge e K a m.","conclusion":"imm_safe ge e K a m","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (H2 : exists r : int, final_state Stuckstate r)","proofString":"destruct H2 as [r F].\ninv F."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (r : int) (F : final_state Stuckstate r) : imm_safe ge e K a m.","conclusion":"imm_safe ge e K a m","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (r : int) (F : final_state Stuckstate r)","proofString":"inv F."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (H2 : exists (t : trace) (s'' : state), Csem.step ge Stuckstate t s'') : imm_safe ge e K a m.","conclusion":"imm_safe ge e K a m","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (H2 : exists (t : trace) (s'' : state), Csem.step ge Stuckstate t s'')","proofString":"destruct H2 as [t [s' S]].\ninv S.\ninv H2.\ninv H2."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (t : trace) (s' : state) (S : Csem.step ge Stuckstate t s') : imm_safe ge e K a m.","conclusion":"imm_safe ge e K a m","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (t : trace) (s' : state) (S : Csem.step ge Stuckstate t s')","proofString":"inv S.\ninv H2.\ninv H2."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (t : trace) (s' : state) (H2 : Csem.estep ge Stuckstate t s') : imm_safe ge e K a m.","conclusion":"imm_safe ge e K a m","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (t : trace) (s' : state) (H2 : Csem.estep ge Stuckstate t s')","proofString":"inv H2."},{"statement":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (t : trace) (s' : state) (H2 : sstep ge Stuckstate t s') : imm_safe ge e K a m.","conclusion":"imm_safe ge e K a m","hypotheses":"(f : function) (C : expr -> expr) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : safe (ExprState f (C a) k e m)) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (t : trace) (s' : state) (H2 : sstep ge Stuckstate t s')","proofString":"inv H2."},{"statement":"(e : env) (v : val) (ty : type) (m : mem) : expr_kind (Eval v ty) = RV.","conclusion":"expr_kind (Eval v ty) = RV","hypotheses":"(e : env) (v : val) (ty : type) (m : mem)","proofString":"auto."},{"statement":"(e : env) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) : expr_kind (Eloc b ofs bf ty) = LV.","conclusion":"expr_kind (Eloc b ofs bf ty) = LV","hypotheses":"(e : env) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem)","proofString":"auto."},{"statement":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (e' : expr) (m' : mem) (H : lred ge e e0 m e' m') (H0 : context LV to C) : expr_kind (C e0) = to.","conclusion":"expr_kind (C e0) = to","hypotheses":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (e' : expr) (m' : mem) (H : lred ge e e0 m e' m') (H0 : context LV to C)","proofString":"eapply context_kind; eauto.\neapply lred_kind; eauto."},{"statement":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (e' : expr) (m' : mem) (H : lred ge e e0 m e' m') (H0 : context LV to C) : expr_kind e0 = LV.","conclusion":"expr_kind e0 = LV","hypotheses":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (e' : expr) (m' : mem) (H : lred ge e e0 m e' m') (H0 : context LV to C)","proofString":"eapply lred_kind; eauto."},{"statement":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (t : trace) (e' : expr) (m' : mem) (H : rred ge e0 m t e' m') (H0 : context RV to C) : expr_kind (C e0) = to.","conclusion":"expr_kind (C e0) = to","hypotheses":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (t : trace) (e' : expr) (m' : mem) (H : rred ge e0 m t e' m') (H0 : context RV to C)","proofString":"eapply context_kind; eauto.\neapply rred_kind; eauto."},{"statement":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (t : trace) (e' : expr) (m' : mem) (H : rred ge e0 m t e' m') (H0 : context RV to C) : expr_kind e0 = RV.","conclusion":"expr_kind e0 = RV","hypotheses":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (t : trace) (e' : expr) (m' : mem) (H : rred ge e0 m t e' m') (H0 : context RV to C)","proofString":"eapply rred_kind; eauto."},{"statement":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (fd : fundef) (args : list val) (ty : type) (H : callred ge e0 m fd args ty) (H0 : context RV to C) : expr_kind (C e0) = to.","conclusion":"expr_kind (C e0) = to","hypotheses":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (fd : fundef) (args : list val) (ty : type) (H : callred ge e0 m fd args ty) (H0 : context RV to C)","proofString":"eapply context_kind; eauto.\neapply callred_kind; eauto."},{"statement":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (fd : fundef) (args : list val) (ty : type) (H : callred ge e0 m fd args ty) (H0 : context RV to C) : expr_kind e0 = RV.","conclusion":"expr_kind e0 = RV","hypotheses":"(e : env) (to : kind) (C : expr -> expr) (e0 : expr) (m : mem) (fd : fundef) (args : list val) (ty : type) (H : callred ge e0 m fd args ty) (H0 : context RV to C)","proofString":"eapply callred_kind; eauto."},{"statement":"(from : kind) (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : context from RV C) (H0 : safe (ExprState f (C a) k e m)) : expr_kind a = from.","conclusion":"expr_kind a = from","hypotheses":"(from : kind) (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : context from RV C) (H0 : safe (ExprState f (C a) k e m))","proofString":"eapply imm_safe_kind.\neapply safe_imm_safe; eauto."},{"statement":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty)) : exists b0 : block,\n  e ! x = Some (b0, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b0.","conclusion":"exists b0 : block,\n  e ! x = Some (b0, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b0","hypotheses":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty))","proofString":"exists b; auto."},{"statement":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = None) (H0 : Genv.find_symbol ge x = Some b) : exists b0 : block,\n  e ! x = Some (b0, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b0.","conclusion":"exists b0 : block,\n  e ! x = Some (b0, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b0","hypotheses":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = None) (H0 : Genv.find_symbol ge x = Some b)","proofString":"exists b; auto."},{"statement":"(b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem) : exists (b0 : block) (ofs0 : ptrofs), Vptr b ofs = Vptr b0 ofs0.","conclusion":"exists (b0 : block) (ofs0 : ptrofs), Vptr b ofs = Vptr b0 ofs0","hypotheses":"(b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem)","proofString":"exists b; exists ofs; auto."},{"statement":"(b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) : ty = ty /\\ (exists (t0 : trace) (v0 : val), deref_loc ge ty m b ofs bf t0 v0).","conclusion":"ty = ty /\\ (exists (t0 : trace) (v0 : val), deref_loc ge ty m b ofs bf t0 v0)","hypotheses":"(b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v)","proofString":"split; auto; exists t; exists v; auto."},{"statement":"(op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) : exists v0 : val, sem_unary_operation op v1 ty1 m = Some v0.","conclusion":"exists v0 : val, sem_unary_operation op v1 ty1 m = Some v0","hypotheses":"(op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v)","proofString":"exists v; auto."},{"statement":"(op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) : exists v0 : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v0.","conclusion":"exists v0 : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v0","hypotheses":"(op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v)","proofString":"exists v; auto."},{"statement":"(ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) : exists v0 : val, sem_cast v1 ty1 ty m = Some v0.","conclusion":"exists v0 : val, sem_cast v1 ty1 ty m = Some v0","hypotheses":"(ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v)","proofString":"exists v; auto."},{"statement":"(v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) : exists b : bool, bool_val v1 ty1 m = Some b.","conclusion":"exists b : bool, bool_val v1 ty1 m = Some b","hypotheses":"(v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true)","proofString":"exists true; auto."},{"statement":"(v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) : exists b : bool, bool_val v1 ty1 m = Some b.","conclusion":"exists b : bool, bool_val v1 ty1 m = Some b","hypotheses":"(v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false)","proofString":"exists false; auto."},{"statement":"(v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) : exists b : bool, bool_val v1 ty1 m = Some b.","conclusion":"exists b : bool, bool_val v1 ty1 m = Some b","hypotheses":"(v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true)","proofString":"exists true; auto."},{"statement":"(v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) : exists b : bool, bool_val v1 ty1 m = Some b.","conclusion":"exists b : bool, bool_val v1 ty1 m = Some b","hypotheses":"(v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false)","proofString":"exists false; auto."},{"statement":"(v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) : exists b0 : bool, bool_val v1 ty1 m = Some b0.","conclusion":"exists b0 : bool, bool_val v1 ty1 m = Some b0","hypotheses":"(v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b)","proofString":"exists b; auto."},{"statement":"(b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') : exists (v0 : val) (m'0 : mem) (v'0 : val) (t0 : trace),\n  ty1 = ty1 /\\\n  sem_cast v2 ty2 ty1 m = Some v0 /\\\n  assign_loc ge ty1 m b ofs bf v0 t0 m'0 v'0.","conclusion":"exists (v0 : val) (m'0 : mem) (v'0 : val) (t0 : trace),\n  ty1 = ty1 /\\\n  sem_cast v2 ty2 ty1 m = Some v0 /\\\n  assign_loc ge ty1 m b ofs bf v0 t0 m'0 v'0","hypotheses":"(b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v')","proofString":"exists v; exists m'; exists v'; exists t; auto."},{"statement":"(op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) : exists (t0 : trace) (v0 : val),\n  ty1 = ty1 /\\ deref_loc ge ty1 m b ofs bf t0 v0.","conclusion":"exists (t0 : trace) (v0 : val),\n  ty1 = ty1 /\\ deref_loc ge ty1 m b ofs bf t0 v0","hypotheses":"(op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1)","proofString":"exists t; exists v1; auto."},{"statement":"(id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) : exists (t0 : trace) (v0 : val), ty = ty /\\ deref_loc ge ty m b ofs bf t0 v0.","conclusion":"exists (t0 : trace) (v0 : val), ty = ty /\\ deref_loc ge ty m b ofs bf t0 v0","hypotheses":"(id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end)","proofString":"exists t; exists v1; auto."},{"statement":"(v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) : exists v0 : val, sem_cast v1 ty1 ty2 m = Some v0.","conclusion":"exists v0 : val, sem_cast v1 ty1 ty2 m = Some v0","hypotheses":"(v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v)","proofString":"exists v; auto."},{"statement":"(ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') : exprlist_all_values el ->\nexists (vargs0 : list val) (t0 : trace) (vres0 : val) \n(m'0 : mem),\n  cast_arguments m el tyargs vargs0 /\\\n  external_call ef ge vargs0 m t0 vres0 m'0.","conclusion":"exprlist_all_values el ->\nexists (vargs0 : list val) (t0 : trace) (vres0 : val) \n(m'0 : mem),\n  cast_arguments m el tyargs vargs0 /\\\n  external_call ef ge vargs0 m t0 vres0 m'0","hypotheses":"(ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m')","proofString":"intros.\nexists vargs; exists t; exists vres; exists m'; auto."},{"statement":"(ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : exprlist_all_values el) : exists (vargs0 : list val) (t0 : trace) (vres0 : val) \n(m'0 : mem),\n  cast_arguments m el tyargs vargs0 /\\\n  external_call ef ge vargs0 m t0 vres0 m'0.","conclusion":"exists (vargs0 : list val) (t0 : trace) (vres0 : val) \n(m'0 : mem),\n  cast_arguments m el tyargs vargs0 /\\\n  external_call ef ge vargs0 m t0 vres0 m'0","hypotheses":"(ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : exprlist_all_values el)","proofString":"exists vargs; exists t; exists vres; exists m'; auto."},{"statement":"(r : expr) (fd : fundef) (args : list val) (ty : type) (m : mem) (H : callred ge r m fd args ty) : invert_expr_prop r m.","conclusion":"invert_expr_prop r m","hypotheses":"(r : expr) (fd : fundef) (args : list val) (ty : type) (m : mem) (H : callred ge r m fd args ty)","proofString":"inv H.\nsimpl.\nintros.\nexists tyargs, tyres, cconv, fd, args; auto."},{"statement":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv) : invert_expr_prop (Ecall (Eval vf tyf) el ty) m.","conclusion":"invert_expr_prop (Ecall (Eval vf tyf) el ty) m","hypotheses":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv)","proofString":"simpl.\nintros.\nexists tyargs, tyres, cconv, fd, args; auto."},{"statement":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv) : exprlist_all_values el ->\nexists\n  (tyargs0 : list type) (tyres0 : type) (cconv0 : calling_convention) \n(fd0 : fundef) (vl : list val),\n  classify_fun tyf = fun_case_f tyargs0 tyres0 cconv0 /\\\n  Genv.find_funct ge vf = Some fd0 /\\\n  cast_arguments m el tyargs0 vl /\\\n  type_of_fundef fd0 = Tfunction tyargs0 tyres0 cconv0.","conclusion":"exprlist_all_values el ->\nexists\n  (tyargs0 : list type) (tyres0 : type) (cconv0 : calling_convention) \n(fd0 : fundef) (vl : list val),\n  classify_fun tyf = fun_case_f tyargs0 tyres0 cconv0 /\\\n  Genv.find_funct ge vf = Some fd0 /\\\n  cast_arguments m el tyargs0 vl /\\\n  type_of_fundef fd0 = Tfunction tyargs0 tyres0 cconv0","hypotheses":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv)","proofString":"intros.\nexists tyargs, tyres, cconv, fd, args; auto."},{"statement":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv) (H : exprlist_all_values el) : exists\n  (tyargs0 : list type) (tyres0 : type) (cconv0 : calling_convention) \n(fd0 : fundef) (vl : list val),\n  classify_fun tyf = fun_case_f tyargs0 tyres0 cconv0 /\\\n  Genv.find_funct ge vf = Some fd0 /\\\n  cast_arguments m el tyargs0 vl /\\\n  type_of_fundef fd0 = Tfunction tyargs0 tyres0 cconv0.","conclusion":"exists\n  (tyargs0 : list type) (tyres0 : type) (cconv0 : calling_convention) \n(fd0 : fundef) (vl : list val),\n  classify_fun tyf = fun_case_f tyargs0 tyres0 cconv0 /\\\n  Genv.find_funct ge vf = Some fd0 /\\\n  cast_arguments m el tyargs0 vl /\\\n  type_of_fundef fd0 = Tfunction tyargs0 tyres0 cconv0","hypotheses":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv) (H : exprlist_all_values el)","proofString":"exists tyargs, tyres, cconv, fd, args; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : invert_expr_prop a m) : invert_expr_prop a m.","conclusion":"invert_expr_prop a m","hypotheses":"(k : kind) (a : expr) (m : mem) (H : invert_expr_prop a m)","proofString":"auto."},{"statement":"(k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v _ => exists (b : block) (ofs : ptrofs), v = Vptr b ofs\n| _ => True\nend.","conclusion":"match C a with\n| Eval v _ => exists (b : block) (ofs : ptrofs), v = Vptr b ofs\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc b ofs bf ty' =>\n    ty' = ty /\\\n    (exists (t : trace) (v : val), deref_loc ge ty m b ofs bf t v)\n| _ => True\nend.","conclusion":"match C a with\n| Eloc b ofs bf ty' =>\n    ty' = ty /\\\n    (exists (t : trace) (v : val), deref_loc ge ty m b ofs bf t v)\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc _ _ bf _ => bf = Full\n| _ => True\nend.","conclusion":"match C a with\n| Eloc _ _ bf _ => bf = Full\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : unary_operation) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists v : val, sem_unary_operation op v1 ty1 m = Some v\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists v : val, sem_unary_operation op v1 ty1 m = Some v\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : unary_operation) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 =>\n    match e2 with\n    | Eval v2 ty2 =>\n        exists v : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 =>\n    match e2 with\n    | Eval v2 ty2 =>\n        exists v : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match e1 with\n| Eval v1 ty1 =>\n    match C a with\n    | Eval v2 ty2 =>\n        exists v : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match e1 with\n| Eval v1 ty1 =>\n    match C a with\n    | Eval v2 ty2 =>\n        exists v : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct e1; auto; destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists v : val, sem_cast v1 ty1 ty m = Some v\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists v : val, sem_cast v1 ty1 ty m = Some v\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc b ofs bf ty1 =>\n    match e2 with\n    | Eval v2 ty2 =>\n        exists (v : val) (m' : mem) (v' : val) (t : trace),\n          ty = ty1 /\\\n          sem_cast v2 ty2 ty1 m = Some v /\\\n          assign_loc ge ty1 m b ofs bf v t m' v'\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match C a with\n| Eloc b ofs bf ty1 =>\n    match e2 with\n    | Eval v2 ty2 =>\n        exists (v : val) (m' : mem) (v' : val) (t : trace),\n          ty = ty1 /\\\n          sem_cast v2 ty2 ty1 m = Some v /\\\n          assign_loc ge ty1 m b ofs bf v t m' v'\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (e1 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match e1 with\n| Eloc b ofs bf ty1 =>\n    match C a with\n    | Eval v2 ty2 =>\n        exists (v : val) (m' : mem) (v' : val) (t : trace),\n          ty = ty1 /\\\n          sem_cast v2 ty2 ty1 m = Some v /\\\n          assign_loc ge ty1 m b ofs bf v t m' v'\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match e1 with\n| Eloc b ofs bf ty1 =>\n    match C a with\n    | Eval v2 ty2 =>\n        exists (v : val) (m' : mem) (v' : val) (t : trace),\n          ty = ty1 /\\\n          sem_cast v2 ty2 ty1 m = Some v /\\\n          assign_loc ge ty1 m b ofs bf v t m' v'\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (e1 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct e1; auto; destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (tyres ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc b ofs bf ty1 =>\n    match e2 with\n    | Eval _ _ =>\n        exists (t : trace) (v1 : val),\n          ty = ty1 /\\ deref_loc ge ty1 m b ofs bf t v1\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match C a with\n| Eloc b ofs bf ty1 =>\n    match e2 with\n    | Eval _ _ =>\n        exists (t : trace) (v1 : val),\n          ty = ty1 /\\ deref_loc ge ty1 m b ofs bf t v1\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (tyres ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (tyres ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match e1 with\n| Eloc b ofs bf ty1 =>\n    match C a with\n    | Eval _ _ =>\n        exists (t : trace) (v1 : val),\n          ty = ty1 /\\ deref_loc ge ty1 m b ofs bf t v1\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match e1 with\n| Eloc b ofs bf ty1 =>\n    match C a with\n    | Eval _ _ =>\n        exists (t : trace) (v1 : val),\n          ty = ty1 /\\ deref_loc ge ty1 m b ofs bf t v1\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (tyres ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct e1; auto; destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (id : incr_or_decr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc b ofs bf ty1 =>\n    exists (t : trace) (v1 : val),\n      ty = ty1 /\\ deref_loc ge ty m b ofs bf t v1\n| _ => True\nend.","conclusion":"match C a with\n| Eloc b ofs bf ty1 =>\n    exists (t : trace) (v1 : val),\n      ty = ty1 /\\ deref_loc ge ty m b ofs bf t v1\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (id : incr_or_decr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval vf tyf =>\n    exprlist_all_values el ->\n    exists\n      (tyargs : list type) (tyres : type) (cconv : calling_convention) \n    (fd : fundef) (vl : list val),\n      classify_fun tyf = fun_case_f tyargs tyres cconv /\\\n      Genv.find_funct ge vf = Some fd /\\\n      cast_arguments m el tyargs vl /\\\n      type_of_fundef fd = Tfunction tyargs tyres cconv\n| _ => True\nend.","conclusion":"match C a with\n| Eval vf tyf =>\n    exprlist_all_values el ->\n    exists\n      (tyargs : list type) (tyres : type) (cconv : calling_convention) \n    (fd : fundef) (vl : list val),\n      classify_fun tyf = fun_case_f tyargs tyres cconv /\\\n      Genv.find_funct ge vf = Some fd /\\\n      cast_arguments m el tyargs vl /\\\n      type_of_fundef fd = Tfunction tyargs tyres cconv\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> exprlist) (e1 : expr) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) : match e1 with\n| Eval vf tyf =>\n    exprlist_all_values (C a) ->\n    exists\n      (tyargs : list type) (tyres : type) (cconv : calling_convention) \n    (fd : fundef) (vl : list val),\n      classify_fun tyf = fun_case_f tyargs tyres cconv /\\\n      Genv.find_funct ge vf = Some fd /\\\n      cast_arguments m (C a) tyargs vl /\\\n      type_of_fundef fd = Tfunction tyargs tyres cconv\n| _ => True\nend.","conclusion":"match e1 with\n| Eval vf tyf =>\n    exprlist_all_values (C a) ->\n    exists\n      (tyargs : list type) (tyres : type) (cconv : calling_convention) \n    (fd : fundef) (vl : list val),\n      classify_fun tyf = fun_case_f tyargs tyres cconv /\\\n      Genv.find_funct ge vf = Some fd /\\\n      cast_arguments m (C a) tyargs vl /\\\n      type_of_fundef fd = Tfunction tyargs tyres cconv\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> exprlist) (e1 : expr) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m)","proofString":"destruct e1; auto.\nintros.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (v : val) (ty0 ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) : exprlist_all_values (C a) ->\nexists\n  (tyargs : list type) (tyres : type) (cconv : calling_convention) \n(fd : fundef) (vl : list val),\n  classify_fun ty0 = fun_case_f tyargs tyres cconv /\\\n  Genv.find_funct ge v = Some fd /\\\n  cast_arguments m (C a) tyargs vl /\\\n  type_of_fundef fd = Tfunction tyargs tyres cconv.","conclusion":"exprlist_all_values (C a) ->\nexists\n  (tyargs : list type) (tyres : type) (cconv : calling_convention) \n(fd : fundef) (vl : list val),\n  classify_fun ty0 = fun_case_f tyargs tyres cconv /\\\n  Genv.find_funct ge v = Some fd /\\\n  cast_arguments m (C a) tyargs vl /\\\n  type_of_fundef fd = Tfunction tyargs tyres cconv","hypotheses":"(k : kind) (C : expr -> exprlist) (v : val) (ty0 ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m)","proofString":"intros.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (v : val) (ty0 ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a)) : exists\n  (tyargs : list type) (tyres : type) (cconv : calling_convention) \n(fd : fundef) (vl : list val),\n  classify_fun ty0 = fun_case_f tyargs tyres cconv /\\\n  Genv.find_funct ge v = Some fd /\\\n  cast_arguments m (C a) tyargs vl /\\\n  type_of_fundef fd = Tfunction tyargs tyres cconv.","conclusion":"exists\n  (tyargs : list type) (tyres : type) (cconv : calling_convention) \n(fd : fundef) (vl : list val),\n  classify_fun ty0 = fun_case_f tyargs tyres cconv /\\\n  Genv.find_funct ge v = Some fd /\\\n  cast_arguments m (C a) tyargs vl /\\\n  type_of_fundef fd = Tfunction tyargs tyres cconv","hypotheses":"(k : kind) (C : expr -> exprlist) (v : val) (ty0 ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a))","proofString":"elim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) : exprlist_all_values (C a) ->\nexists (vargs : list val) (t : trace) (vres : val) \n(m' : mem),\n  cast_arguments m (C a) tyargs vargs /\\\n  external_call ef ge vargs m t vres m'.","conclusion":"exprlist_all_values (C a) ->\nexists (vargs : list val) (t : trace) (vres : val) \n(m' : mem),\n  cast_arguments m (C a) tyargs vargs /\\\n  external_call ef ge vargs m t vres m'","hypotheses":"(k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m)","proofString":"intros.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a)) : exists (vargs : list val) (t : trace) (vres : val) \n(m' : mem),\n  cast_arguments m (C a) tyargs vargs /\\\n  external_call ef ge vargs m t vres m'.","conclusion":"exists (vargs : list val) (t : trace) (vres : val) \n(m' : mem),\n  cast_arguments m (C a) tyargs vargs /\\\n  external_call ef ge vargs m t vres m'","hypotheses":"(k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a))","proofString":"elim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval _ _ => typeof e2 = ty\n| _ => True\nend.","conclusion":"match C a with\n| Eval _ _ => typeof e2 = ty\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (tycast ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists v : val, sem_cast v1 ty1 tycast m = Some v\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists v : val, sem_cast v1 ty1 tycast m = Some v\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (tycast ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : ~ match C a with\n  | Eval _ _ => exprlist_all_values el\n  | _ => False\n  end.","conclusion":"~ match C a with\n  | Eval _ _ => exprlist_all_values el\n  | _ => False\n  end","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"red; intros.\ndestruct (C a); auto."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) (H3 : match C a with\n| Eval _ _ => exprlist_all_values el\n| _ => False\nend) : False.","conclusion":"False","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) (H3 : match C a with\n| Eval _ _ => exprlist_all_values el\n| _ => False\nend)","proofString":"destruct (C a); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) : ~ match e1 with\n  | Eval _ _ => exprlist_all_values (C a)\n  | _ => False\n  end.","conclusion":"~ match e1 with\n  | Eval _ _ => exprlist_all_values (C a)\n  | _ => False\n  end","hypotheses":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m)","proofString":"red; intros.\ndestruct e1; auto.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : match e1 with\n| Eval _ _ => exprlist_all_values (C a)\n| _ => False\nend) : False.","conclusion":"False","hypotheses":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : match e1 with\n| Eval _ _ => exprlist_all_values (C a)\n| _ => False\nend)","proofString":"destruct e1; auto.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (v : val) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a)) : False.","conclusion":"False","hypotheses":"(k : kind) (C : expr -> exprlist) (v : val) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a))","proofString":"elim (H0 a m); auto."},{"statement":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m : mem), invert_expr_prop a m -> invert_expr_prop (C a) m) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m : mem),\ninvert_expr_prop a m -> ~ exprlist_all_values (C a)) : forall (k : kind) (a : expr) (m : mem),\nimm_safe ge e k a m ->\nmatch a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend.","conclusion":"forall (k : kind) (a : expr) (m : mem),\nimm_safe ge e k a m ->\nmatch a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend","hypotheses":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m : mem), invert_expr_prop a m -> invert_expr_prop (C a) m) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m : mem),\ninvert_expr_prop a m -> ~ exprlist_all_values (C a))","proofString":"intros.\ninv H.\nauto.\nauto.\nassert (invert_expr_prop (C e0) m).\neapply A; eauto.\neapply lred_invert; eauto.\nred in H.\ndestruct (C e0); auto; contradiction.\nassert (invert_expr_prop (C e0) m).\neapply A; eauto.\neapply rred_invert; eauto.\nred in H.\ndestruct (C e0); auto; contradiction.\nassert (invert_expr_prop (C e0) m).\neapply A; eauto.\neapply callred_invert; eauto.\nred in H.\ndestruct (C e0); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (k : kind) (a : expr) (m : mem) (H : imm_safe ge e k a m) : match a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend.","conclusion":"match a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend","hypotheses":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (k : kind) (a : expr) (m : mem) (H : imm_safe ge e k a m)","proofString":"inv H.\nauto.\nauto.\nassert (invert_expr_prop (C e0) m).\neapply A; eauto.\neapply lred_invert; eauto.\nred in H.\ndestruct (C e0); auto; contradiction.\nassert (invert_expr_prop (C e0) m).\neapply A; eauto.\neapply rred_invert; eauto.\nred in H.\ndestruct (C e0); auto; contradiction.\nassert (invert_expr_prop (C e0) m).\neapply A; eauto.\neapply callred_invert; eauto.\nred in H.\ndestruct (C e0); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C a) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C a)) (m : mem) (v : val) (ty : type) : True.","conclusion":"True","hypotheses":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C a) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C a)) (m : mem) (v : val) (ty : type)","proofString":"auto."},{"statement":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C a) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C a)) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) : True.","conclusion":"True","hypotheses":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C a) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C a)) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type)","proofString":"auto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C) : match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend.","conclusion":"match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C)","proofString":"assert (invert_expr_prop (C e0) m).\neapply A; eauto.\neapply lred_invert; eauto.\nred in H.\ndestruct (C e0); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C) : invert_expr_prop (C e0) m.","conclusion":"invert_expr_prop (C e0) m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C)","proofString":"eapply A; eauto.\neapply lred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C) : invert_expr_prop e0 m.","conclusion":"invert_expr_prop e0 m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C)","proofString":"eapply lred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C) (H : invert_expr_prop (C e0) m) : match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend.","conclusion":"match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C) (H : invert_expr_prop (C e0) m)","proofString":"red in H.\ndestruct (C e0); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) : match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend.","conclusion":"match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C)","proofString":"assert (invert_expr_prop (C e0) m).\neapply A; eauto.\neapply rred_invert; eauto.\nred in H.\ndestruct (C e0); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) : invert_expr_prop (C e0) m.","conclusion":"invert_expr_prop (C e0) m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C)","proofString":"eapply A; eauto.\neapply rred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) : invert_expr_prop e0 m.","conclusion":"invert_expr_prop e0 m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C)","proofString":"eapply rred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (H : invert_expr_prop (C e0) m) : match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend.","conclusion":"match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (H : invert_expr_prop (C e0) m)","proofString":"red in H.\ndestruct (C e0); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C) : match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend.","conclusion":"match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C)","proofString":"assert (invert_expr_prop (C e0) m).\neapply A; eauto.\neapply callred_invert; eauto.\nred in H.\ndestruct (C e0); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C) : invert_expr_prop (C e0) m.","conclusion":"invert_expr_prop (C e0) m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C)","proofString":"eapply A; eauto.\neapply callred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C) : invert_expr_prop e0 m.","conclusion":"invert_expr_prop e0 m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C)","proofString":"eapply callred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C) (H : invert_expr_prop (C e0) m) : match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend.","conclusion":"match C e0 with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C e0) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C) (H : invert_expr_prop (C e0) m)","proofString":"red in H.\ndestruct (C e0); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (f : function) (a : expr) (K : cont) (m : mem) (H : safe (ExprState f (C a) K e m)) (H0 : context k RV C) : match a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend.","conclusion":"match a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend","hypotheses":"(k : kind) (C : expr -> expr) (f : function) (a : expr) (K : cont) (m : mem) (H : safe (ExprState f (C a) K e m)) (H0 : context k RV C)","proofString":"eapply imm_safe_inv; eauto.\neapply safe_imm_safe; eauto."},{"statement":"(v : val) (ty : type) (C : expr -> expr) (H : context RV RV C) : star Csem.step ge (ExprState f (C (Eval v ty)) k e m) E0\n  (ExprState f (C (Eval v (typeof (Eval v ty)))) k e m).","conclusion":"star Csem.step ge (ExprState f (C (Eval v ty)) k e m) E0\n  (ExprState f (C (Eval v (typeof (Eval v ty)))) k e m)","hypotheses":"(v : val) (ty : type) (C : expr -> expr) (H : context RV RV C)","proofString":"apply star_refl."},{"statement":"(b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (C : expr -> expr) (H : context LV RV C) : star Csem.step ge (ExprState f (C (Eloc b ofs bf ty)) k e m) E0\n  (ExprState f (C (Eloc b ofs bf (typeof (Eloc b ofs bf ty)))) k e m).","conclusion":"star Csem.step ge (ExprState f (C (Eloc b ofs bf ty)) k e m) E0\n  (ExprState f (C (Eloc b ofs bf (typeof (Eloc b ofs bf ty)))) k e m)","hypotheses":"(b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (C : expr -> expr) (H : context LV RV C)","proofString":"apply star_refl."},{"statement":"(C : expr -> expr) (a : expr) (v : val) (H : eval_simple_rvalue e m a v) (H0 : context RV RV C) (H1 : safe (ExprState f (C a) k e m)) : safe (ExprState f (C (Eval v (typeof a))) k e m).","conclusion":"safe (ExprState f (C (Eval v (typeof a))) k e m)","hypotheses":"(C : expr -> expr) (a : expr) (v : val) (H : eval_simple_rvalue e m a v) (H0 : context RV RV C) (H1 : safe (ExprState f (C a) k e m))","proofString":"eapply safe_steps; eauto.\neapply eval_simple_rvalue_steps; eauto."},{"statement":"(C : expr -> expr) (a : expr) (v : val) (H : eval_simple_rvalue e m a v) (H0 : context RV RV C) (H1 : safe (ExprState f (C a) k e m)) : star Csem.step ge (ExprState f (C a) k e m) E0\n  (ExprState f (C (Eval v (typeof a))) k e m).","conclusion":"star Csem.step ge (ExprState f (C a) k e m) E0\n  (ExprState f (C (Eval v (typeof a))) k e m)","hypotheses":"(C : expr -> expr) (a : expr) (v : val) (H : eval_simple_rvalue e m a v) (H0 : context RV RV C) (H1 : safe (ExprState f (C a) k e m))","proofString":"eapply eval_simple_rvalue_steps; eauto."},{"statement":"(C : expr -> expr) (a : expr) (b : block) (ofs : ptrofs) (bf : bitfield) (H : eval_simple_lvalue e m a b ofs bf) (H0 : context LV RV C) (H1 : safe (ExprState f (C a) k e m)) : safe (ExprState f (C (Eloc b ofs bf (typeof a))) k e m).","conclusion":"safe (ExprState f (C (Eloc b ofs bf (typeof a))) k e m)","hypotheses":"(C : expr -> expr) (a : expr) (b : block) (ofs : ptrofs) (bf : bitfield) (H : eval_simple_lvalue e m a b ofs bf) (H0 : context LV RV C) (H1 : safe (ExprState f (C a) k e m))","proofString":"eapply safe_steps; eauto.\neapply eval_simple_lvalue_steps; eauto."},{"statement":"(C : expr -> expr) (a : expr) (b : block) (ofs : ptrofs) (bf : bitfield) (H : eval_simple_lvalue e m a b ofs bf) (H0 : context LV RV C) (H1 : safe (ExprState f (C a) k e m)) : star Csem.step ge (ExprState f (C a) k e m) E0\n  (ExprState f (C (Eloc b ofs bf (typeof a))) k e m).","conclusion":"star Csem.step ge (ExprState f (C a) k e m) E0\n  (ExprState f (C (Eloc b ofs bf (typeof a))) k e m)","hypotheses":"(C : expr -> expr) (a : expr) (b : block) (ofs : ptrofs) (bf : bitfield) (H : eval_simple_lvalue e m a b ofs bf) (H0 : context LV RV C) (H1 : safe (ExprState f (C a) k e m))","proofString":"eapply eval_simple_lvalue_steps; eauto."},{"statement":"(v : val) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Eval v ty)) RV C) (SAFE : safe (ExprState f (C (Eval v ty)) k e m)) : exists v0 : val, eval_simple_rvalue e m (Eval v ty) v0.","conclusion":"exists v0 : val, eval_simple_rvalue e m (Eval v ty) v0","hypotheses":"(v : val) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Eval v ty)) RV C) (SAFE : safe (ExprState f (C (Eval v ty)) k e m))","proofString":"exists v; constructor."},{"statement":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) : exists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Evar x ty) b ofs bf.","conclusion":"exists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Evar x ty) b ofs bf","hypotheses":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m))","proofString":"exploit safe_inv; eauto; simpl.\nintros [b A].\nexists b, Ptrofs.zero, Full.\nintuition.\napply esl_var_local; auto.\napply esl_var_global; auto."},{"statement":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) : (exists b : block,\n   e ! x = Some (b, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b) ->\nexists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Evar x ty) b ofs bf.","conclusion":"(exists b : block,\n   e ! x = Some (b, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b) ->\nexists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Evar x ty) b ofs bf","hypotheses":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m))","proofString":"intros [b A].\nexists b, Ptrofs.zero, Full.\nintuition.\napply esl_var_local; auto.\napply esl_var_global; auto."},{"statement":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) (b : block) (A : e ! x = Some (b, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b) : exists (b0 : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Evar x ty) b0 ofs bf.","conclusion":"exists (b0 : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Evar x ty) b0 ofs bf","hypotheses":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) (b : block) (A : e ! x = Some (b, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b)","proofString":"exists b, Ptrofs.zero, Full.\nintuition.\napply esl_var_local; auto.\napply esl_var_global; auto."},{"statement":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) (b : block) (A : e ! x = Some (b, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b) : eval_simple_lvalue e m (Evar x ty) b Ptrofs.zero Full.","conclusion":"eval_simple_lvalue e m (Evar x ty) b Ptrofs.zero Full","hypotheses":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) (b : block) (A : e ! x = Some (b, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b)","proofString":"intuition.\napply esl_var_local; auto.\napply esl_var_global; auto."},{"statement":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) (b : block) (H : e ! x = Some (b, ty)) : eval_simple_lvalue e m (Evar x ty) b Ptrofs.zero Full.","conclusion":"eval_simple_lvalue e m (Evar x ty) b Ptrofs.zero Full","hypotheses":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) (b : block) (H : e ! x = Some (b, ty))","proofString":"apply esl_var_local; auto."},{"statement":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) (b : block) (H0 : e ! x = None) (H1 : Genv.find_symbol ge x = Some b) : eval_simple_lvalue e m (Evar x ty) b Ptrofs.zero Full.","conclusion":"eval_simple_lvalue e m (Evar x ty) b Ptrofs.zero Full","hypotheses":"(x : ident) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Evar x ty)) RV C) (SAFE : safe (ExprState f (C (Evar x ty)) k e m)) (b : block) (H0 : e ! x = None) (H1 : Genv.find_symbol ge x = Some b)","proofString":"apply esl_var_global; auto."},{"statement":"(a : expr) (f0 : ident) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Efield a f0 ty)) RV C) (SAFE : safe (ExprState f (C (Efield a f0 ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Efield (Eval v (typeof a)) f0 ty)) k e m)) : exists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Efield a f0 ty) b ofs bf.","conclusion":"exists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Efield a f0 ty) b ofs bf","hypotheses":"(a : expr) (f0 : ident) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Efield a f0 ty)) RV C) (SAFE : safe (ExprState f (C (Efield a f0 ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Efield (Eval v (typeof a)) f0 ty)) k e m))","proofString":"exploit safe_inv.\neexact SAFE0.\neauto.\nsimpl.\nintros [b [ofs [EQ TY]]].\nsubst v.\ndestruct (typeof a) eqn:?; try contradiction.\ndestruct TY as (co & delta & bf & CE & OFS).\nexists b, (Ptrofs.add ofs (Ptrofs.repr delta)), bf; eapply esl_field_struct; eauto.\ndestruct TY as (co & delta & bf & CE & OFS).\nexists b, (Ptrofs.add ofs (Ptrofs.repr delta)), bf; eapply esl_field_union; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) : exists v : val, eval_simple_rvalue e m (Evalof a ty) v.","conclusion":"exists v : val, eval_simple_rvalue e m (Evalof a ty) v","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m))","proofString":"exploit safe_inv.\neexact SAFE0.\neauto.\nsimpl.\nintros [TY [t [v LOAD]]].\nassert (t = E0).\ninv LOAD; auto.\ncongruence.\nsubst t.\nexists v; econstructor; eauto.\ncongruence."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) : typeof a = ty /\\\n(exists (t : trace) (v : val), deref_loc ge ty m b ofs bf t v) ->\nexists v : val, eval_simple_rvalue e m (Evalof a ty) v.","conclusion":"typeof a = ty /\\\n(exists (t : trace) (v : val), deref_loc ge ty m b ofs bf t v) ->\nexists v : val, eval_simple_rvalue e m (Evalof a ty) v","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m))","proofString":"intros [TY [t [v LOAD]]].\nassert (t = E0).\ninv LOAD; auto.\ncongruence.\nsubst t.\nexists v; econstructor; eauto.\ncongruence."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (t : trace) (v : val) (LOAD : deref_loc ge ty m b ofs bf t v) : exists v0 : val, eval_simple_rvalue e m (Evalof a ty) v0.","conclusion":"exists v0 : val, eval_simple_rvalue e m (Evalof a ty) v0","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (t : trace) (v : val) (LOAD : deref_loc ge ty m b ofs bf t v)","proofString":"assert (t = E0).\ninv LOAD; auto.\ncongruence.\nsubst t.\nexists v; econstructor; eauto.\ncongruence."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (t : trace) (v : val) (LOAD : deref_loc ge ty m b ofs bf t v) : t = E0.","conclusion":"t = E0","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (t : trace) (v : val) (LOAD : deref_loc ge ty m b ofs bf t v)","proofString":"inv LOAD; auto.\ncongruence."},{"statement":"(a : expr) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (SAFE : safe (ExprState f (C (Evalof a (typeof a))) k e m)) (CTX : context (expr_kind (Evalof a (typeof a))) RV C) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs Full (typeof a)) (typeof a))) k e m)) (E : eval_simple_lvalue e m a b ofs Full) (t : trace) (v : val) (chunk : memory_chunk) (H0 : type_is_volatile (typeof a) = true) (H : access_mode (typeof a) = By_value chunk) (H1 : volatile_load ge chunk m b ofs t v) : t = E0.","conclusion":"t = E0","hypotheses":"(a : expr) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (SAFE : safe (ExprState f (C (Evalof a (typeof a))) k e m)) (CTX : context (expr_kind (Evalof a (typeof a))) RV C) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs Full (typeof a)) (typeof a))) k e m)) (E : eval_simple_lvalue e m a b ofs Full) (t : trace) (v : val) (chunk : memory_chunk) (H0 : type_is_volatile (typeof a) = true) (H : access_mode (typeof a) = By_value chunk) (H1 : volatile_load ge chunk m b ofs t v)","proofString":"congruence."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (t : trace) (v : val) (LOAD : deref_loc ge ty m b ofs bf t v) (H : t = E0) : exists v0 : val, eval_simple_rvalue e m (Evalof a ty) v0.","conclusion":"exists v0 : val, eval_simple_rvalue e m (Evalof a ty) v0","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (t : trace) (v : val) (LOAD : deref_loc ge ty m b ofs bf t v) (H : t = E0)","proofString":"subst t.\nexists v; econstructor; eauto.\ncongruence."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (v : val) (LOAD : deref_loc ge ty m b ofs bf E0 v) : exists v0 : val, eval_simple_rvalue e m (Evalof a ty) v0.","conclusion":"exists v0 : val, eval_simple_rvalue e m (Evalof a ty) v0","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (v : val) (LOAD : deref_loc ge ty m b ofs bf E0 v)","proofString":"exists v; econstructor; eauto.\ncongruence."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (v : val) (LOAD : deref_loc ge ty m b ofs bf E0 v) : type_is_volatile ty = false.","conclusion":"type_is_volatile ty = false","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (CTX : context (expr_kind (Evalof a ty)) RV C) (SAFE : safe (ExprState f (C (Evalof a ty)) k e m)) (S1 : simple a = true) (S2 : type_is_volatile (typeof a) = false) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Evalof (Eloc b ofs bf (typeof a)) ty)) k e m)) (TY : typeof a = ty) (v : val) (LOAD : deref_loc ge ty m b ofs bf E0 v)","proofString":"congruence."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ederef a ty)) RV C) (SAFE : safe (ExprState f (C (Ederef a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ederef (Eval v (typeof a)) ty)) k e m)) : exists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Ederef a ty) b ofs bf.","conclusion":"exists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Ederef a ty) b ofs bf","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ederef a ty)) RV C) (SAFE : safe (ExprState f (C (Ederef a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ederef (Eval v (typeof a)) ty)) k e m))","proofString":"exploit safe_inv.\neexact SAFE0.\neauto.\nsimpl.\nintros [b [ofs EQ]].\nsubst v.\nexists b, ofs, Full; econstructor; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ederef a ty)) RV C) (SAFE : safe (ExprState f (C (Ederef a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ederef (Eval v (typeof a)) ty)) k e m)) : (exists (b : block) (ofs : ptrofs), v = Vptr b ofs) ->\nexists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Ederef a ty) b ofs bf.","conclusion":"(exists (b : block) (ofs : ptrofs), v = Vptr b ofs) ->\nexists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Ederef a ty) b ofs bf","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ederef a ty)) RV C) (SAFE : safe (ExprState f (C (Ederef a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ederef (Eval v (typeof a)) ty)) k e m))","proofString":"intros [b [ofs EQ]].\nsubst v.\nexists b, ofs, Full; econstructor; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ederef a ty)) RV C) (SAFE : safe (ExprState f (C (Ederef a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ederef (Eval v (typeof a)) ty)) k e m)) (b : block) (ofs : ptrofs) (EQ : v = Vptr b ofs) : exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Ederef a ty) b0 ofs0 bf.","conclusion":"exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Ederef a ty) b0 ofs0 bf","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ederef a ty)) RV C) (SAFE : safe (ExprState f (C (Ederef a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ederef (Eval v (typeof a)) ty)) k e m)) (b : block) (ofs : ptrofs) (EQ : v = Vptr b ofs)","proofString":"subst v.\nexists b, ofs, Full; econstructor; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ederef a ty)) RV C) (SAFE : safe (ExprState f (C (Ederef a ty)) k e m)) (b : block) (ofs : ptrofs) (SAFE0 : safe (ExprState f (C (Ederef (Eval (Vptr b ofs) (typeof a)) ty)) k e m)) (E : eval_simple_rvalue e m a (Vptr b ofs)) : exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Ederef a ty) b0 ofs0 bf.","conclusion":"exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m (Ederef a ty) b0 ofs0 bf","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ederef a ty)) RV C) (SAFE : safe (ExprState f (C (Ederef a ty)) k e m)) (b : block) (ofs : ptrofs) (SAFE0 : safe (ExprState f (C (Ederef (Eval (Vptr b ofs) (typeof a)) ty)) k e m)) (E : eval_simple_rvalue e m a (Vptr b ofs))","proofString":"exists b, ofs, Full; econstructor; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eaddrof a ty)) RV C) (SAFE : safe (ExprState f (C (Eaddrof a ty)) k e m)) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Eaddrof (Eloc b ofs bf (typeof a)) ty)) k e m)) : exists v : val, eval_simple_rvalue e m (Eaddrof a ty) v.","conclusion":"exists v : val, eval_simple_rvalue e m (Eaddrof a ty) v","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eaddrof a ty)) RV C) (SAFE : safe (ExprState f (C (Eaddrof a ty)) k e m)) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Eaddrof (Eloc b ofs bf (typeof a)) ty)) k e m))","proofString":"exploit safe_inv.\neexact SAFE0.\neauto.\nsimpl.\nintros EQ; subst bf.\nexists (Vptr b ofs); econstructor; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eaddrof a ty)) RV C) (SAFE : safe (ExprState f (C (Eaddrof a ty)) k e m)) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Eaddrof (Eloc b ofs bf (typeof a)) ty)) k e m)) : bf = Full -> exists v : val, eval_simple_rvalue e m (Eaddrof a ty) v.","conclusion":"bf = Full -> exists v : val, eval_simple_rvalue e m (Eaddrof a ty) v","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf0\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eaddrof a ty)) RV C) (SAFE : safe (ExprState f (C (Eaddrof a ty)) k e m)) (b : block) (ofs : ptrofs) (bf : bitfield) (E : eval_simple_lvalue e m a b ofs bf) (SAFE0 : safe (ExprState f (C (Eaddrof (Eloc b ofs bf (typeof a)) ty)) k e m))","proofString":"intros EQ; subst bf.\nexists (Vptr b ofs); econstructor; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eaddrof a ty)) RV C) (SAFE : safe (ExprState f (C (Eaddrof a ty)) k e m)) (b : block) (ofs : ptrofs) (SAFE0 : safe (ExprState f (C (Eaddrof (Eloc b ofs Full (typeof a)) ty)) k e m)) (E : eval_simple_lvalue e m a b ofs Full) : exists v : val, eval_simple_rvalue e m (Eaddrof a ty) v.","conclusion":"exists v : val, eval_simple_rvalue e m (Eaddrof a ty) v","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b0 ofs0 bf\n| RV => exists v : val, eval_simple_rvalue e m a v\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eaddrof a ty)) RV C) (SAFE : safe (ExprState f (C (Eaddrof a ty)) k e m)) (b : block) (ofs : ptrofs) (SAFE0 : safe (ExprState f (C (Eaddrof (Eloc b ofs Full (typeof a)) ty)) k e m)) (E : eval_simple_lvalue e m a b ofs Full)","proofString":"exists (Vptr b ofs); econstructor; eauto."},{"statement":"(op : unary_operation) (a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eunop op a ty)) RV C) (SAFE : safe (ExprState f (C (Eunop op a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Eunop op (Eval v (typeof a)) ty)) k e m)) : exists v0 : val, eval_simple_rvalue e m (Eunop op a ty) v0.","conclusion":"exists v0 : val, eval_simple_rvalue e m (Eunop op a ty) v0","hypotheses":"(op : unary_operation) (a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eunop op a ty)) RV C) (SAFE : safe (ExprState f (C (Eunop op a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Eunop op (Eval v (typeof a)) ty)) k e m))","proofString":"exploit safe_inv.\neexact SAFE0.\neauto.\nsimpl.\nintros [v' EQ].\nexists v'; econstructor; eauto."},{"statement":"(op : unary_operation) (a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eunop op a ty)) RV C) (SAFE : safe (ExprState f (C (Eunop op a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Eunop op (Eval v (typeof a)) ty)) k e m)) : (exists v0 : val, sem_unary_operation op v (typeof a) m = Some v0) ->\nexists v0 : val, eval_simple_rvalue e m (Eunop op a ty) v0.","conclusion":"(exists v0 : val, sem_unary_operation op v (typeof a) m = Some v0) ->\nexists v0 : val, eval_simple_rvalue e m (Eunop op a ty) v0","hypotheses":"(op : unary_operation) (a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eunop op a ty)) RV C) (SAFE : safe (ExprState f (C (Eunop op a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Eunop op (Eval v (typeof a)) ty)) k e m))","proofString":"intros [v' EQ].\nexists v'; econstructor; eauto."},{"statement":"(op : unary_operation) (a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eunop op a ty)) RV C) (SAFE : safe (ExprState f (C (Eunop op a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Eunop op (Eval v (typeof a)) ty)) k e m)) (v' : val) (EQ : sem_unary_operation op v (typeof a) m = Some v') : exists v0 : val, eval_simple_rvalue e m (Eunop op a ty) v0.","conclusion":"exists v0 : val, eval_simple_rvalue e m (Eunop op a ty) v0","hypotheses":"(op : unary_operation) (a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Eunop op a ty)) RV C) (SAFE : safe (ExprState f (C (Eunop op a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Eunop op (Eval v (typeof a)) ty)) k e m)) (v' : val) (EQ : sem_unary_operation op v (typeof a) m = Some v')","proofString":"exists v'; econstructor; eauto."},{"statement":"(op : binary_operation) (a1 a2 : expr) (ty : type) (IHa1 : forall (from : kind) (C0 : expr -> expr),\nsimple a1 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a1) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a1 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a1 v1\nend) (IHa2 : forall (from : kind) (C0 : expr -> expr),\nsimple a2 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a2) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a2 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a2 v1\nend) (C : expr -> expr) (CTX : context (expr_kind (Ebinop op a1 a2 ty)) RV C) (SAFE : safe (ExprState f (C (Ebinop op a1 a2 ty)) k e m)) (S1 : simple a1 = true) (S2 : simple a2 = true) (v : val) (E : eval_simple_rvalue e m a1 v) (SAFE0 : safe (ExprState f (C (Ebinop op (Eval v (typeof a1)) a2 ty)) k e m)) (v0 : val) (E0 : eval_simple_rvalue e m a2 v0) (SAFE1 : safe\n  (ExprState f (C (Ebinop op (Eval v (typeof a1)) (Eval v0 (typeof a2)) ty))\n     k e m)) : exists v1 : val, eval_simple_rvalue e m (Ebinop op a1 a2 ty) v1.","conclusion":"exists v1 : val, eval_simple_rvalue e m (Ebinop op a1 a2 ty) v1","hypotheses":"(op : binary_operation) (a1 a2 : expr) (ty : type) (IHa1 : forall (from : kind) (C0 : expr -> expr),\nsimple a1 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a1) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a1 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a1 v1\nend) (IHa2 : forall (from : kind) (C0 : expr -> expr),\nsimple a2 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a2) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a2 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a2 v1\nend) (C : expr -> expr) (CTX : context (expr_kind (Ebinop op a1 a2 ty)) RV C) (SAFE : safe (ExprState f (C (Ebinop op a1 a2 ty)) k e m)) (S1 : simple a1 = true) (S2 : simple a2 = true) (v : val) (E : eval_simple_rvalue e m a1 v) (SAFE0 : safe (ExprState f (C (Ebinop op (Eval v (typeof a1)) a2 ty)) k e m)) (v0 : val) (E0 : eval_simple_rvalue e m a2 v0) (SAFE1 : safe\n  (ExprState f (C (Ebinop op (Eval v (typeof a1)) (Eval v0 (typeof a2)) ty))\n     k e m))","proofString":"exploit safe_inv.\neexact SAFE1.\neauto.\nsimpl.\nintros [v' EQ].\nexists v'; econstructor; eauto."},{"statement":"(op : binary_operation) (a1 a2 : expr) (ty : type) (IHa1 : forall (from : kind) (C0 : expr -> expr),\nsimple a1 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a1) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a1 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a1 v1\nend) (IHa2 : forall (from : kind) (C0 : expr -> expr),\nsimple a2 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a2) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a2 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a2 v1\nend) (C : expr -> expr) (CTX : context (expr_kind (Ebinop op a1 a2 ty)) RV C) (SAFE : safe (ExprState f (C (Ebinop op a1 a2 ty)) k e m)) (S1 : simple a1 = true) (S2 : simple a2 = true) (v : val) (E : eval_simple_rvalue e m a1 v) (SAFE0 : safe (ExprState f (C (Ebinop op (Eval v (typeof a1)) a2 ty)) k e m)) (v0 : val) (E0 : eval_simple_rvalue e m a2 v0) (SAFE1 : safe\n  (ExprState f (C (Ebinop op (Eval v (typeof a1)) (Eval v0 (typeof a2)) ty))\n     k e m)) : (exists v1 : val,\n   sem_binary_operation ge op v (typeof a1) v0 (typeof a2) m = Some v1) ->\nexists v1 : val, eval_simple_rvalue e m (Ebinop op a1 a2 ty) v1.","conclusion":"(exists v1 : val,\n   sem_binary_operation ge op v (typeof a1) v0 (typeof a2) m = Some v1) ->\nexists v1 : val, eval_simple_rvalue e m (Ebinop op a1 a2 ty) v1","hypotheses":"(op : binary_operation) (a1 a2 : expr) (ty : type) (IHa1 : forall (from : kind) (C0 : expr -> expr),\nsimple a1 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a1) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a1 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a1 v1\nend) (IHa2 : forall (from : kind) (C0 : expr -> expr),\nsimple a2 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a2) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a2 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a2 v1\nend) (C : expr -> expr) (CTX : context (expr_kind (Ebinop op a1 a2 ty)) RV C) (SAFE : safe (ExprState f (C (Ebinop op a1 a2 ty)) k e m)) (S1 : simple a1 = true) (S2 : simple a2 = true) (v : val) (E : eval_simple_rvalue e m a1 v) (SAFE0 : safe (ExprState f (C (Ebinop op (Eval v (typeof a1)) a2 ty)) k e m)) (v0 : val) (E0 : eval_simple_rvalue e m a2 v0) (SAFE1 : safe\n  (ExprState f (C (Ebinop op (Eval v (typeof a1)) (Eval v0 (typeof a2)) ty))\n     k e m))","proofString":"intros [v' EQ].\nexists v'; econstructor; eauto."},{"statement":"(op : binary_operation) (a1 a2 : expr) (ty : type) (IHa1 : forall (from : kind) (C0 : expr -> expr),\nsimple a1 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a1) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a1 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a1 v1\nend) (IHa2 : forall (from : kind) (C0 : expr -> expr),\nsimple a2 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a2) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a2 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a2 v1\nend) (C : expr -> expr) (CTX : context (expr_kind (Ebinop op a1 a2 ty)) RV C) (SAFE : safe (ExprState f (C (Ebinop op a1 a2 ty)) k e m)) (S1 : simple a1 = true) (S2 : simple a2 = true) (v : val) (E : eval_simple_rvalue e m a1 v) (SAFE0 : safe (ExprState f (C (Ebinop op (Eval v (typeof a1)) a2 ty)) k e m)) (v0 : val) (E0 : eval_simple_rvalue e m a2 v0) (SAFE1 : safe\n  (ExprState f (C (Ebinop op (Eval v (typeof a1)) (Eval v0 (typeof a2)) ty))\n     k e m)) (v' : val) (EQ : sem_binary_operation ge op v (typeof a1) v0 (typeof a2) m = Some v') : exists v1 : val, eval_simple_rvalue e m (Ebinop op a1 a2 ty) v1.","conclusion":"exists v1 : val, eval_simple_rvalue e m (Ebinop op a1 a2 ty) v1","hypotheses":"(op : binary_operation) (a1 a2 : expr) (ty : type) (IHa1 : forall (from : kind) (C0 : expr -> expr),\nsimple a1 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a1) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a1 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a1 v1\nend) (IHa2 : forall (from : kind) (C0 : expr -> expr),\nsimple a2 = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a2) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a2 b ofs bf\n| RV => exists v1 : val, eval_simple_rvalue e m a2 v1\nend) (C : expr -> expr) (CTX : context (expr_kind (Ebinop op a1 a2 ty)) RV C) (SAFE : safe (ExprState f (C (Ebinop op a1 a2 ty)) k e m)) (S1 : simple a1 = true) (S2 : simple a2 = true) (v : val) (E : eval_simple_rvalue e m a1 v) (SAFE0 : safe (ExprState f (C (Ebinop op (Eval v (typeof a1)) a2 ty)) k e m)) (v0 : val) (E0 : eval_simple_rvalue e m a2 v0) (SAFE1 : safe\n  (ExprState f (C (Ebinop op (Eval v (typeof a1)) (Eval v0 (typeof a2)) ty))\n     k e m)) (v' : val) (EQ : sem_binary_operation ge op v (typeof a1) v0 (typeof a2) m = Some v')","proofString":"exists v'; econstructor; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ecast a ty)) RV C) (SAFE : safe (ExprState f (C (Ecast a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ecast (Eval v (typeof a)) ty)) k e m)) : exists v0 : val, eval_simple_rvalue e m (Ecast a ty) v0.","conclusion":"exists v0 : val, eval_simple_rvalue e m (Ecast a ty) v0","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ecast a ty)) RV C) (SAFE : safe (ExprState f (C (Ecast a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ecast (Eval v (typeof a)) ty)) k e m))","proofString":"exploit safe_inv.\neexact SAFE0.\neauto.\nsimpl.\nintros [v' CAST].\nexists v'; econstructor; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ecast a ty)) RV C) (SAFE : safe (ExprState f (C (Ecast a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ecast (Eval v (typeof a)) ty)) k e m)) : (exists v0 : val, sem_cast v (typeof a) ty m = Some v0) ->\nexists v0 : val, eval_simple_rvalue e m (Ecast a ty) v0.","conclusion":"(exists v0 : val, sem_cast v (typeof a) ty m = Some v0) ->\nexists v0 : val, eval_simple_rvalue e m (Ecast a ty) v0","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ecast a ty)) RV C) (SAFE : safe (ExprState f (C (Ecast a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ecast (Eval v (typeof a)) ty)) k e m))","proofString":"intros [v' CAST].\nexists v'; econstructor; eauto."},{"statement":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ecast a ty)) RV C) (SAFE : safe (ExprState f (C (Ecast a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ecast (Eval v (typeof a)) ty)) k e m)) (v' : val) (CAST : sem_cast v (typeof a) ty m = Some v') : exists v0 : val, eval_simple_rvalue e m (Ecast a ty) v0.","conclusion":"exists v0 : val, eval_simple_rvalue e m (Ecast a ty) v0","hypotheses":"(a : expr) (ty : type) (IHa : forall (from : kind) (C0 : expr -> expr),\nsimple a = true ->\ncontext from RV C0 ->\nsafe (ExprState f (C0 a) k e m) ->\nmatch from with\n| LV =>\n    exists (b : block) (ofs : ptrofs) (bf : bitfield),\n      eval_simple_lvalue e m a b ofs bf\n| RV => exists v0 : val, eval_simple_rvalue e m a v0\nend) (C : expr -> expr) (S : simple a = true) (CTX : context (expr_kind (Ecast a ty)) RV C) (SAFE : safe (ExprState f (C (Ecast a ty)) k e m)) (v : val) (E : eval_simple_rvalue e m a v) (SAFE0 : safe (ExprState f (C (Ecast (Eval v (typeof a)) ty)) k e m)) (v' : val) (CAST : sem_cast v (typeof a) ty m = Some v')","proofString":"exists v'; econstructor; eauto."},{"statement":"(ty' ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Esizeof ty' ty)) RV C) (SAFE : safe (ExprState f (C (Esizeof ty' ty)) k e m)) : exists v : val, eval_simple_rvalue e m (Esizeof ty' ty) v.","conclusion":"exists v : val, eval_simple_rvalue e m (Esizeof ty' ty) v","hypotheses":"(ty' ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Esizeof ty' ty)) RV C) (SAFE : safe (ExprState f (C (Esizeof ty' ty)) k e m))","proofString":"econstructor; econstructor."},{"statement":"(ty' ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Ealignof ty' ty)) RV C) (SAFE : safe (ExprState f (C (Ealignof ty' ty)) k e m)) : exists v : val, eval_simple_rvalue e m (Ealignof ty' ty) v.","conclusion":"exists v : val, eval_simple_rvalue e m (Ealignof ty' ty) v","hypotheses":"(ty' ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Ealignof ty' ty)) RV C) (SAFE : safe (ExprState f (C (Ealignof ty' ty)) k e m))","proofString":"econstructor; econstructor."},{"statement":"(b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Eloc b ofs bf ty)) RV C) (SAFE : safe (ExprState f (C (Eloc b ofs bf ty)) k e m)) : exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n  eval_simple_lvalue e m (Eloc b ofs bf ty) b0 ofs0 bf0.","conclusion":"exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n  eval_simple_lvalue e m (Eloc b ofs bf ty) b0 ofs0 bf0","hypotheses":"(b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (C : expr -> expr) (S : true = true) (CTX : context (expr_kind (Eloc b ofs bf ty)) RV C) (SAFE : safe (ExprState f (C (Eloc b ofs bf ty)) k e m))","proofString":"exists b, ofs, bf; constructor."},{"statement":"(r : expr) (C : expr -> expr) (H : simple r = true) (H0 : context RV RV C) (H1 : safe (ExprState f (C r) k e m)) : exists v : val,\n  eval_simple_rvalue e m r v /\\\n  safe (ExprState f (C (Eval v (typeof r))) k e m).","conclusion":"exists v : val,\n  eval_simple_rvalue e m r v /\\\n  safe (ExprState f (C (Eval v (typeof r))) k e m)","hypotheses":"(r : expr) (C : expr -> expr) (H : simple r = true) (H0 : context RV RV C) (H1 : safe (ExprState f (C r) k e m))","proofString":"exploit (simple_can_eval r RV); eauto.\nintros [v A].\nexists v; split; auto.\neapply eval_simple_rvalue_safe; eauto."},{"statement":"(r : expr) (C : expr -> expr) (H : simple r = true) (H0 : context RV RV C) (H1 : safe (ExprState f (C r) k e m)) : (exists v : val, eval_simple_rvalue e m r v) ->\nexists v : val,\n  eval_simple_rvalue e m r v /\\\n  safe (ExprState f (C (Eval v (typeof r))) k e m).","conclusion":"(exists v : val, eval_simple_rvalue e m r v) ->\nexists v : val,\n  eval_simple_rvalue e m r v /\\\n  safe (ExprState f (C (Eval v (typeof r))) k e m)","hypotheses":"(r : expr) (C : expr -> expr) (H : simple r = true) (H0 : context RV RV C) (H1 : safe (ExprState f (C r) k e m))","proofString":"intros [v A].\nexists v; split; auto.\neapply eval_simple_rvalue_safe; eauto."},{"statement":"(r : expr) (C : expr -> expr) (H : simple r = true) (H0 : context RV RV C) (H1 : safe (ExprState f (C r) k e m)) (v : val) (A : eval_simple_rvalue e m r v) : exists v0 : val,\n  eval_simple_rvalue e m r v0 /\\\n  safe (ExprState f (C (Eval v0 (typeof r))) k e m).","conclusion":"exists v0 : val,\n  eval_simple_rvalue e m r v0 /\\\n  safe (ExprState f (C (Eval v0 (typeof r))) k e m)","hypotheses":"(r : expr) (C : expr -> expr) (H : simple r = true) (H0 : context RV RV C) (H1 : safe (ExprState f (C r) k e m)) (v : val) (A : eval_simple_rvalue e m r v)","proofString":"exists v; split; auto.\neapply eval_simple_rvalue_safe; eauto."},{"statement":"(r : expr) (C : expr -> expr) (H : simple r = true) (H0 : context RV RV C) (H1 : safe (ExprState f (C r) k e m)) (v : val) (A : eval_simple_rvalue e m r v) : safe (ExprState f (C (Eval v (typeof r))) k e m).","conclusion":"safe (ExprState f (C (Eval v (typeof r))) k e m)","hypotheses":"(r : expr) (C : expr -> expr) (H : simple r = true) (H0 : context RV RV C) (H1 : safe (ExprState f (C r) k e m)) (v : val) (A : eval_simple_rvalue e m r v)","proofString":"eapply eval_simple_rvalue_safe; eauto."},{"statement":"(l : expr) (C : expr -> expr) (H : simple l = true) (H0 : context LV RV C) (H1 : safe (ExprState f (C l) k e m)) : exists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m l b ofs bf /\\\n  safe (ExprState f (C (Eloc b ofs bf (typeof l))) k e m).","conclusion":"exists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m l b ofs bf /\\\n  safe (ExprState f (C (Eloc b ofs bf (typeof l))) k e m)","hypotheses":"(l : expr) (C : expr -> expr) (H : simple l = true) (H0 : context LV RV C) (H1 : safe (ExprState f (C l) k e m))","proofString":"exploit (simple_can_eval l LV); eauto.\nintros (b & ofs & bf & A).\nexists b, ofs, bf; split; auto.\neapply eval_simple_lvalue_safe; eauto."},{"statement":"(l : expr) (C : expr -> expr) (H : simple l = true) (H0 : context LV RV C) (H1 : safe (ExprState f (C l) k e m)) : (exists (b : block) (ofs : ptrofs) (bf : bitfield),\n   eval_simple_lvalue e m l b ofs bf) ->\nexists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m l b ofs bf /\\\n  safe (ExprState f (C (Eloc b ofs bf (typeof l))) k e m).","conclusion":"(exists (b : block) (ofs : ptrofs) (bf : bitfield),\n   eval_simple_lvalue e m l b ofs bf) ->\nexists (b : block) (ofs : ptrofs) (bf : bitfield),\n  eval_simple_lvalue e m l b ofs bf /\\\n  safe (ExprState f (C (Eloc b ofs bf (typeof l))) k e m)","hypotheses":"(l : expr) (C : expr -> expr) (H : simple l = true) (H0 : context LV RV C) (H1 : safe (ExprState f (C l) k e m))","proofString":"intros (b & ofs & bf & A).\nexists b, ofs, bf; split; auto.\neapply eval_simple_lvalue_safe; eauto."},{"statement":"(l : expr) (C : expr -> expr) (H : simple l = true) (H0 : context LV RV C) (H1 : safe (ExprState f (C l) k e m)) (b : block) (ofs : ptrofs) (bf : bitfield) (A : eval_simple_lvalue e m l b ofs bf) : exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n  eval_simple_lvalue e m l b0 ofs0 bf0 /\\\n  safe (ExprState f (C (Eloc b0 ofs0 bf0 (typeof l))) k e m).","conclusion":"exists (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\n  eval_simple_lvalue e m l b0 ofs0 bf0 /\\\n  safe (ExprState f (C (Eloc b0 ofs0 bf0 (typeof l))) k e m)","hypotheses":"(l : expr) (C : expr -> expr) (H : simple l = true) (H0 : context LV RV C) (H1 : safe (ExprState f (C l) k e m)) (b : block) (ofs : ptrofs) (bf : bitfield) (A : eval_simple_lvalue e m l b ofs bf)","proofString":"exists b, ofs, bf; split; auto.\neapply eval_simple_lvalue_safe; eauto."},{"statement":"(l : expr) (C : expr -> expr) (H : simple l = true) (H0 : context LV RV C) (H1 : safe (ExprState f (C l) k e m)) (b : block) (ofs : ptrofs) (bf : bitfield) (A : eval_simple_lvalue e m l b ofs bf) : safe (ExprState f (C (Eloc b ofs bf (typeof l))) k e m).","conclusion":"safe (ExprState f (C (Eloc b ofs bf (typeof l))) k e m)","hypotheses":"(l : expr) (C : expr -> expr) (H : simple l = true) (H0 : context LV RV C) (H1 : safe (ExprState f (C l) k e m)) (b : block) (ofs : ptrofs) (bf : bitfield) (A : eval_simple_lvalue e m l b ofs bf)","proofString":"eapply eval_simple_lvalue_safe; eauto."},{"statement":"exists vl' : list val,\n  cast_arguments m (rval_list vl' Enil) nil nil /\\ eval_simple_list' Enil vl'.","conclusion":"exists vl' : list val,\n  cast_arguments m (rval_list vl' Enil) nil nil /\\ eval_simple_list' Enil vl'","hypotheses":"","proofString":"exists (@nil val); split.\nconstructor.\nconstructor."},{"statement":"cast_arguments m (rval_list nil Enil) nil nil.","conclusion":"cast_arguments m (rval_list nil Enil) nil nil","hypotheses":"","proofString":"constructor."},{"statement":"eval_simple_list' Enil nil.","conclusion":"eval_simple_list' Enil nil","hypotheses":"","proofString":"constructor."},{"statement":"(r : expr) (rl : exprlist) (ty : type) (tyl : list type) (v : val) (vl : list val) (v' : val) (H : eval_simple_rvalue e m r v') (H0 : sem_cast v' (typeof r) ty m = Some v) (H1 : eval_simple_list e m rl tyl vl) (IHeval_simple_list : exists vl' : list val,\n  cast_arguments m (rval_list vl' rl) tyl vl /\\ eval_simple_list' rl vl') : exists vl' : list val,\n  cast_arguments m (rval_list vl' (Econs r rl)) (ty :: tyl) (v :: vl) /\\\n  eval_simple_list' (Econs r rl) vl'.","conclusion":"exists vl' : list val,\n  cast_arguments m (rval_list vl' (Econs r rl)) (ty :: tyl) (v :: vl) /\\\n  eval_simple_list' (Econs r rl) vl'","hypotheses":"(r : expr) (rl : exprlist) (ty : type) (tyl : list type) (v : val) (vl : list val) (v' : val) (H : eval_simple_rvalue e m r v') (H0 : sem_cast v' (typeof r) ty m = Some v) (H1 : eval_simple_list e m rl tyl vl) (IHeval_simple_list : exists vl' : list val,\n  cast_arguments m (rval_list vl' rl) tyl vl /\\ eval_simple_list' rl vl')","proofString":"destruct IHeval_simple_list as [vl' [A B]].\nexists (v' :: vl'); split.\nconstructor; auto.\nconstructor; auto."},{"statement":"(r : expr) (rl : exprlist) (ty : type) (tyl : list type) (v : val) (vl : list val) (v' : val) (H : eval_simple_rvalue e m r v') (H0 : sem_cast v' (typeof r) ty m = Some v) (H1 : eval_simple_list e m rl tyl vl) (vl' : list val) (A : cast_arguments m (rval_list vl' rl) tyl vl) (B : eval_simple_list' rl vl') : exists vl'0 : list val,\n  cast_arguments m (rval_list vl'0 (Econs r rl)) (ty :: tyl) (v :: vl) /\\\n  eval_simple_list' (Econs r rl) vl'0.","conclusion":"exists vl'0 : list val,\n  cast_arguments m (rval_list vl'0 (Econs r rl)) (ty :: tyl) (v :: vl) /\\\n  eval_simple_list' (Econs r rl) vl'0","hypotheses":"(r : expr) (rl : exprlist) (ty : type) (tyl : list type) (v : val) (vl : list val) (v' : val) (H : eval_simple_rvalue e m r v') (H0 : sem_cast v' (typeof r) ty m = Some v) (H1 : eval_simple_list e m rl tyl vl) (vl' : list val) (A : cast_arguments m (rval_list vl' rl) tyl vl) (B : eval_simple_list' rl vl')","proofString":"exists (v' :: vl'); split.\nconstructor; auto.\nconstructor; auto."},{"statement":"(r : expr) (rl : exprlist) (ty : type) (tyl : list type) (v : val) (vl : list val) (v' : val) (H : eval_simple_rvalue e m r v') (H0 : sem_cast v' (typeof r) ty m = Some v) (H1 : eval_simple_list e m rl tyl vl) (vl' : list val) (A : cast_arguments m (rval_list vl' rl) tyl vl) (B : eval_simple_list' rl vl') : cast_arguments m (rval_list (v' :: vl') (Econs r rl)) (ty :: tyl) (v :: vl).","conclusion":"cast_arguments m (rval_list (v' :: vl') (Econs r rl)) (ty :: tyl) (v :: vl)","hypotheses":"(r : expr) (rl : exprlist) (ty : type) (tyl : list type) (v : val) (vl : list val) (v' : val) (H : eval_simple_rvalue e m r v') (H0 : sem_cast v' (typeof r) ty m = Some v) (H1 : eval_simple_list e m rl tyl vl) (vl' : list val) (A : cast_arguments m (rval_list vl' rl) tyl vl) (B : eval_simple_list' rl vl')","proofString":"constructor; auto."},{"statement":"(r : expr) (rl : exprlist) (ty : type) (tyl : list type) (v : val) (vl : list val) (v' : val) (H : eval_simple_rvalue e m r v') (H0 : sem_cast v' (typeof r) ty m = Some v) (H1 : eval_simple_list e m rl tyl vl) (vl' : list val) (A : cast_arguments m (rval_list vl' rl) tyl vl) (B : eval_simple_list' rl vl') : eval_simple_list' (Econs r rl) (v' :: vl').","conclusion":"eval_simple_list' (Econs r rl) (v' :: vl')","hypotheses":"(r : expr) (rl : exprlist) (ty : type) (tyl : list type) (v : val) (vl : list val) (v' : val) (H : eval_simple_rvalue e m r v') (H0 : sem_cast v' (typeof r) ty m = Some v) (H1 : eval_simple_list e m rl tyl vl) (vl' : list val) (A : cast_arguments m (rval_list vl' rl) tyl vl) (B : eval_simple_list' rl vl')","proofString":"constructor; auto."},{"statement":"(tyl : list type) (vl' : list val) (H : cast_arguments m Enil tyl vl') : eval_simple_list e m Enil tyl vl'.","conclusion":"eval_simple_list e m Enil tyl vl'","hypotheses":"(tyl : list type) (vl' : list val) (H : cast_arguments m Enil tyl vl')","proofString":"inv H.\nconstructor."},{"statement":"eval_simple_list e m Enil nil nil.","conclusion":"eval_simple_list e m Enil nil nil","hypotheses":"","proofString":"constructor."},{"statement":"(r : expr) (rl : exprlist) (v : val) (vl : list val) (H : eval_simple_rvalue e m r v) (H0 : eval_simple_list' rl vl) (IHeval_simple_list' : forall (tyl0 : list type) (vl'0 : list val),\ncast_arguments m (rval_list vl rl) tyl0 vl'0 ->\neval_simple_list e m rl tyl0 vl'0) (tyl : list type) (vl' : list val) (H1 : cast_arguments m (Econs (Eval v (typeof r)) (rval_list vl rl)) tyl vl') : eval_simple_list e m (Econs r rl) tyl vl'.","conclusion":"eval_simple_list e m (Econs r rl) tyl vl'","hypotheses":"(r : expr) (rl : exprlist) (v : val) (vl : list val) (H : eval_simple_rvalue e m r v) (H0 : eval_simple_list' rl vl) (IHeval_simple_list' : forall (tyl0 : list type) (vl'0 : list val),\ncast_arguments m (rval_list vl rl) tyl0 vl'0 ->\neval_simple_list e m rl tyl0 vl'0) (tyl : list type) (vl' : list val) (H1 : cast_arguments m (Econs (Eval v (typeof r)) (rval_list vl rl)) tyl vl')","proofString":"inv H1.\neconstructor; eauto."},{"statement":"(r : expr) (rl : exprlist) (v : val) (vl : list val) (H : eval_simple_rvalue e m r v) (H0 : eval_simple_list' rl vl) (IHeval_simple_list' : forall (tyl : list type) (vl' : list val),\ncast_arguments m (rval_list vl rl) tyl vl' -> eval_simple_list e m rl tyl vl') (targ1 : type) (targs : list type) (v1 : val) (vl0 : list val) (H7 : sem_cast v (typeof r) targ1 m = Some v1) (H8 : cast_arguments m (rval_list vl rl) targs vl0) : eval_simple_list e m (Econs r rl) (targ1 :: targs) (v1 :: vl0).","conclusion":"eval_simple_list e m (Econs r rl) (targ1 :: targs) (v1 :: vl0)","hypotheses":"(r : expr) (rl : exprlist) (v : val) (vl : list val) (H : eval_simple_rvalue e m r v) (H0 : eval_simple_list' rl vl) (IHeval_simple_list' : forall (tyl : list type) (vl' : list val),\ncast_arguments m (rval_list vl rl) tyl vl' -> eval_simple_list e m rl tyl vl') (targ1 : type) (targs : list type) (v1 : val) (vl0 : list val) (H7 : sem_cast v (typeof r) targ1 m = Some v1) (H8 : cast_arguments m (rval_list vl rl) targs vl0)","proofString":"econstructor; eauto."},{"statement":"(rl2 rl3 : exprlist) (r1 : expr) (rl1 : exprlist) (IHrl1 : exprlist_app (exprlist_app rl1 rl2) rl3 =\nexprlist_app rl1 (exprlist_app rl2 rl3)) : exprlist_app (exprlist_app (Econs r1 rl1) rl2) rl3 =\nexprlist_app (Econs r1 rl1) (exprlist_app rl2 rl3).","conclusion":"exprlist_app (exprlist_app (Econs r1 rl1) rl2) rl3 =\nexprlist_app (Econs r1 rl1) (exprlist_app rl2 rl3)","hypotheses":"(rl2 rl3 : exprlist) (r1 : expr) (rl1 : exprlist) (IHrl1 : exprlist_app (exprlist_app rl1 rl2) rl3 =\nexprlist_app rl1 (exprlist_app rl2 rl3))","proofString":"simpl.\ncongruence."},{"statement":"(rl2 rl3 : exprlist) (r1 : expr) (rl1 : exprlist) (IHrl1 : exprlist_app (exprlist_app rl1 rl2) rl3 =\nexprlist_app rl1 (exprlist_app rl2 rl3)) : Econs r1 (exprlist_app (exprlist_app rl1 rl2) rl3) =\nEcons r1 (exprlist_app rl1 (exprlist_app rl2 rl3)).","conclusion":"Econs r1 (exprlist_app (exprlist_app rl1 rl2) rl3) =\nEcons r1 (exprlist_app rl1 (exprlist_app rl2 rl3))","hypotheses":"(rl2 rl3 : exprlist) (r1 : expr) (rl1 : exprlist) (IHrl1 : exprlist_app (exprlist_app rl1 rl2) rl3 =\nexprlist_app rl1 (exprlist_app rl2 rl3))","proofString":"congruence."},{"statement":"(rl2 : exprlist) : contextlist RV (fun x : expr => Econs x rl2).","conclusion":"contextlist RV (fun x : expr => Econs x rl2)","hypotheses":"(rl2 : exprlist)","proofString":"apply ctx_list_head.\nconstructor."},{"statement":"(rl2 : exprlist) : context RV RV (fun x : expr => x).","conclusion":"context RV RV (fun x : expr => x)","hypotheses":"(rl2 : exprlist)","proofString":"constructor."},{"statement":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\ncontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) : contextlist RV (fun x : expr => Econs r1 (exprlist_app rl1 (Econs x rl2))).","conclusion":"contextlist RV (fun x : expr => Econs r1 (exprlist_app rl1 (Econs x rl2)))","hypotheses":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\ncontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist)","proofString":"apply ctx_list_tail.\nauto."},{"statement":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\ncontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) : contextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl2)).","conclusion":"contextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl2))","hypotheses":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\ncontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist)","proofString":"auto."},{"statement":"(rl : exprlist) (C : exprlist -> expr) (H : contextlist' C) : context RV RV (fun x : expr => C (Econs x rl)).","conclusion":"context RV RV (fun x : expr => C (Econs x rl))","hypotheses":"(rl : exprlist) (C : exprlist -> expr) (H : contextlist' C)","proofString":"inv H.\nset (C' := fun x => Ecall r1 (exprlist_app rl0 (Econs x rl)) ty).\nassert (context RV RV C').\nconstructor.\napply exprlist_app_context.\nchange (context RV RV (fun x => C0 (C' x))).\neapply context_compose; eauto.\nset (C' := fun x => Ebuiltin ef tyargs (exprlist_app rl0 (Econs x rl)) ty).\nassert (context RV RV C').\nconstructor.\napply exprlist_app_context.\nchange (context RV RV (fun x => C0 (C' x))).\neapply context_compose; eauto."},{"statement":"(rl : exprlist) (r1 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : context RV RV\n  (fun x : expr => C0 (Ecall r1 (exprlist_app rl0 (Econs x rl)) ty)).","conclusion":"context RV RV\n  (fun x : expr => C0 (Ecall r1 (exprlist_app rl0 (Econs x rl)) ty))","hypotheses":"(rl : exprlist) (r1 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"set (C' := fun x => Ecall r1 (exprlist_app rl0 (Econs x rl)) ty).\nassert (context RV RV C').\nconstructor.\napply exprlist_app_context.\nchange (context RV RV (fun x => C0 (C' x))).\neapply context_compose; eauto."},{"statement":"(rl : exprlist) (r1 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (C' : expr -> expr) : contextlist RV (fun x : expr => exprlist_app rl0 (Econs x rl)).","conclusion":"contextlist RV (fun x : expr => exprlist_app rl0 (Econs x rl))","hypotheses":"(rl : exprlist) (r1 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (C' : expr -> expr)","proofString":"apply exprlist_app_context."},{"statement":"(rl : exprlist) (r1 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (C' : expr -> expr) (H : context RV RV C') : context RV RV (fun x : expr => C0 (C' x)).","conclusion":"context RV RV (fun x : expr => C0 (C' x))","hypotheses":"(rl : exprlist) (r1 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (C' : expr -> expr) (H : context RV RV C')","proofString":"eapply context_compose; eauto."},{"statement":"(rl : exprlist) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : context RV RV\n  (fun x : expr => C0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs x rl)) ty)).","conclusion":"context RV RV\n  (fun x : expr => C0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs x rl)) ty))","hypotheses":"(rl : exprlist) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"set (C' := fun x => Ebuiltin ef tyargs (exprlist_app rl0 (Econs x rl)) ty).\nassert (context RV RV C').\nconstructor.\napply exprlist_app_context.\nchange (context RV RV (fun x => C0 (C' x))).\neapply context_compose; eauto."},{"statement":"(rl : exprlist) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (C' : expr -> expr) : contextlist RV (fun x : expr => exprlist_app rl0 (Econs x rl)).","conclusion":"contextlist RV (fun x : expr => exprlist_app rl0 (Econs x rl))","hypotheses":"(rl : exprlist) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (C' : expr -> expr)","proofString":"apply exprlist_app_context."},{"statement":"(rl : exprlist) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (C' : expr -> expr) (H : context RV RV C') : context RV RV (fun x : expr => C0 (C' x)).","conclusion":"context RV RV (fun x : expr => C0 (C' x))","hypotheses":"(rl : exprlist) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (C' : expr -> expr) (H : context RV RV C')","proofString":"eapply context_compose; eauto."},{"statement":"(r1 : expr) (C : exprlist -> expr) (H : contextlist' C) : contextlist' (fun x : exprlist => C (Econs r1 x)).","conclusion":"contextlist' (fun x : exprlist => C (Econs r1 x))","hypotheses":"(r1 : expr) (C : exprlist -> expr) (H : contextlist' C)","proofString":"inv H.\nreplace (fun x => C0 (Ecall r0 (exprlist_app rl0 (Econs r1 x)) ty))     with (fun x => C0 (Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty)).\nconstructor.\nauto.\napply extensionality; intros.\nf_equal.\nf_equal.\napply exprlist_app_assoc.\nreplace (fun x => C0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty))     with (fun x => C0 (Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty)).\nconstructor.\nauto.\napply extensionality; intros.\nf_equal.\nf_equal.\napply exprlist_app_assoc."},{"statement":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : contextlist'\n  (fun x : exprlist => C0 (Ecall r0 (exprlist_app rl0 (Econs r1 x)) ty)).","conclusion":"contextlist'\n  (fun x : exprlist => C0 (Ecall r0 (exprlist_app rl0 (Econs r1 x)) ty))","hypotheses":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"replace (fun x => C0 (Ecall r0 (exprlist_app rl0 (Econs r1 x)) ty))     with (fun x => C0 (Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty)).\nconstructor.\nauto.\napply extensionality; intros.\nf_equal.\nf_equal.\napply exprlist_app_assoc."},{"statement":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : contextlist'\n  (fun x : exprlist =>\n   C0 (Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty)).","conclusion":"contextlist'\n  (fun x : exprlist =>\n   C0 (Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty))","hypotheses":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"constructor.\nauto."},{"statement":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : context RV RV C0.","conclusion":"context RV RV C0","hypotheses":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"auto."},{"statement":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : (fun x : exprlist =>\n C0 (Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty)) =\n(fun x : exprlist => C0 (Ecall r0 (exprlist_app rl0 (Econs r1 x)) ty)).","conclusion":"(fun x : exprlist =>\n C0 (Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty)) =\n(fun x : exprlist => C0 (Ecall r0 (exprlist_app rl0 (Econs r1 x)) ty))","hypotheses":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"apply extensionality; intros.\nf_equal.\nf_equal.\napply exprlist_app_assoc."},{"statement":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist) : C0 (Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty) =\nC0 (Ecall r0 (exprlist_app rl0 (Econs r1 x)) ty).","conclusion":"C0 (Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty) =\nC0 (Ecall r0 (exprlist_app rl0 (Econs r1 x)) ty)","hypotheses":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist)","proofString":"f_equal.\nf_equal.\napply exprlist_app_assoc."},{"statement":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist) : Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty =\nEcall r0 (exprlist_app rl0 (Econs r1 x)) ty.","conclusion":"Ecall r0 (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty =\nEcall r0 (exprlist_app rl0 (Econs r1 x)) ty","hypotheses":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist)","proofString":"f_equal.\napply exprlist_app_assoc."},{"statement":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist) : exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x =\nexprlist_app rl0 (Econs r1 x).","conclusion":"exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x =\nexprlist_app rl0 (Econs r1 x)","hypotheses":"(r1 r0 : expr) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist)","proofString":"apply exprlist_app_assoc."},{"statement":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : contextlist'\n  (fun x : exprlist =>\n   C0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty)).","conclusion":"contextlist'\n  (fun x : exprlist =>\n   C0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty))","hypotheses":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"replace (fun x => C0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty))     with (fun x => C0 (Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty)).\nconstructor.\nauto.\napply extensionality; intros.\nf_equal.\nf_equal.\napply exprlist_app_assoc."},{"statement":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : contextlist'\n  (fun x : exprlist =>\n   C0\n     (Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x)\n        ty)).","conclusion":"contextlist'\n  (fun x : exprlist =>\n   C0\n     (Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x)\n        ty))","hypotheses":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"constructor.\nauto."},{"statement":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : context RV RV C0.","conclusion":"context RV RV C0","hypotheses":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"auto."},{"statement":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) : (fun x : exprlist =>\n C0\n   (Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty)) =\n(fun x : exprlist =>\n C0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty)).","conclusion":"(fun x : exprlist =>\n C0\n   (Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty)) =\n(fun x : exprlist =>\n C0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty))","hypotheses":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0)","proofString":"apply extensionality; intros.\nf_equal.\nf_equal.\napply exprlist_app_assoc."},{"statement":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist) : C0\n  (Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty) =\nC0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty).","conclusion":"C0\n  (Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty) =\nC0 (Ebuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty)","hypotheses":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist)","proofString":"f_equal.\nf_equal.\napply exprlist_app_assoc."},{"statement":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist) : Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty =\nEbuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty.","conclusion":"Ebuiltin ef tyargs (exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x) ty =\nEbuiltin ef tyargs (exprlist_app rl0 (Econs r1 x)) ty","hypotheses":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist)","proofString":"f_equal.\napply exprlist_app_assoc."},{"statement":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist) : exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x =\nexprlist_app rl0 (Econs r1 x).","conclusion":"exprlist_app (exprlist_app rl0 (Econs r1 Enil)) x =\nexprlist_app rl0 (Econs r1 x)","hypotheses":"(r1 : expr) (ef : external_function) (tyargs : list type) (rl0 : exprlist) (ty : type) (C0 : expr -> expr) (H0 : context RV RV C0) (x : exprlist)","proofString":"apply exprlist_app_assoc."},{"statement":"(C : exprlist -> expr) (H : contextlist' C) : star Csem.step ge (ExprState f (C Enil) k e m) E0\n  (ExprState f (C (rval_list nil Enil)) k e m).","conclusion":"star Csem.step ge (ExprState f (C Enil) k e m) E0\n  (ExprState f (C (rval_list nil Enil)) k e m)","hypotheses":"(C : exprlist -> expr) (H : contextlist' C)","proofString":"apply star_refl."},{"statement":"(C : exprlist -> expr) (H : simplelist Enil = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C Enil) k e m)) : exists vl : list val, eval_simple_list' Enil vl.","conclusion":"exists vl : list val, eval_simple_list' Enil vl","hypotheses":"(C : exprlist -> expr) (H : simplelist Enil = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C Enil) k e m))","proofString":"econstructor; constructor."},{"statement":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simplelist (Econs r1 rl) = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) : exists vl : list val, eval_simple_list' (Econs r1 rl) vl.","conclusion":"exists vl : list val, eval_simple_list' (Econs r1 rl) vl","hypotheses":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simplelist (Econs r1 rl) = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m))","proofString":"simpl in H.\ndestruct (andb_prop _ _ H).\nexploit (simple_can_eval r1 RV (fun x => C(Econs x rl))); eauto.\nintros [v1 EV1].\nexploit (IHrl (fun x => C(Econs (Eval v1 (typeof r1)) x))); eauto.\napply (eval_simple_rvalue_safe (fun x => C(Econs x rl))); eauto.\nintros [vl EVl].\nexists (v1 :: vl); constructor; auto."},{"statement":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) : exists vl : list val, eval_simple_list' (Econs r1 rl) vl.","conclusion":"exists vl : list val, eval_simple_list' (Econs r1 rl) vl","hypotheses":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m))","proofString":"destruct (andb_prop _ _ H).\nexploit (simple_can_eval r1 RV (fun x => C(Econs x rl))); eauto.\nintros [v1 EV1].\nexploit (IHrl (fun x => C(Econs (Eval v1 (typeof r1)) x))); eauto.\napply (eval_simple_rvalue_safe (fun x => C(Econs x rl))); eauto.\nintros [vl EVl].\nexists (v1 :: vl); constructor; auto."},{"statement":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) : exists vl : list val, eval_simple_list' (Econs r1 rl) vl.","conclusion":"exists vl : list val, eval_simple_list' (Econs r1 rl) vl","hypotheses":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true)","proofString":"exploit (simple_can_eval r1 RV (fun x => C(Econs x rl))); eauto.\nintros [v1 EV1].\nexploit (IHrl (fun x => C(Econs (Eval v1 (typeof r1)) x))); eauto.\napply (eval_simple_rvalue_safe (fun x => C(Econs x rl))); eauto.\nintros [vl EVl].\nexists (v1 :: vl); constructor; auto."},{"statement":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) : (exists v : val, eval_simple_rvalue e m r1 v) ->\nexists vl : list val, eval_simple_list' (Econs r1 rl) vl.","conclusion":"(exists v : val, eval_simple_rvalue e m r1 v) ->\nexists vl : list val, eval_simple_list' (Econs r1 rl) vl","hypotheses":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true)","proofString":"intros [v1 EV1].\nexploit (IHrl (fun x => C(Econs (Eval v1 (typeof r1)) x))); eauto.\napply (eval_simple_rvalue_safe (fun x => C(Econs x rl))); eauto.\nintros [vl EVl].\nexists (v1 :: vl); constructor; auto."},{"statement":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) (v1 : val) (EV1 : eval_simple_rvalue e m r1 v1) : exists vl : list val, eval_simple_list' (Econs r1 rl) vl.","conclusion":"exists vl : list val, eval_simple_list' (Econs r1 rl) vl","hypotheses":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) (v1 : val) (EV1 : eval_simple_rvalue e m r1 v1)","proofString":"exploit (IHrl (fun x => C(Econs (Eval v1 (typeof r1)) x))); eauto.\napply (eval_simple_rvalue_safe (fun x => C(Econs x rl))); eauto.\nintros [vl EVl].\nexists (v1 :: vl); constructor; auto."},{"statement":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) (v1 : val) (EV1 : eval_simple_rvalue e m r1 v1) : safe (ExprState f (C (Econs (Eval v1 (typeof r1)) rl)) k e m).","conclusion":"safe (ExprState f (C (Econs (Eval v1 (typeof r1)) rl)) k e m)","hypotheses":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) (v1 : val) (EV1 : eval_simple_rvalue e m r1 v1)","proofString":"apply (eval_simple_rvalue_safe (fun x => C(Econs x rl))); eauto."},{"statement":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) (v1 : val) (EV1 : eval_simple_rvalue e m r1 v1) : (exists vl : list val, eval_simple_list' rl vl) ->\nexists vl : list val, eval_simple_list' (Econs r1 rl) vl.","conclusion":"(exists vl : list val, eval_simple_list' rl vl) ->\nexists vl : list val, eval_simple_list' (Econs r1 rl) vl","hypotheses":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl : list val, eval_simple_list' rl vl) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) (v1 : val) (EV1 : eval_simple_rvalue e m r1 v1)","proofString":"intros [vl EVl].\nexists (v1 :: vl); constructor; auto."},{"statement":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl0 : list val, eval_simple_list' rl vl0) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) (v1 : val) (EV1 : eval_simple_rvalue e m r1 v1) (vl : list val) (EVl : eval_simple_list' rl vl) : exists vl0 : list val, eval_simple_list' (Econs r1 rl) vl0.","conclusion":"exists vl0 : list val, eval_simple_list' (Econs r1 rl) vl0","hypotheses":"(r1 : expr) (rl : exprlist) (IHrl : forall C0 : exprlist -> expr,\nsimplelist rl = true ->\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nexists vl0 : list val, eval_simple_list' rl vl0) (C : exprlist -> expr) (H : simple r1 && simplelist rl = true) (H0 : contextlist' C) (H1 : safe (ExprState f (C (Econs r1 rl)) k e m)) (H2 : simple r1 = true) (H3 : simplelist rl = true) (v1 : val) (EV1 : eval_simple_rvalue e m r1 v1) (vl : list val) (EVl : eval_simple_list' rl vl)","proofString":"exists (v1 :: vl); constructor; auto."},{"statement":"(rl : exprlist) : True.","conclusion":"True","hypotheses":"(rl : exprlist)","proofString":"auto."},{"statement":"(a : val) (vl : list val) (IHvl : forall rl0 : exprlist, exprlist_all_values (rval_list vl rl0)) (rl : exprlist) : exprlist_all_values\n  match rl with\n  | Enil => Enil\n  | Econs r1 rl' => Econs (Eval a (typeof r1)) (rval_list vl rl')\n  end.","conclusion":"exprlist_all_values\n  match rl with\n  | Enil => Enil\n  | Econs r1 rl' => Econs (Eval a (typeof r1)) (rval_list vl rl')\n  end","hypotheses":"(a : val) (vl : list val) (IHvl : forall rl0 : exprlist, exprlist_all_values (rval_list vl rl0)) (rl : exprlist)","proofString":"destruct rl; simpl; auto."},{"statement":"(l : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 l) k e m) ->\nsimple l = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   l = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (f0 : ident) (ty : type) (from : kind) (C : expr -> expr) (H0 : context from RV C) (H1 : safe (ExprState f (C (Efield l f0 ty)) k e m)) : simple l = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   Efield l f0 ty = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C').","conclusion":"simple l = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   Efield l f0 ty = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')","hypotheses":"(l : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 l) k e m) ->\nsimple l = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   l = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (f0 : ident) (ty : type) (from : kind) (C : expr -> expr) (H0 : context from RV C) (H1 : safe (ExprState f (C (Efield l f0 ty)) k e m))","proofString":"Ltac Kind :=  exploit safe_expr_kind; eauto; simpl; intros X; rewrite <- X in *; clear X.\nLtac Rec HR kind C C' :=  destruct (HR kind (fun x => C(C' x))) as [? | [C'' [a' [D [A B]]]]];  [eauto | eauto | auto |   right; exists (fun x => C'(C'' x)); exists a'; rewrite D; auto].\nLtac Base :=  right; exists (fun x => x); econstructor; split; [eauto | simpl; auto].\nKind.\nRec H RV C (fun x => Efield x f0 ty)."},{"statement":"(l : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 l) k e m) ->\nsimple l = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   l = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Evalof l ty)) k e m)) (H2 : simple l = true) (Heqb : type_is_volatile (typeof l) = false) : simple l && negb false = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   Evalof l ty = C' a' /\\ simple_side_effect a' /\\ leftcontext RV RV C').","conclusion":"simple l && negb false = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   Evalof l ty = C' a' /\\ simple_side_effect a' /\\ leftcontext RV RV C')","hypotheses":"(l : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 l) k e m) ->\nsimple l = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   l = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Evalof l ty)) k e m)) (H2 : simple l = true) (Heqb : type_is_volatile (typeof l) = false)","proofString":"rewrite H2; auto."},{"statement":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true) : contextlist' (fun x : exprlist => C (Ecall r1 x ty)).","conclusion":"contextlist' (fun x : exprlist => C (Ecall r1 x ty))","hypotheses":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true)","proofString":"eapply contextlist'_call with (C := C) (rl0 := Enil).\nauto."},{"statement":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true) : context RV RV C.","conclusion":"context RV RV C","hypotheses":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true)","proofString":"auto."},{"statement":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true) : safe (ExprState f (C (Ecall r1 rargs ty)) k e m).","conclusion":"safe (ExprState f (C (Ecall r1 rargs ty)) k e m)","hypotheses":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from0 C')) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true)","proofString":"auto."},{"statement":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from0 C'0)) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rargs = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true) (C' : expr -> exprlist) (a' : expr) (D : rargs = C' a') (A : simple_side_effect a') (B : leftcontextlist RV C') : false = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   Ecall r1 rargs ty = C'0 a'0 /\\\n   simple_side_effect a'0 /\\ leftcontext RV RV C'0).","conclusion":"false = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   Ecall r1 rargs ty = C'0 a'0 /\\\n   simple_side_effect a'0 /\\ leftcontext RV RV C'0)","hypotheses":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from0 C'0)) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rargs = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true) (C' : expr -> exprlist) (a' : expr) (D : rargs = C' a') (A : simple_side_effect a') (B : leftcontextlist RV C')","proofString":"right; exists (fun x => Ecall r1 (C' x) ty); exists a'.\nrewrite D; simpl; auto."},{"statement":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from0 C'0)) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rargs = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true) (C' : expr -> exprlist) (a' : expr) (D : rargs = C' a') (A : simple_side_effect a') (B : leftcontextlist RV C') : Ecall r1 rargs ty = Ecall r1 (C' a') ty /\\\nsimple_side_effect a' /\\\nleftcontext RV RV (fun x : expr => Ecall r1 (C' x) ty).","conclusion":"Ecall r1 rargs ty = Ecall r1 (C' a') ty /\\\nsimple_side_effect a' /\\\nleftcontext RV RV (fun x : expr => Ecall r1 (C' x) ty)","hypotheses":"(r1 : expr) (H : forall (from0 : kind) (C0 : expr -> expr),\ncontext from0 RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from0 C'0)) (rargs : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rargs = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (ty : type) (from : kind) (C : expr -> expr) (H1 : context RV RV C) (H2 : safe (ExprState f (C (Ecall r1 rargs ty)) k e m)) (H3 : simple r1 = true) (C' : expr -> exprlist) (a' : expr) (D : rargs = C' a') (A : simple_side_effect a') (B : leftcontextlist RV C')","proofString":"rewrite D; simpl; auto."},{"statement":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)) : contextlist' (fun x : exprlist => C (Ebuiltin ef tyargs x ty)).","conclusion":"contextlist' (fun x : exprlist => C (Ebuiltin ef tyargs x ty))","hypotheses":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))","proofString":"eapply contextlist'_builtin with (C := C) (rl0 := Enil).\nauto."},{"statement":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)) : context RV RV C.","conclusion":"context RV RV C","hypotheses":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))","proofString":"auto."},{"statement":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)) : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m).","conclusion":"safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)","hypotheses":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rargs = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))","proofString":"auto."},{"statement":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rargs = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)) (C' : expr -> exprlist) (a' : expr) (D : rargs = C' a') (A : simple_side_effect a') (B : leftcontextlist RV C') : false = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   Ebuiltin ef tyargs rargs ty = C'0 a'0 /\\\n   simple_side_effect a'0 /\\ leftcontext RV RV C'0).","conclusion":"false = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   Ebuiltin ef tyargs rargs ty = C'0 a'0 /\\\n   simple_side_effect a'0 /\\ leftcontext RV RV C'0)","hypotheses":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rargs = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)) (C' : expr -> exprlist) (a' : expr) (D : rargs = C' a') (A : simple_side_effect a') (B : leftcontextlist RV C')","proofString":"right; exists (fun x => Ebuiltin ef tyargs (C' x) ty); exists a'.\nrewrite D; simpl; auto."},{"statement":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rargs = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)) (C' : expr -> exprlist) (a' : expr) (D : rargs = C' a') (A : simple_side_effect a') (B : leftcontextlist RV C') : Ebuiltin ef tyargs rargs ty = Ebuiltin ef tyargs (C' a') ty /\\\nsimple_side_effect a' /\\\nleftcontext RV RV (fun x : expr => Ebuiltin ef tyargs (C' x) ty).","conclusion":"Ebuiltin ef tyargs rargs ty = Ebuiltin ef tyargs (C' a') ty /\\\nsimple_side_effect a' /\\\nleftcontext RV RV (fun x : expr => Ebuiltin ef tyargs (C' x) ty)","hypotheses":"(ef : external_function) (tyargs : list type) (rargs : exprlist) (H : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rargs) k e m) ->\nsimplelist rargs = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rargs = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (ty : type) (from : kind) (C : expr -> expr) (H0 : context RV RV C) (H1 : safe (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)) (C' : expr -> exprlist) (a' : expr) (D : rargs = C' a') (A : simple_side_effect a') (B : leftcontextlist RV C')","proofString":"rewrite D; simpl; auto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) : simple r1 && simplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   Econs r1 rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C').","conclusion":"simple r1 && simplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   Econs r1 rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m))","proofString":"destruct (H RV (fun x => C (Econs x rl))) as [A | [C' [a' [A [B D]]]]].\neapply contextlist'_head; eauto.\nauto.\ndestruct (H0 (fun x => C (Econs r1 x))) as [A' | [C' [a' [A' [B D]]]]].\neapply contextlist'_tail; eauto.\nauto.\nrewrite A; rewrite A'; auto.\nright; exists (fun x => Econs r1 (C' x)); exists a'.\nrewrite A'; eauto.\nright; exists (fun x => Econs (C' x) rl); exists a'.\nrewrite A; eauto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) : context RV RV (fun x : expr => C (Econs x rl)).","conclusion":"context RV RV (fun x : expr => C (Econs x rl))","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m))","proofString":"eapply contextlist'_head; eauto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) : safe (ExprState f (C (Econs r1 rl)) k e m).","conclusion":"safe (ExprState f (C (Econs r1 rl)) k e m)","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m))","proofString":"auto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true) : simple r1 && simplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   Econs r1 rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C').","conclusion":"simple r1 && simplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   Econs r1 rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true)","proofString":"destruct (H0 (fun x => C (Econs r1 x))) as [A' | [C' [a' [A' [B D]]]]].\neapply contextlist'_tail; eauto.\nauto.\nrewrite A; rewrite A'; auto.\nright; exists (fun x => Econs r1 (C' x)); exists a'.\nrewrite A'; eauto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true) : contextlist' (fun x : exprlist => C (Econs r1 x)).","conclusion":"contextlist' (fun x : exprlist => C (Econs r1 x))","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true)","proofString":"eapply contextlist'_tail; eauto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true) : safe (ExprState f (C (Econs r1 rl)) k e m).","conclusion":"safe (ExprState f (C (Econs r1 rl)) k e m)","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true)","proofString":"auto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true) (A' : simplelist rl = true) : simple r1 && simplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   Econs r1 rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C').","conclusion":"simple r1 && simplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   Econs r1 rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C' : expr -> expr) (a' : expr),\n   r1 = C' a' /\\ simple_side_effect a' /\\ leftcontext RV from C')) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C' : expr -> exprlist) (a' : expr),\n   rl = C' a' /\\ simple_side_effect a' /\\ leftcontextlist RV C')) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true) (A' : simplelist rl = true)","proofString":"rewrite A; rewrite A'; auto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from C'0)) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true) (C' : expr -> exprlist) (a' : expr) (A' : rl = C' a') (B : simple_side_effect a') (D : leftcontextlist RV C') : simple r1 && simplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   Econs r1 rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0).","conclusion":"simple r1 && simplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   Econs r1 rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from C'0)) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true) (C' : expr -> exprlist) (a' : expr) (A' : rl = C' a') (B : simple_side_effect a') (D : leftcontextlist RV C')","proofString":"right; exists (fun x => Econs r1 (C' x)); exists a'.\nrewrite A'; eauto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from C'0)) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true) (C' : expr -> exprlist) (a' : expr) (A' : rl = C' a') (B : simple_side_effect a') (D : leftcontextlist RV C') : Econs r1 rl = Econs r1 (C' a') /\\\nsimple_side_effect a' /\\ leftcontextlist RV (fun x : expr => Econs r1 (C' x)).","conclusion":"Econs r1 rl = Econs r1 (C' a') /\\\nsimple_side_effect a' /\\ leftcontextlist RV (fun x : expr => Econs r1 (C' x))","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from C'0)) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (A : simple r1 = true) (C' : expr -> exprlist) (a' : expr) (A' : rl = C' a') (B : simple_side_effect a') (D : leftcontextlist RV C')","proofString":"rewrite A'; eauto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from C'0)) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (C' : expr -> expr) (a' : expr) (A : r1 = C' a') (B : simple_side_effect a') (D : leftcontext RV RV C') : simple r1 && simplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   Econs r1 rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0).","conclusion":"simple r1 && simplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   Econs r1 rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from C'0)) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (C' : expr -> expr) (a' : expr) (A : r1 = C' a') (B : simple_side_effect a') (D : leftcontext RV RV C')","proofString":"right; exists (fun x => Econs (C' x) rl); exists a'.\nrewrite A; eauto."},{"statement":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from C'0)) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (C' : expr -> expr) (a' : expr) (A : r1 = C' a') (B : simple_side_effect a') (D : leftcontext RV RV C') : Econs r1 rl = Econs (C' a') rl /\\\nsimple_side_effect a' /\\ leftcontextlist RV (fun x : expr => Econs (C' x) rl).","conclusion":"Econs r1 rl = Econs (C' a') rl /\\\nsimple_side_effect a' /\\ leftcontextlist RV (fun x : expr => Econs (C' x) rl)","hypotheses":"(r1 : expr) (H : forall (from : kind) (C0 : expr -> expr),\ncontext from RV C0 ->\nsafe (ExprState f (C0 r1) k e m) ->\nsimple r1 = true \\/\n(exists (C'0 : expr -> expr) (a'0 : expr),\n   r1 = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontext RV from C'0)) (rl : exprlist) (H0 : forall C0 : exprlist -> expr,\ncontextlist' C0 ->\nsafe (ExprState f (C0 rl) k e m) ->\nsimplelist rl = true \\/\n(exists (C'0 : expr -> exprlist) (a'0 : expr),\n   rl = C'0 a'0 /\\ simple_side_effect a'0 /\\ leftcontextlist RV C'0)) (C : exprlist -> expr) (H1 : contextlist' C) (H2 : safe (ExprState f (C (Econs r1 rl)) k e m)) (C' : expr -> expr) (a' : expr) (A : r1 = C' a') (B : simple_side_effect a') (D : leftcontext RV RV C')","proofString":"rewrite A; eauto."},{"statement":"(a : expr) (H : safe (ExprState f a k e m)) : simple a = true \\/\n(exists (C : expr -> expr) (a' : expr),\n   a = C a' /\\ simple_side_effect a' /\\ leftcontext RV RV C).","conclusion":"simple a = true \\/\n(exists (C : expr -> expr) (a' : expr),\n   a = C a' /\\ simple_side_effect a' /\\ leftcontext RV RV C)","hypotheses":"(a : expr) (H : safe (ExprState f a k e m))","proofString":"eapply (proj1 decompose_expr).\napply ctx_top.\nauto."},{"statement":"(S : state) (t : trace) (S' : state) (H : estep S t S') : plus Csem.step ge S t S'.","conclusion":"plus Csem.step ge S t S'","hypotheses":"(S : state) (t : trace) (S' : state) (H : estep S t S')","proofString":"inv H.\nexploit eval_simple_rvalue_steps; eauto.\nsimpl; intros STEPS.\nexploit star_inv; eauto.\nintros [[EQ1 EQ2] | A]; eauto.\ninversion EQ1.\nrewrite <- H2 in H1; contradiction.\neapply plus_right.\neapply eval_simple_lvalue_steps with (C := fun x => C(Evalof x (typeof l))); eauto.\nleft.\napply step_rred; eauto.\neconstructor; eauto.\nauto.\neapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eseqand x r2 ty)); eauto.\nleft.\napply step_rred; eauto.\napply red_seqand_true; auto.\ntraceEq.\neapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eseqand x r2 ty)); eauto.\nleft.\napply step_rred; eauto.\napply red_seqand_false; auto.\ntraceEq.\neapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eseqor x r2 ty)); eauto.\nleft.\napply step_rred; eauto.\napply red_seqor_true; auto.\ntraceEq.\neapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eseqor x r2 ty)); eauto.\nleft.\napply step_rred; eauto.\napply red_seqor_false; auto.\ntraceEq.\neapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Econdition x r2 r3 ty)); eauto.\nleft; apply step_rred; eauto.\nconstructor; auto.\nauto.\neapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Eassign x r (typeof l))); eauto.\neapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eassign (Eloc b ofs bf (typeof l)) x (typeof l))); eauto.\nleft; apply step_rred; eauto.\neconstructor; eauto.\nreflexivity.\nauto.\neapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Eassignop op x r tyres (typeof l))); eauto.\neapply star_plus_trans.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eassignop op (Eloc b ofs bf (typeof l)) x tyres (typeof l))); eauto.\neapply plus_left.\nleft; apply step_rred; auto.\neconstructor; eauto.\neapply star_left.\nleft; apply step_rred with (C := fun x => C(Eassign (Eloc b ofs bf (typeof l)) x (typeof l))); eauto.\neconstructor; eauto.\napply star_one.\nleft; apply step_rred; auto.\neconstructor; eauto.\nreflexivity.\nreflexivity.\nreflexivity.\ntraceEq.\neapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Eassignop op x r tyres (typeof l))); eauto.\neapply star_plus_trans.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eassignop op (Eloc b ofs bf (typeof l)) x tyres (typeof l))); eauto.\neapply plus_left.\nleft; apply step_rred; auto.\neconstructor; eauto.\ndestruct (sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m) as [v3|] eqn:?.\neapply star_left.\nleft; apply step_rred with (C := fun x => C(Eassign (Eloc b ofs bf (typeof l)) x (typeof l))); eauto.\neconstructor; eauto.\napply star_one.\nleft; eapply step_stuck; eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v4' [m' [v' [t' [A [B D]]]]]].\nrewrite B in H4.\neelim H4; eauto.\nreflexivity.\napply star_one.\nleft; eapply step_stuck with (C := fun x => C(Eassign (Eloc b ofs bf (typeof l)) x (typeof l))); eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v3 A].\ncongruence.\nreflexivity.\nreflexivity.\ntraceEq.\neapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Epostincr id x (typeof l))); eauto.\neapply plus_left.\nleft; apply step_rred; auto.\neconstructor; eauto.\neapply star_left.\nleft; apply step_rred with (C := fun x => C (Ecomma (Eassign (Eloc b ofs bf (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.\neconstructor.\ninstantiate (1 := v2).\ndestruct id; assumption.\neapply star_left.\nleft; apply step_rred with (C := fun x => C (Ecomma x (Eval v1 (typeof l)) (typeof l))); eauto.\neconstructor; eauto.\napply star_one.\nleft; apply step_rred; auto.\neconstructor; eauto.\nreflexivity.\nreflexivity.\nreflexivity.\ntraceEq.\neapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Epostincr id x (typeof l))); eauto.\neapply plus_left.\nleft; apply step_rred; auto.\neconstructor; eauto.\nset (op := match id with Incr => Oadd | Decr => Osub end).\nassert (SEM: sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =              sem_incrdecr ge id v1 (typeof l) m).\ndestruct id; auto.\ndestruct (sem_incrdecr ge id v1 (typeof l) m) as [v2|].\neapply star_left.\nleft; apply step_rred with (C := fun x => C (Ecomma (Eassign (Eloc b ofs bf (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.\neconstructor; eauto.\napply star_one.\nleft; eapply step_stuck with (C := fun x => C (Ecomma x (Eval v1 (typeof l)) (typeof l))); eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v3 [m' [v' [t' [A [B D]]]]]].\nrewrite B in H3.\neelim H3; eauto.\nreflexivity.\napply star_one.\nleft; eapply step_stuck with (C := fun x => C (Ecomma (Eassign (Eloc b ofs bf (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v2 A].\ncongruence.\nreflexivity.\ntraceEq.\neapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Ecomma x r2 (typeof r2))); eauto.\nleft; apply step_rred; eauto.\neconstructor; eauto.\nauto.\neapply plus_right; eauto.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eparen x tycast ty)); eauto.\nleft; apply step_rred; eauto.\neconstructor; eauto.\nauto.\nexploit eval_simple_list_implies; eauto.\nintros [vl' [A B]].\neapply star_plus_trans.\neapply eval_simple_rvalue_steps with (C := fun x => C(Ecall x rargs ty)); eauto.\neapply plus_right.\neapply eval_simple_list_steps with (C := fun x => C(Ecall (Eval vf (typeof rf)) x ty)); eauto.\neapply contextlist'_call with (rl0 := Enil); auto.\nleft; apply Csem.step_call; eauto.\neconstructor; eauto.\ntraceEq.\nauto.\nexploit eval_simple_list_implies; eauto.\nintros [vl' [A B]].\neapply plus_right.\neapply eval_simple_list_steps with (C := fun x => C(Ebuiltin ef tyargs x ty)); eauto.\neapply contextlist'_builtin with (rl0 := Enil); auto.\nleft; apply Csem.step_rred; eauto.\neconstructor; eauto.\ntraceEq."},{"statement":"(f : function) (r : expr) (k : cont) (e : env) (m : mem) (v : val) (H0 : eval_simple_rvalue e m r v) (H1 : match r with\n| Eval _ _ => False\n| _ => True\nend) : plus Csem.step ge (ExprState f r k e m) E0\n  (ExprState f (Eval v (typeof r)) k e m).","conclusion":"plus Csem.step ge (ExprState f r k e m) E0\n  (ExprState f (Eval v (typeof r)) k e m)","hypotheses":"(f : function) (r : expr) (k : cont) (e : env) (m : mem) (v : val) (H0 : eval_simple_rvalue e m r v) (H1 : match r with\n| Eval _ _ => False\n| _ => True\nend)","proofString":"exploit eval_simple_rvalue_steps; eauto.\nsimpl; intros STEPS.\nexploit star_inv; eauto.\nintros [[EQ1 EQ2] | A]; eauto.\ninversion EQ1.\nrewrite <- H2 in H1; contradiction."},{"statement":"(f : function) (r : expr) (k : cont) (e : env) (m : mem) (v : val) (H0 : eval_simple_rvalue e m r v) (H1 : match r with\n| Eval _ _ => False\n| _ => True\nend) (STEPS : star Csem.step ge (ExprState f r k e m) E0\n  (ExprState f (Eval v (typeof r)) k e m)) (EQ1 : ExprState f (Eval v (typeof r)) k e m = ExprState f r k e m) (EQ2 : E0 = E0) : plus Csem.step ge (ExprState f r k e m) E0\n  (ExprState f (Eval v (typeof r)) k e m).","conclusion":"plus Csem.step ge (ExprState f r k e m) E0\n  (ExprState f (Eval v (typeof r)) k e m)","hypotheses":"(f : function) (r : expr) (k : cont) (e : env) (m : mem) (v : val) (H0 : eval_simple_rvalue e m r v) (H1 : match r with\n| Eval _ _ => False\n| _ => True\nend) (STEPS : star Csem.step ge (ExprState f r k e m) E0\n  (ExprState f (Eval v (typeof r)) k e m)) (EQ1 : ExprState f (Eval v (typeof r)) k e m = ExprState f r k e m) (EQ2 : E0 = E0)","proofString":"inversion EQ1.\nrewrite <- H2 in H1; contradiction."},{"statement":"(f : function) (r : expr) (k : cont) (e : env) (m : mem) (v : val) (H0 : eval_simple_rvalue e m r v) (H1 : match r with\n| Eval _ _ => False\n| _ => True\nend) (STEPS : star Csem.step ge (ExprState f r k e m) E0\n  (ExprState f (Eval v (typeof r)) k e m)) (EQ1 : ExprState f (Eval v (typeof r)) k e m = ExprState f r k e m) (EQ2 : E0 = E0) (H2 : Eval v (typeof r) = r) : plus Csem.step ge (ExprState f (Eval v (typeof r)) k e m) E0\n  (ExprState f (Eval v (typeof (Eval v (typeof r)))) k e m).","conclusion":"plus Csem.step ge (ExprState f (Eval v (typeof r)) k e m) E0\n  (ExprState f (Eval v (typeof (Eval v (typeof r)))) k e m)","hypotheses":"(f : function) (r : expr) (k : cont) (e : env) (m : mem) (v : val) (H0 : eval_simple_rvalue e m r v) (H1 : match r with\n| Eval _ _ => False\n| _ => True\nend) (STEPS : star Csem.step ge (ExprState f r k e m) E0\n  (ExprState f (Eval v (typeof r)) k e m)) (EQ1 : ExprState f (Eval v (typeof r)) k e m = ExprState f r k e m) (EQ2 : E0 = E0) (H2 : Eval v (typeof r) = r)","proofString":"rewrite <- H2 in H1; contradiction."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v) (H4 : type_is_volatile (typeof l) = true) : plus Csem.step ge (ExprState f (C (Evalof l (typeof l))) k e m) t\n  (ExprState f (C (Eval v (typeof l))) k e m).","conclusion":"plus Csem.step ge (ExprState f (C (Evalof l (typeof l))) k e m) t\n  (ExprState f (C (Eval v (typeof l))) k e m)","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v) (H4 : type_is_volatile (typeof l) = true)","proofString":"eapply plus_right.\neapply eval_simple_lvalue_steps with (C := fun x => C(Evalof x (typeof l))); eauto.\nleft.\napply step_rred; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : function) (C : expr -> expr) (r1 r2 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some true) : plus Csem.step ge (ExprState f (C (Eseqand r1 r2 ty)) k e m) E0\n  (ExprState f (C (Eparen r2 type_bool ty)) k e m).","conclusion":"plus Csem.step ge (ExprState f (C (Eseqand r1 r2 ty)) k e m) E0\n  (ExprState f (C (Eparen r2 type_bool ty)) k e m)","hypotheses":"(f : function) (C : expr -> expr) (r1 r2 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some true)","proofString":"eapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eseqand x r2 ty)); eauto.\nleft.\napply step_rred; eauto.\napply red_seqand_true; auto.\ntraceEq."},{"statement":"(f : function) (C : expr -> expr) (r1 r2 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some false) : plus Csem.step ge (ExprState f (C (Eseqand r1 r2 ty)) k e m) E0\n  (ExprState f (C (Eval (Vint Int.zero) ty)) k e m).","conclusion":"plus Csem.step ge (ExprState f (C (Eseqand r1 r2 ty)) k e m) E0\n  (ExprState f (C (Eval (Vint Int.zero) ty)) k e m)","hypotheses":"(f : function) (C : expr -> expr) (r1 r2 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some false)","proofString":"eapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eseqand x r2 ty)); eauto.\nleft.\napply step_rred; eauto.\napply red_seqand_false; auto.\ntraceEq."},{"statement":"(f : function) (C : expr -> expr) (r1 r2 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some true) : plus Csem.step ge (ExprState f (C (Eseqor r1 r2 ty)) k e m) E0\n  (ExprState f (C (Eval (Vint Int.one) ty)) k e m).","conclusion":"plus Csem.step ge (ExprState f (C (Eseqor r1 r2 ty)) k e m) E0\n  (ExprState f (C (Eval (Vint Int.one) ty)) k e m)","hypotheses":"(f : function) (C : expr -> expr) (r1 r2 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some true)","proofString":"eapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eseqor x r2 ty)); eauto.\nleft.\napply step_rred; eauto.\napply red_seqor_true; auto.\ntraceEq."},{"statement":"(f : function) (C : expr -> expr) (r1 r2 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some false) : plus Csem.step ge (ExprState f (C (Eseqor r1 r2 ty)) k e m) E0\n  (ExprState f (C (Eparen r2 type_bool ty)) k e m).","conclusion":"plus Csem.step ge (ExprState f (C (Eseqor r1 r2 ty)) k e m) E0\n  (ExprState f (C (Eparen r2 type_bool ty)) k e m)","hypotheses":"(f : function) (C : expr -> expr) (r1 r2 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some false)","proofString":"eapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eseqor x r2 ty)); eauto.\nleft.\napply step_rred; eauto.\napply red_seqor_false; auto.\ntraceEq."},{"statement":"(f : function) (C : expr -> expr) (r1 r2 r3 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (b : bool) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some b) : plus Csem.step ge (ExprState f (C (Econdition r1 r2 r3 ty)) k e m) E0\n  (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m).","conclusion":"plus Csem.step ge (ExprState f (C (Econdition r1 r2 r3 ty)) k e m) E0\n  (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)","hypotheses":"(f : function) (C : expr -> expr) (r1 r2 r3 : expr) (ty : type) (k : cont) (e : env) (m : mem) (v : val) (b : bool) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) (H2 : bool_val v (typeof r1) m = Some b)","proofString":"eapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Econdition x r2 r3 ty)); eauto.\nleft; apply step_rred; eauto.\nconstructor; auto.\nauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (m' : mem) (v' : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : eval_simple_rvalue e m r v) (H3 : sem_cast v (typeof r) (typeof l) m = Some v1) (H4 : assign_loc ge (typeof l) m b ofs bf v1 t m' v') : plus Csem.step ge (ExprState f (C (Eassign l r (typeof l))) k e m) t\n  (ExprState f (C (Eval v' (typeof l))) k e m').","conclusion":"plus Csem.step ge (ExprState f (C (Eassign l r (typeof l))) k e m) t\n  (ExprState f (C (Eval v' (typeof l))) k e m')","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (m' : mem) (v' : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : eval_simple_rvalue e m r v) (H3 : sem_cast v (typeof r) (typeof l) m = Some v1) (H4 : assign_loc ge (typeof l) m b ofs bf v1 t m' v')","proofString":"eapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Eassign x r (typeof l))); eauto.\neapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eassign (Eloc b ofs bf (typeof l)) x (typeof l))); eauto.\nleft; apply step_rred; eauto.\neconstructor; eauto.\nreflexivity.\nauto."},{"statement":"(f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t1 v1) (H3 : eval_simple_rvalue e m r v2) (H4 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') : plus Csem.step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (t1 ** t2) (ExprState f (C (Eval v' (typeof l))) k e m').","conclusion":"plus Csem.step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (t1 ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')","hypotheses":"(f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t1 v1) (H3 : eval_simple_rvalue e m r v2) (H4 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v')","proofString":"eapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Eassignop op x r tyres (typeof l))); eauto.\neapply star_plus_trans.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eassignop op (Eloc b ofs bf (typeof l)) x tyres (typeof l))); eauto.\neapply plus_left.\nleft; apply step_rred; auto.\neconstructor; eauto.\neapply star_left.\nleft; apply step_rred with (C := fun x => C(Eassign (Eloc b ofs bf (typeof l)) x (typeof l))); eauto.\neconstructor; eauto.\napply star_one.\nleft; apply step_rred; auto.\neconstructor; eauto.\nreflexivity.\nreflexivity.\nreflexivity.\ntraceEq."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (H4 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) : plus Csem.step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  t Stuckstate.","conclusion":"plus Csem.step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  t Stuckstate","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (H4 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend)","proofString":"eapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Eassignop op x r tyres (typeof l))); eauto.\neapply star_plus_trans.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eassignop op (Eloc b ofs bf (typeof l)) x tyres (typeof l))); eauto.\neapply plus_left.\nleft; apply step_rred; auto.\neconstructor; eauto.\ndestruct (sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m) as [v3|] eqn:?.\neapply star_left.\nleft; apply step_rred with (C := fun x => C(Eassign (Eloc b ofs bf (typeof l)) x (typeof l))); eauto.\neconstructor; eauto.\napply star_one.\nleft; eapply step_stuck; eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v4' [m' [v' [t' [A [B D]]]]]].\nrewrite B in H4.\neelim H4; eauto.\nreflexivity.\napply star_one.\nleft; eapply step_stuck with (C := fun x => C(Eassign (Eloc b ofs bf (typeof l)) x (typeof l))); eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v3 A].\ncongruence.\nreflexivity.\nreflexivity.\ntraceEq."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n| None => True\nend) : ~\nimm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m.","conclusion":"~\nimm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n| None => True\nend)","proofString":"red; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v4' [m' [v' [t' [A [B D]]]]]].\nrewrite B in H4.\neelim H4; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n| None => True\nend) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m) : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n| None => True\nend) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m)","proofString":"exploit imm_safe_inv; eauto.\nsimpl.\nintros [v4' [m' [v' [t' [A [B D]]]]]].\nrewrite B in H4.\neelim H4; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n| None => True\nend) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m) : match Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l) with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ =>\n    invert_expr_prop e\n      (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m\nend -> False.","conclusion":"match Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l) with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ =>\n    invert_expr_prop e\n      (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m\nend -> False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n| None => True\nend) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m)","proofString":"simpl.\nintros [v4' [m' [v' [t' [A [B D]]]]]].\nrewrite B in H4.\neelim H4; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n| None => True\nend) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m) : (exists (v : val) (m' : mem) (v' : val) (t0 : trace),\n   typeof l = typeof l /\\\n   sem_cast v3 tyres (typeof l) m = Some v /\\\n   assign_loc ge (typeof l) m b ofs bf v t0 m' v') -> False.","conclusion":"(exists (v : val) (m' : mem) (v' : val) (t0 : trace),\n   typeof l = typeof l /\\\n   sem_cast v3 tyres (typeof l) m = Some v /\\\n   assign_loc ge (typeof l) m b ofs bf v t0 m' v') -> False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n| None => True\nend) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m)","proofString":"intros [v4' [m' [v' [t' [A [B D]]]]]].\nrewrite B in H4.\neelim H4; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m'0 : mem) (v'0 : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m'0 v'0\n| None => True\nend) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m) (v4' : val) (m' : mem) (v' : val) (t' : trace) (A : typeof l = typeof l) (B : sem_cast v3 tyres (typeof l) m = Some v4') (D : assign_loc ge (typeof l) m b ofs bf v4' t' m' v') : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H4 : match sem_cast v3 tyres (typeof l) m with\n| Some v4 =>\n    forall (t2 : trace) (m'0 : mem) (v'0 : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m'0 v'0\n| None => True\nend) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m) (v4' : val) (m' : mem) (v' : val) (t' : trace) (A : typeof l = typeof l) (B : sem_cast v3 tyres (typeof l) m = Some v4') (D : assign_loc ge (typeof l) m b ofs bf v4' t' m' v')","proofString":"rewrite B in H4.\neelim H4; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (v4' : val) (H4 : forall (t2 : trace) (m'0 : mem) (v'0 : val),\n~ assign_loc ge (typeof l) m b ofs bf v4' t2 m'0 v'0) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m) (m' : mem) (v' : val) (t' : trace) (A : typeof l = typeof l) (B : sem_cast v3 tyres (typeof l) m = Some v4') (D : assign_loc ge (typeof l) m b ofs bf v4' t' m' v') : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (v3 : val) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (v4' : val) (H4 : forall (t2 : trace) (m'0 : mem) (v'0 : val),\n~ assign_loc ge (typeof l) m b ofs bf v4' t2 m'0 v'0) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v3 tyres) (typeof l)) m) (m' : mem) (v' : val) (t' : trace) (A : typeof l = typeof l) (B : sem_cast v3 tyres (typeof l) m = Some v4') (D : assign_loc ge (typeof l) m b ofs bf v4' t' m' v')","proofString":"eelim H4; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) : Csem.step ge\n  (ExprState f\n     (C\n        (Eassign (Eloc b ofs bf (typeof l))\n           (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n           (typeof l))) k e m) (E0 ** E0) Stuckstate.","conclusion":"Csem.step ge\n  (ExprState f\n     (C\n        (Eassign (Eloc b ofs bf (typeof l))\n           (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n           (typeof l))) k e m) (E0 ** E0) Stuckstate","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True)","proofString":"left; eapply step_stuck with (C := fun x => C(Eassign (Eloc b ofs bf (typeof l)) x (typeof l))); eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v3 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) : ~\nimm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m.","conclusion":"~\nimm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True)","proofString":"red; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v3 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) (H : imm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m) : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) (H : imm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m)","proofString":"exploit imm_safe_inv; eauto.\nsimpl.\nintros [v3 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) (H : imm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m) : match Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ =>\n    invert_expr_prop e\n      (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres) m\nend -> False.","conclusion":"match Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ =>\n    invert_expr_prop e\n      (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres) m\nend -> False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) (H : imm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m)","proofString":"simpl.\nintros [v3 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) (H : imm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m) : (exists v : val,\n   sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v) ->\nFalse.","conclusion":"(exists v : val,\n   sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v) ->\nFalse","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) (H : imm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m)","proofString":"intros [v3 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) (H : imm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m) (v3 : val) (A : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue e m r v2) (Heqo : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = None) (H4 : True) (H : imm_safe ge e RV (Ebinop op (Eval v1 (typeof l)) (Eval v2 (typeof r)) tyres)\n  m) (v3 : val) (A : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3)","proofString":"congruence."},{"statement":"(f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H5 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H2 : deref_loc ge (typeof l) m b ofs bf t1 v1) : plus Csem.step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (t1 ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m').","conclusion":"plus Csem.step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (t1 ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')","hypotheses":"(f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H5 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H2 : deref_loc ge (typeof l) m b ofs bf t1 v1)","proofString":"eapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Epostincr id x (typeof l))); eauto.\neapply plus_left.\nleft; apply step_rred; auto.\neconstructor; eauto.\neapply star_left.\nleft; apply step_rred with (C := fun x => C (Ecomma (Eassign (Eloc b ofs bf (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.\neconstructor.\ninstantiate (1 := v2).\ndestruct id; assumption.\neapply star_left.\nleft; apply step_rred with (C := fun x => C (Ecomma x (Eval v1 (typeof l)) (typeof l))); eauto.\neconstructor; eauto.\napply star_one.\nleft; apply step_rred; auto.\neconstructor; eauto.\nreflexivity.\nreflexivity.\nreflexivity.\ntraceEq."},{"statement":"(f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H5 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H2 : deref_loc ge (typeof l) m b ofs bf t1 v1) : sem_binary_operation ge match id with\n                        | Incr => Oadd\n                        | Decr => Osub\n                        end v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2.","conclusion":"sem_binary_operation ge match id with\n                        | Incr => Oadd\n                        | Decr => Osub\n                        end v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2","hypotheses":"(f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H5 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H2 : deref_loc ge (typeof l) m b ofs bf t1 v1)","proofString":"destruct id; assumption."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) : plus Csem.step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) t\n  Stuckstate.","conclusion":"plus Csem.step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) t\n  Stuckstate","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1)","proofString":"eapply star_plus_trans.\neapply eval_simple_lvalue_steps with (C := fun x => C(Epostincr id x (typeof l))); eauto.\neapply plus_left.\nleft; apply step_rred; auto.\neconstructor; eauto.\nset (op := match id with Incr => Oadd | Decr => Osub end).\nassert (SEM: sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =              sem_incrdecr ge id v1 (typeof l) m).\ndestruct id; auto.\ndestruct (sem_incrdecr ge id v1 (typeof l) m) as [v2|].\neapply star_left.\nleft; apply step_rred with (C := fun x => C (Ecomma (Eassign (Eloc b ofs bf (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.\neconstructor; eauto.\napply star_one.\nleft; eapply step_stuck with (C := fun x => C (Ecomma x (Eval v1 (typeof l)) (typeof l))); eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v3 [m' [v' [t' [A [B D]]]]]].\nrewrite B in H3.\neelim H3; eauto.\nreflexivity.\napply star_one.\nleft; eapply step_stuck with (C := fun x => C (Ecomma (Eassign (Eloc b ofs bf (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v2 A].\ncongruence.\nreflexivity.\ntraceEq."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v3 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) : ~\nimm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m.","conclusion":"~\nimm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v3 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2)","proofString":"red; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v3 [m' [v' [t' [A [B D]]]]]].\nrewrite B in H3.\neelim H3; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v3 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m) : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v3 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m)","proofString":"exploit imm_safe_inv; eauto.\nsimpl.\nintros [v3 [m' [v' [t' [A [B D]]]]]].\nrewrite B in H3.\neelim H3; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v3 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m) : match\n  Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n    (typeof l)\nwith\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ =>\n    invert_expr_prop e\n      (Eassign (Eloc b ofs bf (typeof l))\n         (Eval v2 (incrdecr_type (typeof l))) (typeof l)) m\nend -> False.","conclusion":"match\n  Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n    (typeof l)\nwith\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ =>\n    invert_expr_prop e\n      (Eassign (Eloc b ofs bf (typeof l))\n         (Eval v2 (incrdecr_type (typeof l))) (typeof l)) m\nend -> False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v3 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m)","proofString":"simpl.\nintros [v3 [m' [v' [t' [A [B D]]]]]].\nrewrite B in H3.\neelim H3; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v3 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m) : (exists (v : val) (m' : mem) (v' : val) (t0 : trace),\n   typeof l = typeof l /\\\n   sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v /\\\n   assign_loc ge (typeof l) m b ofs bf v t0 m' v') -> False.","conclusion":"(exists (v : val) (m' : mem) (v' : val) (t0 : trace),\n   typeof l = typeof l /\\\n   sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v /\\\n   assign_loc ge (typeof l) m b ofs bf v t0 m' v') -> False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v3 =>\n    forall (t2 : trace) (m' : mem) (v' : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m)","proofString":"intros [v3 [m' [v' [t' [A [B D]]]]]].\nrewrite B in H3.\neelim H3; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v0 =>\n    forall (t2 : trace) (m'0 : mem) (v'0 : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v0 t2 m'0 v'0\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m) (v3 : val) (m' : mem) (v' : val) (t' : trace) (A : typeof l = typeof l) (B : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (D : assign_loc ge (typeof l) m b ofs bf v3 t' m' v') : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 : val) (H3 : match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n| Some v0 =>\n    forall (t2 : trace) (m'0 : mem) (v'0 : val),\n    ~ assign_loc ge (typeof l) m b ofs bf v0 t2 m'0 v'0\n| None => True\nend) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m) (v3 : val) (m' : mem) (v' : val) (t' : trace) (A : typeof l = typeof l) (B : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (D : assign_loc ge (typeof l) m b ofs bf v3 t' m' v')","proofString":"rewrite B in H3.\neelim H3; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 v3 : val) (H3 : forall (t2 : trace) (m'0 : mem) (v'0 : val),\n~ assign_loc ge (typeof l) m b ofs bf v3 t2 m'0 v'0) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m) (m' : mem) (v' : val) (t' : trace) (A : typeof l = typeof l) (B : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (D : assign_loc ge (typeof l) m b ofs bf v3 t' m' v') : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (v2 v3 : val) (H3 : forall (t2 : trace) (m'0 : mem) (v'0 : val),\n~ assign_loc ge (typeof l) m b ofs bf v3 t2 m'0 v'0) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) (H : imm_safe ge e RV\n  (Eassign (Eloc b ofs bf (typeof l)) (Eval v2 (incrdecr_type (typeof l)))\n     (typeof l)) m) (m' : mem) (v' : val) (t' : trace) (A : typeof l = typeof l) (B : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (D : assign_loc ge (typeof l) m b ofs bf v3 t' m' v')","proofString":"eelim H3; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) : Csem.step ge\n  (ExprState f\n     (C\n        (Ecomma\n           (Eassign (Eloc b ofs bf (typeof l))\n              (Ebinop op (Eval v1 (typeof l))\n                 (Eval (Vint Int.one) type_int32s) \n                 (incrdecr_type (typeof l))) (typeof l)) \n           (Eval v1 (typeof l)) (typeof l))) k e m) \n  (E0 ** E0) Stuckstate.","conclusion":"Csem.step ge\n  (ExprState f\n     (C\n        (Ecomma\n           (Eassign (Eloc b ofs bf (typeof l))\n              (Ebinop op (Eval v1 (typeof l))\n                 (Eval (Vint Int.one) type_int32s) \n                 (incrdecr_type (typeof l))) (typeof l)) \n           (Eval v1 (typeof l)) (typeof l))) k e m) \n  (E0 ** E0) Stuckstate","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None)","proofString":"left; eapply step_stuck with (C := fun x => C (Ecomma (Eassign (Eloc b ofs bf (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.\nred; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v2 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) : ~\nimm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m.","conclusion":"~\nimm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None)","proofString":"red; intros.\nexploit imm_safe_inv; eauto.\nsimpl.\nintros [v2 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) (H : imm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m) : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) (H : imm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m)","proofString":"exploit imm_safe_inv; eauto.\nsimpl.\nintros [v2 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) (H : imm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m) : match\n  Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n    (incrdecr_type (typeof l))\nwith\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ =>\n    invert_expr_prop e\n      (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n         (incrdecr_type (typeof l))) m\nend -> False.","conclusion":"match\n  Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n    (incrdecr_type (typeof l))\nwith\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ =>\n    invert_expr_prop e\n      (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n         (incrdecr_type (typeof l))) m\nend -> False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) (H : imm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m)","proofString":"simpl.\nintros [v2 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) (H : imm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m) : (exists v : val,\n   sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\n   Some v) -> False.","conclusion":"(exists v : val,\n   sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\n   Some v) -> False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) (H : imm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m)","proofString":"intros [v2 A].\ncongruence."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) (H : imm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m) (v2 : val) (A : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2) : False.","conclusion":"False","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_lvalue e m l b ofs bf) (H3 : True) (H2 : deref_loc ge (typeof l) m b ofs bf t v1) (op : binary_operation) (SEM : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m = None) (H : imm_safe ge e RV\n  (Ebinop op (Eval v1 (typeof l)) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type (typeof l))) m) (v2 : val) (A : sem_binary_operation ge op v1 (typeof l) (Vint Int.one) type_int32s m =\nSome v2)","proofString":"congruence."},{"statement":"(f : function) (C : expr -> expr) (r1 r2 : expr) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v) : plus Csem.step ge (ExprState f (C (Ecomma r1 r2 (typeof r2))) k e m) E0\n  (ExprState f (C r2) k e m).","conclusion":"plus Csem.step ge (ExprState f (C (Ecomma r1 r2 (typeof r2))) k e m) E0\n  (ExprState f (C r2) k e m)","hypotheses":"(f : function) (C : expr -> expr) (r1 r2 : expr) (k : cont) (e : env) (m : mem) (v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r1 v)","proofString":"eapply plus_right.\neapply eval_simple_rvalue_steps with (C := fun x => C(Ecomma x r2 (typeof r2))); eauto.\nleft; apply step_rred; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : function) (C : expr -> expr) (r : expr) (tycast ty : type) (k : cont) (e : env) (m : mem) (v1 v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r v1) (H2 : sem_cast v1 (typeof r) tycast m = Some v) : plus Csem.step ge (ExprState f (C (Eparen r tycast ty)) k e m) E0\n  (ExprState f (C (Eval v ty)) k e m).","conclusion":"plus Csem.step ge (ExprState f (C (Eparen r tycast ty)) k e m) E0\n  (ExprState f (C (Eval v ty)) k e m)","hypotheses":"(f : function) (C : expr -> expr) (r : expr) (tycast ty : type) (k : cont) (e : env) (m : mem) (v1 v : val) (H0 : leftcontext RV RV C) (H1 : eval_simple_rvalue e m r v1) (H2 : sem_cast v1 (typeof r) tycast m = Some v)","proofString":"eapply plus_right; eauto.\neapply eval_simple_rvalue_steps with (C := fun x => C(Eparen x tycast ty)); eauto.\nleft; apply step_rred; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv) : plus Csem.step ge (ExprState f (C (Ecall rf rargs ty)) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"plus Csem.step ge (ExprState f (C (Ecall rf rargs ty)) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv)","proofString":"exploit eval_simple_list_implies; eauto.\nintros [vl' [A B]].\neapply star_plus_trans.\neapply eval_simple_rvalue_steps with (C := fun x => C(Ecall x rargs ty)); eauto.\neapply plus_right.\neapply eval_simple_list_steps with (C := fun x => C(Ecall (Eval vf (typeof rf)) x ty)); eauto.\neapply contextlist'_call with (rl0 := Enil); auto.\nleft; apply Csem.step_call; eauto.\neconstructor; eauto.\ntraceEq.\nauto."},{"statement":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv) : (exists vl' : list val,\n   cast_arguments m (rval_list vl' rargs) targs vargs /\\\n   eval_simple_list' e m rargs vl') ->\nplus Csem.step ge (ExprState f (C (Ecall rf rargs ty)) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"(exists vl' : list val,\n   cast_arguments m (rval_list vl' rargs) targs vargs /\\\n   eval_simple_list' e m rargs vl') ->\nplus Csem.step ge (ExprState f (C (Ecall rf rargs ty)) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv)","proofString":"intros [vl' [A B]].\neapply star_plus_trans.\neapply eval_simple_rvalue_steps with (C := fun x => C(Ecall x rargs ty)); eauto.\neapply plus_right.\neapply eval_simple_list_steps with (C := fun x => C(Ecall (Eval vf (typeof rf)) x ty)); eauto.\neapply contextlist'_call with (rl0 := Enil); auto.\nleft; apply Csem.step_call; eauto.\neconstructor; eauto.\ntraceEq.\nauto."},{"statement":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv) (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) targs vargs) (B : eval_simple_list' e m rargs vl') : plus Csem.step ge (ExprState f (C (Ecall rf rargs ty)) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"plus Csem.step ge (ExprState f (C (Ecall rf rargs ty)) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv) (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) targs vargs) (B : eval_simple_list' e m rargs vl')","proofString":"eapply star_plus_trans.\neapply eval_simple_rvalue_steps with (C := fun x => C(Ecall x rargs ty)); eauto.\neapply plus_right.\neapply eval_simple_list_steps with (C := fun x => C(Ecall (Eval vf (typeof rf)) x ty)); eauto.\neapply contextlist'_call with (rl0 := Enil); auto.\nleft; apply Csem.step_call; eauto.\neconstructor; eauto.\ntraceEq.\nauto."},{"statement":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv) (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) targs vargs) (B : eval_simple_list' e m rargs vl') : contextlist' (fun x : exprlist => C (Ecall (Eval vf (typeof rf)) x ty)).","conclusion":"contextlist' (fun x : exprlist => C (Ecall (Eval vf (typeof rf)) x ty))","hypotheses":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv) (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) targs vargs) (B : eval_simple_list' e m rargs vl')","proofString":"eapply contextlist'_call with (rl0 := Enil); auto."},{"statement":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv) (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) targs vargs) (B : eval_simple_list' e m rargs vl') : callred ge (Ecall (Eval vf (typeof rf)) (rval_list vl' rargs) ty) m fd vargs\n  ty.","conclusion":"callred ge (Ecall (Eval vf (typeof rf)) (rval_list vl' rargs) ty) m fd vargs\n  ty","hypotheses":"(f : function) (C : expr -> expr) (rf : expr) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : fundef) (H0 : leftcontext RV RV C) (H1 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H2 : eval_simple_rvalue e m rf vf) (H3 : eval_simple_list e m rargs targs vargs) (H4 : Genv.find_funct ge vf = Some fd) (H5 : type_of_fundef fd = Tfunction targs tres cconv) (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) targs vargs) (B : eval_simple_list' e m rargs vl')","proofString":"econstructor; eauto."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : leftcontext RV RV C) (H1 : eval_simple_list e m rargs tyargs vargs) (H2 : external_call ef ge vargs m t vres m') : plus Csem.step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) t\n  (ExprState f (C (Eval vres ty)) k e m').","conclusion":"plus Csem.step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) t\n  (ExprState f (C (Eval vres ty)) k e m')","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : leftcontext RV RV C) (H1 : eval_simple_list e m rargs tyargs vargs) (H2 : external_call ef ge vargs m t vres m')","proofString":"exploit eval_simple_list_implies; eauto.\nintros [vl' [A B]].\neapply plus_right.\neapply eval_simple_list_steps with (C := fun x => C(Ebuiltin ef tyargs x ty)); eauto.\neapply contextlist'_builtin with (rl0 := Enil); auto.\nleft; apply Csem.step_rred; eauto.\neconstructor; eauto.\ntraceEq."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : leftcontext RV RV C) (H1 : eval_simple_list e m rargs tyargs vargs) (H2 : external_call ef ge vargs m t vres m') : (exists vl' : list val,\n   cast_arguments m (rval_list vl' rargs) tyargs vargs /\\\n   eval_simple_list' e m rargs vl') ->\nplus Csem.step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) t\n  (ExprState f (C (Eval vres ty)) k e m').","conclusion":"(exists vl' : list val,\n   cast_arguments m (rval_list vl' rargs) tyargs vargs /\\\n   eval_simple_list' e m rargs vl') ->\nplus Csem.step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) t\n  (ExprState f (C (Eval vres ty)) k e m')","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : leftcontext RV RV C) (H1 : eval_simple_list e m rargs tyargs vargs) (H2 : external_call ef ge vargs m t vres m')","proofString":"intros [vl' [A B]].\neapply plus_right.\neapply eval_simple_list_steps with (C := fun x => C(Ebuiltin ef tyargs x ty)); eauto.\neapply contextlist'_builtin with (rl0 := Enil); auto.\nleft; apply Csem.step_rred; eauto.\neconstructor; eauto.\ntraceEq."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : leftcontext RV RV C) (H1 : eval_simple_list e m rargs tyargs vargs) (H2 : external_call ef ge vargs m t vres m') (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) tyargs vargs) (B : eval_simple_list' e m rargs vl') : plus Csem.step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) t\n  (ExprState f (C (Eval vres ty)) k e m').","conclusion":"plus Csem.step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) t\n  (ExprState f (C (Eval vres ty)) k e m')","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : leftcontext RV RV C) (H1 : eval_simple_list e m rargs tyargs vargs) (H2 : external_call ef ge vargs m t vres m') (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) tyargs vargs) (B : eval_simple_list' e m rargs vl')","proofString":"eapply plus_right.\neapply eval_simple_list_steps with (C := fun x => C(Ebuiltin ef tyargs x ty)); eauto.\neapply contextlist'_builtin with (rl0 := Enil); auto.\nleft; apply Csem.step_rred; eauto.\neconstructor; eauto.\ntraceEq."},{"statement":"(t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : leftcontext RV RV C) (H1 : eval_simple_list e m rargs tyargs vargs) (H2 : external_call ef ge vargs m t vres m') (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) tyargs vargs) (B : eval_simple_list' e m rargs vl') : contextlist' (fun x : exprlist => C (Ebuiltin ef tyargs x ty)).","conclusion":"contextlist' (fun x : exprlist => C (Ebuiltin ef tyargs x ty))","hypotheses":"(t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H0 : leftcontext RV RV C) (H1 : eval_simple_list e m rargs tyargs vargs) (H2 : external_call ef ge vargs m t vres m') (vl' : list val) (A : cast_arguments m (rval_list vl' rargs) tyargs vargs) (B : eval_simple_list' e m rargs vl')","proofString":"eapply contextlist'_builtin with (rl0 := Enil); auto."},{"statement":"(S1 : state) (t : trace) (S2 : state) (H : step S1 t S2) : plus Csem.step ge S1 t S2.","conclusion":"plus Csem.step ge S1 t S2","hypotheses":"(S1 : state) (t : trace) (S2 : state) (H : step S1 t S2)","proofString":"inv H.\napply estep_simulation; auto.\napply plus_one.\nright.\nauto."},{"statement":"(S1 : state) (t : trace) (S2 : state) (H0 : estep S1 t S2) : plus Csem.step ge S1 t S2.","conclusion":"plus Csem.step ge S1 t S2","hypotheses":"(S1 : state) (t : trace) (S2 : state) (H0 : estep S1 t S2)","proofString":"apply estep_simulation; auto."},{"statement":"(S1 : state) (t : trace) (S2 : state) (H0 : sstep ge S1 t S2) : plus Csem.step ge S1 t S2.","conclusion":"plus Csem.step ge S1 t S2","hypotheses":"(S1 : state) (t : trace) (S2 : state) (H0 : sstep ge S1 t S2)","proofString":"apply plus_one.\nright.\nauto."},{"statement":"(S1 : state) (t : trace) (S2 : state) (H0 : sstep ge S1 t S2) : Csem.step ge S1 t S2.","conclusion":"Csem.step ge S1 t S2","hypotheses":"(S1 : state) (t : trace) (S2 : state) (H0 : sstep ge S1 t S2)","proofString":"right.\nauto."},{"statement":"(S1 : state) (t : trace) (S2 : state) (H0 : sstep ge S1 t S2) : sstep ge S1 t S2.","conclusion":"sstep ge S1 t S2","hypotheses":"(S1 : state) (t : trace) (S2 : state) (H0 : sstep ge S1 t S2)","proofString":"auto."},{"statement":"(S : state) (H : safe S) : (exists r : int, final_state S r) \\/\n(exists (t : trace) (S' : state), step S t S').","conclusion":"(exists r : int, final_state S r) \\/\n(exists (t : trace) (S' : state), step S t S')","hypotheses":"(S : state) (H : safe S)","proofString":"exploit H.\napply star_refl.\nintros [FIN | [t [S' STEP]]].\nauto.\nright.\ndestruct STEP.\nassert (exists t, exists S', estep S t S').\ninv H0.\neapply can_estep; eauto.\ninv H2; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\nexploit (H Stuckstate).\napply star_one.\nleft.\neconstructor; eauto.\nintros [[r F] | [t [S' R]]].\ninv F.\ninv R.\ninv H0.\ninv H0.\ndestruct H1 as [t' [S'' ESTEP]].\nexists t'; exists S''; left; auto.\nexists t; exists S'; right; auto."},{"statement":"(S : state) (H : safe S) (FIN : exists r : int, final_state S r) : (exists r : int, final_state S r) \\/\n(exists (t : trace) (S' : state), step S t S').","conclusion":"(exists r : int, final_state S r) \\/\n(exists (t : trace) (S' : state), step S t S')","hypotheses":"(S : state) (H : safe S) (FIN : exists r : int, final_state S r)","proofString":"auto."},{"statement":"(S : state) (H : safe S) (t : trace) (S' : state) (STEP : Csem.step ge S t S') : (exists r : int, final_state S r) \\/\n(exists (t0 : trace) (S'0 : state), step S t0 S'0).","conclusion":"(exists r : int, final_state S r) \\/\n(exists (t0 : trace) (S'0 : state), step S t0 S'0)","hypotheses":"(S : state) (H : safe S) (t : trace) (S' : state) (STEP : Csem.step ge S t S')","proofString":"right.\ndestruct STEP.\nassert (exists t, exists S', estep S t S').\ninv H0.\neapply can_estep; eauto.\ninv H2; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\nexploit (H Stuckstate).\napply star_one.\nleft.\neconstructor; eauto.\nintros [[r F] | [t [S' R]]].\ninv F.\ninv R.\ninv H0.\ninv H0.\ndestruct H1 as [t' [S'' ESTEP]].\nexists t'; exists S''; left; auto.\nexists t; exists S'; right; auto."},{"statement":"(S : state) (H : safe S) (t : trace) (S' : state) (STEP : Csem.step ge S t S') : exists (t0 : trace) (S'0 : state), step S t0 S'0.","conclusion":"exists (t0 : trace) (S'0 : state), step S t0 S'0","hypotheses":"(S : state) (H : safe S) (t : trace) (S' : state) (STEP : Csem.step ge S t S')","proofString":"destruct STEP.\nassert (exists t, exists S', estep S t S').\ninv H0.\neapply can_estep; eauto.\ninv H2; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\nexploit (H Stuckstate).\napply star_one.\nleft.\neconstructor; eauto.\nintros [[r F] | [t [S' R]]].\ninv F.\ninv R.\ninv H0.\ninv H0.\ndestruct H1 as [t' [S'' ESTEP]].\nexists t'; exists S''; left; auto.\nexists t; exists S'; right; auto."},{"statement":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : Csem.estep ge S t S') : exists (t0 : trace) (S'0 : state), step S t0 S'0.","conclusion":"exists (t0 : trace) (S'0 : state), step S t0 S'0","hypotheses":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : Csem.estep ge S t S')","proofString":"assert (exists t, exists S', estep S t S').\ninv H0.\neapply can_estep; eauto.\ninv H2; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\nexploit (H Stuckstate).\napply star_one.\nleft.\neconstructor; eauto.\nintros [[r F] | [t [S' R]]].\ninv F.\ninv R.\ninv H0.\ninv H0.\ndestruct H1 as [t' [S'' ESTEP]].\nexists t'; exists S''; left; auto."},{"statement":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : Csem.estep ge S t S') : exists (t0 : trace) (S'0 : state), estep S t0 S'0.","conclusion":"exists (t0 : trace) (S'0 : state), estep S t0 S'0","hypotheses":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : Csem.estep ge S t S')","proofString":"inv H0.\neapply can_estep; eauto.\ninv H2; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\neapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto.\nexploit (H Stuckstate).\napply star_one.\nleft.\neconstructor; eauto.\nintros [[r F] | [t [S' R]]].\ninv F.\ninv R.\ninv H0.\ninv H0."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (a' : expr) (m' : mem) (H1 : lred ge e a m a' m') (H2 : context LV RV C) : exists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'.","conclusion":"exists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (a' : expr) (m' : mem) (H1 : lred ge e a m a' m') (H2 : context LV RV C)","proofString":"eapply can_estep; eauto.\ninv H2; auto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (a' : expr) (m' : mem) (H1 : lred ge e a m a' m') (H2 : context LV RV C) : match C a with\n| Eval _ _ => False\n| _ => True\nend.","conclusion":"match C a with\n| Eval _ _ => False\n| _ => True\nend","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (a' : expr) (m' : mem) (H1 : lred ge e a m a' m') (H2 : context LV RV C)","proofString":"inv H2; auto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (t : trace) (a' : expr) (m' : mem) (H1 : rred ge a m t a' m') (H2 : context RV RV C) : exists (t0 : trace) (S' : state), estep (ExprState f (C a) k e m) t0 S'.","conclusion":"exists (t0 : trace) (S' : state), estep (ExprState f (C a) k e m) t0 S'","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (t : trace) (a' : expr) (m' : mem) (H1 : rred ge a m t a' m') (H2 : context RV RV C)","proofString":"eapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (t : trace) (a' : expr) (m' : mem) (H1 : rred ge a m t a' m') (H2 : context RV RV C) : match C a with\n| Eval _ _ => False\n| _ => True\nend.","conclusion":"match C a with\n| Eval _ _ => False\n| _ => True\nend","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (t : trace) (a' : expr) (m' : mem) (H1 : rred ge a m t a' m') (H2 : context RV RV C)","proofString":"inv H2; auto.\ninv H1; auto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f a k e m)) (t : trace) (a' : expr) (m' : mem) (H1 : rred ge a m t a' m') : match a with\n| Eval _ _ => False\n| _ => True\nend.","conclusion":"match a with\n| Eval _ _ => False\n| _ => True\nend","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f a k e m)) (t : trace) (a' : expr) (m' : mem) (H1 : rred ge a m t a' m')","proofString":"inv H1; auto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (fd : fundef) (vargs : list val) (ty : type) (H1 : callred ge a m fd vargs ty) (H2 : context RV RV C) : exists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'.","conclusion":"exists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (fd : fundef) (vargs : list val) (ty : type) (H1 : callred ge a m fd vargs ty) (H2 : context RV RV C)","proofString":"eapply can_estep; eauto.\ninv H2; auto.\ninv H1; auto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (fd : fundef) (vargs : list val) (ty : type) (H1 : callred ge a m fd vargs ty) (H2 : context RV RV C) : match C a with\n| Eval _ _ => False\n| _ => True\nend.","conclusion":"match C a with\n| Eval _ _ => False\n| _ => True\nend","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (fd : fundef) (vargs : list val) (ty : type) (H1 : callred ge a m fd vargs ty) (H2 : context RV RV C)","proofString":"inv H2; auto.\ninv H1; auto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f a k e m)) (fd : fundef) (vargs : list val) (ty : type) (H1 : callred ge a m fd vargs ty) : match a with\n| Eval _ _ => False\n| _ => True\nend.","conclusion":"match a with\n| Eval _ _ => False\n| _ => True\nend","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f a k e m)) (fd : fundef) (vargs : list val) (ty : type) (H1 : callred ge a m fd vargs ty)","proofString":"inv H1; auto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) : exists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'.","conclusion":"exists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m)","proofString":"exploit (H Stuckstate).\napply star_one.\nleft.\neconstructor; eauto.\nintros [[r F] | [t [S' R]]].\ninv F.\ninv R.\ninv H0.\ninv H0."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) : star Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate.","conclusion":"star Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m)","proofString":"apply star_one.\nleft.\neconstructor; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) : Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate.","conclusion":"Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m)","proofString":"left.\neconstructor; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) : Csem.estep ge (ExprState f (C a) k e m) E0 Stuckstate.","conclusion":"Csem.estep ge (ExprState f (C a) k e m) E0 Stuckstate","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m)","proofString":"econstructor; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) : (exists r : int, final_state Stuckstate r) \\/\n(exists (t : trace) (s'' : state), Csem.step ge Stuckstate t s'') ->\nexists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'.","conclusion":"(exists r : int, final_state Stuckstate r) \\/\n(exists (t : trace) (s'' : state), Csem.step ge Stuckstate t s'') ->\nexists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m)","proofString":"intros [[r F] | [t [S' R]]].\ninv F.\ninv R.\ninv H0.\ninv H0."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) (r : int) (F : final_state Stuckstate r) : exists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'.","conclusion":"exists (t : trace) (S' : state), estep (ExprState f (C a) k e m) t S'","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) (r : int) (F : final_state Stuckstate r)","proofString":"inv F."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) (t : trace) (S' : state) (R : Csem.step ge Stuckstate t S') : exists (t0 : trace) (S'0 : state), estep (ExprState f (C a) k e m) t0 S'0.","conclusion":"exists (t0 : trace) (S'0 : state), estep (ExprState f (C a) k e m) t0 S'0","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) (t : trace) (S' : state) (R : Csem.step ge Stuckstate t S')","proofString":"inv R.\ninv H0.\ninv H0."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) (t : trace) (S' : state) (H0 : Csem.estep ge Stuckstate t S') : exists (t0 : trace) (S'0 : state), estep (ExprState f (C a) k e m) t0 S'0.","conclusion":"exists (t0 : trace) (S'0 : state), estep (ExprState f (C a) k e m) t0 S'0","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) (t : trace) (S' : state) (H0 : Csem.estep ge Stuckstate t S')","proofString":"inv H0."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) (t : trace) (S' : state) (H0 : sstep ge Stuckstate t S') : exists (t0 : trace) (S'0 : state), estep (ExprState f (C a) k e m) t0 S'0.","conclusion":"exists (t0 : trace) (S'0 : state), estep (ExprState f (C a) k e m) t0 S'0","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : safe (ExprState f (C a) k e m)) (K : kind) (H1 : context K RV C) (H2 : ~ imm_safe ge e K a m) (t : trace) (S' : state) (H0 : sstep ge Stuckstate t S')","proofString":"inv H0."},{"statement":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : Csem.estep ge S t S') (H1 : exists (t0 : trace) (S'0 : state), estep S t0 S'0) : exists (t0 : trace) (S'0 : state), step S t0 S'0.","conclusion":"exists (t0 : trace) (S'0 : state), step S t0 S'0","hypotheses":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : Csem.estep ge S t S') (H1 : exists (t0 : trace) (S'0 : state), estep S t0 S'0)","proofString":"destruct H1 as [t' [S'' ESTEP]].\nexists t'; exists S''; left; auto."},{"statement":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : Csem.estep ge S t S') (t' : trace) (S'' : state) (ESTEP : estep S t' S'') : exists (t0 : trace) (S'0 : state), step S t0 S'0.","conclusion":"exists (t0 : trace) (S'0 : state), step S t0 S'0","hypotheses":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : Csem.estep ge S t S') (t' : trace) (S'' : state) (ESTEP : estep S t' S'')","proofString":"exists t'; exists S''; left; auto."},{"statement":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : sstep ge S t S') : exists (t0 : trace) (S'0 : state), step S t0 S'0.","conclusion":"exists (t0 : trace) (S'0 : state), step S t0 S'0","hypotheses":"(S : state) (H : safe S) (t : trace) (S' : state) (H0 : sstep ge S t S')","proofString":"exists t; exists S'; right; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) : match t with\n| _ :: _ :: _ => False\n| _ => True\nend.","conclusion":"match t with\n| _ :: _ :: _ => False\n| _ => True\nend","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v)","proofString":"inv H; simpl; auto.\ninv H2; simpl; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v) : match t with\n| _ :: _ :: _ => False\n| _ => True\nend.","conclusion":"match t with\n| _ :: _ :: _ => False\n| _ => True\nend","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v)","proofString":"inv H2; simpl; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (ev2 : event) (H : deref_loc ge ty m b ofs bf (ev1 :: t1) v) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) : t1 = nil /\\ (exists v' : val, deref_loc ge ty m b ofs bf (ev2 :: nil) v').","conclusion":"t1 = nil /\\ (exists v' : val, deref_loc ge ty m b ofs bf (ev2 :: nil) v')","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (ev2 : event) (H : deref_loc ge ty m b ofs bf (ev1 :: t1) v) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil))","proofString":"assert (t1 = nil).\nexploit deref_loc_trace; eauto.\ndestruct t1; simpl; tauto.\ninv H.\nexploit volatile_load_receptive; eauto.\nintros [v' A].\nsplit; auto; exists v'; econstructor; eauto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (ev2 : event) (H : deref_loc ge ty m b ofs bf (ev1 :: t1) v) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) : t1 = nil.","conclusion":"t1 = nil","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (ev2 : event) (H : deref_loc ge ty m b ofs bf (ev1 :: t1) v) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil))","proofString":"exploit deref_loc_trace; eauto.\ndestruct t1; simpl; tauto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (ev2 : event) (H : deref_loc ge ty m b ofs bf (ev1 :: t1) v) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) : match ev1 :: t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> t1 = nil.","conclusion":"match ev1 :: t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> t1 = nil","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (ev2 : event) (H : deref_loc ge ty m b ofs bf (ev1 :: t1) v) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil))","proofString":"destruct t1; simpl; tauto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (ev2 : event) (H : deref_loc ge ty m b ofs bf (ev1 :: t1) v) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) (H1 : t1 = nil) : t1 = nil /\\ (exists v' : val, deref_loc ge ty m b ofs bf (ev2 :: nil) v').","conclusion":"t1 = nil /\\ (exists v' : val, deref_loc ge ty m b ofs bf (ev2 :: nil) v')","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (ev2 : event) (H : deref_loc ge ty m b ofs bf (ev1 :: t1) v) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) (H1 : t1 = nil)","proofString":"inv H.\nexploit volatile_load_receptive; eauto.\nintros [v' A].\nsplit; auto; exists v'; econstructor; eauto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' : val) (H : assign_loc ge ty m b ofs bf v t m' v') : match t with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend.","conclusion":"match t with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' : val) (H : assign_loc ge ty m b ofs bf v t m' v')","proofString":"inv H; simpl; auto.\ninv H2; simpl; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m') : match t with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend.","conclusion":"match t with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m')","proofString":"inv H2; simpl; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (m' : mem) (v' : val) (ev2 : event) (H : assign_loc ge ty m b ofs bf v (ev1 :: t1) m' v') (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) : ev1 :: t1 = ev2 :: nil.","conclusion":"ev1 :: t1 = ev2 :: nil","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (m' : mem) (v' : val) (ev2 : event) (H : assign_loc ge ty m b ofs bf v (ev1 :: t1) m' v') (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil))","proofString":"assert (t1 = nil).\nexploit assign_loc_trace; eauto.\ndestruct t1; simpl; tauto.\ninv H.\neapply volatile_store_receptive; eauto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (m' : mem) (v' : val) (ev2 : event) (H : assign_loc ge ty m b ofs bf v (ev1 :: t1) m' v') (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) : t1 = nil.","conclusion":"t1 = nil","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (m' : mem) (v' : val) (ev2 : event) (H : assign_loc ge ty m b ofs bf v (ev1 :: t1) m' v') (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil))","proofString":"exploit assign_loc_trace; eauto.\ndestruct t1; simpl; tauto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (m' : mem) (v' : val) (ev2 : event) (H : assign_loc ge ty m b ofs bf v (ev1 :: t1) m' v') (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) : match ev1 :: t1 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend -> t1 = nil.","conclusion":"match ev1 :: t1 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend -> t1 = nil","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (m' : mem) (v' : val) (ev2 : event) (H : assign_loc ge ty m b ofs bf v (ev1 :: t1) m' v') (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil))","proofString":"destruct t1; simpl; tauto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (m' : mem) (v' : val) (ev2 : event) (H : assign_loc ge ty m b ofs bf v (ev1 :: t1) m' v') (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) (H1 : t1 = nil) : ev1 :: t1 = ev2 :: nil.","conclusion":"ev1 :: t1 = ev2 :: nil","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ev1 : event) (t1 : list event) (v : val) (m' : mem) (v' : val) (ev2 : event) (H : assign_loc ge ty m b ofs bf v (ev1 :: t1) m' v') (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) (H1 : t1 = nil)","proofString":"inv H.\neapply volatile_store_receptive; eauto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (ev1 : event) (m' : mem) (v' : val) (ev2 : event) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) (chunk : memory_chunk) (H2 : access_mode ty = By_value chunk) (H3 : type_is_volatile ty = true) (H4 : volatile_store ge chunk m b ofs v' (ev1 :: nil) m') : ev1 :: nil = ev2 :: nil.","conclusion":"ev1 :: nil = ev2 :: nil","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (ev1 : event) (m' : mem) (v' : val) (ev2 : event) (H0 : match_traces ge (ev1 :: nil) (ev2 :: nil)) (chunk : memory_chunk) (H2 : access_mode ty = By_value chunk) (H3 : type_is_volatile ty = true) (H4 : volatile_store ge chunk m b ofs v' (ev1 :: nil) m')","proofString":"eapply volatile_store_receptive; eauto."},{"statement":"(p : program) : strongly_receptive (semantics p).","conclusion":"strongly_receptive (semantics p)","hypotheses":"(p : program)","proofString":"constructor; simpl; intros.\nset (ge := globalenv p) in *.\ninversion H; subst.\ninv H1.\nexploit deref_loc_receptive; eauto.\nintros [A [v' B]].\neconstructor; econstructor.\nleft; eapply step_rvalof_volatile; eauto.\nexploit assign_loc_receptive; eauto.\nintro EQ; rewrite EQ in H.\neconstructor; econstructor; eauto.\ndestruct t0 as [ | ev0 t0]; simpl in H10.\nsubst t2.\nexploit assign_loc_receptive; eauto.\nintros EQ; rewrite EQ in H.\neconstructor; econstructor; eauto.\ninv H10.\nexploit deref_loc_receptive; eauto.\nintros [EQ [v1' A]].\nsubst t0.\ndestruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto.\nexploit deref_loc_receptive; eauto.\nintros [EQ [v1' A]].\nsubst t1.\ndestruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto.\ndestruct t0 as [ | ev0 t0]; simpl in H9.\nsubst t2.\nexploit assign_loc_receptive; eauto.\nintros EQ; rewrite EQ in H.\neconstructor; econstructor; eauto.\ninv H9.\nexploit deref_loc_receptive; eauto.\nintros [EQ [v1' A]].\nsubst t0.\ndestruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto.\nexploit deref_loc_receptive; eauto.\nintros [EQ [v1' A]].\nsubst t1.\ndestruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto.\nexploit external_call_trace_length; eauto.\ndestruct t1; simpl; intros.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\neconstructor; econstructor.\nleft; eapply step_builtin; eauto.\nextlia.\ninv H1.\nexploit external_call_trace_length; eauto.\ndestruct t1; simpl; intros.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2); exists E0; right; econstructor; eauto.\nextlia.\nred; intros.\ninv H; inv H0; simpl; auto.\nexploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto.\nexploit assign_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; simpl; tauto.\nexploit deref_loc_trace; eauto.\nexploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto.\nexploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto.\nexploit deref_loc_trace; eauto.\nexploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto.\nexploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto.\nexploit external_call_trace_length; eauto.\ndestruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia.\nexploit external_call_trace_length; eauto.\ndestruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia."},{"statement":"(p : program) (s : state) (ev1 : event) (t1 : list event) (s1 : state) (ev2 : event) (H : step (globalenv p) s (ev1 :: t1) s1) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) : exists (s2 : state) (t2 : list event), step (globalenv p) s (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event), step (globalenv p) s (ev2 :: t2) s2","hypotheses":"(p : program) (s : state) (ev1 : event) (t1 : list event) (s1 : state) (ev2 : event) (H : step (globalenv p) s (ev1 :: t1) s1) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil))","proofString":"set (ge := globalenv p) in *.\ninversion H; subst.\ninv H1.\nexploit deref_loc_receptive; eauto.\nintros [A [v' B]].\neconstructor; econstructor.\nleft; eapply step_rvalof_volatile; eauto.\nexploit assign_loc_receptive; eauto.\nintro EQ; rewrite EQ in H.\neconstructor; econstructor; eauto.\ndestruct t0 as [ | ev0 t0]; simpl in H10.\nsubst t2.\nexploit assign_loc_receptive; eauto.\nintros EQ; rewrite EQ in H.\neconstructor; econstructor; eauto.\ninv H10.\nexploit deref_loc_receptive; eauto.\nintros [EQ [v1' A]].\nsubst t0.\ndestruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto.\nexploit deref_loc_receptive; eauto.\nintros [EQ [v1' A]].\nsubst t1.\ndestruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto.\ndestruct t0 as [ | ev0 t0]; simpl in H9.\nsubst t2.\nexploit assign_loc_receptive; eauto.\nintros EQ; rewrite EQ in H.\neconstructor; econstructor; eauto.\ninv H9.\nexploit deref_loc_receptive; eauto.\nintros [EQ [v1' A]].\nsubst t0.\ndestruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto.\nexploit deref_loc_receptive; eauto.\nintros [EQ [v1' A]].\nsubst t1.\ndestruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto.\nexploit external_call_trace_length; eauto.\ndestruct t1; simpl; intros.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\neconstructor; econstructor.\nleft; eapply step_builtin; eauto.\nextlia.\ninv H1.\nexploit external_call_trace_length; eauto.\ndestruct t1; simpl; intros.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2); exists E0; right; econstructor; eauto.\nextlia."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (v : val) (H : step ge (ExprState f (C (Evalof l (typeof l))) k e m) \n  (ev1 :: t1) (ExprState f (C (Eval v (typeof l))) k e m)) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v) (H6 : type_is_volatile (typeof l) = true) : t1 = nil /\\\n(exists v' : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v') ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Evalof l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"t1 = nil /\\\n(exists v' : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v') ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Evalof l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (v : val) (H : step ge (ExprState f (C (Evalof l (typeof l))) k e m) \n  (ev1 :: t1) (ExprState f (C (Eval v (typeof l))) k e m)) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v) (H6 : type_is_volatile (typeof l) = true)","proofString":"intros [A [v' B]].\neconstructor; econstructor.\nleft; eapply step_rvalof_volatile; eauto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (v : val) (H : step ge (ExprState f (C (Evalof l (typeof l))) k e m) \n  (ev1 :: t1) (ExprState f (C (Eval v (typeof l))) k e m)) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v) (H6 : type_is_volatile (typeof l) = true) (A : t1 = nil) (v' : val) (B : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Evalof l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Evalof l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (v : val) (H : step ge (ExprState f (C (Evalof l (typeof l))) k e m) \n  (ev1 :: t1) (ExprState f (C (Eval v (typeof l))) k e m)) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v) (H6 : type_is_volatile (typeof l) = true) (A : t1 = nil) (v' : val) (B : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v')","proofString":"econstructor; econstructor.\nleft; eapply step_rvalof_volatile; eauto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m m' : mem) (v' : val) (H : step ge (ExprState f (C (Eassign l r (typeof l))) k e m) \n  (ev1 :: t1) (ExprState f (C (Eval v' (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : eval_simple_rvalue ge e m r v) (H5 : sem_cast v (typeof r) (typeof l) m = Some v1) (H6 : assign_loc ge (typeof l) m b ofs bf v1 (ev1 :: t1) m' v') : ev1 :: t1 = ev2 :: nil ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassign l r (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"ev1 :: t1 = ev2 :: nil ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassign l r (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m m' : mem) (v' : val) (H : step ge (ExprState f (C (Eassign l r (typeof l))) k e m) \n  (ev1 :: t1) (ExprState f (C (Eval v' (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : eval_simple_rvalue ge e m r v) (H5 : sem_cast v (typeof r) (typeof l) m = Some v1) (H6 : assign_loc ge (typeof l) m b ofs bf v1 (ev1 :: t1) m' v')","proofString":"intro EQ; rewrite EQ in H.\neconstructor; econstructor; eauto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m m' : mem) (v' : val) (H : step ge (ExprState f (C (Eassign l r (typeof l))) k e m) \n  (ev2 :: nil) (ExprState f (C (Eval v' (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : eval_simple_rvalue ge e m r v) (H5 : sem_cast v (typeof r) (typeof l) m = Some v1) (H6 : assign_loc ge (typeof l) m b ofs bf v1 (ev1 :: t1) m' v') (EQ : ev1 :: t1 = ev2 :: nil) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassign l r (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassign l r (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m m' : mem) (v' : val) (H : step ge (ExprState f (C (Eassign l r (typeof l))) k e m) \n  (ev2 :: nil) (ExprState f (C (Eval v' (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : eval_simple_rvalue ge e m r v) (H5 : sem_cast v (typeof r) (typeof l) m = Some v1) (H6 : assign_loc ge (typeof l) m b ofs bf v1 (ev1 :: t1) m' v') (EQ : ev1 :: t1 = ev2 :: nil)","proofString":"econstructor; econstructor; eauto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: t1) (ExprState f (C (Eval v' (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf nil v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 (ev1 :: t1) m' v') : ev1 :: t1 = ev2 :: nil ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"ev1 :: t1 = ev2 :: nil ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: t1) (ExprState f (C (Eval v' (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf nil v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 (ev1 :: t1) m' v')","proofString":"intros EQ; rewrite EQ in H.\neconstructor; econstructor; eauto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev2 :: nil) (ExprState f (C (Eval v' (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf nil v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 (ev1 :: t1) m' v') (EQ : ev1 :: t1 = ev2 :: nil) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev2 :: nil) (ExprState f (C (Eval v' (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf nil v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 (ev1 :: t1) m' v') (EQ : ev1 :: t1 = ev2 :: nil)","proofString":"econstructor; econstructor; eauto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t0 : list event) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: t0 ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: t0) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') : t0 = nil /\\\n(exists v'0 : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v'0) ->\nexists (s2 : state) (t1 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t1) s2.","conclusion":"t0 = nil /\\\n(exists v'0 : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v'0) ->\nexists (s2 : state) (t1 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t1) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t0 : list event) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: t0 ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: t0) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v')","proofString":"intros [EQ [v1' A]].\nsubst t0.\ndestruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t0 : list event) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: t0 ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: t0) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (EQ : t0 = nil) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') : exists (s2 : state) (t1 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t1) s2.","conclusion":"exists (s2 : state) (t1 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t1) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t0 : list event) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: t0 ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: t0) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (EQ : t0 = nil) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1')","proofString":"subst t0.\ndestruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1')","proofString":"destruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3')","proofString":"destruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4')","proofString":"destruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')","proofString":"destruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (t2' : trace) (m'' : mem) (v'' : val) (P : assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (t2' : trace) (m'' : mem) (v'' : val) (P : assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')","proofString":"econstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''))","proofString":"econstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) : match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v0 =>\n    match sem_cast v0 tyres (typeof l) m with\n    | Some v5 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v5 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v0 =>\n    match sem_cast v0 tyres (typeof l) m with\n    | Some v5 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v5 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''))","proofString":"rewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) : forall (t0 : trace) (m'0 : mem) (v'0 : val),\n~ assign_loc ge (typeof l) m b ofs bf v4' t0 m'0 v'0.","conclusion":"forall (t0 : trace) (m'0 : mem) (v'0 : val),\n~ assign_loc ge (typeof l) m b ofs bf v4' t0 m'0 v'0","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''))","proofString":"intros; red; intros; elim H1.\nexists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) (t0 : trace) (m'0 : mem) (v'0 : val) (H9 : assign_loc ge (typeof l) m b ofs bf v4' t0 m'0 v'0) : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''.","conclusion":"exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) (t0 : trace) (m'0 : mem) (v'0 : val) (H9 : assign_loc ge (typeof l) m b ofs bf v4' t0 m'0 v'0)","proofString":"exists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (Heqo0 : sem_cast v3' tyres (typeof l) m = None) : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (Heqo0 : sem_cast v3' tyres (typeof l) m = None)","proofString":"econstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (Heqo0 : sem_cast v3' tyres (typeof l) m = None) : match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v0 =>\n    match sem_cast v0 tyres (typeof l) m with\n    | Some v5 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v5 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v0 =>\n    match sem_cast v0 tyres (typeof l) m with\n    | Some v5 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v5 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (Heqo0 : sem_cast v3' tyres (typeof l) m = None)","proofString":"rewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = None) : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = None)","proofString":"econstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = None) : match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v0 =>\n    match sem_cast v0 tyres (typeof l) m with\n    | Some v5 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v5 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v0 =>\n    match sem_cast v0 tyres (typeof l) m with\n    | Some v5 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v5 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m m' : mem) (v' : val) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v' (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m = Some v3) (H7 : sem_cast v3 tyres (typeof l) m = Some v4) (H8 : assign_loc ge (typeof l) m b ofs bf v4 t2 m' v') (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = None)","proofString":"rewrite Heqo; auto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: t1) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) : t1 = nil /\\\n(exists v' : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v') ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"t1 = nil /\\\n(exists v' : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v') ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: t1) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend)","proofString":"intros [EQ [v1' A]].\nsubst t1.\ndestruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: t1) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (EQ : t1 = nil) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: t1) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (EQ : t1 = nil) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1')","proofString":"subst t1.\ndestruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1')","proofString":"destruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.\ndestruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3')","proofString":"destruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4')","proofString":"destruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')","proofString":"destruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (t2' : trace) (m'' : mem) (v'' : val) (P : assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (t2' : trace) (m'' : mem) (v'' : val) (P : assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')","proofString":"econstructor; econstructor.\nleft; eapply step_assignop with (v1 := v1'); eauto.\nsimpl; reflexivity."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''))","proofString":"econstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) : match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''))","proofString":"rewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) : forall (t2 : trace) (m' : mem) (v' : val),\n~ assign_loc ge (typeof l) m b ofs bf v4' t2 m' v'.","conclusion":"forall (t2 : trace) (m' : mem) (v' : val),\n~ assign_loc ge (typeof l) m b ofs bf v4' t2 m' v'","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''))","proofString":"intros; red; intros; elim H1.\nexists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) (t2 : trace) (m' : mem) (v' : val) (H7 : assign_loc ge (typeof l) m b ofs bf v4' t2 m' v') : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''.","conclusion":"exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v''","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (v4' : val) (Heqo0 : sem_cast v3' tyres (typeof l) m = Some v4') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v4' t2' m'' v'')) (t2 : trace) (m' : mem) (v' : val) (H7 : assign_loc ge (typeof l) m b ofs bf v4' t2 m' v')","proofString":"exists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (Heqo0 : sem_cast v3' tyres (typeof l) m = None) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (Heqo0 : sem_cast v3' tyres (typeof l) m = None)","proofString":"econstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (Heqo0 : sem_cast v3' tyres (typeof l) m = None) : match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v3' : val) (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = Some v3') (Heqo0 : sem_cast v3' tyres (typeof l) m = None)","proofString":"rewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = None) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = None)","proofString":"econstructor; econstructor.\nleft; eapply step_assignop_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = None) : match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Eassignop op l r tyres (typeof l))) k e m)\n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (H5 : eval_simple_rvalue ge e m r v2) (H6 : match sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m with\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m = None)","proofString":"rewrite Heqo; auto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: t1) (ExprState f (C (Eval v1 (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 (ev1 :: t1) m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf nil v1) : ev1 :: t1 = ev2 :: nil ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"ev1 :: t1 = ev2 :: nil ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: t1) (ExprState f (C (Eval v1 (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 (ev1 :: t1) m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf nil v1)","proofString":"intros EQ; rewrite EQ in H.\neconstructor; econstructor; eauto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev2 :: nil) (ExprState f (C (Eval v1 (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 (ev1 :: t1) m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf nil v1) (EQ : ev1 :: t1 = ev2 :: nil) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev2 :: nil) (ExprState f (C (Eval v1 (typeof l))) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 (ev1 :: t1) m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf nil v1) (EQ : ev1 :: t1 = ev2 :: nil)","proofString":"econstructor; econstructor; eauto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t0 : list event) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev0 :: t0 ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: t0) v1) : t0 = nil /\\\n(exists v'0 : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v'0) ->\nexists (s2 : state) (t1 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t1) s2.","conclusion":"t0 = nil /\\\n(exists v'0 : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v'0) ->\nexists (s2 : state) (t1 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t1) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t0 : list event) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev0 :: t0 ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: t0) v1)","proofString":"intros [EQ [v1' A]].\nsubst t0.\ndestruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t0 : list event) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev0 :: t0 ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: t0) v1) (EQ : t0 = nil) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') : exists (s2 : state) (t1 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t1) s2.","conclusion":"exists (s2 : state) (t1 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t1) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t0 : list event) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev0 :: t0 ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: t0) v1) (EQ : t0 = nil) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1')","proofString":"subst t0.\ndestruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1')","proofString":"destruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2')","proofString":"destruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3')","proofString":"destruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')","proofString":"destruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (t2' : trace) (m'' : mem) (v'' : val) (P : assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'') : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (t2' : trace) (m'' : mem) (v'' : val) (P : assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')","proofString":"econstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''))","proofString":"econstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) : match sem_incrdecr ge id v1' (typeof l) m with\n| Some v0 =>\n    match sem_cast v0 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v4 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_incrdecr ge id v1' (typeof l) m with\n| Some v0 =>\n    match sem_cast v0 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v4 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''))","proofString":"rewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) : forall (t0 : trace) (m'0 : mem) (v'0 : val),\n~ assign_loc ge (typeof l) m b ofs bf v3' t0 m'0 v'0.","conclusion":"forall (t0 : trace) (m'0 : mem) (v'0 : val),\n~ assign_loc ge (typeof l) m b ofs bf v3' t0 m'0 v'0","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''))","proofString":"intros; red; intros; elim H1.\nexists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) (t0 : trace) (m'0 : mem) (v'0 : val) (H8 : assign_loc ge (typeof l) m b ofs bf v3' t0 m'0 v'0) : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''.","conclusion":"exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) (t0 : trace) (m'0 : mem) (v'0 : val) (H8 : assign_loc ge (typeof l) m b ofs bf v3' t0 m'0 v'0)","proofString":"exists t0, m'0, v'0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = None) : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = None)","proofString":"econstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = None) : match sem_incrdecr ge id v1' (typeof l) m with\n| Some v0 =>\n    match sem_cast v0 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v4 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_incrdecr ge id v1' (typeof l) m with\n| Some v0 =>\n    match sem_cast v0 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v4 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = None)","proofString":"rewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_incrdecr ge id v1' (typeof l) m = None) : exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2.","conclusion":"exists (s2 : state) (t0 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t0) s2","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_incrdecr ge id v1' (typeof l) m = None)","proofString":"econstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_incrdecr ge id v1' (typeof l) m = None) : match sem_incrdecr ge id v1' (typeof l) m with\n| Some v0 =>\n    match sem_cast v0 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v4 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_incrdecr ge id v1' (typeof l) m with\n| Some v0 =>\n    match sem_cast v0 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v4 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v4 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (v1 : val) (m' : mem) (ev0 : event) (H0 : match_traces (Genv.globalenv p) (ev0 :: nil) (ev2 :: nil)) (t2 : trace) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m)\n  (ev0 :: nil ** t2) (ExprState f (C (Eval v1 (typeof l))) k e m')) (b : block) (ofs : ptrofs) (bf : bitfield) (v2 v3 v' : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H7 : assign_loc ge (typeof l) m b ofs bf v3 t2 m' v') (H6 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H5 : sem_incrdecr ge id v1 (typeof l) m = Some v2) (H4 : deref_loc ge (typeof l) m b ofs bf (ev0 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_incrdecr ge id v1' (typeof l) m = None)","proofString":"rewrite Heqo; auto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: t1) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v1) : t1 = nil /\\\n(exists v' : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v') ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"t1 = nil /\\\n(exists v' : val, deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v') ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: t1) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v1)","proofString":"intros [EQ [v1' A]].\nsubst t1.\ndestruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: t1) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v1) (EQ : t1 = nil) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: t1) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: t1) v1) (EQ : t1 = nil) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1')","proofString":"subst t1.\ndestruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1')","proofString":"destruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.\ndestruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2')","proofString":"destruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.\ndestruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3')","proofString":"destruct (classic (exists t2' m'' v'', assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')).\ndestruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity.\neconstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')","proofString":"destruct H1 as [t2' [m'' [v'' P]]].\neconstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (t2' : trace) (m'' : mem) (v'' : val) (P : assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'') : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (t2' : trace) (m'' : mem) (v'' : val) (P : assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')","proofString":"econstructor; econstructor.\nleft; eapply step_postincr with (v1 := v1'); eauto.\nsimpl; reflexivity."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''))","proofString":"econstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) : match sem_incrdecr ge id v1' (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_incrdecr ge id v1' (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''))","proofString":"rewrite Heqo; rewrite Heqo0.\nintros; red; intros; elim H1.\nexists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) : forall (t2 : trace) (m' : mem) (v' : val),\n~ assign_loc ge (typeof l) m b ofs bf v3' t2 m' v'.","conclusion":"forall (t2 : trace) (m' : mem) (v' : val),\n~ assign_loc ge (typeof l) m b ofs bf v3' t2 m' v'","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''))","proofString":"intros; red; intros; elim H1.\nexists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) (t2 : trace) (m' : mem) (v' : val) (H6 : assign_loc ge (typeof l) m b ofs bf v3' t2 m' v') : exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''.","conclusion":"exists (t2' : trace) (m'' : mem) (v'' : val),\n  assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v''","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t0 : trace) (m'0 : mem) (v'0 : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t0 m'0 v'0\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (v3' : val) (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = Some v3') (H1 : ~\n(exists (t2' : trace) (m'' : mem) (v'' : val),\n   assign_loc ge (typeof l) m b ofs bf v3' t2' m'' v'')) (t2 : trace) (m' : mem) (v' : val) (H6 : assign_loc ge (typeof l) m b ofs bf v3' t2 m' v')","proofString":"exists t2, m', v'; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = None) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = None)","proofString":"econstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = None) : match sem_incrdecr ge id v1' (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_incrdecr ge id v1' (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (v2' : val) (Heqo : sem_incrdecr ge id v1' (typeof l) m = Some v2') (Heqo0 : sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m = None)","proofString":"rewrite Heqo; rewrite Heqo0; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_incrdecr ge id v1' (typeof l) m = None) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_incrdecr ge id v1' (typeof l) m = None)","proofString":"econstructor; econstructor.\nleft; eapply step_postincr_stuck with (v1 := v1'); eauto.\nrewrite Heqo; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_incrdecr ge id v1' (typeof l) m = None) : match sem_incrdecr ge id v1' (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend.","conclusion":"match sem_incrdecr ge id v1' (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (H : step ge (ExprState f (C (Epostincr id l (typeof l))) k e m) \n  (ev1 :: nil) Stuckstate) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H2 : leftcontext RV RV C) (H3 : eval_simple_lvalue ge e m l b ofs bf) (H5 : match sem_incrdecr ge id v1 (typeof l) m with\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ assign_loc ge (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H4 : deref_loc ge (typeof l) m b ofs bf (ev1 :: nil) v1) (v1' : val) (A : deref_loc ge (typeof l) m b ofs bf (ev2 :: nil) v1') (Heqo : sem_incrdecr ge id v1' (typeof l) m = None)","proofString":"rewrite Heqo; auto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vres : val) (m' : mem) (H : step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n  (ev1 :: nil) (ExprState f (C (Eval vres ty)) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (vargs : list val) (H2 : leftcontext RV RV C) (H3 : eval_simple_list ge e m rargs tyargs vargs) (H4 : external_call ef ge vargs m (ev1 :: nil) vres m') (H1 : (1 <= 1)%nat) : (exists (vres2 : val) (m2 : mem),\n   external_call ef ge vargs m (ev2 :: nil) vres2 m2) ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n    (ev2 :: t2) s2.","conclusion":"(exists (vres2 : val) (m2 : mem),\n   external_call ef ge vargs m (ev2 :: nil) vres2 m2) ->\nexists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vres : val) (m' : mem) (H : step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n  (ev1 :: nil) (ExprState f (C (Eval vres ty)) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (vargs : list val) (H2 : leftcontext RV RV C) (H3 : eval_simple_list ge e m rargs tyargs vargs) (H4 : external_call ef ge vargs m (ev1 :: nil) vres m') (H1 : (1 <= 1)%nat)","proofString":"intros [vres2 [m2 EC2]].\neconstructor; econstructor.\nleft; eapply step_builtin; eauto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vres : val) (m' : mem) (H : step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n  (ev1 :: nil) (ExprState f (C (Eval vres ty)) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (vargs : list val) (H2 : leftcontext RV RV C) (H3 : eval_simple_list ge e m rargs tyargs vargs) (H4 : external_call ef ge vargs m (ev1 :: nil) vres m') (H1 : (1 <= 1)%nat) (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m (ev2 :: nil) vres2 m2) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vres : val) (m' : mem) (H : step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n  (ev1 :: nil) (ExprState f (C (Eval vres ty)) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (vargs : list val) (H2 : leftcontext RV RV C) (H3 : eval_simple_list ge e m rargs tyargs vargs) (H4 : external_call ef ge vargs m (ev1 :: nil) vres m') (H1 : (1 <= 1)%nat) (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m (ev2 :: nil) vres2 m2)","proofString":"econstructor; econstructor.\nleft; eapply step_builtin; eauto."},{"statement":"(p : program) (ev1 e0 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vres : val) (m' : mem) (H : step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)\n  (ev1 :: e0 :: t1) (ExprState f (C (Eval vres ty)) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (vargs : list val) (H2 : leftcontext RV RV C) (H3 : eval_simple_list ge e m rargs tyargs vargs) (H4 : external_call ef ge vargs m (ev1 :: e0 :: t1) vres m') (H1 : (S (S (Datatypes.length t1)) <= 1)%nat) : exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n    (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m) \n    (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 e0 : event) (t1 : list event) (ev2 : event) (ge : genv) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vres : val) (m' : mem) (H : step ge (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m)\n  (ev1 :: e0 :: t1) (ExprState f (C (Eval vres ty)) k e m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (vargs : list val) (H2 : leftcontext RV RV C) (H3 : eval_simple_list ge e m rargs tyargs vargs) (H4 : external_call ef ge vargs m (ev1 :: e0 :: t1) vres m') (H1 : (S (S (Datatypes.length t1)) <= 1)%nat)","proofString":"extlia."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step ge (Callstate (External ef targs tres cc) vargs k m) \n  (ev1 :: nil) (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (H2 : external_call ef ge vargs m (ev1 :: nil) vres m') (H1 : (1 <= 1)%nat) : (exists (vres2 : val) (m2 : mem),\n   external_call ef ge vargs m (ev2 :: nil) vres2 m2) ->\nexists (s2 : state) (t2 : list event),\n  step ge (Callstate (External ef targs tres cc) vargs k m) (ev2 :: t2) s2.","conclusion":"(exists (vres2 : val) (m2 : mem),\n   external_call ef ge vargs m (ev2 :: nil) vres2 m2) ->\nexists (s2 : state) (t2 : list event),\n  step ge (Callstate (External ef targs tres cc) vargs k m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step ge (Callstate (External ef targs tres cc) vargs k m) \n  (ev1 :: nil) (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (H2 : external_call ef ge vargs m (ev1 :: nil) vres m') (H1 : (1 <= 1)%nat)","proofString":"intros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2); exists E0; right; econstructor; eauto."},{"statement":"(p : program) (ev1 ev2 : event) (ge : genv) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step ge (Callstate (External ef targs tres cc) vargs k m) \n  (ev1 :: nil) (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (H2 : external_call ef ge vargs m (ev1 :: nil) vres m') (H1 : (1 <= 1)%nat) (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m (ev2 :: nil) vres2 m2) : exists (s2 : state) (t2 : list event),\n  step ge (Callstate (External ef targs tres cc) vargs k m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (Callstate (External ef targs tres cc) vargs k m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 ev2 : event) (ge : genv) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step ge (Callstate (External ef targs tres cc) vargs k m) \n  (ev1 :: nil) (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (H2 : external_call ef ge vargs m (ev1 :: nil) vres m') (H1 : (1 <= 1)%nat) (vres2 : val) (m2 : mem) (EC2 : external_call ef ge vargs m (ev2 :: nil) vres2 m2)","proofString":"exists (Returnstate vres2 k m2); exists E0; right; econstructor; eauto."},{"statement":"(p : program) (ev1 e : event) (t1 : list event) (ev2 : event) (ge : genv) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step ge (Callstate (External ef targs tres cc) vargs k m) \n  (ev1 :: e :: t1) (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (H2 : external_call ef ge vargs m (ev1 :: e :: t1) vres m') (H1 : (S (S (Datatypes.length t1)) <= 1)%nat) : exists (s2 : state) (t2 : list event),\n  step ge (Callstate (External ef targs tres cc) vargs k m) (ev2 :: t2) s2.","conclusion":"exists (s2 : state) (t2 : list event),\n  step ge (Callstate (External ef targs tres cc) vargs k m) (ev2 :: t2) s2","hypotheses":"(p : program) (ev1 e : event) (t1 : list event) (ev2 : event) (ge : genv) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step ge (Callstate (External ef targs tres cc) vargs k m) \n  (ev1 :: e :: t1) (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) (ev1 :: nil) (ev2 :: nil)) (H2 : external_call ef ge vargs m (ev1 :: e :: t1) vres m') (H1 : (S (S (Datatypes.length t1)) <= 1)%nat)","proofString":"extlia."},{"statement":"(p : program) : well_behaved_traces (semantics p).","conclusion":"well_behaved_traces (semantics p)","hypotheses":"(p : program)","proofString":"red; intros.\ninv H; inv H0; simpl; auto.\nexploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto.\nexploit assign_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; simpl; tauto.\nexploit deref_loc_trace; eauto.\nexploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto.\nexploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto.\nexploit deref_loc_trace; eauto.\nexploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto.\nexploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto.\nexploit external_call_trace_length; eauto.\ndestruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia.\nexploit external_call_trace_length; eauto.\ndestruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia."},{"statement":"(p : program) (s : Smallstep.state (semantics p)) (t : trace) (s' : Smallstep.state (semantics p)) (H : Step (semantics p) s t s') : match t with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (s : Smallstep.state (semantics p)) (t : trace) (s' : Smallstep.state (semantics p)) (H : Step (semantics p) s t s')","proofString":"inv H; inv H0; simpl; auto.\nexploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto.\nexploit assign_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; simpl; tauto.\nexploit deref_loc_trace; eauto.\nexploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto.\nexploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto.\nexploit deref_loc_trace; eauto.\nexploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto.\nexploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto.\nexploit external_call_trace_length; eauto.\ndestruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia.\nexploit external_call_trace_length; eauto.\ndestruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v) (H4 : type_is_volatile (typeof l) = true) : match t with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v) (H4 : type_is_volatile (typeof l) = true)","proofString":"exploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v) (H4 : type_is_volatile (typeof l) = true) : match t with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end.","conclusion":"match t with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v) (H4 : type_is_volatile (typeof l) = true)","proofString":"destruct t; auto.\ndestruct t; tauto."},{"statement":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf \n  (e0 :: t) v) (H4 : type_is_volatile (typeof l) = true) : match t with\n| nil => True\n| _ :: _ => False\nend -> output_trace t.","conclusion":"match t with\n| nil => True\n| _ :: _ => False\nend -> output_trace t","hypotheses":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf \n  (e0 :: t) v) (H4 : type_is_volatile (typeof l) = true)","proofString":"destruct t; tauto."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v) (H3 : sem_cast v (typeof r) (typeof l) m = Some v1) (H4 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v1 t m'\n  v') : match t with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v) (H3 : sem_cast v (typeof r) (typeof l) m = Some v1) (H4 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v1 t m'\n  v')","proofString":"exploit assign_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; simpl; tauto."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v) (H3 : sem_cast v (typeof r) (typeof l) m = Some v1) (H4 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v1 t m'\n  v') : match t with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend -> match t with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end.","conclusion":"match t with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend -> match t with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v) (H3 : sem_cast v (typeof r) (typeof l) m = Some v1) (H4 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v1 t m'\n  v')","proofString":"destruct t; auto.\ndestruct t; simpl; tauto."},{"statement":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v) (H3 : sem_cast v (typeof r) (typeof l) m = Some v1) (H4 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v1\n  (e0 :: t) m' v') : match t with\n| nil => output_event e0\n| _ :: _ => False\nend -> output_trace t.","conclusion":"match t with\n| nil => output_event e0\n| _ :: _ => False\nend -> output_trace t","hypotheses":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (l r : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v) (H3 : sem_cast v (typeof r) (typeof l) m = Some v1) (H4 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v1\n  (e0 :: t) m' v')","proofString":"destruct t; simpl; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v') : match t1 ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t1 ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v')","proofString":"exploit deref_loc_trace; eauto.\nexploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v') : match t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t1 ** t2 with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end.","conclusion":"match t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t1 ** t2 with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v')","proofString":"exploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v') : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nmatch t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t1 ** t2 with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nmatch t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t1 ** t2 with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v')","proofString":"destruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v') : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nTrue -> match nil ** t2 with\n        | nil => True\n        | _ :: t' => output_trace t'\n        end.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nTrue -> match nil ** t2 with\n        | nil => True\n        | _ :: t' => output_trace t'\n        end","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v')","proofString":"destruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 nil\n  m' v') : True ->\nTrue -> match nil ** nil with\n        | nil => True\n        | _ :: t' => output_trace t'\n        end.","conclusion":"True ->\nTrue -> match nil ** nil with\n        | nil => True\n        | _ :: t' => output_trace t'\n        end","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 nil\n  m' v')","proofString":"simpl; auto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 : event) (t2 : list event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4\n  (e0 :: t2) m' v') : match t2 with\n| nil => output_event e0\n| _ :: _ => False\nend ->\nTrue ->\nmatch nil ** e0 :: t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => output_event e0\n| _ :: _ => False\nend ->\nTrue ->\nmatch nil ** e0 :: t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 : event) (t2 : list event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4\n  (e0 :: t2) m' v')","proofString":"destruct t2; simpl; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 : event) (t1 : list event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: t1) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v') : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nmatch t1 with\n| nil => True\n| _ :: _ => False\nend ->\nmatch (e0 :: t1) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nmatch t1 with\n| nil => True\n| _ :: _ => False\nend ->\nmatch (e0 :: t1) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 : event) (t1 : list event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: t1) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v')","proofString":"destruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 : event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v') : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nTrue ->\nmatch (e0 :: nil) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nTrue ->\nmatch (e0 :: nil) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 : event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v')","proofString":"destruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 : event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 nil\n  m' v') : True ->\nTrue ->\nmatch (e0 :: nil) ** nil with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"True ->\nTrue ->\nmatch (e0 :: nil) ** nil with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 : event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 nil\n  m' v')","proofString":"simpl; auto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 e1 : event) (t2 : list event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4\n  (e1 :: t2) m' v') : match t2 with\n| nil => output_event e1\n| _ :: _ => False\nend ->\nTrue ->\nmatch (e0 :: nil) ** e1 :: t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => output_event e1\n| _ :: _ => False\nend ->\nTrue ->\nmatch (e0 :: nil) ** e1 :: t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 e1 : event) (t2 : list event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4\n  (e1 :: t2) m' v')","proofString":"destruct t2; simpl; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 e1 : event) (t1 : list event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: e1 :: t1) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v') : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nFalse ->\nmatch (e0 :: e1 :: t1) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nFalse ->\nmatch (e0 :: e1 :: t1) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 v4 : val) (e0 e1 : event) (t1 : list event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: e1 :: t1) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n  (typeof l) v2 (typeof r) m = Some v3) (H5 : sem_cast v3 tyres (typeof l) m = Some v4) (H6 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v4 t2 m'\n  v')","proofString":"tauto."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : match\n  sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n    (typeof l) v2 (typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) : match t with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : match\n  sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n    (typeof l) v2 (typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend)","proofString":"exploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : match\n  sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n    (typeof l) v2 (typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) : match t with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end.","conclusion":"match t with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : match\n  sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n    (typeof l) v2 (typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend)","proofString":"destruct t; auto.\ndestruct t; tauto."},{"statement":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf \n  (e0 :: t) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : match\n  sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n    (typeof l) v2 (typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) : match t with\n| nil => True\n| _ :: _ => False\nend -> output_trace t.","conclusion":"match t with\n| nil => True\n| _ :: _ => False\nend -> output_trace t","hypotheses":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (op : binary_operation) (l r : expr) (tyres : type) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf \n  (e0 :: t) v1) (H3 : eval_simple_rvalue (Smallstep.globalenv (semantics p)) e m r v2) (H4 : match\n  sem_binary_operation (Smallstep.globalenv (semantics p)) op v1 \n    (typeof l) v2 (typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend)","proofString":"destruct t; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1) : match t1 ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t1 ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1)","proofString":"exploit deref_loc_trace; eauto.\nexploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1) : match t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t1 ** t2 with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end.","conclusion":"match t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t1 ** t2 with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1)","proofString":"exploit assign_loc_trace; eauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1) : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nmatch t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t1 ** t2 with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nmatch t1 with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t1 ** t2 with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t1 v1)","proofString":"destruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ndestruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1) : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nTrue -> match nil ** t2 with\n        | nil => True\n        | _ :: t' => output_trace t'\n        end.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nTrue -> match nil ** t2 with\n        | nil => True\n        | _ :: t' => output_trace t'\n        end","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1)","proofString":"destruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 nil\n  m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1) : True ->\nTrue -> match nil ** nil with\n        | nil => True\n        | _ :: t' => output_trace t'\n        end.","conclusion":"True ->\nTrue -> match nil ** nil with\n        | nil => True\n        | _ :: t' => output_trace t'\n        end","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 nil\n  m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1)","proofString":"simpl; auto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 : event) (t2 : list event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3\n  (e0 :: t2) m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1) : match t2 with\n| nil => output_event e0\n| _ :: _ => False\nend ->\nTrue ->\nmatch nil ** e0 :: t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => output_event e0\n| _ :: _ => False\nend ->\nTrue ->\nmatch nil ** e0 :: t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 : event) (t2 : list event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3\n  (e0 :: t2) m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf nil v1)","proofString":"destruct t2; simpl; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 : event) (t1 : list event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: t1) v1) : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nmatch t1 with\n| nil => True\n| _ :: _ => False\nend ->\nmatch (e0 :: t1) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nmatch t1 with\n| nil => True\n| _ :: _ => False\nend ->\nmatch (e0 :: t1) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 : event) (t1 : list event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: t1) v1)","proofString":"destruct t1.\ndestruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto.\ntauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 : event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1) : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nTrue ->\nmatch (e0 :: nil) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nTrue ->\nmatch (e0 :: nil) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 : event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1)","proofString":"destruct t2.\nsimpl; auto.\ndestruct t2; simpl; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 : event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 nil\n  m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1) : True ->\nTrue ->\nmatch (e0 :: nil) ** nil with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"True ->\nTrue ->\nmatch (e0 :: nil) ** nil with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 : event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 nil\n  m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1)","proofString":"simpl; auto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 e1 : event) (t2 : list event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3\n  (e1 :: t2) m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1) : match t2 with\n| nil => output_event e1\n| _ :: _ => False\nend ->\nTrue ->\nmatch (e0 :: nil) ** e1 :: t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => output_event e1\n| _ :: _ => False\nend ->\nTrue ->\nmatch (e0 :: nil) ** e1 :: t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 e1 : event) (t2 : list event) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3\n  (e1 :: t2) m' v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: nil) v1)","proofString":"destruct t2; simpl; tauto."},{"statement":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 e1 : event) (t1 : list event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: e1 :: t1) v1) : match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nFalse ->\nmatch (e0 :: e1 :: t1) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t2 with\n| nil => True\n| ev :: nil => output_event ev\n| ev :: _ :: _ => False\nend ->\nFalse ->\nmatch (e0 :: e1 :: t1) ** t2 with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (e0 e1 : event) (t1 : list event) (t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H5 : assign_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf v3 t2 m'\n  v') (H4 : sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m = Some v3) (H3 : sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m = Some v2) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf\n  (e0 :: e1 :: t1) v1)","proofString":"tauto."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H3 : match\n  sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m\nwith\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v1) : match t with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H3 : match\n  sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m\nwith\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v1)","proofString":"exploit deref_loc_trace; eauto.\ndestruct t; auto.\ndestruct t; tauto."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H3 : match\n  sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m\nwith\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v1) : match t with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end.","conclusion":"match t with\n| _ :: _ :: _ => False\n| _ => True\nend -> match t with\n       | nil => True\n       | _ :: t' => output_trace t'\n       end","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H3 : match\n  sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m\nwith\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf t v1)","proofString":"destruct t; auto.\ndestruct t; tauto."},{"statement":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H3 : match\n  sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m\nwith\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf \n  (e0 :: t) v1) : match t with\n| nil => True\n| _ :: _ => False\nend -> output_trace t.","conclusion":"match t with\n| nil => True\n| _ :: _ => False\nend -> output_trace t","hypotheses":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (id : incr_or_decr) (l : expr) (k : cont) (e : env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (H : leftcontext RV RV C) (H1 : eval_simple_lvalue (Smallstep.globalenv (semantics p)) e m l b ofs bf) (H3 : match\n  sem_incrdecr (Smallstep.globalenv (semantics p)) id v1 (typeof l) m\nwith\n| Some v2 =>\n    match sem_cast v2 (incrdecr_type (typeof l)) (typeof l) m with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~\n        assign_loc (Smallstep.globalenv (semantics p)) \n          (typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H2 : deref_loc (Smallstep.globalenv (semantics p)) (typeof l) m b ofs bf \n  (e0 :: t) v1)","proofString":"destruct t; tauto."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H1 : eval_simple_list (Smallstep.globalenv (semantics p)) e m rargs tyargs vargs) (H2 : external_call ef (Smallstep.globalenv (semantics p)) vargs m t vres m') : match t with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H1 : eval_simple_list (Smallstep.globalenv (semantics p)) e m rargs tyargs vargs) (H2 : external_call ef (Smallstep.globalenv (semantics p)) vargs m t vres m')","proofString":"exploit external_call_trace_length; eauto.\ndestruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia."},{"statement":"(p : program) (t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H1 : eval_simple_list (Smallstep.globalenv (semantics p)) e m rargs tyargs vargs) (H2 : external_call ef (Smallstep.globalenv (semantics p)) vargs m t vres m') : (Datatypes.length t <= 1)%nat ->\nmatch t with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"(Datatypes.length t <= 1)%nat ->\nmatch t with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (t : trace) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H1 : eval_simple_list (Smallstep.globalenv (semantics p)) e m rargs tyargs vargs) (H2 : external_call ef (Smallstep.globalenv (semantics p)) vargs m t vres m')","proofString":"destruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia."},{"statement":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H1 : eval_simple_list (Smallstep.globalenv (semantics p)) e m rargs tyargs vargs) (H2 : external_call ef (Smallstep.globalenv (semantics p)) vargs m \n  (e0 :: t) vres m') : (S (Datatypes.length t) <= 1)%nat -> output_trace t.","conclusion":"(S (Datatypes.length t) <= 1)%nat -> output_trace t","hypotheses":"(p : program) (e0 : event) (t : list event) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H1 : eval_simple_list (Smallstep.globalenv (semantics p)) e m rargs tyargs vargs) (H2 : external_call ef (Smallstep.globalenv (semantics p)) vargs m \n  (e0 :: t) vres m')","proofString":"destruct t; simpl; auto.\nintros; extlia."},{"statement":"(p : program) (e0 e1 : event) (t : list event) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H1 : eval_simple_list (Smallstep.globalenv (semantics p)) e m rargs tyargs vargs) (H2 : external_call ef (Smallstep.globalenv (semantics p)) vargs m \n  (e0 :: e1 :: t) vres m') : (S (S (Datatypes.length t)) <= 1)%nat -> output_event e1 /\\ output_trace t.","conclusion":"(S (S (Datatypes.length t)) <= 1)%nat -> output_event e1 /\\ output_trace t","hypotheses":"(p : program) (e0 e1 : event) (t : list event) (f : function) (C : expr -> expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : cont) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H1 : eval_simple_list (Smallstep.globalenv (semantics p)) e m rargs tyargs vargs) (H2 : external_call ef (Smallstep.globalenv (semantics p)) vargs m \n  (e0 :: e1 :: t) vres m')","proofString":"intros; extlia."},{"statement":"(p : program) (t : trace) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : external_call ef (Smallstep.globalenv (semantics p)) vargs m t vres m') : match t with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"match t with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (t : trace) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : external_call ef (Smallstep.globalenv (semantics p)) vargs m t vres m')","proofString":"exploit external_call_trace_length; eauto.\ndestruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia."},{"statement":"(p : program) (t : trace) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : external_call ef (Smallstep.globalenv (semantics p)) vargs m t vres m') : (Datatypes.length t <= 1)%nat ->\nmatch t with\n| nil => True\n| _ :: t' => output_trace t'\nend.","conclusion":"(Datatypes.length t <= 1)%nat ->\nmatch t with\n| nil => True\n| _ :: t' => output_trace t'\nend","hypotheses":"(p : program) (t : trace) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : external_call ef (Smallstep.globalenv (semantics p)) vargs m t vres m')","proofString":"destruct t; simpl; auto.\ndestruct t; simpl; auto.\nintros; extlia."},{"statement":"(p : program) (e : event) (t : list event) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : external_call ef (Smallstep.globalenv (semantics p)) vargs m (e :: t) vres m') : (S (Datatypes.length t) <= 1)%nat -> output_trace t.","conclusion":"(S (Datatypes.length t) <= 1)%nat -> output_trace t","hypotheses":"(p : program) (e : event) (t : list event) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : external_call ef (Smallstep.globalenv (semantics p)) vargs m (e :: t) vres m')","proofString":"destruct t; simpl; auto.\nintros; extlia."},{"statement":"(p : program) (e e0 : event) (t : list event) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : external_call ef (Smallstep.globalenv (semantics p)) vargs m \n  (e :: e0 :: t) vres m') : (S (S (Datatypes.length t)) <= 1)%nat -> output_event e0 /\\ output_trace t.","conclusion":"(S (S (Datatypes.length t)) <= 1)%nat -> output_event e0 /\\ output_trace t","hypotheses":"(p : program) (e e0 : event) (t : list event) (ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : external_call ef (Smallstep.globalenv (semantics p)) vargs m \n  (e :: e0 :: t) vres m')","proofString":"intros; extlia."},{"statement":"(p : program) : backward_simulation (Csem.semantics p) (semantics p).","conclusion":"backward_simulation (Csem.semantics p) (semantics p)","hypotheses":"(p : program)","proofString":"apply backward_simulation_plus with (match_states := fun (S1 S2: state) => S1 = S2); simpl.\nauto.\nintros.\nexists s1; auto.\nintros.\nexists s2; auto.\nintros.\nsubst s2.\nauto.\nintros.\nsubst s2.\napply progress.\nauto.\nintros.\nsubst s1.\nexists s2'; split; auto.\napply step_simulation; auto."},{"statement":"(p : program) : forall id : ident,\nGenv.public_symbol (Genv.globalenv p) id =\nGenv.public_symbol (Genv.globalenv p) id.","conclusion":"forall id : ident,\nGenv.public_symbol (Genv.globalenv p) id =\nGenv.public_symbol (Genv.globalenv p) id","hypotheses":"(p : program)","proofString":"auto."},{"statement":"(p : program) : forall s1 : state,\ninitial_state p s1 -> exists s2 : state, initial_state p s2.","conclusion":"forall s1 : state,\ninitial_state p s1 -> exists s2 : state, initial_state p s2","hypotheses":"(p : program)","proofString":"intros.\nexists s1; auto."},{"statement":"(p : program) (s1 : state) (H : initial_state p s1) : exists s2 : state, initial_state p s2.","conclusion":"exists s2 : state, initial_state p s2","hypotheses":"(p : program) (s1 : state) (H : initial_state p s1)","proofString":"exists s1; auto."},{"statement":"(p : program) : forall s1 s2 : state,\ninitial_state p s1 ->\ninitial_state p s2 -> exists s1' : state, initial_state p s1' /\\ s1' = s2.","conclusion":"forall s1 s2 : state,\ninitial_state p s1 ->\ninitial_state p s2 -> exists s1' : state, initial_state p s1' /\\ s1' = s2","hypotheses":"(p : program)","proofString":"intros.\nexists s2; auto."},{"statement":"(p : program) (s1 s2 : state) (H : initial_state p s1) (H0 : initial_state p s2) : exists s1' : state, initial_state p s1' /\\ s1' = s2.","conclusion":"exists s1' : state, initial_state p s1' /\\ s1' = s2","hypotheses":"(p : program) (s1 s2 : state) (H : initial_state p s1) (H0 : initial_state p s2)","proofString":"exists s2; auto."},{"statement":"(p : program) : forall (s1 s2 : state) (r : int),\ns1 = s2 -> final_state s2 r -> final_state s1 r.","conclusion":"forall (s1 s2 : state) (r : int),\ns1 = s2 -> final_state s2 r -> final_state s1 r","hypotheses":"(p : program)","proofString":"intros.\nsubst s2.\nauto."},{"statement":"(p : program) (s1 s2 : state) (r : int) (H : s1 = s2) (H0 : final_state s2 r) : final_state s1 r.","conclusion":"final_state s1 r","hypotheses":"(p : program) (s1 s2 : state) (r : int) (H : s1 = s2) (H0 : final_state s2 r)","proofString":"subst s2.\nauto."},{"statement":"(p : program) (s1 : state) (r : int) (H0 : final_state s1 r) : final_state s1 r.","conclusion":"final_state s1 r","hypotheses":"(p : program) (s1 : state) (r : int) (H0 : final_state s1 r)","proofString":"auto."},{"statement":"(p : program) : forall s1 s2 : state,\ns1 = s2 ->\nSmallstep.safe (Csem.semantics p) s1 ->\n(exists r : int, final_state s2 r) \\/\n(exists (t : trace) (s2' : state), step (globalenv p) s2 t s2').","conclusion":"forall s1 s2 : state,\ns1 = s2 ->\nSmallstep.safe (Csem.semantics p) s1 ->\n(exists r : int, final_state s2 r) \\/\n(exists (t : trace) (s2' : state), step (globalenv p) s2 t s2')","hypotheses":"(p : program)","proofString":"intros.\nsubst s2.\napply progress.\nauto."},{"statement":"(p : program) (s1 s2 : state) (H : s1 = s2) (H0 : Smallstep.safe (Csem.semantics p) s1) : (exists r : int, final_state s2 r) \\/\n(exists (t : trace) (s2' : state), step (globalenv p) s2 t s2').","conclusion":"(exists r : int, final_state s2 r) \\/\n(exists (t : trace) (s2' : state), step (globalenv p) s2 t s2')","hypotheses":"(p : program) (s1 s2 : state) (H : s1 = s2) (H0 : Smallstep.safe (Csem.semantics p) s1)","proofString":"subst s2.\napply progress.\nauto."},{"statement":"(p : program) (s1 : state) (H0 : Smallstep.safe (Csem.semantics p) s1) : (exists r : int, final_state s1 r) \\/\n(exists (t : trace) (s2' : state), step (globalenv p) s1 t s2').","conclusion":"(exists r : int, final_state s1 r) \\/\n(exists (t : trace) (s2' : state), step (globalenv p) s1 t s2')","hypotheses":"(p : program) (s1 : state) (H0 : Smallstep.safe (Csem.semantics p) s1)","proofString":"apply progress.\nauto."},{"statement":"(p : program) (s1 : state) (H0 : Smallstep.safe (Csem.semantics p) s1) : safe (globalenv p) s1.","conclusion":"safe (globalenv p) s1","hypotheses":"(p : program) (s1 : state) (H0 : Smallstep.safe (Csem.semantics p) s1)","proofString":"auto."},{"statement":"(p : program) : forall (s2 : state) (t : trace) (s2' : state),\nstep (globalenv p) s2 t s2' ->\nforall s1 : state,\ns1 = s2 ->\nSmallstep.safe (Csem.semantics p) s1 ->\nexists s1' : state, plus Csem.step (globalenv p) s1 t s1' /\\ s1' = s2'.","conclusion":"forall (s2 : state) (t : trace) (s2' : state),\nstep (globalenv p) s2 t s2' ->\nforall s1 : state,\ns1 = s2 ->\nSmallstep.safe (Csem.semantics p) s1 ->\nexists s1' : state, plus Csem.step (globalenv p) s1 t s1' /\\ s1' = s2'","hypotheses":"(p : program)","proofString":"intros.\nsubst s1.\nexists s2'; split; auto.\napply step_simulation; auto."},{"statement":"(p : program) (s2 : state) (t : trace) (s2' : state) (H : step (globalenv p) s2 t s2') (s1 : state) (H0 : s1 = s2) (H1 : Smallstep.safe (Csem.semantics p) s1) : exists s1' : state, plus Csem.step (globalenv p) s1 t s1' /\\ s1' = s2'.","conclusion":"exists s1' : state, plus Csem.step (globalenv p) s1 t s1' /\\ s1' = s2'","hypotheses":"(p : program) (s2 : state) (t : trace) (s2' : state) (H : step (globalenv p) s2 t s2') (s1 : state) (H0 : s1 = s2) (H1 : Smallstep.safe (Csem.semantics p) s1)","proofString":"subst s1.\nexists s2'; split; auto.\napply step_simulation; auto."},{"statement":"(p : program) (s2 : state) (t : trace) (s2' : state) (H : step (globalenv p) s2 t s2') (H1 : Smallstep.safe (Csem.semantics p) s2) : exists s1' : state, plus Csem.step (globalenv p) s2 t s1' /\\ s1' = s2'.","conclusion":"exists s1' : state, plus Csem.step (globalenv p) s2 t s1' /\\ s1' = s2'","hypotheses":"(p : program) (s2 : state) (t : trace) (s2' : state) (H : step (globalenv p) s2 t s2') (H1 : Smallstep.safe (Csem.semantics p) s2)","proofString":"exists s2'; split; auto.\napply step_simulation; auto."},{"statement":"(p : program) (s2 : state) (t : trace) (s2' : state) (H : step (globalenv p) s2 t s2') (H1 : Smallstep.safe (Csem.semantics p) s2) : plus Csem.step (globalenv p) s2 t s2'.","conclusion":"plus Csem.step (globalenv p) s2 t s2'","hypotheses":"(p : program) (s2 : state) (t : trace) (s2' : state) (H : step (globalenv p) s2 t s2') (H1 : Smallstep.safe (Csem.semantics p) s2)","proofString":"apply step_simulation; auto."},{"statement":"(rl2 : exprlist) (H : true = true) : leftcontextlist RV (fun x : expr => Econs x rl2).","conclusion":"leftcontextlist RV (fun x : expr => Econs x rl2)","hypotheses":"(rl2 : exprlist) (H : true = true)","proofString":"apply lctx_list_head.\nconstructor."},{"statement":"(rl2 : exprlist) (H : true = true) : leftcontext RV RV (fun x : expr => x).","conclusion":"leftcontext RV RV (fun x : expr => x)","hypotheses":"(rl2 : exprlist) (H : true = true)","proofString":"constructor."},{"statement":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist rl1 = true ->\nleftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) (H : simple r1 && simplelist rl1 = true) : leftcontextlist RV\n  (fun x : expr => Econs r1 (exprlist_app rl1 (Econs x rl2))).","conclusion":"leftcontextlist RV\n  (fun x : expr => Econs r1 (exprlist_app rl1 (Econs x rl2)))","hypotheses":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist rl1 = true ->\nleftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) (H : simple r1 && simplelist rl1 = true)","proofString":"destruct (andb_prop _ _ H).\napply lctx_list_tail.\nauto.\nauto."},{"statement":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist rl1 = true ->\nleftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) (H : simple r1 && simplelist rl1 = true) (H0 : simple r1 = true) (H1 : simplelist rl1 = true) : leftcontextlist RV\n  (fun x : expr => Econs r1 (exprlist_app rl1 (Econs x rl2))).","conclusion":"leftcontextlist RV\n  (fun x : expr => Econs r1 (exprlist_app rl1 (Econs x rl2)))","hypotheses":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist rl1 = true ->\nleftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) (H : simple r1 && simplelist rl1 = true) (H0 : simple r1 = true) (H1 : simplelist rl1 = true)","proofString":"apply lctx_list_tail.\nauto.\nauto."},{"statement":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist rl1 = true ->\nleftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) (H : simple r1 && simplelist rl1 = true) (H0 : simple r1 = true) (H1 : simplelist rl1 = true) : simple r1 = true.","conclusion":"simple r1 = true","hypotheses":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist rl1 = true ->\nleftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) (H : simple r1 && simplelist rl1 = true) (H0 : simple r1 = true) (H1 : simplelist rl1 = true)","proofString":"auto."},{"statement":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist rl1 = true ->\nleftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) (H : simple r1 && simplelist rl1 = true) (H0 : simple r1 = true) (H1 : simplelist rl1 = true) : leftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl2)).","conclusion":"leftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl2))","hypotheses":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist rl1 = true ->\nleftcontextlist RV (fun x : expr => exprlist_app rl1 (Econs x rl0))) (rl2 : exprlist) (H : simple r1 && simplelist rl1 = true) (H0 : simple r1 = true) (H1 : simplelist rl1 = true)","proofString":"auto."},{"statement":"(rl2 : exprlist) : simplelist rl2 = simplelist rl2.","conclusion":"simplelist rl2 = simplelist rl2","hypotheses":"(rl2 : exprlist)","proofString":"auto."},{"statement":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist (exprlist_app rl1 rl0) = simplelist rl1 && simplelist rl0) (rl2 : exprlist) : simple r1 && simplelist (exprlist_app rl1 rl2) =\nsimple r1 && simplelist rl1 && simplelist rl2.","conclusion":"simple r1 && simplelist (exprlist_app rl1 rl2) =\nsimple r1 && simplelist rl1 && simplelist rl2","hypotheses":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist (exprlist_app rl1 rl0) = simplelist rl1 && simplelist rl0) (rl2 : exprlist)","proofString":"rewrite IHrl1.\napply andb_assoc."},{"statement":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist (exprlist_app rl1 rl0) = simplelist rl1 && simplelist rl0) (rl2 : exprlist) : simple r1 && (simplelist rl1 && simplelist rl2) =\nsimple r1 && simplelist rl1 && simplelist rl2.","conclusion":"simple r1 && (simplelist rl1 && simplelist rl2) =\nsimple r1 && simplelist rl1 && simplelist rl2","hypotheses":"(r1 : expr) (rl1 : exprlist) (IHrl1 : forall rl0 : exprlist,\nsimplelist (exprlist_app rl1 rl0) = simplelist rl1 && simplelist rl0) (rl2 : exprlist)","proofString":"apply andb_assoc."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t.","conclusion":"forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t)","proofString":"assert (COS:    forall e m s t f k,    execinf_stmt e m s t ->    forever_N step lt ge O (State f s k e m) t).\ncofix COS.\nassert (COE:    forall e m K a t C f k,    evalinf_expr e m K a t ->    leftcontext K RV C ->    forever_N step lt ge (esize a) (ExprState f (C a) k e m) t).\ncofix COE.\nassert (COEL:    forall e m a t C f k a1 al ty,    evalinf_exprlist e m a t ->    leftcontext RV RV C -> simple a1 = true -> simplelist al = true ->    forever_N step lt ge (esizelist a)                   (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t).\ncofix COEL.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)).\neauto.\neapply leftcontext_compose; eauto.\nconstructor.\nauto.\napply exprlist_app_leftcontext; auto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H3             (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\napply exprlist_app_leftcontext; auto.\neapply forever_N_star with (a2 := (esizelist al0)).\neexact R.\nsimpl; lia.\nchange (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).\nrewrite <- exprlist_app_assoc.\neapply COEL.\neauto.\nauto.\nauto.\nrewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto.\nauto.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Efield x f0 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Evalof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ederef x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eaddrof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eunop op x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ebinop op x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecast x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqand x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqand x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqand_true; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqor x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqor x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqor_false; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Econdition x a2 a3 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Econdition x a2 a3 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_condition; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x ty ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassign x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op x a2 tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassignop op x a2 tyres ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op a1' x tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Epostincr id x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecomma x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecomma x a2 (typeof a2))) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_comma; eauto.\nreflexivity.\neapply COE with (C := C); eauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esizelist a2)).\neexact R.\nsimpl; lia.\neapply COEL with (al := Enil).\neauto.\nauto.\nauto.\nauto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x rargs ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\ndestruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k)  as [S T].\nauto.\nauto.\nsimpl; auto.\neapply forever_N_plus.\neapply plus_right.\neapply star_trans.\neexact R.\neexact T.\nreflexivity.\nsimpl.\nleft; eapply step_call; eauto.\ncongruence.\nreflexivity.\napply COF.\neauto.\ntraceEq.\nintros.\ninv H.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neauto.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright.\neapply step_ifthenelse_2 with (b := b).\nauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_while_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kwhile2 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_while_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_while; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_one.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\nreflexivity.\nreflexivity.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_left.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_dowhile_true; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\nassert (a1 <> Sskip).\nred; intros; subst a1; inv H0.\neapply forever_N_plus.\napply plus_one.\nright.\nconstructor.\nauto.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq (Sfor Sskip a2 a3 s0) k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\nauto.\neapply star_trans.\neexact A1.\napply star_one.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; apply step_for.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_for_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_for3; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H4 f (Kfor4 a2 a3 s0 k)) as [S2 [A2 B2]]; auto.\ninv B2.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H3; inv B1; right; apply step_skip_or_continue_for3; auto.\neapply star_right.\neexact A2.\nright; constructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; constructor.\neauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\nintros.\ninv H.\neapply forever_N_plus.\napply plus_one.\nright; econstructor; eauto.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t.","conclusion":"forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t)","proofString":"cofix COS.\nassert (COE:    forall e m K a t C f k,    evalinf_expr e m K a t ->    leftcontext K RV C ->    forever_N step lt ge (esize a) (ExprState f (C a) k e m) t).\ncofix COE.\nassert (COEL:    forall e m a t C f k a1 al ty,    evalinf_exprlist e m a t ->    leftcontext RV RV C -> simple a1 = true -> simplelist al = true ->    forever_N step lt ge (esizelist a)                   (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t).\ncofix COEL.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)).\neauto.\neapply leftcontext_compose; eauto.\nconstructor.\nauto.\napply exprlist_app_leftcontext; auto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H3             (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\napply exprlist_app_leftcontext; auto.\neapply forever_N_star with (a2 := (esizelist al0)).\neexact R.\nsimpl; lia.\nchange (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).\nrewrite <- exprlist_app_assoc.\neapply COEL.\neauto.\nauto.\nauto.\nrewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto.\nauto.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Efield x f0 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Evalof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ederef x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eaddrof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eunop op x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ebinop op x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecast x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqand x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqand x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqand_true; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqor x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqor x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqor_false; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Econdition x a2 a3 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Econdition x a2 a3 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_condition; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x ty ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassign x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op x a2 tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassignop op x a2 tyres ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op a1' x tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Epostincr id x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecomma x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecomma x a2 (typeof a2))) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_comma; eauto.\nreflexivity.\neapply COE with (C := C); eauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esizelist a2)).\neexact R.\nsimpl; lia.\neapply COEL with (al := Enil).\neauto.\nauto.\nauto.\nauto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x rargs ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\ndestruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k)  as [S T].\nauto.\nauto.\nsimpl; auto.\neapply forever_N_plus.\neapply plus_right.\neapply star_trans.\neexact R.\neexact T.\nreflexivity.\nsimpl.\nleft; eapply step_call; eauto.\ncongruence.\nreflexivity.\napply COF.\neauto.\ntraceEq.\nintros.\ninv H.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neauto.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright.\neapply step_ifthenelse_2 with (b := b).\nauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_while_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kwhile2 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_while_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_while; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_one.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\nreflexivity.\nreflexivity.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_left.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_dowhile_true; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\nassert (a1 <> Sskip).\nred; intros; subst a1; inv H0.\neapply forever_N_plus.\napply plus_one.\nright.\nconstructor.\nauto.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq (Sfor Sskip a2 a3 s0) k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\nauto.\neapply star_trans.\neexact A1.\napply star_one.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; apply step_for.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_for_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_for3; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H4 f (Kfor4 a2 a3 s0 k)) as [S2 [A2 B2]]; auto.\ninv B2.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H3; inv B1; right; apply step_skip_or_continue_for3; auto.\neapply star_right.\neexact A2.\nright; constructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; constructor.\neauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t.","conclusion":"forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t)","proofString":"assert (COE:    forall e m K a t C f k,    evalinf_expr e m K a t ->    leftcontext K RV C ->    forever_N step lt ge (esize a) (ExprState f (C a) k e m) t).\ncofix COE.\nassert (COEL:    forall e m a t C f k a1 al ty,    evalinf_exprlist e m a t ->    leftcontext RV RV C -> simple a1 = true -> simplelist al = true ->    forever_N step lt ge (esizelist a)                   (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t).\ncofix COEL.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)).\neauto.\neapply leftcontext_compose; eauto.\nconstructor.\nauto.\napply exprlist_app_leftcontext; auto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H3             (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\napply exprlist_app_leftcontext; auto.\neapply forever_N_star with (a2 := (esizelist al0)).\neexact R.\nsimpl; lia.\nchange (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).\nrewrite <- exprlist_app_assoc.\neapply COEL.\neauto.\nauto.\nauto.\nrewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto.\nauto.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Efield x f0 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Evalof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ederef x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eaddrof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eunop op x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ebinop op x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecast x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqand x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqand x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqand_true; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqor x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqor x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqor_false; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Econdition x a2 a3 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Econdition x a2 a3 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_condition; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x ty ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassign x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op x a2 tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassignop op x a2 tyres ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op a1' x tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Epostincr id x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecomma x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecomma x a2 (typeof a2))) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_comma; eauto.\nreflexivity.\neapply COE with (C := C); eauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esizelist a2)).\neexact R.\nsimpl; lia.\neapply COEL with (al := Enil).\neauto.\nauto.\nauto.\nauto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x rargs ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\ndestruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k)  as [S T].\nauto.\nauto.\nsimpl; auto.\neapply forever_N_plus.\neapply plus_right.\neapply star_trans.\neexact R.\neexact T.\nreflexivity.\nsimpl.\nleft; eapply step_call; eauto.\ncongruence.\nreflexivity.\napply COF.\neauto.\ntraceEq.\nintros.\ninv H.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neauto.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright.\neapply step_ifthenelse_2 with (b := b).\nauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_while_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kwhile2 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_while_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_while; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_one.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\nreflexivity.\nreflexivity.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_left.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_dowhile_true; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\nassert (a1 <> Sskip).\nred; intros; subst a1; inv H0.\neapply forever_N_plus.\napply plus_one.\nright.\nconstructor.\nauto.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq (Sfor Sskip a2 a3 s0) k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\nauto.\neapply star_trans.\neexact A1.\napply star_one.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; apply step_for.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_for_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_for3; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H4 f (Kfor4 a2 a3 s0 k)) as [S2 [A2 B2]]; auto.\ninv B2.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H3; inv B1; right; apply step_skip_or_continue_for3; auto.\neapply star_right.\neexact A2.\nright; constructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; constructor.\neauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t.","conclusion":"forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t)","proofString":"cofix COE.\nassert (COEL:    forall e m a t C f k a1 al ty,    evalinf_exprlist e m a t ->    leftcontext RV RV C -> simple a1 = true -> simplelist al = true ->    forever_N step lt ge (esizelist a)                   (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t).\ncofix COEL.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)).\neauto.\neapply leftcontext_compose; eauto.\nconstructor.\nauto.\napply exprlist_app_leftcontext; auto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H3             (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\napply exprlist_app_leftcontext; auto.\neapply forever_N_star with (a2 := (esizelist al0)).\neexact R.\nsimpl; lia.\nchange (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).\nrewrite <- exprlist_app_assoc.\neapply COEL.\neauto.\nauto.\nauto.\nrewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto.\nauto.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Efield x f0 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Evalof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ederef x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eaddrof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eunop op x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ebinop op x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecast x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqand x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqand x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqand_true; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqor x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqor x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqor_false; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Econdition x a2 a3 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Econdition x a2 a3 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_condition; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x ty ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassign x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op x a2 tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassignop op x a2 tyres ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op a1' x tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Epostincr id x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecomma x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecomma x a2 (typeof a2))) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_comma; eauto.\nreflexivity.\neapply COE with (C := C); eauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esizelist a2)).\neexact R.\nsimpl; lia.\neapply COEL with (al := Enil).\neauto.\nauto.\nauto.\nauto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x rargs ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\ndestruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k)  as [S T].\nauto.\nauto.\nsimpl; auto.\neapply forever_N_plus.\neapply plus_right.\neapply star_trans.\neexact R.\neexact T.\nreflexivity.\nsimpl.\nleft; eapply step_call; eauto.\ncongruence.\nreflexivity.\napply COF.\neauto.\ntraceEq."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t) : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t.","conclusion":"forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t)","proofString":"assert (COEL:    forall e m a t C f k a1 al ty,    evalinf_exprlist e m a t ->    leftcontext RV RV C -> simple a1 = true -> simplelist al = true ->    forever_N step lt ge (esizelist a)                   (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t).\ncofix COEL.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)).\neauto.\neapply leftcontext_compose; eauto.\nconstructor.\nauto.\napply exprlist_app_leftcontext; auto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H3             (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\napply exprlist_app_leftcontext; auto.\neapply forever_N_star with (a2 := (esizelist al0)).\neexact R.\nsimpl; lia.\nchange (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).\nrewrite <- exprlist_app_assoc.\neapply COEL.\neauto.\nauto.\nauto.\nrewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto.\nauto.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Efield x f0 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Evalof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ederef x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eaddrof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eunop op x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ebinop op x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecast x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqand x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqand x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqand_true; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqor x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqor x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqor_false; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Econdition x a2 a3 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Econdition x a2 a3 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_condition; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x ty ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassign x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op x a2 tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassignop op x a2 tyres ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op a1' x tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Epostincr id x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecomma x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecomma x a2 (typeof a2))) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_comma; eauto.\nreflexivity.\neapply COE with (C := C); eauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esizelist a2)).\neexact R.\nsimpl; lia.\neapply COEL with (al := Enil).\neauto.\nauto.\nauto.\nauto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x rargs ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\ndestruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k)  as [S T].\nauto.\nauto.\nsimpl; auto.\neapply forever_N_plus.\neapply plus_right.\neapply star_trans.\neexact R.\neexact T.\nreflexivity.\nsimpl.\nleft; eapply step_call; eauto.\ncongruence.\nreflexivity.\napply COF.\neauto.\ntraceEq."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t) : forall (e : env) (m : mem) (a : exprlist) (t : traceinf) \n  (C : expr -> expr) (f : function) (k : cont) (a1 : expr) \n  (al : exprlist) (ty : type),\nevalinf_exprlist e m a t ->\nleftcontext RV RV C ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t.","conclusion":"forall (e : env) (m : mem) (a : exprlist) (t : traceinf) \n  (C : expr -> expr) (f : function) (k : cont) (a1 : expr) \n  (al : exprlist) (ty : type),\nevalinf_exprlist e m a t ->\nleftcontext RV RV C ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t)","proofString":"cofix COEL.\nintros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)).\neauto.\neapply leftcontext_compose; eauto.\nconstructor.\nauto.\napply exprlist_app_leftcontext; auto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H3             (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\napply exprlist_app_leftcontext; auto.\neapply forever_N_star with (a2 := (esizelist al0)).\neexact R.\nsimpl; lia.\nchange (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).\nrewrite <- exprlist_app_assoc.\neapply COEL.\neauto.\nauto.\nauto.\nrewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto.\nauto."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t) (COEL : forall (e : env) (m : mem) (a : exprlist) (t : traceinf) \n  (C : expr -> expr) (f : function) (k : cont) (a1 : expr) \n  (al : exprlist) (ty : type),\nevalinf_exprlist e m a t ->\nleftcontext RV RV C ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t) : forall (e : env) (m : mem) (a : exprlist) (t : traceinf) \n  (C : expr -> expr) (f : function) (k : cont) (a1 : expr) \n  (al : exprlist) (ty : type),\nevalinf_exprlist e m a t ->\nleftcontext RV RV C ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t.","conclusion":"forall (e : env) (m : mem) (a : exprlist) (t : traceinf) \n  (C : expr -> expr) (f : function) (k : cont) (a1 : expr) \n  (al : exprlist) (ty : type),\nevalinf_exprlist e m a t ->\nleftcontext RV RV C ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t) (COEL : forall (e : env) (m : mem) (a : exprlist) (t : traceinf) \n  (C : expr -> expr) (f : function) (k : cont) (a1 : expr) \n  (al : exprlist) (ty : type),\nevalinf_exprlist e m a t ->\nleftcontext RV RV C ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t)","proofString":"intros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)).\neauto.\neapply leftcontext_compose; eauto.\nconstructor.\nauto.\napply exprlist_app_leftcontext; auto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H3             (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\napply exprlist_app_leftcontext; auto.\neapply forever_N_star with (a2 := (esizelist al0)).\neexact R.\nsimpl; lia.\nchange (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).\nrewrite <- exprlist_app_assoc.\neapply COEL.\neauto.\nauto.\nauto.\nrewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto.\nauto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (H3 : evalinf_expr e m RV a0 t) : (esize a0 < esizelist (Econs a0 al0))%nat.","conclusion":"(esize a0 < esizelist (Econs a0 al0))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (H3 : evalinf_expr e m RV a0 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (H3 : evalinf_expr e m RV a0 t) : leftcontext RV RV\n  (fun x : expr => Ecall a1 (exprlist_app al (Econs x al0)) ty).","conclusion":"leftcontext RV RV\n  (fun x : expr => Ecall a1 (exprlist_app al (Econs x al0)) ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (H3 : evalinf_expr e m RV a0 t)","proofString":"constructor.\nauto.\napply exprlist_app_leftcontext; auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (H3 : evalinf_expr e m RV a0 t) : simple a1 = true.","conclusion":"simple a1 = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (H3 : evalinf_expr e m RV a0 t)","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (H3 : evalinf_expr e m RV a0 t) : leftcontextlist RV (fun x : expr => exprlist_app al (Econs x al0)).","conclusion":"leftcontextlist RV (fun x : expr => exprlist_app al (Econs x al0))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (H3 : evalinf_expr e m RV a0 t)","proofString":"apply exprlist_app_leftcontext; auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) : forever_N step lt ge (esizelist (Econs a0 al0))\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m)\n  (t1 *** t2).","conclusion":"forever_N step lt ge (esizelist (Econs a0 al0))\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m)\n  (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2)","proofString":"destruct (eval_expr_to_steps _ _ _ _ _ _ _ H3             (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\napply exprlist_app_leftcontext; auto.\neapply forever_N_star with (a2 := (esizelist al0)).\neexact R.\nsimpl; lia.\nchange (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).\nrewrite <- exprlist_app_assoc.\neapply COEL.\neauto.\nauto.\nauto.\nrewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto.\nauto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) : leftcontext RV RV\n  (fun x : expr => C (Ecall a1 (exprlist_app al (Econs x al0)) ty)).","conclusion":"leftcontext RV RV\n  (fun x : expr => C (Ecall a1 (exprlist_app al (Econs x al0)) ty))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\napply exprlist_app_leftcontext; auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) : leftcontext RV RV\n  (fun x : expr => Ecall a1 (exprlist_app al (Econs x al0)) ty).","conclusion":"leftcontext RV RV\n  (fun x : expr => Ecall a1 (exprlist_app al (Econs x al0)) ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2)","proofString":"repeat constructor.\nauto.\napply exprlist_app_leftcontext; auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) : simple a1 = true.","conclusion":"simple a1 = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2)","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) : leftcontextlist RV (fun x : expr => exprlist_app al (Econs x al0)).","conclusion":"leftcontextlist RV (fun x : expr => exprlist_app al (Econs x al0))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2)","proofString":"apply exprlist_app_leftcontext; auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1)) : forever_N step lt ge (esizelist (Econs a0 al0))\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m)\n  (t1 *** t2).","conclusion":"forever_N step lt ge (esizelist (Econs a0 al0))\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m)\n  (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1))","proofString":"eapply forever_N_star with (a2 := (esizelist al0)).\neexact R.\nsimpl; lia.\nchange (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).\nrewrite <- exprlist_app_assoc.\neapply COEL.\neauto.\nauto.\nauto.\nrewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto.\nauto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1)) : (esizelist al0 < esizelist (Econs a0 al0))%nat.","conclusion":"(esizelist al0 < esizelist (Econs a0 al0))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1))","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1)) : leftcontext RV RV C.","conclusion":"leftcontext RV RV C","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1)) : simple a1 = true.","conclusion":"simple a1 = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1)) : simplelist (exprlist_app al (Econs a1' Enil)) = true.","conclusion":"simplelist (exprlist_app al (Econs a1' Enil)) = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1))","proofString":"rewrite exprlist_app_simple.\nsimpl.\nrewrite H2; rewrite P; auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1)) : simplelist al && simplelist (Econs a1' Enil) = true.","conclusion":"simplelist al && simplelist (Econs a1' Enil) = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1))","proofString":"simpl.\nrewrite H2; rewrite P; auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1)) : simplelist al && (simple a1' && true) = true.","conclusion":"simplelist al && (simple a1' && true) = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a2 : expr) (al1 : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a2 = true ->\nsimplelist al1 = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a2 (exprlist_app al1 a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (a1 : expr) (al : exprlist) (ty : type) (H0 : leftcontext RV RV C) (H1 : simple a1 = true) (H2 : simplelist al = true) (a0 : expr) (al0 : exprlist) (t1 : trace) (m1 : mem) (a1' : expr) (t2 : traceinf) (H3 : eval_expr e m RV a0 t1 m1 a1') (H4 : evalinf_exprlist e m1 al0 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a0) (R : star step ge\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a0 al0)) ty)) k e m) t1\n  (ExprState f (C (Ecall a1 (exprlist_app al (Econs a1' al0)) ty)) k e m1))","proofString":"rewrite H2; rewrite P; auto."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t) (COEL : forall (e : env) (m : mem) (a : exprlist) (t : traceinf) \n  (C : expr -> expr) (f : function) (k : cont) (a1 : expr) \n  (al : exprlist) (ty : type),\nevalinf_exprlist e m a t ->\nleftcontext RV RV C ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t) : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t.","conclusion":"forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t) (COEL : forall (e : env) (m : mem) (a : exprlist) (t : traceinf) \n  (C : expr -> expr) (f : function) (k : cont) (a1 : expr) \n  (al : exprlist) (ty : type),\nevalinf_exprlist e m a t ->\nleftcontext RV RV C ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t)","proofString":"intros.\ninv H.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Efield x f0 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Evalof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ederef x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eaddrof x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eunop op x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ebinop op x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Ebinop op a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecast x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqand x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqand x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqand_true; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eseqor x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqor x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_seqor_false; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x type_bool ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Econdition x a2 a3 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Econdition x a2 a3 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_condition; eauto.\nrewrite Q; eauto.\nreflexivity.\neapply COE with (C := fun x => (C (Eparen x ty ty))).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassign x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassign a1' x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op x a2 tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassignop op x a2 tyres ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esize a2)).\neexact R.\nsimpl; lia.\neapply COE with (C := fun x => C(Eassignop op a1' x tyres ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\nauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a0)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Epostincr id x ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecomma x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecomma x a2 (typeof a2))) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_plus.\neapply plus_right.\neexact R.\nleft; eapply step_comma; eauto.\nreflexivity.\neapply COE with (C := C); eauto.\ntraceEq.\neapply forever_N_star with (a2 := (esize a1)).\napply star_refl.\nsimpl; lia.\neapply COE with (C := fun x => C(Ecall x a2 ty)).\neauto.\neapply leftcontext_compose; eauto.\nrepeat constructor.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esizelist a2)).\neexact R.\nsimpl; lia.\neapply COEL with (al := Enil).\neauto.\nauto.\nauto.\nauto.\ntraceEq.\ndestruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x rargs ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\ndestruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k)  as [S T].\nauto.\nauto.\nsimpl; auto.\neapply forever_N_plus.\neapply plus_right.\neapply star_trans.\neexact R.\neexact T.\nreflexivity.\nsimpl.\nleft; eapply step_call; eauto.\ncongruence.\nreflexivity.\napply COF.\neauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f1 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f1 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f1 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f1 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f1 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f1 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext LV RV C) (a0 : expr) (f0 : ident) (ty : type) (H1 : evalinf_expr e m RV a0 t) : (esize a0 < esize (Efield a0 f0 ty))%nat.","conclusion":"(esize a0 < esize (Efield a0 f0 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f1 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f1 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f1 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f1 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f1 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f1 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext LV RV C) (a0 : expr) (f0 : ident) (ty : type) (H1 : evalinf_expr e m RV a0 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f1 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f1 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f1 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f1 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f1 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f1 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext LV RV C) (a0 : expr) (f0 : ident) (ty : type) (H1 : evalinf_expr e m RV a0 t) : leftcontext RV LV (fun x : expr => Efield x f0 ty).","conclusion":"leftcontext RV LV (fun x : expr => Efield x f0 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f1 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f1 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f1 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f1 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f1 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f1 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext LV RV C) (a0 : expr) (f0 : ident) (ty : type) (H1 : evalinf_expr e m RV a0 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m LV a0 t) : (esize a0 < esize (Evalof a0 ty))%nat.","conclusion":"(esize a0 < esize (Evalof a0 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m LV a0 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m LV a0 t) : leftcontext LV RV (fun x : expr => Evalof x ty).","conclusion":"leftcontext LV RV (fun x : expr => Evalof x ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m LV a0 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext LV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m RV a0 t) : (esize a0 < esize (Ederef a0 ty))%nat.","conclusion":"(esize a0 < esize (Ederef a0 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext LV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m RV a0 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext LV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m RV a0 t) : leftcontext RV LV (fun x : expr => Ederef x ty).","conclusion":"leftcontext RV LV (fun x : expr => Ederef x ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext LV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m RV a0 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m LV a0 t) : (esize a0 < esize (Eaddrof a0 ty))%nat.","conclusion":"(esize a0 < esize (Eaddrof a0 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m LV a0 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m LV a0 t) : leftcontext LV RV (fun x : expr => Eaddrof x ty).","conclusion":"leftcontext LV RV (fun x : expr => Eaddrof x ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m LV a0 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (op : unary_operation) (ty : type) (H1 : evalinf_expr e m RV a0 t) : (esize a0 < esize (Eunop op a0 ty))%nat.","conclusion":"(esize a0 < esize (Eunop op a0 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (op : unary_operation) (ty : type) (H1 : evalinf_expr e m RV a0 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (op : unary_operation) (ty : type) (H1 : evalinf_expr e m RV a0 t) : leftcontext RV RV (fun x : expr => Eunop op x ty).","conclusion":"leftcontext RV RV (fun x : expr => Eunop op x ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (op : unary_operation) (ty : type) (H1 : evalinf_expr e m RV a0 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (op : binary_operation) (ty : type) (H1 : evalinf_expr e m RV a1 t) : (esize a1 < esize (Ebinop op a1 a2 ty))%nat.","conclusion":"(esize a1 < esize (Ebinop op a1 a2 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (op : binary_operation) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (op : binary_operation) (ty : type) (H1 : evalinf_expr e m RV a1 t) : leftcontext RV RV (fun x : expr => Ebinop op x a2 ty).","conclusion":"leftcontext RV RV (fun x : expr => Ebinop op x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (op : binary_operation) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) : leftcontext RV RV (fun x : expr => C (Ebinop op x a2 ty)).","conclusion":"leftcontext RV RV (fun x : expr => C (Ebinop op x a2 ty))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) : leftcontext RV RV (fun x : expr => Ebinop op x a2 ty).","conclusion":"leftcontext RV RV (fun x : expr => Ebinop op x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ebinop op a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ebinop op a1' a2 ty)) k e m')) : (esize a2 < esize (Ebinop op a1 a2 ty))%nat.","conclusion":"(esize a2 < esize (Ebinop op a1 a2 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ebinop op a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ebinop op a1' a2 ty)) k e m'))","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ebinop op a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ebinop op a1' a2 ty)) k e m')) : leftcontext RV RV (fun x : expr => Ebinop op a1' x ty).","conclusion":"leftcontext RV RV (fun x : expr => Ebinop op a1' x ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ebinop op a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ebinop op a1' a2 ty)) k e m'))","proofString":"repeat constructor.\nauto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ebinop op a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ebinop op a1' a2 ty)) k e m')) : simple a1' = true.","conclusion":"simple a1' = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (ty : type) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ebinop op a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ebinop op a1' a2 ty)) k e m'))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m RV a0 t) : (esize a0 < esize (Ecast a0 ty))%nat.","conclusion":"(esize a0 < esize (Ecast a0 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m RV a0 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m RV a0 t) : leftcontext RV RV (fun x : expr => Ecast x ty).","conclusion":"leftcontext RV RV (fun x : expr => Ecast x ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (ty : type) (H1 : evalinf_expr e m RV a0 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t) : (esize a1 < esize (Eseqand a1 a2 ty))%nat.","conclusion":"(esize a1 < esize (Eseqand a1 a2 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t) : leftcontext RV RV (fun x : expr => Eseqand x a2 ty).","conclusion":"leftcontext RV RV (fun x : expr => Eseqand x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some true) (H4 : evalinf_expr e m' RV a2 t2) : leftcontext RV RV (fun x : expr => C (Eseqand x a2 ty)).","conclusion":"leftcontext RV RV (fun x : expr => C (Eseqand x a2 ty))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some true) (H4 : evalinf_expr e m' RV a2 t2)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some true) (H4 : evalinf_expr e m' RV a2 t2) : leftcontext RV RV (fun x : expr => Eseqand x a2 ty).","conclusion":"leftcontext RV RV (fun x : expr => Eseqand x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some true) (H4 : evalinf_expr e m' RV a2 t2)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some true) (H4 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eseqand a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eseqand a1' a2 ty)) k e m')) : bool_val v1 (typeof a1') m' = Some true.","conclusion":"bool_val v1 (typeof a1') m' = Some true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some true) (H4 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eseqand a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eseqand a1' a2 ty)) k e m'))","proofString":"rewrite Q; eauto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some true) (H4 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eseqand a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eseqand a1' a2 ty)) k e m')) : leftcontext RV RV (fun x : expr => Eparen x type_bool ty).","conclusion":"leftcontext RV RV (fun x : expr => Eparen x type_bool ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some true) (H4 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eseqand a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eseqand a1' a2 ty)) k e m'))","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t) : (esize a1 < esize (Eseqor a1 a2 ty))%nat.","conclusion":"(esize a1 < esize (Eseqor a1 a2 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t) : leftcontext RV RV (fun x : expr => Eseqor x a2 ty).","conclusion":"leftcontext RV RV (fun x : expr => Eseqor x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some false) (H4 : evalinf_expr e m' RV a2 t2) : leftcontext RV RV (fun x : expr => C (Eseqor x a2 ty)).","conclusion":"leftcontext RV RV (fun x : expr => C (Eseqor x a2 ty))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some false) (H4 : evalinf_expr e m' RV a2 t2)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some false) (H4 : evalinf_expr e m' RV a2 t2) : leftcontext RV RV (fun x : expr => Eseqor x a2 ty).","conclusion":"leftcontext RV RV (fun x : expr => Eseqor x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some false) (H4 : evalinf_expr e m' RV a2 t2)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some false) (H4 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eseqor a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eseqor a1' a2 ty)) k e m')) : bool_val v1 (typeof a1') m' = Some false.","conclusion":"bool_val v1 (typeof a1') m' = Some false","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some false) (H4 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eseqor a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eseqor a1' a2 ty)) k e m'))","proofString":"rewrite Q; eauto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some false) (H4 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eseqor a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eseqor a1' a2 ty)) k e m')) : leftcontext RV RV (fun x : expr => Eparen x type_bool ty).","conclusion":"leftcontext RV RV (fun x : expr => Eparen x type_bool ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some false) (H4 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eseqor a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eseqor a1' a2 ty)) k e m'))","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t) : (esize a1 < esize (Econdition a1 a2 a3 ty))%nat.","conclusion":"(esize a1 < esize (Econdition a1 a2 a3 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t) : leftcontext RV RV (fun x : expr => Econdition x a2 a3 ty).","conclusion":"leftcontext RV RV (fun x : expr => Econdition x a2 a3 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (b : bool) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some b) (H4 : evalinf_expr e m' RV (if b then a2 else a3) t2) : leftcontext RV RV (fun x : expr => C (Econdition x a2 a3 ty)).","conclusion":"leftcontext RV RV (fun x : expr => C (Econdition x a2 a3 ty))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (b : bool) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some b) (H4 : evalinf_expr e m' RV (if b then a2 else a3) t2)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (b : bool) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some b) (H4 : evalinf_expr e m' RV (if b then a2 else a3) t2) : leftcontext RV RV (fun x : expr => Econdition x a2 a3 ty).","conclusion":"leftcontext RV RV (fun x : expr => Econdition x a2 a3 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (b : bool) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some b) (H4 : evalinf_expr e m' RV (if b then a2 else a3) t2)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (b : bool) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some b) (H4 : evalinf_expr e m' RV (if b then a2 else a3) t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Econdition a1 a2 a3 ty)) k e m) t1\n  (ExprState f (C (Econdition a1' a2 a3 ty)) k e m')) : leftcontext RV RV (fun x : expr => Eparen x ty ty).","conclusion":"leftcontext RV RV (fun x : expr => Eparen x ty ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 a3 : expr) (ty : type) (t1 : trace) (m' : mem) (a1' : expr) (v1 : val) (t2 : traceinf) (b : bool) (H1 : eval_expr e m RV a1 t1 m' a1') (H2 : eval_simple_rvalue ge e m' a1' v1) (H3 : bool_val v1 (typeof a1) m' = Some b) (H4 : evalinf_expr e m' RV (if b then a2 else a3) t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Econdition a1 a2 a3 ty)) k e m) t1\n  (ExprState f (C (Econdition a1' a2 a3 ty)) k e m'))","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m LV a1 t) : (esize a1 < esize (Eassign a1 a2 ty))%nat.","conclusion":"(esize a1 < esize (Eassign a1 a2 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m LV a1 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m LV a1 t) : leftcontext LV RV (fun x : expr => Eassign x a2 ty).","conclusion":"leftcontext LV RV (fun x : expr => Eassign x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m LV a1 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) : leftcontext LV RV (fun x : expr => C (Eassign x a2 ty)).","conclusion":"leftcontext LV RV (fun x : expr => C (Eassign x a2 ty))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) : leftcontext LV RV (fun x : expr => Eassign x a2 ty).","conclusion":"leftcontext LV RV (fun x : expr => Eassign x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassign a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eassign a1' a2 ty)) k e m')) : (esize a2 < esize (Eassign a1 a2 ty))%nat.","conclusion":"(esize a2 < esize (Eassign a1 a2 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassign a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eassign a1' a2 ty)) k e m'))","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassign a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eassign a1' a2 ty)) k e m')) : leftcontext RV RV (fun x : expr => Eassign a1' x ty).","conclusion":"leftcontext RV RV (fun x : expr => Eassign a1' x ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassign a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eassign a1' a2 ty)) k e m'))","proofString":"repeat constructor.\nauto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassign a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eassign a1' a2 ty)) k e m')) : simple a1' = true.","conclusion":"simple a1' = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassign a1 a2 ty)) k e m) t1\n  (ExprState f (C (Eassign a1' a2 ty)) k e m'))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (op : binary_operation) (tyres ty : type) (H1 : evalinf_expr e m LV a1 t) : (esize a1 < esize (Eassignop op a1 a2 tyres ty))%nat.","conclusion":"(esize a1 < esize (Eassignop op a1 a2 tyres ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (op : binary_operation) (tyres ty : type) (H1 : evalinf_expr e m LV a1 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (op : binary_operation) (tyres ty : type) (H1 : evalinf_expr e m LV a1 t) : leftcontext LV RV (fun x : expr => Eassignop op x a2 tyres ty).","conclusion":"leftcontext LV RV (fun x : expr => Eassignop op x a2 tyres ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (op : binary_operation) (tyres ty : type) (H1 : evalinf_expr e m LV a1 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) : leftcontext LV RV (fun x : expr => C (Eassignop op x a2 tyres ty)).","conclusion":"leftcontext LV RV (fun x : expr => C (Eassignop op x a2 tyres ty))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) : leftcontext LV RV (fun x : expr => Eassignop op x a2 tyres ty).","conclusion":"leftcontext LV RV (fun x : expr => Eassignop op x a2 tyres ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassignop op a1 a2 tyres ty)) k e m) t1\n  (ExprState f (C (Eassignop op a1' a2 tyres ty)) k e m')) : (esize a2 < esize (Eassignop op a1 a2 tyres ty))%nat.","conclusion":"(esize a2 < esize (Eassignop op a1 a2 tyres ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassignop op a1 a2 tyres ty)) k e m) t1\n  (ExprState f (C (Eassignop op a1' a2 tyres ty)) k e m'))","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassignop op a1 a2 tyres ty)) k e m) t1\n  (ExprState f (C (Eassignop op a1' a2 tyres ty)) k e m')) : leftcontext RV RV (fun x : expr => Eassignop op a1' x tyres ty).","conclusion":"leftcontext RV RV (fun x : expr => Eassignop op a1' x tyres ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassignop op a1 a2 tyres ty)) k e m) t1\n  (ExprState f (C (Eassignop op a1' a2 tyres ty)) k e m'))","proofString":"repeat constructor.\nauto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassignop op a1 a2 tyres ty)) k e m) t1\n  (ExprState f (C (Eassignop op a1' a2 tyres ty)) k e m')) : simple a1' = true.","conclusion":"simple a1' = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m' : mem) (a1' a2 : expr) (t2 : traceinf) (op : binary_operation) (tyres ty : type) (H1 : eval_expr e m LV a1 t1 m' a1') (H2 : evalinf_expr e m' RV a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Eassignop op a1 a2 tyres ty)) k e m) t1\n  (ExprState f (C (Eassignop op a1' a2 tyres ty)) k e m'))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (id : incr_or_decr) (ty : type) (H1 : evalinf_expr e m LV a0 t) : (esize a0 < esize (Epostincr id a0 ty))%nat.","conclusion":"(esize a0 < esize (Epostincr id a0 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (id : incr_or_decr) (ty : type) (H1 : evalinf_expr e m LV a0 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (id : incr_or_decr) (ty : type) (H1 : evalinf_expr e m LV a0 t) : leftcontext LV RV (fun x : expr => Epostincr id x ty).","conclusion":"leftcontext LV RV (fun x : expr => Epostincr id x ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a0 : expr) (id : incr_or_decr) (ty : type) (H1 : evalinf_expr e m LV a0 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t) : (esize a1 < esize (Ecomma a1 a2 ty))%nat.","conclusion":"(esize a1 < esize (Ecomma a1 a2 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t) : leftcontext RV RV (fun x : expr => Ecomma x a2 ty).","conclusion":"leftcontext RV RV (fun x : expr => Ecomma x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 a2 : expr) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (v1 : val) (a2 : expr) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : eval_simple_rvalue ge e m1 a1' v1) (H4 : evalinf_expr e m1 RV a2 t2) : leftcontext RV RV (fun x : expr => C (Ecomma x a2 (typeof a2))).","conclusion":"leftcontext RV RV (fun x : expr => C (Ecomma x a2 (typeof a2)))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (v1 : val) (a2 : expr) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : eval_simple_rvalue ge e m1 a1' v1) (H4 : evalinf_expr e m1 RV a2 t2)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (v1 : val) (a2 : expr) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : eval_simple_rvalue ge e m1 a1' v1) (H4 : evalinf_expr e m1 RV a2 t2) : leftcontext RV RV (fun x : expr => Ecomma x a2 (typeof a2)).","conclusion":"leftcontext RV RV (fun x : expr => Ecomma x a2 (typeof a2))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (v1 : val) (a2 : expr) (t2 : traceinf) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : eval_simple_rvalue ge e m1 a1' v1) (H4 : evalinf_expr e m1 RV a2 t2)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (a2 : exprlist) (ty : type) (H1 : evalinf_expr e m RV a1 t) : (esize a1 < esize (Ecall a1 a2 ty))%nat.","conclusion":"(esize a1 < esize (Ecall a1 a2 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (a2 : exprlist) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (a2 : exprlist) (ty : type) (H1 : evalinf_expr e m RV a1 t) : leftcontext RV RV (fun x : expr => Ecall x a2 ty).","conclusion":"leftcontext RV RV (fun x : expr => Ecall x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t0) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t0 : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t0 ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (a2 : exprlist) (ty : type) (H1 : evalinf_expr e m RV a1 t)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) : forever_N step lt ge (esize (Ecall a1 a2 ty))\n  (ExprState f (C (Ecall a1 a2 ty)) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge (esize (Ecall a1 a2 ty))\n  (ExprState f (C (Ecall a1 a2 ty)) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2)","proofString":"destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x a2 ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\neapply forever_N_star with (a2 := (esizelist a2)).\neexact R.\nsimpl; lia.\neapply COEL with (al := Enil).\neauto.\nauto.\nauto.\nauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) : leftcontext RV RV (fun x : expr => C (Ecall x a2 ty)).","conclusion":"leftcontext RV RV (fun x : expr => C (Ecall x a2 ty))","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) : leftcontext RV RV (fun x : expr => Ecall x a2 ty).","conclusion":"leftcontext RV RV (fun x : expr => Ecall x a2 ty)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1)) : forever_N step lt ge (esize (Ecall a1 a2 ty))\n  (ExprState f (C (Ecall a1 a2 ty)) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge (esize (Ecall a1 a2 ty))\n  (ExprState f (C (Ecall a1 a2 ty)) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1))","proofString":"eapply forever_N_star with (a2 := (esizelist a2)).\neexact R.\nsimpl; lia.\neapply COEL with (al := Enil).\neauto.\nauto.\nauto.\nauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1)) : (esizelist a2 < esize (Ecall a1 a2 ty))%nat.","conclusion":"(esizelist a2 < esize (Ecall a1 a2 ty))%nat","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1))","proofString":"simpl; lia."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1)) : leftcontext RV RV C.","conclusion":"leftcontext RV RV C","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1)) : simple a1' = true.","conclusion":"simple a1' = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1)) : simplelist Enil = true.","conclusion":"simplelist Enil = true","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a0 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a0 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a0 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (a1 : expr) (t1 : trace) (m1 : mem) (a1' : expr) (a2 : exprlist) (t2 : traceinf) (ty : type) (H1 : eval_expr e m RV a1 t1 m1 a1') (H2 : evalinf_exprlist e m1 a2 t2) (P : simple a1' = true) (Q : typeof a1' = typeof a1) (R : star step ge (ExprState f (C (Ecall a1 a2 ty)) k e m) t1\n  (ExprState f (C (Ecall a1' a2 ty)) k e m1))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) : forever_N step lt ge (esize (Ecall rf rargs ty))\n  (ExprState f (C (Ecall rf rargs ty)) k e m) (t1 *** t2 *** t3).","conclusion":"forever_N step lt ge (esize (Ecall rf rargs ty))\n  (ExprState f (C (Ecall rf rargs ty)) k e m) (t1 *** t2 *** t3)","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3)","proofString":"destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x rargs ty)) f k)  as [P [Q R]].\neapply leftcontext_compose; eauto.\nrepeat constructor.\ndestruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k)  as [S T].\nauto.\nauto.\nsimpl; auto.\neapply forever_N_plus.\neapply plus_right.\neapply star_trans.\neexact R.\neexact T.\nreflexivity.\nsimpl.\nleft; eapply step_call; eauto.\ncongruence.\nreflexivity.\napply COF.\neauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) : leftcontext RV RV (fun x : expr => C (Ecall x rargs ty)).","conclusion":"leftcontext RV RV (fun x : expr => C (Ecall x rargs ty))","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3)","proofString":"eapply leftcontext_compose; eauto.\nrepeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) : leftcontext RV RV (fun x : expr => Ecall x rargs ty).","conclusion":"leftcontext RV RV (fun x : expr => Ecall x rargs ty)","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3)","proofString":"repeat constructor."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1)) : forever_N step lt ge (esize (Ecall rf rargs ty))\n  (ExprState f (C (Ecall rf rargs ty)) k e m) (t1 *** t2 *** t3).","conclusion":"forever_N step lt ge (esize (Ecall rf rargs ty))\n  (ExprState f (C (Ecall rf rargs ty)) k e m) (t1 *** t2 *** t3)","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1))","proofString":"destruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k)  as [S T].\nauto.\nauto.\nsimpl; auto.\neapply forever_N_plus.\neapply plus_right.\neapply star_trans.\neexact R.\neexact T.\nreflexivity.\nsimpl.\nleft; eapply step_call; eauto.\ncongruence.\nreflexivity.\napply COF.\neauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1)) : leftcontext RV RV C.","conclusion":"leftcontext RV RV C","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1)) : simple rf' = true.","conclusion":"simple rf' = true","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1)) : simplelist Enil = true.","conclusion":"simplelist Enil = true","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1))","proofString":"simpl; auto."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1)) (S : simplelist rargs' = true) (T : star step ge\n  (ExprState f (C (Ecall rf' (exprlist_app Enil rargs) ty)) k e m1) t2\n  (ExprState f (C (Ecall rf' (exprlist_app Enil rargs') ty)) k e m2)) : forever_N step lt ge (esize (Ecall rf rargs ty))\n  (ExprState f (C (Ecall rf rargs ty)) k e m) (t1 *** t2 *** t3).","conclusion":"forever_N step lt ge (esize (Ecall rf rargs ty))\n  (ExprState f (C (Ecall rf rargs ty)) k e m) (t1 *** t2 *** t3)","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1)) (S : simplelist rargs' = true) (T : star step ge\n  (ExprState f (C (Ecall rf' (exprlist_app Enil rargs) ty)) k e m1) t2\n  (ExprState f (C (Ecall rf' (exprlist_app Enil rargs') ty)) k e m2))","proofString":"eapply forever_N_plus.\neapply plus_right.\neapply star_trans.\neexact R.\neexact T.\nreflexivity.\nsimpl.\nleft; eapply step_call; eauto.\ncongruence.\nreflexivity.\napply COF.\neauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1)) (S : simplelist rargs' = true) (T : star step ge\n  (ExprState f (C (Ecall rf' (exprlist_app Enil rargs) ty)) k e m1) t2\n  (ExprState f (C (Ecall rf' (exprlist_app Enil rargs') ty)) k e m2)) : classify_fun (typeof rf') = fun_case_f targs tres cconv.","conclusion":"classify_fun (typeof rf') = fun_case_f targs tres cconv","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args t ->\nforever_N step lt ge 0%nat (Callstate fd0 args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C0 : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C0 ->\nforever_N step lt ge (esize a) (ExprState f0 (C0 a) k0 e0 m0) t) (COEL : forall (e0 : env) (m0 : mem) (a : exprlist) (t : traceinf)\n  (C0 : expr -> expr) (f0 : function) (k0 : cont) \n  (a1 : expr) (al : exprlist) (ty0 : type),\nevalinf_exprlist e0 m0 a t ->\nleftcontext RV RV C0 ->\nsimple a1 = true ->\nsimplelist al = true ->\nforever_N step lt ge (esizelist a)\n  (ExprState f0 (C0 (Ecall a1 (exprlist_app al a) ty0)) k0 e0 m0) t) (e : env) (m : mem) (C : expr -> expr) (f : function) (k : cont) (H0 : leftcontext RV RV C) (rf : expr) (rargs : exprlist) (ty : type) (t1 : trace) (m1 : mem) (rf' : expr) (t2 : trace) (m2 : mem) (rargs' : exprlist) (vf : val) (vargs : list val) (targs : list type) (tres : type) (cconv : calling_convention) (fd : fundef) (t3 : traceinf) (H1 : eval_expr e m RV rf t1 m1 rf') (H2 : eval_exprlist e m1 rargs t2 m2 rargs') (H3 : eval_simple_rvalue ge e m2 rf' vf) (H4 : eval_simple_list ge e m2 rargs' targs vargs) (H5 : classify_fun (typeof rf) = fun_case_f targs tres cconv) (H6 : Genv.find_funct ge vf = Some fd) (H7 : type_of_fundef fd = Tfunction targs tres cconv) (H8 : evalinf_funcall m2 fd vargs t3) (P : simple rf' = true) (Q : typeof rf' = typeof rf) (R : star step ge (ExprState f (C (Ecall rf rargs ty)) k e m) t1\n  (ExprState f (C (Ecall rf' rargs ty)) k e m1)) (S : simplelist rargs' = true) (T : star step ge\n  (ExprState f (C (Ecall rf' (exprlist_app Enil rargs) ty)) k e m1) t2\n  (ExprState f (C (Ecall rf' (exprlist_app Enil rargs') ty)) k e m2))","proofString":"congruence."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t) : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t.","conclusion":"forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) (COE : forall (e : env) (m : mem) (K : kind) (a : expr) (t : traceinf)\n  (C : expr -> expr) (f : function) (k : cont),\nevalinf_expr e m K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f (C a) k e m) t)","proofString":"intros.\ninv H.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neauto.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright.\neapply step_ifthenelse_2 with (b := b).\nauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_while_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kwhile2 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_while_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_while; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_one.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\nreflexivity.\nreflexivity.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_left.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_dowhile_true; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\nassert (a1 <> Sskip).\nred; intros; subst a1; inv H0.\neapply forever_N_plus.\napply plus_one.\nright.\nconstructor.\nauto.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq (Sfor Sskip a2 a3 s0) k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\nauto.\neapply star_trans.\neexact A1.\napply star_one.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; apply step_for.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_for_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_for3; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H4 f (Kfor4 a2 a3 s0 k)) as [S2 [A2 B2]]; auto.\ninv B2.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H3; inv B1; right; apply step_skip_or_continue_for3; auto.\neapply star_right.\neexact A2.\nright; constructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; constructor.\neauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s0 : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s0 t0 ->\nforever_N step lt ge 0%nat (State f0 s0 k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (s : statement) (t : traceinf) (f : function) (k : cont) (H : execinf_stmt e m s t) : forever_N step lt ge 0%nat (State f s k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f s k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s0 : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s0 t0 ->\nforever_N step lt ge 0%nat (State f0 s0 k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (s : statement) (t : traceinf) (f : function) (k : cont) (H : execinf_stmt e m s t)","proofString":"inv H.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neauto.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright.\neapply step_ifthenelse_2 with (b := b).\nauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_while_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kwhile2 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_while_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_while; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_one.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\nreflexivity.\nreflexivity.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_left.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_dowhile_true; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\nassert (a1 <> Sskip).\nred; intros; subst a1; inv H0.\neapply forever_N_plus.\napply plus_one.\nright.\nconstructor.\nauto.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq (Sfor Sskip a2 a3 s0) k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\nauto.\neapply star_trans.\neexact A1.\napply star_one.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; apply step_for.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_for_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_for3; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H4 f (Kfor4 a2 a3 s0 k)) as [S2 [A2 B2]]; auto.\ninv B2.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H3; inv B1; right; apply step_skip_or_continue_for3; auto.\neapply star_right.\neexact A2.\nright; constructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq.\neapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; constructor.\neauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (H0 : evalinf_expr e m RV a t) : forever_N step lt ge 0%nat (State f (Sdo a) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Sdo a) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (H0 : evalinf_expr e m RV a t)","proofString":"eapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (H0 : evalinf_expr e m RV a t) : leftcontext RV RV (fun x : expr => x).","conclusion":"leftcontext RV RV (fun x : expr => x)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (H0 : evalinf_expr e m RV a t)","proofString":"constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s1 s2 : statement) (H0 : execinf_stmt e m s1 t) : forever_N step lt ge 0%nat (State f (Ssequence s1 s2) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Ssequence s1 s2) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s1 s2 : statement) (H0 : execinf_stmt e m s1 t)","proofString":"eapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt e m s1 t1 m1 Out_normal) (H1 : execinf_stmt e m1 s2 t2) : forever_N step lt ge 0%nat (State f (Ssequence s1 s2) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Ssequence s1 s2) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt e m s1 t1 m1 Out_normal) (H1 : execinf_stmt e m1 s2 t2)","proofString":"destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neauto.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt e m s1 t1 m1 Out_normal) (H1 : execinf_stmt e m1 s2 t2) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kseq s2 k) Out_normal S1) : forever_N step lt ge 0%nat (State f (Ssequence s1 s2) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Ssequence s1 s2) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt e m s1 t1 m1 Out_normal) (H1 : execinf_stmt e m1 s2 t2) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kseq s2 k) Out_normal S1)","proofString":"inv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neauto.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt e m s1 t1 m1 Out_normal) (H1 : execinf_stmt e m1 s2 t2) (A1 : star step ge (State f s1 (Kseq s2 k) e m) t1 (State f Sskip (Kseq s2 k) e m1)) : forever_N step lt ge 0%nat (State f (Ssequence s1 s2) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Ssequence s1 s2) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s1 s2 : statement) (t1 : trace) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt e m s1 t1 m1 Out_normal) (H1 : execinf_stmt e m1 s2 t2) (A1 : star step ge (State f s1 (Kseq s2 k) e m) t1 (State f Sskip (Kseq s2 k) e m1))","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neauto.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (H0 : evalinf_expr e m RV a t) : forever_N step lt ge 0%nat (State f (Sifthenelse a s1 s2) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Sifthenelse a s1 s2) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (H0 : evalinf_expr e m RV a t)","proofString":"eapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (H0 : evalinf_expr e m RV a t) : leftcontext RV RV (fun x : expr => x).","conclusion":"leftcontext RV RV (fun x : expr => x)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (H0 : evalinf_expr e m RV a t)","proofString":"constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (t1 : trace) (m1 : mem) (v1 : val) (t2 : traceinf) (b : bool) (H0 : eval_expression e m a t1 m1 v1) (H1 : bool_val v1 (typeof a) m1 = Some b) (H2 : execinf_stmt e m1 (if b then s1 else s2) t2) : forever_N step lt ge 0%nat (State f (Sifthenelse a s1 s2) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Sifthenelse a s1 s2) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (t1 : trace) (m1 : mem) (v1 : val) (t2 : traceinf) (b : bool) (H0 : eval_expression e m a t1 m1 v1) (H1 : bool_val v1 (typeof a) m1 = Some b) (H2 : execinf_stmt e m1 (if b then s1 else s2) t2)","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright.\neapply step_ifthenelse_2 with (b := b).\nauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (t1 : trace) (m1 : mem) (v1 : val) (t2 : traceinf) (b : bool) (H0 : eval_expression e m a t1 m1 v1) (H1 : bool_val v1 (typeof a) m1 = Some b) (H2 : execinf_stmt e m1 (if b then s1 else s2) t2) : bool_val v1 (typeof a) m1 = Some b.","conclusion":"bool_val v1 (typeof a) m1 = Some b","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s1 s2 : statement) (t1 : trace) (m1 : mem) (v1 : val) (t2 : traceinf) (b : bool) (H0 : eval_expression e m a t1 m1 v1) (H1 : bool_val v1 (typeof a) m1 = Some b) (H2 : execinf_stmt e m1 (if b then s1 else s2) t2)","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (H0 : evalinf_expr e m RV a t) : forever_N step lt ge 0%nat (State f (Sreturn (Some a)) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Sreturn (Some a)) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (H0 : evalinf_expr e m RV a t)","proofString":"eapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (H0 : evalinf_expr e m RV a t) : leftcontext RV RV (fun x : expr => x).","conclusion":"leftcontext RV RV (fun x : expr => x)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (H0 : evalinf_expr e m RV a t)","proofString":"constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (s0 : statement) (H0 : evalinf_expr e m RV a t) : forever_N step lt ge 0%nat (State f (Swhile a s0) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Swhile a s0) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (s0 : statement) (H0 : evalinf_expr e m RV a t)","proofString":"eapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (s0 : statement) (H0 : evalinf_expr e m RV a t) : leftcontext RV RV (fun x : expr => x).","conclusion":"leftcontext RV RV (fun x : expr => x)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (s0 : statement) (H0 : evalinf_expr e m RV a t)","proofString":"constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s0 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : traceinf) (H0 : eval_expression e m a t1 m1 v) (H1 : bool_val v (typeof a) m1 = Some true) (H2 : execinf_stmt e m1 s0 t2) : forever_N step lt ge 0%nat (State f (Swhile a s0) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Swhile a s0) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s0 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : traceinf) (H0 : eval_expression e m a t1 m1 v) (H1 : bool_val v (typeof a) m1 = Some true) (H2 : execinf_stmt e m1 s0 t2)","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_while_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s0 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : traceinf) (H0 : eval_expression e m a t1 m1 v) (H1 : bool_val v (typeof a) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : execinf_stmt e m2 (Swhile a s0) t3) : forever_N step lt ge 0%nat (State f (Swhile a s0) k e m) (t1 *** t2 *** t3).","conclusion":"forever_N step lt ge 0%nat (State f (Swhile a s0) k e m) (t1 *** t2 *** t3)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s0 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : traceinf) (H0 : eval_expression e m a t1 m1 v) (H1 : bool_val v (typeof a) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : execinf_stmt e m2 (Swhile a s0) t3)","proofString":"destruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kwhile2 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_while_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_while; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s0 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : traceinf) (H0 : eval_expression e m a t1 m1 v) (H1 : bool_val v (typeof a) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : execinf_stmt e m2 (Swhile a s0) t3) (S1 : state) (A1 : star step ge (State f s0 (Kwhile2 a s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kwhile2 a s0 k) out1 S1) : forever_N step lt ge 0%nat (State f (Swhile a s0) k e m) (t1 *** t2 *** t3).","conclusion":"forever_N step lt ge 0%nat (State f (Swhile a s0) k e m) (t1 *** t2 *** t3)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (s0 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : traceinf) (H0 : eval_expression e m a t1 m1 v) (H1 : bool_val v (typeof a) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : execinf_stmt e m2 (Swhile a s0) t3) (S1 : state) (A1 : star step ge (State f s0 (Kwhile2 a s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kwhile2 a s0 k) out1 S1)","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_while_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_while; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 : statement) (a : expr) (H0 : execinf_stmt e m s0 t) : forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 : statement) (a : expr) (H0 : execinf_stmt e m s0 t)","proofString":"eapply forever_N_plus.\napply plus_one; right; constructor.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : evalinf_expr e m1 RV a t2) : forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : evalinf_expr e m1 RV a t2)","proofString":"destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_one.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\nreflexivity.\nreflexivity.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : evalinf_expr e m1 RV a t2) (S1 : state) (A1 : star step ge (State f s0 (Kdowhile1 a s0 k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kdowhile1 a s0 k) out1 S1) : forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : evalinf_expr e m1 RV a t2) (S1 : state) (A1 : star step ge (State f s0 (Kdowhile1 a s0 k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kdowhile1 a s0 k) out1 S1)","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_one.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\nreflexivity.\nreflexivity.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : evalinf_expr e m1 RV a t2) (S1 : state) (A1 : star step ge (State f s0 (Kdowhile1 a s0 k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kdowhile1 a s0 k) out1 S1) : leftcontext RV RV (fun x : expr => x).","conclusion":"leftcontext RV RV (fun x : expr => x)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : evalinf_expr e m1 RV a t2) (S1 : state) (A1 : star step ge (State f s0 (Kdowhile1 a s0 k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kdowhile1 a s0 k) out1 S1)","proofString":"constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : trace) (m2 : mem) (v : val) (t3 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : eval_expression e m1 a t2 m2 v) (H3 : bool_val v (typeof a) m2 = Some true) (H4 : execinf_stmt e m2 (Sdowhile a s0) t3) : forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) (t1 *** t2 *** t3).","conclusion":"forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) (t1 *** t2 *** t3)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : trace) (m2 : mem) (v : val) (t3 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : eval_expression e m1 a t2 m2 v) (H3 : bool_val v (typeof a) m2 = Some true) (H4 : execinf_stmt e m2 (Sdowhile a s0) t3)","proofString":"destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_left.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_dowhile_true; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : trace) (m2 : mem) (v : val) (t3 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : eval_expression e m1 a t2 m2 v) (H3 : bool_val v (typeof a) m2 = Some true) (H4 : execinf_stmt e m2 (Sdowhile a s0) t3) (S1 : state) (A1 : star step ge (State f s0 (Kdowhile1 a s0 k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kdowhile1 a s0 k) out1 S1) : forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) (t1 *** t2 *** t3).","conclusion":"forever_N step lt ge 0%nat (State f (Sdowhile a s0) k e m) (t1 *** t2 *** t3)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a : expr) (t1 : trace) (m1 : mem) (out1 : outcome) (t2 : trace) (m2 : mem) (v : val) (t3 : traceinf) (H0 : exec_stmt e m s0 t1 m1 out1) (H1 : out_normal_or_continue out1) (H2 : eval_expression e m1 a t2 m2 v) (H3 : bool_val v (typeof a) m2 = Some true) (H4 : execinf_stmt e m2 (Sdowhile a s0) t3) (S1 : state) (A1 : star step ge (State f s0 (Kdowhile1 a s0 k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kdowhile1 a s0 k) out1 S1)","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_trans.\neexact A1.\neapply star_left.\nright.\ninv H1; inv B1; apply step_skip_or_continue_dowhile; auto.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_dowhile_true; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (H0 : execinf_stmt e m a1 t) : forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (H0 : execinf_stmt e m a1 t)","proofString":"assert (a1 <> Sskip).\nred; intros; subst a1; inv H0.\neapply forever_N_plus.\napply plus_one.\nright.\nconstructor.\nauto.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (H0 : execinf_stmt e m a1 t) : a1 <> Sskip.","conclusion":"a1 <> Sskip","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (H0 : execinf_stmt e m a1 t)","proofString":"red; intros; subst a1; inv H0."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (H0 : execinf_stmt e m a1 t) (H : a1 <> Sskip) : forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (H0 : execinf_stmt e m a1 t) (H : a1 <> Sskip)","proofString":"eapply forever_N_plus.\napply plus_one.\nright.\nconstructor.\nauto.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (H0 : execinf_stmt e m a1 t) (H : a1 <> Sskip) : a1 <> Sskip.","conclusion":"a1 <> Sskip","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (H0 : execinf_stmt e m a1 t) (H : a1 <> Sskip)","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (m1 : mem) (t1 : trace) (t2 : traceinf) (H0 : exec_stmt e m a1 t1 m1 Out_normal) (H1 : a1 <> Sskip) (H2 : execinf_stmt e m1 (Sfor Sskip a2 a3 s0) t2) : forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (m1 : mem) (t1 : trace) (t2 : traceinf) (H0 : exec_stmt e m a1 t1 m1 Out_normal) (H1 : a1 <> Sskip) (H2 : execinf_stmt e m1 (Sfor Sskip a2 a3 s0) t2)","proofString":"destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq (Sfor Sskip a2 a3 s0) k)) as [S1 [A1 B1]]; auto.\ninv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\nauto.\neapply star_trans.\neexact A1.\napply star_one.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (m1 : mem) (t1 : trace) (t2 : traceinf) (H0 : exec_stmt e m a1 t1 m1 Out_normal) (H1 : a1 <> Sskip) (H2 : execinf_stmt e m1 (Sfor Sskip a2 a3 s0) t2) (S1 : state) (A1 : star step ge (State f a1 (Kseq (Sfor Sskip a2 a3 s0) k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kseq (Sfor Sskip a2 a3 s0) k) Out_normal S1) : forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (m1 : mem) (t1 : trace) (t2 : traceinf) (H0 : exec_stmt e m a1 t1 m1 Out_normal) (H1 : a1 <> Sskip) (H2 : execinf_stmt e m1 (Sfor Sskip a2 a3 s0) t2) (S1 : state) (A1 : star step ge (State f a1 (Kseq (Sfor Sskip a2 a3 s0) k) e m) t1 S1) (B1 : outcome_state_match e m1 f (Kseq (Sfor Sskip a2 a3 s0) k) Out_normal S1)","proofString":"inv B1.\neapply forever_N_plus.\neapply plus_left.\nright; constructor.\nauto.\neapply star_trans.\neexact A1.\napply star_one.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (m1 : mem) (t1 : trace) (t2 : traceinf) (H0 : exec_stmt e m a1 t1 m1 Out_normal) (H1 : a1 <> Sskip) (H2 : execinf_stmt e m1 (Sfor Sskip a2 a3 s0) t2) (A1 : star step ge (State f a1 (Kseq (Sfor Sskip a2 a3 s0) k) e m) t1\n  (State f Sskip (Kseq (Sfor Sskip a2 a3 s0) k) e m1)) : forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor a1 a2 a3 s0) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (m1 : mem) (t1 : trace) (t2 : traceinf) (H0 : exec_stmt e m a1 t1 m1 Out_normal) (H1 : a1 <> Sskip) (H2 : execinf_stmt e m1 (Sfor Sskip a2 a3 s0) t2) (A1 : star step ge (State f a1 (Kseq (Sfor Sskip a2 a3 s0) k) e m) t1\n  (State f Sskip (Kseq (Sfor Sskip a2 a3 s0) k) e m1))","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; constructor.\nauto.\neapply star_trans.\neexact A1.\napply star_one.\nright; constructor.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (m1 : mem) (t1 : trace) (t2 : traceinf) (H0 : exec_stmt e m a1 t1 m1 Out_normal) (H1 : a1 <> Sskip) (H2 : execinf_stmt e m1 (Sfor Sskip a2 a3 s0) t2) (A1 : star step ge (State f a1 (Kseq (Sfor Sskip a2 a3 s0) k) e m) t1\n  (State f Sskip (Kseq (Sfor Sskip a2 a3 s0) k) e m1)) : a1 <> Sskip.","conclusion":"a1 <> Sskip","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 a1 : statement) (a2 : expr) (a3 : statement) (m1 : mem) (t1 : trace) (t2 : traceinf) (H0 : exec_stmt e m a1 t1 m1 Out_normal) (H1 : a1 <> Sskip) (H2 : execinf_stmt e m1 (Sfor Sskip a2 a3 s0) t2) (A1 : star step ge (State f a1 (Kseq (Sfor Sskip a2 a3 s0) k) e m) t1\n  (State f Sskip (Kseq (Sfor Sskip a2 a3 s0) k) e m1))","proofString":"auto."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (H0 : evalinf_expr e m RV a2 t) : forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (H0 : evalinf_expr e m RV a2 t)","proofString":"eapply forever_N_plus.\napply plus_one; right; apply step_for.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (H0 : evalinf_expr e m RV a2 t) : leftcontext RV RV (fun x : expr => x).","conclusion":"leftcontext RV RV (fun x : expr => x)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (H0 : evalinf_expr e m RV a2 t)","proofString":"constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : execinf_stmt e m1 s0 t2) : forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : execinf_stmt e m1 s0 t2)","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; apply step_for_true; auto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : execinf_stmt e m2 a3 t3) : forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : execinf_stmt e m2 a3 t3)","proofString":"destruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_for3; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : execinf_stmt e m2 a3 t3) (S1 : state) (A1 : star step ge (State f s0 (Kfor3 a2 a3 s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kfor3 a2 a3 s0 k) out1 S1) : forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : execinf_stmt e m2 a3 t3) (S1 : state) (A1 : star step ge (State f s0 (Kfor3 a2 a3 s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kfor3 a2 a3 s0 k) out1 S1)","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\ninv H3; inv B1; apply star_one; right; apply step_skip_or_continue_for3; auto.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : trace) (m3 : mem) (t4 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : exec_stmt e m2 a3 t3 m3 Out_normal) (H5 : execinf_stmt e m3 (Sfor Sskip a2 a3 s0) t4) : forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3 *** t4).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3 *** t4)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : trace) (m3 : mem) (t4 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : exec_stmt e m2 a3 t3 m3 Out_normal) (H5 : execinf_stmt e m3 (Sfor Sskip a2 a3 s0) t4)","proofString":"destruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.\ndestruct (exec_stmt_to_steps _ _ _ _ _ _ H4 f (Kfor4 a2 a3 s0 k)) as [S2 [A2 B2]]; auto.\ninv B2.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H3; inv B1; right; apply step_skip_or_continue_for3; auto.\neapply star_right.\neexact A2.\nright; constructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : trace) (m3 : mem) (t4 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : exec_stmt e m2 a3 t3 m3 Out_normal) (H5 : execinf_stmt e m3 (Sfor Sskip a2 a3 s0) t4) (S1 : state) (A1 : star step ge (State f s0 (Kfor3 a2 a3 s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kfor3 a2 a3 s0 k) out1 S1) : forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3 *** t4).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3 *** t4)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : trace) (m3 : mem) (t4 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : exec_stmt e m2 a3 t3 m3 Out_normal) (H5 : execinf_stmt e m3 (Sfor Sskip a2 a3 s0) t4) (S1 : state) (A1 : star step ge (State f s0 (Kfor3 a2 a3 s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kfor3 a2 a3 s0 k) out1 S1)","proofString":"destruct (exec_stmt_to_steps _ _ _ _ _ _ H4 f (Kfor4 a2 a3 s0 k)) as [S2 [A2 B2]]; auto.\ninv B2.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H3; inv B1; right; apply step_skip_or_continue_for3; auto.\neapply star_right.\neexact A2.\nright; constructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : trace) (m3 : mem) (t4 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : exec_stmt e m2 a3 t3 m3 Out_normal) (H5 : execinf_stmt e m3 (Sfor Sskip a2 a3 s0) t4) (S1 : state) (A1 : star step ge (State f s0 (Kfor3 a2 a3 s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kfor3 a2 a3 s0 k) out1 S1) (S2 : state) (A2 : star step ge (State f a3 (Kfor4 a2 a3 s0 k) e m2) t3 S2) (B2 : outcome_state_match e m3 f (Kfor4 a2 a3 s0 k) Out_normal S2) : forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3 *** t4).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3 *** t4)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : trace) (m3 : mem) (t4 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : exec_stmt e m2 a3 t3 m3 Out_normal) (H5 : execinf_stmt e m3 (Sfor Sskip a2 a3 s0) t4) (S1 : state) (A1 : star step ge (State f s0 (Kfor3 a2 a3 s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kfor3 a2 a3 s0 k) out1 S1) (S2 : state) (A2 : star step ge (State f a3 (Kfor4 a2 a3 s0 k) e m2) t3 S2) (B2 : outcome_state_match e m3 f (Kfor4 a2 a3 s0 k) Out_normal S2)","proofString":"inv B2.\neapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H3; inv B1; right; apply step_skip_or_continue_for3; auto.\neapply star_right.\neexact A2.\nright; constructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : trace) (m3 : mem) (t4 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : exec_stmt e m2 a3 t3 m3 Out_normal) (H5 : execinf_stmt e m3 (Sfor Sskip a2 a3 s0) t4) (S1 : state) (A1 : star step ge (State f s0 (Kfor3 a2 a3 s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kfor3 a2 a3 s0 k) out1 S1) (A2 : star step ge (State f a3 (Kfor4 a2 a3 s0 k) e m2) t3\n  (State f Sskip (Kfor4 a2 a3 s0 k) e m3)) : forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3 *** t4).","conclusion":"forever_N step lt ge 0%nat (State f (Sfor Sskip a2 a3 s0) k e m)\n  (t1 *** t2 *** t3 *** t4)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a) (ExprState f0 (C a) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (s0 : statement) (a2 : expr) (a3 : statement) (t1 : trace) (m1 : mem) (v : val) (t2 : trace) (m2 : mem) (out1 : outcome) (t3 : trace) (m3 : mem) (t4 : traceinf) (H0 : eval_expression e m a2 t1 m1 v) (H1 : bool_val v (typeof a2) m1 = Some true) (H2 : exec_stmt e m1 s0 t2 m2 out1) (H3 : out_normal_or_continue out1) (H4 : exec_stmt e m2 a3 t3 m3 Out_normal) (H5 : execinf_stmt e m3 (Sfor Sskip a2 a3 s0) t4) (S1 : state) (A1 : star step ge (State f s0 (Kfor3 a2 a3 s0 k) e m1) t2 S1) (B1 : outcome_state_match e m2 f (Kfor3 a2 a3 s0 k) out1 S1) (A2 : star step ge (State f a3 (Kfor4 a2 a3 s0 k) e m2) t3\n  (State f Sskip (Kfor4 a2 a3 s0 k) e m3))","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; apply step_for.\neapply star_trans.\neapply eval_expression_to_steps; eauto.\neapply star_left.\nright; apply step_for_true; auto.\neapply star_trans.\neexact A1.\neapply star_left.\ninv H3; inv B1; right; apply step_skip_or_continue_for3; auto.\neapply star_right.\neexact A2.\nright; constructor.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (sl : labeled_statements) (H0 : evalinf_expr e m RV a t) : forever_N step lt ge 0%nat (State f (Sswitch a sl) k e m) t.","conclusion":"forever_N step lt ge 0%nat (State f (Sswitch a sl) k e m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (sl : labeled_statements) (H0 : evalinf_expr e m RV a t)","proofString":"eapply forever_N_plus.\napply plus_one; right; constructor.\neapply COE with (C := fun x => x); eauto.\nconstructor.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (sl : labeled_statements) (H0 : evalinf_expr e m RV a t) : leftcontext RV RV (fun x : expr => x).","conclusion":"leftcontext RV RV (fun x : expr => x)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t0 ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t0 : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t0 ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t0) (e : env) (m : mem) (t : traceinf) (f : function) (k : cont) (a : expr) (sl : labeled_statements) (H0 : evalinf_expr e m RV a t)","proofString":"constructor."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (sl : labeled_statements) (t1 : trace) (m1 : mem) (v : val) (n : Z) (t2 : traceinf) (H0 : eval_expression e m a t1 m1 v) (H1 : sem_switch_arg v (typeof a) = Some n) (H2 : execinf_stmt e m1 (seq_of_labeled_statement (select_switch n sl)) t2) : forever_N step lt ge 0%nat (State f (Sswitch a sl) k e m) (t1 *** t2).","conclusion":"forever_N step lt ge 0%nat (State f (Sswitch a sl) k e m) (t1 *** t2)","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args : list val) (t : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k0 m0) t) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t -> forever_N step lt ge 0%nat (State f0 s k0 e0 m0) t) (COE : forall (e0 : env) (m0 : mem) (K : kind) (a0 : expr) \n  (t : traceinf) (C : expr -> expr) (f0 : function) \n  (k0 : cont),\nevalinf_expr e0 m0 K a0 t ->\nleftcontext K RV C ->\nforever_N step lt ge (esize a0) (ExprState f0 (C a0) k0 e0 m0) t) (e : env) (m : mem) (f : function) (k : cont) (a : expr) (sl : labeled_statements) (t1 : trace) (m1 : mem) (v : val) (n : Z) (t2 : traceinf) (H0 : eval_expression e m a t1 m1 v) (H1 : sem_switch_arg v (typeof a) = Some n) (H2 : execinf_stmt e m1 (seq_of_labeled_statement (select_switch n sl)) t2)","proofString":"eapply forever_N_plus.\neapply plus_left.\nright; constructor.\neapply star_right.\neapply eval_expression_to_steps; eauto.\nright; constructor.\neauto.\nreflexivity.\nreflexivity.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t) : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t.","conclusion":"forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t","hypotheses":"(COF : forall (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont),\nevalinf_funcall m fd args t ->\nforever_N step lt ge 0%nat (Callstate fd args k m) t) (COS : forall (e : env) (m : mem) (s : statement) (t : traceinf) \n  (f : function) (k : cont),\nexecinf_stmt e m s t -> forever_N step lt ge 0%nat (State f s k e m) t)","proofString":"intros.\ninv H.\neapply forever_N_plus.\napply plus_one.\nright; econstructor; eauto.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd0 : fundef) (args0 : list val) \n  (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args0 t0 ->\nforever_N step lt ge 0%nat (Callstate fd0 args0 k0 m0) t0) (COS : forall (e : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f : function) (k0 : cont),\nexecinf_stmt e m0 s t0 -> forever_N step lt ge 0%nat (State f s k0 e m0) t0) (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont) (H : evalinf_funcall m fd args t) : forever_N step lt ge 0%nat (Callstate fd args k m) t.","conclusion":"forever_N step lt ge 0%nat (Callstate fd args k m) t","hypotheses":"(COF : forall (m0 : mem) (fd0 : fundef) (args0 : list val) \n  (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd0 args0 t0 ->\nforever_N step lt ge 0%nat (Callstate fd0 args0 k0 m0) t0) (COS : forall (e : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f : function) (k0 : cont),\nexecinf_stmt e m0 s t0 -> forever_N step lt ge 0%nat (State f s k0 e m0) t0) (m : mem) (fd : fundef) (args : list val) (t : traceinf) (k : cont) (H : evalinf_funcall m fd args t)","proofString":"inv H.\neapply forever_N_plus.\napply plus_one.\nright; econstructor; eauto.\neapply COS; eauto.\ntraceEq."},{"statement":"(COF : forall (m0 : mem) (fd : fundef) (args0 : list val) \n  (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args0 t0 ->\nforever_N step lt ge 0%nat (Callstate fd args0 k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (m : mem) (args : list val) (t : traceinf) (k : cont) (f : function) (e : env) (m1 m2 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H2 : bind_parameters ge e m1 (fn_params f) args m2) (H3 : execinf_stmt e m2 (fn_body f) t) : forever_N step lt ge 0%nat (Callstate (Internal f) args k m) t.","conclusion":"forever_N step lt ge 0%nat (Callstate (Internal f) args k m) t","hypotheses":"(COF : forall (m0 : mem) (fd : fundef) (args0 : list val) \n  (t0 : traceinf) (k0 : cont),\nevalinf_funcall m0 fd args0 t0 ->\nforever_N step lt ge 0%nat (Callstate fd args0 k0 m0) t0) (COS : forall (e0 : env) (m0 : mem) (s : statement) (t0 : traceinf) \n  (f0 : function) (k0 : cont),\nexecinf_stmt e0 m0 s t0 ->\nforever_N step lt ge 0%nat (State f0 s k0 e0 m0) t0) (m : mem) (args : list val) (t : traceinf) (k : cont) (f : function) (e : env) (m1 m2 : mem) (H0 : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H1 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H2 : bind_parameters ge e m1 (fn_params f) args m2) (H3 : execinf_stmt e m2 (fn_body f) t)","proofString":"eapply forever_N_plus.\napply plus_one.\nright; econstructor; eauto.\neapply COS; eauto.\ntraceEq."},{"statement":"(p : program) (t : trace) (r : int) (H : bigstep_terminates (bigstep_semantics p) t r) : exists s1 s2 : Smallstep.state (semantics p),\n  Smallstep.initial_state (semantics p) s1 /\\\n  Star (semantics p) s1 t s2 /\\ Smallstep.final_state (semantics p) s2 r.","conclusion":"exists s1 s2 : Smallstep.state (semantics p),\n  Smallstep.initial_state (semantics p) s1 /\\\n  Star (semantics p) s1 t s2 /\\ Smallstep.final_state (semantics p) s2 r","hypotheses":"(p : program) (t : trace) (r : int) (H : bigstep_terminates (bigstep_semantics p) t r)","proofString":"inv H.\neconstructor; econstructor.\nsplit.\neconstructor; eauto.\nsplit.\napply eval_funcall_to_steps.\neauto.\nred; auto.\neconstructor."},{"statement":"(p : program) (t : trace) (r : int) (b : block) (f : fundef) (m0 m1 : mem) (ge : genv) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : eval_funcall ge m0 f nil t m1 (Vint r)) : is_call_cont Kstop.","conclusion":"is_call_cont Kstop","hypotheses":"(p : program) (t : trace) (r : int) (b : block) (f : fundef) (m0 m1 : mem) (ge : genv) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : eval_funcall ge m0 f nil t m1 (Vint r))","proofString":"red; auto."},{"statement":"(p : program) (T : traceinf) (H : bigstep_diverges (bigstep_semantics p) T) : exists s1 : Smallstep.state (semantics p),\n  Smallstep.initial_state (semantics p) s1 /\\\n  forever (Smallstep.step (semantics p)) (Smallstep.globalenv (semantics p))\n    s1 T.","conclusion":"exists s1 : Smallstep.state (semantics p),\n  Smallstep.initial_state (semantics p) s1 /\\\n  forever (Smallstep.step (semantics p)) (Smallstep.globalenv (semantics p))\n    s1 T","hypotheses":"(p : program) (T : traceinf) (H : bigstep_diverges (bigstep_semantics p) T)","proofString":"inv H.\neconstructor.\nsplit.\neconstructor; eauto.\neapply forever_N_forever with (order := lt).\napply lt_wf.\neapply evalinf_funcall_steps; eauto."},{"statement":"(p : program) (T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge : genv) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge m0 f nil T) : well_founded lt.","conclusion":"well_founded lt","hypotheses":"(p : program) (T : traceinf) (b : block) (f : fundef) (m0 : mem) (ge : genv) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (H4 : evalinf_funcall ge m0 f nil T)","proofString":"apply lt_wf."}]}