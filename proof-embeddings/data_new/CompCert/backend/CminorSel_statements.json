{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/CminorSel.v","fileSamples":[{"statement":"(le : letenv) (v : val) (n : nat) (v0 : val) (H : nth_error le n = Some v0) (H0 : (0 > n)%nat) : nth_error (v :: le) n = Some v0.","conclusion":"nth_error (v :: le) n = Some v0","hypotheses":"(le : letenv) (v : val) (n : nat) (v0 : val) (H : nth_error le n = Some v0) (H0 : (0 > n)%nat)","proofString":"extlia."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p > n0)%nat -> nth_error le' n0 = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) n = Some v0) (H1 : (S p > n)%nat) : nth_error (v :: le') n = Some v0.","conclusion":"nth_error (v :: le') n = Some v0","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p > n0)%nat -> nth_error le' n0 = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) n = Some v0) (H1 : (S p > n)%nat)","proofString":"destruct n; simpl; simpl in H0.\nauto.\napply IHinsert_lenv.\nauto.\nlia."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n : nat) (v1 : val),\nnth_error le n = Some v1 -> (p > n)%nat -> nth_error le' n = Some v1) (v0 : val) (H0 : Some v = Some v0) (H1 : (S p > 0)%nat) : Some v = Some v0.","conclusion":"Some v = Some v0","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n : nat) (v1 : val),\nnth_error le n = Some v1 -> (p > n)%nat -> nth_error le' n = Some v1) (v0 : val) (H0 : Some v = Some v0) (H1 : (S p > 0)%nat)","proofString":"auto."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p > n0)%nat -> nth_error le' n0 = Some v1) (n : nat) (v0 : val) (H0 : nth_error le n = Some v0) (H1 : (S p > S n)%nat) : nth_error le' n = Some v0.","conclusion":"nth_error le' n = Some v0","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p > n0)%nat -> nth_error le' n0 = Some v1) (n : nat) (v0 : val) (H0 : nth_error le n = Some v0) (H1 : (S p > S n)%nat)","proofString":"apply IHinsert_lenv.\nauto.\nlia."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p > n0)%nat -> nth_error le' n0 = Some v1) (n : nat) (v0 : val) (H0 : nth_error le n = Some v0) (H1 : (S p > S n)%nat) : nth_error le n = Some v0.","conclusion":"nth_error le n = Some v0","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p > n0)%nat -> nth_error le' n0 = Some v1) (n : nat) (v0 : val) (H0 : nth_error le n = Some v0) (H1 : (S p > S n)%nat)","proofString":"auto."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p > n0)%nat -> nth_error le' n0 = Some v1) (n : nat) (v0 : val) (H0 : nth_error le n = Some v0) (H1 : (S p > S n)%nat) : (p > n)%nat.","conclusion":"(p > n)%nat","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p > n0)%nat -> nth_error le' n0 = Some v1) (n : nat) (v0 : val) (H0 : nth_error le n = Some v0) (H1 : (S p > S n)%nat)","proofString":"lia."},{"statement":"(le : letenv) (v : val) (n : nat) (v0 : val) (H : nth_error le n = Some v0) (H0 : (0 <= n)%nat) : nth_error (v :: le) (S n) = Some v0.","conclusion":"nth_error (v :: le) (S n) = Some v0","hypotheses":"(le : letenv) (v : val) (n : nat) (v0 : val) (H : nth_error le n = Some v0) (H0 : (0 <= n)%nat)","proofString":"simpl.\nassumption."},{"statement":"(le : letenv) (v : val) (n : nat) (v0 : val) (H : nth_error le n = Some v0) (H0 : (0 <= n)%nat) : nth_error le n = Some v0.","conclusion":"nth_error le n = Some v0","hypotheses":"(le : letenv) (v : val) (n : nat) (v0 : val) (H : nth_error le n = Some v0) (H0 : (0 <= n)%nat)","proofString":"assumption."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) n = Some v0) (H1 : (S p <= n)%nat) : nth_error (v :: le') (S n) = Some v0.","conclusion":"nth_error (v :: le') (S n) = Some v0","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) n = Some v0) (H1 : (S p <= n)%nat)","proofString":"simpl.\ndestruct n.\nextlia.\napply IHinsert_lenv.\nexact H0.\nlia."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) n = Some v0) (H1 : (S p <= n)%nat) : nth_error le' n = Some v0.","conclusion":"nth_error le' n = Some v0","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) n = Some v0) (H1 : (S p <= n)%nat)","proofString":"destruct n.\nextlia.\napply IHinsert_lenv.\nexact H0.\nlia."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n : nat) (v1 : val),\nnth_error le n = Some v1 -> (p <= n)%nat -> nth_error le' (S n) = Some v1) (v0 : val) (H0 : nth_error (v :: le) 0 = Some v0) (H1 : (S p <= 0)%nat) : nth_error le' 0 = Some v0.","conclusion":"nth_error le' 0 = Some v0","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n : nat) (v1 : val),\nnth_error le n = Some v1 -> (p <= n)%nat -> nth_error le' (S n) = Some v1) (v0 : val) (H0 : nth_error (v :: le) 0 = Some v0) (H1 : (S p <= 0)%nat)","proofString":"extlia."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) (S n) = Some v0) (H1 : (S p <= S n)%nat) : nth_error le' (S n) = Some v0.","conclusion":"nth_error le' (S n) = Some v0","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) (S n) = Some v0) (H1 : (S p <= S n)%nat)","proofString":"apply IHinsert_lenv.\nexact H0.\nlia."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) (S n) = Some v0) (H1 : (S p <= S n)%nat) : nth_error le n = Some v0.","conclusion":"nth_error le n = Some v0","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) (S n) = Some v0) (H1 : (S p <= S n)%nat)","proofString":"exact H0."},{"statement":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) (S n) = Some v0) (H1 : (S p <= S n)%nat) : (p <= n)%nat.","conclusion":"(p <= n)%nat","hypotheses":"(le : letenv) (p : nat) (w : val) (le' : letenv) (v : val) (H : insert_lenv le p w le') (IHinsert_lenv : forall (n0 : nat) (v1 : val),\nnth_error le n0 = Some v1 -> (p <= n0)%nat -> nth_error le' (S n0) = Some v1) (n : nat) (v0 : val) (H0 : nth_error (v :: le) (S n) = Some v0) (H1 : (S p <= S n)%nat)","proofString":"lia."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) : forall (le : letenv) (a : expr) (v : val),\neval_expr ge sp e m le a v ->\nforall (p : nat) (le' : letenv),\ninsert_lenv le p w le' -> eval_expr ge sp e m le' (lift_expr p a) v.","conclusion":"forall (le : letenv) (a : expr) (v : val),\neval_expr ge sp e m le a v ->\nforall (p : nat) (le' : letenv),\ninsert_lenv le p w le' -> eval_expr ge sp e m le' (lift_expr p a) v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val)","proofString":"apply (eval_expr_ind3 ge sp e m    (fun le a v =>      forall p le', insert_lenv le p w le' ->      eval_expr ge sp e m le' (lift_expr p a) v)    (fun le al vl =>      forall p le', insert_lenv le p w le' ->      eval_exprlist ge sp e m le' (lift_exprlist p al) vl)    (fun le a b =>      forall p le', insert_lenv le p w le' ->      eval_condexpr ge sp e m le' (lift_condexpr p a) b));  simpl; intros; eauto with evalexpr.\neapply eval_Econdition; eauto.\ndestruct va; eauto.\neapply eval_Elet.\neauto.\napply H2.\napply insert_lenv_S; auto.\ncase (le_gt_dec p n); intro.\napply eval_Eletvar.\neapply insert_lenv_lookup2; eauto.\napply eval_Eletvar.\neapply insert_lenv_lookup1; eauto.\neapply eval_CEcondition; eauto.\ndestruct va; eauto.\neapply eval_CElet; eauto.\napply H2.\nconstructor; auto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : condexpr) (b c : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 a) va) (H1 : eval_expr ge sp e m le (if va then b else c) v) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_expr ge sp e m le'0 (lift_expr p0 (if va then b else c)) v) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le') : eval_expr ge sp e m le'\n  (Econdition (lift_condexpr p a) (lift_expr p b) (lift_expr p c)) v.","conclusion":"eval_expr ge sp e m le'\n  (Econdition (lift_condexpr p a) (lift_expr p b) (lift_expr p c)) v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : condexpr) (b c : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 a) va) (H1 : eval_expr ge sp e m le (if va then b else c) v) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_expr ge sp e m le'0 (lift_expr p0 (if va then b else c)) v) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le')","proofString":"eapply eval_Econdition; eauto.\ndestruct va; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : condexpr) (b c : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 a) va) (H1 : eval_expr ge sp e m le (if va then b else c) v) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_expr ge sp e m le'0 (lift_expr p0 (if va then b else c)) v) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le') : eval_expr ge sp e m le' (if va then lift_expr p b else lift_expr p c) v.","conclusion":"eval_expr ge sp e m le' (if va then lift_expr p b else lift_expr p c) v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : condexpr) (b c : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 a) va) (H1 : eval_expr ge sp e m le (if va then b else c) v) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_expr ge sp e m le'0 (lift_expr p0 (if va then b else c)) v) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le')","proofString":"destruct va; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a b : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_expr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_expr ge sp e m le'0 (lift_expr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le') : eval_expr ge sp e m le' (Elet (lift_expr p a) (lift_expr (S p) b)) v2.","conclusion":"eval_expr ge sp e m le' (Elet (lift_expr p a) (lift_expr (S p) b)) v2","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a b : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_expr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_expr ge sp e m le'0 (lift_expr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le')","proofString":"eapply eval_Elet.\neauto.\napply H2.\napply insert_lenv_S; auto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a b : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_expr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_expr ge sp e m le'0 (lift_expr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le') : insert_lenv (v1 :: le) (S p) w (v1 :: le').","conclusion":"insert_lenv (v1 :: le) (S p) w (v1 :: le')","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a b : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_expr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_expr ge sp e m le'0 (lift_expr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le')","proofString":"apply insert_lenv_S; auto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le') : eval_expr ge sp e m le' (if le_gt_dec p n then Eletvar (S n) else Eletvar n)\n  v.","conclusion":"eval_expr ge sp e m le' (if le_gt_dec p n then Eletvar (S n) else Eletvar n)\n  v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le')","proofString":"case (le_gt_dec p n); intro.\napply eval_Eletvar.\neapply insert_lenv_lookup2; eauto.\napply eval_Eletvar.\neapply insert_lenv_lookup1; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le') (l : (p <= n)%nat) : eval_expr ge sp e m le' (Eletvar (S n)) v.","conclusion":"eval_expr ge sp e m le' (Eletvar (S n)) v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le') (l : (p <= n)%nat)","proofString":"apply eval_Eletvar.\neapply insert_lenv_lookup2; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le') (l : (p <= n)%nat) : nth_error le' (S n) = Some v.","conclusion":"nth_error le' (S n) = Some v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le') (l : (p <= n)%nat)","proofString":"eapply insert_lenv_lookup2; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le') (g : (p > n)%nat) : eval_expr ge sp e m le' (Eletvar n) v.","conclusion":"eval_expr ge sp e m le' (Eletvar n) v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le') (g : (p > n)%nat)","proofString":"apply eval_Eletvar.\neapply insert_lenv_lookup1; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le') (g : (p > n)%nat) : nth_error le' n = Some v.","conclusion":"nth_error le' n = Some v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (p : nat) (le' : letenv) (H0 : insert_lenv le p w le') (g : (p > n)%nat)","proofString":"eapply insert_lenv_lookup1; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 a) va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 (if va then b else c)) v) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le') : eval_condexpr ge sp e m le'\n  (CEcondition (lift_condexpr p a) (lift_condexpr p b) (lift_condexpr p c)) v.","conclusion":"eval_condexpr ge sp e m le'\n  (CEcondition (lift_condexpr p a) (lift_condexpr p b) (lift_condexpr p c)) v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 a) va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 (if va then b else c)) v) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le')","proofString":"eapply eval_CEcondition; eauto.\ndestruct va; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 a) va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 (if va then b else c)) v) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le') : eval_condexpr ge sp e m le'\n  (if va then lift_condexpr p b else lift_condexpr p c) v.","conclusion":"eval_condexpr ge sp e m le'\n  (if va then lift_condexpr p b else lift_condexpr p c) v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 a) va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 (if va then b else c)) v) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le')","proofString":"destruct va; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le') : eval_condexpr ge sp e m le' (CElet (lift_expr p a) (lift_condexpr (S p) b))\n  v2.","conclusion":"eval_condexpr ge sp e m le' (CElet (lift_expr p a) (lift_condexpr (S p) b))\n  v2","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le')","proofString":"eapply eval_CElet; eauto.\napply H2.\nconstructor; auto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le') : eval_condexpr ge sp e m (v1 :: le') (lift_condexpr (S p) b) v2.","conclusion":"eval_condexpr ge sp e m (v1 :: le') (lift_condexpr (S p) b) v2","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le')","proofString":"apply H2.\nconstructor; auto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le') : insert_lenv (v1 :: le) (S p) w (v1 :: le').","conclusion":"insert_lenv (v1 :: le) (S p) w (v1 :: le')","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (w : val) (le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv le p0 w le'0 -> eval_expr ge sp e m le'0 (lift_expr p0 a) v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : forall (p0 : nat) (le'0 : letenv),\ninsert_lenv (v1 :: le) p0 w le'0 ->\neval_condexpr ge sp e m le'0 (lift_condexpr p0 b) v2) (p : nat) (le' : letenv) (H3 : insert_lenv le p w le')","proofString":"constructor; auto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : expr) (v w : val) (H : eval_expr ge sp e m le a v) : eval_expr ge sp e m (w :: le) (lift a) v.","conclusion":"eval_expr ge sp e m (w :: le) (lift a) v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : expr) (v w : val) (H : eval_expr ge sp e m le a v)","proofString":"unfold lift.\neapply eval_lift_expr.\neexact H.\napply insert_lenv_0."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : expr) (v w : val) (H : eval_expr ge sp e m le a v) : eval_expr ge sp e m (w :: le) (lift_expr 0 a) v.","conclusion":"eval_expr ge sp e m (w :: le) (lift_expr 0 a) v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : expr) (v w : val) (H : eval_expr ge sp e m le a v)","proofString":"eapply eval_lift_expr.\neexact H.\napply insert_lenv_0."}]}