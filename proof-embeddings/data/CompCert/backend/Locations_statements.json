{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Locations.v","fileSamples":[{"statement":"(ty : typ) : (typealign ty | typesize ty).","proofString":"exists (typesize ty / typealign ty); destruct ty; reflexivity."},{"statement":"(p q : loc) (r r0 : mreg) : {r = r0} + {r <> r0}.","proofString":"apply mreg_eq."},{"statement":"(p q : loc) (sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (a : sl = sl0) (a0 : pos = pos0) : {ty = ty0} + {ty <> ty0}.","proofString":"apply typ_eq."},{"statement":"(p q : loc) (sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (a : sl = sl0) : {pos = pos0} + {pos <> pos0}.","proofString":"apply zeq."},{"statement":"(p q : loc) (sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) : {sl = sl0} + {sl <> sl0}.","proofString":"apply slot_eq."},{"statement":"(sl : slot) (pos : Z) (ty : typ) : ~ (sl <> sl \\/ pos + typesize ty <= pos \\/ pos + typesize ty <= pos).","proofString":"red; intros.\ndestruct H; auto.\ngeneralize (typesize_pos ty); lia."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : sl <> sl \\/ pos + typesize ty <= pos \\/ pos + typesize ty <= pos) : False.","proofString":"destruct H; auto.\ngeneralize (typesize_pos ty); lia."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : pos + typesize ty <= pos \\/ pos + typesize ty <= pos) : False.","proofString":"generalize (typesize_pos ty); lia."},{"statement":"(l1 l2 : loc) (H : diff l1 l2) (H0 : l1 = l2) : False.","proofString":"subst l2.\nelim (same_not_diff l1 H)."},{"statement":"(l1 : loc) (H : diff l1 l1) : False.","proofString":"elim (same_not_diff l1 H)."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) : sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos ->\nsl0 <> sl \\/ pos0 + typesize ty0 <= pos \\/ pos + typesize ty <= pos0.","proofString":"intuition."},{"statement":"(l1 l2 : loc) : {diff l1 l2} + {~ diff l1 l2}.","proofString":"destruct l1; destruct l2; simpl.\ndestruct (mreg_eq r r0).\nright; tauto.\nleft; auto.\nleft; auto.\nleft; auto.\ndestruct (slot_eq sl sl0).\ndestruct (zle (pos + typesize ty) pos0).\nleft; auto.\ndestruct (zle (pos0 + typesize ty0) pos).\nleft; auto.\nright; red; intros [P | [P | P]].\ncongruence.\nlia.\nlia.\nleft; auto."},{"statement":"(r r0 : mreg) : {r <> r0} + {~ r <> r0}.","proofString":"destruct (mreg_eq r r0).\nright; tauto.\nleft; auto."},{"statement":"(r r0 : mreg) (e : r = r0) : {r <> r0} + {~ r <> r0}.","proofString":"right; tauto."},{"statement":"(r r0 : mreg) (n : r <> r0) : {r <> r0} + {~ r <> r0}.","proofString":"left; auto."},{"statement":"(r : mreg) (sl : slot) (pos : Z) (ty : typ) : {True} + {~ True}.","proofString":"left; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (r : mreg) : {True} + {~ True}.","proofString":"left; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) : {sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos} +\n{~ (sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos)}.","proofString":"destruct (slot_eq sl sl0).\ndestruct (zle (pos + typesize ty) pos0).\nleft; auto.\ndestruct (zle (pos0 + typesize ty0) pos).\nleft; auto.\nright; red; intros [P | [P | P]].\ncongruence.\nlia.\nlia.\nleft; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : sl = sl0) : {sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos} +\n{~ (sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos)}.","proofString":"destruct (zle (pos + typesize ty) pos0).\nleft; auto.\ndestruct (zle (pos0 + typesize ty0) pos).\nleft; auto.\nright; red; intros [P | [P | P]].\ncongruence.\nlia.\nlia."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : sl = sl0) (l : pos + typesize ty <= pos0) : {sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos} +\n{~ (sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos)}.","proofString":"left; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : sl = sl0) (g : pos + typesize ty > pos0) : {sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos} +\n{~ (sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos)}.","proofString":"destruct (zle (pos0 + typesize ty0) pos).\nleft; auto.\nright; red; intros [P | [P | P]].\ncongruence.\nlia.\nlia."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : sl = sl0) (g : pos + typesize ty > pos0) (l : pos0 + typesize ty0 <= pos) : {sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos} +\n{~ (sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos)}.","proofString":"left; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : sl = sl0) (g : pos + typesize ty > pos0) (g0 : pos0 + typesize ty0 > pos) : {sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos} +\n{~ (sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos)}.","proofString":"right; red; intros [P | [P | P]].\ncongruence.\nlia.\nlia."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : sl = sl0) (g : pos + typesize ty > pos0) (g0 : pos0 + typesize ty0 > pos) (P : sl <> sl0) : False.","proofString":"congruence."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : sl = sl0) (g : pos + typesize ty > pos0) (g0 : pos0 + typesize ty0 > pos) (P : pos + typesize ty <= pos0) : False.","proofString":"lia."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : sl = sl0) (g : pos + typesize ty > pos0) (g0 : pos0 + typesize ty0 > pos) (P : pos0 + typesize ty0 <= pos) : False.","proofString":"lia."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (n : sl <> sl0) : {sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos} +\n{~ (sl <> sl0 \\/ pos + typesize ty <= pos0 \\/ pos0 + typesize ty0 <= pos)}.","proofString":"left; auto."},{"statement":"(l : loc) : True <-> (forall l' : loc, False -> diff l l').","proofString":"tauto."},{"statement":"(l a : loc) (ll : list loc) (IHll : notin l ll <-> (forall l' : loc, In l' ll -> diff l l')) : diff l a /\\ notin l ll <-> (forall l' : loc, a = l' \\/ In l' ll -> diff l l').","proofString":"rewrite IHll.\nintuition.\nsubst a.\nauto."},{"statement":"(l a : loc) (ll : list loc) (IHll : notin l ll <-> (forall l' : loc, In l' ll -> diff l l')) : diff l a /\\ (forall l' : loc, In l' ll -> diff l l') <->\n(forall l' : loc, a = l' \\/ In l' ll -> diff l l').","proofString":"intuition.\nsubst a.\nauto."},{"statement":"(l a : loc) (ll : list loc) (H2 : diff l a) (H3 : forall l'0 : loc, In l'0 ll -> diff l l'0) (H1 : notin l ll) (H0 : forall l'0 : loc, In l'0 ll -> diff l l'0) (l' : loc) (H4 : a = l') : diff l l'.","proofString":"subst a.\nauto."},{"statement":"(l : loc) (ll : list loc) (l' : loc) (H2 : diff l l') (H3 : forall l'0 : loc, In l'0 ll -> diff l l'0) (H1 : notin l ll) (H0 : forall l'0 : loc, In l'0 ll -> diff l l'0) : diff l l'.","proofString":"auto."},{"statement":"(l : loc) (ll : list loc) (H : notin l ll) (H0 : In l ll) : False.","proofString":"rewrite notin_iff in H.\nelim (diff_not_eq l l); auto."},{"statement":"(l : loc) (ll : list loc) (H : forall l' : loc, In l' ll -> diff l l') (H0 : In l ll) : False.","proofString":"elim (diff_not_eq l l); auto."},{"statement":"(l : loc) : {True} + {~ True}.","proofString":"left; auto."},{"statement":"(l a : loc) (ll : list loc) (IHll : {notin l ll} + {~ notin l ll}) : {diff l a /\\ notin l ll} + {~ (diff l a /\\ notin l ll)}.","proofString":"destruct (diff_dec l a).\ndestruct IHll.\nleft; auto.\nright; tauto.\nright; tauto."},{"statement":"(l a : loc) (ll : list loc) (IHll : {notin l ll} + {~ notin l ll}) (d : diff l a) : {diff l a /\\ notin l ll} + {~ (diff l a /\\ notin l ll)}.","proofString":"destruct IHll.\nleft; auto.\nright; tauto."},{"statement":"(l a : loc) (ll : list loc) (n : notin l ll) (d : diff l a) : {diff l a /\\ notin l ll} + {~ (diff l a /\\ notin l ll)}.","proofString":"left; auto."},{"statement":"(l a : loc) (ll : list loc) (n : ~ notin l ll) (d : diff l a) : {diff l a /\\ notin l ll} + {~ (diff l a /\\ notin l ll)}.","proofString":"right; tauto."},{"statement":"(l a : loc) (ll : list loc) (IHll : {notin l ll} + {~ notin l ll}) (n : ~ diff l a) : {diff l a /\\ notin l ll} + {~ (diff l a /\\ notin l ll)}.","proofString":"right; tauto."},{"statement":"(a : loc) (l1 l2 : list loc) (H : forall x0 x3 : loc, In x0 (a :: l1) -> In x3 l2 -> diff x0 x3) (x1 x2 : loc) (H0 : In x1 l1) (H1 : In x2 l2) : diff x1 x2.","proofString":"auto with coqlib."},{"statement":"(a : loc) (l1 l2 : list loc) (H : forall x0 x3 : loc, In x0 l1 -> In x3 (a :: l2) -> diff x0 x3) (x1 x2 : loc) (H0 : In x1 l1) (H1 : In x2 l2) : diff x1 x2.","proofString":"auto with coqlib."},{"statement":"(l1 l2 : list loc) (H : forall x0 x3 : loc, In x0 l1 -> In x3 l2 -> diff x0 x3) (x1 x2 : loc) (H0 : In x1 l2) (H1 : In x2 l1) : diff x1 x2.","proofString":"apply diff_sym; auto."},{"statement":"(l1 l2 : loc) (ll : list loc) (H : notin l1 ll) (H0 : In l2 ll) : diff l1 l2.","proofString":"rewrite notin_iff in H.\nauto."},{"statement":"(l1 l2 : loc) (ll : list loc) (H : forall l' : loc, In l' ll -> diff l1 l') (H0 : In l2 ll) : diff l1 l2.","proofString":"auto."},{"statement":"(l1 l2 : list loc) (H : forall x : loc, In x l1 -> notin x l2) (x1 x2 : loc) (H0 : In x1 l1) (H1 : In x2 l2) : diff x1 x2.","proofString":"exploit H; eauto.\nrewrite notin_iff; intros.\nauto."},{"statement":"(l1 l2 : list loc) (H : forall x : loc, In x l1 -> notin x l2) (x1 x2 : loc) (H0 : In x1 l1) (H1 : In x2 l2) : notin x1 l2 -> diff x1 x2.","proofString":"rewrite notin_iff; intros.\nauto."},{"statement":"(l1 l2 : list loc) (H : forall x : loc, In x l1 -> notin x l2) (x1 x2 : loc) (H0 : In x1 l1) (H1 : In x2 l2) (H2 : forall l' : loc, In l' l2 -> diff x1 l') : diff x1 x2.","proofString":"auto."},{"statement":"(l1 l2 : list loc) (x : loc) (H : disjoint l1 l2) (H0 : In x l1) (l' : loc) (H1 : In l' l2) : diff x l'.","proofString":"red in H.\nauto."},{"statement":"(l1 l2 : list loc) (x : loc) (H : forall x1 x2 : loc, In x1 l1 -> In x2 l2 -> diff x1 x2) (H0 : In x l1) (l' : loc) (H1 : In l' l2) : diff x l'.","proofString":"auto."},{"statement":"{norepet nil} + {~ norepet nil}.","proofString":"left; constructor."},{"statement":"(a : loc) (ll : list loc) (IHll : {norepet ll} + {~ norepet ll}) : {norepet (a :: ll)} + {~ norepet (a :: ll)}.","proofString":"destruct (notin_dec a ll).\ndestruct IHll.\nleft; constructor; auto.\nright; red; intros P; inv P; contradiction.\nright; red; intros P; inv P; contradiction."},{"statement":"(a : loc) (ll : list loc) (IHll : {norepet ll} + {~ norepet ll}) (n : notin a ll) : {norepet (a :: ll)} + {~ norepet (a :: ll)}.","proofString":"destruct IHll.\nleft; constructor; auto.\nright; red; intros P; inv P; contradiction."},{"statement":"(a : loc) (ll : list loc) (n0 : norepet ll) (n : notin a ll) : {norepet (a :: ll)} + {~ norepet (a :: ll)}.","proofString":"left; constructor; auto."},{"statement":"(a : loc) (ll : list loc) (n0 : ~ norepet ll) (n : notin a ll) : {norepet (a :: ll)} + {~ norepet (a :: ll)}.","proofString":"right; red; intros P; inv P; contradiction."},{"statement":"(a : loc) (ll : list loc) (IHll : {norepet ll} + {~ norepet ll}) (n : ~ notin a ll) : {norepet (a :: ll)} + {~ norepet (a :: ll)}.","proofString":"right; red; intros P; inv P; contradiction."},{"statement":"(l : loc) (v : val) (m : t) : set l v m l =\nmatch l with\n| R _ => v\n| S _ _ ty => Val.load_result (chunk_of_type ty) v\nend.","proofString":"unfold set.\napply dec_eq_true."},{"statement":"(l : loc) (v : val) (m : t) : (if Loc.eq l l\n then\n  match l with\n  | R _ => v\n  | S _ _ ty => Val.load_result (chunk_of_type ty) v\n  end\n else if Loc.diff_dec l l then m l else Vundef) =\nmatch l with\n| R _ => v\n| S _ _ ty => Val.load_result (chunk_of_type ty) v\nend.","proofString":"apply dec_eq_true."},{"statement":"(r : mreg) (v : val) (m : t) : set (R r) v m (R r) = v.","proofString":"unfold set.\nrewrite dec_eq_true.\nauto."},{"statement":"(r : mreg) (v : val) (m : t) : (if Loc.eq (R r) (R r)\n then v\n else if Loc.diff_dec (R r) (R r) then m (R r) else Vundef) = v.","proofString":"rewrite dec_eq_true.\nauto."},{"statement":"(r : mreg) (v : val) (m : t) : v = v.","proofString":"auto."},{"statement":"(l : loc) (v : val) (m : t) (H : Val.has_type v (Loc.type l)) : set l v m l = v.","proofString":"rewrite gss.\ndestruct l.\nauto.\napply Val.load_result_same; auto."},{"statement":"(l : loc) (v : val) (m : t) (H : Val.has_type v (Loc.type l)) : match l with\n| R _ => v\n| S _ _ ty => Val.load_result (chunk_of_type ty) v\nend = v.","proofString":"destruct l.\nauto.\napply Val.load_result_same; auto."},{"statement":"(r : mreg) (v : val) (m : t) (H : Val.has_type v (Loc.type (R r))) : v = v.","proofString":"auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (v : val) (m : t) (H : Val.has_type v (Loc.type (S sl pos ty))) : Val.load_result (chunk_of_type ty) v = v.","proofString":"apply Val.load_result_same; auto."},{"statement":"(l : loc) (v : val) (m : t) (p : loc) (H : Loc.diff l p) : set l v m p = m p.","proofString":"unfold set.\ndestruct (Loc.eq l p).\nsubst p.\nelim (Loc.same_not_diff _ H).\ndestruct (Loc.diff_dec l p).\nauto.\ncontradiction."},{"statement":"(l : loc) (v : val) (m : t) (p : loc) (H : Loc.diff l p) : (if Loc.eq l p\n then\n  match l with\n  | R _ => v\n  | S _ _ ty => Val.load_result (chunk_of_type ty) v\n  end\n else if Loc.diff_dec l p then m p else Vundef) = \nm p.","proofString":"destruct (Loc.eq l p).\nsubst p.\nelim (Loc.same_not_diff _ H).\ndestruct (Loc.diff_dec l p).\nauto.\ncontradiction."},{"statement":"(l : loc) (v : val) (m : t) (p : loc) (H : Loc.diff l p) (e : l = p) : match l with\n| R _ => v\n| S _ _ ty => Val.load_result (chunk_of_type ty) v\nend = m p.","proofString":"subst p.\nelim (Loc.same_not_diff _ H)."},{"statement":"(l : loc) (v : val) (m : t) (H : Loc.diff l l) : match l with\n| R _ => v\n| S _ _ ty => Val.load_result (chunk_of_type ty) v\nend = m l.","proofString":"elim (Loc.same_not_diff _ H)."},{"statement":"(l : loc) (v : val) (m : t) (p : loc) (H : Loc.diff l p) (n : l <> p) : (if Loc.diff_dec l p then m p else Vundef) = m p.","proofString":"destruct (Loc.diff_dec l p).\nauto.\ncontradiction."},{"statement":"(l : loc) (v : val) (m : t) (p : loc) (H : Loc.diff l p) (n : l <> p) (d : Loc.diff l p) : m p = m p.","proofString":"auto."},{"statement":"(l : loc) (v : val) (m : t) (p : loc) (H : Loc.diff l p) (n : l <> p) (n0 : ~ Loc.diff l p) : Vundef = m p.","proofString":"contradiction."},{"statement":"(l : loc) (m : t) (H : True) : m l = m l.","proofString":"auto."},{"statement":"(a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), Loc.notin l0 ll -> undef ll m0 l0 = m0 l0) (l : loc) (m : t) (H : Loc.diff l a /\\ Loc.notin l ll) : undef ll (set a Vundef m) l = m l.","proofString":"destruct H.\nrewrite IHll; auto.\napply gso.\napply Loc.diff_sym; auto."},{"statement":"(a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), Loc.notin l0 ll -> undef ll m0 l0 = m0 l0) (l : loc) (m : t) (H : Loc.diff l a) (H0 : Loc.notin l ll) : undef ll (set a Vundef m) l = m l.","proofString":"rewrite IHll; auto.\napply gso.\napply Loc.diff_sym; auto."},{"statement":"(a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), Loc.notin l0 ll -> undef ll m0 l0 = m0 l0) (l : loc) (m : t) (H : Loc.diff l a) (H0 : Loc.notin l ll) : set a Vundef m l = m l.","proofString":"apply gso.\napply Loc.diff_sym; auto."},{"statement":"(a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), Loc.notin l0 ll -> undef ll m0 l0 = m0 l0) (l : loc) (m : t) (H : Loc.diff l a) (H0 : Loc.notin l ll) : Loc.diff a l.","proofString":"apply Loc.diff_sym; auto."},{"statement":"forall (ll : list loc) (l : loc) (m : loc -> val),\nm l = Vundef -> undef ll m l = Vundef.","proofString":"induction ll; simpl; intros.\nauto.\napply IHll.\nunfold set.\ndestruct (Loc.eq a l).\ndestruct a.\nauto.\ndestruct ty; reflexivity.\ndestruct (Loc.diff_dec a l); auto."},{"statement":"(l : loc) (m : loc -> val) (H : m l = Vundef) : m l = Vundef.","proofString":"auto."},{"statement":"(a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll m0 l0 = Vundef) (l : loc) (m : loc -> val) (H : m l = Vundef) : undef ll (set a Vundef m) l = Vundef.","proofString":"apply IHll.\nunfold set.\ndestruct (Loc.eq a l).\ndestruct a.\nauto.\ndestruct ty; reflexivity.\ndestruct (Loc.diff_dec a l); auto."},{"statement":"(a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll m0 l0 = Vundef) (l : loc) (m : loc -> val) (H : m l = Vundef) : set a Vundef m l = Vundef.","proofString":"unfold set.\ndestruct (Loc.eq a l).\ndestruct a.\nauto.\ndestruct ty; reflexivity.\ndestruct (Loc.diff_dec a l); auto."},{"statement":"(a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll m0 l0 = Vundef) (l : loc) (m : loc -> val) (H : m l = Vundef) : (if Loc.eq a l\n then\n  match a with\n  | R _ => Vundef\n  | S _ _ ty => Val.load_result (chunk_of_type ty) Vundef\n  end\n else if Loc.diff_dec a l then m l else Vundef) = Vundef.","proofString":"destruct (Loc.eq a l).\ndestruct a.\nauto.\ndestruct ty; reflexivity.\ndestruct (Loc.diff_dec a l); auto."},{"statement":"(a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll m0 l0 = Vundef) (l : loc) (m : loc -> val) (H : m l = Vundef) (e : a = l) : match a with\n| R _ => Vundef\n| S _ _ ty => Val.load_result (chunk_of_type ty) Vundef\nend = Vundef.","proofString":"destruct a.\nauto.\ndestruct ty; reflexivity."},{"statement":"(r : mreg) (ll : list loc) (IHll : forall (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll m0 l0 = Vundef) (l : loc) (m : loc -> val) (H : m l = Vundef) (e : R r = l) : Vundef = Vundef.","proofString":"auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (ll : list loc) (IHll : forall (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll m0 l0 = Vundef) (l : loc) (m : loc -> val) (H : m l = Vundef) (e : S sl pos ty = l) : Val.load_result (chunk_of_type ty) Vundef = Vundef.","proofString":"destruct ty; reflexivity."},{"statement":"(a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll m0 l0 = Vundef) (l : loc) (m : loc -> val) (H : m l = Vundef) (n : a <> l) : (if Loc.diff_dec a l then m l else Vundef) = Vundef.","proofString":"destruct (Loc.diff_dec a l); auto."},{"statement":"(P : forall (ll : list loc) (l : loc) (m : loc -> val),\nm l = Vundef -> undef ll m l = Vundef) : forall (ll : list loc) (l : loc) (m : t), In l ll -> undef ll m l = Vundef.","proofString":"induction ll; simpl; intros.\ncontradiction.\ndestruct H.\napply P.\nsubst a.\napply gss_typed.\nexact I.\nauto."},{"statement":"(P : forall (ll : list loc) (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll m0 l0 = Vundef) (l : loc) (m : t) (H : False) : m l = Vundef.","proofString":"contradiction."},{"statement":"(P : forall (ll0 : list loc) (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll0 m0 l0 = Vundef) (a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), In l0 ll -> undef ll m0 l0 = Vundef) (l : loc) (m : t) (H : a = l \\/ In l ll) : undef ll (set a Vundef m) l = Vundef.","proofString":"destruct H.\napply P.\nsubst a.\napply gss_typed.\nexact I.\nauto."},{"statement":"(P : forall (ll0 : list loc) (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll0 m0 l0 = Vundef) (a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), In l0 ll -> undef ll m0 l0 = Vundef) (l : loc) (m : t) (H : a = l) : undef ll (set a Vundef m) l = Vundef.","proofString":"apply P.\nsubst a.\napply gss_typed.\nexact I."},{"statement":"(P : forall (ll0 : list loc) (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll0 m0 l0 = Vundef) (a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), In l0 ll -> undef ll m0 l0 = Vundef) (l : loc) (m : t) (H : a = l) : set a Vundef m l = Vundef.","proofString":"subst a.\napply gss_typed.\nexact I."},{"statement":"(P : forall (ll0 : list loc) (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll0 m0 l0 = Vundef) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), In l0 ll -> undef ll m0 l0 = Vundef) (l : loc) (m : t) : set l Vundef m l = Vundef.","proofString":"apply gss_typed.\nexact I."},{"statement":"(P : forall (ll0 : list loc) (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll0 m0 l0 = Vundef) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), In l0 ll -> undef ll m0 l0 = Vundef) (l : loc) (m : t) : Val.has_type Vundef (Loc.type l).","proofString":"exact I."},{"statement":"(P : forall (ll0 : list loc) (l0 : loc) (m0 : loc -> val),\nm0 l0 = Vundef -> undef ll0 m0 l0 = Vundef) (a : loc) (ll : list loc) (IHll : forall (l0 : loc) (m0 : t), In l0 ll -> undef ll m0 l0 = Vundef) (l : loc) (m : t) (H : In l ll) : undef ll (set a Vundef m) l = Vundef.","proofString":"auto."},{"statement":"(p : rpair loc) (ls1 ls2 : loc -> val) (H : forall l : loc, In l (regs_of_rpair p) -> ls2 l = ls1 l) : getpair p ls2 = getpair p ls1.","proofString":"destruct p; simpl.\napply H; simpl; auto.\nf_equal; apply H; simpl; auto."},{"statement":"(r : loc) (ls1 ls2 : loc -> val) (H : forall l : loc, In l (regs_of_rpair (One r)) -> ls2 l = ls1 l) : ls2 r = ls1 r.","proofString":"apply H; simpl; auto."},{"statement":"(rhi rlo : loc) (ls1 ls2 : loc -> val) (H : forall l : loc, In l (regs_of_rpair (Twolong rhi rlo)) -> ls2 l = ls1 l) : Val.longofwords (ls2 rhi) (ls2 rlo) = Val.longofwords (ls1 rhi) (ls1 rlo).","proofString":"f_equal; apply H; simpl; auto."},{"statement":"(r : mreg) (v : val) (m : t) (l : loc) (H : Loc.diff l (R r)) : set (R r) v m l = m l.","proofString":"apply gso.\napply Loc.diff_sym; auto."},{"statement":"(r : mreg) (v : val) (m : t) (l : loc) (H : Loc.diff l (R r)) : Loc.diff (R r) l.","proofString":"apply Loc.diff_sym; auto."},{"statement":"(rhi rlo : mreg) (v : val) (m : t) (l : loc) (H : Loc.diff l (R rhi) /\\ Loc.diff l (R rlo)) : set (R rlo) (Val.loword v) (set (R rhi) (Val.hiword v) m) l = m l.","proofString":"destruct H.\nrewrite ! gso by (apply Loc.diff_sym; auto).\nauto."},{"statement":"(rhi rlo : mreg) (v : val) (m : t) (l : loc) (H : Loc.diff l (R rhi)) (H0 : Loc.diff l (R rlo)) : set (R rlo) (Val.loword v) (set (R rhi) (Val.hiword v) m) l = m l.","proofString":"rewrite ! gso by (apply Loc.diff_sym; auto).\nauto."},{"statement":"(rhi rlo : mreg) (v : val) (m : t) (l : loc) (H : Loc.diff l (R rhi)) (H0 : Loc.diff l (R rlo)) : m l = m l.","proofString":"auto."},{"statement":"(x y z : t) (H : match x with\n| R r1 =>\n    match y with\n    | R r2 => Plt (IndexedMreg.index r1) (IndexedMreg.index r2)\n    | S _ _ _ => True\n    end\n| S sl1 ofs1 ty1 =>\n    match y with\n    | R _ => False\n    | S sl2 ofs2 ty2 =>\n        OrderedSlot.lt sl1 sl2 \\/\n        sl1 = sl2 /\\ (ofs1 < ofs2 \\/ ofs1 = ofs2 /\\ OrderedTyp.lt ty1 ty2)\n    end\nend) (H0 : match y with\n| R r1 =>\n    match z with\n    | R r2 => Plt (IndexedMreg.index r1) (IndexedMreg.index r2)\n    | S _ _ _ => True\n    end\n| S sl1 ofs1 ty1 =>\n    match z with\n    | R _ => False\n    | S sl2 ofs2 ty2 =>\n        OrderedSlot.lt sl1 sl2 \\/\n        sl1 = sl2 /\\ (ofs1 < ofs2 \\/ ofs1 = ofs2 /\\ OrderedTyp.lt ty1 ty2)\n    end\nend) : match x with\n| R r1 =>\n    match z with\n    | R r2 => Plt (IndexedMreg.index r1) (IndexedMreg.index r2)\n    | S _ _ _ => True\n    end\n| S sl1 ofs1 ty1 =>\n    match z with\n    | R _ => False\n    | S sl2 ofs2 ty2 =>\n        OrderedSlot.lt sl1 sl2 \\/\n        sl1 = sl2 /\\ (ofs1 < ofs2 \\/ ofs1 = ofs2 /\\ OrderedTyp.lt ty1 ty2)\n    end\nend.","proofString":"destruct x; destruct y; destruct z; try tauto.\neapply Plt_trans; eauto.\ndestruct H.\ndestruct H0.\nleft; eapply OrderedSlot.lt_trans; eauto.\ndestruct H0.\nsubst sl0.\nauto.\ndestruct H.\nsubst sl.\ndestruct H0.\nauto.\ndestruct H.\nright.\nsplit.\nauto.\nintuition try lia.\nright; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(r r0 r1 : mreg) (H : Plt (IndexedMreg.index r) (IndexedMreg.index r0)) (H0 : Plt (IndexedMreg.index r0) (IndexedMreg.index r1)) : Plt (IndexedMreg.index r) (IndexedMreg.index r1).","proofString":"eapply Plt_trans; eauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : OrderedSlot.lt sl sl0 \\/\nsl = sl0 /\\ (pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0)) (H0 : OrderedSlot.lt sl0 sl1 \\/\nsl0 = sl1 /\\ (pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1)) : OrderedSlot.lt sl sl1 \\/\nsl = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"destruct H.\ndestruct H0.\nleft; eapply OrderedSlot.lt_trans; eauto.\ndestruct H0.\nsubst sl0.\nauto.\ndestruct H.\nsubst sl.\ndestruct H0.\nauto.\ndestruct H.\nright.\nsplit.\nauto.\nintuition try lia.\nright; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : OrderedSlot.lt sl sl0) (H0 : OrderedSlot.lt sl0 sl1 \\/\nsl0 = sl1 /\\ (pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1)) : OrderedSlot.lt sl sl1 \\/\nsl = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"destruct H0.\nleft; eapply OrderedSlot.lt_trans; eauto.\ndestruct H0.\nsubst sl0.\nauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : OrderedSlot.lt sl sl0) (H0 : OrderedSlot.lt sl0 sl1) : OrderedSlot.lt sl sl1 \\/\nsl = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"left; eapply OrderedSlot.lt_trans; eauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : OrderedSlot.lt sl sl0) (H0 : sl0 = sl1 /\\ (pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1)) : OrderedSlot.lt sl sl1 \\/\nsl = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"destruct H0.\nsubst sl0.\nauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : OrderedSlot.lt sl sl0) (H0 : sl0 = sl1) (H1 : pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1) : OrderedSlot.lt sl sl1 \\/\nsl = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"subst sl0.\nauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : OrderedSlot.lt sl sl1) (H1 : pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1) : OrderedSlot.lt sl sl1 \\/\nsl = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : sl = sl0 /\\ (pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0)) (H0 : OrderedSlot.lt sl0 sl1 \\/\nsl0 = sl1 /\\ (pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1)) : OrderedSlot.lt sl sl1 \\/\nsl = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"destruct H.\nsubst sl.\ndestruct H0.\nauto.\ndestruct H.\nright.\nsplit.\nauto.\nintuition try lia.\nright; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : sl = sl0) (H1 : pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0) (H0 : OrderedSlot.lt sl0 sl1 \\/\nsl0 = sl1 /\\ (pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1)) : OrderedSlot.lt sl sl1 \\/\nsl = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"subst sl.\ndestruct H0.\nauto.\ndestruct H.\nright.\nsplit.\nauto.\nintuition try lia.\nright; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H1 : pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0) (H0 : OrderedSlot.lt sl0 sl1 \\/\nsl0 = sl1 /\\ (pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1)) : OrderedSlot.lt sl0 sl1 \\/\nsl0 = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"destruct H0.\nauto.\ndestruct H.\nright.\nsplit.\nauto.\nintuition try lia.\nright; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H1 : pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0) (H : OrderedSlot.lt sl0 sl1) : OrderedSlot.lt sl0 sl1 \\/\nsl0 = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"auto."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H1 : pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0) (H : sl0 = sl1 /\\ (pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1)) : OrderedSlot.lt sl0 sl1 \\/\nsl0 = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"destruct H.\nright.\nsplit.\nauto.\nintuition try lia.\nright; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H1 : pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0) (H : sl0 = sl1) (H0 : pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1) : OrderedSlot.lt sl0 sl1 \\/\nsl0 = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"right.\nsplit.\nauto.\nintuition try lia.\nright; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H1 : pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0) (H : sl0 = sl1) (H0 : pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1) : sl0 = sl1 /\\ (pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1).","proofString":"split.\nauto.\nintuition try lia.\nright; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H1 : pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0) (H : sl0 = sl1) (H0 : pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1) : sl0 = sl1.","proofString":"auto."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H1 : pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0) (H : sl0 = sl1) (H0 : pos0 < pos1 \\/ pos0 = pos1 /\\ OrderedTyp.lt ty0 ty1) : pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1.","proofString":"intuition try lia.\nright; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : sl0 = sl1) (H1 : pos = pos0) (H3 : OrderedTyp.lt ty ty0) (H0 : pos0 = pos1) (H4 : OrderedTyp.lt ty0 ty1) : pos < pos1 \\/ pos = pos1 /\\ OrderedTyp.lt ty ty1.","proofString":"right; split.\ncongruence.\neapply OrderedTyp.lt_trans; eauto."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : sl0 = sl1) (H1 : pos = pos0) (H3 : OrderedTyp.lt ty ty0) (H0 : pos0 = pos1) (H4 : OrderedTyp.lt ty0 ty1) : pos = pos1.","proofString":"congruence."},{"statement":"(pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (sl1 : slot) (pos1 : Z) (ty1 : typ) (H : sl0 = sl1) (H1 : pos = pos0) (H3 : OrderedTyp.lt ty ty0) (H0 : pos0 = pos1) (H4 : OrderedTyp.lt ty0 ty1) : OrderedTyp.lt ty ty1.","proofString":"eapply OrderedTyp.lt_trans; eauto."},{"statement":"(x y : t) (H : match x with\n| R r1 =>\n    match y with\n    | R r2 => Plt (IndexedMreg.index r1) (IndexedMreg.index r2)\n    | S _ _ _ => True\n    end\n| S sl1 ofs1 ty1 =>\n    match y with\n    | R _ => False\n    | S sl2 ofs2 ty2 =>\n        OrderedSlot.lt sl1 sl2 \\/\n        sl1 = sl2 /\\ (ofs1 < ofs2 \\/ ofs1 = ofs2 /\\ OrderedTyp.lt ty1 ty2)\n    end\nend) (H0 : x = y) : False.","proofString":"subst y.\ndestruct x.\neelim Plt_strict; eauto.\ndestruct H.\neelim OrderedSlot.lt_not_eq; eauto.\nred; auto.\ndestruct H.\ndestruct H0.\nlia.\ndestruct H0.\neelim OrderedTyp.lt_not_eq; eauto.\nred; auto."},{"statement":"(x : t) (H : match x with\n| R r1 =>\n    match x with\n    | R r2 => Plt (IndexedMreg.index r1) (IndexedMreg.index r2)\n    | S _ _ _ => True\n    end\n| S sl1 ofs1 ty1 =>\n    match x with\n    | R _ => False\n    | S sl2 ofs2 ty2 =>\n        OrderedSlot.lt sl1 sl2 \\/\n        sl1 = sl2 /\\ (ofs1 < ofs2 \\/ ofs1 = ofs2 /\\ OrderedTyp.lt ty1 ty2)\n    end\nend) : False.","proofString":"destruct x.\neelim Plt_strict; eauto.\ndestruct H.\neelim OrderedSlot.lt_not_eq; eauto.\nred; auto.\ndestruct H.\ndestruct H0.\nlia.\ndestruct H0.\neelim OrderedTyp.lt_not_eq; eauto.\nred; auto."},{"statement":"(r : mreg) (H : Plt (IndexedMreg.index r) (IndexedMreg.index r)) : False.","proofString":"eelim Plt_strict; eauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : OrderedSlot.lt sl sl \\/\nsl = sl /\\ (pos < pos \\/ pos = pos /\\ OrderedTyp.lt ty ty)) : False.","proofString":"destruct H.\neelim OrderedSlot.lt_not_eq; eauto.\nred; auto.\ndestruct H.\ndestruct H0.\nlia.\ndestruct H0.\neelim OrderedTyp.lt_not_eq; eauto.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : OrderedSlot.lt sl sl) : False.","proofString":"eelim OrderedSlot.lt_not_eq; eauto.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : OrderedSlot.lt sl sl) : OrderedSlot.eq sl sl.","proofString":"red; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : sl = sl /\\ (pos < pos \\/ pos = pos /\\ OrderedTyp.lt ty ty)) : False.","proofString":"destruct H.\ndestruct H0.\nlia.\ndestruct H0.\neelim OrderedTyp.lt_not_eq; eauto.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : sl = sl) (H0 : pos < pos \\/ pos = pos /\\ OrderedTyp.lt ty ty) : False.","proofString":"destruct H0.\nlia.\ndestruct H0.\neelim OrderedTyp.lt_not_eq; eauto.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : sl = sl) (H0 : pos < pos) : False.","proofString":"lia."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : sl = sl) (H0 : pos = pos /\\ OrderedTyp.lt ty ty) : False.","proofString":"destruct H0.\neelim OrderedTyp.lt_not_eq; eauto.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : sl = sl) (H0 : pos = pos) (H1 : OrderedTyp.lt ty ty) : False.","proofString":"eelim OrderedTyp.lt_not_eq; eauto.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : sl = sl) (H0 : pos = pos) (H1 : OrderedTyp.lt ty ty) : OrderedTyp.eq ty ty.","proofString":"red; auto."},{"statement":"(x y : t) : Compare lt eq x y.","proofString":"destruct x; destruct y.\ndestruct (OrderedPositive.compare (IndexedMreg.index r) (IndexedMreg.index r0)).\napply LT.\nred.\nauto.\napply EQ.\nred.\nf_equal.\napply IndexedMreg.index_inj.\nauto.\napply GT.\nred.\nauto.\napply LT.\nred; auto.\napply GT.\nred; auto.\ndestruct (OrderedSlot.compare sl sl0).\napply LT.\nred; auto.\ndestruct (OrderedZ.compare pos pos0).\napply LT.\nred.\nauto.\ndestruct (OrderedTyp.compare ty ty0).\napply LT.\nred; auto.\napply EQ.\nred; red in e; red in e0; red in e1.\ncongruence.\napply GT.\nred; auto.\napply GT.\nred.\nauto.\napply GT.\nred; auto."},{"statement":"(r r0 : mreg) : Compare lt eq (R r) (R r0).","proofString":"destruct (OrderedPositive.compare (IndexedMreg.index r) (IndexedMreg.index r0)).\napply LT.\nred.\nauto.\napply EQ.\nred.\nf_equal.\napply IndexedMreg.index_inj.\nauto.\napply GT.\nred.\nauto."},{"statement":"(r r0 : mreg) (l : OrderedPositive.lt (IndexedMreg.index r) (IndexedMreg.index r0)) : Compare lt eq (R r) (R r0).","proofString":"apply LT.\nred.\nauto."},{"statement":"(r r0 : mreg) (l : OrderedPositive.lt (IndexedMreg.index r) (IndexedMreg.index r0)) : lt (R r) (R r0).","proofString":"red.\nauto."},{"statement":"(r r0 : mreg) (l : OrderedPositive.lt (IndexedMreg.index r) (IndexedMreg.index r0)) : Plt (IndexedMreg.index r) (IndexedMreg.index r0).","proofString":"auto."},{"statement":"(r r0 : mreg) (e : OrderedPositive.eq (IndexedMreg.index r) (IndexedMreg.index r0)) : Compare lt eq (R r) (R r0).","proofString":"apply EQ.\nred.\nf_equal.\napply IndexedMreg.index_inj.\nauto."},{"statement":"(r r0 : mreg) (e : OrderedPositive.eq (IndexedMreg.index r) (IndexedMreg.index r0)) : eq (R r) (R r0).","proofString":"red.\nf_equal.\napply IndexedMreg.index_inj.\nauto."},{"statement":"(r r0 : mreg) (e : OrderedPositive.eq (IndexedMreg.index r) (IndexedMreg.index r0)) : R r = R r0.","proofString":"f_equal.\napply IndexedMreg.index_inj.\nauto."},{"statement":"(r r0 : mreg) (e : OrderedPositive.eq (IndexedMreg.index r) (IndexedMreg.index r0)) : r = r0.","proofString":"apply IndexedMreg.index_inj.\nauto."},{"statement":"(r r0 : mreg) (e : OrderedPositive.eq (IndexedMreg.index r) (IndexedMreg.index r0)) : IndexedMreg.index r = IndexedMreg.index r0.","proofString":"auto."},{"statement":"(r r0 : mreg) (l : OrderedPositive.lt (IndexedMreg.index r0) (IndexedMreg.index r)) : Compare lt eq (R r) (R r0).","proofString":"apply GT.\nred.\nauto."},{"statement":"(r r0 : mreg) (l : OrderedPositive.lt (IndexedMreg.index r0) (IndexedMreg.index r)) : lt (R r0) (R r).","proofString":"red.\nauto."},{"statement":"(r r0 : mreg) (l : OrderedPositive.lt (IndexedMreg.index r0) (IndexedMreg.index r)) : Plt (IndexedMreg.index r0) (IndexedMreg.index r).","proofString":"auto."},{"statement":"(r : mreg) (sl : slot) (pos : Z) (ty : typ) : Compare lt eq (R r) (S sl pos ty).","proofString":"apply LT.\nred; auto."},{"statement":"(r : mreg) (sl : slot) (pos : Z) (ty : typ) : lt (R r) (S sl pos ty).","proofString":"red; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (r : mreg) : Compare lt eq (S sl pos ty) (R r).","proofString":"apply GT.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (r : mreg) : lt (R r) (S sl pos ty).","proofString":"red; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"destruct (OrderedSlot.compare sl sl0).\napply LT.\nred; auto.\ndestruct (OrderedZ.compare pos pos0).\napply LT.\nred.\nauto.\ndestruct (OrderedTyp.compare ty ty0).\napply LT.\nred; auto.\napply EQ.\nred; red in e; red in e0; red in e1.\ncongruence.\napply GT.\nred; auto.\napply GT.\nred.\nauto.\napply GT.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (l : OrderedSlot.lt sl sl0) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"apply LT.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (l : OrderedSlot.lt sl sl0) : lt (S sl pos ty) (S sl0 pos0 ty0).","proofString":"red; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"destruct (OrderedZ.compare pos pos0).\napply LT.\nred.\nauto.\ndestruct (OrderedTyp.compare ty ty0).\napply LT.\nred; auto.\napply EQ.\nred; red in e; red in e0; red in e1.\ncongruence.\napply GT.\nred; auto.\napply GT.\nred.\nauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (l : OrderedZ.lt pos pos0) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"apply LT.\nred.\nauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (l : OrderedZ.lt pos pos0) : lt (S sl pos ty) (S sl0 pos0 ty0).","proofString":"red.\nauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (l : OrderedZ.lt pos pos0) : OrderedSlot.lt sl sl0 \\/\nsl = sl0 /\\ (pos < pos0 \\/ pos = pos0 /\\ OrderedTyp.lt ty ty0).","proofString":"auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (e0 : OrderedZ.eq pos pos0) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"destruct (OrderedTyp.compare ty ty0).\napply LT.\nred; auto.\napply EQ.\nred; red in e; red in e0; red in e1.\ncongruence.\napply GT.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (e0 : OrderedZ.eq pos pos0) (l : OrderedTyp.lt ty ty0) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"apply LT.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (e0 : OrderedZ.eq pos pos0) (l : OrderedTyp.lt ty ty0) : lt (S sl pos ty) (S sl0 pos0 ty0).","proofString":"red; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (e0 : OrderedZ.eq pos pos0) (e1 : OrderedTyp.eq ty ty0) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"apply EQ.\nred; red in e; red in e0; red in e1.\ncongruence."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (e0 : OrderedZ.eq pos pos0) (e1 : OrderedTyp.eq ty ty0) : eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"red; red in e; red in e0; red in e1.\ncongruence."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : sl = sl0) (e0 : pos = pos0) (e1 : ty = ty0) : S sl pos ty = S sl0 pos0 ty0.","proofString":"congruence."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (e0 : OrderedZ.eq pos pos0) (l : OrderedTyp.lt ty0 ty) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"apply GT.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (e0 : OrderedZ.eq pos pos0) (l : OrderedTyp.lt ty0 ty) : lt (S sl0 pos0 ty0) (S sl pos ty).","proofString":"red; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (l : OrderedZ.lt pos0 pos) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"apply GT.\nred.\nauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (l : OrderedZ.lt pos0 pos) : lt (S sl0 pos0 ty0) (S sl pos ty).","proofString":"red.\nauto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (e : OrderedSlot.eq sl sl0) (l : OrderedZ.lt pos0 pos) : OrderedSlot.lt sl0 sl \\/\nsl0 = sl /\\ (pos0 < pos \\/ pos0 = pos /\\ OrderedTyp.lt ty0 ty).","proofString":"auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (l : OrderedSlot.lt sl0 sl) : Compare lt eq (S sl pos ty) (S sl0 pos0 ty0).","proofString":"apply GT.\nred; auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (sl0 : slot) (pos0 : Z) (ty0 : typ) (l : OrderedSlot.lt sl0 sl) : lt (S sl0 pos0 ty0) (S sl pos ty).","proofString":"red; auto."},{"statement":"(l : loc) (l' : t) (H : lt l' (diff_low_bound l) \\/ lt (diff_high_bound l) l') : Loc.diff l l'.","proofString":"destruct l as [mr | sl ofs ty]; destruct l' as [mr' | sl' ofs' ty']; simpl in *; auto.\nassert (IndexedMreg.index mr <> IndexedMreg.index mr').\ndestruct H.\napply not_eq_sym.\napply Plt_ne; auto.\napply Plt_ne; auto.\ncongruence.\nassert (RANGE: forall ty, 1 <= typesize ty <= 2).\nintros; unfold typesize.\ndestruct ty0; lia.\ndestruct H.\ndestruct H.\nleft.\napply not_eq_sym.\napply OrderedSlot.lt_not_eq; auto.\ndestruct H.\nright.\ndestruct H0.\nright.\ngeneralize (RANGE ty'); lia.\ndestruct H0.\nassert (ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32).\nunfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence.\nright.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia.\ndestruct H.\nleft.\napply OrderedSlot.lt_not_eq; auto.\ndestruct H.\nright.\ndestruct H0.\nleft; lia.\ndestruct H0.\nexfalso.\ndestruct ty'; compute in H1; congruence."},{"statement":"(mr mr' : mreg) (H : Plt (IndexedMreg.index mr') (IndexedMreg.index mr) \\/\nPlt (IndexedMreg.index mr) (IndexedMreg.index mr')) : mr <> mr'.","proofString":"assert (IndexedMreg.index mr <> IndexedMreg.index mr').\ndestruct H.\napply not_eq_sym.\napply Plt_ne; auto.\napply Plt_ne; auto.\ncongruence."},{"statement":"(mr mr' : mreg) (H : Plt (IndexedMreg.index mr') (IndexedMreg.index mr) \\/\nPlt (IndexedMreg.index mr) (IndexedMreg.index mr')) : IndexedMreg.index mr <> IndexedMreg.index mr'.","proofString":"destruct H.\napply not_eq_sym.\napply Plt_ne; auto.\napply Plt_ne; auto."},{"statement":"(mr mr' : mreg) (H : Plt (IndexedMreg.index mr') (IndexedMreg.index mr)) : IndexedMreg.index mr <> IndexedMreg.index mr'.","proofString":"apply not_eq_sym.\napply Plt_ne; auto."},{"statement":"(mr mr' : mreg) (H : Plt (IndexedMreg.index mr') (IndexedMreg.index mr)) : IndexedMreg.index mr' <> IndexedMreg.index mr.","proofString":"apply Plt_ne; auto."},{"statement":"(mr mr' : mreg) (H : Plt (IndexedMreg.index mr) (IndexedMreg.index mr')) : IndexedMreg.index mr <> IndexedMreg.index mr'.","proofString":"apply Plt_ne; auto."},{"statement":"(mr mr' : mreg) (H : Plt (IndexedMreg.index mr') (IndexedMreg.index mr) \\/\nPlt (IndexedMreg.index mr) (IndexedMreg.index mr')) (H0 : IndexedMreg.index mr <> IndexedMreg.index mr') : mr <> mr'.","proofString":"congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty')) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"assert (RANGE: forall ty, 1 <= typesize ty <= 2).\nintros; unfold typesize.\ndestruct ty0; lia.\ndestruct H.\ndestruct H.\nleft.\napply not_eq_sym.\napply OrderedSlot.lt_not_eq; auto.\ndestruct H.\nright.\ndestruct H0.\nright.\ngeneralize (RANGE ty'); lia.\ndestruct H0.\nassert (ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32).\nunfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence.\nright.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia.\ndestruct H.\nleft.\napply OrderedSlot.lt_not_eq; auto.\ndestruct H.\nright.\ndestruct H0.\nleft; lia.\ndestruct H0.\nexfalso.\ndestruct ty'; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty')) : forall ty0 : typ, 1 <= typesize ty0 <= 2.","proofString":"intros; unfold typesize.\ndestruct ty0; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty')) (ty0 : typ) : 1 <= match ty0 with\n     | Tint | Tsingle | Tany32 => 1\n     | _ => 2\n     end <= 2.","proofString":"destruct ty0; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty')) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"destruct H.\ndestruct H.\nleft.\napply not_eq_sym.\napply OrderedSlot.lt_not_eq; auto.\ndestruct H.\nright.\ndestruct H0.\nright.\ngeneralize (RANGE ty'); lia.\ndestruct H0.\nassert (ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32).\nunfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence.\nright.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia.\ndestruct H.\nleft.\napply OrderedSlot.lt_not_eq; auto.\ndestruct H.\nright.\ndestruct H0.\nleft; lia.\ndestruct H0.\nexfalso.\ndestruct ty'; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : OrderedSlot.lt sl' sl \\/\nsl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"destruct H.\nleft.\napply not_eq_sym.\napply OrderedSlot.lt_not_eq; auto.\ndestruct H.\nright.\ndestruct H0.\nright.\ngeneralize (RANGE ty'); lia.\ndestruct H0.\nassert (ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32).\nunfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence.\nright.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : OrderedSlot.lt sl' sl) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"left.\napply not_eq_sym.\napply OrderedSlot.lt_not_eq; auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : OrderedSlot.lt sl' sl) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl'.","proofString":"apply not_eq_sym.\napply OrderedSlot.lt_not_eq; auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : OrderedSlot.lt sl' sl) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl' <> sl.","proofString":"apply OrderedSlot.lt_not_eq; auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"destruct H.\nright.\ndestruct H0.\nright.\ngeneralize (RANGE ty'); lia.\ndestruct H0.\nassert (ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32).\nunfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence.\nright.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"right.\ndestruct H0.\nright.\ngeneralize (RANGE ty'); lia.\ndestruct H0.\nassert (ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32).\nunfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence.\nright.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"destruct H0.\nright.\ngeneralize (RANGE ty'); lia.\ndestruct H0.\nassert (ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32).\nunfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence.\nright.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' < ofs - 1) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"right.\ngeneralize (RANGE ty'); lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' < ofs - 1) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ofs' + typesize ty' <= ofs.","proofString":"generalize (RANGE ty'); lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"destruct H0.\nassert (ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32).\nunfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence.\nright.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' = ofs - 1) (H1 : OrderedTyp.lt ty' Tany64) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"assert (ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32).\nunfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence.\nright.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' = ofs - 1) (H1 : OrderedTyp.lt ty' Tany64) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32.","proofString":"unfold OrderedTyp.lt in H1.\ndestruct ty'; auto; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' = ofs - 1) (H1 : Plt (IndexedTyp.index ty') (IndexedTyp.index Tany64)) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32.","proofString":"destruct ty'; auto; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' = ofs - 1) (H1 : OrderedTyp.lt ty' Tany64) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) (H2 : ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32) : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"right.\ndestruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl' = sl) (H0 : ofs' = ofs - 1) (H1 : OrderedTyp.lt ty' Tany64) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) (H2 : ty' = Tint \\/ ty' = Tsingle \\/ ty' = Tany32) : ofs' + typesize ty' <= ofs.","proofString":"destruct H2 as [E|[E|E]]; subst ty'; simpl typesize; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : OrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty')) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"destruct H.\nleft.\napply OrderedSlot.lt_not_eq; auto.\ndestruct H.\nright.\ndestruct H0.\nleft; lia.\ndestruct H0.\nexfalso.\ndestruct ty'; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : OrderedSlot.lt sl sl') (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"left.\napply OrderedSlot.lt_not_eq; auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : OrderedSlot.lt sl sl') (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl'.","proofString":"apply OrderedSlot.lt_not_eq; auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty')) (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"destruct H.\nright.\ndestruct H0.\nleft; lia.\ndestruct H0.\nexfalso.\ndestruct ty'; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl = sl') (H0 : ofs + typesize ty - 1 < ofs' \\/\nofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty') (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"right.\ndestruct H0.\nleft; lia.\ndestruct H0.\nexfalso.\ndestruct ty'; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl = sl') (H0 : ofs + typesize ty - 1 < ofs' \\/\nofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty') (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"destruct H0.\nleft; lia.\ndestruct H0.\nexfalso.\ndestruct ty'; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl = sl') (H0 : ofs + typesize ty - 1 < ofs') (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"left; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl = sl') (H0 : ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty') (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"destruct H0.\nexfalso.\ndestruct ty'; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl = sl') (H0 : ofs + typesize ty - 1 = ofs') (H1 : OrderedTyp.lt Tlong ty') (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs.","proofString":"exfalso.\ndestruct ty'; compute in H1; congruence."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl = sl') (H0 : ofs + typesize ty - 1 = ofs') (H1 : OrderedTyp.lt Tlong ty') (RANGE : forall ty0 : typ, 1 <= typesize ty0 <= 2) : False.","proofString":"destruct ty'; compute in H1; congruence."},{"statement":"(l l' : loc) (H : Loc.diff l l') : lt l' (diff_low_bound l) \\/ lt (diff_high_bound l) l'.","proofString":"destruct l as [mr | sl ofs ty]; destruct l' as [mr' | sl' ofs' ty']; simpl in *; auto.\nunfold Plt, Pos.lt.\ndestruct (Pos.compare (IndexedMreg.index mr) (IndexedMreg.index mr')) eqn:C.\nelim H.\napply IndexedMreg.index_inj.\napply Pos.compare_eq_iff.\nauto.\nauto.\nrewrite Pos.compare_antisym.\nrewrite C.\nauto.\ndestruct (OrderedSlot.compare sl sl'); auto.\ndestruct H.\ncontradiction.\ndestruct H.\nright; right; split; auto.\nleft; lia.\nleft; right; split; auto.\nassert (EITHER: typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2).\ndestruct ty'; compute; auto.\ndestruct (zlt ofs' (ofs - 1)).\nleft; auto.\ndestruct EITHER as [[P Q] | P].\nright; split; auto.\nlia.\nleft; lia."},{"statement":"(mr mr' : mreg) (H : mr <> mr') : Plt (IndexedMreg.index mr') (IndexedMreg.index mr) \\/\nPlt (IndexedMreg.index mr) (IndexedMreg.index mr').","proofString":"unfold Plt, Pos.lt.\ndestruct (Pos.compare (IndexedMreg.index mr) (IndexedMreg.index mr')) eqn:C.\nelim H.\napply IndexedMreg.index_inj.\napply Pos.compare_eq_iff.\nauto.\nauto.\nrewrite Pos.compare_antisym.\nrewrite C.\nauto."},{"statement":"(mr mr' : mreg) (H : mr <> mr') : (IndexedMreg.index mr' ?= IndexedMreg.index mr)%positive = Lt \\/\n(IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Lt.","proofString":"destruct (Pos.compare (IndexedMreg.index mr) (IndexedMreg.index mr')) eqn:C.\nelim H.\napply IndexedMreg.index_inj.\napply Pos.compare_eq_iff.\nauto.\nauto.\nrewrite Pos.compare_antisym.\nrewrite C.\nauto."},{"statement":"(mr mr' : mreg) (H : mr <> mr') (C : (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Eq) : (IndexedMreg.index mr' ?= IndexedMreg.index mr)%positive = Lt \\/ Eq = Lt.","proofString":"elim H.\napply IndexedMreg.index_inj.\napply Pos.compare_eq_iff.\nauto."},{"statement":"(mr mr' : mreg) (H : mr <> mr') (C : (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Eq) : mr = mr'.","proofString":"apply IndexedMreg.index_inj.\napply Pos.compare_eq_iff.\nauto."},{"statement":"(mr mr' : mreg) (H : mr <> mr') (C : (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Eq) : IndexedMreg.index mr = IndexedMreg.index mr'.","proofString":"apply Pos.compare_eq_iff.\nauto."},{"statement":"(mr mr' : mreg) (H : mr <> mr') (C : (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Eq) : (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Eq.","proofString":"auto."},{"statement":"(mr mr' : mreg) (H : mr <> mr') (C : (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Lt) : (IndexedMreg.index mr' ?= IndexedMreg.index mr)%positive = Lt \\/ Lt = Lt.","proofString":"auto."},{"statement":"(mr mr' : mreg) (H : mr <> mr') (C : (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Gt) : (IndexedMreg.index mr' ?= IndexedMreg.index mr)%positive = Lt \\/ Gt = Lt.","proofString":"rewrite Pos.compare_antisym.\nrewrite C.\nauto."},{"statement":"(mr mr' : mreg) (H : mr <> mr') (C : (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Gt) : CompOpp (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Lt \\/\nGt = Lt.","proofString":"rewrite C.\nauto."},{"statement":"(mr mr' : mreg) (H : mr <> mr') (C : (IndexedMreg.index mr ?= IndexedMreg.index mr')%positive = Gt) : CompOpp Gt = Lt \\/ Gt = Lt.","proofString":"auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs) : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty').","proofString":"destruct (OrderedSlot.compare sl sl'); auto.\ndestruct H.\ncontradiction.\ndestruct H.\nright; right; split; auto.\nleft; lia.\nleft; right; split; auto.\nassert (EITHER: typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2).\ndestruct ty'; compute; auto.\ndestruct (zlt ofs' (ofs - 1)).\nleft; auto.\ndestruct EITHER as [[P Q] | P].\nright; split; auto.\nlia.\nleft; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl <> sl' \\/ ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty').","proofString":"destruct H.\ncontradiction.\ndestruct H.\nright; right; split; auto.\nleft; lia.\nleft; right; split; auto.\nassert (EITHER: typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2).\ndestruct ty'; compute; auto.\ndestruct (zlt ofs' (ofs - 1)).\nleft; auto.\ndestruct EITHER as [[P Q] | P].\nright; split; auto.\nlia.\nleft; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : sl <> sl') (e : OrderedSlot.eq sl sl') : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty').","proofString":"contradiction."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs + typesize ty <= ofs' \\/ ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty').","proofString":"destruct H.\nright; right; split; auto.\nleft; lia.\nleft; right; split; auto.\nassert (EITHER: typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2).\ndestruct ty'; compute; auto.\ndestruct (zlt ofs' (ofs - 1)).\nleft; auto.\ndestruct EITHER as [[P Q] | P].\nright; split; auto.\nlia.\nleft; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs + typesize ty <= ofs') (e : OrderedSlot.eq sl sl') : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty').","proofString":"right; right; split; auto.\nleft; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs + typesize ty <= ofs') (e : OrderedSlot.eq sl sl') : ofs + typesize ty - 1 < ofs' \\/\nofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty'.","proofString":"left; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') : (OrderedSlot.lt sl' sl \\/\n sl' = sl /\\ (ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64)) \\/\nOrderedSlot.lt sl sl' \\/\nsl = sl' /\\\n(ofs + typesize ty - 1 < ofs' \\/\n ofs + typesize ty - 1 = ofs' /\\ OrderedTyp.lt Tlong ty').","proofString":"left; right; split; auto.\nassert (EITHER: typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2).\ndestruct ty'; compute; auto.\ndestruct (zlt ofs' (ofs - 1)).\nleft; auto.\ndestruct EITHER as [[P Q] | P].\nright; split; auto.\nlia.\nleft; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') : ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64.","proofString":"assert (EITHER: typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2).\ndestruct ty'; compute; auto.\ndestruct (zlt ofs' (ofs - 1)).\nleft; auto.\ndestruct EITHER as [[P Q] | P].\nright; split; auto.\nlia.\nleft; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') : typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2.","proofString":"destruct ty'; compute; auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') (EITHER : typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2) : ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64.","proofString":"destruct (zlt ofs' (ofs - 1)).\nleft; auto.\ndestruct EITHER as [[P Q] | P].\nright; split; auto.\nlia.\nleft; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') (EITHER : typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2) (l : ofs' < ofs - 1) : ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64.","proofString":"left; auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') (EITHER : typesize ty' = 1 /\\ OrderedTyp.lt ty' Tany64 \\/ typesize ty' = 2) (g : ofs' >= ofs - 1) : ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64.","proofString":"destruct EITHER as [[P Q] | P].\nright; split; auto.\nlia.\nleft; lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') (P : typesize ty' = 1) (Q : OrderedTyp.lt ty' Tany64) (g : ofs' >= ofs - 1) : ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64.","proofString":"right; split; auto.\nlia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') (P : typesize ty' = 1) (Q : OrderedTyp.lt ty' Tany64) (g : ofs' >= ofs - 1) : ofs' = ofs - 1.","proofString":"lia."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (sl' : slot) (ofs' : Z) (ty' : typ) (H : ofs' + typesize ty' <= ofs) (e : OrderedSlot.eq sl sl') (P : typesize ty' = 2) (g : ofs' >= ofs - 1) : ofs' < ofs - 1 \\/ ofs' = ofs - 1 /\\ OrderedTyp.lt ty' Tany64.","proofString":"left; lia."}]}