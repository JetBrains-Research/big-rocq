[{"statement":"Lemma no_ob'_to_init:\n  ob' ≡ ob' ⨾ ⦗set_compl is_init⦘.","proof":"forward eapply WF as WF; eauto.\nsplit; [| basic_solver].\napply domb_rewrite.\nunfold ob', \"obs'\".\nrewrite dob_in_sb, aob_in_sb, bob'_in_sb; auto.\nrewrite !unionA, !unionK.\nrewrite rfe_in_rf, no_rf_to_init, no_co_to_init, no_fr_to_init, no_sb_to_init; auto.\nall: try by apply CON.\nbasic_solver.\n"},{"statement":"Lemma wf_ob'E:\n  ob' ≡ ⦗E⦘ ⨾ ob' ⨾ ⦗E⦘.","proof":"split; [| basic_solver].\napply dom_helper_3.\nunfold ob', \"obs'\".\nrewrite dob_in_sb, aob_in_sb, bob'_in_sb; try by apply CON.\nrewrite wf_rfeE, wf_coE, wf_frE, wf_sbE; try by apply CON.\nbasic_solver.\n"},{"statement":"Lemma fin_locs_arm_hb_ct_fsupp \n      (FINLOCS: exists locs, forall e (ENIe: (E \\₁ is_init) e), In (loc e) locs)\n      (FAIR: mem_fair G)\n      :\n      fsupp (⦗set_compl is_init⦘ ⨾ ob'^+).","proof":"forward eapply WF as WF; eauto.\ndesc.\nrewrite clos_trans_domb_begin.\n2: {\nrewrite no_ob'_to_init; basic_solver.\n}\napply fsupp_wf_implies_fsupp_ct.\n2: {\nunfold ob'.\nunfold ob', \"obs'\".\nrewrite dob_in_sb, aob_in_sb, bob'_in_sb; auto.\nrewrite !unionA, !unionK.\nrewrite rfe_in_rf.\nrepeat rewrite seq_union_r.\nrepeat apply fsupp_union.\n1-3: rewrite inclusion_seq_eqv_l.\nall: (apply FAIR || apply fsupp_rf || apply fsupp_sb); auto.\n}\ncontra NWF.\napply not_wf_inf_decr_enum in NWF as [f DECR].\nassert (forall i, (transp ob') (f i) (f (i + 1))) as DECR'.\n{\nins.\nred.\neapply seq_eqv_l.\neauto.\n}\nassert (f ↑₁ set_full ⊆₁ E \\₁ is_init) as ENUM_E.\n{\nintros e [i [_ Fie]].\nspecialize (DECR i).\neapply same_relation_exp in DECR.\n2: {\nrewrite no_ob'_to_init, wf_ob'E; auto.\n}\ngeneralize DECR.\nsubst e.\nbasic_solver.\n}\nassert (~ set_finite (f ↓₁ W)) as INFW'.\n{\nintros [iws FINW].\nset (wb := list_max iws + 1).\nassert (forall j (GE: j >= wb), sb (f (j + 1)) (f j)) as SB_STEPS.\n{\nintros.\nspecialize (DECR j).\napply seq_eqv_l in DECR.\ndesc.\nunfold ob' in DECR0.\neapply hahn_inclusion_exp in DECR0.\n2: {\nunfold \"obs'\".\nrewrite dob_in_sb, aob_in_sb, bob'_in_sb; auto.\nrewrite !unionA, !unionK, <- !unionA.\neapply union_mori with (y := W × set_full ∪ set_full × W); [| reflexivity].\nrewrite wf_rfeD, wf_coD, wf_frD; auto.\nbasic_solver.\n}\ndestruct DECR0; auto.\ndestruct H; red in H; desc;        [specialize (FINW (j + 1)) | specialize (FINW j)];        specialize_full FINW; try basic_solver.\nall: apply In_gt_list_max in FINW; vauto; lia.\n}\nforward eapply fsupp_dom_enum with (f := fun k => f (wb + k))                                       (r := ⦗set_compl is_init⦘ ⨾ sb) as [].\n{\nins.\napply seq_eqv_l.\nsplit.\n{\napply ENUM_E.\nvauto.\n}\nrewrite PeanoNat.Nat.add_assoc.\napply SB_STEPS.\nlia.\n}\n{\neapply acyclic_mori; [| by apply sb_acyclic].\nred.\nbasic_solver.\n}\neapply fsupp_mori; [| by apply fsupp_sb; eauto].\nred.\nrewrite inclusion_ct_seq_eqv_l.\nrewrite ct_of_trans; vauto.\napply sb_trans.\n}\neapply exists_inf_loc in INFW' as [ol [Ll INFtl]]; eauto.\ndestruct ol.\n2: {\ndestruct INFtl.\nexists [].\nunfolder.\nins.\ndesc.\nforward eapply is_w_loc; eauto.\nins.\ndesc.\nvauto.\n}\neapply enum_order_contradiction with (r' := co)                                       (S := (E \\₁ is_init) ∩₁ (W ∩₁ Loc_ (Some l))); eauto.\n{\nintros FIN.\ndestruct INFtl.\neapply set_finite_mori; eauto.\nred.\nrewrite set_map_inter with (d := _ \\₁ _).\napply set_subset_inter_r.\nsplit; [| basic_solver].\nred.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto.\n}\n{\nred.\nins.\nforward eapply wf_co_total with (a := a) (b := b);        try by (generalize IWa; generalize IWb; (vauto || basic_solver)).\nunfolder in IWa.\nunfolder in IWb.\nunfolder.\ndesc.\nsplits; congruence.\n}\n{\nby apply external_alt.\n}\n{\napply FAIR.\n}\nrewrite <- ct_unit at 2.\napply seq_mori; [reflexivity| ].\nunfold ob', \"obs'\".\nbasic_solver 10.\n"}]