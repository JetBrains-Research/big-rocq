{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Core/Digits.v","fileSamples":[{"statement":"(n : positive) (d : nat) : (Zpower_nat 2 (digits2_Pnat n) <= Z.pos n < Zpower_nat 2 (S (digits2_Pnat n)))%Z.","conclusion":"(Zpower_nat 2 (digits2_Pnat n) <= Z.pos n < Zpower_nat 2 (S (digits2_Pnat n)))%Z","hypotheses":"(n : positive) (d : nat)","proofString":"clear.\nassert (Hp: forall m, (Zpower_nat 2 (S m) = 2 * Zpower_nat 2 m)%Z) by easy.\ninduction n ; simpl digits2_Pnat.\nrewrite Zpos_xI, 2!Hp.\nlia.\nrewrite (Zpos_xO n), 2!Hp.\nlia.\nnow split."},{"statement":"(n : positive) : (Zpower_nat 2 (digits2_Pnat n) <= Z.pos n < Zpower_nat 2 (S (digits2_Pnat n)))%Z.","conclusion":"(Zpower_nat 2 (digits2_Pnat n) <= Z.pos n < Zpower_nat 2 (S (digits2_Pnat n)))%Z","hypotheses":"(n : positive)","proofString":"assert (Hp: forall m, (Zpower_nat 2 (S m) = 2 * Zpower_nat 2 m)%Z) by easy.\ninduction n ; simpl digits2_Pnat.\nrewrite Zpos_xI, 2!Hp.\nlia.\nrewrite (Zpos_xO n), 2!Hp.\nlia.\nnow split."},{"statement":"(n : positive) (Hp : forall m : nat, Zpower_nat 2 (S m) = (2 * Zpower_nat 2 m)%Z) : (Zpower_nat 2 (digits2_Pnat n) <= Z.pos n < Zpower_nat 2 (S (digits2_Pnat n)))%Z.","conclusion":"(Zpower_nat 2 (digits2_Pnat n) <= Z.pos n < Zpower_nat 2 (S (digits2_Pnat n)))%Z","hypotheses":"(n : positive) (Hp : forall m : nat, Zpower_nat 2 (S m) = (2 * Zpower_nat 2 m)%Z)","proofString":"induction n ; simpl digits2_Pnat.\nrewrite Zpos_xI, 2!Hp.\nlia.\nrewrite (Zpos_xO n), 2!Hp.\nlia.\nnow split."},{"statement":"(n : Z) (k : positive) (Hk : (Z.neg k < 0)%Z) : Zdigit n (Z.neg k) = 0%Z.","conclusion":"Zdigit n (Z.neg k) = 0%Z","hypotheses":"(n : Z) (k : positive) (Hk : (Z.neg k < 0)%Z)","proofString":"now case n."},{"statement":"(k : Z) : Zdigit 0 k = 0%Z.","conclusion":"Zdigit 0 k = 0%Z","hypotheses":"(k : Z)","proofString":"unfold Zdigit.\nrewrite Zquot_0_l.\napply Zrem_0_l."},{"statement":"(k : Z) : Z.rem (0 ÷ beta ^ k) beta = 0%Z.","conclusion":"Z.rem (0 ÷ beta ^ k) beta = 0%Z","hypotheses":"(k : Z)","proofString":"rewrite Zquot_0_l.\napply Zrem_0_l."},{"statement":"(k : Z) : Z.rem 0 beta = 0%Z.","conclusion":"Z.rem 0 beta = 0%Z","hypotheses":"(k : Z)","proofString":"apply Zrem_0_l."},{"statement":"(n k : Z) : Zdigit (- n) k = (- Zdigit n k)%Z.","conclusion":"Zdigit (- n) k = (- Zdigit n k)%Z","hypotheses":"(n k : Z)","proofString":"unfold Zdigit.\nrewrite Zquot_opp_l.\napply Zrem_opp_l."},{"statement":"(n k : Z) : Z.rem (- n ÷ beta ^ k) beta = (- Z.rem (n ÷ beta ^ k) beta)%Z.","conclusion":"Z.rem (- n ÷ beta ^ k) beta = (- Z.rem (n ÷ beta ^ k) beta)%Z","hypotheses":"(n k : Z)","proofString":"rewrite Zquot_opp_l.\napply Zrem_opp_l."},{"statement":"(n k : Z) : Z.rem (- (n ÷ beta ^ k)) beta = (- Z.rem (n ÷ beta ^ k) beta)%Z.","conclusion":"Z.rem (- (n ÷ beta ^ k)) beta = (- Z.rem (n ÷ beta ^ k) beta)%Z","hypotheses":"(n k : Z)","proofString":"apply Zrem_opp_l."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : Zdigit n k = 0%Z.","conclusion":"Zdigit n k = 0%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"unfold Zdigit.\nrewrite Z.quot_small.\napply Zrem_0_l.\nsplit.\napply Hn.\napply Z.lt_le_trans with (1 := proj2 Hn).\nreplace k with (e + (k - e))%Z by ring.\nrewrite Zpower_plus.\nrewrite <- (Zmult_1_r (beta ^ e)) at 1.\napply Zmult_le_compat_l.\napply (Zlt_le_succ 0).\napply Zpower_gt_0.\nnow apply Zle_minus_le_0.\napply Zlt_le_weak.\nnow apply Z.le_lt_trans with n.\ngeneralize (Z.le_lt_trans _ _ _ (proj1 Hn) (proj2 Hn)).\nclear.\nnow destruct e as [|e|e].\nnow apply Zle_minus_le_0."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : Z.rem (n ÷ beta ^ k) beta = 0%Z.","conclusion":"Z.rem (n ÷ beta ^ k) beta = 0%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"rewrite Z.quot_small.\napply Zrem_0_l.\nsplit.\napply Hn.\napply Z.lt_le_trans with (1 := proj2 Hn).\nreplace k with (e + (k - e))%Z by ring.\nrewrite Zpower_plus.\nrewrite <- (Zmult_1_r (beta ^ e)) at 1.\napply Zmult_le_compat_l.\napply (Zlt_le_succ 0).\napply Zpower_gt_0.\nnow apply Zle_minus_le_0.\napply Zlt_le_weak.\nnow apply Z.le_lt_trans with n.\ngeneralize (Z.le_lt_trans _ _ _ (proj1 Hn) (proj2 Hn)).\nclear.\nnow destruct e as [|e|e].\nnow apply Zle_minus_le_0."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : Z.rem 0 beta = 0%Z.","conclusion":"Z.rem 0 beta = 0%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"apply Zrem_0_l."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (0 <= n < beta ^ k)%Z.","conclusion":"(0 <= n < beta ^ k)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"split.\napply Hn.\napply Z.lt_le_trans with (1 := proj2 Hn).\nreplace k with (e + (k - e))%Z by ring.\nrewrite Zpower_plus.\nrewrite <- (Zmult_1_r (beta ^ e)) at 1.\napply Zmult_le_compat_l.\napply (Zlt_le_succ 0).\napply Zpower_gt_0.\nnow apply Zle_minus_le_0.\napply Zlt_le_weak.\nnow apply Z.le_lt_trans with n.\ngeneralize (Z.le_lt_trans _ _ _ (proj1 Hn) (proj2 Hn)).\nclear.\nnow destruct e as [|e|e].\nnow apply Zle_minus_le_0."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (0 <= n)%Z.","conclusion":"(0 <= n)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"apply Hn."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (n < beta ^ k)%Z.","conclusion":"(n < beta ^ k)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"apply Z.lt_le_trans with (1 := proj2 Hn).\nreplace k with (e + (k - e))%Z by ring.\nrewrite Zpower_plus.\nrewrite <- (Zmult_1_r (beta ^ e)) at 1.\napply Zmult_le_compat_l.\napply (Zlt_le_succ 0).\napply Zpower_gt_0.\nnow apply Zle_minus_le_0.\napply Zlt_le_weak.\nnow apply Z.le_lt_trans with n.\ngeneralize (Z.le_lt_trans _ _ _ (proj1 Hn) (proj2 Hn)).\nclear.\nnow destruct e as [|e|e].\nnow apply Zle_minus_le_0."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (beta ^ e <= beta ^ k)%Z.","conclusion":"(beta ^ e <= beta ^ k)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"replace k with (e + (k - e))%Z by ring.\nrewrite Zpower_plus.\nrewrite <- (Zmult_1_r (beta ^ e)) at 1.\napply Zmult_le_compat_l.\napply (Zlt_le_succ 0).\napply Zpower_gt_0.\nnow apply Zle_minus_le_0.\napply Zlt_le_weak.\nnow apply Z.le_lt_trans with n.\ngeneralize (Z.le_lt_trans _ _ _ (proj1 Hn) (proj2 Hn)).\nclear.\nnow destruct e as [|e|e].\nnow apply Zle_minus_le_0."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (beta ^ e <= beta ^ (e + (k - e)))%Z.","conclusion":"(beta ^ e <= beta ^ (e + (k - e)))%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"rewrite Zpower_plus.\nrewrite <- (Zmult_1_r (beta ^ e)) at 1.\napply Zmult_le_compat_l.\napply (Zlt_le_succ 0).\napply Zpower_gt_0.\nnow apply Zle_minus_le_0.\napply Zlt_le_weak.\nnow apply Z.le_lt_trans with n.\ngeneralize (Z.le_lt_trans _ _ _ (proj1 Hn) (proj2 Hn)).\nclear.\nnow destruct e as [|e|e].\nnow apply Zle_minus_le_0."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (beta ^ e <= beta ^ e * beta ^ (k - e))%Z.","conclusion":"(beta ^ e <= beta ^ e * beta ^ (k - e))%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"rewrite <- (Zmult_1_r (beta ^ e)) at 1.\napply Zmult_le_compat_l.\napply (Zlt_le_succ 0).\napply Zpower_gt_0.\nnow apply Zle_minus_le_0.\napply Zlt_le_weak.\nnow apply Z.le_lt_trans with n."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (beta ^ e * 1 <= beta ^ e * beta ^ (k - e))%Z.","conclusion":"(beta ^ e * 1 <= beta ^ e * beta ^ (k - e))%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"apply Zmult_le_compat_l.\napply (Zlt_le_succ 0).\napply Zpower_gt_0.\nnow apply Zle_minus_le_0.\napply Zlt_le_weak.\nnow apply Z.le_lt_trans with n."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (1 <= beta ^ (k - e))%Z.","conclusion":"(1 <= beta ^ (k - e))%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"apply (Zlt_le_succ 0).\napply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (0 < beta ^ (k - e))%Z.","conclusion":"(0 < beta ^ (k - e))%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"apply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (0 <= k - e)%Z.","conclusion":"(0 <= k - e)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"now apply Zle_minus_le_0."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (0 <= beta ^ e)%Z.","conclusion":"(0 <= beta ^ e)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"apply Zlt_le_weak.\nnow apply Z.le_lt_trans with n."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (0 < beta ^ e)%Z.","conclusion":"(0 < beta ^ e)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"now apply Z.le_lt_trans with n."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (0 <= e)%Z.","conclusion":"(0 <= e)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"generalize (Z.le_lt_trans _ _ _ (proj1 Hn) (proj2 Hn)).\nclear.\nnow destruct e as [|e|e]."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (0 < beta ^ e)%Z -> (0 <= e)%Z.","conclusion":"(0 < beta ^ e)%Z -> (0 <= e)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"clear.\nnow destruct e as [|e|e]."},{"statement":"(e : Z) : (0 < beta ^ e)%Z -> (0 <= e)%Z.","conclusion":"(0 < beta ^ e)%Z -> (0 <= e)%Z","hypotheses":"(e : Z)","proofString":"now destruct e as [|e|e]."},{"statement":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z) : (0 <= k - e)%Z.","conclusion":"(0 <= k - e)%Z","hypotheses":"(e n : Z) (Hn : (0 <= n < beta ^ e)%Z) (k : Z) (Hk : (e <= k)%Z)","proofString":"now apply Zle_minus_le_0."},{"statement":"(e : Z) (Hn : (Z.abs 0 < beta ^ e)%Z) (k : Z) : (e <= k)%Z -> Zdigit 0 k = 0%Z.","conclusion":"(e <= k)%Z -> Zdigit 0 k = 0%Z","hypotheses":"(e : Z) (Hn : (Z.abs 0 < beta ^ e)%Z) (k : Z)","proofString":"easy."},{"statement":"(e : Z) (n : positive) (Hn : (Z.abs (Z.pos n) < beta ^ e)%Z) (k : Z) : (e <= k)%Z -> Zdigit (Z.pos n) k = 0%Z.","conclusion":"(e <= k)%Z -> Zdigit (Z.pos n) k = 0%Z","hypotheses":"(e : Z) (n : positive) (Hn : (Z.abs (Z.pos n) < beta ^ e)%Z) (k : Z)","proofString":"apply Zdigit_ge_Zpower_pos.\nnow split."},{"statement":"(e : Z) (n : positive) (Hn : (Z.abs (Z.pos n) < beta ^ e)%Z) (k : Z) : (0 <= Z.pos n < beta ^ e)%Z.","conclusion":"(0 <= Z.pos n < beta ^ e)%Z","hypotheses":"(e : Z) (n : positive) (Hn : (Z.abs (Z.pos n) < beta ^ e)%Z) (k : Z)","proofString":"now split."},{"statement":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) : (e <= k)%Z -> Zdigit (Z.neg n) k = 0%Z.","conclusion":"(e <= k)%Z -> Zdigit (Z.neg n) k = 0%Z","hypotheses":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z)","proofString":"intros He.\nchange (Zneg n) with (Z.opp (Zpos n)).\nrewrite Zdigit_opp.\nrewrite Zdigit_ge_Zpower_pos with (2 := He).\napply Z.opp_0.\nnow split."},{"statement":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z) : Zdigit (Z.neg n) k = 0%Z.","conclusion":"Zdigit (Z.neg n) k = 0%Z","hypotheses":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z)","proofString":"change (Zneg n) with (Z.opp (Zpos n)).\nrewrite Zdigit_opp.\nrewrite Zdigit_ge_Zpower_pos with (2 := He).\napply Z.opp_0.\nnow split."},{"statement":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z) : Zdigit (- Z.pos n) k = 0%Z.","conclusion":"Zdigit (- Z.pos n) k = 0%Z","hypotheses":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z)","proofString":"rewrite Zdigit_opp.\nrewrite Zdigit_ge_Zpower_pos with (2 := He).\napply Z.opp_0.\nnow split."},{"statement":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z) : (- Zdigit (Z.pos n) k)%Z = 0%Z.","conclusion":"(- Zdigit (Z.pos n) k)%Z = 0%Z","hypotheses":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z)","proofString":"rewrite Zdigit_ge_Zpower_pos with (2 := He).\napply Z.opp_0.\nnow split."},{"statement":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z) : (- 0)%Z = 0%Z.","conclusion":"(- 0)%Z = 0%Z","hypotheses":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z)","proofString":"apply Z.opp_0."},{"statement":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z) : (0 <= Z.pos n < beta ^ e)%Z.","conclusion":"(0 <= Z.pos n < beta ^ e)%Z","hypotheses":"(e : Z) (n : positive) (Hn : (Z.abs (Z.neg n) < beta ^ e)%Z) (k : Z) (He : (e <= k)%Z)","proofString":"now split."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : Zdigit n e <> 0%Z.","conclusion":"Zdigit n e <> 0%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"unfold Zdigit.\nrewrite <- ZOdiv_mod_mult.\nrewrite Z.rem_small.\nintros H.\napply Zle_not_lt with (1 := Hn1).\nrewrite (Z.quot_rem' n (beta ^ e)).\nrewrite H, Zmult_0_r, Zplus_0_l.\napply Zrem_lt_pos_pos.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nnow apply Zpower_gt_0.\nsplit.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nreplace (beta ^ e * beta)%Z with (beta ^ (e + 1))%Z.\nexact Hn2.\nrewrite <- (Zmult_1_r beta) at 3.\nnow apply (Zpower_plus beta e 1)."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : Z.rem (n ÷ beta ^ e) beta <> 0%Z.","conclusion":"Z.rem (n ÷ beta ^ e) beta <> 0%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"rewrite <- ZOdiv_mod_mult.\nrewrite Z.rem_small.\nintros H.\napply Zle_not_lt with (1 := Hn1).\nrewrite (Z.quot_rem' n (beta ^ e)).\nrewrite H, Zmult_0_r, Zplus_0_l.\napply Zrem_lt_pos_pos.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nnow apply Zpower_gt_0.\nsplit.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nreplace (beta ^ e * beta)%Z with (beta ^ (e + 1))%Z.\nexact Hn2.\nrewrite <- (Zmult_1_r beta) at 3.\nnow apply (Zpower_plus beta e 1)."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : (Z.rem n (beta ^ e * beta) ÷ beta ^ e)%Z <> 0%Z.","conclusion":"(Z.rem n (beta ^ e * beta) ÷ beta ^ e)%Z <> 0%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"rewrite Z.rem_small.\nintros H.\napply Zle_not_lt with (1 := Hn1).\nrewrite (Z.quot_rem' n (beta ^ e)).\nrewrite H, Zmult_0_r, Zplus_0_l.\napply Zrem_lt_pos_pos.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nnow apply Zpower_gt_0.\nsplit.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nreplace (beta ^ e * beta)%Z with (beta ^ (e + 1))%Z.\nexact Hn2.\nrewrite <- (Zmult_1_r beta) at 3.\nnow apply (Zpower_plus beta e 1)."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : (n ÷ beta ^ e)%Z <> 0%Z.","conclusion":"(n ÷ beta ^ e)%Z <> 0%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"intros H.\napply Zle_not_lt with (1 := Hn1).\nrewrite (Z.quot_rem' n (beta ^ e)).\nrewrite H, Zmult_0_r, Zplus_0_l.\napply Zrem_lt_pos_pos.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nnow apply Zpower_gt_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z) : False.","conclusion":"False","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z)","proofString":"apply Zle_not_lt with (1 := Hn1).\nrewrite (Z.quot_rem' n (beta ^ e)).\nrewrite H, Zmult_0_r, Zplus_0_l.\napply Zrem_lt_pos_pos.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nnow apply Zpower_gt_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z) : (n < beta ^ e)%Z.","conclusion":"(n < beta ^ e)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z)","proofString":"rewrite (Z.quot_rem' n (beta ^ e)).\nrewrite H, Zmult_0_r, Zplus_0_l.\napply Zrem_lt_pos_pos.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nnow apply Zpower_gt_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z) : (beta ^ e * (n ÷ beta ^ e) + Z.rem n (beta ^ e) < beta ^ e)%Z.","conclusion":"(beta ^ e * (n ÷ beta ^ e) + Z.rem n (beta ^ e) < beta ^ e)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z)","proofString":"rewrite H, Zmult_0_r, Zplus_0_l.\napply Zrem_lt_pos_pos.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nnow apply Zpower_gt_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z) : (Z.rem n (beta ^ e) < beta ^ e)%Z.","conclusion":"(Z.rem n (beta ^ e) < beta ^ e)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z)","proofString":"apply Zrem_lt_pos_pos.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nnow apply Zpower_gt_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z) : (0 <= n)%Z.","conclusion":"(0 <= n)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z)","proofString":"apply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z) : (0 <= beta ^ e)%Z.","conclusion":"(0 <= beta ^ e)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z)","proofString":"apply Zpower_ge_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z) : (0 < beta ^ e)%Z.","conclusion":"(0 < beta ^ e)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) (H : (n ÷ beta ^ e)%Z = 0%Z)","proofString":"now apply Zpower_gt_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : (0 <= n < beta ^ e * beta)%Z.","conclusion":"(0 <= n < beta ^ e * beta)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"split.\napply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0.\nreplace (beta ^ e * beta)%Z with (beta ^ (e + 1))%Z.\nexact Hn2.\nrewrite <- (Zmult_1_r beta) at 3.\nnow apply (Zpower_plus beta e 1)."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : (0 <= n)%Z.","conclusion":"(0 <= n)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"apply Z.le_trans with (2 := Hn1).\napply Zpower_ge_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : (0 <= beta ^ e)%Z.","conclusion":"(0 <= beta ^ e)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"apply Zpower_ge_0."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : (n < beta ^ e * beta)%Z.","conclusion":"(n < beta ^ e * beta)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"replace (beta ^ e * beta)%Z with (beta ^ (e + 1))%Z.\nexact Hn2.\nrewrite <- (Zmult_1_r beta) at 3.\nnow apply (Zpower_plus beta e 1)."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : (n < beta ^ (e + 1))%Z.","conclusion":"(n < beta ^ (e + 1))%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"exact Hn2."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : (beta ^ (e + 1))%Z = (beta ^ e * beta)%Z.","conclusion":"(beta ^ (e + 1))%Z = (beta ^ e * beta)%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"rewrite <- (Zmult_1_r beta) at 3.\nnow apply (Zpower_plus beta e 1)."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z) : (beta ^ (e + 1))%Z = (beta ^ e * (beta * 1))%Z.","conclusion":"(beta ^ (e + 1))%Z = (beta ^ e * (beta * 1))%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn1 : (beta ^ e <= n)%Z) (Hn2 : (n < beta ^ (e + 1))%Z)","proofString":"now apply (Zpower_plus beta e 1)."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= Z.abs n < beta ^ (e + 1))%Z) : Zdigit n e <> 0%Z.","conclusion":"Zdigit n e <> 0%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= Z.abs n < beta ^ (e + 1))%Z)","proofString":"destruct (Zle_or_lt 0 n) as [Hn'|Hn'].\nrewrite (Z.abs_eq _ Hn') in Hn.\nnow apply Zdigit_not_0_pos.\nintros H.\nrewrite (Zabs_non_eq n) in Hn by now apply Zlt_le_weak.\napply (Zdigit_not_0_pos _ _ He Hn).\nnow rewrite Zdigit_opp, H."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= Z.abs n < beta ^ (e + 1))%Z) (Hn' : (0 <= n)%Z) : Zdigit n e <> 0%Z.","conclusion":"Zdigit n e <> 0%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= Z.abs n < beta ^ (e + 1))%Z) (Hn' : (0 <= n)%Z)","proofString":"rewrite (Z.abs_eq _ Hn') in Hn.\nnow apply Zdigit_not_0_pos."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= n < beta ^ (e + 1))%Z) (Hn' : (0 <= n)%Z) : Zdigit n e <> 0%Z.","conclusion":"Zdigit n e <> 0%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= n < beta ^ (e + 1))%Z) (Hn' : (0 <= n)%Z)","proofString":"now apply Zdigit_not_0_pos."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= Z.abs n < beta ^ (e + 1))%Z) (Hn' : (n < 0)%Z) : Zdigit n e <> 0%Z.","conclusion":"Zdigit n e <> 0%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= Z.abs n < beta ^ (e + 1))%Z) (Hn' : (n < 0)%Z)","proofString":"intros H.\nrewrite (Zabs_non_eq n) in Hn by now apply Zlt_le_weak.\napply (Zdigit_not_0_pos _ _ He Hn).\nnow rewrite Zdigit_opp, H."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= Z.abs n < beta ^ (e + 1))%Z) (Hn' : (n < 0)%Z) (H : Zdigit n e = 0%Z) : False.","conclusion":"False","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= Z.abs n < beta ^ (e + 1))%Z) (Hn' : (n < 0)%Z) (H : Zdigit n e = 0%Z)","proofString":"rewrite (Zabs_non_eq n) in Hn by now apply Zlt_le_weak.\napply (Zdigit_not_0_pos _ _ He Hn).\nnow rewrite Zdigit_opp, H."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= - n < beta ^ (e + 1))%Z) (Hn' : (n < 0)%Z) (H : Zdigit n e = 0%Z) : False.","conclusion":"False","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= - n < beta ^ (e + 1))%Z) (Hn' : (n < 0)%Z) (H : Zdigit n e = 0%Z)","proofString":"apply (Zdigit_not_0_pos _ _ He Hn).\nnow rewrite Zdigit_opp, H."},{"statement":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= - n < beta ^ (e + 1))%Z) (Hn' : (n < 0)%Z) (H : Zdigit n e = 0%Z) : Zdigit (- n) e = 0%Z.","conclusion":"Zdigit (- n) e = 0%Z","hypotheses":"(e n : Z) (He : (0 <= e)%Z) (Hn : (beta ^ e <= - n < beta ^ (e + 1))%Z) (Hn' : (n < 0)%Z) (H : Zdigit n e = 0%Z)","proofString":"now rewrite Zdigit_opp, H."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) : Zdigit (n * beta ^ k') k = Zdigit n (k - k').","conclusion":"Zdigit (n * beta ^ k') k = Zdigit n (k - k')","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z)","proofString":"destruct (Zle_or_lt k' k) as [H|H].\nrevert k H.\npattern k' ; apply Zlt_0_ind with (2 := Hk').\nclear k' Hk'.\nintros k' IHk' Hk' k H.\nunfold Zdigit.\napply (f_equal (fun x => Z.rem x beta)).\npattern k at 1 ; replace k with (k - k' + k')%Z by ring.\nrewrite Zpower_plus with (2 := Hk').\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zle_minus_le_0.\ndestruct (Zle_or_lt 0 k) as [H0|H0].\nrewrite (Zdigit_lt n) by lia.\nunfold Zdigit.\nreplace k' with (k' - k + k)%Z by ring.\nrewrite Zpower_plus with (2 := H0).\nrewrite Zmult_assoc, Z_quot_mult.\nreplace (k' - k)%Z with (k' - k - 1 + 1)%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak.\nrewrite Zdigit_lt with (1 := H0).\napply sym_eq.\napply Zdigit_lt.\nlia."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k' <= k)%Z) : Zdigit (n * beta ^ k') k = Zdigit n (k - k').","conclusion":"Zdigit (n * beta ^ k') k = Zdigit n (k - k')","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k' <= k)%Z)","proofString":"revert k H.\npattern k' ; apply Zlt_0_ind with (2 := Hk').\nclear k' Hk'.\nintros k' IHk' Hk' k H.\nunfold Zdigit.\napply (f_equal (fun x => Z.rem x beta)).\npattern k at 1 ; replace k with (k - k' + k')%Z by ring.\nrewrite Zpower_plus with (2 := Hk').\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(n k' : Z) (Hk' : (0 <= k')%Z) : forall k : Z, (k' <= k)%Z -> Zdigit (n * beta ^ k') k = Zdigit n (k - k').","conclusion":"forall k : Z, (k' <= k)%Z -> Zdigit (n * beta ^ k') k = Zdigit n (k - k')","hypotheses":"(n k' : Z) (Hk' : (0 <= k')%Z)","proofString":"pattern k' ; apply Zlt_0_ind with (2 := Hk').\nclear k' Hk'.\nintros k' IHk' Hk' k H.\nunfold Zdigit.\napply (f_equal (fun x => Z.rem x beta)).\npattern k at 1 ; replace k with (k - k' + k')%Z by ring.\nrewrite Zpower_plus with (2 := Hk').\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(n k' : Z) (Hk' : (0 <= k')%Z) : forall x : Z,\n(forall y : Z,\n (0 <= y < x)%Z ->\n forall k : Z, (y <= k)%Z -> Zdigit (n * beta ^ y) k = Zdigit n (k - y)) ->\n(0 <= x)%Z ->\nforall k : Z, (x <= k)%Z -> Zdigit (n * beta ^ x) k = Zdigit n (k - x).","conclusion":"forall x : Z,\n(forall y : Z,\n (0 <= y < x)%Z ->\n forall k : Z, (y <= k)%Z -> Zdigit (n * beta ^ y) k = Zdigit n (k - y)) ->\n(0 <= x)%Z ->\nforall k : Z, (x <= k)%Z -> Zdigit (n * beta ^ x) k = Zdigit n (k - x)","hypotheses":"(n k' : Z) (Hk' : (0 <= k')%Z)","proofString":"clear k' Hk'.\nintros k' IHk' Hk' k H.\nunfold Zdigit.\napply (f_equal (fun x => Z.rem x beta)).\npattern k at 1 ; replace k with (k - k' + k')%Z by ring.\nrewrite Zpower_plus with (2 := Hk').\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(n : Z) : forall x : Z,\n(forall y : Z,\n (0 <= y < x)%Z ->\n forall k : Z, (y <= k)%Z -> Zdigit (n * beta ^ y) k = Zdigit n (k - y)) ->\n(0 <= x)%Z ->\nforall k : Z, (x <= k)%Z -> Zdigit (n * beta ^ x) k = Zdigit n (k - x).","conclusion":"forall x : Z,\n(forall y : Z,\n (0 <= y < x)%Z ->\n forall k : Z, (y <= k)%Z -> Zdigit (n * beta ^ y) k = Zdigit n (k - y)) ->\n(0 <= x)%Z ->\nforall k : Z, (x <= k)%Z -> Zdigit (n * beta ^ x) k = Zdigit n (k - x)","hypotheses":"(n : Z)","proofString":"intros k' IHk' Hk' k H.\nunfold Zdigit.\napply (f_equal (fun x => Z.rem x beta)).\npattern k at 1 ; replace k with (k - k' + k')%Z by ring.\nrewrite Zpower_plus with (2 := Hk').\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z) : Zdigit (n * beta ^ k') k = Zdigit n (k - k').","conclusion":"Zdigit (n * beta ^ k') k = Zdigit n (k - k')","hypotheses":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z)","proofString":"unfold Zdigit.\napply (f_equal (fun x => Z.rem x beta)).\npattern k at 1 ; replace k with (k - k' + k')%Z by ring.\nrewrite Zpower_plus with (2 := Hk').\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z) : Z.rem (n * beta ^ k' ÷ beta ^ k) beta = Z.rem (n ÷ beta ^ (k - k')) beta.","conclusion":"Z.rem (n * beta ^ k' ÷ beta ^ k) beta = Z.rem (n ÷ beta ^ (k - k')) beta","hypotheses":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z)","proofString":"apply (f_equal (fun x => Z.rem x beta)).\npattern k at 1 ; replace k with (k - k' + k')%Z by ring.\nrewrite Zpower_plus with (2 := Hk').\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z) : (n * beta ^ k' ÷ beta ^ k)%Z = (n ÷ beta ^ (k - k'))%Z.","conclusion":"(n * beta ^ k' ÷ beta ^ k)%Z = (n ÷ beta ^ (k - k'))%Z","hypotheses":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z)","proofString":"pattern k at 1 ; replace k with (k - k' + k')%Z by ring.\nrewrite Zpower_plus with (2 := Hk').\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z) : (n * beta ^ k' ÷ beta ^ (k - k' + k'))%Z = (n ÷ beta ^ (k - k'))%Z.","conclusion":"(n * beta ^ k' ÷ beta ^ (k - k' + k'))%Z = (n ÷ beta ^ (k - k'))%Z","hypotheses":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z)","proofString":"rewrite Zpower_plus with (2 := Hk').\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zle_minus_le_0."},{"statement":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z) : (n * beta ^ k' ÷ (beta ^ (k - k') * beta ^ k'))%Z = (n ÷ beta ^ (k - k'))%Z.","conclusion":"(n * beta ^ k' ÷ (beta ^ (k - k') * beta ^ k'))%Z = (n ÷ beta ^ (k - k'))%Z","hypotheses":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z)","proofString":"apply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z) : (beta ^ k')%Z <> 0%Z.","conclusion":"(beta ^ k')%Z <> 0%Z","hypotheses":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z)","proofString":"apply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z) : (0 < beta ^ k')%Z.","conclusion":"(0 < beta ^ k')%Z","hypotheses":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z)","proofString":"now apply Zpower_gt_0."},{"statement":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z) : (0 <= k - k')%Z.","conclusion":"(0 <= k - k')%Z","hypotheses":"(n k' : Z) (IHk' : forall y : Z,\n(0 <= y < k')%Z ->\nforall k0 : Z, (y <= k0)%Z -> Zdigit (n * beta ^ y) k0 = Zdigit n (k0 - y)) (Hk' : (0 <= k')%Z) (k : Z) (H : (k' <= k)%Z)","proofString":"now apply Zle_minus_le_0."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) : Zdigit (n * beta ^ k') k = Zdigit n (k - k').","conclusion":"Zdigit (n * beta ^ k') k = Zdigit n (k - k')","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z)","proofString":"destruct (Zle_or_lt 0 k) as [H0|H0].\nrewrite (Zdigit_lt n) by lia.\nunfold Zdigit.\nreplace k' with (k' - k + k)%Z by ring.\nrewrite Zpower_plus with (2 := H0).\nrewrite Zmult_assoc, Z_quot_mult.\nreplace (k' - k)%Z with (k' - k - 1 + 1)%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak.\nrewrite Zdigit_lt with (1 := H0).\napply sym_eq.\napply Zdigit_lt.\nlia."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Zdigit (n * beta ^ k') k = Zdigit n (k - k').","conclusion":"Zdigit (n * beta ^ k') k = Zdigit n (k - k')","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"rewrite (Zdigit_lt n) by lia.\nunfold Zdigit.\nreplace k' with (k' - k + k)%Z by ring.\nrewrite Zpower_plus with (2 := H0).\nrewrite Zmult_assoc, Z_quot_mult.\nreplace (k' - k)%Z with (k' - k - 1 + 1)%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Zdigit (n * beta ^ k') k = 0%Z.","conclusion":"Zdigit (n * beta ^ k') k = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"unfold Zdigit.\nreplace k' with (k' - k + k)%Z by ring.\nrewrite Zpower_plus with (2 := H0).\nrewrite Zmult_assoc, Z_quot_mult.\nreplace (k' - k)%Z with (k' - k - 1 + 1)%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Z.rem (n * beta ^ k' ÷ beta ^ k) beta = 0%Z.","conclusion":"Z.rem (n * beta ^ k' ÷ beta ^ k) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"replace k' with (k' - k + k)%Z by ring.\nrewrite Zpower_plus with (2 := H0).\nrewrite Zmult_assoc, Z_quot_mult.\nreplace (k' - k)%Z with (k' - k - 1 + 1)%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Z.rem (n * beta ^ (k' - k + k) ÷ beta ^ k) beta = 0%Z.","conclusion":"Z.rem (n * beta ^ (k' - k + k) ÷ beta ^ k) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"rewrite Zpower_plus with (2 := H0).\nrewrite Zmult_assoc, Z_quot_mult.\nreplace (k' - k)%Z with (k' - k - 1 + 1)%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Z.rem (n * (beta ^ (k' - k) * beta ^ k) ÷ beta ^ k) beta = 0%Z.","conclusion":"Z.rem (n * (beta ^ (k' - k) * beta ^ k) ÷ beta ^ k) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"rewrite Zmult_assoc, Z_quot_mult.\nreplace (k' - k)%Z with (k' - k - 1 + 1)%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Z.rem (n * beta ^ (k' - k)) beta = 0%Z.","conclusion":"Z.rem (n * beta ^ (k' - k)) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"replace (k' - k)%Z with (k' - k - 1 + 1)%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Z.rem (n * beta ^ (k' - k - 1 + 1)) beta = 0%Z.","conclusion":"Z.rem (n * beta ^ (k' - k - 1 + 1)) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"rewrite Zpower_exp by lia.\nrewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Z.rem (n * (beta ^ (k' - k - 1) * beta ^ 1)) beta = 0%Z.","conclusion":"Z.rem (n * (beta ^ (k' - k - 1) * beta ^ 1)) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"rewrite Zmult_assoc.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Z.rem (n * beta ^ (k' - k - 1) * beta ^ 1) beta = 0%Z.","conclusion":"Z.rem (n * beta ^ (k' - k - 1) * beta ^ 1) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"change (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply Z_rem_mult."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Z.rem (n * beta ^ (k' - k - 1) * (beta * 1)) beta = 0%Z.","conclusion":"Z.rem (n * beta ^ (k' - k - 1) * (beta * 1)) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"rewrite Zmult_1_r.\napply Z_rem_mult."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : Z.rem (n * beta ^ (k' - k - 1) * beta) beta = 0%Z.","conclusion":"Z.rem (n * beta ^ (k' - k - 1) * beta) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"apply Z_rem_mult."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : (beta ^ k)%Z <> 0%Z.","conclusion":"(beta ^ k)%Z <> 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"apply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : (0 < beta ^ k)%Z.","conclusion":"(0 < beta ^ k)%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"now apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : (0 <= k' - k)%Z.","conclusion":"(0 <= k' - k)%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"apply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z) : (k <= k')%Z.","conclusion":"(k <= k')%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (0 <= k)%Z)","proofString":"now apply Zlt_le_weak."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (k < 0)%Z) : Zdigit (n * beta ^ k') k = Zdigit n (k - k').","conclusion":"Zdigit (n * beta ^ k') k = Zdigit n (k - k')","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (k < 0)%Z)","proofString":"rewrite Zdigit_lt with (1 := H0).\napply sym_eq.\napply Zdigit_lt.\nlia."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (k < 0)%Z) : 0%Z = Zdigit n (k - k').","conclusion":"0%Z = Zdigit n (k - k')","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (k < 0)%Z)","proofString":"apply sym_eq.\napply Zdigit_lt.\nlia."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (k < 0)%Z) : Zdigit n (k - k') = 0%Z.","conclusion":"Zdigit n (k - k') = 0%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (k < 0)%Z)","proofString":"apply Zdigit_lt.\nlia."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (k < 0)%Z) : (k - k' < 0)%Z.","conclusion":"(k - k' < 0)%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (H : (k < k')%Z) (H0 : (k < 0)%Z)","proofString":"lia."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z) : Zdigit (n ÷ beta ^ k') k = Zdigit n (k + k').","conclusion":"Zdigit (n ÷ beta ^ k') k = Zdigit n (k + k')","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z)","proofString":"unfold Zdigit.\nrewrite Zquot_Zquot.\nrewrite Zplus_comm.\nnow rewrite Zpower_plus."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z) : Z.rem (n ÷ beta ^ k' ÷ beta ^ k) beta = Z.rem (n ÷ beta ^ (k + k')) beta.","conclusion":"Z.rem (n ÷ beta ^ k' ÷ beta ^ k) beta = Z.rem (n ÷ beta ^ (k + k')) beta","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z)","proofString":"rewrite Zquot_Zquot.\nrewrite Zplus_comm.\nnow rewrite Zpower_plus."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z) : Z.rem (n ÷ (beta ^ k' * beta ^ k)) beta = Z.rem (n ÷ beta ^ (k + k')) beta.","conclusion":"Z.rem (n ÷ (beta ^ k' * beta ^ k)) beta = Z.rem (n ÷ beta ^ (k + k')) beta","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z)","proofString":"rewrite Zplus_comm.\nnow rewrite Zpower_plus."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z) : Z.rem (n ÷ (beta ^ k' * beta ^ k)) beta = Z.rem (n ÷ beta ^ (k' + k)) beta.","conclusion":"Z.rem (n ÷ (beta ^ k' * beta ^ k)) beta = Z.rem (n ÷ beta ^ (k' + k)) beta","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z)","proofString":"now rewrite Zpower_plus."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) : Zdigit (Z.rem n (beta ^ k')) k = Zdigit n k.","conclusion":"Zdigit (Z.rem n (beta ^ k')) k = Zdigit n k","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z)","proofString":"destruct (Zle_or_lt 0 k) as [H|H].\nunfold Zdigit.\nrewrite <- 2!ZOdiv_mod_mult.\napply (f_equal (fun x => Z.quot x (beta ^ k))).\nreplace k' with (k + 1 + (k' - (k + 1)))%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_comm.\nrewrite Zpower_plus by easy.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply ZOmod_mod_mult.\nnow rewrite 2!Zdigit_lt."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : Zdigit (Z.rem n (beta ^ k')) k = Zdigit n k.","conclusion":"Zdigit (Z.rem n (beta ^ k')) k = Zdigit n k","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"unfold Zdigit.\nrewrite <- 2!ZOdiv_mod_mult.\napply (f_equal (fun x => Z.quot x (beta ^ k))).\nreplace k' with (k + 1 + (k' - (k + 1)))%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_comm.\nrewrite Zpower_plus by easy.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : Z.rem (Z.rem n (beta ^ k') ÷ beta ^ k) beta = Z.rem (n ÷ beta ^ k) beta.","conclusion":"Z.rem (Z.rem n (beta ^ k') ÷ beta ^ k) beta = Z.rem (n ÷ beta ^ k) beta","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"rewrite <- 2!ZOdiv_mod_mult.\napply (f_equal (fun x => Z.quot x (beta ^ k))).\nreplace k' with (k + 1 + (k' - (k + 1)))%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_comm.\nrewrite Zpower_plus by easy.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : (Z.rem (Z.rem n (beta ^ k')) (beta ^ k * beta) ÷ beta ^ k)%Z =\n(Z.rem n (beta ^ k * beta) ÷ beta ^ k)%Z.","conclusion":"(Z.rem (Z.rem n (beta ^ k')) (beta ^ k * beta) ÷ beta ^ k)%Z =\n(Z.rem n (beta ^ k * beta) ÷ beta ^ k)%Z","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"apply (f_equal (fun x => Z.quot x (beta ^ k))).\nreplace k' with (k + 1 + (k' - (k + 1)))%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_comm.\nrewrite Zpower_plus by easy.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : Z.rem (Z.rem n (beta ^ k')) (beta ^ k * beta) = Z.rem n (beta ^ k * beta).","conclusion":"Z.rem (Z.rem n (beta ^ k')) (beta ^ k * beta) = Z.rem n (beta ^ k * beta)","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"replace k' with (k + 1 + (k' - (k + 1)))%Z by ring.\nrewrite Zpower_exp by lia.\nrewrite Zmult_comm.\nrewrite Zpower_plus by easy.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : Z.rem (Z.rem n (beta ^ (k + 1 + (k' - (k + 1))))) (beta ^ k * beta) =\nZ.rem n (beta ^ k * beta).","conclusion":"Z.rem (Z.rem n (beta ^ (k + 1 + (k' - (k + 1))))) (beta ^ k * beta) =\nZ.rem n (beta ^ k * beta)","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"rewrite Zpower_exp by lia.\nrewrite Zmult_comm.\nrewrite Zpower_plus by easy.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : Z.rem (Z.rem n (beta ^ (k + 1) * beta ^ (k' - (k + 1)))) (beta ^ k * beta) =\nZ.rem n (beta ^ k * beta).","conclusion":"Z.rem (Z.rem n (beta ^ (k + 1) * beta ^ (k' - (k + 1)))) (beta ^ k * beta) =\nZ.rem n (beta ^ k * beta)","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"rewrite Zmult_comm.\nrewrite Zpower_plus by easy.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : Z.rem (Z.rem n (beta ^ (k' - (k + 1)) * beta ^ (k + 1))) (beta ^ k * beta) =\nZ.rem n (beta ^ k * beta).","conclusion":"Z.rem (Z.rem n (beta ^ (k' - (k + 1)) * beta ^ (k + 1))) (beta ^ k * beta) =\nZ.rem n (beta ^ k * beta)","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"rewrite Zpower_plus by easy.\nchange (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : Z.rem (Z.rem n (beta ^ (k' - (k + 1)) * (beta ^ k * beta ^ 1)))\n  (beta ^ k * beta) = Z.rem n (beta ^ k * beta).","conclusion":"Z.rem (Z.rem n (beta ^ (k' - (k + 1)) * (beta ^ k * beta ^ 1)))\n  (beta ^ k * beta) = Z.rem n (beta ^ k * beta)","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"change (Zpower beta 1) with (beta * 1)%Z.\nrewrite Zmult_1_r.\napply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : Z.rem (Z.rem n (beta ^ (k' - (k + 1)) * (beta ^ k * (beta * 1))))\n  (beta ^ k * beta) = Z.rem n (beta ^ k * beta).","conclusion":"Z.rem (Z.rem n (beta ^ (k' - (k + 1)) * (beta ^ k * (beta * 1))))\n  (beta ^ k * beta) = Z.rem n (beta ^ k * beta)","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"rewrite Zmult_1_r.\napply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z) : Z.rem (Z.rem n (beta ^ (k' - (k + 1)) * (beta ^ k * beta))) (beta ^ k * beta) =\nZ.rem n (beta ^ k * beta).","conclusion":"Z.rem (Z.rem n (beta ^ (k' - (k + 1)) * (beta ^ k * beta))) (beta ^ k * beta) =\nZ.rem n (beta ^ k * beta)","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (0 <= k)%Z)","proofString":"apply ZOmod_mod_mult."},{"statement":"(n k k' : Z) (Hk : (k < k')%Z) (H : (k < 0)%Z) : Zdigit (Z.rem n (beta ^ k')) k = Zdigit n k.","conclusion":"Zdigit (Z.rem n (beta ^ k')) k = Zdigit n k","hypotheses":"(n k k' : Z) (Hk : (k < k')%Z) (H : (k < 0)%Z)","proofString":"now rewrite 2!Zdigit_lt."},{"statement":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z) : Zdigit (Z.rem n (beta ^ k')) k = 0%Z.","conclusion":"Zdigit (Z.rem n (beta ^ k')) k = 0%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z)","proofString":"unfold Zdigit.\nrewrite ZOdiv_small_abs.\napply Zrem_0_l.\napply Z.lt_le_trans with (Zpower beta k').\nrewrite <- (Z.abs_eq (beta ^ k')) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zpower_le."},{"statement":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z) : Z.rem (Z.rem n (beta ^ k') ÷ beta ^ k) beta = 0%Z.","conclusion":"Z.rem (Z.rem n (beta ^ k') ÷ beta ^ k) beta = 0%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z)","proofString":"rewrite ZOdiv_small_abs.\napply Zrem_0_l.\napply Z.lt_le_trans with (Zpower beta k').\nrewrite <- (Z.abs_eq (beta ^ k')) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zpower_le."},{"statement":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z) : Z.rem 0 beta = 0%Z.","conclusion":"Z.rem 0 beta = 0%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z)","proofString":"apply Zrem_0_l."},{"statement":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z) : (Z.abs (Z.rem n (beta ^ k')) < beta ^ k)%Z.","conclusion":"(Z.abs (Z.rem n (beta ^ k')) < beta ^ k)%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z)","proofString":"apply Z.lt_le_trans with (Zpower beta k').\nrewrite <- (Z.abs_eq (beta ^ k')) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nnow apply Zpower_le."},{"statement":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z) : (Z.abs (Z.rem n (beta ^ k')) < beta ^ k')%Z.","conclusion":"(Z.abs (Z.rem n (beta ^ k')) < beta ^ k')%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z)","proofString":"rewrite <- (Z.abs_eq (beta ^ k')) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z) : (Z.abs (Z.rem n (beta ^ k')) < Z.abs (beta ^ k'))%Z.","conclusion":"(Z.abs (Z.rem n (beta ^ k')) < Z.abs (beta ^ k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z)","proofString":"apply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z) : (beta ^ k')%Z <> 0%Z.","conclusion":"(beta ^ k')%Z <> 0%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z)","proofString":"apply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z) : (0 < beta ^ k')%Z.","conclusion":"(0 < beta ^ k')%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z)","proofString":"now apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z) : (beta ^ k' <= beta ^ k)%Z.","conclusion":"(beta ^ k' <= beta ^ k)%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k' <= k)%Z)","proofString":"now apply Zpower_le."},{"statement":"(n : Z) : forall k : nat, Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k).","conclusion":"forall k : nat, Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)","hypotheses":"(n : Z)","proofString":"induction k.\napply sym_eq.\napply Z.rem_1_r.\nsimpl Zsum_digit.\nrewrite IHk.\nunfold Zdigit.\nrewrite <- ZOdiv_mod_mult.\nrewrite <- (ZOmod_mod_mult n beta).\nrewrite Zmult_comm.\nreplace (beta ^ Z_of_nat k * beta)%Z with (Zpower beta (Z_of_nat (S k))).\nrewrite Zplus_comm, Zmult_comm.\napply sym_eq.\napply Z.quot_rem'.\nrewrite inj_S.\nrewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) : Zsum_digit (Zdigit n) 0 = Z.rem n (beta ^ Z.of_nat 0).","conclusion":"Zsum_digit (Zdigit n) 0 = Z.rem n (beta ^ Z.of_nat 0)","hypotheses":"(n : Z)","proofString":"apply sym_eq.\napply Z.rem_1_r."},{"statement":"(n : Z) : Z.rem n (beta ^ Z.of_nat 0) = Zsum_digit (Zdigit n) 0.","conclusion":"Z.rem n (beta ^ Z.of_nat 0) = Zsum_digit (Zdigit n) 0","hypotheses":"(n : Z)","proofString":"apply Z.rem_1_r."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : Zsum_digit (Zdigit n) (S k) = Z.rem n (beta ^ Z.of_nat (S k)).","conclusion":"Zsum_digit (Zdigit n) (S k) = Z.rem n (beta ^ Z.of_nat (S k))","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"simpl Zsum_digit.\nrewrite IHk.\nunfold Zdigit.\nrewrite <- ZOdiv_mod_mult.\nrewrite <- (ZOmod_mod_mult n beta).\nrewrite Zmult_comm.\nreplace (beta ^ Z_of_nat k * beta)%Z with (Zpower beta (Z_of_nat (S k))).\nrewrite Zplus_comm, Zmult_comm.\napply sym_eq.\napply Z.quot_rem'.\nrewrite inj_S.\nrewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (Zsum_digit (Zdigit n) k + Zdigit n (Z.of_nat k) * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k)).","conclusion":"(Zsum_digit (Zdigit n) k + Zdigit n (Z.of_nat k) * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k))","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"rewrite IHk.\nunfold Zdigit.\nrewrite <- ZOdiv_mod_mult.\nrewrite <- (ZOmod_mod_mult n beta).\nrewrite Zmult_comm.\nreplace (beta ^ Z_of_nat k * beta)%Z with (Zpower beta (Z_of_nat (S k))).\nrewrite Zplus_comm, Zmult_comm.\napply sym_eq.\napply Z.quot_rem'.\nrewrite inj_S.\nrewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (Z.rem n (beta ^ Z.of_nat k) + Zdigit n (Z.of_nat k) * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k)).","conclusion":"(Z.rem n (beta ^ Z.of_nat k) + Zdigit n (Z.of_nat k) * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k))","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"unfold Zdigit.\nrewrite <- ZOdiv_mod_mult.\nrewrite <- (ZOmod_mod_mult n beta).\nrewrite Zmult_comm.\nreplace (beta ^ Z_of_nat k * beta)%Z with (Zpower beta (Z_of_nat (S k))).\nrewrite Zplus_comm, Zmult_comm.\napply sym_eq.\napply Z.quot_rem'.\nrewrite inj_S.\nrewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (Z.rem n (beta ^ Z.of_nat k) +\n Z.rem (n ÷ beta ^ Z.of_nat k) beta * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k)).","conclusion":"(Z.rem n (beta ^ Z.of_nat k) +\n Z.rem (n ÷ beta ^ Z.of_nat k) beta * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k))","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"rewrite <- ZOdiv_mod_mult.\nrewrite <- (ZOmod_mod_mult n beta).\nrewrite Zmult_comm.\nreplace (beta ^ Z_of_nat k * beta)%Z with (Zpower beta (Z_of_nat (S k))).\nrewrite Zplus_comm, Zmult_comm.\napply sym_eq.\napply Z.quot_rem'.\nrewrite inj_S.\nrewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (Z.rem n (beta ^ Z.of_nat k) +\n Z.rem n (beta ^ Z.of_nat k * beta) ÷ beta ^ Z.of_nat k * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k)).","conclusion":"(Z.rem n (beta ^ Z.of_nat k) +\n Z.rem n (beta ^ Z.of_nat k * beta) ÷ beta ^ Z.of_nat k * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k))","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"rewrite <- (ZOmod_mod_mult n beta).\nrewrite Zmult_comm.\nreplace (beta ^ Z_of_nat k * beta)%Z with (Zpower beta (Z_of_nat (S k))).\nrewrite Zplus_comm, Zmult_comm.\napply sym_eq.\napply Z.quot_rem'.\nrewrite inj_S.\nrewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (Z.rem (Z.rem n (beta * beta ^ Z.of_nat k)) (beta ^ Z.of_nat k) +\n Z.rem n (beta ^ Z.of_nat k * beta) ÷ beta ^ Z.of_nat k * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k)).","conclusion":"(Z.rem (Z.rem n (beta * beta ^ Z.of_nat k)) (beta ^ Z.of_nat k) +\n Z.rem n (beta ^ Z.of_nat k * beta) ÷ beta ^ Z.of_nat k * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k))","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"rewrite Zmult_comm.\nreplace (beta ^ Z_of_nat k * beta)%Z with (Zpower beta (Z_of_nat (S k))).\nrewrite Zplus_comm, Zmult_comm.\napply sym_eq.\napply Z.quot_rem'.\nrewrite inj_S.\nrewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (Z.rem (Z.rem n (beta ^ Z.of_nat k * beta)) (beta ^ Z.of_nat k) +\n Z.rem n (beta ^ Z.of_nat k * beta) ÷ beta ^ Z.of_nat k * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k)).","conclusion":"(Z.rem (Z.rem n (beta ^ Z.of_nat k * beta)) (beta ^ Z.of_nat k) +\n Z.rem n (beta ^ Z.of_nat k * beta) ÷ beta ^ Z.of_nat k * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k))","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"replace (beta ^ Z_of_nat k * beta)%Z with (Zpower beta (Z_of_nat (S k))).\nrewrite Zplus_comm, Zmult_comm.\napply sym_eq.\napply Z.quot_rem'.\nrewrite inj_S.\nrewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (Z.rem (Z.rem n (beta ^ Z.of_nat (S k))) (beta ^ Z.of_nat k) +\n Z.rem n (beta ^ Z.of_nat (S k)) ÷ beta ^ Z.of_nat k * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k)).","conclusion":"(Z.rem (Z.rem n (beta ^ Z.of_nat (S k))) (beta ^ Z.of_nat k) +\n Z.rem n (beta ^ Z.of_nat (S k)) ÷ beta ^ Z.of_nat k * beta ^ Z.of_nat k)%Z =\nZ.rem n (beta ^ Z.of_nat (S k))","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"rewrite Zplus_comm, Zmult_comm.\napply sym_eq.\napply Z.quot_rem'."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (beta ^ Z.of_nat k * (Z.rem n (beta ^ Z.of_nat (S k)) ÷ beta ^ Z.of_nat k) +\n Z.rem (Z.rem n (beta ^ Z.of_nat (S k))) (beta ^ Z.of_nat k))%Z =\nZ.rem n (beta ^ Z.of_nat (S k)).","conclusion":"(beta ^ Z.of_nat k * (Z.rem n (beta ^ Z.of_nat (S k)) ÷ beta ^ Z.of_nat k) +\n Z.rem (Z.rem n (beta ^ Z.of_nat (S k))) (beta ^ Z.of_nat k))%Z =\nZ.rem n (beta ^ Z.of_nat (S k))","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"apply sym_eq.\napply Z.quot_rem'."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : Z.rem n (beta ^ Z.of_nat (S k)) =\n(beta ^ Z.of_nat k * (Z.rem n (beta ^ Z.of_nat (S k)) ÷ beta ^ Z.of_nat k) +\n Z.rem (Z.rem n (beta ^ Z.of_nat (S k))) (beta ^ Z.of_nat k))%Z.","conclusion":"Z.rem n (beta ^ Z.of_nat (S k)) =\n(beta ^ Z.of_nat k * (Z.rem n (beta ^ Z.of_nat (S k)) ÷ beta ^ Z.of_nat k) +\n Z.rem (Z.rem n (beta ^ Z.of_nat (S k))) (beta ^ Z.of_nat k))%Z","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"apply Z.quot_rem'."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (beta ^ Z.of_nat (S k))%Z = (beta ^ Z.of_nat k * beta)%Z.","conclusion":"(beta ^ Z.of_nat (S k))%Z = (beta ^ Z.of_nat k * beta)%Z","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"rewrite inj_S.\nrewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (beta ^ Z.succ (Z.of_nat k))%Z = (beta ^ Z.of_nat k * beta)%Z.","conclusion":"(beta ^ Z.succ (Z.of_nat k))%Z = (beta ^ Z.of_nat k * beta)%Z","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"rewrite <- (Zmult_1_r beta) at 3.\napply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (beta ^ Z.succ (Z.of_nat k))%Z = (beta ^ Z.of_nat k * (beta * 1))%Z.","conclusion":"(beta ^ Z.succ (Z.of_nat k))%Z = (beta ^ Z.of_nat k * (beta * 1))%Z","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"apply Zpower_plus.\napply Zle_0_nat.\neasy."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (0 <= Z.of_nat k)%Z.","conclusion":"(0 <= Z.of_nat k)%Z","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"apply Zle_0_nat."},{"statement":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k)) : (0 <= 1)%Z.","conclusion":"(0 <= 1)%Z","hypotheses":"(n : Z) (k : nat) (IHk : Zsum_digit (Zdigit n) k = Z.rem n (beta ^ Z.of_nat k))","proofString":"easy."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : n1 = n2.","conclusion":"n1 = n2","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"rewrite <- (ZOmod_small_abs n1 (Zpower beta (Z.max (Z.abs n1) (Z.abs n2)))).\nrewrite <- (ZOmod_small_abs n2 (Zpower beta (Z.max (Z.abs n1) (Z.abs n2)))) at 2.\nreplace (Z.max (Z.abs n1) (Z.abs n2)) with (Z_of_nat (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2)))).\nrewrite <- 2!Zsum_digit_digit.\ninduction (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))).\neasy.\nsimpl.\nrewrite H, IHn.\napply refl_equal.\napply Zle_0_nat.\nrewrite inj_Zabs_nat.\napply Z.abs_eq.\napply Z.le_trans with (Z.abs n1).\napply Zabs_pos.\napply Z.le_max_l.\napply Z.lt_le_trans with (Zpower beta (Z.abs n2)).\napply Zpower_gt_id.\napply Zpower_le.\napply Z.le_max_r.\napply Z.lt_le_trans with (Zpower beta (Z.abs n1)).\napply Zpower_gt_id.\napply Zpower_le.\napply Z.le_max_l."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : Z.rem n1 (beta ^ Z.max (Z.abs n1) (Z.abs n2)) = n2.","conclusion":"Z.rem n1 (beta ^ Z.max (Z.abs n1) (Z.abs n2)) = n2","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"rewrite <- (ZOmod_small_abs n2 (Zpower beta (Z.max (Z.abs n1) (Z.abs n2)))) at 2.\nreplace (Z.max (Z.abs n1) (Z.abs n2)) with (Z_of_nat (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2)))).\nrewrite <- 2!Zsum_digit_digit.\ninduction (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))).\neasy.\nsimpl.\nrewrite H, IHn.\napply refl_equal.\napply Zle_0_nat.\nrewrite inj_Zabs_nat.\napply Z.abs_eq.\napply Z.le_trans with (Z.abs n1).\napply Zabs_pos.\napply Z.le_max_l.\napply Z.lt_le_trans with (Zpower beta (Z.abs n2)).\napply Zpower_gt_id.\napply Zpower_le.\napply Z.le_max_r."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : Z.rem n1 (beta ^ Z.max (Z.abs n1) (Z.abs n2)) =\nZ.rem n2 (beta ^ Z.max (Z.abs n1) (Z.abs n2)).","conclusion":"Z.rem n1 (beta ^ Z.max (Z.abs n1) (Z.abs n2)) =\nZ.rem n2 (beta ^ Z.max (Z.abs n1) (Z.abs n2))","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"replace (Z.max (Z.abs n1) (Z.abs n2)) with (Z_of_nat (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2)))).\nrewrite <- 2!Zsum_digit_digit.\ninduction (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))).\neasy.\nsimpl.\nrewrite H, IHn.\napply refl_equal.\napply Zle_0_nat.\nrewrite inj_Zabs_nat.\napply Z.abs_eq.\napply Z.le_trans with (Z.abs n1).\napply Zabs_pos.\napply Z.le_max_l."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : Z.rem n1 (beta ^ Z.of_nat (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2)))) =\nZ.rem n2 (beta ^ Z.of_nat (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2)))).","conclusion":"Z.rem n1 (beta ^ Z.of_nat (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2)))) =\nZ.rem n2 (beta ^ Z.of_nat (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))))","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"rewrite <- 2!Zsum_digit_digit.\ninduction (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))).\neasy.\nsimpl.\nrewrite H, IHn.\napply refl_equal.\napply Zle_0_nat."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : Zsum_digit (Zdigit n1) (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))) =\nZsum_digit (Zdigit n2) (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))).","conclusion":"Zsum_digit (Zdigit n1) (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))) =\nZsum_digit (Zdigit n2) (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2)))","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"induction (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))).\neasy.\nsimpl.\nrewrite H, IHn.\napply refl_equal.\napply Zle_0_nat."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : Zsum_digit (Zdigit n1) 0 = Zsum_digit (Zdigit n2) 0.","conclusion":"Zsum_digit (Zdigit n1) 0 = Zsum_digit (Zdigit n2) 0","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"easy."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) (n : nat) (IHn : Zsum_digit (Zdigit n1) n = Zsum_digit (Zdigit n2) n) : Zsum_digit (Zdigit n1) (S n) = Zsum_digit (Zdigit n2) (S n).","conclusion":"Zsum_digit (Zdigit n1) (S n) = Zsum_digit (Zdigit n2) (S n)","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) (n : nat) (IHn : Zsum_digit (Zdigit n1) n = Zsum_digit (Zdigit n2) n)","proofString":"simpl.\nrewrite H, IHn.\napply refl_equal.\napply Zle_0_nat."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) (n : nat) (IHn : Zsum_digit (Zdigit n1) n = Zsum_digit (Zdigit n2) n) : (Zsum_digit (Zdigit n1) n + Zdigit n1 (Z.of_nat n) * beta ^ Z.of_nat n)%Z =\n(Zsum_digit (Zdigit n2) n + Zdigit n2 (Z.of_nat n) * beta ^ Z.of_nat n)%Z.","conclusion":"(Zsum_digit (Zdigit n1) n + Zdigit n1 (Z.of_nat n) * beta ^ Z.of_nat n)%Z =\n(Zsum_digit (Zdigit n2) n + Zdigit n2 (Z.of_nat n) * beta ^ Z.of_nat n)%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) (n : nat) (IHn : Zsum_digit (Zdigit n1) n = Zsum_digit (Zdigit n2) n)","proofString":"rewrite H, IHn.\napply refl_equal.\napply Zle_0_nat."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) (n : nat) (IHn : Zsum_digit (Zdigit n1) n = Zsum_digit (Zdigit n2) n) : (Zsum_digit (Zdigit n2) n + Zdigit n2 (Z.of_nat n) * beta ^ Z.of_nat n)%Z =\n(Zsum_digit (Zdigit n2) n + Zdigit n2 (Z.of_nat n) * beta ^ Z.of_nat n)%Z.","conclusion":"(Zsum_digit (Zdigit n2) n + Zdigit n2 (Z.of_nat n) * beta ^ Z.of_nat n)%Z =\n(Zsum_digit (Zdigit n2) n + Zdigit n2 (Z.of_nat n) * beta ^ Z.of_nat n)%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) (n : nat) (IHn : Zsum_digit (Zdigit n1) n = Zsum_digit (Zdigit n2) n)","proofString":"apply refl_equal."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) (n : nat) (IHn : Zsum_digit (Zdigit n1) n = Zsum_digit (Zdigit n2) n) : (0 <= Z.of_nat n)%Z.","conclusion":"(0 <= Z.of_nat n)%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) (n : nat) (IHn : Zsum_digit (Zdigit n1) n = Zsum_digit (Zdigit n2) n)","proofString":"apply Zle_0_nat."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : Z.of_nat (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))) =\nZ.max (Z.abs n1) (Z.abs n2).","conclusion":"Z.of_nat (Z.abs_nat (Z.max (Z.abs n1) (Z.abs n2))) =\nZ.max (Z.abs n1) (Z.abs n2)","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"rewrite inj_Zabs_nat.\napply Z.abs_eq.\napply Z.le_trans with (Z.abs n1).\napply Zabs_pos.\napply Z.le_max_l."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : Z.abs (Z.max (Z.abs n1) (Z.abs n2)) = Z.max (Z.abs n1) (Z.abs n2).","conclusion":"Z.abs (Z.max (Z.abs n1) (Z.abs n2)) = Z.max (Z.abs n1) (Z.abs n2)","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Z.abs_eq.\napply Z.le_trans with (Z.abs n1).\napply Zabs_pos.\napply Z.le_max_l."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (0 <= Z.max (Z.abs n1) (Z.abs n2))%Z.","conclusion":"(0 <= Z.max (Z.abs n1) (Z.abs n2))%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Z.le_trans with (Z.abs n1).\napply Zabs_pos.\napply Z.le_max_l."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (0 <= Z.abs n1)%Z.","conclusion":"(0 <= Z.abs n1)%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Zabs_pos."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (Z.abs n1 <= Z.max (Z.abs n1) (Z.abs n2))%Z.","conclusion":"(Z.abs n1 <= Z.max (Z.abs n1) (Z.abs n2))%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Z.le_max_l."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (Z.abs n2 < beta ^ Z.max (Z.abs n1) (Z.abs n2))%Z.","conclusion":"(Z.abs n2 < beta ^ Z.max (Z.abs n1) (Z.abs n2))%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Z.lt_le_trans with (Zpower beta (Z.abs n2)).\napply Zpower_gt_id.\napply Zpower_le.\napply Z.le_max_r."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (Z.abs n2 < beta ^ Z.abs n2)%Z.","conclusion":"(Z.abs n2 < beta ^ Z.abs n2)%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Zpower_gt_id."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (beta ^ Z.abs n2 <= beta ^ Z.max (Z.abs n1) (Z.abs n2))%Z.","conclusion":"(beta ^ Z.abs n2 <= beta ^ Z.max (Z.abs n1) (Z.abs n2))%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Zpower_le.\napply Z.le_max_r."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (Z.abs n2 <= Z.max (Z.abs n1) (Z.abs n2))%Z.","conclusion":"(Z.abs n2 <= Z.max (Z.abs n1) (Z.abs n2))%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Z.le_max_r."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (Z.abs n1 < beta ^ Z.max (Z.abs n1) (Z.abs n2))%Z.","conclusion":"(Z.abs n1 < beta ^ Z.max (Z.abs n1) (Z.abs n2))%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Z.lt_le_trans with (Zpower beta (Z.abs n1)).\napply Zpower_gt_id.\napply Zpower_le.\napply Z.le_max_l."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (Z.abs n1 < beta ^ Z.abs n1)%Z.","conclusion":"(Z.abs n1 < beta ^ Z.abs n1)%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Zpower_gt_id."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (beta ^ Z.abs n1 <= beta ^ Z.max (Z.abs n1) (Z.abs n2))%Z.","conclusion":"(beta ^ Z.abs n1 <= beta ^ Z.max (Z.abs n1) (Z.abs n2))%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Zpower_le.\napply Z.le_max_l."},{"statement":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k) : (Z.abs n1 <= Z.max (Z.abs n1) (Z.abs n2))%Z.","conclusion":"(Z.abs n1 <= Z.max (Z.abs n1) (Z.abs n2))%Z","hypotheses":"(n1 n2 : Z) (H : forall k : Z, (0 <= k)%Z -> Zdigit n1 k = Zdigit n2 k)","proofString":"apply Z.le_max_l."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) : ((u + v) ÷ beta ^ n)%Z = (u ÷ beta ^ n + v ÷ beta ^ n)%Z.","conclusion":"((u + v) ÷ beta ^ n)%Z = (u ÷ beta ^ n + v ÷ beta ^ n)%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z)","proofString":"rewrite <- (Zplus_0_r (Z.quot u (Zpower beta n) + Z.quot v (Zpower beta n))).\nrewrite ZOdiv_plus with (1 := Huv).\nrewrite <- ZOmod_plus_pow_digit by assumption.\napply f_equal.\ndestruct (Zle_or_lt 0 n) as [Hn|Hn].\napply ZOdiv_small_abs.\nrewrite <- Z.abs_eq.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zpower_ge_0.\nclear -Hn.\ndestruct n as [|n|n] ; try easy.\napply Zquot_0_r."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) : ((u + v) ÷ beta ^ n)%Z = (u ÷ beta ^ n + v ÷ beta ^ n + 0)%Z.","conclusion":"((u + v) ÷ beta ^ n)%Z = (u ÷ beta ^ n + v ÷ beta ^ n + 0)%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z)","proofString":"rewrite ZOdiv_plus with (1 := Huv).\nrewrite <- ZOmod_plus_pow_digit by assumption.\napply f_equal.\ndestruct (Zle_or_lt 0 n) as [Hn|Hn].\napply ZOdiv_small_abs.\nrewrite <- Z.abs_eq.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zpower_ge_0.\nclear -Hn.\ndestruct n as [|n|n] ; try easy.\napply Zquot_0_r."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) : (u ÷ beta ^ n + v ÷ beta ^ n +\n (Z.rem u (beta ^ n) + Z.rem v (beta ^ n)) ÷ beta ^ n)%Z =\n(u ÷ beta ^ n + v ÷ beta ^ n + 0)%Z.","conclusion":"(u ÷ beta ^ n + v ÷ beta ^ n +\n (Z.rem u (beta ^ n) + Z.rem v (beta ^ n)) ÷ beta ^ n)%Z =\n(u ÷ beta ^ n + v ÷ beta ^ n + 0)%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z)","proofString":"rewrite <- ZOmod_plus_pow_digit by assumption.\napply f_equal.\ndestruct (Zle_or_lt 0 n) as [Hn|Hn].\napply ZOdiv_small_abs.\nrewrite <- Z.abs_eq.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zpower_ge_0.\nclear -Hn.\ndestruct n as [|n|n] ; try easy.\napply Zquot_0_r."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) : (u ÷ beta ^ n + v ÷ beta ^ n + Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z =\n(u ÷ beta ^ n + v ÷ beta ^ n + 0)%Z.","conclusion":"(u ÷ beta ^ n + v ÷ beta ^ n + Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z =\n(u ÷ beta ^ n + v ÷ beta ^ n + 0)%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z)","proofString":"apply f_equal.\ndestruct (Zle_or_lt 0 n) as [Hn|Hn].\napply ZOdiv_small_abs.\nrewrite <- Z.abs_eq.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zpower_ge_0.\nclear -Hn.\ndestruct n as [|n|n] ; try easy.\napply Zquot_0_r."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) : (Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z = 0%Z.","conclusion":"(Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z = 0%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z)","proofString":"destruct (Zle_or_lt 0 n) as [Hn|Hn].\napply ZOdiv_small_abs.\nrewrite <- Z.abs_eq.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zpower_ge_0.\nclear -Hn.\ndestruct n as [|n|n] ; try easy.\napply Zquot_0_r."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z) : (Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z = 0%Z.","conclusion":"(Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z = 0%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z)","proofString":"apply ZOdiv_small_abs.\nrewrite <- Z.abs_eq.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zpower_ge_0."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z) : (Z.abs (Z.rem (u + v) (beta ^ n)) < beta ^ n)%Z.","conclusion":"(Z.abs (Z.rem (u + v) (beta ^ n)) < beta ^ n)%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z)","proofString":"rewrite <- Z.abs_eq.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\napply Zpower_ge_0."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z) : (Z.abs (Z.rem (u + v) (beta ^ n)) < Z.abs (beta ^ n))%Z.","conclusion":"(Z.abs (Z.rem (u + v) (beta ^ n)) < Z.abs (beta ^ n))%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z)","proofString":"apply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z) : (beta ^ n)%Z <> 0%Z.","conclusion":"(beta ^ n)%Z <> 0%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z)","proofString":"apply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z) : (0 < beta ^ n)%Z.","conclusion":"(0 < beta ^ n)%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z)","proofString":"now apply Zpower_gt_0."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z) : (0 <= beta ^ n)%Z.","conclusion":"(0 <= beta ^ n)%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (0 <= n)%Z)","proofString":"apply Zpower_ge_0."},{"statement":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (n < 0)%Z) : (Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z = 0%Z.","conclusion":"(Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z = 0%Z","hypotheses":"(u v n : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k : Z, (0 <= k < n)%Z -> Zdigit u k = 0%Z \\/ Zdigit v k = 0%Z) (Hn : (n < 0)%Z)","proofString":"clear -Hn.\ndestruct n as [|n|n] ; try easy.\napply Zquot_0_r."},{"statement":"(u v n : Z) (Hn : (n < 0)%Z) : (Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z = 0%Z.","conclusion":"(Z.rem (u + v) (beta ^ n) ÷ beta ^ n)%Z = 0%Z","hypotheses":"(u v n : Z) (Hn : (n < 0)%Z)","proofString":"destruct n as [|n|n] ; try easy.\napply Zquot_0_r."},{"statement":"(u v : Z) (n : positive) (Hn : (Z.neg n < 0)%Z) : (Z.rem (u + v) (beta ^ Z.neg n) ÷ beta ^ Z.neg n)%Z = 0%Z.","conclusion":"(Z.rem (u + v) (beta ^ Z.neg n) ÷ beta ^ Z.neg n)%Z = 0%Z","hypotheses":"(u v : Z) (n : positive) (Hn : (Z.neg n < 0)%Z)","proofString":"apply Zquot_0_r."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) : Zdigit (u + v) k = (Zdigit u k + Zdigit v k)%Z.","conclusion":"Zdigit (u + v) k = (Zdigit u k + Zdigit v k)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z)","proofString":"destruct (Zle_or_lt 0 k) as [Hk|Hk].\nunfold Zdigit.\nrewrite ZOdiv_plus_pow_digit with (1 := Huv).\nrewrite <- (Zmult_1_r beta) at 3 5 7.\nchange (beta * 1)%Z with (beta ^1)%Z.\napply ZOmod_plus_pow_digit.\napply Zsame_sign_trans_weak with v.\nintros Zv ; rewrite Zv.\napply Zquot_0_l.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with u.\nintros Zu ; rewrite Zu.\napply Zquot_0_l.\nnow rewrite Zmult_comm.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\nintros k' (Hk1,Hk2).\nrewrite 2!Zdigit_div_pow by assumption.\napply Hd.\nnow apply Zplus_le_0_compat.\nintros k' (Hk1,Hk2).\nnow apply Hd.\nnow rewrite 3!Zdigit_lt."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : Zdigit (u + v) k = (Zdigit u k + Zdigit v k)%Z.","conclusion":"Zdigit (u + v) k = (Zdigit u k + Zdigit v k)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"unfold Zdigit.\nrewrite ZOdiv_plus_pow_digit with (1 := Huv).\nrewrite <- (Zmult_1_r beta) at 3 5 7.\nchange (beta * 1)%Z with (beta ^1)%Z.\napply ZOmod_plus_pow_digit.\napply Zsame_sign_trans_weak with v.\nintros Zv ; rewrite Zv.\napply Zquot_0_l.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with u.\nintros Zu ; rewrite Zu.\napply Zquot_0_l.\nnow rewrite Zmult_comm.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\nintros k' (Hk1,Hk2).\nrewrite 2!Zdigit_div_pow by assumption.\napply Hd.\nnow apply Zplus_le_0_compat.\nintros k' (Hk1,Hk2).\nnow apply Hd."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : Z.rem ((u + v) ÷ beta ^ k) beta =\n(Z.rem (u ÷ beta ^ k) beta + Z.rem (v ÷ beta ^ k) beta)%Z.","conclusion":"Z.rem ((u + v) ÷ beta ^ k) beta =\n(Z.rem (u ÷ beta ^ k) beta + Z.rem (v ÷ beta ^ k) beta)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"rewrite ZOdiv_plus_pow_digit with (1 := Huv).\nrewrite <- (Zmult_1_r beta) at 3 5 7.\nchange (beta * 1)%Z with (beta ^1)%Z.\napply ZOmod_plus_pow_digit.\napply Zsame_sign_trans_weak with v.\nintros Zv ; rewrite Zv.\napply Zquot_0_l.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with u.\nintros Zu ; rewrite Zu.\napply Zquot_0_l.\nnow rewrite Zmult_comm.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\nintros k' (Hk1,Hk2).\nrewrite 2!Zdigit_div_pow by assumption.\napply Hd.\nnow apply Zplus_le_0_compat.\nintros k' (Hk1,Hk2).\nnow apply Hd."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : Z.rem (u ÷ beta ^ k + v ÷ beta ^ k) beta =\n(Z.rem (u ÷ beta ^ k) beta + Z.rem (v ÷ beta ^ k) beta)%Z.","conclusion":"Z.rem (u ÷ beta ^ k + v ÷ beta ^ k) beta =\n(Z.rem (u ÷ beta ^ k) beta + Z.rem (v ÷ beta ^ k) beta)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"rewrite <- (Zmult_1_r beta) at 3 5 7.\nchange (beta * 1)%Z with (beta ^1)%Z.\napply ZOmod_plus_pow_digit.\napply Zsame_sign_trans_weak with v.\nintros Zv ; rewrite Zv.\napply Zquot_0_l.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with u.\nintros Zu ; rewrite Zu.\napply Zquot_0_l.\nnow rewrite Zmult_comm.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\nintros k' (Hk1,Hk2).\nrewrite 2!Zdigit_div_pow by assumption.\napply Hd.\nnow apply Zplus_le_0_compat."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : Z.rem (u ÷ beta ^ k + v ÷ beta ^ k) (beta * 1) =\n(Z.rem (u ÷ beta ^ k) (beta * 1) + Z.rem (v ÷ beta ^ k) (beta * 1))%Z.","conclusion":"Z.rem (u ÷ beta ^ k + v ÷ beta ^ k) (beta * 1) =\n(Z.rem (u ÷ beta ^ k) (beta * 1) + Z.rem (v ÷ beta ^ k) (beta * 1))%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"change (beta * 1)%Z with (beta ^1)%Z.\napply ZOmod_plus_pow_digit.\napply Zsame_sign_trans_weak with v.\nintros Zv ; rewrite Zv.\napply Zquot_0_l.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with u.\nintros Zu ; rewrite Zu.\napply Zquot_0_l.\nnow rewrite Zmult_comm.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\nintros k' (Hk1,Hk2).\nrewrite 2!Zdigit_div_pow by assumption.\napply Hd.\nnow apply Zplus_le_0_compat."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : Z.rem (u ÷ beta ^ k + v ÷ beta ^ k) (beta ^ 1) =\n(Z.rem (u ÷ beta ^ k) (beta ^ 1) + Z.rem (v ÷ beta ^ k) (beta ^ 1))%Z.","conclusion":"Z.rem (u ÷ beta ^ k + v ÷ beta ^ k) (beta ^ 1) =\n(Z.rem (u ÷ beta ^ k) (beta ^ 1) + Z.rem (v ÷ beta ^ k) (beta ^ 1))%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"apply ZOmod_plus_pow_digit.\napply Zsame_sign_trans_weak with v.\nintros Zv ; rewrite Zv.\napply Zquot_0_l.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with u.\nintros Zu ; rewrite Zu.\napply Zquot_0_l.\nnow rewrite Zmult_comm.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\nintros k' (Hk1,Hk2).\nrewrite 2!Zdigit_div_pow by assumption.\napply Hd.\nnow apply Zplus_le_0_compat."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : (0 <= u ÷ beta ^ k * (v ÷ beta ^ k))%Z.","conclusion":"(0 <= u ÷ beta ^ k * (v ÷ beta ^ k))%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zsame_sign_trans_weak with v.\nintros Zv ; rewrite Zv.\napply Zquot_0_l.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with u.\nintros Zu ; rewrite Zu.\napply Zquot_0_l.\nnow rewrite Zmult_comm.\napply Zsame_sign_odiv.\napply Zpower_ge_0.\napply Zsame_sign_odiv.\napply Zpower_ge_0."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : v = 0%Z -> (v ÷ beta ^ k)%Z = 0%Z.","conclusion":"v = 0%Z -> (v ÷ beta ^ k)%Z = 0%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"intros Zv ; rewrite Zv.\napply Zquot_0_l."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (Zv : v = 0%Z) : (0 ÷ beta ^ k)%Z = 0%Z.","conclusion":"(0 ÷ beta ^ k)%Z = 0%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (Zv : v = 0%Z)","proofString":"apply Zquot_0_l."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : (0 <= u ÷ beta ^ k * v)%Z.","conclusion":"(0 <= u ÷ beta ^ k * v)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"rewrite Zmult_comm.\napply Zsame_sign_trans_weak with u.\nintros Zu ; rewrite Zu.\napply Zquot_0_l.\nnow rewrite Zmult_comm.\napply Zsame_sign_odiv.\napply Zpower_ge_0."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : (0 <= v * (u ÷ beta ^ k))%Z.","conclusion":"(0 <= v * (u ÷ beta ^ k))%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zsame_sign_trans_weak with u.\nintros Zu ; rewrite Zu.\napply Zquot_0_l.\nnow rewrite Zmult_comm.\napply Zsame_sign_odiv.\napply Zpower_ge_0."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : u = 0%Z -> (u ÷ beta ^ k)%Z = 0%Z.","conclusion":"u = 0%Z -> (u ÷ beta ^ k)%Z = 0%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"intros Zu ; rewrite Zu.\napply Zquot_0_l."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (Zu : u = 0%Z) : (0 ÷ beta ^ k)%Z = 0%Z.","conclusion":"(0 ÷ beta ^ k)%Z = 0%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (Zu : u = 0%Z)","proofString":"apply Zquot_0_l."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : (0 <= v * u)%Z.","conclusion":"(0 <= v * u)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"now rewrite Zmult_comm."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : (0 <= u * (u ÷ beta ^ k))%Z.","conclusion":"(0 <= u * (u ÷ beta ^ k))%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zsame_sign_odiv.\napply Zpower_ge_0."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : (0 <= beta ^ k)%Z.","conclusion":"(0 <= beta ^ k)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zpower_ge_0."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : (0 <= v * (v ÷ beta ^ k))%Z.","conclusion":"(0 <= v * (v ÷ beta ^ k))%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zsame_sign_odiv.\napply Zpower_ge_0."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : (0 <= beta ^ k)%Z.","conclusion":"(0 <= beta ^ k)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zpower_ge_0."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : forall k0 : Z,\n(0 <= k0 < 1)%Z ->\nZdigit (u ÷ beta ^ k) k0 = 0%Z \\/ Zdigit (v ÷ beta ^ k) k0 = 0%Z.","conclusion":"forall k0 : Z,\n(0 <= k0 < 1)%Z ->\nZdigit (u ÷ beta ^ k) k0 = 0%Z \\/ Zdigit (v ÷ beta ^ k) k0 = 0%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"intros k' (Hk1,Hk2).\nrewrite 2!Zdigit_div_pow by assumption.\napply Hd.\nnow apply Zplus_le_0_compat."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk1 : (0 <= k')%Z) (Hk2 : (k' < 1)%Z) : Zdigit (u ÷ beta ^ k) k' = 0%Z \\/ Zdigit (v ÷ beta ^ k) k' = 0%Z.","conclusion":"Zdigit (u ÷ beta ^ k) k' = 0%Z \\/ Zdigit (v ÷ beta ^ k) k' = 0%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk1 : (0 <= k')%Z) (Hk2 : (k' < 1)%Z)","proofString":"rewrite 2!Zdigit_div_pow by assumption.\napply Hd.\nnow apply Zplus_le_0_compat."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk1 : (0 <= k')%Z) (Hk2 : (k' < 1)%Z) : Zdigit u (k' + k) = 0%Z \\/ Zdigit v (k' + k) = 0%Z.","conclusion":"Zdigit u (k' + k) = 0%Z \\/ Zdigit v (k' + k) = 0%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk1 : (0 <= k')%Z) (Hk2 : (k' < 1)%Z)","proofString":"apply Hd.\nnow apply Zplus_le_0_compat."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk1 : (0 <= k')%Z) (Hk2 : (k' < 1)%Z) : (0 <= k' + k)%Z.","conclusion":"(0 <= k' + k)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk1 : (0 <= k')%Z) (Hk2 : (k' < 1)%Z)","proofString":"now apply Zplus_le_0_compat."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) : forall k0 : Z, (0 <= k0 < k)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z.","conclusion":"forall k0 : Z, (0 <= k0 < k)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"intros k' (Hk1,Hk2).\nnow apply Hd."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk1 : (0 <= k')%Z) (Hk2 : (k' < k)%Z) : Zdigit u k' = 0%Z \\/ Zdigit v k' = 0%Z.","conclusion":"Zdigit u k' = 0%Z \\/ Zdigit v k' = 0%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk1 : (0 <= k')%Z) (Hk2 : (k' < k)%Z)","proofString":"now apply Hd."},{"statement":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (k < 0)%Z) : Zdigit (u + v) k = (Zdigit u k + Zdigit v k)%Z.","conclusion":"Zdigit (u + v) k = (Zdigit u k + Zdigit v k)%Z","hypotheses":"(u v : Z) (Huv : (0 <= u * v)%Z) (Hd : forall k0 : Z, (0 <= k0)%Z -> Zdigit u k0 = 0%Z \\/ Zdigit v k0 = 0%Z) (k : Z) (Hk : (k < 0)%Z)","proofString":"now rewrite 3!Zdigit_lt."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) : Zdigit (Zscale n k) k' = Zdigit n (k' - k).","conclusion":"Zdigit (Zscale n k) k' = Zdigit n (k' - k)","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z)","proofString":"unfold Zscale.\ncase Zle_bool_spec ; intros Hk.\nnow apply Zdigit_mul_pow.\napply Zdigit_div_pow with (1 := Hk').\nlia."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) : Zdigit (if (0 <=? k)%Z then (n * beta ^ k)%Z else (n ÷ beta ^ (- k))%Z) k' =\nZdigit n (k' - k).","conclusion":"Zdigit (if (0 <=? k)%Z then (n * beta ^ k)%Z else (n ÷ beta ^ (- k))%Z) k' =\nZdigit n (k' - k)","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z)","proofString":"case Zle_bool_spec ; intros Hk.\nnow apply Zdigit_mul_pow.\napply Zdigit_div_pow with (1 := Hk').\nlia."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (Hk : (0 <= k)%Z) : Zdigit (n * beta ^ k) k' = Zdigit n (k' - k).","conclusion":"Zdigit (n * beta ^ k) k' = Zdigit n (k' - k)","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (Hk : (0 <= k)%Z)","proofString":"now apply Zdigit_mul_pow."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (Hk : (k < 0)%Z) : Zdigit (n ÷ beta ^ (- k)) k' = Zdigit n (k' - k).","conclusion":"Zdigit (n ÷ beta ^ (- k)) k' = Zdigit n (k' - k)","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (Hk : (k < 0)%Z)","proofString":"apply Zdigit_div_pow with (1 := Hk').\nlia."},{"statement":"(n k k' : Z) (Hk' : (0 <= k')%Z) (Hk : (k < 0)%Z) : (0 <= - k)%Z.","conclusion":"(0 <= - k)%Z","hypotheses":"(n k k' : Z) (Hk' : (0 <= k')%Z) (Hk : (k < 0)%Z)","proofString":"lia."},{"statement":"(k : Z) : Zscale 0 k = 0%Z.","conclusion":"Zscale 0 k = 0%Z","hypotheses":"(k : Z)","proofString":"unfold Zscale.\ncase Zle_bool.\napply Zmult_0_l.\napply Zquot_0_l."},{"statement":"(k : Z) : (if (0 <=? k)%Z then (0 * beta ^ k)%Z else (0 ÷ beta ^ (- k))%Z) = 0%Z.","conclusion":"(if (0 <=? k)%Z then (0 * beta ^ k)%Z else (0 ÷ beta ^ (- k))%Z) = 0%Z","hypotheses":"(k : Z)","proofString":"case Zle_bool.\napply Zmult_0_l.\napply Zquot_0_l."},{"statement":"(k : Z) : (0 * beta ^ k)%Z = 0%Z.","conclusion":"(0 * beta ^ k)%Z = 0%Z","hypotheses":"(k : Z)","proofString":"apply Zmult_0_l."},{"statement":"(k : Z) : (0 ÷ beta ^ (- k))%Z = 0%Z.","conclusion":"(0 ÷ beta ^ (- k))%Z = 0%Z","hypotheses":"(k : Z)","proofString":"apply Zquot_0_l."},{"statement":"(n k : Z) : (0 <= n * Zscale n k)%Z.","conclusion":"(0 <= n * Zscale n k)%Z","hypotheses":"(n k : Z)","proofString":"unfold Zscale.\ncase Zle_bool_spec ; intros Hk.\nrewrite Zmult_assoc.\napply Zmult_le_0_compat.\napply Zsame_sign_imp ; apply Zlt_le_weak.\napply Zpower_ge_0.\napply Zsame_sign_odiv.\napply Zpower_ge_0."},{"statement":"(n k : Z) : (0 <= n * (if 0 <=? k then n * beta ^ k else n ÷ beta ^ (- k)))%Z.","conclusion":"(0 <= n * (if 0 <=? k then n * beta ^ k else n ÷ beta ^ (- k)))%Z","hypotheses":"(n k : Z)","proofString":"case Zle_bool_spec ; intros Hk.\nrewrite Zmult_assoc.\napply Zmult_le_0_compat.\napply Zsame_sign_imp ; apply Zlt_le_weak.\napply Zpower_ge_0.\napply Zsame_sign_odiv.\napply Zpower_ge_0."},{"statement":"(n k : Z) (Hk : (0 <= k)%Z) : (0 <= n * (n * beta ^ k))%Z.","conclusion":"(0 <= n * (n * beta ^ k))%Z","hypotheses":"(n k : Z) (Hk : (0 <= k)%Z)","proofString":"rewrite Zmult_assoc.\napply Zmult_le_0_compat.\napply Zsame_sign_imp ; apply Zlt_le_weak.\napply Zpower_ge_0."},{"statement":"(n k : Z) (Hk : (0 <= k)%Z) : (0 <= n * n * beta ^ k)%Z.","conclusion":"(0 <= n * n * beta ^ k)%Z","hypotheses":"(n k : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zmult_le_0_compat.\napply Zsame_sign_imp ; apply Zlt_le_weak.\napply Zpower_ge_0."},{"statement":"(n k : Z) (Hk : (0 <= k)%Z) : (0 <= n * n)%Z.","conclusion":"(0 <= n * n)%Z","hypotheses":"(n k : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zsame_sign_imp ; apply Zlt_le_weak."},{"statement":"(n k : Z) (Hk : (0 <= k)%Z) : (0 <= beta ^ k)%Z.","conclusion":"(0 <= beta ^ k)%Z","hypotheses":"(n k : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zpower_ge_0."},{"statement":"(n k : Z) (Hk : (k < 0)%Z) : (0 <= n * (n ÷ beta ^ (- k)))%Z.","conclusion":"(0 <= n * (n ÷ beta ^ (- k)))%Z","hypotheses":"(n k : Z) (Hk : (k < 0)%Z)","proofString":"apply Zsame_sign_odiv.\napply Zpower_ge_0."},{"statement":"(n k : Z) (Hk : (k < 0)%Z) : (0 <= beta ^ (- k))%Z.","conclusion":"(0 <= beta ^ (- k))%Z","hypotheses":"(n k : Z) (Hk : (k < 0)%Z)","proofString":"apply Zpower_ge_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) : Zscale (n * beta ^ k) k' = Zscale n (k + k').","conclusion":"Zscale (n * beta ^ k) k' = Zscale n (k + k')","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z)","proofString":"unfold Zscale.\ncase Zle_bool_spec ; intros Hk'.\nrewrite Zle_bool_true.\nrewrite <- Zmult_assoc.\napply f_equal.\nnow rewrite Zpower_plus.\nnow apply Zplus_le_0_compat.\ncase Zle_bool_spec ; intros Hk''.\npattern k at 1 ; replace k with (k + k' + -k')%Z by ring.\nassert (0 <= -k')%Z by lia.\nrewrite Zpower_plus by easy.\nrewrite Zmult_assoc, Z_quot_mult.\napply refl_equal.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nreplace (-k')%Z with (-(k+k') + k)%Z by ring.\nrewrite Zpower_plus with (2 := Hk).\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nlia."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) : (if (0 <=? k')%Z\n then (n * beta ^ k * beta ^ k')%Z\n else (n * beta ^ k ÷ beta ^ (- k'))%Z) =\n(if (0 <=? k + k')%Z\n then (n * beta ^ (k + k'))%Z\n else (n ÷ beta ^ (- (k + k')))%Z).","conclusion":"(if (0 <=? k')%Z\n then (n * beta ^ k * beta ^ k')%Z\n else (n * beta ^ k ÷ beta ^ (- k'))%Z) =\n(if (0 <=? k + k')%Z\n then (n * beta ^ (k + k'))%Z\n else (n ÷ beta ^ (- (k + k')))%Z)","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z)","proofString":"case Zle_bool_spec ; intros Hk'.\nrewrite Zle_bool_true.\nrewrite <- Zmult_assoc.\napply f_equal.\nnow rewrite Zpower_plus.\nnow apply Zplus_le_0_compat.\ncase Zle_bool_spec ; intros Hk''.\npattern k at 1 ; replace k with (k + k' + -k')%Z by ring.\nassert (0 <= -k')%Z by lia.\nrewrite Zpower_plus by easy.\nrewrite Zmult_assoc, Z_quot_mult.\napply refl_equal.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nreplace (-k')%Z with (-(k+k') + k)%Z by ring.\nrewrite Zpower_plus with (2 := Hk).\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nlia."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z) : (n * beta ^ k * beta ^ k')%Z =\n(if (0 <=? k + k')%Z\n then (n * beta ^ (k + k'))%Z\n else (n ÷ beta ^ (- (k + k')))%Z).","conclusion":"(n * beta ^ k * beta ^ k')%Z =\n(if (0 <=? k + k')%Z\n then (n * beta ^ (k + k'))%Z\n else (n ÷ beta ^ (- (k + k')))%Z)","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z)","proofString":"rewrite Zle_bool_true.\nrewrite <- Zmult_assoc.\napply f_equal.\nnow rewrite Zpower_plus.\nnow apply Zplus_le_0_compat."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z) : (n * beta ^ k * beta ^ k')%Z = (n * beta ^ (k + k'))%Z.","conclusion":"(n * beta ^ k * beta ^ k')%Z = (n * beta ^ (k + k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z)","proofString":"rewrite <- Zmult_assoc.\napply f_equal.\nnow rewrite Zpower_plus."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z) : (n * (beta ^ k * beta ^ k'))%Z = (n * beta ^ (k + k'))%Z.","conclusion":"(n * (beta ^ k * beta ^ k'))%Z = (n * beta ^ (k + k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z)","proofString":"apply f_equal.\nnow rewrite Zpower_plus."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z) : (beta ^ k * beta ^ k')%Z = (beta ^ (k + k'))%Z.","conclusion":"(beta ^ k * beta ^ k')%Z = (beta ^ (k + k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z)","proofString":"now rewrite Zpower_plus."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z) : (0 <= k + k')%Z.","conclusion":"(0 <= k + k')%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (0 <= k')%Z)","proofString":"now apply Zplus_le_0_compat."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) : (n * beta ^ k ÷ beta ^ (- k'))%Z =\n(if (0 <=? k + k')%Z\n then (n * beta ^ (k + k'))%Z\n else (n ÷ beta ^ (- (k + k')))%Z).","conclusion":"(n * beta ^ k ÷ beta ^ (- k'))%Z =\n(if (0 <=? k + k')%Z\n then (n * beta ^ (k + k'))%Z\n else (n ÷ beta ^ (- (k + k')))%Z)","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z)","proofString":"case Zle_bool_spec ; intros Hk''.\npattern k at 1 ; replace k with (k + k' + -k')%Z by ring.\nassert (0 <= -k')%Z by lia.\nrewrite Zpower_plus by easy.\nrewrite Zmult_assoc, Z_quot_mult.\napply refl_equal.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nreplace (-k')%Z with (-(k+k') + k)%Z by ring.\nrewrite Zpower_plus with (2 := Hk).\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nlia."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) : (n * beta ^ k ÷ beta ^ (- k'))%Z = (n * beta ^ (k + k'))%Z.","conclusion":"(n * beta ^ k ÷ beta ^ (- k'))%Z = (n * beta ^ (k + k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z)","proofString":"pattern k at 1 ; replace k with (k + k' + -k')%Z by ring.\nassert (0 <= -k')%Z by lia.\nrewrite Zpower_plus by easy.\nrewrite Zmult_assoc, Z_quot_mult.\napply refl_equal.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) : (n * beta ^ (k + k' + - k') ÷ beta ^ (- k'))%Z = (n * beta ^ (k + k'))%Z.","conclusion":"(n * beta ^ (k + k' + - k') ÷ beta ^ (- k'))%Z = (n * beta ^ (k + k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z)","proofString":"assert (0 <= -k')%Z by lia.\nrewrite Zpower_plus by easy.\nrewrite Zmult_assoc, Z_quot_mult.\napply refl_equal.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z) : (n * beta ^ (k + k' + - k') ÷ beta ^ (- k'))%Z = (n * beta ^ (k + k'))%Z.","conclusion":"(n * beta ^ (k + k' + - k') ÷ beta ^ (- k'))%Z = (n * beta ^ (k + k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z)","proofString":"rewrite Zpower_plus by easy.\nrewrite Zmult_assoc, Z_quot_mult.\napply refl_equal.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z) : (n * (beta ^ (k + k') * beta ^ (- k')) ÷ beta ^ (- k'))%Z =\n(n * beta ^ (k + k'))%Z.","conclusion":"(n * (beta ^ (k + k') * beta ^ (- k')) ÷ beta ^ (- k'))%Z =\n(n * beta ^ (k + k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z)","proofString":"rewrite Zmult_assoc, Z_quot_mult.\napply refl_equal.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z) : (n * beta ^ (k + k'))%Z = (n * beta ^ (k + k'))%Z.","conclusion":"(n * beta ^ (k + k'))%Z = (n * beta ^ (k + k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z)","proofString":"apply refl_equal."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z) : (beta ^ (- k'))%Z <> 0%Z.","conclusion":"(beta ^ (- k'))%Z <> 0%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z)","proofString":"apply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z) : (0 < beta ^ (- k'))%Z.","conclusion":"(0 < beta ^ (- k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (0 <= k + k')%Z) (H : (0 <= - k')%Z)","proofString":"now apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z) : (n * beta ^ k ÷ beta ^ (- k'))%Z = (n ÷ beta ^ (- (k + k')))%Z.","conclusion":"(n * beta ^ k ÷ beta ^ (- k'))%Z = (n ÷ beta ^ (- (k + k')))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z)","proofString":"replace (-k')%Z with (-(k+k') + k)%Z by ring.\nrewrite Zpower_plus with (2 := Hk).\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nlia."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z) : (n * beta ^ k ÷ beta ^ (- (k + k') + k))%Z = (n ÷ beta ^ (- (k + k')))%Z.","conclusion":"(n * beta ^ k ÷ beta ^ (- (k + k') + k))%Z = (n ÷ beta ^ (- (k + k')))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z)","proofString":"rewrite Zpower_plus with (2 := Hk).\napply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0.\nlia."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z) : (n * beta ^ k ÷ (beta ^ (- (k + k')) * beta ^ k))%Z =\n(n ÷ beta ^ (- (k + k')))%Z.","conclusion":"(n * beta ^ k ÷ (beta ^ (- (k + k')) * beta ^ k))%Z =\n(n ÷ beta ^ (- (k + k')))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z)","proofString":"apply Zquot_mult_cancel_r.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z) : (beta ^ k)%Z <> 0%Z.","conclusion":"(beta ^ k)%Z <> 0%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z)","proofString":"apply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z) : (0 < beta ^ k)%Z.","conclusion":"(0 < beta ^ k)%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z)","proofString":"now apply Zpower_gt_0."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z) : (0 <= - (k + k'))%Z.","conclusion":"(0 <= - (k + k'))%Z","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z) (Hk' : (k' < 0)%Z) (Hk'' : (k + k' < 0)%Z)","proofString":"lia."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) : Zscale (Zscale n k) k' = Zscale n (k + k').","conclusion":"Zscale (Zscale n k) k' = Zscale n (k + k')","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z)","proofString":"unfold Zscale at 2.\nrewrite Zle_bool_true with (1 := Hk).\nnow apply Zscale_mul_pow."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) : Zscale (if (0 <=? k)%Z then (n * beta ^ k)%Z else (n ÷ beta ^ (- k))%Z) k' =\nZscale n (k + k').","conclusion":"Zscale (if (0 <=? k)%Z then (n * beta ^ k)%Z else (n ÷ beta ^ (- k))%Z) k' =\nZscale n (k + k')","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z)","proofString":"rewrite Zle_bool_true with (1 := Hk).\nnow apply Zscale_mul_pow."},{"statement":"(n k k' : Z) (Hk : (0 <= k)%Z) : Zscale (n * beta ^ k) k' = Zscale n (k + k').","conclusion":"Zscale (n * beta ^ k) k' = Zscale n (k + k')","hypotheses":"(n k k' : Z) (Hk : (0 <= k)%Z)","proofString":"now apply Zscale_mul_pow."},{"statement":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z) : Zdigit (Zslice n k1 k2) k = Zdigit n (k1 + k).","conclusion":"Zdigit (Zslice n k1 k2) k = Zdigit n (k1 + k)","hypotheses":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z)","proofString":"unfold Zslice.\nrewrite Zle_bool_true.\nrewrite Zdigit_mod_pow by apply Hk.\nrewrite Zdigit_scale by apply Hk.\nunfold Zminus.\nnow rewrite Z.opp_involutive, Zplus_comm.\nlia."},{"statement":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z) : Zdigit (if (0 <=? k2)%Z then Z.rem (Zscale n (- k1)) (beta ^ k2) else 0%Z) k =\nZdigit n (k1 + k).","conclusion":"Zdigit (if (0 <=? k2)%Z then Z.rem (Zscale n (- k1)) (beta ^ k2) else 0%Z) k =\nZdigit n (k1 + k)","hypotheses":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z)","proofString":"rewrite Zle_bool_true.\nrewrite Zdigit_mod_pow by apply Hk.\nrewrite Zdigit_scale by apply Hk.\nunfold Zminus.\nnow rewrite Z.opp_involutive, Zplus_comm.\nlia."},{"statement":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z) : Zdigit (Z.rem (Zscale n (- k1)) (beta ^ k2)) k = Zdigit n (k1 + k).","conclusion":"Zdigit (Z.rem (Zscale n (- k1)) (beta ^ k2)) k = Zdigit n (k1 + k)","hypotheses":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z)","proofString":"rewrite Zdigit_mod_pow by apply Hk.\nrewrite Zdigit_scale by apply Hk.\nunfold Zminus.\nnow rewrite Z.opp_involutive, Zplus_comm."},{"statement":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z) : Zdigit (Zscale n (- k1)) k = Zdigit n (k1 + k).","conclusion":"Zdigit (Zscale n (- k1)) k = Zdigit n (k1 + k)","hypotheses":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z)","proofString":"rewrite Zdigit_scale by apply Hk.\nunfold Zminus.\nnow rewrite Z.opp_involutive, Zplus_comm."},{"statement":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z) : Zdigit n (k - - k1) = Zdigit n (k1 + k).","conclusion":"Zdigit n (k - - k1) = Zdigit n (k1 + k)","hypotheses":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z)","proofString":"unfold Zminus.\nnow rewrite Z.opp_involutive, Zplus_comm."},{"statement":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z) : Zdigit n (k + - - k1) = Zdigit n (k1 + k).","conclusion":"Zdigit n (k + - - k1) = Zdigit n (k1 + k)","hypotheses":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z)","proofString":"now rewrite Z.opp_involutive, Zplus_comm."},{"statement":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z) : (0 <= k2)%Z.","conclusion":"(0 <= k2)%Z","hypotheses":"(n k1 k2 k : Z) (Hk : (0 <= k < k2)%Z)","proofString":"lia."},{"statement":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z) : Zdigit (Zslice n k1 k2) k = 0%Z.","conclusion":"Zdigit (Zslice n k1 k2) k = 0%Z","hypotheses":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z)","proofString":"unfold Zslice.\ncase Zle_bool_spec ; intros Hk2.\napply Zdigit_mod_pow_out.\nnow split.\napply Zdigit_0."},{"statement":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z) : Zdigit (if (0 <=? k2)%Z then Z.rem (Zscale n (- k1)) (beta ^ k2) else 0%Z) k =\n0%Z.","conclusion":"Zdigit (if (0 <=? k2)%Z then Z.rem (Zscale n (- k1)) (beta ^ k2) else 0%Z) k =\n0%Z","hypotheses":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z)","proofString":"case Zle_bool_spec ; intros Hk2.\napply Zdigit_mod_pow_out.\nnow split.\napply Zdigit_0."},{"statement":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z) (Hk2 : (0 <= k2)%Z) : Zdigit (Z.rem (Zscale n (- k1)) (beta ^ k2)) k = 0%Z.","conclusion":"Zdigit (Z.rem (Zscale n (- k1)) (beta ^ k2)) k = 0%Z","hypotheses":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z) (Hk2 : (0 <= k2)%Z)","proofString":"apply Zdigit_mod_pow_out.\nnow split."},{"statement":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z) (Hk2 : (0 <= k2)%Z) : (0 <= k2 <= k)%Z.","conclusion":"(0 <= k2 <= k)%Z","hypotheses":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z) (Hk2 : (0 <= k2)%Z)","proofString":"now split."},{"statement":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z) (Hk2 : (k2 < 0)%Z) : Zdigit 0 k = 0%Z.","conclusion":"Zdigit 0 k = 0%Z","hypotheses":"(n k1 k2 k : Z) (Hk : (k2 <= k)%Z) (Hk2 : (k2 < 0)%Z)","proofString":"apply Zdigit_0."},{"statement":"(k k' : Z) : Zslice 0 k k' = 0%Z.","conclusion":"Zslice 0 k k' = 0%Z","hypotheses":"(k k' : Z)","proofString":"unfold Zslice.\ncase Zle_bool.\nrewrite Zscale_0.\napply Zrem_0_l.\napply refl_equal."},{"statement":"(k k' : Z) : (if (0 <=? k')%Z then Z.rem (Zscale 0 (- k)) (beta ^ k') else 0%Z) = 0%Z.","conclusion":"(if (0 <=? k')%Z then Z.rem (Zscale 0 (- k)) (beta ^ k') else 0%Z) = 0%Z","hypotheses":"(k k' : Z)","proofString":"case Zle_bool.\nrewrite Zscale_0.\napply Zrem_0_l.\napply refl_equal."},{"statement":"(k k' : Z) : Z.rem (Zscale 0 (- k)) (beta ^ k') = 0%Z.","conclusion":"Z.rem (Zscale 0 (- k)) (beta ^ k') = 0%Z","hypotheses":"(k k' : Z)","proofString":"rewrite Zscale_0.\napply Zrem_0_l."},{"statement":"(k k' : Z) : Z.rem 0 (beta ^ k') = 0%Z.","conclusion":"Z.rem 0 (beta ^ k') = 0%Z","hypotheses":"(k k' : Z)","proofString":"apply Zrem_0_l."},{"statement":"(k k' : Z) : 0%Z = 0%Z.","conclusion":"0%Z = 0%Z","hypotheses":"(k k' : Z)","proofString":"apply refl_equal."},{"statement":"(n k k' : Z) : (0 <= n * Zslice n k k')%Z.","conclusion":"(0 <= n * Zslice n k k')%Z","hypotheses":"(n k k' : Z)","proofString":"unfold Zslice.\ncase Zle_bool.\napply Zsame_sign_trans_weak with (Zscale n (-k)).\nintros H ; rewrite H.\napply Zrem_0_l.\napply Zsame_sign_scale.\nrewrite Zmult_comm.\napply Zrem_sgn2.\nnow rewrite Zmult_0_r."},{"statement":"(n k k' : Z) : (0 <= n * (if 0 <=? k' then Z.rem (Zscale n (- k)) (beta ^ k') else 0))%Z.","conclusion":"(0 <= n * (if 0 <=? k' then Z.rem (Zscale n (- k)) (beta ^ k') else 0))%Z","hypotheses":"(n k k' : Z)","proofString":"case Zle_bool.\napply Zsame_sign_trans_weak with (Zscale n (-k)).\nintros H ; rewrite H.\napply Zrem_0_l.\napply Zsame_sign_scale.\nrewrite Zmult_comm.\napply Zrem_sgn2.\nnow rewrite Zmult_0_r."},{"statement":"(n k k' : Z) : (0 <= n * Z.rem (Zscale n (- k)) (beta ^ k'))%Z.","conclusion":"(0 <= n * Z.rem (Zscale n (- k)) (beta ^ k'))%Z","hypotheses":"(n k k' : Z)","proofString":"apply Zsame_sign_trans_weak with (Zscale n (-k)).\nintros H ; rewrite H.\napply Zrem_0_l.\napply Zsame_sign_scale.\nrewrite Zmult_comm.\napply Zrem_sgn2."},{"statement":"(n k k' : Z) : Zscale n (- k) = 0%Z -> Z.rem (Zscale n (- k)) (beta ^ k') = 0%Z.","conclusion":"Zscale n (- k) = 0%Z -> Z.rem (Zscale n (- k)) (beta ^ k') = 0%Z","hypotheses":"(n k k' : Z)","proofString":"intros H ; rewrite H.\napply Zrem_0_l."},{"statement":"(n k k' : Z) (H : Zscale n (- k) = 0%Z) : Z.rem 0 (beta ^ k') = 0%Z.","conclusion":"Z.rem 0 (beta ^ k') = 0%Z","hypotheses":"(n k k' : Z) (H : Zscale n (- k) = 0%Z)","proofString":"apply Zrem_0_l."},{"statement":"(n k k' : Z) : (0 <= n * Zscale n (- k))%Z.","conclusion":"(0 <= n * Zscale n (- k))%Z","hypotheses":"(n k k' : Z)","proofString":"apply Zsame_sign_scale."},{"statement":"(n k k' : Z) : (0 <= Zscale n (- k) * Z.rem (Zscale n (- k)) (beta ^ k'))%Z.","conclusion":"(0 <= Zscale n (- k) * Z.rem (Zscale n (- k)) (beta ^ k'))%Z","hypotheses":"(n k k' : Z)","proofString":"rewrite Zmult_comm.\napply Zrem_sgn2."},{"statement":"(n k k' : Z) : (0 <= Z.rem (Zscale n (- k)) (beta ^ k') * Zscale n (- k))%Z.","conclusion":"(0 <= Z.rem (Zscale n (- k)) (beta ^ k') * Zscale n (- k))%Z","hypotheses":"(n k k' : Z)","proofString":"apply Zrem_sgn2."},{"statement":"(n k k' : Z) : (0 <= n * 0)%Z.","conclusion":"(0 <= n * 0)%Z","hypotheses":"(n k k' : Z)","proofString":"now rewrite Zmult_0_r."},{"statement":"(n k1 k2 k1' k2' : Z) (Hk1' : (0 <= k1' <= k2)%Z) : Zslice (Zslice n k1 k2) k1' k2' = Zslice n (k1 + k1') (Z.min (k2 - k1') k2').","conclusion":"Zslice (Zslice n k1 k2) k1' k2' = Zslice n (k1 + k1') (Z.min (k2 - k1') k2')","hypotheses":"(n k1 k2 k1' k2' : Z) (Hk1' : (0 <= k1' <= k2)%Z)","proofString":"destruct (Zle_or_lt 0 k2') as [Hk2'|Hk2'].\napply Zdigit_ext.\nintros k Hk.\ndestruct (Zle_or_lt (Z.min (k2 - k1') k2') k) as [Hk'|Hk'].\nrewrite (Zdigit_slice_out n (k1 + k1')) with (1 := Hk').\ndestruct (Zle_or_lt k2' k) as [Hk''|Hk''].\nnow apply Zdigit_slice_out.\nrewrite Zdigit_slice by now split.\napply Zdigit_slice_out.\nlia.\nrewrite Zdigit_slice by lia.\nrewrite (Zdigit_slice n (k1 + k1')) by now split.\nrewrite Zdigit_slice.\nnow rewrite Zplus_assoc.\nlia.\nunfold Zslice.\nrewrite Z.min_r.\nnow rewrite Zle_bool_false.\nlia."},{"statement":"(n k1 k2 k1' k2' : Z) (Hk1' : (0 <= k1' <= k2)%Z) (Hk2' : (0 <= k2')%Z) (k : Z) (Hk : (0 <= k)%Z) (Hk' : (Z.min (k2 - k1') k2' <= k)%Z) (Hk'' : (k2' <= k)%Z) : Zdigit (Zslice (Zslice n k1 k2) k1' k2') k = 0%Z.","conclusion":"Zdigit (Zslice (Zslice n k1 k2) k1' k2') k = 0%Z","hypotheses":"(n k1 k2 k1' k2' : Z) (Hk1' : (0 <= k1' <= k2)%Z) (Hk2' : (0 <= k2')%Z) (k : Z) (Hk : (0 <= k)%Z) (Hk' : (Z.min (k2 - k1') k2' <= k)%Z) (Hk'' : (k2' <= k)%Z)","proofString":"now apply Zdigit_slice_out."},{"statement":"(n k1 k2 k1' k2' : Z) (Hk1' : (0 <= k1' <= k2)%Z) (Hk2' : (0 <= k2')%Z) (k : Z) (Hk : (0 <= k)%Z) (Hk' : (Z.min (k2 - k1') k2' <= k)%Z) (Hk'' : (k < k2')%Z) : (k2 <= k1' + k)%Z.","conclusion":"(k2 <= k1' + k)%Z","hypotheses":"(n k1 k2 k1' k2' : Z) (Hk1' : (0 <= k1' <= k2)%Z) (Hk2' : (0 <= k2')%Z) (k : Z) (Hk : (0 <= k)%Z) (Hk' : (Z.min (k2 - k1') k2' <= k)%Z) (Hk'' : (k < k2')%Z)","proofString":"lia."},{"statement":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z) : Zslice (Zscale n k) k1 k2 = Zslice n (k1 - k) k2.","conclusion":"Zslice (Zscale n k) k1 k2 = Zslice n (k1 - k) k2","hypotheses":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z)","proofString":"unfold Zscale.\ncase Zle_bool_spec; intros Hk.\nnow apply Zslice_mul_pow.\napply Zslice_div_pow with (2 := Hk1).\nlia."},{"statement":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z) : Zslice (if (0 <=? k)%Z then (n * beta ^ k)%Z else (n ÷ beta ^ (- k))%Z) k1 k2 =\nZslice n (k1 - k) k2.","conclusion":"Zslice (if (0 <=? k)%Z then (n * beta ^ k)%Z else (n ÷ beta ^ (- k))%Z) k1 k2 =\nZslice n (k1 - k) k2","hypotheses":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z)","proofString":"case Zle_bool_spec; intros Hk.\nnow apply Zslice_mul_pow.\napply Zslice_div_pow with (2 := Hk1).\nlia."},{"statement":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z) (Hk : (0 <= k)%Z) : Zslice (n * beta ^ k) k1 k2 = Zslice n (k1 - k) k2.","conclusion":"Zslice (n * beta ^ k) k1 k2 = Zslice n (k1 - k) k2","hypotheses":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z) (Hk : (0 <= k)%Z)","proofString":"now apply Zslice_mul_pow."},{"statement":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z) (Hk : (k < 0)%Z) : Zslice (n ÷ beta ^ (- k)) k1 k2 = Zslice n (k1 - k) k2.","conclusion":"Zslice (n ÷ beta ^ (- k)) k1 k2 = Zslice n (k1 - k) k2","hypotheses":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z) (Hk : (k < 0)%Z)","proofString":"apply Zslice_div_pow with (2 := Hk1).\nlia."},{"statement":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z) (Hk : (k < 0)%Z) : (0 <= - k)%Z.","conclusion":"(0 <= - k)%Z","hypotheses":"(n k k1 k2 : Z) (Hk1 : (0 <= k1)%Z) (Hk : (k < 0)%Z)","proofString":"lia."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) : Zslice (n ÷ beta ^ k) k1 k2 = Zscale (Zslice n k (k1 + k2)) (- k1).","conclusion":"Zslice (n ÷ beta ^ k) k1 k2 = Zscale (Zslice n k (k1 + k2)) (- k1)","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z)","proofString":"apply Zdigit_ext.\nintros k' Hk'.\nrewrite Zdigit_scale with (1 := Hk').\nunfold Zminus.\nrewrite (Zplus_comm k'), Z.opp_involutive.\ndestruct (Zle_or_lt k2 k') as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\napply sym_eq.\napply Zdigit_slice_out.\nnow apply Zplus_le_compat_l.\nrewrite Zdigit_slice by now split.\ndestruct (Zle_or_lt 0 (k1 + k')) as [Hk1'|Hk1'].\nrewrite Zdigit_slice by lia.\nrewrite Zdigit_div_pow by assumption.\napply f_equal.\nring.\nnow rewrite 2!Zdigit_lt."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) : forall k0 : Z,\n(0 <= k0)%Z ->\nZdigit (Zslice (n ÷ beta ^ k) k1 k2) k0 =\nZdigit (Zscale (Zslice n k (k1 + k2)) (- k1)) k0.","conclusion":"forall k0 : Z,\n(0 <= k0)%Z ->\nZdigit (Zslice (n ÷ beta ^ k) k1 k2) k0 =\nZdigit (Zscale (Zslice n k (k1 + k2)) (- k1)) k0","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z)","proofString":"intros k' Hk'.\nrewrite Zdigit_scale with (1 := Hk').\nunfold Zminus.\nrewrite (Zplus_comm k'), Z.opp_involutive.\ndestruct (Zle_or_lt k2 k') as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\napply sym_eq.\napply Zdigit_slice_out.\nnow apply Zplus_le_compat_l.\nrewrite Zdigit_slice by now split.\ndestruct (Zle_or_lt 0 (k1 + k')) as [Hk1'|Hk1'].\nrewrite Zdigit_slice by lia.\nrewrite Zdigit_div_pow by assumption.\napply f_equal.\nring.\nnow rewrite 2!Zdigit_lt."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) : Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zscale (Zslice n k (k1 + k2)) (- k1)) k'.","conclusion":"Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zscale (Zslice n k (k1 + k2)) (- k1)) k'","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z)","proofString":"rewrite Zdigit_scale with (1 := Hk').\nunfold Zminus.\nrewrite (Zplus_comm k'), Z.opp_involutive.\ndestruct (Zle_or_lt k2 k') as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\napply sym_eq.\napply Zdigit_slice_out.\nnow apply Zplus_le_compat_l.\nrewrite Zdigit_slice by now split.\ndestruct (Zle_or_lt 0 (k1 + k')) as [Hk1'|Hk1'].\nrewrite Zdigit_slice by lia.\nrewrite Zdigit_div_pow by assumption.\napply f_equal.\nring.\nnow rewrite 2!Zdigit_lt."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) : Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k' - - k1).","conclusion":"Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k' - - k1)","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z)","proofString":"unfold Zminus.\nrewrite (Zplus_comm k'), Z.opp_involutive.\ndestruct (Zle_or_lt k2 k') as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\napply sym_eq.\napply Zdigit_slice_out.\nnow apply Zplus_le_compat_l.\nrewrite Zdigit_slice by now split.\ndestruct (Zle_or_lt 0 (k1 + k')) as [Hk1'|Hk1'].\nrewrite Zdigit_slice by lia.\nrewrite Zdigit_div_pow by assumption.\napply f_equal.\nring.\nnow rewrite 2!Zdigit_lt."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) : Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k' + - - k1).","conclusion":"Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k' + - - k1)","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z)","proofString":"rewrite (Zplus_comm k'), Z.opp_involutive.\ndestruct (Zle_or_lt k2 k') as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\napply sym_eq.\napply Zdigit_slice_out.\nnow apply Zplus_le_compat_l.\nrewrite Zdigit_slice by now split.\ndestruct (Zle_or_lt 0 (k1 + k')) as [Hk1'|Hk1'].\nrewrite Zdigit_slice by lia.\nrewrite Zdigit_div_pow by assumption.\napply f_equal.\nring.\nnow rewrite 2!Zdigit_lt."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) : Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k1 + k').","conclusion":"Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k1 + k')","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z)","proofString":"destruct (Zle_or_lt k2 k') as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\napply sym_eq.\napply Zdigit_slice_out.\nnow apply Zplus_le_compat_l.\nrewrite Zdigit_slice by now split.\ndestruct (Zle_or_lt 0 (k1 + k')) as [Hk1'|Hk1'].\nrewrite Zdigit_slice by lia.\nrewrite Zdigit_div_pow by assumption.\napply f_equal.\nring.\nnow rewrite 2!Zdigit_lt."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k2 <= k')%Z) : Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k1 + k').","conclusion":"Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k1 + k')","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k2 <= k')%Z)","proofString":"rewrite Zdigit_slice_out with (1 := Hk2).\napply sym_eq.\napply Zdigit_slice_out.\nnow apply Zplus_le_compat_l."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k2 <= k')%Z) : 0%Z = Zdigit (Zslice n k (k1 + k2)) (k1 + k').","conclusion":"0%Z = Zdigit (Zslice n k (k1 + k2)) (k1 + k')","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k2 <= k')%Z)","proofString":"apply sym_eq.\napply Zdigit_slice_out.\nnow apply Zplus_le_compat_l."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k2 <= k')%Z) : Zdigit (Zslice n k (k1 + k2)) (k1 + k') = 0%Z.","conclusion":"Zdigit (Zslice n k (k1 + k2)) (k1 + k') = 0%Z","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k2 <= k')%Z)","proofString":"apply Zdigit_slice_out.\nnow apply Zplus_le_compat_l."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k2 <= k')%Z) : (k1 + k2 <= k1 + k')%Z.","conclusion":"(k1 + k2 <= k1 + k')%Z","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k2 <= k')%Z)","proofString":"now apply Zplus_le_compat_l."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) : Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k1 + k').","conclusion":"Zdigit (Zslice (n ÷ beta ^ k) k1 k2) k' =\nZdigit (Zslice n k (k1 + k2)) (k1 + k')","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z)","proofString":"rewrite Zdigit_slice by now split.\ndestruct (Zle_or_lt 0 (k1 + k')) as [Hk1'|Hk1'].\nrewrite Zdigit_slice by lia.\nrewrite Zdigit_div_pow by assumption.\napply f_equal.\nring.\nnow rewrite 2!Zdigit_lt."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) : Zdigit (n ÷ beta ^ k) (k1 + k') = Zdigit (Zslice n k (k1 + k2)) (k1 + k').","conclusion":"Zdigit (n ÷ beta ^ k) (k1 + k') = Zdigit (Zslice n k (k1 + k2)) (k1 + k')","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z)","proofString":"destruct (Zle_or_lt 0 (k1 + k')) as [Hk1'|Hk1'].\nrewrite Zdigit_slice by lia.\nrewrite Zdigit_div_pow by assumption.\napply f_equal.\nring.\nnow rewrite 2!Zdigit_lt."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (0 <= k1 + k')%Z) : Zdigit (n ÷ beta ^ k) (k1 + k') = Zdigit (Zslice n k (k1 + k2)) (k1 + k').","conclusion":"Zdigit (n ÷ beta ^ k) (k1 + k') = Zdigit (Zslice n k (k1 + k2)) (k1 + k')","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (0 <= k1 + k')%Z)","proofString":"rewrite Zdigit_slice by lia.\nrewrite Zdigit_div_pow by assumption.\napply f_equal.\nring."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (0 <= k1 + k')%Z) : Zdigit (n ÷ beta ^ k) (k1 + k') = Zdigit n (k + (k1 + k')).","conclusion":"Zdigit (n ÷ beta ^ k) (k1 + k') = Zdigit n (k + (k1 + k'))","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (0 <= k1 + k')%Z)","proofString":"rewrite Zdigit_div_pow by assumption.\napply f_equal.\nring."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (0 <= k1 + k')%Z) : Zdigit n (k1 + k' + k) = Zdigit n (k + (k1 + k')).","conclusion":"Zdigit n (k1 + k' + k) = Zdigit n (k + (k1 + k'))","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (0 <= k1 + k')%Z)","proofString":"apply f_equal.\nring."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (0 <= k1 + k')%Z) : (k1 + k' + k)%Z = (k + (k1 + k'))%Z.","conclusion":"(k1 + k' + k)%Z = (k + (k1 + k'))%Z","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (0 <= k1 + k')%Z)","proofString":"ring."},{"statement":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (k1 + k' < 0)%Z) : Zdigit (n ÷ beta ^ k) (k1 + k') = Zdigit (Zslice n k (k1 + k2)) (k1 + k').","conclusion":"Zdigit (n ÷ beta ^ k) (k1 + k') = Zdigit (Zslice n k (k1 + k2)) (k1 + k')","hypotheses":"(n k k1 k2 : Z) (Hk : (0 <= k)%Z) (k' : Z) (Hk' : (0 <= k')%Z) (Hk2 : (k' < k2)%Z) (Hk1' : (k1 + k' < 0)%Z)","proofString":"now rewrite 2!Zdigit_lt."},{"statement":"(n k1 l1 l2 : Z) (Hl1 : (0 <= l1)%Z) (Hl2 : (0 <= l2)%Z) : (Zslice n k1 l1 + Zscale (Zslice n (k1 + l1) l2) l1)%Z =\nZslice n k1 (l1 + l2).","conclusion":"(Zslice n k1 l1 + Zscale (Zslice n (k1 + l1) l2) l1)%Z =\nZslice n k1 (l1 + l2)","hypotheses":"(n k1 l1 l2 : Z) (Hl1 : (0 <= l1)%Z) (Hl2 : (0 <= l2)%Z)","proofString":"clear Hl1.\napply Zdigit_ext.\nintros k Hk.\nrewrite Zdigit_plus.\nrewrite Zdigit_scale with (1 := Hk).\ndestruct (Zle_or_lt (l1 + l2) k) as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\nnow rewrite 2!Zdigit_slice_out by lia.\nrewrite Zdigit_slice with (1 := conj Hk Hk2).\ndestruct (Zle_or_lt l1 k) as [Hk1|Hk1].\nrewrite Zdigit_slice_out with (1 := Hk1).\nrewrite Zdigit_slice by lia.\nsimpl ; apply f_equal.\nring.\nrewrite Zdigit_slice with (1 := conj Hk Hk1).\nrewrite (Zdigit_lt _ (k - l1)) by lia.\napply Zplus_0_r.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with n.\nintros H ; rewrite H.\napply Zslice_0.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with (Zslice n (k1 + l1) l2).\nintros H ; rewrite H.\napply Zscale_0.\napply Zsame_sign_slice.\napply Zsame_sign_scale.\napply Zsame_sign_slice.\nclear k Hk ; intros k Hk.\nrewrite Zdigit_scale with (1 := Hk).\ndestruct (Zle_or_lt l1 k) as [Hk1|Hk1].\nleft.\nnow apply Zdigit_slice_out.\nright.\napply Zdigit_lt.\nlia."},{"statement":"(n k1 l1 l2 : Z) (Hl2 : (0 <= l2)%Z) : (Zslice n k1 l1 + Zscale (Zslice n (k1 + l1) l2) l1)%Z =\nZslice n k1 (l1 + l2).","conclusion":"(Zslice n k1 l1 + Zscale (Zslice n (k1 + l1) l2) l1)%Z =\nZslice n k1 (l1 + l2)","hypotheses":"(n k1 l1 l2 : Z) (Hl2 : (0 <= l2)%Z)","proofString":"apply Zdigit_ext.\nintros k Hk.\nrewrite Zdigit_plus.\nrewrite Zdigit_scale with (1 := Hk).\ndestruct (Zle_or_lt (l1 + l2) k) as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\nnow rewrite 2!Zdigit_slice_out by lia.\nrewrite Zdigit_slice with (1 := conj Hk Hk2).\ndestruct (Zle_or_lt l1 k) as [Hk1|Hk1].\nrewrite Zdigit_slice_out with (1 := Hk1).\nrewrite Zdigit_slice by lia.\nsimpl ; apply f_equal.\nring.\nrewrite Zdigit_slice with (1 := conj Hk Hk1).\nrewrite (Zdigit_lt _ (k - l1)) by lia.\napply Zplus_0_r.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with n.\nintros H ; rewrite H.\napply Zslice_0.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with (Zslice n (k1 + l1) l2).\nintros H ; rewrite H.\napply Zscale_0.\napply Zsame_sign_slice.\napply Zsame_sign_scale.\napply Zsame_sign_slice.\nclear k Hk ; intros k Hk.\nrewrite Zdigit_scale with (1 := Hk).\ndestruct (Zle_or_lt l1 k) as [Hk1|Hk1].\nleft.\nnow apply Zdigit_slice_out.\nright.\napply Zdigit_lt.\nlia."},{"statement":"(n k1 l1 l2 : Z) (Hl2 : (0 <= l2)%Z) : forall k : Z,\n(0 <= k)%Z ->\nZdigit (Zslice n k1 l1 + Zscale (Zslice n (k1 + l1) l2) l1) k =\nZdigit (Zslice n k1 (l1 + l2)) k.","conclusion":"forall k : Z,\n(0 <= k)%Z ->\nZdigit (Zslice n k1 l1 + Zscale (Zslice n (k1 + l1) l2) l1) k =\nZdigit (Zslice n k1 (l1 + l2)) k","hypotheses":"(n k1 l1 l2 : Z) (Hl2 : (0 <= l2)%Z)","proofString":"intros k Hk.\nrewrite Zdigit_plus.\nrewrite Zdigit_scale with (1 := Hk).\ndestruct (Zle_or_lt (l1 + l2) k) as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\nnow rewrite 2!Zdigit_slice_out by lia.\nrewrite Zdigit_slice with (1 := conj Hk Hk2).\ndestruct (Zle_or_lt l1 k) as [Hk1|Hk1].\nrewrite Zdigit_slice_out with (1 := Hk1).\nrewrite Zdigit_slice by lia.\nsimpl ; apply f_equal.\nring.\nrewrite Zdigit_slice with (1 := conj Hk Hk1).\nrewrite (Zdigit_lt _ (k - l1)) by lia.\napply Zplus_0_r.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with n.\nintros H ; rewrite H.\napply Zslice_0.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with (Zslice n (k1 + l1) l2).\nintros H ; rewrite H.\napply Zscale_0.\napply Zsame_sign_slice.\napply Zsame_sign_scale.\napply Zsame_sign_slice.\nclear k Hk ; intros k Hk.\nrewrite Zdigit_scale with (1 := Hk).\ndestruct (Zle_or_lt l1 k) as [Hk1|Hk1].\nleft.\nnow apply Zdigit_slice_out.\nright.\napply Zdigit_lt.\nlia."},{"statement":"(n k1 l1 l2 : Z) (Hl2 : (0 <= l2)%Z) (k : Z) (Hk : (0 <= k)%Z) : Zdigit (Zslice n k1 l1 + Zscale (Zslice n (k1 + l1) l2) l1) k =\nZdigit (Zslice n k1 (l1 + l2)) k.","conclusion":"Zdigit (Zslice n k1 l1 + Zscale (Zslice n (k1 + l1) l2) l1) k =\nZdigit (Zslice n k1 (l1 + l2)) k","hypotheses":"(n k1 l1 l2 : Z) (Hl2 : (0 <= l2)%Z) (k : Z) (Hk : (0 <= k)%Z)","proofString":"rewrite Zdigit_plus.\nrewrite Zdigit_scale with (1 := Hk).\ndestruct (Zle_or_lt (l1 + l2) k) as [Hk2|Hk2].\nrewrite Zdigit_slice_out with (1 := Hk2).\nnow rewrite 2!Zdigit_slice_out by lia.\nrewrite Zdigit_slice with (1 := conj Hk Hk2).\ndestruct (Zle_or_lt l1 k) as [Hk1|Hk1].\nrewrite Zdigit_slice_out with (1 := Hk1).\nrewrite Zdigit_slice by lia.\nsimpl ; apply f_equal.\nring.\nrewrite Zdigit_slice with (1 := conj Hk Hk1).\nrewrite (Zdigit_lt _ (k - l1)) by lia.\napply Zplus_0_r.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with n.\nintros H ; rewrite H.\napply Zslice_0.\nrewrite Zmult_comm.\napply Zsame_sign_trans_weak with (Zslice n (k1 + l1) l2).\nintros H ; rewrite H.\napply Zscale_0.\napply Zsame_sign_slice.\napply Zsame_sign_scale.\napply Zsame_sign_slice.\nclear k Hk ; intros k Hk.\nrewrite Zdigit_scale with (1 := Hk).\ndestruct (Zle_or_lt l1 k) as [Hk1|Hk1].\nleft.\nnow apply Zdigit_slice_out.\nright.\napply Zdigit_lt.\nlia."},{"statement":"(forall p : positive,\n (beta ^ (Zdigits (Z.pos p) - 1) <= Z.pos p < beta ^ Zdigits (Z.pos p))%Z) ->\nforall n : Z, (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z.","conclusion":"(forall p : positive,\n (beta ^ (Zdigits (Z.pos p) - 1) <= Z.pos p < beta ^ Zdigits (Z.pos p))%Z) ->\nforall n : Z, (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z","hypotheses":"","proofString":"intros H [|n|n] ; try exact (H n).\nnow split."},{"statement":"(H : forall p : positive,\n(beta ^ (Zdigits (Z.pos p) - 1) <= Z.pos p < beta ^ Zdigits (Z.pos p))%Z) : (beta ^ (Zdigits 0 - 1) <= Z.abs 0 < beta ^ Zdigits 0)%Z.","conclusion":"(beta ^ (Zdigits 0 - 1) <= Z.abs 0 < beta ^ Zdigits 0)%Z","hypotheses":"(H : forall p : positive,\n(beta ^ (Zdigits (Z.pos p) - 1) <= Z.pos p < beta ^ Zdigits (Z.pos p))%Z)","proofString":"now split."},{"statement":"forall p : positive,\n(beta ^ (Zdigits (Z.pos p) - 1) <= Z.pos p < beta ^ Zdigits (Z.pos p))%Z.","conclusion":"forall p : positive,\n(beta ^ (Zdigits (Z.pos p) - 1) <= Z.pos p < beta ^ Zdigits (Z.pos p))%Z","hypotheses":"","proofString":"intros n.\nsimpl.\nassert (U: (Zpos n < Zpower beta (Z_of_nat (S (digits2_Pnat n))))%Z).\napply Z.lt_le_trans with (1 := proj2 (digits2_Pnat_correct n)).\nrewrite Zpower_Zpower_nat.\nrewrite Zabs_nat_Z_of_nat.\ninduction (S (digits2_Pnat n)).\neasy.\nrewrite 2!(Zpower_nat_S).\napply Zmult_le_compat with (2 := IHn0).\napply Zle_bool_imp_le.\napply beta.\neasy.\nrewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat.\napply Zle_0_nat.\nrevert U.\nrewrite inj_S.\nunfold Z.succ.\ngeneralize (digits2_Pnat n).\nintros u U.\npattern (radix_val beta) at 2 4 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nassert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) : (beta ^ (Zdigits (Z.pos n) - 1) <= Z.pos n < beta ^ Zdigits (Z.pos n))%Z.","conclusion":"(beta ^ (Zdigits (Z.pos n) - 1) <= Z.pos n < beta ^ Zdigits (Z.pos n))%Z","hypotheses":"(n : positive)","proofString":"simpl.\nassert (U: (Zpos n < Zpower beta (Z_of_nat (S (digits2_Pnat n))))%Z).\napply Z.lt_le_trans with (1 := proj2 (digits2_Pnat_correct n)).\nrewrite Zpower_Zpower_nat.\nrewrite Zabs_nat_Z_of_nat.\ninduction (S (digits2_Pnat n)).\neasy.\nrewrite 2!(Zpower_nat_S).\napply Zmult_le_compat with (2 := IHn0).\napply Zle_bool_imp_le.\napply beta.\neasy.\nrewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat.\napply Zle_0_nat.\nrevert U.\nrewrite inj_S.\nunfold Z.succ.\ngeneralize (digits2_Pnat n).\nintros u U.\npattern (radix_val beta) at 2 4 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nassert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) : (beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z.","conclusion":"(beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z","hypotheses":"(n : positive)","proofString":"assert (U: (Zpos n < Zpower beta (Z_of_nat (S (digits2_Pnat n))))%Z).\napply Z.lt_le_trans with (1 := proj2 (digits2_Pnat_correct n)).\nrewrite Zpower_Zpower_nat.\nrewrite Zabs_nat_Z_of_nat.\ninduction (S (digits2_Pnat n)).\neasy.\nrewrite 2!(Zpower_nat_S).\napply Zmult_le_compat with (2 := IHn0).\napply Zle_bool_imp_le.\napply beta.\neasy.\nrewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat.\napply Zle_0_nat.\nrevert U.\nrewrite inj_S.\nunfold Z.succ.\ngeneralize (digits2_Pnat n).\nintros u U.\npattern (radix_val beta) at 2 4 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nassert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) : (Z.pos n < beta ^ Z.of_nat (S (digits2_Pnat n)))%Z.","conclusion":"(Z.pos n < beta ^ Z.of_nat (S (digits2_Pnat n)))%Z","hypotheses":"(n : positive)","proofString":"apply Z.lt_le_trans with (1 := proj2 (digits2_Pnat_correct n)).\nrewrite Zpower_Zpower_nat.\nrewrite Zabs_nat_Z_of_nat.\ninduction (S (digits2_Pnat n)).\neasy.\nrewrite 2!(Zpower_nat_S).\napply Zmult_le_compat with (2 := IHn0).\napply Zle_bool_imp_le.\napply beta.\neasy.\nrewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat.\napply Zle_0_nat."},{"statement":"(n : positive) : (Zpower_nat 2 (S (digits2_Pnat n)) <= beta ^ Z.of_nat (S (digits2_Pnat n)))%Z.","conclusion":"(Zpower_nat 2 (S (digits2_Pnat n)) <= beta ^ Z.of_nat (S (digits2_Pnat n)))%Z","hypotheses":"(n : positive)","proofString":"rewrite Zpower_Zpower_nat.\nrewrite Zabs_nat_Z_of_nat.\ninduction (S (digits2_Pnat n)).\neasy.\nrewrite 2!(Zpower_nat_S).\napply Zmult_le_compat with (2 := IHn0).\napply Zle_bool_imp_le.\napply beta.\neasy.\nrewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat.\napply Zle_0_nat."},{"statement":"(n : positive) : (Zpower_nat 2 (S (digits2_Pnat n)) <=\n Zpower_nat beta (Z.abs_nat (Z.of_nat (S (digits2_Pnat n)))))%Z.","conclusion":"(Zpower_nat 2 (S (digits2_Pnat n)) <=\n Zpower_nat beta (Z.abs_nat (Z.of_nat (S (digits2_Pnat n)))))%Z","hypotheses":"(n : positive)","proofString":"rewrite Zabs_nat_Z_of_nat.\ninduction (S (digits2_Pnat n)).\neasy.\nrewrite 2!(Zpower_nat_S).\napply Zmult_le_compat with (2 := IHn0).\napply Zle_bool_imp_le.\napply beta.\neasy.\nrewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat."},{"statement":"(n : positive) : (Zpower_nat 2 (S (digits2_Pnat n)) <= Zpower_nat beta (S (digits2_Pnat n)))%Z.","conclusion":"(Zpower_nat 2 (S (digits2_Pnat n)) <= Zpower_nat beta (S (digits2_Pnat n)))%Z","hypotheses":"(n : positive)","proofString":"induction (S (digits2_Pnat n)).\neasy.\nrewrite 2!(Zpower_nat_S).\napply Zmult_le_compat with (2 := IHn0).\napply Zle_bool_imp_le.\napply beta.\neasy.\nrewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat."},{"statement":"(n : positive) : (Zpower_nat 2 0 <= Zpower_nat beta 0)%Z.","conclusion":"(Zpower_nat 2 0 <= Zpower_nat beta 0)%Z","hypotheses":"(n : positive)","proofString":"easy."},{"statement":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z) : (Zpower_nat 2 (S n0) <= Zpower_nat beta (S n0))%Z.","conclusion":"(Zpower_nat 2 (S n0) <= Zpower_nat beta (S n0))%Z","hypotheses":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z)","proofString":"rewrite 2!(Zpower_nat_S).\napply Zmult_le_compat with (2 := IHn0).\napply Zle_bool_imp_le.\napply beta.\neasy.\nrewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat."},{"statement":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z) : (2 * Zpower_nat 2 n0 <= beta * Zpower_nat beta n0)%Z.","conclusion":"(2 * Zpower_nat 2 n0 <= beta * Zpower_nat beta n0)%Z","hypotheses":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z)","proofString":"apply Zmult_le_compat with (2 := IHn0).\napply Zle_bool_imp_le.\napply beta.\neasy.\nrewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat."},{"statement":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z) : (2 <= beta)%Z.","conclusion":"(2 <= beta)%Z","hypotheses":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z)","proofString":"apply Zle_bool_imp_le.\napply beta."},{"statement":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z) : (2 <=? beta)%Z = true.","conclusion":"(2 <=? beta)%Z = true","hypotheses":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z)","proofString":"apply beta."},{"statement":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z) : (0 <= 2)%Z.","conclusion":"(0 <= 2)%Z","hypotheses":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z)","proofString":"easy."},{"statement":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z) : (0 <= Zpower_nat 2 n0)%Z.","conclusion":"(0 <= Zpower_nat 2 n0)%Z","hypotheses":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z)","proofString":"rewrite <- (Zabs_nat_Z_of_nat n0).\nrewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat."},{"statement":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z) : (0 <= Zpower_nat 2 (Z.abs_nat (Z.of_nat n0)))%Z.","conclusion":"(0 <= Zpower_nat 2 (Z.abs_nat (Z.of_nat n0)))%Z","hypotheses":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z)","proofString":"rewrite <- Zpower_Zpower_nat.\napply (Zpower_ge_0 (Build_radix 2 (refl_equal true))).\napply Zle_0_nat."},{"statement":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z) : (0 <= 2 ^ Z.of_nat n0)%Z.","conclusion":"(0 <= 2 ^ Z.of_nat n0)%Z","hypotheses":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z)","proofString":"apply (Zpower_ge_0 (Build_radix 2 (refl_equal true)))."},{"statement":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z) : (0 <= Z.of_nat n0)%Z.","conclusion":"(0 <= Z.of_nat n0)%Z","hypotheses":"(n : positive) (n0 : nat) (IHn0 : (Zpower_nat 2 n0 <= Zpower_nat beta n0)%Z)","proofString":"apply Zle_0_nat."},{"statement":"(n : positive) : (0 <= Z.of_nat (S (digits2_Pnat n)))%Z.","conclusion":"(0 <= Z.of_nat (S (digits2_Pnat n)))%Z","hypotheses":"(n : positive)","proofString":"apply Zle_0_nat."},{"statement":"(n : positive) (U : (Z.pos n < beta ^ Z.of_nat (S (digits2_Pnat n)))%Z) : (beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z.","conclusion":"(beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z","hypotheses":"(n : positive) (U : (Z.pos n < beta ^ Z.of_nat (S (digits2_Pnat n)))%Z)","proofString":"revert U.\nrewrite inj_S.\nunfold Z.succ.\ngeneralize (digits2_Pnat n).\nintros u U.\npattern (radix_val beta) at 2 4 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nassert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) : (Z.pos n < beta ^ Z.of_nat (S (digits2_Pnat n)))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z.","conclusion":"(Z.pos n < beta ^ Z.of_nat (S (digits2_Pnat n)))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z","hypotheses":"(n : positive)","proofString":"rewrite inj_S.\nunfold Z.succ.\ngeneralize (digits2_Pnat n).\nintros u U.\npattern (radix_val beta) at 2 4 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nassert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) : (Z.pos n < beta ^ Z.succ (Z.of_nat (digits2_Pnat n)))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z.","conclusion":"(Z.pos n < beta ^ Z.succ (Z.of_nat (digits2_Pnat n)))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z","hypotheses":"(n : positive)","proofString":"unfold Z.succ.\ngeneralize (digits2_Pnat n).\nintros u U.\npattern (radix_val beta) at 2 4 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nassert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) : (Z.pos n < beta ^ (Z.of_nat (digits2_Pnat n) + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z.","conclusion":"(Z.pos n < beta ^ (Z.of_nat (digits2_Pnat n) + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 beta (digits2_Pnat n))%Z","hypotheses":"(n : positive)","proofString":"generalize (digits2_Pnat n).\nintros u U.\npattern (radix_val beta) at 2 4 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nassert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) : forall n0 : nat,\n(Z.pos n < beta ^ (Z.of_nat n0 + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 beta n0 - 1) <= Z.pos n <\n beta ^ Zdigits_aux (Z.pos n) 1 beta n0)%Z.","conclusion":"forall n0 : nat,\n(Z.pos n < beta ^ (Z.of_nat n0 + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 beta n0 - 1) <= Z.pos n <\n beta ^ Zdigits_aux (Z.pos n) 1 beta n0)%Z","hypotheses":"(n : positive)","proofString":"intros u U.\npattern (radix_val beta) at 2 4 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nassert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z) : (beta ^ (Zdigits_aux (Z.pos n) 1 beta u - 1) <= Z.pos n <\n beta ^ Zdigits_aux (Z.pos n) 1 beta u)%Z.","conclusion":"(beta ^ (Zdigits_aux (Z.pos n) 1 beta u - 1) <= Z.pos n <\n beta ^ Zdigits_aux (Z.pos n) 1 beta u)%Z","hypotheses":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z)","proofString":"pattern (radix_val beta) at 2 4 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nassert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z) : (beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z.","conclusion":"(beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z","hypotheses":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z)","proofString":"assert (V: (Zpower beta (1 - 1) <= Zpos n)%Z).\nnow apply (Zlt_le_succ 0).\ngeneralize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z) : (beta ^ (1 - 1) <= Z.pos n)%Z.","conclusion":"(beta ^ (1 - 1) <= Z.pos n)%Z","hypotheses":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z)","proofString":"now apply (Zlt_le_succ 0)."},{"statement":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z) (V : (beta ^ (1 - 1) <= Z.pos n)%Z) : (beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z.","conclusion":"(beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z","hypotheses":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z) (V : (beta ^ (1 - 1) <= Z.pos n)%Z)","proofString":"generalize (conj V U).\nclear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z) (V : (beta ^ (1 - 1) <= Z.pos n)%Z) : (beta ^ (1 - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z.","conclusion":"(beta ^ (1 - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z","hypotheses":"(n : positive) (u : nat) (U : (Z.pos n < beta ^ (Z.of_nat u + 1))%Z) (V : (beta ^ (1 - 1) <= Z.pos n)%Z)","proofString":"clear.\ngeneralize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) : (beta ^ (1 - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z.","conclusion":"(beta ^ (1 - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z","hypotheses":"(n : positive) (u : nat)","proofString":"generalize (Z.le_refl 1).\ngeneralize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) : (1 <= 1)%Z ->\n(beta ^ (1 - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z.","conclusion":"(1 <= 1)%Z ->\n(beta ^ (1 - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) 1 (beta ^ 1) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) 1 (beta ^ 1) u)%Z","hypotheses":"(n : positive) (u : nat)","proofString":"generalize 1%Z at 2 3 5 6 7 9 10.\ninduction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z.","conclusion":"forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z","hypotheses":"(n : positive) (u : nat)","proofString":"induction u.\neasy.\nrewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat 0 + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) 0 - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) 0)%Z.","conclusion":"forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat 0 + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) 0 - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) 0)%Z","hypotheses":"(n : positive)","proofString":"easy."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat (S u) + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) (S u) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) (S u))%Z.","conclusion":"forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat (S u) + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) (S u) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) (S u))%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z)","proofString":"rewrite inj_S; unfold Z.succ.\nsimpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) (S u) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) (S u))%Z.","conclusion":"forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) (S u) - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) (S u))%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z)","proofString":"simpl Zdigits_aux.\nintros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + z))%Z ->\n(beta\n ^ ((if Z.pos n <? beta ^ z\n     then z\n     else Zdigits_aux (Z.pos n) (z + 1) (beta * beta ^ z) u) - 1) <=\n Z.pos n <\n beta\n ^ (if Z.pos n <? beta ^ z\n    then z\n    else Zdigits_aux (Z.pos n) (z + 1) (beta * beta ^ z) u))%Z.","conclusion":"forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + z))%Z ->\n(beta\n ^ ((if Z.pos n <? beta ^ z\n     then z\n     else Zdigits_aux (Z.pos n) (z + 1) (beta * beta ^ z) u) - 1) <=\n Z.pos n <\n beta\n ^ (if Z.pos n <? beta ^ z\n    then z\n    else Zdigits_aux (Z.pos n) (z + 1) (beta * beta ^ z) u))%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z)","proofString":"intros v Hv U.\ncase Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) : (beta\n ^ ((if Z.pos n <? beta ^ v\n     then v\n     else Zdigits_aux (Z.pos n) (v + 1) (beta * beta ^ v) u) - 1) <=\n Z.pos n <\n beta\n ^ (if Z.pos n <? beta ^ v\n    then v\n    else Zdigits_aux (Z.pos n) (v + 1) (beta * beta ^ v) u))%Z.","conclusion":"(beta\n ^ ((if Z.pos n <? beta ^ v\n     then v\n     else Zdigits_aux (Z.pos n) (v + 1) (beta * beta ^ v) u) - 1) <=\n Z.pos n <\n beta\n ^ (if Z.pos n <? beta ^ v\n    then v\n    else Zdigits_aux (Z.pos n) (v + 1) (beta * beta ^ v) u))%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z)","proofString":"case Zlt_bool_spec ; intros K.\nnow split.\npattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (Z.pos n < beta ^ v)%Z) : (beta ^ (v - 1) <= Z.pos n < beta ^ v)%Z.","conclusion":"(beta ^ (v - 1) <= Z.pos n < beta ^ v)%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (Z.pos n < beta ^ v)%Z)","proofString":"now split."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (beta ^ (Zdigits_aux (Z.pos n) (v + 1) (beta * beta ^ v) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) (v + 1) (beta * beta ^ v) u)%Z.","conclusion":"(beta ^ (Zdigits_aux (Z.pos n) (v + 1) (beta * beta ^ v) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) (v + 1) (beta * beta ^ v) u)%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"pattern (radix_val beta) at 2 5 ; replace (radix_val beta) with (Zpower beta 1) by apply Zmult_1_r.\nrewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (beta ^ (Zdigits_aux (Z.pos n) (v + 1) (beta ^ 1 * beta ^ v) u - 1) <=\n Z.pos n < beta ^ Zdigits_aux (Z.pos n) (v + 1) (beta ^ 1 * beta ^ v) u)%Z.","conclusion":"(beta ^ (Zdigits_aux (Z.pos n) (v + 1) (beta ^ 1 * beta ^ v) u - 1) <=\n Z.pos n < beta ^ Zdigits_aux (Z.pos n) (v + 1) (beta ^ 1 * beta ^ v) u)%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"rewrite <- Zpower_plus.\nrewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc.\neasy.\napply Zle_succ_le with (1 := Hv)."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (beta ^ (Zdigits_aux (Z.pos n) (v + 1) (beta ^ (1 + v)) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) (v + 1) (beta ^ (1 + v)) u)%Z.","conclusion":"(beta ^ (Zdigits_aux (Z.pos n) (v + 1) (beta ^ (1 + v)) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) (v + 1) (beta ^ (1 + v)) u)%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"rewrite Zplus_comm.\napply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (beta ^ (Zdigits_aux (Z.pos n) (1 + v) (beta ^ (1 + v)) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) (1 + v) (beta ^ (1 + v)) u)%Z.","conclusion":"(beta ^ (Zdigits_aux (Z.pos n) (1 + v) (beta ^ (1 + v)) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) (1 + v) (beta ^ (1 + v)) u)%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"apply IHu.\nclear -Hv ; lia.\nsplit.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (1 <= 1 + v)%Z.","conclusion":"(1 <= 1 + v)%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"clear -Hv ; lia."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (beta ^ (1 + v - 1) <= Z.pos n < beta ^ (Z.of_nat u + (1 + v)))%Z.","conclusion":"(beta ^ (1 + v - 1) <= Z.pos n < beta ^ (Z.of_nat u + (1 + v)))%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"split.\nnow ring_simplify (1 + v - 1)%Z.\nnow rewrite Zplus_assoc."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (beta ^ (1 + v - 1) <= Z.pos n)%Z.","conclusion":"(beta ^ (1 + v - 1) <= Z.pos n)%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"now ring_simplify (1 + v - 1)%Z."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (Z.pos n < beta ^ (Z.of_nat u + (1 + v)))%Z.","conclusion":"(Z.pos n < beta ^ (Z.of_nat u + (1 + v)))%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"now rewrite Zplus_assoc."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (0 <= 1)%Z.","conclusion":"(0 <= 1)%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"easy."},{"statement":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z) : (0 <= v)%Z.","conclusion":"(0 <= v)%Z","hypotheses":"(n : positive) (u : nat) (IHu : forall z : Z,\n(1 <= z)%Z ->\n(beta ^ (z - 1) <= Z.pos n < beta ^ (Z.of_nat u + z))%Z ->\n(beta ^ (Zdigits_aux (Z.pos n) z (beta ^ z) u - 1) <= \n Z.pos n < beta ^ Zdigits_aux (Z.pos n) z (beta ^ z) u)%Z) (v : Z) (Hv : (1 <= v)%Z) (U : (beta ^ (v - 1) <= Z.pos n < beta ^ (Z.of_nat u + 1 + v))%Z) (K : (beta ^ v <= Z.pos n)%Z)","proofString":"apply Zle_succ_le with (1 := Hv)."},{"statement":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) : Zdigits n = d.","conclusion":"Zdigits n = d","hypotheses":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z)","proofString":"assert (Hd' := Zdigits_correct n).\napply Zle_antisym.\napply (Zpower_lt_Zpower beta).\nnow apply Z.le_lt_trans with (Z.abs n).\napply (Zpower_lt_Zpower beta).\nnow apply Z.le_lt_trans with (Z.abs n)."},{"statement":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z) : Zdigits n = d.","conclusion":"Zdigits n = d","hypotheses":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z)","proofString":"apply Zle_antisym.\napply (Zpower_lt_Zpower beta).\nnow apply Z.le_lt_trans with (Z.abs n).\napply (Zpower_lt_Zpower beta).\nnow apply Z.le_lt_trans with (Z.abs n)."},{"statement":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z) : (Zdigits n <= d)%Z.","conclusion":"(Zdigits n <= d)%Z","hypotheses":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z)","proofString":"apply (Zpower_lt_Zpower beta).\nnow apply Z.le_lt_trans with (Z.abs n)."},{"statement":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z) : (beta ^ (Zdigits n - 1) < beta ^ d)%Z.","conclusion":"(beta ^ (Zdigits n - 1) < beta ^ d)%Z","hypotheses":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z)","proofString":"now apply Z.le_lt_trans with (Z.abs n)."},{"statement":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z) : (d <= Zdigits n)%Z.","conclusion":"(d <= Zdigits n)%Z","hypotheses":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z)","proofString":"apply (Zpower_lt_Zpower beta).\nnow apply Z.le_lt_trans with (Z.abs n)."},{"statement":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z) : (beta ^ (d - 1) < beta ^ Zdigits n)%Z.","conclusion":"(beta ^ (d - 1) < beta ^ Zdigits n)%Z","hypotheses":"(n d : Z) (Hd : (beta ^ (d - 1) <= Z.abs n < beta ^ d)%Z) (Hd' : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z)","proofString":"now apply Z.le_lt_trans with (Z.abs n)."},{"statement":"(n : Z) (Zn : n <> 0%Z) : (0 < Zdigits n)%Z.","conclusion":"(0 < Zdigits n)%Z","hypotheses":"(n : Z) (Zn : n <> 0%Z)","proofString":"rewrite <- (Zdigits_abs n).\nassert (Hn: (0 < Z.abs n)%Z).\ndestruct n ; [|easy|easy].\nnow elim Zn.\ndestruct (Z.abs n) as [|p|p] ; try easy ; clear.\nsimpl.\ngeneralize 1%Z (radix_val beta) (refl_equal Lt : (0 < 1)%Z).\ninduction (digits2_Pnat p).\neasy.\nsimpl.\nintros.\ncase Zlt_bool.\nexact H.\napply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(n : Z) (Zn : n <> 0%Z) : (0 < Zdigits (Z.abs n))%Z.","conclusion":"(0 < Zdigits (Z.abs n))%Z","hypotheses":"(n : Z) (Zn : n <> 0%Z)","proofString":"assert (Hn: (0 < Z.abs n)%Z).\ndestruct n ; [|easy|easy].\nnow elim Zn.\ndestruct (Z.abs n) as [|p|p] ; try easy ; clear.\nsimpl.\ngeneralize 1%Z (radix_val beta) (refl_equal Lt : (0 < 1)%Z).\ninduction (digits2_Pnat p).\neasy.\nsimpl.\nintros.\ncase Zlt_bool.\nexact H.\napply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(n : Z) (Zn : n <> 0%Z) : (0 < Z.abs n)%Z.","conclusion":"(0 < Z.abs n)%Z","hypotheses":"(n : Z) (Zn : n <> 0%Z)","proofString":"destruct n ; [|easy|easy].\nnow elim Zn."},{"statement":"(Zn : 0%Z <> 0%Z) : (0 < Z.abs 0)%Z.","conclusion":"(0 < Z.abs 0)%Z","hypotheses":"(Zn : 0%Z <> 0%Z)","proofString":"now elim Zn."},{"statement":"(n : Z) (Zn : n <> 0%Z) (Hn : (0 < Z.abs n)%Z) : (0 < Zdigits (Z.abs n))%Z.","conclusion":"(0 < Zdigits (Z.abs n))%Z","hypotheses":"(n : Z) (Zn : n <> 0%Z) (Hn : (0 < Z.abs n)%Z)","proofString":"destruct (Z.abs n) as [|p|p] ; try easy ; clear.\nsimpl.\ngeneralize 1%Z (radix_val beta) (refl_equal Lt : (0 < 1)%Z).\ninduction (digits2_Pnat p).\neasy.\nsimpl.\nintros.\ncase Zlt_bool.\nexact H.\napply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(p : positive) : (0 < Zdigits (Z.pos p))%Z.","conclusion":"(0 < Zdigits (Z.pos p))%Z","hypotheses":"(p : positive)","proofString":"simpl.\ngeneralize 1%Z (radix_val beta) (refl_equal Lt : (0 < 1)%Z).\ninduction (digits2_Pnat p).\neasy.\nsimpl.\nintros.\ncase Zlt_bool.\nexact H.\napply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(p : positive) : (0 < Zdigits_aux (Z.pos p) 1 beta (digits2_Pnat p))%Z.","conclusion":"(0 < Zdigits_aux (Z.pos p) 1 beta (digits2_Pnat p))%Z","hypotheses":"(p : positive)","proofString":"generalize 1%Z (radix_val beta) (refl_equal Lt : (0 < 1)%Z).\ninduction (digits2_Pnat p).\neasy.\nsimpl.\nintros.\ncase Zlt_bool.\nexact H.\napply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(p : positive) : forall z z0 : Z,\n(0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 (digits2_Pnat p))%Z.","conclusion":"forall z z0 : Z,\n(0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 (digits2_Pnat p))%Z","hypotheses":"(p : positive)","proofString":"induction (digits2_Pnat p).\neasy.\nsimpl.\nintros.\ncase Zlt_bool.\nexact H.\napply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(p : positive) : forall z z0 : Z, (0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 0)%Z.","conclusion":"forall z z0 : Z, (0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 0)%Z","hypotheses":"(p : positive)","proofString":"easy."},{"statement":"(p : positive) (n : nat) (IHn : forall z z0 : Z, (0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 n)%Z) : forall z z0 : Z, (0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 (S n))%Z.","conclusion":"forall z z0 : Z, (0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 (S n))%Z","hypotheses":"(p : positive) (n : nat) (IHn : forall z z0 : Z, (0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 n)%Z)","proofString":"simpl.\nintros.\ncase Zlt_bool.\nexact H.\napply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(p : positive) (n : nat) (IHn : forall z z0 : Z, (0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 n)%Z) : forall z z0 : Z,\n(0 < z)%Z ->\n(0 <\n (if Z.pos p <? z0 then z else Zdigits_aux (Z.pos p) (z + 1) (beta * z0) n))%Z.","conclusion":"forall z z0 : Z,\n(0 < z)%Z ->\n(0 <\n (if Z.pos p <? z0 then z else Zdigits_aux (Z.pos p) (z + 1) (beta * z0) n))%Z","hypotheses":"(p : positive) (n : nat) (IHn : forall z z0 : Z, (0 < z)%Z -> (0 < Zdigits_aux (Z.pos p) z z0 n)%Z)","proofString":"intros.\ncase Zlt_bool.\nexact H.\napply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(p : positive) (n : nat) (IHn : forall z1 z2 : Z, (0 < z1)%Z -> (0 < Zdigits_aux (Z.pos p) z1 z2 n)%Z) (z z0 : Z) (H : (0 < z)%Z) : (0 <\n (if Z.pos p <? z0 then z else Zdigits_aux (Z.pos p) (z + 1) (beta * z0) n))%Z.","conclusion":"(0 <\n (if Z.pos p <? z0 then z else Zdigits_aux (Z.pos p) (z + 1) (beta * z0) n))%Z","hypotheses":"(p : positive) (n : nat) (IHn : forall z1 z2 : Z, (0 < z1)%Z -> (0 < Zdigits_aux (Z.pos p) z1 z2 n)%Z) (z z0 : Z) (H : (0 < z)%Z)","proofString":"case Zlt_bool.\nexact H.\napply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(p : positive) (n : nat) (IHn : forall z1 z2 : Z, (0 < z1)%Z -> (0 < Zdigits_aux (Z.pos p) z1 z2 n)%Z) (z z0 : Z) (H : (0 < z)%Z) : (0 < z)%Z.","conclusion":"(0 < z)%Z","hypotheses":"(p : positive) (n : nat) (IHn : forall z1 z2 : Z, (0 < z1)%Z -> (0 < Zdigits_aux (Z.pos p) z1 z2 n)%Z) (z z0 : Z) (H : (0 < z)%Z)","proofString":"exact H."},{"statement":"(p : positive) (n : nat) (IHn : forall z1 z2 : Z, (0 < z1)%Z -> (0 < Zdigits_aux (Z.pos p) z1 z2 n)%Z) (z z0 : Z) (H : (0 < z)%Z) : (0 < Zdigits_aux (Z.pos p) (z + 1) (beta * z0) n)%Z.","conclusion":"(0 < Zdigits_aux (Z.pos p) (z + 1) (beta * z0) n)%Z","hypotheses":"(p : positive) (n : nat) (IHn : forall z1 z2 : Z, (0 < z1)%Z -> (0 < Zdigits_aux (Z.pos p) z1 z2 n)%Z) (z z0 : Z) (H : (0 < z)%Z)","proofString":"apply IHn.\nnow apply Zlt_lt_succ."},{"statement":"(p : positive) (n : nat) (IHn : forall z1 z2 : Z, (0 < z1)%Z -> (0 < Zdigits_aux (Z.pos p) z1 z2 n)%Z) (z z0 : Z) (H : (0 < z)%Z) : (0 < z + 1)%Z.","conclusion":"(0 < z + 1)%Z","hypotheses":"(p : positive) (n : nat) (IHn : forall z1 z2 : Z, (0 < z1)%Z -> (0 < Zdigits_aux (Z.pos p) z1 z2 n)%Z) (z z0 : Z) (H : (0 < z)%Z)","proofString":"now apply Zlt_lt_succ."},{"statement":"(n : Z) : (0 <= Zdigits n)%Z.","conclusion":"(0 <= Zdigits n)%Z","hypotheses":"(n : Z)","proofString":"destruct (Z.eq_dec n 0) as [H|H].\nnow rewrite H.\napply Zlt_le_weak.\nnow apply Zdigits_gt_0."},{"statement":"(n : Z) (H : n = 0%Z) : (0 <= Zdigits n)%Z.","conclusion":"(0 <= Zdigits n)%Z","hypotheses":"(n : Z) (H : n = 0%Z)","proofString":"now rewrite H."},{"statement":"(n : Z) (H : n <> 0%Z) : (0 <= Zdigits n)%Z.","conclusion":"(0 <= Zdigits n)%Z","hypotheses":"(n : Z) (H : n <> 0%Z)","proofString":"apply Zlt_le_weak.\nnow apply Zdigits_gt_0."},{"statement":"(n : Z) (H : n <> 0%Z) : (0 < Zdigits n)%Z.","conclusion":"(0 < Zdigits n)%Z","hypotheses":"(n : Z) (H : n <> 0%Z)","proofString":"now apply Zdigits_gt_0."},{"statement":"(n k : Z) (Hk : (Zdigits n <= k)%Z) : Zdigit n k = 0%Z.","conclusion":"Zdigit n k = 0%Z","hypotheses":"(n k : Z) (Hk : (Zdigits n <= k)%Z)","proofString":"apply Zdigit_ge_Zpower with (2 := Hk).\napply Zdigits_correct."},{"statement":"(n k : Z) (Hk : (Zdigits n <= k)%Z) : (Z.abs n < beta ^ Zdigits n)%Z.","conclusion":"(Z.abs n < beta ^ Zdigits n)%Z","hypotheses":"(n k : Z) (Hk : (Zdigits n <= k)%Z)","proofString":"apply Zdigits_correct."},{"statement":"(n : Z) (Zn : n <> 0%Z) : Zdigit n (Zdigits n - 1) <> 0%Z.","conclusion":"Zdigit n (Zdigits n - 1) <> 0%Z","hypotheses":"(n : Z) (Zn : n <> 0%Z)","proofString":"apply Zdigit_not_0.\napply Zlt_0_le_0_pred.\nnow apply Zdigits_gt_0.\nring_simplify (Zdigits n - 1 + 1)%Z.\napply Zdigits_correct."},{"statement":"(n : Z) (Zn : n <> 0%Z) : (0 <= Zdigits n - 1)%Z.","conclusion":"(0 <= Zdigits n - 1)%Z","hypotheses":"(n : Z) (Zn : n <> 0%Z)","proofString":"apply Zlt_0_le_0_pred.\nnow apply Zdigits_gt_0."},{"statement":"(n : Z) (Zn : n <> 0%Z) : (0 < Zdigits n)%Z.","conclusion":"(0 < Zdigits n)%Z","hypotheses":"(n : Z) (Zn : n <> 0%Z)","proofString":"now apply Zdigits_gt_0."},{"statement":"(n : Z) (Zn : n <> 0%Z) : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ (Zdigits n - 1 + 1))%Z.","conclusion":"(beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ (Zdigits n - 1 + 1))%Z","hypotheses":"(n : Z) (Zn : n <> 0%Z)","proofString":"ring_simplify (Zdigits n - 1 + 1)%Z.\napply Zdigits_correct."},{"statement":"(n : Z) (Zn : n <> 0%Z) : (beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z.","conclusion":"(beta ^ (Zdigits n - 1) <= Z.abs n < beta ^ Zdigits n)%Z","hypotheses":"(n : Z) (Zn : n <> 0%Z)","proofString":"apply Zdigits_correct."},{"statement":"(n k l : Z) (Hl : (0 <= l)%Z) : (Zdigits (Zslice n k l) <= l)%Z.","conclusion":"(Zdigits (Zslice n k l) <= l)%Z","hypotheses":"(n k l : Z) (Hl : (0 <= l)%Z)","proofString":"unfold Zslice.\nrewrite Zle_bool_true with (1 := Hl).\ndestruct (Zdigits_correct (Z.rem (Zscale n (- k)) (Zpower beta l))) as (H1,H2).\napply Zpower_lt_Zpower with beta.\napply Z.le_lt_trans with (1 := H1).\nrewrite <- (Z.abs_eq (beta ^ l)) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k l : Z) (Hl : (0 <= l)%Z) : (Zdigits (if 0 <=? l then Z.rem (Zscale n (- k)) (beta ^ l) else 0) <= l)%Z.","conclusion":"(Zdigits (if 0 <=? l then Z.rem (Zscale n (- k)) (beta ^ l) else 0) <= l)%Z","hypotheses":"(n k l : Z) (Hl : (0 <= l)%Z)","proofString":"rewrite Zle_bool_true with (1 := Hl).\ndestruct (Zdigits_correct (Z.rem (Zscale n (- k)) (Zpower beta l))) as (H1,H2).\napply Zpower_lt_Zpower with beta.\napply Z.le_lt_trans with (1 := H1).\nrewrite <- (Z.abs_eq (beta ^ l)) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k l : Z) (Hl : (0 <= l)%Z) : (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) <= l)%Z.","conclusion":"(Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) <= l)%Z","hypotheses":"(n k l : Z) (Hl : (0 <= l)%Z)","proofString":"destruct (Zdigits_correct (Z.rem (Zscale n (- k)) (Zpower beta l))) as (H1,H2).\napply Zpower_lt_Zpower with beta.\napply Z.le_lt_trans with (1 := H1).\nrewrite <- (Z.abs_eq (beta ^ l)) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) : (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) <= l)%Z.","conclusion":"(Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) <= l)%Z","hypotheses":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z)","proofString":"apply Zpower_lt_Zpower with beta.\napply Z.le_lt_trans with (1 := H1).\nrewrite <- (Z.abs_eq (beta ^ l)) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) < beta ^ l)%Z.","conclusion":"(beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) < beta ^ l)%Z","hypotheses":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z)","proofString":"apply Z.le_lt_trans with (1 := H1).\nrewrite <- (Z.abs_eq (beta ^ l)) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) < beta ^ l)%Z.","conclusion":"(Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) < beta ^ l)%Z","hypotheses":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z)","proofString":"rewrite <- (Z.abs_eq (beta ^ l)) at 2 by apply Zpower_ge_0.\napply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) < Z.abs (beta ^ l))%Z.","conclusion":"(Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) < Z.abs (beta ^ l))%Z","hypotheses":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z)","proofString":"apply Zrem_lt.\napply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) : (beta ^ l)%Z <> 0%Z.","conclusion":"(beta ^ l)%Z <> 0%Z","hypotheses":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z)","proofString":"apply Zgt_not_eq.\nnow apply Zpower_gt_0."},{"statement":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) : (0 < beta ^ l)%Z.","conclusion":"(0 < beta ^ l)%Z","hypotheses":"(n k l : Z) (Hl : (0 <= l)%Z) (H1 : (beta ^ (Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)) - 1) <=\n Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)))%Z) (H2 : (Z.abs (Z.rem (Zscale n (- k)) (beta ^ l)) <\n beta ^ Zdigits (Z.rem (Zscale n (- k)) (beta ^ l)))%Z)","proofString":"now apply Zpower_gt_0."},{"statement":"(e : Z) (He : (0 <= e)%Z) : Zdigits (beta ^ e) = (e + 1)%Z.","conclusion":"Zdigits (beta ^ e) = (e + 1)%Z","hypotheses":"(e : Z) (He : (0 <= e)%Z)","proofString":"rewrite <- (Zmult_1_l (Zpower beta e)).\nrewrite Zdigits_mult_Zpower ; try easy.\napply Zplus_comm."},{"statement":"(e : Z) (He : (0 <= e)%Z) : Zdigits (1 * beta ^ e) = (e + 1)%Z.","conclusion":"Zdigits (1 * beta ^ e) = (e + 1)%Z","hypotheses":"(e : Z) (He : (0 <= e)%Z)","proofString":"rewrite Zdigits_mult_Zpower ; try easy.\napply Zplus_comm."},{"statement":"(e : Z) (He : (0 <= e)%Z) : (Zdigits 1 + e)%Z = (e + 1)%Z.","conclusion":"(Zdigits 1 + e)%Z = (e + 1)%Z","hypotheses":"(e : Z) (He : (0 <= e)%Z)","proofString":"apply Zplus_comm."},{"statement":"(x y : Z) (Zx : (0 <= x)%Z) (Hxy : (x <= y)%Z) : (Zdigits x <= Zdigits y)%Z.","conclusion":"(Zdigits x <= Zdigits y)%Z","hypotheses":"(x y : Z) (Zx : (0 <= x)%Z) (Hxy : (x <= y)%Z)","proofString":"assert (Hx := Zdigits_correct x).\nassert (Hy := Zdigits_correct y).\napply (Zpower_lt_Zpower beta).\nlia."},{"statement":"(x y : Z) (Zx : (0 <= x)%Z) (Hxy : (x <= y)%Z) (Hx : (beta ^ (Zdigits x - 1) <= Z.abs x < beta ^ Zdigits x)%Z) : (Zdigits x <= Zdigits y)%Z.","conclusion":"(Zdigits x <= Zdigits y)%Z","hypotheses":"(x y : Z) (Zx : (0 <= x)%Z) (Hxy : (x <= y)%Z) (Hx : (beta ^ (Zdigits x - 1) <= Z.abs x < beta ^ Zdigits x)%Z)","proofString":"assert (Hy := Zdigits_correct y).\napply (Zpower_lt_Zpower beta).\nlia."},{"statement":"(x y : Z) (Zx : (0 <= x)%Z) (Hxy : (x <= y)%Z) (Hx : (beta ^ (Zdigits x - 1) <= Z.abs x < beta ^ Zdigits x)%Z) (Hy : (beta ^ (Zdigits y - 1) <= Z.abs y < beta ^ Zdigits y)%Z) : (Zdigits x <= Zdigits y)%Z.","conclusion":"(Zdigits x <= Zdigits y)%Z","hypotheses":"(x y : Z) (Zx : (0 <= x)%Z) (Hxy : (x <= y)%Z) (Hx : (beta ^ (Zdigits x - 1) <= Z.abs x < beta ^ Zdigits x)%Z) (Hy : (beta ^ (Zdigits y - 1) <= Z.abs y < beta ^ Zdigits y)%Z)","proofString":"apply (Zpower_lt_Zpower beta).\nlia."},{"statement":"(x y : Z) (Zx : (0 <= x)%Z) (Hxy : (x <= y)%Z) (Hx : (beta ^ (Zdigits x - 1) <= Z.abs x < beta ^ Zdigits x)%Z) (Hy : (beta ^ (Zdigits y - 1) <= Z.abs y < beta ^ Zdigits y)%Z) : (beta ^ (Zdigits x - 1) < beta ^ Zdigits y)%Z.","conclusion":"(beta ^ (Zdigits x - 1) < beta ^ Zdigits y)%Z","hypotheses":"(x y : Z) (Zx : (0 <= x)%Z) (Hxy : (x <= y)%Z) (Hx : (beta ^ (Zdigits x - 1) <= Z.abs x < beta ^ Zdigits x)%Z) (Hy : (beta ^ (Zdigits y - 1) <= Z.abs y < beta ^ Zdigits y)%Z)","proofString":"lia."},{"statement":"(x y : Z) (Hy : (0 <= y)%Z) : (Zdigits x < Zdigits y)%Z -> (x < y)%Z.","conclusion":"(Zdigits x < Zdigits y)%Z -> (x < y)%Z","hypotheses":"(x y : Z) (Hy : (0 <= y)%Z)","proofString":"cut (y <= x -> Zdigits y <= Zdigits x)%Z.\nlia.\nnow apply Zdigits_le."},{"statement":"(x y : Z) (Hy : (0 <= y)%Z) : ((y <= x)%Z -> (Zdigits y <= Zdigits x)%Z) ->\n(Zdigits x < Zdigits y)%Z -> (x < y)%Z.","conclusion":"((y <= x)%Z -> (Zdigits y <= Zdigits x)%Z) ->\n(Zdigits x < Zdigits y)%Z -> (x < y)%Z","hypotheses":"(x y : Z) (Hy : (0 <= y)%Z)","proofString":"lia."},{"statement":"(x y : Z) (Hy : (0 <= y)%Z) : (y <= x)%Z -> (Zdigits y <= Zdigits x)%Z.","conclusion":"(y <= x)%Z -> (Zdigits y <= Zdigits x)%Z","hypotheses":"(x y : Z) (Hy : (0 <= y)%Z)","proofString":"now apply Zdigits_le."},{"statement":"(e x : Z) (Hex : (e < Zdigits x)%Z) : (beta ^ e <= Z.abs x)%Z.","conclusion":"(beta ^ e <= Z.abs x)%Z","hypotheses":"(e x : Z) (Hex : (e < Zdigits x)%Z)","proofString":"destruct (Zdigits_correct x) as [H1 H2].\napply Z.le_trans with (2 := H1).\napply Zpower_le.\nclear -Hex ; lia."},{"statement":"(e x : Z) (Hex : (e < Zdigits x)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z) : (beta ^ e <= Z.abs x)%Z.","conclusion":"(beta ^ e <= Z.abs x)%Z","hypotheses":"(e x : Z) (Hex : (e < Zdigits x)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z)","proofString":"apply Z.le_trans with (2 := H1).\napply Zpower_le.\nclear -Hex ; lia."},{"statement":"(e x : Z) (Hex : (e < Zdigits x)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z) : (beta ^ e <= beta ^ (Zdigits x - 1))%Z.","conclusion":"(beta ^ e <= beta ^ (Zdigits x - 1))%Z","hypotheses":"(e x : Z) (Hex : (e < Zdigits x)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z)","proofString":"apply Zpower_le.\nclear -Hex ; lia."},{"statement":"(e x : Z) (Hex : (e < Zdigits x)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z) : (e <= Zdigits x - 1)%Z.","conclusion":"(e <= Zdigits x - 1)%Z","hypotheses":"(e x : Z) (Hex : (e < Zdigits x)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z)","proofString":"clear -Hex ; lia."},{"statement":"(e x : Z) : (Z.abs x < beta ^ e)%Z -> (Zdigits x <= e)%Z.","conclusion":"(Z.abs x < beta ^ e)%Z -> (Zdigits x <= e)%Z","hypotheses":"(e x : Z)","proofString":"generalize (Zpower_le_Zdigits e x).\nlia."},{"statement":"(e x : Z) : ((e < Zdigits x)%Z -> (beta ^ e <= Z.abs x)%Z) ->\n(Z.abs x < beta ^ e)%Z -> (Zdigits x <= e)%Z.","conclusion":"((e < Zdigits x)%Z -> (beta ^ e <= Z.abs x)%Z) ->\n(Z.abs x < beta ^ e)%Z -> (Zdigits x <= e)%Z","hypotheses":"(e x : Z)","proofString":"lia."},{"statement":"(e x : Z) (Hex : (Zdigits x <= e)%Z) : (Z.abs x < beta ^ e)%Z.","conclusion":"(Z.abs x < beta ^ e)%Z","hypotheses":"(e x : Z) (Hex : (Zdigits x <= e)%Z)","proofString":"destruct (Zdigits_correct x) as [H1 H2].\napply Z.lt_le_trans with (1 := H2).\nnow apply Zpower_le."},{"statement":"(e x : Z) (Hex : (Zdigits x <= e)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z) : (Z.abs x < beta ^ e)%Z.","conclusion":"(Z.abs x < beta ^ e)%Z","hypotheses":"(e x : Z) (Hex : (Zdigits x <= e)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z)","proofString":"apply Z.lt_le_trans with (1 := H2).\nnow apply Zpower_le."},{"statement":"(e x : Z) (Hex : (Zdigits x <= e)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z) : (beta ^ Zdigits x <= beta ^ e)%Z.","conclusion":"(beta ^ Zdigits x <= beta ^ e)%Z","hypotheses":"(e x : Z) (Hex : (Zdigits x <= e)%Z) (H1 : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z) (H2 : (Z.abs x < beta ^ Zdigits x)%Z)","proofString":"now apply Zpower_le."},{"statement":"(e x : Z) (Hex : (beta ^ e <= Z.abs x)%Z) : (e < Zdigits x)%Z.","conclusion":"(e < Zdigits x)%Z","hypotheses":"(e x : Z) (Hex : (beta ^ e <= Z.abs x)%Z)","proofString":"generalize (Zpower_gt_Zdigits e x).\nlia."},{"statement":"(e x : Z) (Hex : (beta ^ e <= Z.abs x)%Z) : ((Zdigits x <= e)%Z -> (Z.abs x < beta ^ e)%Z) -> (e < Zdigits x)%Z.","conclusion":"((Zdigits x <= e)%Z -> (Z.abs x < beta ^ e)%Z) -> (e < Zdigits x)%Z","hypotheses":"(e x : Z) (Hex : (beta ^ e <= Z.abs x)%Z)","proofString":"lia."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (Zdigits (x + y + x * y) <= Zdigits x + Zdigits y)%Z.","conclusion":"(Zdigits (x + y + x * y) <= Zdigits x + Zdigits y)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"apply Zdigits_le_Zpower.\nrewrite Z.abs_eq.\napply Z.lt_le_trans with ((x + 1) * (y + 1))%Z.\nring_simplify.\napply Zle_lt_succ, Z.le_refl.\nrewrite Zpower_plus by apply Zdigits_ge_0.\napply Zmult_le_compat.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq x) at 1 by easy.\napply Zdigits_correct.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq y) at 1 by easy.\napply Zdigits_correct.\nclear -Hx ; lia.\nclear -Hy ; lia.\nchange Z0 with (0 + 0 + 0)%Z.\napply Zplus_le_compat.\nnow apply Zplus_le_compat.\nnow apply Zmult_le_0_compat."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (Z.abs (x + y + x * y) < beta ^ (Zdigits x + Zdigits y))%Z.","conclusion":"(Z.abs (x + y + x * y) < beta ^ (Zdigits x + Zdigits y))%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"rewrite Z.abs_eq.\napply Z.lt_le_trans with ((x + 1) * (y + 1))%Z.\nring_simplify.\napply Zle_lt_succ, Z.le_refl.\nrewrite Zpower_plus by apply Zdigits_ge_0.\napply Zmult_le_compat.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq x) at 1 by easy.\napply Zdigits_correct.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq y) at 1 by easy.\napply Zdigits_correct.\nclear -Hx ; lia.\nclear -Hy ; lia.\nchange Z0 with (0 + 0 + 0)%Z.\napply Zplus_le_compat.\nnow apply Zplus_le_compat.\nnow apply Zmult_le_0_compat."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (x + y + x * y < beta ^ (Zdigits x + Zdigits y))%Z.","conclusion":"(x + y + x * y < beta ^ (Zdigits x + Zdigits y))%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"apply Z.lt_le_trans with ((x + 1) * (y + 1))%Z.\nring_simplify.\napply Zle_lt_succ, Z.le_refl.\nrewrite Zpower_plus by apply Zdigits_ge_0.\napply Zmult_le_compat.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq x) at 1 by easy.\napply Zdigits_correct.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq y) at 1 by easy.\napply Zdigits_correct.\nclear -Hx ; lia.\nclear -Hy ; lia."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (x + y + x * y < (x + 1) * (y + 1))%Z.","conclusion":"(x + y + x * y < (x + 1) * (y + 1))%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"ring_simplify.\napply Zle_lt_succ, Z.le_refl."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (x * y + x + y < x * y + x + y + 1)%Z.","conclusion":"(x * y + x + y < x * y + x + y + 1)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"apply Zle_lt_succ, Z.le_refl."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : ((x + 1) * (y + 1) <= beta ^ (Zdigits x + Zdigits y))%Z.","conclusion":"((x + 1) * (y + 1) <= beta ^ (Zdigits x + Zdigits y))%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"rewrite Zpower_plus by apply Zdigits_ge_0.\napply Zmult_le_compat.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq x) at 1 by easy.\napply Zdigits_correct.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq y) at 1 by easy.\napply Zdigits_correct.\nclear -Hx ; lia.\nclear -Hy ; lia."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : ((x + 1) * (y + 1) <= beta ^ Zdigits x * beta ^ Zdigits y)%Z.","conclusion":"((x + 1) * (y + 1) <= beta ^ Zdigits x * beta ^ Zdigits y)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"apply Zmult_le_compat.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq x) at 1 by easy.\napply Zdigits_correct.\napply Zlt_le_succ.\nrewrite <- (Z.abs_eq y) at 1 by easy.\napply Zdigits_correct.\nclear -Hx ; lia.\nclear -Hy ; lia."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (x + 1 <= beta ^ Zdigits x)%Z.","conclusion":"(x + 1 <= beta ^ Zdigits x)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"apply Zlt_le_succ.\nrewrite <- (Z.abs_eq x) at 1 by easy.\napply Zdigits_correct."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (x < beta ^ Zdigits x)%Z.","conclusion":"(x < beta ^ Zdigits x)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"rewrite <- (Z.abs_eq x) at 1 by easy.\napply Zdigits_correct."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (Z.abs x < beta ^ Zdigits x)%Z.","conclusion":"(Z.abs x < beta ^ Zdigits x)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"apply Zdigits_correct."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (y + 1 <= beta ^ Zdigits y)%Z.","conclusion":"(y + 1 <= beta ^ Zdigits y)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"apply Zlt_le_succ.\nrewrite <- (Z.abs_eq y) at 1 by easy.\napply Zdigits_correct."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (y < beta ^ Zdigits y)%Z.","conclusion":"(y < beta ^ Zdigits y)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"rewrite <- (Z.abs_eq y) at 1 by easy.\napply Zdigits_correct."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (Z.abs y < beta ^ Zdigits y)%Z.","conclusion":"(Z.abs y < beta ^ Zdigits y)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"apply Zdigits_correct."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (0 <= x + 1)%Z.","conclusion":"(0 <= x + 1)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"clear -Hx ; lia."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (0 <= y + 1)%Z.","conclusion":"(0 <= y + 1)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"clear -Hy ; lia."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (0 <= x + y + x * y)%Z.","conclusion":"(0 <= x + y + x * y)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"change Z0 with (0 + 0 + 0)%Z.\napply Zplus_le_compat.\nnow apply Zplus_le_compat.\nnow apply Zmult_le_0_compat."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (0 + 0 + 0 <= x + y + x * y)%Z.","conclusion":"(0 + 0 + 0 <= x + y + x * y)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"apply Zplus_le_compat.\nnow apply Zplus_le_compat.\nnow apply Zmult_le_0_compat."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (0 + 0 <= x + y)%Z.","conclusion":"(0 + 0 <= x + y)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"now apply Zplus_le_compat."},{"statement":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z) : (0 <= x * y)%Z.","conclusion":"(0 <= x * y)%Z","hypotheses":"(x y : Z) (Hx : (0 <= x)%Z) (Hy : (0 <= y)%Z)","proofString":"now apply Zmult_le_0_compat."},{"statement":"(x y : Z) : (Zdigits (x * y) <= Zdigits x + Zdigits y)%Z.","conclusion":"(Zdigits (x * y) <= Zdigits x + Zdigits y)%Z","hypotheses":"(x y : Z)","proofString":"rewrite <- Zdigits_abs.\nrewrite <- (Zdigits_abs x).\nrewrite <- (Zdigits_abs y).\napply Z.le_trans with (Zdigits (Z.abs x + Z.abs y + Z.abs x * Z.abs y)).\napply Zdigits_le.\napply Zabs_pos.\nrewrite Zabs_Zmult.\ngeneralize (Zabs_pos x) (Zabs_pos y).\nlia.\napply Zdigits_mult_strong ; apply Zabs_pos."},{"statement":"(x y : Z) : (Zdigits (Z.abs (x * y)) <= Zdigits x + Zdigits y)%Z.","conclusion":"(Zdigits (Z.abs (x * y)) <= Zdigits x + Zdigits y)%Z","hypotheses":"(x y : Z)","proofString":"rewrite <- (Zdigits_abs x).\nrewrite <- (Zdigits_abs y).\napply Z.le_trans with (Zdigits (Z.abs x + Z.abs y + Z.abs x * Z.abs y)).\napply Zdigits_le.\napply Zabs_pos.\nrewrite Zabs_Zmult.\ngeneralize (Zabs_pos x) (Zabs_pos y).\nlia.\napply Zdigits_mult_strong ; apply Zabs_pos."},{"statement":"(x y : Z) : (Zdigits (Z.abs (x * y)) <= Zdigits (Z.abs x) + Zdigits y)%Z.","conclusion":"(Zdigits (Z.abs (x * y)) <= Zdigits (Z.abs x) + Zdigits y)%Z","hypotheses":"(x y : Z)","proofString":"rewrite <- (Zdigits_abs y).\napply Z.le_trans with (Zdigits (Z.abs x + Z.abs y + Z.abs x * Z.abs y)).\napply Zdigits_le.\napply Zabs_pos.\nrewrite Zabs_Zmult.\ngeneralize (Zabs_pos x) (Zabs_pos y).\nlia.\napply Zdigits_mult_strong ; apply Zabs_pos."},{"statement":"(x y : Z) : (Zdigits (Z.abs (x * y)) <= Zdigits (Z.abs x) + Zdigits (Z.abs y))%Z.","conclusion":"(Zdigits (Z.abs (x * y)) <= Zdigits (Z.abs x) + Zdigits (Z.abs y))%Z","hypotheses":"(x y : Z)","proofString":"apply Z.le_trans with (Zdigits (Z.abs x + Z.abs y + Z.abs x * Z.abs y)).\napply Zdigits_le.\napply Zabs_pos.\nrewrite Zabs_Zmult.\ngeneralize (Zabs_pos x) (Zabs_pos y).\nlia.\napply Zdigits_mult_strong ; apply Zabs_pos."},{"statement":"(x y : Z) : (0 <= Z.abs (x * y))%Z.","conclusion":"(0 <= Z.abs (x * y))%Z","hypotheses":"(x y : Z)","proofString":"apply Zabs_pos."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (Zdigits x + Zdigits y - 1 <= Zdigits (x * y))%Z.","conclusion":"(Zdigits x + Zdigits y - 1 <= Zdigits (x * y))%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"cut ((Zdigits x - 1) + (Zdigits y - 1) < Zdigits (x * y))%Z.\nlia.\napply Zdigits_gt_Zpower.\nrewrite Zabs_Zmult.\nrewrite Zpower_exp.\napply Zmult_le_compat.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_ge_0.\napply Zpower_ge_0.\ngeneralize (Zdigits_gt_0 x).\nlia.\ngeneralize (Zdigits_gt_0 y).\nlia."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (Zdigits x - 1 + (Zdigits y - 1) < Zdigits (x * y))%Z ->\n(Zdigits x + Zdigits y - 1 <= Zdigits (x * y))%Z.","conclusion":"(Zdigits x - 1 + (Zdigits y - 1) < Zdigits (x * y))%Z ->\n(Zdigits x + Zdigits y - 1 <= Zdigits (x * y))%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"lia."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (Zdigits x - 1 + (Zdigits y - 1) < Zdigits (x * y))%Z.","conclusion":"(Zdigits x - 1 + (Zdigits y - 1) < Zdigits (x * y))%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"apply Zdigits_gt_Zpower.\nrewrite Zabs_Zmult.\nrewrite Zpower_exp.\napply Zmult_le_compat.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_ge_0.\napply Zpower_ge_0.\ngeneralize (Zdigits_gt_0 x).\nlia.\ngeneralize (Zdigits_gt_0 y).\nlia."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (beta ^ (Zdigits x - 1 + (Zdigits y - 1)) <= Z.abs (x * y))%Z.","conclusion":"(beta ^ (Zdigits x - 1 + (Zdigits y - 1)) <= Z.abs (x * y))%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"rewrite Zabs_Zmult.\nrewrite Zpower_exp.\napply Zmult_le_compat.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_ge_0.\napply Zpower_ge_0.\ngeneralize (Zdigits_gt_0 x).\nlia.\ngeneralize (Zdigits_gt_0 y).\nlia."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (beta ^ (Zdigits x - 1 + (Zdigits y - 1)) <= Z.abs x * Z.abs y)%Z.","conclusion":"(beta ^ (Zdigits x - 1 + (Zdigits y - 1)) <= Z.abs x * Z.abs y)%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"rewrite Zpower_exp.\napply Zmult_le_compat.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_ge_0.\napply Zpower_ge_0.\ngeneralize (Zdigits_gt_0 x).\nlia.\ngeneralize (Zdigits_gt_0 y).\nlia."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (beta ^ (Zdigits x - 1) * beta ^ (Zdigits y - 1) <= Z.abs x * Z.abs y)%Z.","conclusion":"(beta ^ (Zdigits x - 1) * beta ^ (Zdigits y - 1) <= Z.abs x * Z.abs y)%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"apply Zmult_le_compat.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_le_Zdigits.\napply Zlt_pred.\napply Zpower_ge_0.\napply Zpower_ge_0."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (beta ^ (Zdigits x - 1) <= Z.abs x)%Z.","conclusion":"(beta ^ (Zdigits x - 1) <= Z.abs x)%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"apply Zpower_le_Zdigits.\napply Zlt_pred."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (Zdigits x - 1 < Zdigits x)%Z.","conclusion":"(Zdigits x - 1 < Zdigits x)%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"apply Zlt_pred."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (beta ^ (Zdigits y - 1) <= Z.abs y)%Z.","conclusion":"(beta ^ (Zdigits y - 1) <= Z.abs y)%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"apply Zpower_le_Zdigits.\napply Zlt_pred."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (Zdigits y - 1 < Zdigits y)%Z.","conclusion":"(Zdigits y - 1 < Zdigits y)%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"apply Zlt_pred."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (0 <= beta ^ (Zdigits x - 1))%Z.","conclusion":"(0 <= beta ^ (Zdigits x - 1))%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"apply Zpower_ge_0."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (0 <= beta ^ (Zdigits y - 1))%Z.","conclusion":"(0 <= beta ^ (Zdigits y - 1))%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"apply Zpower_ge_0."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (x <> 0%Z -> (0 < Zdigits x)%Z) -> (Zdigits x - 1 >= 0)%Z.","conclusion":"(x <> 0%Z -> (0 < Zdigits x)%Z) -> (Zdigits x - 1 >= 0)%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"generalize (Zdigits_gt_0 y).\nlia."},{"statement":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z) : (y <> 0%Z -> (0 < Zdigits y)%Z) ->\n(x <> 0%Z -> (0 < Zdigits x)%Z) -> (Zdigits x - 1 >= 0)%Z.","conclusion":"(y <> 0%Z -> (0 < Zdigits y)%Z) ->\n(x <> 0%Z -> (0 < Zdigits x)%Z) -> (Zdigits x - 1 >= 0)%Z","hypotheses":"(x y : Z) (Zx : x <> 0%Z) (Zy : y <> 0%Z)","proofString":"lia."},{"statement":"(p : positive) : (Zdigits (Z.pos p + 1) <= Zdigits (Z.pos p) + 1)%Z.","conclusion":"(Zdigits (Z.pos p + 1) <= Zdigits (Z.pos p) + 1)%Z","hypotheses":"(p : positive)","proofString":"transitivity (Zdigits (Z.pos p * beta ^ 1));    [apply Zdigits_le; [lia |] | rewrite Zdigits_mult_Zpower; lia].\napply Ztac.Zlt_le_add_1.\nrewrite <-Z.mul_1_r at 1.\napply Zmult_lt_compat_l; [lia |].\nrewrite Z.pow_1_r.\napply radix_gt_1."},{"statement":"(p : positive) : (Z.pos p + 1 <= Z.pos p * beta ^ 1)%Z.","conclusion":"(Z.pos p + 1 <= Z.pos p * beta ^ 1)%Z","hypotheses":"(p : positive)","proofString":"apply Ztac.Zlt_le_add_1.\nrewrite <-Z.mul_1_r at 1.\napply Zmult_lt_compat_l; [lia |].\nrewrite Z.pow_1_r.\napply radix_gt_1."},{"statement":"(p : positive) : (Z.pos p < Z.pos p * beta ^ 1)%Z.","conclusion":"(Z.pos p < Z.pos p * beta ^ 1)%Z","hypotheses":"(p : positive)","proofString":"rewrite <-Z.mul_1_r at 1.\napply Zmult_lt_compat_l; [lia |].\nrewrite Z.pow_1_r.\napply radix_gt_1."},{"statement":"(p : positive) : (Z.pos p * 1 < Z.pos p * beta ^ 1)%Z.","conclusion":"(Z.pos p * 1 < Z.pos p * beta ^ 1)%Z","hypotheses":"(p : positive)","proofString":"apply Zmult_lt_compat_l; [lia |].\nrewrite Z.pow_1_r.\napply radix_gt_1."},{"statement":"(p : positive) : (1 < beta ^ 1)%Z.","conclusion":"(1 < beta ^ 1)%Z","hypotheses":"(p : positive)","proofString":"rewrite Z.pow_1_r.\napply radix_gt_1."},{"statement":"(p : positive) : (1 < beta)%Z.","conclusion":"(1 < beta)%Z","hypotheses":"(p : positive)","proofString":"apply radix_gt_1."},{"statement":"(m : positive) : Z.of_nat (S (digits2_Pnat m)) = Zdigits radix2 (Z.pos m).","conclusion":"Z.of_nat (S (digits2_Pnat m)) = Zdigits radix2 (Z.pos m)","hypotheses":"(m : positive)","proofString":"apply eq_sym, Zdigits_unique.\nrewrite <- Zpower_nat_Z.\nrewrite Nat2Z.inj_succ.\nchange (_ - 1)%Z with (Z.pred (Z.succ (Z.of_nat (digits2_Pnat m)))).\nrewrite <- Zpred_succ.\nrewrite <- Zpower_nat_Z.\napply digits2_Pnat_correct."},{"statement":"(m : positive) : (radix2 ^ (Z.of_nat (S (digits2_Pnat m)) - 1) <= Z.abs (Z.pos m) <\n radix2 ^ Z.of_nat (S (digits2_Pnat m)))%Z.","conclusion":"(radix2 ^ (Z.of_nat (S (digits2_Pnat m)) - 1) <= Z.abs (Z.pos m) <\n radix2 ^ Z.of_nat (S (digits2_Pnat m)))%Z","hypotheses":"(m : positive)","proofString":"rewrite <- Zpower_nat_Z.\nrewrite Nat2Z.inj_succ.\nchange (_ - 1)%Z with (Z.pred (Z.succ (Z.of_nat (digits2_Pnat m)))).\nrewrite <- Zpred_succ.\nrewrite <- Zpower_nat_Z.\napply digits2_Pnat_correct."},{"statement":"(m : positive) : (radix2 ^ (Z.of_nat (S (digits2_Pnat m)) - 1) <= Z.abs (Z.pos m) <\n Zpower_nat radix2 (S (digits2_Pnat m)))%Z.","conclusion":"(radix2 ^ (Z.of_nat (S (digits2_Pnat m)) - 1) <= Z.abs (Z.pos m) <\n Zpower_nat radix2 (S (digits2_Pnat m)))%Z","hypotheses":"(m : positive)","proofString":"rewrite Nat2Z.inj_succ.\nchange (_ - 1)%Z with (Z.pred (Z.succ (Z.of_nat (digits2_Pnat m)))).\nrewrite <- Zpred_succ.\nrewrite <- Zpower_nat_Z.\napply digits2_Pnat_correct."},{"statement":"(m : positive) : (radix2 ^ (Z.succ (Z.of_nat (digits2_Pnat m)) - 1) <= \n Z.abs (Z.pos m) < Zpower_nat radix2 (S (digits2_Pnat m)))%Z.","conclusion":"(radix2 ^ (Z.succ (Z.of_nat (digits2_Pnat m)) - 1) <= \n Z.abs (Z.pos m) < Zpower_nat radix2 (S (digits2_Pnat m)))%Z","hypotheses":"(m : positive)","proofString":"change (_ - 1)%Z with (Z.pred (Z.succ (Z.of_nat (digits2_Pnat m)))).\nrewrite <- Zpred_succ.\nrewrite <- Zpower_nat_Z.\napply digits2_Pnat_correct."},{"statement":"(m : positive) : (radix2 ^ Z.pred (Z.succ (Z.of_nat (digits2_Pnat m))) <= \n Z.abs (Z.pos m) < Zpower_nat radix2 (S (digits2_Pnat m)))%Z.","conclusion":"(radix2 ^ Z.pred (Z.succ (Z.of_nat (digits2_Pnat m))) <= \n Z.abs (Z.pos m) < Zpower_nat radix2 (S (digits2_Pnat m)))%Z","hypotheses":"(m : positive)","proofString":"rewrite <- Zpred_succ.\nrewrite <- Zpower_nat_Z.\napply digits2_Pnat_correct."},{"statement":"(m : positive) : (radix2 ^ Z.of_nat (digits2_Pnat m) <= Z.abs (Z.pos m) <\n Zpower_nat radix2 (S (digits2_Pnat m)))%Z.","conclusion":"(radix2 ^ Z.of_nat (digits2_Pnat m) <= Z.abs (Z.pos m) <\n Zpower_nat radix2 (S (digits2_Pnat m)))%Z","hypotheses":"(m : positive)","proofString":"rewrite <- Zpower_nat_Z.\napply digits2_Pnat_correct."},{"statement":"(m : positive) : (Zpower_nat radix2 (digits2_Pnat m) <= Z.abs (Z.pos m) <\n Zpower_nat radix2 (S (digits2_Pnat m)))%Z.","conclusion":"(Zpower_nat radix2 (digits2_Pnat m) <= Z.abs (Z.pos m) <\n Zpower_nat radix2 (S (digits2_Pnat m)))%Z","hypotheses":"(m : positive)","proofString":"apply digits2_Pnat_correct."},{"statement":"(m : positive) : Z.pos (SpecFloat.digits2_pos m) = Zdigits radix2 (Z.pos m).","conclusion":"Z.pos (SpecFloat.digits2_pos m) = Zdigits radix2 (Z.pos m)","hypotheses":"(m : positive)","proofString":"rewrite <- Z_of_nat_S_digits2_Pnat.\nunfold Z.of_nat.\napply f_equal.\ninduction m ; simpl ; try easy ;  apply f_equal, IHm."},{"statement":"(m : positive) : Z.pos (SpecFloat.digits2_pos m) = Z.of_nat (S (digits2_Pnat m)).","conclusion":"Z.pos (SpecFloat.digits2_pos m) = Z.of_nat (S (digits2_Pnat m))","hypotheses":"(m : positive)","proofString":"unfold Z.of_nat.\napply f_equal.\ninduction m ; simpl ; try easy ;  apply f_equal, IHm."},{"statement":"(m : positive) : Z.pos (SpecFloat.digits2_pos m) = Z.pos (Pos.of_succ_nat (digits2_Pnat m)).","conclusion":"Z.pos (SpecFloat.digits2_pos m) = Z.pos (Pos.of_succ_nat (digits2_Pnat m))","hypotheses":"(m : positive)","proofString":"apply f_equal.\ninduction m ; simpl ; try easy ;  apply f_equal, IHm."},{"statement":"(m : positive) : SpecFloat.digits2_pos m = Pos.of_succ_nat (digits2_Pnat m).","conclusion":"SpecFloat.digits2_pos m = Pos.of_succ_nat (digits2_Pnat m)","hypotheses":"(m : positive)","proofString":"induction m ; simpl ; try easy ;  apply f_equal, IHm."}]}