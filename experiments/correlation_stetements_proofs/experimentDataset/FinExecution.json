[{"statement":"Lemma fin_exec_full_equiv (G: execution):\n  fin_exec_full G <-> fin_exec G /\\ set_finite (acts_set G ∩₁ is_init).","proof":"unfold fin_exec, fin_exec_full.\nrewrite <- set_finite_union.\napply set_finite_more.\nrewrite set_minusE, set_unionC, <- set_inter_union_r, <- set_full_split.\nbasic_solver.\n"},{"statement":"Lemma exists_nE thread :\n    exists n, ~ acts_set G (ThreadEvent thread n).","proof":"set (AA:=FINDOM).\napply set_finite_exists_bigger with (f:=ThreadEvent thread) in AA.\n3: {\nins.\ndesf.\n}\n2: {\napply eq_dec_actid.\n}\ndesf.\nexists (1 + n).\napply AA.\nlia.\n"},{"statement":"Lemma acts_set_findom: acts_set G \\₁ is_init ≡₁ (fun e => In e acts_list).","proof":"unfold acts_list.\ndestruct constructive_indefinite_description.\nsimpl.\nsplit; intros e.\nall: rewrite in_filterP_iff; intuition.\napply i.\napply H.\n"},{"statement":"Lemma fin_exec_same_events G G'\n      (SAME: acts_set G ≡₁ acts_set G') (FIN: fin_exec G):\n  fin_exec G'.","proof":"unfold fin_exec in *.\nby rewrite <- SAME.\n"},{"statement":"Lemma tid_is_init_fin_helper (S: actid -> Prop) thread\n      (NT: thread <> tid_init)\n      (FIN: set_finite (S \\₁ is_init)):\n  set_finite (S ∩₁ Tid_ thread).","proof":"rewrite set_split_complete with (s := is_init).\napply set_finite_union.\nsplit.\n{\neapply set_finite_mori; [| by apply set_finite_empty].\nred.\nunfolder.\nins.\ndesc.\nvauto.\nby destruct x.\n}\neapply set_finite_mori; [| by apply FIN].\nred.\nbasic_solver.\n"}]