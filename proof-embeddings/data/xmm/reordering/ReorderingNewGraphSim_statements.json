{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/reordering/ReorderingNewGraphSim.v","fileSamples":[{"statement":"(NEQ : a_t <> b_t) : A_s ⊆₁ (fun x : actid => ~ same_loc_s a_t x).","proofString":"clear - NLOC INV.\nunfold extra_a; desf.\nunfolder in *.\nintros x XEQ.\nsubst x.\nintro FALSO.\napply NLOC with b_t.\napply extra_a_some; desf.\nunfold same_loc in FALSO.\nrewrite <- (rsr_rex_labloc_helper l_a INV) by desf.\narewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"A_s ⊆₁ (fun x : actid => ~ same_loc_s a_t x).","proofString":"unfold extra_a; desf.\nunfolder in *.\nintros x XEQ.\nsubst x.\nintro FALSO.\napply NLOC with b_t.\napply extra_a_some; desf.\nunfold same_loc in FALSO.\nrewrite <- (rsr_rex_labloc_helper l_a INV) by desf.\narewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) : eq b_t ⊆₁ (fun x : actid => ~ same_loc_s a_t x).","proofString":"unfolder in *.\nintros x XEQ.\nsubst x.\nintro FALSO.\napply NLOC with b_t.\napply extra_a_some; desf.\nunfold same_loc in FALSO.\nrewrite <- (rsr_rex_labloc_helper l_a INV) by desf.\narewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) : forall x : actid, b_t = x -> ~ same_loc_s a_t x.","proofString":"intros x XEQ.\nsubst x.\nintro FALSO.\napply NLOC with b_t.\napply extra_a_some; desf.\nunfold same_loc in FALSO.\nrewrite <- (rsr_rex_labloc_helper l_a INV) by desf.\narewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) (x : actid) (XEQ : b_t = x) : ~ same_loc_s a_t x.","proofString":"subst x.\nintro FALSO.\napply NLOC with b_t.\napply extra_a_some; desf.\nunfold same_loc in FALSO.\nrewrite <- (rsr_rex_labloc_helper l_a INV) by desf.\narewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) : ~ same_loc_s a_t b_t.","proofString":"intro FALSO.\napply NLOC with b_t.\napply extra_a_some; desf.\nunfold same_loc in FALSO.\nrewrite <- (rsr_rex_labloc_helper l_a INV) by desf.\narewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) (FALSO : same_loc_s a_t b_t) : False.","proofString":"apply NLOC with b_t.\napply extra_a_some; desf.\nunfold same_loc in FALSO.\nrewrite <- (rsr_rex_labloc_helper l_a INV) by desf.\narewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) (FALSO : same_loc_s a_t b_t) : A_s b_t.","proofString":"apply extra_a_some; desf."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) (FALSO : same_loc_s a_t b_t) : WCore.lab_loc l_a = loc_t b_t.","proofString":"unfold same_loc in FALSO.\nrewrite <- (rsr_rex_labloc_helper l_a INV) by desf.\narewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) (FALSO : loc_s a_t = loc_s b_t) : WCore.lab_loc l_a = loc_t b_t.","proofString":"rewrite <- (rsr_rex_labloc_helper l_a INV) by desf.\narewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) (FALSO : loc_s a_t = loc_s b_t) : loc_s b_t = loc_t b_t.","proofString":"arewrite (loc_t b_t = loc_s a_t); [| congruence].\nsimpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) (FALSO : loc_s a_t = loc_s b_t) : loc_t b_t = loc_s a_t.","proofString":"simpl.\nunfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) (FALSO : loc_s a_t = loc_s b_t) : loc_t b_t = loc (lab_s_ X_t a_t b_t l_a) a_t.","proofString":"unfold lab_s_, compose; desf; [| tauto].\nunfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t) (a0 : E_t b_t) (FALSO : loc_s a_t = loc_s b_t) (a1 : ~ E_t a_t /\\ E_t b_t) : loc_t b_t = loc (fun x : actid => upd lab_t a_t l_a (mapper x)) a_t.","proofString":"unfold loc.\nrewrite rsr_mapper_at, updo; congruence."},{"statement":"(a : ~ E_t a_t) (a0 : E_t b_t) (FALSO : loc_s a_t = loc_s b_t) (a1 : ~ E_t a_t /\\ E_t b_t) : match lab_t b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch upd lab_t a_t l_a (mapper a_t) with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"rewrite rsr_mapper_at, updo; congruence."},{"statement":"A_s ⊆₁ R_s ∪₁ W_s.","proofString":"unfold extra_a; desf.\nunfolder in *.\nintros x XEQ.\nsubst x.\nsimpl.\nunfold lab_s_.\ndesf; [| tauto].\nunfold is_r, is_w, compose.\nrewrite rsr_mapper_bt, upds by apply INV.\nunfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) : eq b_t ⊆₁ R_s ∪₁ W_s.","proofString":"unfolder in *.\nintros x XEQ.\nsubst x.\nsimpl.\nunfold lab_s_.\ndesf; [| tauto].\nunfold is_r, is_w, compose.\nrewrite rsr_mapper_bt, upds by apply INV.\nunfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) : forall x : actid, b_t = x -> is_r lab_s x \\/ is_w lab_s x.","proofString":"intros x XEQ.\nsubst x.\nsimpl.\nunfold lab_s_.\ndesf; [| tauto].\nunfold is_r, is_w, compose.\nrewrite rsr_mapper_bt, upds by apply INV.\nunfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) (x : actid) (XEQ : b_t = x) : is_r lab_s x \\/ is_w lab_s x.","proofString":"subst x.\nsimpl.\nunfold lab_s_.\ndesf; [| tauto].\nunfold is_r, is_w, compose.\nrewrite rsr_mapper_bt, upds by apply INV.\nunfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) : is_r lab_s b_t \\/ is_w lab_s b_t.","proofString":"simpl.\nunfold lab_s_.\ndesf; [| tauto].\nunfold is_r, is_w, compose.\nrewrite rsr_mapper_bt, upds by apply INV.\nunfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) : is_r (lab_s_ X_t a_t b_t l_a) b_t \\/ is_w (lab_s_ X_t a_t b_t l_a) b_t.","proofString":"unfold lab_s_.\ndesf; [| tauto].\nunfold is_r, is_w, compose.\nrewrite rsr_mapper_bt, upds by apply INV.\nunfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) : is_r ((ifP ~ E_t a_t /\\ E_t b_t then upd lab_t a_t l_a else lab_t) ∘ mapper)\n  b_t \\/\nis_w ((ifP ~ E_t a_t /\\ E_t b_t then upd lab_t a_t l_a else lab_t) ∘ mapper)\n  b_t.","proofString":"desf; [| tauto].\nunfold is_r, is_w, compose.\nrewrite rsr_mapper_bt, upds by apply INV.\nunfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t) (a0 : E_t b_t) (a1 : ~ E_t a_t /\\ E_t b_t) : is_r (upd lab_t a_t l_a ∘ mapper) b_t \\/\nis_w (upd lab_t a_t l_a ∘ mapper) b_t.","proofString":"unfold is_r, is_w, compose.\nrewrite rsr_mapper_bt, upds by apply INV.\nunfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t) (a0 : E_t b_t) (a1 : ~ E_t a_t /\\ E_t b_t) : match upd lab_t a_t l_a (mapper b_t) with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/\nmatch upd lab_t a_t l_a (mapper b_t) with\n| Astore _ _ _ _ => true\n| _ => false\nend.","proofString":"rewrite rsr_mapper_bt, upds by apply INV.\nunfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t) (a0 : E_t b_t) (a1 : ~ E_t a_t /\\ E_t b_t) : match l_a with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/ match l_a with\n       | Astore _ _ _ _ => true\n       | _ => false\n       end.","proofString":"unfold WCore.lab_is_r, WCore.lab_is_w in *.\ndesf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(a : ~ E_t a_t) (a0 : E_t b_t) (a1 : ~ E_t a_t /\\ E_t b_t) : match l_a with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/ match l_a with\n       | Astore _ _ _ _ => true\n       | _ => false\n       end.","proofString":"desf; eauto.\nforward apply (ARW b_t); [| basic_solver].\napply extra_a_some; auto."},{"statement":"(o : mode) (a : ~ E_t a_t) (a0 : E_t b_t) (a1 : ~ E_t a_t) (a2 : E_t b_t) : A_s b_t.","proofString":"apply extra_a_some; auto."},{"statement":"E_s ∩₁ eq a_t ⊆₁ set_compl (Acq_s ∪₁ Rel_s).","proofString":"assert (NEQ : a_t <> b_t) by apply INV.\nchange E_s with (E_s'' ∪₁ A_s).\nrewrite set_inter_union_l.\narewrite (A_s ∩₁ eq a_t ⊆₁ ∅).\nunfold extra_a; desf; basic_solver.\nrewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t).\nforward apply RLX.\nunfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto.\nenough (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t).\nforward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : E_s ∩₁ eq a_t ⊆₁ set_compl (Acq_s ∪₁ Rel_s).","proofString":"change E_s with (E_s'' ∪₁ A_s).\nrewrite set_inter_union_l.\narewrite (A_s ∩₁ eq a_t ⊆₁ ∅).\nunfold extra_a; desf; basic_solver.\nrewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t).\nforward apply RLX.\nunfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto.\nenough (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t).\nforward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : (E_s'' ∪₁ A_s) ∩₁ eq a_t ⊆₁ set_compl (Acq_s ∪₁ Rel_s).","proofString":"rewrite set_inter_union_l.\narewrite (A_s ∩₁ eq a_t ⊆₁ ∅).\nunfold extra_a; desf; basic_solver.\nrewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t).\nforward apply RLX.\nunfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto.\nenough (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t).\nforward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : E_s'' ∩₁ eq a_t ∪₁ A_s ∩₁ eq a_t ⊆₁ set_compl (Acq_s ∪₁ Rel_s).","proofString":"arewrite (A_s ∩₁ eq a_t ⊆₁ ∅).\nunfold extra_a; desf; basic_solver.\nrewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t).\nforward apply RLX.\nunfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto.\nenough (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t).\nforward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : A_s ∩₁ eq a_t ⊆₁ ∅.","proofString":"unfold extra_a; desf; basic_solver."},{"statement":"(NEQ : a_t <> b_t) : E_s'' ∩₁ eq a_t ∪₁ ∅ ⊆₁ set_compl (Acq_s ∪₁ Rel_s).","proofString":"rewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t).\nforward apply RLX.\nunfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto.\nenough (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t).\nforward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : E_s'' ∩₁ eq a_t ⊆₁ set_compl (Acq_s ∪₁ Rel_s).","proofString":"intros x (XIN & XEQ).\nsubst x.\nenough (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t).\nforward apply RLX.\nunfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto.\nenough (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t).\nforward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (x : actid) (XIN : E_s'' x) (XEQ : a_t = x) : set_compl (Acq_s ∪₁ Rel_s) x.","proofString":"subst x.\nenough (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t).\nforward apply RLX.\nunfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto.\nenough (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t).\nforward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : set_compl (Acq_s ∪₁ Rel_s) a_t.","proofString":"enough (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t).\nforward apply RLX.\nunfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto.\nenough (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t).\nforward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t) : set_compl (Acq_s ∪₁ Rel_s) a_t.","proofString":"forward apply RLX.\nunfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t) : set_compl (Acq_s'' ∪₁ Rel_s'') a_t -> set_compl (Acq_s ∪₁ Rel_s) a_t.","proofString":"unfolder.\nunfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RLX : set_compl (Acq_s'' ∪₁ Rel_s'') a_t) : ~ (is_acq lab_s'' a_t \\/ is_rel lab_s'' a_t) ->\n~ (is_acq lab_s a_t \\/ is_rel lab_s a_t).","proofString":"unfold is_acq, is_rel, mod in *.\nrewrite <- rsr_rexi; auto."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RLX : set_compl\n  ((fun e : actid =>\n    mode_le Oacq\n      match lab_s'' e with\n      | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n      end)\n   ∪₁ (fun e : actid =>\n       mode_le Orel\n         match lab_s'' e with\n         | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n         end)) a_t) : ~\n(mode_le Oacq\n   match lab_s'' a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Orel\n   match lab_s'' a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end) ->\n~\n(mode_le Oacq\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Orel\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"rewrite <- rsr_rexi; auto."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : set_compl (Acq_s'' ∪₁ Rel_s'') a_t.","proofString":"enough (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t).\nforward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t) : set_compl (Acq_s'' ∪₁ Rel_s'') a_t.","proofString":"forward apply RLX.\nunfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t) : set_compl (Acq_t ∪₁ Rel_t) b_t -> set_compl (Acq_s'' ∪₁ Rel_s'') a_t.","proofString":"unfolder.\nsimpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t) : ~ (is_acq lab_t b_t \\/ is_rel lab_t b_t) ->\n~ (is_acq lab_s'' a_t \\/ is_rel lab_s'' a_t).","proofString":"simpl.\nunfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t) : ~ (is_acq lab_t b_t \\/ is_rel lab_t b_t) ->\n~ (is_acq (lab_t ∘ mapper) a_t \\/ is_rel (lab_t ∘ mapper) a_t).","proofString":"unfold is_acq, is_rel, mod, compose.\nnow rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RLX : set_compl (Acq_t ∪₁ Rel_t) b_t) : ~\n(mode_le Oacq\n   match lab_t b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Orel\n   match lab_t b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end) ->\n~\n(mode_le Oacq\n   match lab_t (mapper a_t) with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Orel\n   match lab_t (mapper a_t) with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"now rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : set_compl (Acq_t ∪₁ Rel_t) b_t.","proofString":"apply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : eq b_t ⊆₁ set_compl (Acq_t ∪₁ Rel_t).","proofString":"rewrite set_unionC.\nrewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : eq b_t ⊆₁ set_compl (Rel_t ∪₁ Acq_t).","proofString":"rewrite <- (rsr_bt_rlx INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : eq b_t ⊆₁ eq b_t ∩₁ E_t.","proofString":"apply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : (eq b_t ∩₁ E_t) b_t.","proofString":"split; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : E_t b_t.","proofString":"ins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : (mapper ↑₁ E_t) a_t) : E_t b_t.","proofString":"unfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : exists y : actid, E_t y /\\ mapper y = a_t) : E_t b_t.","proofString":"desf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (XIN : E_t y) (XIN0 : mapper y = a_t) : E_t b_t.","proofString":"enough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (XIN : E_t y) (XIN0 : mapper y = a_t) : y = b_t.","proofString":"now apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"E_s ∩₁ eq a_t ⊆₁ R_s ∪₁ W_s.","proofString":"assert (NEQ : a_t <> b_t) by apply INV.\nchange E_s with (E_s'' ∪₁ A_s).\nrewrite set_inter_union_l.\narewrite (A_s ∩₁ eq a_t ⊆₁ ∅).\nunfold extra_a; desf; basic_solver.\nrewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RW : (R_s'' ∪₁ W_s'') a_t).\nforward apply RW.\nunfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto.\nenough (RW : (R_t ∪₁ W_t) b_t).\nforward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : E_s ∩₁ eq a_t ⊆₁ R_s ∪₁ W_s.","proofString":"change E_s with (E_s'' ∪₁ A_s).\nrewrite set_inter_union_l.\narewrite (A_s ∩₁ eq a_t ⊆₁ ∅).\nunfold extra_a; desf; basic_solver.\nrewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RW : (R_s'' ∪₁ W_s'') a_t).\nforward apply RW.\nunfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto.\nenough (RW : (R_t ∪₁ W_t) b_t).\nforward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : (E_s'' ∪₁ A_s) ∩₁ eq a_t ⊆₁ R_s ∪₁ W_s.","proofString":"rewrite set_inter_union_l.\narewrite (A_s ∩₁ eq a_t ⊆₁ ∅).\nunfold extra_a; desf; basic_solver.\nrewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RW : (R_s'' ∪₁ W_s'') a_t).\nforward apply RW.\nunfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto.\nenough (RW : (R_t ∪₁ W_t) b_t).\nforward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : E_s'' ∩₁ eq a_t ∪₁ A_s ∩₁ eq a_t ⊆₁ R_s ∪₁ W_s.","proofString":"arewrite (A_s ∩₁ eq a_t ⊆₁ ∅).\nunfold extra_a; desf; basic_solver.\nrewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RW : (R_s'' ∪₁ W_s'') a_t).\nforward apply RW.\nunfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto.\nenough (RW : (R_t ∪₁ W_t) b_t).\nforward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : A_s ∩₁ eq a_t ⊆₁ ∅.","proofString":"unfold extra_a; desf; basic_solver."},{"statement":"(NEQ : a_t <> b_t) : E_s'' ∩₁ eq a_t ∪₁ ∅ ⊆₁ R_s ∪₁ W_s.","proofString":"rewrite set_union_empty_r.\nintros x (XIN & XEQ).\nsubst x.\nenough (RW : (R_s'' ∪₁ W_s'') a_t).\nforward apply RW.\nunfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto.\nenough (RW : (R_t ∪₁ W_t) b_t).\nforward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) : E_s'' ∩₁ eq a_t ⊆₁ R_s ∪₁ W_s.","proofString":"intros x (XIN & XEQ).\nsubst x.\nenough (RW : (R_s'' ∪₁ W_s'') a_t).\nforward apply RW.\nunfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto.\nenough (RW : (R_t ∪₁ W_t) b_t).\nforward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (x : actid) (XIN : E_s'' x) (XEQ : a_t = x) : (R_s ∪₁ W_s) x.","proofString":"subst x.\nenough (RW : (R_s'' ∪₁ W_s'') a_t).\nforward apply RW.\nunfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto.\nenough (RW : (R_t ∪₁ W_t) b_t).\nforward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : (R_s ∪₁ W_s) a_t.","proofString":"enough (RW : (R_s'' ∪₁ W_s'') a_t).\nforward apply RW.\nunfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto.\nenough (RW : (R_t ∪₁ W_t) b_t).\nforward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RW : (R_s'' ∪₁ W_s'') a_t) : (R_s ∪₁ W_s) a_t.","proofString":"forward apply RW.\nunfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RW : (R_s'' ∪₁ W_s'') a_t) : (R_s'' ∪₁ W_s'') a_t -> (R_s ∪₁ W_s) a_t.","proofString":"unfolder.\nunfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RW : (R_s'' ∪₁ W_s'') a_t) : is_r lab_s'' a_t \\/ is_w lab_s'' a_t -> is_r lab_s a_t \\/ is_w lab_s a_t.","proofString":"unfold is_w, is_r in *.\nrewrite <- rsr_rexi; auto."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RW : ((fun x : actid =>\n  match lab_s'' x with\n  | Aload _ _ _ _ => true\n  | _ => false\n  end)\n ∪₁ (fun x : actid =>\n     match lab_s'' x with\n     | Astore _ _ _ _ => true\n     | _ => false\n     end)) a_t) : match lab_s'' a_t with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/ match lab_s'' a_t with\n       | Astore _ _ _ _ => true\n       | _ => false\n       end ->\nmatch lab_s a_t with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/ match lab_s a_t with\n       | Astore _ _ _ _ => true\n       | _ => false\n       end.","proofString":"rewrite <- rsr_rexi; auto."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : (R_s'' ∪₁ W_s'') a_t.","proofString":"enough (RW : (R_t ∪₁ W_t) b_t).\nforward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ).\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RW : (R_t ∪₁ W_t) b_t) : (R_s'' ∪₁ W_s'') a_t.","proofString":"forward apply RW.\nunfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RW : (R_t ∪₁ W_t) b_t) : (R_t ∪₁ W_t) b_t -> (R_s'' ∪₁ W_s'') a_t.","proofString":"unfolder.\nsimpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RW : (R_t ∪₁ W_t) b_t) : is_r lab_t b_t \\/ is_w lab_t b_t -> is_r lab_s'' a_t \\/ is_w lab_s'' a_t.","proofString":"simpl.\nunfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RW : (R_t ∪₁ W_t) b_t) : is_r lab_t b_t \\/ is_w lab_t b_t ->\nis_r (lab_t ∘ mapper) a_t \\/ is_w (lab_t ∘ mapper) a_t.","proofString":"unfold is_r, is_w, compose.\nnow rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) (RW : (R_t ∪₁ W_t) b_t) : match lab_t b_t with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/ match lab_t b_t with\n       | Astore _ _ _ _ => true\n       | _ => false\n       end ->\nmatch lab_t (mapper a_t) with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/\nmatch lab_t (mapper a_t) with\n| Astore _ _ _ _ => true\n| _ => false\nend.","proofString":"now rewrite (rsr_mapper_at NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : (R_t ∪₁ W_t) b_t.","proofString":"apply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : eq b_t ⊆₁ R_t ∪₁ W_t.","proofString":"rewrite set_unionC.\nrewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : eq b_t ⊆₁ W_t ∪₁ R_t.","proofString":"rewrite <- (rsr_b_t_is_r_or_w INV).\napply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : eq b_t ⊆₁ eq b_t ∩₁ E_t.","proofString":"apply set_subset_single_l.\nsplit; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : (eq b_t ∩₁ E_t) b_t.","proofString":"split; auto.\nins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : E_s'' a_t) : E_t b_t.","proofString":"ins.\nunfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : (mapper ↑₁ E_t) a_t) : E_t b_t.","proofString":"unfolder in XIN.\ndesf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (XIN : exists y : actid, E_t y /\\ mapper y = a_t) : E_t b_t.","proofString":"desf.\nenough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (XIN : E_t y) (XIN0 : mapper y = a_t) : E_t b_t.","proofString":"enough (y = b_t) by congruence.\nnow apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (XIN : E_t y) (XIN0 : mapper y = a_t) : y = b_t.","proofString":"now apply (rsr_mapper_inv_at _ NEQ)."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : forall x y : actid,\n(exists z : actid, sb_s'' x z /\\ a_t = z /\\ sb_s y z /\\ b_t = y) ->\nsb_s x y /\\ b_t = y.","proofString":"intros x y (z & XZ & ZEQ & YZ & YEQ).\nsubst z y.\nsplit; auto.\nunfold sb.\nunfolder.\nenough (SB : ext_sb x b_t).\nsplits; auto.\nleft.\napply wf_sbE in XZ.\nunfolder in XZ.\ndesf.\nright.\nnow apply extra_a_some.\nassert (XZ' : ext_sb x a_t).\nforward apply XZ.\nunfold sb.\nclear.\nbasic_solver.\nassert (XNA : x <> a_t).\nintro FALSO.\nsubst x.\neapply sb_irr; eauto.\nassert (XIN : E_s'' x).\nforward apply XZ.\nclear.\nunfold sb.\nbasic_solver.\nassert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x y z : actid) (XZ : sb_s'' x z) (ZEQ : a_t = z) (YZ : sb_s y z) (YEQ : b_t = y) : sb_s x y /\\ b_t = y.","proofString":"subst z y.\nsplit; auto.\nunfold sb.\nunfolder.\nenough (SB : ext_sb x b_t).\nsplits; auto.\nleft.\napply wf_sbE in XZ.\nunfolder in XZ.\ndesf.\nright.\nnow apply extra_a_some.\nassert (XZ' : ext_sb x a_t).\nforward apply XZ.\nunfold sb.\nclear.\nbasic_solver.\nassert (XNA : x <> a_t).\nintro FALSO.\nsubst x.\neapply sb_irr; eauto.\nassert (XIN : E_s'' x).\nforward apply XZ.\nclear.\nunfold sb.\nbasic_solver.\nassert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) : sb_s x b_t /\\ b_t = b_t.","proofString":"split; auto.\nunfold sb.\nunfolder.\nenough (SB : ext_sb x b_t).\nsplits; auto.\nleft.\napply wf_sbE in XZ.\nunfolder in XZ.\ndesf.\nright.\nnow apply extra_a_some.\nassert (XZ' : ext_sb x a_t).\nforward apply XZ.\nunfold sb.\nclear.\nbasic_solver.\nassert (XNA : x <> a_t).\nintro FALSO.\nsubst x.\neapply sb_irr; eauto.\nassert (XIN : E_s'' x).\nforward apply XZ.\nclear.\nunfold sb.\nbasic_solver.\nassert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) : sb_s x b_t.","proofString":"unfold sb.\nunfolder.\nenough (SB : ext_sb x b_t).\nsplits; auto.\nleft.\napply wf_sbE in XZ.\nunfolder in XZ.\ndesf.\nright.\nnow apply extra_a_some.\nassert (XZ' : ext_sb x a_t).\nforward apply XZ.\nunfold sb.\nclear.\nbasic_solver.\nassert (XNA : x <> a_t).\nintro FALSO.\nsubst x.\neapply sb_irr; eauto.\nassert (XIN : E_s'' x).\nforward apply XZ.\nclear.\nunfold sb.\nbasic_solver.\nassert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) : (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) x b_t.","proofString":"unfolder.\nenough (SB : ext_sb x b_t).\nsplits; auto.\nleft.\napply wf_sbE in XZ.\nunfolder in XZ.\ndesf.\nright.\nnow apply extra_a_some.\nassert (XZ' : ext_sb x a_t).\nforward apply XZ.\nunfold sb.\nclear.\nbasic_solver.\nassert (XNA : x <> a_t).\nintro FALSO.\nsubst x.\neapply sb_irr; eauto.\nassert (XIN : E_s'' x).\nforward apply XZ.\nclear.\nunfold sb.\nbasic_solver.\nassert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) : E_s x /\\ ext_sb x b_t /\\ E_s b_t.","proofString":"enough (SB : ext_sb x b_t).\nsplits; auto.\nleft.\napply wf_sbE in XZ.\nunfolder in XZ.\ndesf.\nright.\nnow apply extra_a_some.\nassert (XZ' : ext_sb x a_t).\nforward apply XZ.\nunfold sb.\nclear.\nbasic_solver.\nassert (XNA : x <> a_t).\nintro FALSO.\nsubst x.\neapply sb_irr; eauto.\nassert (XIN : E_s'' x).\nforward apply XZ.\nclear.\nunfold sb.\nbasic_solver.\nassert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (SB : ext_sb x b_t) : E_s x /\\ ext_sb x b_t /\\ E_s b_t.","proofString":"splits; auto.\nleft.\napply wf_sbE in XZ.\nunfolder in XZ.\ndesf.\nright.\nnow apply extra_a_some."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (SB : ext_sb x b_t) : E_s x.","proofString":"left.\napply wf_sbE in XZ.\nunfolder in XZ.\ndesf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (SB : ext_sb x b_t) : (mapper ↑₁ E_t) x.","proofString":"apply wf_sbE in XZ.\nunfolder in XZ.\ndesf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : (⦗E_s''⦘ ⨾ sb_s'' ⨾ ⦗E_s''⦘) x a_t) (YZ : sb_s b_t a_t) (SB : ext_sb x b_t) : (mapper ↑₁ E_t) x.","proofString":"unfolder in XZ.\ndesf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (YZ : sb_s b_t a_t) (SB : ext_sb x b_t) (XZ : E_s'' x /\\ sb_s'' x a_t /\\ E_s'' a_t) : (mapper ↑₁ E_t) x.","proofString":"desf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (SB : ext_sb x b_t) : E_s b_t.","proofString":"right.\nnow apply extra_a_some."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (SB : ext_sb x b_t) : A_s b_t.","proofString":"now apply extra_a_some."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) : ext_sb x b_t.","proofString":"assert (XZ' : ext_sb x a_t).\nforward apply XZ.\nunfold sb.\nclear.\nbasic_solver.\nassert (XNA : x <> a_t).\nintro FALSO.\nsubst x.\neapply sb_irr; eauto.\nassert (XIN : E_s'' x).\nforward apply XZ.\nclear.\nunfold sb.\nbasic_solver.\nassert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) : ext_sb x a_t.","proofString":"forward apply XZ.\nunfold sb.\nclear.\nbasic_solver."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) : sb_s'' x a_t -> ext_sb x a_t.","proofString":"unfold sb.\nclear.\nbasic_solver."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) : (⦗E_s''⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘) x a_t -> ext_sb x a_t.","proofString":"clear.\nbasic_solver."},{"statement":"(x : actid) : (⦗E_s''⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘) x a_t -> ext_sb x a_t.","proofString":"basic_solver."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) : ext_sb x b_t.","proofString":"assert (XNA : x <> a_t).\nintro FALSO.\nsubst x.\neapply sb_irr; eauto.\nassert (XIN : E_s'' x).\nforward apply XZ.\nclear.\nunfold sb.\nbasic_solver.\nassert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) : x <> a_t.","proofString":"intro FALSO.\nsubst x.\neapply sb_irr; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (FALSO : x = a_t) : False.","proofString":"subst x.\neapply sb_irr; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (XZ : sb_s'' a_t a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb a_t a_t) : False.","proofString":"eapply sb_irr; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) : ext_sb x b_t.","proofString":"assert (XIN : E_s'' x).\nforward apply XZ.\nclear.\nunfold sb.\nbasic_solver.\nassert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) : E_s'' x.","proofString":"forward apply XZ.\nclear.\nunfold sb.\nbasic_solver."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) : sb_s'' x a_t -> E_s'' x.","proofString":"clear.\nunfold sb.\nbasic_solver."},{"statement":"(x : actid) : sb_s'' x a_t -> E_s'' x.","proofString":"unfold sb.\nbasic_solver."},{"statement":"(x : actid) : (⦗E_s''⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘) x a_t -> E_s'' x.","proofString":"basic_solver."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) (XIN : E_s'' x) : ext_sb x b_t.","proofString":"assert (XNB : x <> b_t).\nintro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto.\napply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) (XIN : E_s'' x) : x <> b_t.","proofString":"intro FALSO.\nsubst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) (XIN : E_s'' x) (FALSO : x = b_t) : False.","proofString":"subst x.\napply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (XZ : sb_s'' b_t a_t) (YZ : sb_s b_t a_t) (XIN : E_s'' b_t) (XNA : b_t <> a_t) (XZ' : ext_sb b_t a_t) : False.","proofString":"apply NINA.\nsimpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (XZ : sb_s'' b_t a_t) (YZ : sb_s b_t a_t) (XIN : E_s'' b_t) (XNA : b_t <> a_t) (XZ' : ext_sb b_t a_t) : E_t a_t.","proofString":"simpl in XIN.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (XZ : sb_s'' b_t a_t) (YZ : sb_s b_t a_t) (XIN : (mapper ↑₁ E_t) b_t) (XNA : b_t <> a_t) (XZ' : ext_sb b_t a_t) : E_t a_t.","proofString":"unfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (XZ : sb_s'' b_t a_t) (YZ : sb_s b_t a_t) (XIN : exists y : actid, E_t y /\\ mapper y = b_t) (XNA : b_t <> a_t) (XZ' : ext_sb b_t a_t) : E_t a_t.","proofString":"destruct XIN as (y & YIN & YEQ).\nenough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (XZ : sb_s'' b_t a_t) (YZ : sb_s b_t a_t) (y : actid) (YIN : E_t y) (YEQ : mapper y = b_t) (XNA : b_t <> a_t) (XZ' : ext_sb b_t a_t) : E_t a_t.","proofString":"enough (y = a_t) by congruence.\neapply rsr_mapper_inv_bt; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (XZ : sb_s'' b_t a_t) (YZ : sb_s b_t a_t) (y : actid) (YIN : E_t y) (YEQ : mapper y = b_t) (XNA : b_t <> a_t) (XZ' : ext_sb b_t a_t) : y = a_t.","proofString":"eapply rsr_mapper_inv_bt; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) (XIN : E_s'' x) (XNB : x <> b_t) : ext_sb x b_t.","proofString":"apply (rsr_rex_extsb_inv_l INV); auto.\nunfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) (XIN : E_s'' x) (XNB : x <> b_t) : E_t x.","proofString":"unfolder in XIN.\ndestruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) (XIN : E_s'' x) (XNB : x <> b_t) : E_t x.","proofString":"destruct XIN as (y & YIN & YEQ).\nsubst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XZ : sb_s'' x a_t) (YZ : sb_s b_t a_t) (XZ' : ext_sb x a_t) (XNA : x <> a_t) (y : actid) (YIN : E_t y) (YEQ : mapper y = x) (XNB : x <> b_t) : E_t x.","proofString":"subst x.\nrewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (y : actid) (XZ : sb_s'' (mapper y) a_t) (YZ : sb_s b_t a_t) (XNA : mapper y <> a_t) (XZ' : ext_sb (mapper y) a_t) (YIN : E_t y) (XNB : mapper y <> b_t) : E_t (mapper y).","proofString":"rewrite rsr_mappero; auto.\nintro YEQ.\nsubst y.\neauto.\nintro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (y : actid) (XZ : sb_s'' (mapper y) a_t) (YZ : sb_s b_t a_t) (XNA : mapper y <> a_t) (XZ' : ext_sb (mapper y) a_t) (YIN : E_t y) (XNB : mapper y <> b_t) : y <> a_t.","proofString":"intro YEQ.\nsubst y.\neauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (y : actid) (XZ : sb_s'' (mapper y) a_t) (YZ : sb_s b_t a_t) (XNA : mapper y <> a_t) (XZ' : ext_sb (mapper y) a_t) (YIN : E_t y) (XNB : mapper y <> b_t) (YEQ : y = a_t) : False.","proofString":"subst y.\neauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (XZ : sb_s'' (mapper a_t) a_t) (YZ : sb_s b_t a_t) (XNB : mapper a_t <> b_t) (YIN : E_t a_t) (XZ' : ext_sb (mapper a_t) a_t) (XNA : mapper a_t <> a_t) : False.","proofString":"eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (y : actid) (XZ : sb_s'' (mapper y) a_t) (YZ : sb_s b_t a_t) (XNA : mapper y <> a_t) (XZ' : ext_sb (mapper y) a_t) (YIN : E_t y) (XNB : mapper y <> b_t) : y <> b_t.","proofString":"intro YEQ.\nsubst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (y : actid) (XZ : sb_s'' (mapper y) a_t) (YZ : sb_s b_t a_t) (XNA : mapper y <> a_t) (XZ' : ext_sb (mapper y) a_t) (YIN : E_t y) (XNB : mapper y <> b_t) (YEQ : y = b_t) : False.","proofString":"subst y.\nrewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (XZ : sb_s'' (mapper b_t) a_t) (YZ : sb_s b_t a_t) (XNB : mapper b_t <> b_t) (YIN : E_t b_t) (XZ' : ext_sb (mapper b_t) a_t) (XNA : mapper b_t <> a_t) : False.","proofString":"rewrite rsr_mapper_bt in XNA; congruence."},{"statement":"(NEQ : a_t <> b_t) : drf_s'' ≡ srf_s ⨾ ⦗A_s ∩₁ R_s⦘.","proofString":"unfold extra_a; desf; [| basic_solver].\ndestruct classic with (~R_s b_t) as [NINR|ISR'].\nrewrite <- (rsr_rex_isr_helper l_a INV); desf.\narewrite (eq b_t ∩₁ R_s ≡₁ ∅) by basic_solver.\nnow rewrite eqv_empty, !seq_false_r.\nassert (ISR : R_s b_t) by tauto.\narewrite (    eq b_t ∩₁ R_s ≡₁ eq b_t ∩₁ WCore.lab_is_r l_a  ).\napply (rsr_rex_isr_helper l_a INV); desf.\napply fake_srf_is_srf.\napply (rsr_imm_Gs_wf INV).\nunfold sb, fake_sb.\nchange (E_s) with (E_s'' ∪₁ A_s).\nrewrite extra_a_some by desf.\nreflexivity.\nintros (x & XIN & XEQ).\nenough (x = a_t) by (desf; congruence).\neapply rsr_mapper_inv_bt; [apply INV | eauto].\nsimpl.\nunfold lab_s_; desf; [| tauto].\nrewrite upd_compose; auto with xmm.\nnow rewrite rsr_mapper_bt; auto.\napply rsr_vfsb; auto; desf.\nchange co_s with (co_s'' ∪    (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a)) ×    (A_s ∩₁ WCore.lab_is_w l_a)  ).\nrewrite seq_union_l, <- cross_inter_r.\narewrite (    A_s ∩₁ WCore.lab_is_w l_a ∩₁ E_s'' ≡₁      WCore.lab_is_w l_a ∩₁ (A_s ∩₁ E_s'')  ) by basic_solver.\narewrite (A_s ∩₁ E_s'' ≡₁ ∅).\napply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x.\nnow rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) : fake_srf G_s'' b_t l_a ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ srf_s ⨾ ⦗eq b_t ∩₁ R_s⦘.","proofString":"destruct classic with (~R_s b_t) as [NINR|ISR'].\nrewrite <- (rsr_rex_isr_helper l_a INV); desf.\narewrite (eq b_t ∩₁ R_s ≡₁ ∅) by basic_solver.\nnow rewrite eqv_empty, !seq_false_r.\nassert (ISR : R_s b_t) by tauto.\narewrite (    eq b_t ∩₁ R_s ≡₁ eq b_t ∩₁ WCore.lab_is_r l_a  ).\napply (rsr_rex_isr_helper l_a INV); desf.\napply fake_srf_is_srf.\napply (rsr_imm_Gs_wf INV).\nunfold sb, fake_sb.\nchange (E_s) with (E_s'' ∪₁ A_s).\nrewrite extra_a_some by desf.\nreflexivity.\nintros (x & XIN & XEQ).\nenough (x = a_t) by (desf; congruence).\neapply rsr_mapper_inv_bt; [apply INV | eauto].\nsimpl.\nunfold lab_s_; desf; [| tauto].\nrewrite upd_compose; auto with xmm.\nnow rewrite rsr_mapper_bt; auto.\napply rsr_vfsb; auto; desf.\nchange co_s with (co_s'' ∪    (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a)) ×    (A_s ∩₁ WCore.lab_is_w l_a)  ).\nrewrite seq_union_l, <- cross_inter_r.\narewrite (    A_s ∩₁ WCore.lab_is_w l_a ∩₁ E_s'' ≡₁      WCore.lab_is_w l_a ∩₁ (A_s ∩₁ E_s'')  ) by basic_solver.\narewrite (A_s ∩₁ E_s'' ≡₁ ∅).\napply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x.\nnow rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (NINR : ~ is_r lab_s b_t) : fake_srf G_s'' b_t l_a ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ srf_s ⨾ ⦗eq b_t ∩₁ R_s⦘.","proofString":"rewrite <- (rsr_rex_isr_helper l_a INV); desf.\narewrite (eq b_t ∩₁ R_s ≡₁ ∅) by basic_solver.\nnow rewrite eqv_empty, !seq_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (NINR : ~ is_r lab_s b_t) : fake_srf G_s'' b_t l_a ⨾ ⦗eq b_t ∩₁ R_s⦘ ≡ srf_s ⨾ ⦗eq b_t ∩₁ R_s⦘.","proofString":"arewrite (eq b_t ∩₁ R_s ≡₁ ∅) by basic_solver.\nnow rewrite eqv_empty, !seq_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (NINR : ~ is_r lab_s b_t) : fake_srf G_s'' b_t l_a ⨾ ⦗∅⦘ ≡ srf_s ⨾ ⦗∅⦘.","proofString":"now rewrite eqv_empty, !seq_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) : fake_srf G_s'' b_t l_a ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ srf_s ⨾ ⦗eq b_t ∩₁ R_s⦘.","proofString":"assert (ISR : R_s b_t) by tauto.\narewrite (    eq b_t ∩₁ R_s ≡₁ eq b_t ∩₁ WCore.lab_is_r l_a  ).\napply (rsr_rex_isr_helper l_a INV); desf.\napply fake_srf_is_srf.\napply (rsr_imm_Gs_wf INV).\nunfold sb, fake_sb.\nchange (E_s) with (E_s'' ∪₁ A_s).\nrewrite extra_a_some by desf.\nreflexivity.\nintros (x & XIN & XEQ).\nenough (x = a_t) by (desf; congruence).\neapply rsr_mapper_inv_bt; [apply INV | eauto].\nsimpl.\nunfold lab_s_; desf; [| tauto].\nrewrite upd_compose; auto with xmm.\nnow rewrite rsr_mapper_bt; auto.\napply rsr_vfsb; auto; desf.\nchange co_s with (co_s'' ∪    (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a)) ×    (A_s ∩₁ WCore.lab_is_w l_a)  ).\nrewrite seq_union_l, <- cross_inter_r.\narewrite (    A_s ∩₁ WCore.lab_is_w l_a ∩₁ E_s'' ≡₁      WCore.lab_is_w l_a ∩₁ (A_s ∩₁ E_s'')  ) by basic_solver.\narewrite (A_s ∩₁ E_s'' ≡₁ ∅).\napply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x.\nnow rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : fake_srf G_s'' b_t l_a ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ srf_s ⨾ ⦗eq b_t ∩₁ R_s⦘.","proofString":"arewrite (    eq b_t ∩₁ R_s ≡₁ eq b_t ∩₁ WCore.lab_is_r l_a  ).\napply (rsr_rex_isr_helper l_a INV); desf.\napply fake_srf_is_srf.\napply (rsr_imm_Gs_wf INV).\nunfold sb, fake_sb.\nchange (E_s) with (E_s'' ∪₁ A_s).\nrewrite extra_a_some by desf.\nreflexivity.\nintros (x & XIN & XEQ).\nenough (x = a_t) by (desf; congruence).\neapply rsr_mapper_inv_bt; [apply INV | eauto].\nsimpl.\nunfold lab_s_; desf; [| tauto].\nrewrite upd_compose; auto with xmm.\nnow rewrite rsr_mapper_bt; auto.\napply rsr_vfsb; auto; desf.\nchange co_s with (co_s'' ∪    (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a)) ×    (A_s ∩₁ WCore.lab_is_w l_a)  ).\nrewrite seq_union_l, <- cross_inter_r.\narewrite (    A_s ∩₁ WCore.lab_is_w l_a ∩₁ E_s'' ≡₁      WCore.lab_is_w l_a ∩₁ (A_s ∩₁ E_s'')  ) by basic_solver.\narewrite (A_s ∩₁ E_s'' ≡₁ ∅).\napply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x.\nnow rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : eq b_t ∩₁ R_s ≡₁ eq b_t ∩₁ WCore.lab_is_r l_a.","proofString":"apply (rsr_rex_isr_helper l_a INV); desf."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : fake_srf G_s'' b_t l_a ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ srf_s ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘.","proofString":"apply fake_srf_is_srf.\napply (rsr_imm_Gs_wf INV).\nunfold sb, fake_sb.\nchange (E_s) with (E_s'' ∪₁ A_s).\nrewrite extra_a_some by desf.\nreflexivity.\nintros (x & XIN & XEQ).\nenough (x = a_t) by (desf; congruence).\neapply rsr_mapper_inv_bt; [apply INV | eauto].\nsimpl.\nunfold lab_s_; desf; [| tauto].\nrewrite upd_compose; auto with xmm.\nnow rewrite rsr_mapper_bt; auto.\napply rsr_vfsb; auto; desf.\nchange co_s with (co_s'' ∪    (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a)) ×    (A_s ∩₁ WCore.lab_is_w l_a)  ).\nrewrite seq_union_l, <- cross_inter_r.\narewrite (    A_s ∩₁ WCore.lab_is_w l_a ∩₁ E_s'' ≡₁      WCore.lab_is_w l_a ∩₁ (A_s ∩₁ E_s'')  ) by basic_solver.\narewrite (A_s ∩₁ E_s'' ≡₁ ∅).\napply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x.\nnow rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : Wf G_s''.","proofString":"apply (rsr_imm_Gs_wf INV)."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : sb_s ≡ fake_sb G_s'' b_t.","proofString":"unfold sb, fake_sb.\nchange (E_s) with (E_s'' ∪₁ A_s).\nrewrite extra_a_some by desf.\nreflexivity."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ≡ ⦗E_s'' ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s'' ∪₁ eq b_t⦘.","proofString":"change (E_s) with (E_s'' ∪₁ A_s).\nrewrite extra_a_some by desf.\nreflexivity."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : ⦗E_s'' ∪₁ A_s⦘ ⨾ ext_sb ⨾ ⦗E_s'' ∪₁ A_s⦘\n≡ ⦗E_s'' ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s'' ∪₁ eq b_t⦘.","proofString":"rewrite extra_a_some by desf.\nreflexivity."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : ⦗E_s'' ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s'' ∪₁ eq b_t⦘\n≡ ⦗E_s'' ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s'' ∪₁ eq b_t⦘.","proofString":"reflexivity."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : ~ E_s'' b_t.","proofString":"intros (x & XIN & XEQ).\nenough (x = a_t) by (desf; congruence).\neapply rsr_mapper_inv_bt; [apply INV | eauto]."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) (x : actid) (XIN : E_t x) (XEQ : mapper x = b_t) : False.","proofString":"enough (x = a_t) by (desf; congruence).\neapply rsr_mapper_inv_bt; [apply INV | eauto]."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) (x : actid) (XIN : E_t x) (XEQ : mapper x = b_t) : x = a_t.","proofString":"eapply rsr_mapper_inv_bt; [apply INV | eauto]."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : lab_s = upd lab_s'' b_t l_a.","proofString":"simpl.\nunfold lab_s_; desf; [| tauto].\nrewrite upd_compose; auto with xmm.\nnow rewrite rsr_mapper_bt; auto."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : lab_s_ X_t a_t b_t l_a = upd (lab_t ∘ mapper) b_t l_a.","proofString":"unfold lab_s_; desf; [| tauto].\nrewrite upd_compose; auto with xmm.\nnow rewrite rsr_mapper_bt; auto."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) (a1 : ~ E_t a_t /\\ E_t b_t) : upd lab_t a_t l_a ∘ mapper = upd (lab_t ∘ mapper) b_t l_a.","proofString":"rewrite upd_compose; auto with xmm.\nnow rewrite rsr_mapper_bt; auto."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) (a1 : ~ E_t a_t /\\ E_t b_t) : upd lab_t a_t l_a ∘ mapper = upd lab_t (mapper b_t) l_a ∘ mapper.","proofString":"now rewrite rsr_mapper_bt; auto."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : vf_s ⨾ sb_s ⨾ ⦗eq b_t⦘ ≡ vf_s'' ⨾ sb_s ⨾ ⦗eq b_t⦘.","proofString":"apply rsr_vfsb; auto; desf."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : co_s ⨾ ⦗E_s''⦘ ≡ co_s'' ⨾ ⦗E_s''⦘.","proofString":"change co_s with (co_s'' ∪    (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a)) ×    (A_s ∩₁ WCore.lab_is_w l_a)  ).\nrewrite seq_union_l, <- cross_inter_r.\narewrite (    A_s ∩₁ WCore.lab_is_w l_a ∩₁ E_s'' ≡₁      WCore.lab_is_w l_a ∩₁ (A_s ∩₁ E_s'')  ) by basic_solver.\narewrite (A_s ∩₁ E_s'' ≡₁ ∅).\napply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x.\nnow rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : (co_s''\n ∪ (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a))\n   × (A_s ∩₁ WCore.lab_is_w l_a)) ⨾ ⦗E_s''⦘ ≡ co_s'' ⨾ ⦗E_s''⦘.","proofString":"rewrite seq_union_l, <- cross_inter_r.\narewrite (    A_s ∩₁ WCore.lab_is_w l_a ∩₁ E_s'' ≡₁      WCore.lab_is_w l_a ∩₁ (A_s ∩₁ E_s'')  ) by basic_solver.\narewrite (A_s ∩₁ E_s'' ≡₁ ∅).\napply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x.\nnow rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : co_s'' ⨾ ⦗E_s''⦘\n∪ (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a))\n  × (A_s ∩₁ WCore.lab_is_w l_a ∩₁ E_s'') ≡ co_s'' ⨾ ⦗E_s''⦘.","proofString":"arewrite (    A_s ∩₁ WCore.lab_is_w l_a ∩₁ E_s'' ≡₁      WCore.lab_is_w l_a ∩₁ (A_s ∩₁ E_s'')  ) by basic_solver.\narewrite (A_s ∩₁ E_s'' ≡₁ ∅).\napply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x.\nnow rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : co_s'' ⨾ ⦗E_s''⦘\n∪ (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a))\n  × (WCore.lab_is_w l_a ∩₁ (A_s ∩₁ E_s'')) ≡ co_s'' ⨾ ⦗E_s''⦘.","proofString":"arewrite (A_s ∩₁ E_s'' ≡₁ ∅).\napply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x.\nnow rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : A_s ∩₁ E_s'' ≡₁ ∅.","proofString":"apply set_disjointE.\nunfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : set_disjoint A_s E_s''.","proofString":"unfolder.\nintros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : forall x : actid, A_s x -> E_s'' x -> False.","proofString":"intros x XIN XIN'.\nnow apply (rsr_exa_notin_imm INV) with x."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) (x : actid) (XIN : A_s x) (XIN' : E_s'' x) : False.","proofString":"now apply (rsr_exa_notin_imm INV) with x."},{"statement":"(NEQ : a_t <> b_t) (a : ~ E_t a_t /\\ E_t b_t) (ISR' : ~ ~ is_r lab_s b_t) (ISR : R_s b_t) : co_s'' ⨾ ⦗E_s''⦘\n∪ (E_s'' ∩₁ W_s'' ∩₁ Loc_s_'' (WCore.lab_loc l_a))\n  × (WCore.lab_is_w l_a ∩₁ ∅) ≡ co_s'' ⨾ ⦗E_s''⦘.","proofString":"now rewrite set_inter_empty_r, cross_false_r,          union_false_r."},{"statement":"(x : actid) (XIN : A_s x) : extra_a_pred X_s a_t b_t x.","proofString":"constructor.\nunfold extra_a in XIN.\ndesf.\ntransitivity rf_s; [| apply (new_G_s_wf INV LVAL)].\narewrite (eq x ≡₁ A_s).\nsplit; [basic_solver |].\nunfold extra_a in *.\ndesf.\nrewrite <- rsr_srf_eq.\nsimpl.\nbasic_solver.\nnow apply rsr_rex_nsloc.\napply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- rsr_rex_a_rlx.\nbasic_solver.\nnow apply rsr_rex_a_rw."},{"statement":"(x : actid) (XIN : A_s x) : same_tid b_t x.","proofString":"unfold extra_a in XIN.\ndesf."},{"statement":"(x : actid) (XIN : (ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅) x) : same_tid b_t x.","proofString":"desf."},{"statement":"(x : actid) (XIN : A_s x) : srf_s ⨾ ⦗eq x ∩₁ R_s⦘ ⊆ same_val_s.","proofString":"transitivity rf_s; [| apply (new_G_s_wf INV LVAL)].\narewrite (eq x ≡₁ A_s).\nsplit; [basic_solver |].\nunfold extra_a in *.\ndesf.\nrewrite <- rsr_srf_eq.\nsimpl.\nbasic_solver."},{"statement":"(x : actid) (XIN : A_s x) : srf_s ⨾ ⦗eq x ∩₁ R_s⦘ ⊆ rf_s.","proofString":"arewrite (eq x ≡₁ A_s).\nsplit; [basic_solver |].\nunfold extra_a in *.\ndesf.\nrewrite <- rsr_srf_eq.\nsimpl.\nbasic_solver."},{"statement":"(x : actid) (XIN : A_s x) : eq x ≡₁ A_s.","proofString":"split; [basic_solver |].\nunfold extra_a in *.\ndesf."},{"statement":"(x : actid) (XIN : A_s x) : A_s ⊆₁ eq x.","proofString":"unfold extra_a in *.\ndesf."},{"statement":"(x : actid) (XIN : (ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅) x) : (ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅) ⊆₁ eq x.","proofString":"desf."},{"statement":"(x : actid) (XIN : A_s x) : srf_s ⨾ ⦗A_s ∩₁ R_s⦘ ⊆ rf_s.","proofString":"rewrite <- rsr_srf_eq.\nsimpl.\nbasic_solver."},{"statement":"(x : actid) (XIN : A_s x) : drf_s'' ⊆ rf_s.","proofString":"simpl.\nbasic_solver."},{"statement":"(x : actid) (XIN : A_s x) : fake_srf (rsr_imm_g X_t a_t b_t) b_t l_a ⨾ ⦗A_s ∩₁ WCore.lab_is_r l_a⦘\n⊆ mapper ↑ rf_t\n  ∪ fake_srf (rsr_imm_g X_t a_t b_t) b_t l_a ⨾ ⦗A_s ∩₁ WCore.lab_is_r l_a⦘.","proofString":"basic_solver."},{"statement":"(x : actid) (XIN : A_s x) : ~ same_loc_s a_t x.","proofString":"now apply rsr_rex_nsloc."},{"statement":"(x : actid) (XIN : A_s x) : set_compl (Rel_s ∪₁ Acq_s) x.","proofString":"apply set_subset_single_l.\nrewrite set_unionC.\nrewrite <- rsr_rex_a_rlx.\nbasic_solver."},{"statement":"(x : actid) (XIN : A_s x) : eq x ⊆₁ set_compl (Rel_s ∪₁ Acq_s).","proofString":"rewrite set_unionC.\nrewrite <- rsr_rex_a_rlx.\nbasic_solver."},{"statement":"(x : actid) (XIN : A_s x) : eq x ⊆₁ set_compl (Acq_s ∪₁ Rel_s).","proofString":"rewrite <- rsr_rex_a_rlx.\nbasic_solver."},{"statement":"(x : actid) (XIN : A_s x) : eq x ⊆₁ A_s.","proofString":"basic_solver."},{"statement":"(x : actid) (XIN : A_s x) : (R_s ∪₁ W_s) x.","proofString":"now apply rsr_rex_a_rw."}]}