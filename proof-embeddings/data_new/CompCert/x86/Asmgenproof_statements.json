{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/x86/Asmgenproof.v","fileSamples":[{"statement":"(p : Mach.program) (tp : program) (H : transf_program p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Mach.program) (tp : program) (H : transf_program p = OK tp)","proofString":"eapply match_transform_partial_program; eauto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) : Genv.find_funct_ptr tge fb = Some (Internal tf).","conclusion":"Genv.find_funct_ptr tge fb = Some (Internal tf)","hypotheses":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf)","proofString":"exploit functions_translated; eauto.\nintros [tf' [A B]].\nmonadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) : (exists tf0 : fundef,\n   Genv.find_funct_ptr tge fb = Some tf0 /\\\n   transf_fundef (Internal f) = OK tf0) ->\nGenv.find_funct_ptr tge fb = Some (Internal tf).","conclusion":"(exists tf0 : fundef,\n   Genv.find_funct_ptr tge fb = Some tf0 /\\\n   transf_fundef (Internal f) = OK tf0) ->\nGenv.find_funct_ptr tge fb = Some (Internal tf)","hypotheses":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf)","proofString":"intros [tf' [A B]].\nmonadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (tf' : fundef) (A : Genv.find_funct_ptr tge fb = Some tf') (B : transf_fundef (Internal f) = OK tf') : Genv.find_funct_ptr tge fb = Some (Internal tf).","conclusion":"Genv.find_funct_ptr tge fb = Some (Internal tf)","hypotheses":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (tf' : fundef) (A : Genv.find_funct_ptr tge fb = Some tf') (B : transf_fundef (Internal f) = OK tf')","proofString":"monadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (x : function) (A : Genv.find_funct_ptr tge fb = Some (Internal x)) (EQ : transf_function f = OK x) : Genv.find_funct_ptr tge fb = Some (Internal tf).","conclusion":"Genv.find_funct_ptr tge fb = Some (Internal tf)","hypotheses":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (x : function) (A : Genv.find_funct_ptr tge fb = Some (Internal x)) (EQ : transf_function f = OK x)","proofString":"rewrite H0 in EQ; inv EQ; auto."},{"statement":"(f : Mach.function) (tf : function) (H : transf_function f = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","conclusion":"list_length_z (fn_code tf) <= Ptrofs.max_unsigned","hypotheses":"(f : Mach.function) (tf : function) (H : transf_function f = OK tf)","proofString":"monadInv H.\ndestruct (zlt Ptrofs.max_unsigned (list_length_z (fn_code x))); monadInv EQ0.\nlia."},{"statement":"(f : Mach.function) (tf x : function) (EQ : transl_function f = OK x) (EQ0 : (if zlt Ptrofs.max_unsigned (list_length_z (fn_code x))\n then Error (msg \"code size exceeded\")\n else OK x) = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","conclusion":"list_length_z (fn_code tf) <= Ptrofs.max_unsigned","hypotheses":"(f : Mach.function) (tf x : function) (EQ : transl_function f = OK x) (EQ0 : (if zlt Ptrofs.max_unsigned (list_length_z (fn_code x))\n then Error (msg \"code size exceeded\")\n else OK x) = OK tf)","proofString":"destruct (zlt Ptrofs.max_unsigned (list_length_z (fn_code x))); monadInv EQ0.\nlia."},{"statement":"(f : Mach.function) (tf : function) (g : Ptrofs.max_unsigned >= list_length_z (fn_code tf)) (EQ : transl_function f = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","conclusion":"list_length_z (fn_code tf) <= Ptrofs.max_unsigned","hypotheses":"(f : Mach.function) (tf : function) (g : Ptrofs.max_unsigned >= list_length_z (fn_code tf)) (EQ : transl_function f = OK tf)","proofString":"lia."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : exec_straight tge tf tc rs m c' rs' m') : plus step tge (State rs m) E0 (State rs' m').","conclusion":"plus step tge (State rs m) E0 (State rs' m')","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : exec_straight tge tf tc rs m c' rs' m')","proofString":"inv H.\neapply exec_straight_steps_1; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : plus step tge (State rs m) E0 (State rs' m').","conclusion":"plus step tge (State rs m) E0 (State rs' m')","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC)","proofString":"eapply exec_straight_steps_1; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","conclusion":"list_length_z (fn_code tf) <= Ptrofs.max_unsigned","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC)","proofString":"eapply transf_function_no_overflow; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : Genv.find_funct_ptr tge fb = Some (Internal tf).","conclusion":"Genv.find_funct_ptr tge fb = Some (Internal tf)","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC)","proofString":"eapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","conclusion":"transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m')","proofString":"inv H.\nexploit exec_straight_steps_2; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto.\nintros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","conclusion":"transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC)","proofString":"exploit exec_straight_steps_2; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto.\nintros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","conclusion":"list_length_z (fn_code tf) <= Ptrofs.max_unsigned","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC)","proofString":"eapply transf_function_no_overflow; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : Genv.find_funct_ptr tge fb = Some (Internal tf).","conclusion":"Genv.find_funct_ptr tge fb = Some (Internal tf)","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC)","proofString":"eapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : (exists ofs' : ptrofs,\n   rs' PC = Vptr fb ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') ->\ntransl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","conclusion":"(exists ofs' : ptrofs,\n   rs' PC = Vptr fb ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') ->\ntransl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC)","proofString":"intros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","conclusion":"transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc')","proofString":"rewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') : transl_code_at_pc ge (Vptr fb ofs') fb f c' ep' tf tc'.","conclusion":"transl_code_at_pc ge (Vptr fb ofs') fb f c' ep' tf tc'","hypotheses":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc')","proofString":"constructor; auto."},{"statement":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c) : find_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k).","conclusion":"find_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k)","hypotheses":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c)","proofString":"exploit transl_instr_label; eauto.\ndestruct i; try (intros [A B]; apply B).\nintros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c) : match i with\n| Mlabel lbl0 => c = Plabel lbl0 :: k\n| _ => tail_nolabel k c\nend ->\nfind_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k).","conclusion":"match i with\n| Mlabel lbl0 => c = Plabel lbl0 :: k\n| _ => tail_nolabel k c\nend ->\nfind_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k)","hypotheses":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c)","proofString":"destruct i; try (intros [A B]; apply B).\nintros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c) : c = Plabel l :: k ->\nfind_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","conclusion":"c = Plabel l :: k ->\nfind_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k)","hypotheses":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c)","proofString":"intros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c) (H0 : c = Plabel l :: k) : find_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","conclusion":"find_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k)","hypotheses":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c) (H0 : c = Plabel l :: k)","proofString":"subst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k)) : find_label lbl (Plabel l :: k) =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","conclusion":"find_label lbl (Plabel l :: k) =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k)","hypotheses":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k))","proofString":"simpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k)) : (if if peq lbl l then true else false then Some k else find_label lbl k) =\n(if if peq lbl l then true else false then Some k else find_label lbl k).","conclusion":"(if if peq lbl l then true else false then Some k else find_label lbl k) =\n(if if peq lbl l then true else false then Some k else find_label lbl k)","hypotheses":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k))","proofString":"auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (ep : bool) (tc : list instruction) (H : OK nil = OK tc) : find_label lbl tc = None.","conclusion":"find_label lbl tc = None","hypotheses":"(lbl : Mach.label) (f : Mach.function) (ep : bool) (tc : list instruction) (H : OK nil = OK tc)","proofString":"inv H.\nauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (ep : bool) : find_label lbl nil = None.","conclusion":"find_label lbl nil = None","hypotheses":"(lbl : Mach.label) (f : Mach.function) (ep : bool)","proofString":"auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc : list instruction) (H : bind (transl_code f c (it1_is_parent ep a))\n  (fun k : list instruction => transl_instr f a ep k) = \nOK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend.","conclusion":"match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend","hypotheses":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc : list instruction) (H : bind (transl_code f c (it1_is_parent ep a))\n  (fun k : list instruction => transl_instr f a ep k) = \nOK tc)","proofString":"monadInv H.\nrewrite (transl_instr_label' lbl _ _ _ _ _ EQ0).\ngeneralize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend.","conclusion":"match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend","hypotheses":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc)","proofString":"rewrite (transl_instr_label' lbl _ _ _ _ _ EQ0).\ngeneralize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend.","conclusion":"match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend","hypotheses":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc)","proofString":"generalize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : (if Mach.is_label lbl a then a = Mlabel lbl else a <> Mlabel lbl) ->\nmatch (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend.","conclusion":"(if Mach.is_label lbl a then a = Mlabel lbl else a <> Mlabel lbl) ->\nmatch (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend","hypotheses":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc)","proofString":"destruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a = Mlabel lbl) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","conclusion":"exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'","hypotheses":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a = Mlabel lbl)","proofString":"subst a.\nsimpl in EQ.\nexists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c (it1_is_parent ep (Mlabel lbl)) = OK x) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","conclusion":"exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'","hypotheses":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c (it1_is_parent ep (Mlabel lbl)) = OK x)","proofString":"simpl in EQ.\nexists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c false = OK x) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","conclusion":"exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'","hypotheses":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c false = OK x)","proofString":"exists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a <> Mlabel lbl) : match Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl x = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl x = None\nend.","conclusion":"match Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl x = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl x = None\nend","hypotheses":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a <> Mlabel lbl)","proofString":"eapply IHc; eauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","conclusion":"exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r)","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c')","proofString":"exploit (transl_find_label lbl f tf); eauto.\nrewrite H2.\nintros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl (fn_code tf) = Some tc /\\ transl_code f c false = OK tc\n| None => find_label lbl (fn_code tf) = None\nend ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","conclusion":"match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl (fn_code tf) = Some tc /\\ transl_code f c false = OK tc\n| None => find_label lbl (fn_code tf) = None\nend ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r)","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c')","proofString":"rewrite H2.\nintros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : (exists tc : code,\n   find_label lbl (fn_code tf) = Some tc /\\ transl_code f c' false = OK tc) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","conclusion":"(exists tc : code,\n   find_label lbl (fn_code tf) = Some tc /\\ transl_code f c' false = OK tc) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r)","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c')","proofString":"intros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","conclusion":"exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r)","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc)","proofString":"exploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) : (exists pos' : Z,\n   label_pos lbl 0 (fn_code tf) = Some pos' /\\\n   code_tail (pos' - 0) (fn_code tf) tc /\\\n   0 < pos' <= 0 + list_length_z (fn_code tf)) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","conclusion":"(exists pos' : Z,\n   label_pos lbl 0 (fn_code tf) = Some pos' /\\\n   code_tail (pos' - 0) (fn_code tf) tc /\\\n   0 < pos' <= 0 + list_length_z (fn_code tf)) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r)","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc)","proofString":"intros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","conclusion":"exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r)","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"exists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m /\\\ntransl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r).","conclusion":"goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m /\\\ntransl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r)","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"split.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","conclusion":"goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"unfold goto_label.\nrewrite P.\nrewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : match label_pos lbl 0 (fn_code tf) with\n| Some pos =>\n    match rs PC with\n    | Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos)) m\n    | _ => Stuck\n    end\n| None => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","conclusion":"match label_pos lbl 0 (fn_code tf) with\n| Some pos =>\n    match rs PC with\n    | Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos)) m\n    | _ => Stuck\n    end\n| None => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"rewrite P.\nrewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : match rs PC with\n| Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos')) m\n| _ => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","conclusion":"match rs PC with\n| Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos')) m\n| _ => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"rewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m =\nNext rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","conclusion":"Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m =\nNext rs # PC <- (Vptr b (Ptrofs.repr pos')) m","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r).","conclusion":"transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r)","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"split.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc.","conclusion":"transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"rewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (Vptr b (Ptrofs.repr pos')) b f c' false tf tc.","conclusion":"transl_code_at_pc ge (Vptr b (Ptrofs.repr pos')) b f c' false tf tc","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"constructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail (Ptrofs.unsigned (Ptrofs.repr pos')) (fn_code tf) tc.","conclusion":"code_tail (Ptrofs.unsigned (Ptrofs.repr pos')) (fn_code tf) tc","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"rewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail pos' (fn_code tf) tc.","conclusion":"code_tail pos' (fn_code tf) tc","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"replace (pos' - 0) with pos' in Q.\nauto.\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail pos' (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail pos' (fn_code tf) tc.","conclusion":"code_tail pos' (fn_code tf) tc","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail pos' (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : pos' = pos' - 0.","conclusion":"pos' = pos' - 0","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"lia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : 0 <= pos' <= Ptrofs.max_unsigned.","conclusion":"0 <= pos' <= Ptrofs.max_unsigned","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"generalize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned ->\n0 <= pos' <= Ptrofs.max_unsigned.","conclusion":"list_length_z (fn_code tf) <= Ptrofs.max_unsigned ->\n0 <= pos' <= Ptrofs.max_unsigned","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"lia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r.","conclusion":"forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf))","proofString":"intros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) (r : preg) (H3 : r <> PC) : rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r.","conclusion":"rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r","hypotheses":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) (r : preg) (H3 : r <> PC)","proofString":"apply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) : forall (f0 : Mach.function) (i : Mach.instruction) (ep : bool) (k c0 : code),\ntransl_instr f0 i ep k = OK c0 -> is_tail k c0.","conclusion":"forall (f0 : Mach.function) (i : Mach.instruction) (ep : bool) (k c0 : code),\ntransl_instr f0 i ep k = OK c0 -> is_tail k c0","hypotheses":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f))","proofString":"intros.\nexploit transl_instr_label; eauto.\ndestruct i; try (intros [A B]; apply A).\nintros.\nsubst c0.\nrepeat constructor."},{"statement":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (i : Mach.instruction) (ep : bool) (k c0 : code) (H0 : transl_instr f0 i ep k = OK c0) : is_tail k c0.","conclusion":"is_tail k c0","hypotheses":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (i : Mach.instruction) (ep : bool) (k c0 : code) (H0 : transl_instr f0 i ep k = OK c0)","proofString":"exploit transl_instr_label; eauto.\ndestruct i; try (intros [A B]; apply A).\nintros.\nsubst c0.\nrepeat constructor."},{"statement":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (i : Mach.instruction) (ep : bool) (k c0 : code) (H0 : transl_instr f0 i ep k = OK c0) : match i with\n| Mlabel lbl => c0 = Plabel lbl :: k\n| _ => tail_nolabel k c0\nend -> is_tail k c0.","conclusion":"match i with\n| Mlabel lbl => c0 = Plabel lbl :: k\n| _ => tail_nolabel k c0\nend -> is_tail k c0","hypotheses":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (i : Mach.instruction) (ep : bool) (k c0 : code) (H0 : transl_instr f0 i ep k = OK c0)","proofString":"destruct i; try (intros [A B]; apply A).\nintros.\nsubst c0.\nrepeat constructor."},{"statement":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (l : Mach.label) (ep : bool) (k c0 : code) (H0 : transl_instr f0 (Mlabel l) ep k = OK c0) : c0 = Plabel l :: k -> is_tail k c0.","conclusion":"c0 = Plabel l :: k -> is_tail k c0","hypotheses":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (l : Mach.label) (ep : bool) (k c0 : code) (H0 : transl_instr f0 (Mlabel l) ep k = OK c0)","proofString":"intros.\nsubst c0.\nrepeat constructor."},{"statement":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (l : Mach.label) (ep : bool) (k c0 : code) (H0 : transl_instr f0 (Mlabel l) ep k = OK c0) (H1 : c0 = Plabel l :: k) : is_tail k c0.","conclusion":"is_tail k c0","hypotheses":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (l : Mach.label) (ep : bool) (k c0 : code) (H0 : transl_instr f0 (Mlabel l) ep k = OK c0) (H1 : c0 = Plabel l :: k)","proofString":"subst c0.\nrepeat constructor."},{"statement":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H0 : transl_instr f0 (Mlabel l) ep k = OK (Plabel l :: k)) : is_tail k (Plabel l :: k).","conclusion":"is_tail k (Plabel l :: k)","hypotheses":"(f : Mach.function) (sg : signature) (ros : mreg + ident) (c : list Mach.instruction) (H : is_tail (Mcall sg ros :: c) (Mach.fn_code f)) (f0 : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H0 : transl_instr f0 (Mlabel l) ep k = OK (Plabel l :: k))","proofString":"repeat constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (Mach.semantics return_address_offset prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (Mach.semantics return_address_offset prog)) id","hypotheses":"","proofString":"apply senv_preserved."}]}