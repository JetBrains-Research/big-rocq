{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/AST.v","fileSamples":[{"statement":"(x y : calling_convention) (cc_vararg0 : option Z) (cc_unproto0 cc_structret0 : bool) (cc_vararg1 : option Z) (cc_unproto1 cc_structret1 : bool) : {cc_vararg0 = cc_vararg1} + {cc_vararg0 <> cc_vararg1}.","proofString":"decide equality; apply Z.eq_dec."},{"statement":"(i : ident) (i0 : ptrofs) : (if Archi.ptr64 then 8 else 4) >= 0.","proofString":"destruct Archi.ptr64; lia."},{"statement":"0 >= 0.","proofString":"lia."},{"statement":"(a : init_data) (il : list init_data) (IHil : init_data_list_size il >= 0) : init_data_size a + init_data_list_size il >= 0.","proofString":"generalize (init_data_size_pos a); lia."},{"statement":"(defs1 : list (ident * globdef F V)) (id : ident) (g : globdef F V) (defs2 : list (ident * globdef F V)) (H : prog_defs p = defs1 ++ (id, g) :: defs2) (H0 : ~ In id (map fst defs2)) : (PTree_Properties.of_list (prog_defs p)) ! id = Some g.","proofString":"rewrite H.\napply PTree_Properties.of_list_unique; auto."},{"statement":"(defs1 : list (ident * globdef F V)) (id : ident) (g : globdef F V) (defs2 : list (ident * globdef F V)) (H : prog_defs p = defs1 ++ (id, g) :: defs2) (H0 : ~ In id (map fst defs2)) : (PTree_Properties.of_list (defs1 ++ (id, g) :: defs2)) ! id = Some g.","proofString":"apply PTree_Properties.of_list_unique; auto."},{"statement":"(A : Type) (B : Type) (V : Type) (transf_fun : A -> B) (p : program A V) : transform_partial_program (fun f : A => OK (transf_fun f)) p =\nOK (transform_program transf_fun p).","proofString":"unfold transform_partial_program, transform_partial_program2.\nassert (EQ: forall l,              transf_globdefs (fun i f => OK (transf_fun f)) (fun i (v: V) => OK v) l =              OK (List.map (transform_program_globdef transf_fun) l)).\ninduction l as [ | [id g] l]; simpl.\nauto.\ndestruct g; simpl; rewrite IHl; simpl.\nauto.\ndestruct v; auto.\nrewrite EQ; simpl.\nauto."},{"statement":"(A : Type) (B : Type) (V : Type) (transf_fun : A -> B) (p : program A V) : (do gl' <-\n transf_globdefs (fun (_ : ident) (f : A) => OK (transf_fun f))\n   (fun (_ : ident) (v : V) => OK v) (prog_defs p);\n OK\n   {|\n     prog_defs := gl'; prog_public := prog_public p; prog_main := prog_main p\n   |}) = OK (transform_program transf_fun p).","proofString":"assert (EQ: forall l,              transf_globdefs (fun i f => OK (transf_fun f)) (fun i (v: V) => OK v) l =              OK (List.map (transform_program_globdef transf_fun) l)).\ninduction l as [ | [id g] l]; simpl.\nauto.\ndestruct g; simpl; rewrite IHl; simpl.\nauto.\ndestruct v; auto.\nrewrite EQ; simpl.\nauto."},{"statement":"(A : Type) (B : Type) (V : Type) (transf_fun : A -> B) (p : program A V) : forall l : list (ident * globdef A V),\ntransf_globdefs (fun (_ : ident) (f : A) => OK (transf_fun f))\n  (fun (_ : ident) (v : V) => OK v) l =\nOK (map (transform_program_globdef transf_fun) l).","proofString":"induction l as [ | [id g] l]; simpl.\nauto.\ndestruct g; simpl; rewrite IHl; simpl.\nauto.\ndestruct v; auto."},{"statement":"(A : Type) (B : Type) (V : Type) (transf_fun : A -> B) (p : program A V) (id : ident) (g : globdef A V) (l : list (ident * globdef A V)) (IHl : transf_globdefs (fun (_ : ident) (f : A) => OK (transf_fun f))\n  (fun (_ : ident) (v : V) => OK v) l =\nOK (map (transform_program_globdef transf_fun) l)) : match g with\n| Gfun f =>\n    do tl' <-\n    transf_globdefs (fun (_ : ident) (f0 : A) => OK (transf_fun f0))\n      (fun (_ : ident) (v : V) => OK v) l;\n    OK ((id, Gfun (transf_fun f)) :: tl')\n| Gvar v =>\n    do tl' <-\n    transf_globdefs (fun (_ : ident) (f : A) => OK (transf_fun f))\n      (fun (_ : ident) (v0 : V) => OK v0) l;\n    OK\n      ((id,\n        Gvar\n          {|\n            gvar_info := gvar_info v;\n            gvar_init := gvar_init v;\n            gvar_readonly := gvar_readonly v;\n            gvar_volatile := gvar_volatile v\n          |}) :: tl')\nend =\nOK\n  (match g with\n   | Gfun f => (id, Gfun (transf_fun f))\n   | Gvar v => (id, Gvar v)\n   end :: map (transform_program_globdef transf_fun) l).","proofString":"destruct g; simpl; rewrite IHl; simpl.\nauto.\ndestruct v; auto."},{"statement":"(A : Type) (B : Type) (V : Type) (transf_fun : A -> B) (p : program A V) (id : ident) (f : A) (l : list (ident * globdef A V)) (IHl : transf_globdefs (fun (_ : ident) (f0 : A) => OK (transf_fun f0))\n  (fun (_ : ident) (v : V) => OK v) l =\nOK (map (transform_program_globdef transf_fun) l)) : OK\n  ((id, Gfun (transf_fun f)) :: map (transform_program_globdef transf_fun) l) =\nOK\n  ((id, Gfun (transf_fun f)) :: map (transform_program_globdef transf_fun) l).","proofString":"auto."},{"statement":"(A : Type) (B : Type) (V : Type) (transf_fun : A -> B) (p : program A V) (id : ident) (v : globvar V) (l : list (ident * globdef A V)) (IHl : transf_globdefs (fun (_ : ident) (f : A) => OK (transf_fun f))\n  (fun (_ : ident) (v0 : V) => OK v0) l =\nOK (map (transform_program_globdef transf_fun) l)) : OK\n  ((id,\n    Gvar\n      {|\n        gvar_info := gvar_info v;\n        gvar_init := gvar_init v;\n        gvar_readonly := gvar_readonly v;\n        gvar_volatile := gvar_volatile v\n      |}) :: map (transform_program_globdef transf_fun) l) =\nOK ((id, Gvar v) :: map (transform_program_globdef transf_fun) l).","proofString":"destruct v; auto."},{"statement":"(A : Type) (B : Type) (V : Type) (transf_fun : A -> B) (p : program A V) (EQ : forall l : list (ident * globdef A V),\ntransf_globdefs (fun (_ : ident) (f : A) => OK (transf_fun f))\n  (fun (_ : ident) (v : V) => OK v) l =\nOK (map (transform_program_globdef transf_fun) l)) : (do gl' <-\n transf_globdefs (fun (_ : ident) (f : A) => OK (transf_fun f))\n   (fun (_ : ident) (v : V) => OK v) (prog_defs p);\n OK\n   {|\n     prog_defs := gl'; prog_public := prog_public p; prog_main := prog_main p\n   |}) = OK (transform_program transf_fun p).","proofString":"rewrite EQ; simpl.\nauto."},{"statement":"(A : Type) (B : Type) (V : Type) (transf_fun : A -> B) (p : program A V) (EQ : forall l : list (ident * globdef A V),\ntransf_globdefs (fun (_ : ident) (f : A) => OK (transf_fun f))\n  (fun (_ : ident) (v : V) => OK v) l =\nOK (map (transform_program_globdef transf_fun) l)) : OK\n  {|\n    prog_defs := map (transform_program_globdef transf_fun) (prog_defs p);\n    prog_public := prog_public p;\n    prog_main := prog_main p\n  |} = OK (transform_program transf_fun p).","proofString":"auto."},{"statement":"(H : forall x y : positive, {x = y} + {x <> y}) (H0 : forall s1 s2 : string, {s1 = s2} + {s1 <> s2}) (H1 : forall s1 s2 : signature, {s1 = s2} + {s1 <> s2}) (H2 : forall c1 c2 : memory_chunk, {c1 = c2} + {c1 <> c2}) (H3 : forall t1 t2 : typ, {t1 = t2} + {t1 <> t2}) (H4 : forall t1 t2 : xtype, {t1 = t2} + {t1 <> t2}) (X : forall A : Type,\n(forall x y : A, {x = y} + {x <> y}) ->\nforall l l' : list A, {l = l'} + {l <> l'}) (H5 : forall x y : Z, {x = y} + {x <> y}) (H6 : forall x y : int, {x = y} + {x <> y}) (ef1 ef2 : external_function) : {ef1 = ef2} + {ef1 <> ef2}.","proofString":"decide equality."},{"statement":"(A : Type) (x : A) (p : rpair A) (H : In x (regs_of_rpair p)) (H0 : False) : False.","proofString":"auto."},{"statement":"(A : Type) (x : A) (p : rpair A) (H : In x (regs_of_rpair p)) (a : rpair A) (l : list (rpair A)) (IHl : In p l -> In x (regs_of_rpairs l)) (H0 : a = p \\/ In p l) : In x (regs_of_rpair a ++ regs_of_rpairs l).","proofString":"apply in_app.\ndestruct H0; auto.\nsubst a.\nauto."},{"statement":"(A : Type) (x : A) (p : rpair A) (H : In x (regs_of_rpair p)) (a : rpair A) (l : list (rpair A)) (IHl : In p l -> In x (regs_of_rpairs l)) (H0 : a = p \\/ In p l) : In x (regs_of_rpair a) \\/ In x (regs_of_rpairs l).","proofString":"destruct H0; auto.\nsubst a.\nauto."},{"statement":"(A : Type) (x : A) (p : rpair A) (H : In x (regs_of_rpair p)) (a : rpair A) (l : list (rpair A)) (IHl : In p l -> In x (regs_of_rpairs l)) (H0 : a = p) : In x (regs_of_rpair a) \\/ In x (regs_of_rpairs l).","proofString":"subst a.\nauto."},{"statement":"(A : Type) (x : A) (p : rpair A) (H : In x (regs_of_rpair p)) (l : list (rpair A)) (IHl : In p l -> In x (regs_of_rpairs l)) : In x (regs_of_rpair p) \\/ In x (regs_of_rpairs l).","proofString":"auto."},{"statement":"(A : Type) (x : A) (H : False) : exists p : rpair A, False /\\ In x (regs_of_rpair p).","proofString":"contradiction."},{"statement":"(A : Type) (x : A) (a : rpair A) (l : list (rpair A)) (IHl : In x (regs_of_rpairs l) ->\nexists p : rpair A, In p l /\\ In x (regs_of_rpair p)) (H : In x (regs_of_rpair a ++ regs_of_rpairs l)) : exists p : rpair A, (a = p \\/ In p l) /\\ In x (regs_of_rpair p).","proofString":"rewrite in_app_iff in H; destruct H.\nexists a; auto.\napply IHl in H.\nfirstorder auto."},{"statement":"(A : Type) (x : A) (a : rpair A) (l : list (rpair A)) (IHl : In x (regs_of_rpairs l) ->\nexists p : rpair A, In p l /\\ In x (regs_of_rpair p)) (H : In x (regs_of_rpair a)) : exists p : rpair A, (a = p \\/ In p l) /\\ In x (regs_of_rpair p).","proofString":"exists a; auto."},{"statement":"(A : Type) (x : A) (a : rpair A) (l : list (rpair A)) (IHl : In x (regs_of_rpairs l) ->\nexists p : rpair A, In p l /\\ In x (regs_of_rpair p)) (H : In x (regs_of_rpairs l)) : exists p : rpair A, (a = p \\/ In p l) /\\ In x (regs_of_rpair p).","proofString":"apply IHl in H.\nfirstorder auto."},{"statement":"(A : Type) (x : A) (a : rpair A) (l : list (rpair A)) (IHl : In x (regs_of_rpairs l) ->\nexists p : rpair A, In p l /\\ In x (regs_of_rpair p)) (H : exists p : rpair A, In p l /\\ In x (regs_of_rpair p)) : exists p : rpair A, (a = p \\/ In p l) /\\ In x (regs_of_rpair p).","proofString":"firstorder auto."},{"statement":"(A : Type) (eq : forall x0 y0 : A, {x0 = y0} + {x0 <> y0}) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) (H2 : forall f1 f2 : float, {f1 = f2} + {f1 <> f2}) (H3 : forall f1 f2 : float32, {f1 = f2} + {f1 <> f2}) (H4 : forall c1 c2 : memory_chunk, {c1 = c2} + {c1 <> c2}) (H5 : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (x y : builtin_arg A) : {x = y} + {x <> y}.","proofString":"decide equality."}]}