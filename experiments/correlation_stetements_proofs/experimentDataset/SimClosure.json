[{"statement":"Lemma iiord_step_incl l tc1 tc2\n  (STEP : iiord_step l tc1 tc2) :\n  tc2 ≡₁ tc1 ∪₁ eq l.","proof":"red in STEP.\ngeneralize STEP.\nbasic_solver.\n"},{"statement":"Lemma covered_rel_clos tc : covered (rel_clos tc) ≡₁ Rel ∩₁ issued tc.","proof":"unfold rel_clos.\nunfold covered, set_pair.\nsplit; unfolder; ins; do 2 desf.\neexists (_, _); eauto.\n"},{"statement":"Lemma rmw_clos_dist (tc1 tc2: trav_label -> Prop):\n  rmw_clos (tc1 ∪₁ tc2) ≡₁ rmw_clos tc1 ∪₁ rmw_clos tc2.","proof":"unfold rmw_clos.\nrewrite !set_pair_alt.\nunfold covered.\nbasic_solver 10.\n"},{"statement":"Lemma rel_clos_dist (tc1 tc2: trav_label -> Prop):\n  rel_clos (tc1 ∪₁ tc2) ≡₁ rel_clos tc1 ∪₁ rel_clos tc2.","proof":"unfold rel_clos.\nrewrite !set_pair_alt.\nunfold issued.\nbasic_solver 10.\n"},{"statement":"Lemma sim_clos_union (tc1 tc2: trav_label -> Prop):\n  sim_clos (tc1 ∪₁ tc2) ≡₁ sim_clos tc1 ∪₁ sim_clos tc2.","proof":"unfold sim_clos.\nrewrite rel_clos_dist, rmw_clos_dist.\nbasic_solver.\n"},{"statement":"Lemma sim_clos_empty:\n  sim_clos ∅ ≡₁ ∅.","proof":"unfold sim_clos, rmw_clos, rel_clos, issued, covered.\nrewrite !set_pair_alt.\nbasic_solver.\n"},{"statement":"Lemma rmw_clos_once WF (tc: trav_label -> Prop):\n  rmw_clos (rmw_clos tc) ⊆₁ ∅.","proof":"unfold rmw_clos.\nunfold covered.\nrewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0 x1 z.\nsubst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver.\n"},{"statement":"Lemma rmw_rel_clos_none WF (tc: trav_label -> Prop) (TCOH: tls_coherent G tc):\n  rmw_clos (rel_clos tc) ⊆₁ ∅.","proof":"unfold rmw_clos, rel_clos.\nunfold covered, issued.\nrewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver.\n"},{"statement":"Lemma rel_rmw_clos_rmw (tc: trav_label -> Prop)\n      (TCOH: tls_coherent G tc) (ICOH: iord_coherent G sc tc):\n  rel_clos (rmw_clos tc) ⊆₁ rmw_clos tc.","proof":"unfold rmw_clos, rel_clos.\nunfold covered, issued.\nrewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto).\n"},{"statement":"Lemma rel_clos_idemp (tc: trav_label -> Prop):\n  rel_clos (rel_clos tc) ⊆₁ rel_clos tc.","proof":"unfold rel_clos.\nunfold issued.\nrewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst.\nsplits; eauto.\n"},{"statement":"Lemma sim_clos_dist (tc1 tc2: trav_label -> Prop):\n  sim_clos (tc1 ∪₁ tc2) ≡₁ sim_clos tc1 ∪₁ sim_clos tc2.","proof":"unfold sim_clos.\nrewrite rmw_clos_dist, rel_clos_dist.\nbasic_solver.\n"},{"statement":"Lemma sim_clos_sim_coherent WF (tc: trav_label -> Prop)\n      (TCOH: tls_coherent G tc) (ICOH: iord_coherent G sc tc):\n  sim_coherent (sim_clos tc).","proof":"unfold sim_coherent.\nunfold sim_clos.\nsplit; [basic_solver 10| ].\nrewrite !rmw_clos_dist, !rel_clos_dist.\nrepeat (apply set_subset_union_l; split; try basic_solver).\n{\nrewrite rmw_clos_once; basic_solver.\n}\n{\nrewrite rmw_rel_clos_none; basic_solver.\n}\n{\nrewrite rel_rmw_clos_rmw; basic_solver.\n}\nrewrite rel_clos_idemp; basic_solver.\n"},{"statement":"Lemma exec_tls_sim_coh (WF: Wf G):\n  sim_coherent (exec_tls G).","proof":"unfold sim_coherent, sim_clos.\nsplit; [basic_solver| ].\nrepeat (apply set_subset_union_l; split; try basic_solver).\n{\nunfold rmw_clos, exec_tls, covered, issued.\nrepeat rewrite set_pair_alt.\nrewrite wf_rmwE, wf_rmwD, rmw_non_init_lr; auto.\niord_dom_unfolder; [by vauto| ].\nintuition.\n}\n{\nunfold rel_clos, exec_tls, covered, issued.\nrepeat rewrite set_pair_alt.\niord_dom_unfolder.\nleft.\nvauto.\n}\n"},{"statement":"Lemma init_tls_sim_coh (WF: Wf G):\n  sim_coherent (init_tls G).","proof":"unfold sim_coherent, sim_clos.\nsplit; [basic_solver| ].\nrepeat (apply set_subset_union_l; split); try basic_solver.\n{\nunfold rmw_clos.\nrewrite set_pair_alt.\netransitivity.\n{\nred.\nintro.\napply proj2.\n}\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver.\n}\nunfold rel_clos.\nrewrite set_pair_alt.\netransitivity.\n{\nred.\nintro.\napply proj2.\n}\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto.\n"},{"statement":"Lemma event_sur:\n  forall y : actid, exists x : trav_label, event x = y.","proof":"ins.\nexists (mkTL ta_cover y).\nvauto.\n"},{"statement":"Lemma action_sur:\n  forall y : trav_action, exists x : trav_label, action x = y.","proof":"ins.\nexists (mkTL y (InitEvent tid_init)).\nvauto.\n"},{"statement":"Lemma rmw_cover_simpl WF tc:\n  codom_rel (event ↓ (⦗covered tc⦘ ⨾ rmw)) ⊆₁\n  codom_rel (⦗(tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ event ↓ rmw).","proof":"unfolder.\nins.\ndesc.\ndo 2 red in H.\ndesc.\nred in H.\ndesc.\ndestruct x as [a2 e2], x0 as [a1 e1], y as [a3 e3].\nred in H2.\nins.\nsubst.\neexists.\nsplits; eauto.\n"},{"statement":"Lemma sb_cr_tc_cover (tc: trav_label -> Prop)\n      (TCOH: tls_coherent G tc) (ICOH: iord_coherent G sc tc):\n  ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb^? ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘ ⊆\n  ⦗tc ∩₁ action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb^? ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘.","proof":"rewrite crE, map_rel_union, seq_union_l.\nrepeat case_union _ _.\napply union_mori.\n{\niord_dom_solver.\n}\nrewrite id_inter, seqA.\napply doma_helper, doma_alt.\nrewrite set_split_complete with (s' := action ↓₁ _) (s := event ↓₁ is_init)at 1.\nrewrite id_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\n{\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\n}\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver.\n"},{"statement":"Lemma iord_coherent_AR_ext_cover WF CONS tc\n      (TCOH: tls_coherent G tc) (ICOH: iord_coherent G sc tc):\n  dom_rel (((⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾\n                (ar ∪ rf ⨾ ppo ∩ same_loc)^*) ⨾ ⦗action ↓₁ eq ta_cover⦘)) ⨾ ⦗tc⦘)\n             ⊆₁ tc.","proof":"rewrite rtEE.\nrewrite seq_bunion_r, rel_map_bunionC.\nrepeat seq_rewrite seq_bunion_r.\nrepeat seq_rewrite seq_bunion_l.\nrewrite dom_rel_bunion.\napply set_subset_bunion_l.\nintros n _.\ninduction n.\n{\nsimpl.\nunfolder.\nins.\ndesc.\ndestruct x, y; ins; vauto.\nforward eapply tlsc_w_covered_issued with (x := (ta_cover, a0)); eauto.\n{\nbasic_solver.\n}\nunfold event, action.\nunfolder.\nins.\ndesc.\ndestruct y; ins; vauto.\n}\nrewrite pow_S_end.\nrewrite <- seqA.\narewrite (ar ∪ rf ⨾ ppo ∩ same_loc ⊆ (sb ∪ sc)^+ ∪ rfe ⨾ (sb ∪ sc)^*) at 2.\n{\nunfold \"ar\".\nrewrite rfi_union_rfe, inclusion_inter_l1.\nrewrite ppo_in_sb, ar_int_in_sb, rfi_in_sb; auto.\ncase_union _ _.\nrewrite sb_sb.\nrewrite <- ct_step.\nrepeat (apply inclusion_union_l); try basic_solver 10.\napply inclusion_union_r2_search.\nhahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step.\n}\nrepeat case_union _ _.\nrewrite map_rel_union.\nrewrite <- !seqA.\nrewrite seqA with (r2 := rfe).\nrewrite map_rel_seq_insert_exact with (r2 := rfe ⨾ _) (d := action ↓₁ eq ta_issue).\n2: {\nins.\nexists (mkTL ta_issue b).\nvauto.\n}\nrewrite map_rel_seq_insert_exact with (d := action ↓₁ eq ta_cover) at 1.\n2: {\nins.\nexists (mkTL ta_cover b).\nvauto.\n}\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\n{\nerewrite dom_rel_mori.\n2: {\nrewrite !seqA.\ndo 2 (apply seq_mori; [reflexivity| ]).\nrewrite <- seq_eqvK at 1.\nrewrite seqA.\napply seq_mori; [reflexivity| ].\napply dom_rel_helper_in in ICOH.\netransitivity; [| apply ICOH].\nunfold iord_simpl, SB.\nbasic_solver 10.\n}\nrewrite <- !seqA.\ndo 2 rewrite dom_seq.\nrewrite !seqA.\nerewrite dom_rel_mori; [by apply IHn| ].\nbasic_solver.\n}\nrewrite map_rel_seq_insert_exact with (r1 := rfe) (d := action ↓₁ eq ta_cover).\n2: {\nins.\nexists (mkTL ta_cover b).\nvauto.\n}\nrewrite !seqA.\nerewrite dom_rel_mori.\n2: {\ndo 4 (apply seq_mori; [reflexivity| ]).\napply dom_rel_helper_in with (d := tc).\nrewrite rtE, map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\n{\niord_dom_solver.\n}\netransitivity; [| by apply ICOH].\nunfold iord_simpl, SB.\nbasic_solver 10.\n}\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\nrewrite !seqA.\nerewrite dom_rel_mori.\n2: {\ndo 2 (apply seq_mori; [reflexivity| ]).\nrewrite seq_eqvC.\napply dom_rel_helper_in with (d := tc).\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (RF G); [| unfold iord_simpl; basic_solver 10].\nunfold RF.\nhahn_frame.\nrewrite rfe_in_rf, (dom_l (wf_rfD WF)).\nbasic_solver.\n}\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\nrewrite !seqA, seq_eqvC.\narewrite ((ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)^*).\nrewrite rtE.\ncase_union _ _ .\nrewrite map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\n{\niord_dom_solver.\n}\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10.\n"},{"statement":"Lemma sim_clos_iord_simpl_rmw_clos WF CONS (tc: trav_label -> Prop)\n      (TCOH: tls_coherent G tc) (ICOH: iord_coherent G sc tc):\n  dom_rel (iord_simpl G sc ⨾ ⦗rmw_clos tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","proof":"unfold iord_simpl.\nrepeat case_union _ _.\nrewrite !dom_union.\nunfold rmw_clos.\nrewrite !set_pair_alt.\nrepeat (apply set_subset_union_l; split).\n5,6: iord_dom_solver.\n{\netransitivity; [| do 2 (apply set_subset_union_r; left); reflexivity].\nfold action event.\nunfold SB.\nrewrite ct_end at 1.\nerewrite <- map_rel_seq2; [| by_sur].\nrewrite map_rel_union.\nrewrite !seqA, seq_union_l.\netransitivity.\n{\napply dom_rel_mori.\ndo 2 (apply seq_mori; [reflexivity| ]).\napply union_mori; [reflexivity| ].\nUnshelve.\n2: exact (fun _ _ => False).\ncdes CONS.\nrewrite wf_scD, wf_rmwD; eauto.\nunfold event, action.\ntype_solver.\n}\nrewrite union_false_r.\nrewrite <- !id_inter.\nrewrite <- !set_interA.\nrewrite set_inter_absorb_r with (s' := _ ↓₁ (_ ∪₁ _)); [| basic_solver].\nrewrite <- set_map_codom_ext; [| apply event_sur].\nrewrite rmw_cover_simpl; auto.\nerewrite eqv_rel_mori with (x := _ ∩₁ _); [| red; intro; apply proj2].\nrewrite <- !seqA, dom_rel_eqv_codom_rel.\nrewrite transp_seq, <- map_rel_transp, !transp_eqv_rel.\nrewrite !seqA.\nseq_rewrite !map_rel_seq2; try by_sur.\nrewrite seqA.\nsin_rewrite sb_transp_rmw; auto.\narewrite ((sb ∪ sc)＊ ⨾ sb^? ⊆ (sb ∪ sc)＊).\n{\nrewrite crE, seq_union_r.\napply inclusion_union_l; [basic_solver| ].\nrewrite <- rt_unit at 2.\napply seq_mori; basic_solver.\n}\nrewrite rtE, map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\n{\niord_dom_solver.\n}\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite set_interC, id_inter.\nunfold iord_simpl, SB.\nbasic_solver 10.\n}\n{\nunfold RF.\nrewrite crE, seq_union_r, map_rel_union.\nrewrite !seqA, !seq_union_l.\netransitivity.\n{\napply dom_rel_mori.\napply seq_mori; [reflexivity| ].\napply union_mori; [reflexivity| ].\nUnshelve.\n2: exact (fun _ _ => False).\nrewrite wf_rfD, wf_rmwD; auto.\nunfold action, event.\ntype_solver 10.\n}\napply set_subset_union_r.\nleft.\napply set_subset_union_r.\nright.\nunfold action, event.\niord_dom_unfolder.\nvauto.\n}\n{\ndo 2 (apply set_subset_union_r; left).\nerewrite eqv_rel_mori with (x := _ ∩₁ _); [| red; intro; apply proj2].\nfold event action.\nrewrite <- set_map_codom_ext; [| apply event_sur].\nrewrite rmw_cover_simpl; auto.\nrewrite dom_rel_eqv_codom_rel.\nrewrite transp_seq, transp_eqv_rel, <- map_rel_transp.\netransitivity; [| apply iord_simpl_coh_clos_refl].\n2: {\neapply iord_coh_implies_iord_simpl_coh; eauto.\n}\napply dom_rel_mori.\nunfold iord_simpl.\nrepeat rewrite unionA.\netransitivity.\n2: {\napply seq_mori; [| reflexivity].\napply clos_refl_mori.\napply inclusion_union_r1.\n}\nunfold FWBOB, SB.\nrewrite fwbob_in_sb.\nrewrite inclusion_seq_eqv_r with (dom := W).\nrewrite inclusion_seq_eqv_r with (dom := action ↓₁ _) at 1.\nrewrite seqA.\nseq_rewrite map_rel_seq2; [| by_sur].\nrewrite sb_transp_rmw; auto.\nrewrite crE, map_rel_union.\nrepeat case_union _ _.\napply inclusion_union_l.\n{\nrewrite crE.\ncase_union _ _ .\netransitivity; [| apply inclusion_union_r1].\niord_dom_solver; vauto.\n}\nrewrite crE.\ncase_union _ _ .\netransitivity; [| apply inclusion_union_r2].\nrewrite id_inter, seq_eqvC.\nhahn_frame.\nrewrite <- inclusion_union_r1, <- ct_step.\nbasic_solver.\n}\nunfold AR.\nfold event action.\nrewrite ct_end, !seqA.\nunfold \"ar\" at 2.\nrepeat rewrite seq_union_l with (r := ⦗W⦘).\narewrite (sc ⨾ ⦗W⦘ ∪ rfe ⨾ ⦗W⦘ ⊆ ∅₂); [| rewrite union_false_l].\n{\ncdes CONS.\nrewrite (wf_scD Wf_sc), wf_rfeD; eauto.\ntype_solver.\n}\nrewrite ar_int_in_sb; auto.\narewrite (ppo ∩ same_loc ⊆ sb) at 2.\n{\nrewrite ppo_in_sb; basic_solver.\n}\nrewrite <- cr_seq.\narewrite (rf^? ⨾ sb ⊆ rfe^? ⨾ sb).\n{\nrewrite rfi_union_rfe.\nrewrite crE.\nrepeat case_union _ _.\nrewrite rfi_in_sb, sb_sb.\nbasic_solver.\n}\nrewrite <- seqA with (r2 := rfe^?).\nerewrite inclusion_seq_trans with (r' := rfe^?); [| | reflexivity| ].\n2: {\napply transitive_rt.\n}\n2: {\nrewrite <- inclusion_r_rt; [| reflexivity].\napply clos_refl_mori.\nunfold \"ar\".\nbasic_solver.\n}\nrewrite <- seqA with (r1 := ⦗W⦘).\nrewrite map_rel_seq_insert_exact with (d := action ↓₁ eq ta_cover).\n2: {\nins.\nby exists (mkTL ta_cover b).\n}\nrewrite <- set_map_codom_ext, rmw_cover_simpl at 1; auto; [|by apply event_sur].\nrewrite id_inter with (s := action ↓₁ _).\nrewrite <- !seqA, dom_rel_eqv_codom_rel.\ndo 2 rewrite inclusion_seq_eqv_r.\nrewrite transp_seq, transp_eqv_rel, <- map_rel_transp.\nrewrite inclusion_seq_eqv_r with (dom := W).\nrewrite seqA.\nseq_rewrite map_rel_seq2; [| by_sur].\nrewrite sb_transp_rmw; auto.\nrewrite seqA, sb_cr_tc_cover; auto.\nrewrite <- !seqA.\ndo 2 rewrite dom_seq.\nrewrite !seqA.\nrewrite rtE.\ncase_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\netransitivity; [| rewrite set_unionA; apply set_subset_union_r1].\napply set_subset_union_l.\nsplit.\n{\nunfolder.\nins.\ndesc.\ndestruct x, y.\nins.\nsubst.\nforward eapply tlsc_w_covered_issued with (x := (ta_cover, a0)); eauto.\n{\nbasic_solver.\n}\nunfolder.\nins.\ndesc.\ndestruct y.\nins.\nvauto.\n}\netransitivity; [| apply iord_coherent_AR_ext_cover]; auto.\nbasic_solver 10.\n"},{"statement":"Lemma sim_clos_iord_simpl_rel_clos WF CONS (tc: trav_label -> Prop)\n      (TCOH: tls_coherent G tc) (ICOH: iord_coherent G sc tc):\n  dom_rel (iord_simpl G sc ⨾ ⦗rel_clos tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","proof":"pose proof ICOH as ICOH'.\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\nunfold rel_clos at 1.\nrewrite !set_pair_alt.\nunfold iord_simpl.\nfold action event.\nrepeat (case_union _ _; rewrite dom_union; apply set_subset_union_l; split).\nall: try by iord_dom_solver.\n{\nunfold issued, SB.\nunfolder.\nins.\ndesc.\ndestruct x, y, y0; ins; vauto.\nleft.\nleft.\nenough (dom_rel (⦗action ↓₁ eq ta_cover⦘ ⨾ (event ↓ (sb ∪ sc)^+)⨾ ⦗event ↓₁ Rel⦘ ⨾ ⦗action ↓₁ eq ta_issue⦘⨾ ⦗tc⦘) ⊆₁ tc) as ALT.\n{\nrewrite <- !id_inter in ALT.\napply ALT.\neexists.\napply seq_eqv_lr.\nsplits; basic_solver.\n}\nclear dependent a.\nclear dependent a0.\nclear H2.\nrewrite ct_end.\nrewrite map_rel_seq_insert_exact with (d := action ↓₁ eq ta_cover).\n2: {\nins.\nby exists (mkTL ta_cover b).\n}\nrewrite !seqA.\nrewrite map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\nerewrite set_union_mori.\n{\nrewrite set_union_empty_r.\nreflexivity.\n}\n2: {\nrewrite <- !id_inter.\nerewrite eqv_rel_mori with (x := _ ∩₁ _).\n2: {\netransitivity; [| apply tlsc_I_in_W]; basic_solver.\n}\ncdes CONS.\nrewrite (wf_scD Wf_sc).\niord_dom_unfolder.\ntype_solver.\n}\nrewrite dom_rel_helper_in with (r := _ ⨾ _ ⨾ _ ⨾ _ ⨾ ⦗tc⦘) (d := tc).\n2: {\nrewrite <- ICOH at 2.\napply dom_rel_mori.\ntransitivity (FWBOB G ⨾ ⦗tc⦘); [| unfold iord_simpl; basic_solver 10].\nunfold FWBOB.\nrewrite <- sb_to_w_rel_in_fwbob.\niord_dom_unfolder.\nsplits; vauto.\nforward eapply tlsc_I_in_W with (x := (ta_issue, d)) as I_W; eauto.\n{\nbasic_solver.\n}\neexists.\nsplits; eauto.\n}\nrewrite <- !seqA.\ndo 4 rewrite dom_seq.\nrewrite !seqA.\nrewrite seq_eqvC.\nrewrite rtE, map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit; [iord_dom_solver| ].\nrewrite <- ICOH at 2.\nunfold iord_simpl, SB.\nbasic_solver 10.\n}\n{\nunfold RF.\nrewrite crE, seq_union_r, map_rel_union.\nrepeat case_union _ _.\nrewrite union_mori; [rewrite union_false_r| reflexivity| ].\n2: {\nrewrite wf_rfD; auto.\nunfold issued.\nrewrite tlsc_I_in_W; eauto.\niord_dom_unfolder.\ntype_solver.\n}\niord_dom_unfolder.\nleft.\nleft.\ndo 2 red in d4.\ndesc.\ndestruct y; ins; vauto.\nunfolder in d4.\ndesc.\nins; vauto.\n}\n"},{"statement":"Lemma sim_clos_iord_coherent WF CONS (tc: trav_label -> Prop)\n      (TCOH: tls_coherent G tc) (ICOH: iord_coherent G sc tc)\n      :\n      iord_coherent G sc (sim_clos tc).","proof":"apply iord_simpl_coh_implies_iord_coh; auto.\nunfold sim_clos, iord_coherent.\nred.\nrewrite !id_union, !seq_union_r, !dom_union.\ndo 2 (try (apply set_subset_union_l; split)).\n{\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\nrewrite ICOH.\nbasic_solver.\n}\n{\napply sim_clos_iord_simpl_rmw_clos; auto.\n}\napply sim_clos_iord_simpl_rel_clos; auto.\n"},{"statement":"Lemma rmw_clos_exec_tls tc (WF: Wf G):\n  rmw_clos tc ⊆₁ exec_tls G.","proof":"unfold rmw_clos, exec_tls.\nrewrite !set_pair_alt.\narewrite (codom_rel (⦗covered tc⦘ ⨾ rmw) ⊆₁ (E \\₁ is_init) ∩₁ W).\n2: {\nbasic_solver 10.\n}\nrewrite wf_rmwD, wf_rmwE, rmw_in_sb, no_sb_to_init; auto.\nbasic_solver.\n"},{"statement":"Lemma rel_clos_exec_tls tc (WF: Wf G) (TC_E: tc ⊆₁ event ↓₁ E):\n  rel_clos tc ⊆₁ exec_tls G.","proof":"unfold rel_clos, exec_tls.\nrewrite !set_pair_alt.\napply set_subset_union_r.\nleft.\napply set_subset_inter; [done| ].\napply set_map_mori; [done| ].\nunfold issued.\nunfolder.\nins.\ndesc.\nsplit.\n{\napply TC_E in H0.\nvauto.\n}\neintros INIT%init_pln; eauto.\nmode_solver.\n"},{"statement":"Lemma sim_clos_exec_tls WF tc\n      (TC_EXEC: tc ⊆₁ exec_tls G):\n  sim_clos tc ⊆₁ exec_tls G.","proof":"repeat (apply set_subset_union_l; split); auto.\n{\nby apply rmw_clos_exec_tls.\n}\napply rel_clos_exec_tls; auto.\nrewrite TC_EXEC.\nrewrite exec_tls_ENI.\nbasic_solver.\n"},{"statement":"Lemma sim_clos_tls_coherent WF tc\n      (TCOH: tls_coherent G tc):\n  tls_coherent G (sim_clos tc).","proof":"pose proof TCOH as TCOH'.\napply tls_coherent_defs_equiv.\napply tls_coherent_defs_equiv in TCOH.\nred in TCOH.\ndesc.\nred.\nunfold sim_clos.\nexists (tc' ∪₁ rmw_clos tc ∪₁ rel_clos tc).\nsplit.\n2: {\nrewrite TCOH0 at 1.\nbasic_solver.\n}\nrepeat (apply set_subset_union_l; split); auto.\n{\nby apply rmw_clos_exec_tls.\n}\napply rel_clos_exec_tls; auto.\nby apply tlsc_E.\n"},{"statement":"Lemma iord_coh_intermediate WF CONS tc s1 s2\n      (ICOH: iord_coherent G sc tc)\n      (ICOH2: iord_coherent G sc (tc ∪₁ s1 ∪₁ s2))\n      (TCOH: tls_coherent G tc)\n      (TCOH2: tls_coherent G (tc ∪₁ s1 ∪₁ s2))\n      (NO_INTER: dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅):\n  iord_coherent G sc (tc ∪₁ s1).","proof":"apply iord_simpl_coh_implies_iord_coh; auto.\nred.\nrewrite id_union, seq_union_r, dom_union.\napply set_subset_union_l.\nsplit.\n{\nrewrite iord_coh_implies_iord_simpl_coh; auto using ICOH,TCOH.\nbasic_solver.\n}\napply iord_coh_implies_iord_simpl_coh in ICOH2; auto.\nrewrite <- set_subset_union_r1, <- set_subset_union_r2 in ICOH2 at 1.\nrewrite set_subset_inter_exact in ICOH2.\nrewrite set_inter_union_r, NO_INTER, set_union_empty_r in ICOH2.\nrewrite set_subset_inter_exact.\nauto.\n"},{"statement":"Lemma isim_clos_step_mon tl tc1 tc2\n  (STEP : isim_clos_step tl tc1 tc2) :\n  tc1 ⊆₁ tc2.","proof":"red in STEP.\ndesf.\nall: try now (erewrite iiord_step_incl with (tc2:=tc2); eauto with hahn).\nall: destruct STEP as [_ [x [AA BB]]].\nall: try now erewrite iiord_step_incl with (tc1:=x) (tc2:=tc2); eauto with hahn;               erewrite iiord_step_incl with (tc1:=tc1) (tc2:=x); eauto with hahn.\ndestruct BB as [y [BB CC]].\nerewrite iiord_step_incl with (tc1:=y)   (tc2:=tc2); eauto with hahn.\nerewrite iiord_step_incl with (tc1:=x)   (tc2:=y  ); eauto with hahn.\nerewrite iiord_step_incl with (tc1:=tc1) (tc2:=x  ); eauto with hahn.\nclear.\nbasic_solver.\n"},{"statement":"Lemma sim_clos_step_mon tc1 tc2\n  (STEP : sim_clos_step tc1 tc2) :\n  tc1 ⊆₁ tc2.","proof":"clear -STEP.\ninv STEP.\ndesf.\neapply isim_clos_step_mon; eauto.\n"},{"statement":"Lemma ICOHs: iord_coherent G sc stc.","proof":"subst stc.\napply sim_clos_iord_coherent; auto; apply CONS.\n"},{"statement":"Lemma ICOHs': iord_coherent G sc stc'.","proof":"subst stc'.\napply sim_clos_iord_coherent; auto; apply CONS.\n"},{"statement":"Lemma TCOHs: tls_coherent G stc.","proof":"subst stc.\napply sim_clos_tls_coherent; auto; apply CONS.\n"},{"statement":"Lemma TCOHs': tls_coherent G stc'.","proof":"subst stc'.\napply sim_clos_tls_coherent; auto; apply CONS.\n"},{"statement":"Lemma sim_clos_steps_cover_fence (FENCE: F e):\n    sim_clos_step＊ stc stc'.","proof":"rename e into f.\ngeneralize (set_equiv_refl2 stc),  (set_equiv_refl2 stc').\nunfold stc at 2, stc' at 2.\nunfold sim_clos, tc'.\nrewrite rmw_clos_dist, rel_clos_dist.\narewrite (rmw_clos (eq lbl) ≡₁ ∅).\n{\napply set_subset_empty_r.\nunfold rmw_clos, covered.\nsubst lbl.\nrewrite wf_rmwD; auto.\niord_dom_unfolder; try type_solver.\n}\nassert (rel_clos (eq lbl) ⊆₁ eq lbl) as REL_LBL.\n{\nunfold rel_clos, issued.\nsubst lbl.\niord_dom_unfolder.\n}\nintros STC STC'.\napply rt_step.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_sim_coherent; auto).\nexists [lbl].\nsimpl.\nrewrite COVER.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_iord_coherent; auto).\napply seq_eqv_l.\nsplit; [| rewrite STC, STC'; basic_solver].\neapply set_equiv_compl; [apply STC| ].\nrepeat (apply set_compl_union; split); try done.\n{\nunfold rmw_clos.\nsubst lbl.\napply set_disjoint_eq_r.\nrewrite wf_rmwD; auto.\niord_dom_unfolder.\ntype_solver.\n}\nunfold rel_clos.\nsubst lbl.\napply set_disjoint_eq_r.\nunfold issued.\nrewrite tlsc_I_in_W; eauto.\niord_dom_unfolder.\ntype_solver.\n"},{"statement":"Lemma sim_clos_steps_cover_write (WRITE: W e):\n    sim_clos_step＊ stc stc'.","proof":"rename e into w.\nremember (stc ∪₁ eq (mkTL ta_issue w)) as stc_w.\nassert (tc (mkTL ta_issue w)) as Iw.\n{\napply iord_coh_implies_iord_simpl_coh in ICOH'; auto.\nspecialize (@ICOH' (mkTL ta_issue w)).\nspecialize_full ICOH'.\n{\nexists (mkTL ta_cover w).\napply seq_eqv_r.\nsplit; [| red; basic_solver].\napply hahn_inclusion_exp with (r := RF G); [unfold iord_simpl; basic_solver 10| ].\nred.\napply seq_eqv_lr.\nsplits; try by vauto.\nred.\nsimpl.\napply seq_eqv_l; auto.\n}\ndo 2 red in ICOH'.\ndestruct ICOH'; try done.\nvauto.\n}\ngeneralize (set_equiv_refl2 stc),  (set_equiv_refl2 stc').\nunfold stc at 2, stc' at 2.\nunfold sim_clos, tc'.\nrewrite rmw_clos_dist, rel_clos_dist.\nassert (rmw_clos (eq lbl) ≡₁ ∅) as NOWRMW.\n{\nunfold rmw_clos.\nrewrite wf_rmwD; auto.\nsubst lbl.\napply set_subset_empty_r.\nunfold covered.\niord_dom_unfolder; type_solver 10.\n}\nrewrite NOWRMW, set_union_empty_r.\nassert (rel_clos (eq lbl) ⊆₁ eq lbl) as REL_CLOS.\n{\nunfold rel_clos.\nunfold issued.\nsubst lbl.\niord_dom_unfolder.\n}\nintros STC STC'.\nassert (stc' ≡₁ stc ∪₁ eq lbl) as STC'_ALT.\n{\nrewrite STC, STC'.\nsplit; [| basic_solver].\nrewrite REL_CLOS.\nbasic_solver.\n}\ndestruct (classic (set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))) as [NEWw | OLDw].\n2: {\nrewrite STC, STC'.\neapply set_equiv_rel_more; [reflexivity | | apply rt_refl].\nsplit; [| basic_solver].\nrewrite REL_CLOS.\nedestruct @set_disjoint_not_eq_r as [SD _].\nspecialize (SD OLDw).\napply set_subset_eq in SD.\nrewrite !SD.\nbasic_solver.\n}\napply rt_step.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_sim_coherent; auto).\nexists [lbl].\nsimpl.\nrewrite COVER.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_iord_coherent; auto).\napply seq_eqv_l.\nsplit; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r.\n"},{"statement":"Lemma sim_clos_steps_cover_read (READ: R e):\n    sim_clos_step＊ stc stc'.","proof":"generalize (set_equiv_refl2 stc),  (set_equiv_refl2 stc').\nunfold stc at 2, stc' at 2.\nunfold sim_clos, tc'.\nrename e into r.\nassert (set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) as NCLOS.\n{\napply set_disjoint_union_l.\nsplit.\n{\nunfold rmw_clos.\nrewrite set_pair_alt.\nrewrite wf_rmwD; auto.\nsubst lbl.\nunfolder.\nins.\nsubst.\ntype_solver.\n}\nunfold rel_clos.\nunfold issued.\niord_dom_unfolder.\nsubst lbl.\ninv IN'.\nforward eapply tlsc_I_in_W with (x := (ta_issue, a1)) (tc := tc); eauto.\nall: type_solver.\n}\nrewrite rmw_clos_dist, rel_clos_dist.\narewrite (rel_clos (eq lbl) ≡₁ ∅); [| rewrite set_union_empty_r].\n{\napply set_subset_empty_r.\nunfold rel_clos, issued.\niord_dom_unfolder.\n}\nunfold rmw_clos at 3.\nunfold lbl at 2.\nrename r into e.\nrewrite COVER, covered_single.\nrename e into r.\ndestruct (classic (dom_rel rmw r)) as [RMWr | NRMWr].\n2: {\narewrite (codom_rel (⦗eq r⦘ ⨾ rmw) ≡₁ ∅).\n{\ngeneralize NRMWr.\nbasic_solver.\n}\nrewrite set_pair_alt, set_map_empty,set_inter_empty_r, set_union_empty_r.\nintros STC STC'.\napply rt_step.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_sim_coherent).\nexists [mkTL ta_cover r].\nsimpl.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_iord_coherent).\napply seq_eqv_l.\nsplit; [| rewrite STC, STC'; basic_solver].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union.\nrewrite <- COVER.\nunfold mkTL.\nfold lbl.\nsplit; auto.\napply set_disjoint_eq_r; vauto.\n}\nforward eapply (functional_codom rmw r) as [w RMWD]; auto using wf_rmwf.\npose proof (proj2 RMWD) as RMW.\nred in RMW.\nspecialize (RMW w eq_refl).\nred in RMW.\ndesc.\napply seq_eqv_l in RMW as [<- RMW].\nrewrite RMWD.\nassert ((E \\₁ is_init) r) as ENIr.\n{\neapply same_relation_exp in RMW.\n2: {\nrewrite rmw_from_non_init, wf_rmwE; auto.\n}\ngeneralize RMW.\nbasic_solver.\n}\narewrite ((eq ta_cover ∪₁ eq ta_issue) <*> eq w ≡₁ eq (mkTL ta_issue w) ∪₁ eq (mkTL ta_cover w)).\n{\nrewrite set_pair_alt.\nsplit; try basic_solver 10.\niord_dom_unfolder; intuition.\n}\nassert (~ tc (mkTL ta_cover w)) as NCw.\n{\nintros COVw.\napply NEW.\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\napply ICOH.\neexists.\napply seq_eqv_r.\nsplit; eauto.\nred.\ndo 4 apply unionA.\nleft.\nred.\nsubst lbl.\napply seq_eqv_lr.\nsplits; try by vauto.\napply ct_step.\nleft.\napply rmw_in_sb; auto.\n}\nassert ((E \\₁ is_init) w /\\ W w) as (ENIw & Ww).\n{\neapply same_relation_exp in RMW.\n2: {\nrewrite wf_rmwD, wf_rmwE, rmw_non_init_lr; auto.\n}\nunfolder in RMW.\ndesc.\nsubst.\nvauto.\n}\nassert (set_disjoint (event ↓₁ eq w) (rmw_clos tc)) as DISJW.\n{\nintros [?a w_] [=<-] INTER.\nred in INTER.\nred in INTER.\ndesc.\nred in INTER0.\ndesc.\napply seq_eqv_l in INTER0.\ndesc.\nforward eapply (wf_rmw_invf WF w r x) as ->; eauto.\napply NEW.\nred in INTER0.\nunfolder in INTER0.\ndesc.\nsubst lbl.\ndestruct y; ins; vauto.\n}\nintros STC STC'.\nassert (stc' ≡₁ stc ∪₁ eq lbl ∪₁ (eq (mkTL ta_issue w) ∪₁ eq (mkTL ta_cover w))) as STC'_ALT.\n{\nrewrite STC, STC'.\nbasic_solver 10.\n}\nremember (stc ∪₁ eq lbl) as stc_r.\nassert (iord_coherent G sc stc_r) as ICOHsr.\n{\nrename r into e.\ngeneralize ICOHs, ICOHs', TCOHs, TCOHs'.\nins.\nrewrite STC'_ALT in *.\nsubst stc_r.\neapply iord_coh_intermediate; eauto.\nrewrite set_interC, <- dom_eqv1, id_union.\nunfold iord_simpl.\nrepeat case_union _ _.\nrepeat rewrite dom_union.\nsubst lbl.\nrewrite COVER.\nrepeat (apply set_subset_union_l; split).\nall: try by iord_dom_solver.\n2: {\ncdes CONS.\niord_dom_unfolder.\nedestruct sb_sc_acyclic with (x := b); eauto.\napply ct_unit.\nexists a1.\nsplit; auto.\nleft.\ninv d.\napply rmw_in_sb; auto.\n}\niord_dom_unfolder; [type_solver| ].\ncdes CONS.\napply imm_s_hb.coherence_sc_per_loc in Cint.\nred in Cint.\ndestruct (Cint a1).\nexists z.\ninv d.\nsplit.\n{\napply rmw_in_sb; auto.\n}\napply rf_in_eco; auto.\n}\nassert (tls_coherent G stc_r) as TCOHsr.\n{\nsubst stc_r.\napply tls_coherent_ext; auto using TCOHs.\nred.\nsubst lbl.\nleft.\nsplit; auto.\n}\nremember (stc_r ∪₁ eq (mkTL ta_issue w)) as stc_rw1.\nassert (iord_coherent G sc stc_rw1) as ICOHsrw1.\n{\nrename r into e.\ngeneralize ICOHs, ICOHs', TCOHs, TCOHs'.\nins.\nrewrite <- set_unionA in STC'_ALT.\nrewrite STC'_ALT in *.\nsubst stc_rw1.\neapply iord_coh_intermediate; eauto.\nrewrite set_interC, <- dom_eqv1.\nunfold iord_simpl.\nrepeat case_union _ _.\nrepeat rewrite dom_union.\nrepeat (apply set_subset_union_l; split).\nall: try by iord_dom_solver.\niord_dom_unfolder.\ninv d.\ninv d2.\napply fwbob_in_sb in d0.\nedestruct sb_irr; eauto.\n}\nassert (iiord_step (ta_cover, w) stc_rw1 stc') as ISTEP'.\n{\nrename r into e.\ndo 2 red.\nsplits; auto using ICOHs'.\napply seq_eqv_l.\nsplit.\n2: {\nsubst stc_rw1.\nrewrite STC'_ALT.\nbasic_solver.\n}\neapply set_equiv_compl; [rewrite Heqstc_rw1, Heqstc_r, STC; reflexivity| ].\nsubst lbl.\nrepeat (apply set_compl_union; split); try by vauto.\n{\napply set_disjoint_eq_l.\neapply set_disjoint_mori; [..| apply DISJW]; red; basic_solver.\n}\n{\nunfold rel_clos, issued.\nintros [RCcw].\nunfolder in H.\ndesc.\ndestruct y; ins.\nsubst.\napply NEW.\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\napply ICOH.\nexists (ta_issue, w).\napply seq_eqv_r.\nsplit; auto.\nred.\ndo 3 left.\nright.\nred.\napply seq_eqv_lr.\nsplits; try by vauto.\nred.\nsimpl.\napply seq_eqv_r.\nsplit; auto.\napply sb_to_w_rel_in_fwbob.\napply rmw_in_sb in RMW; basic_solver.\n}\nintros [=].\ntype_solver.\n}\ndestruct (classic (Rel w)) as [RELw | NRELw].\n{\nassert (~ tc (mkTL ta_issue w)) as NIw.\n{\nintros ISSw.\napply NEW.\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\napply ICOH.\neexists.\napply seq_eqv_r.\nsplit; eauto.\nred.\ndo 3 left.\nright.\nred.\nunfold lbl.\napply seq_eqv_lr.\nsplits; try by vauto.\nred.\nsimpl.\napply seq_eqv_r.\nsplit; auto.\napply sb_to_w_rel_in_fwbob.\napply seq_eqv_r.\nsplit; [| basic_solver].\napply rmw_in_sb; auto.\n}\napply rt_step.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_sim_coherent).\nexists [mkTL ta_cover r; mkTL ta_issue w; mkTL ta_cover w].\nsimpl.\nsplit; auto.\nexists stc_r.\nsplit.\n{\ndo 2 red.\nsplits; auto using ICOHs.\napply seq_eqv_l.\nsplit; [|basic_solver].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union.\nsplit; try by vauto.\nrewrite <- COVER.\nby apply set_disjoint_eq_r.\n}\nexists stc_rw1.\nsplit; auto.\ndo 2 red.\nsplits; auto.\napply seq_eqv_l.\nsplit.\n2: {\nsubst stc_rw1 stc_r.\nbasic_solver.\n}\neapply set_equiv_compl; [rewrite Heqstc_r, STC; reflexivity| ].\nsubst lbl.\nrepeat (apply set_compl_union; split); try by vauto.\n2: {\nby intros [?].\n}\napply set_disjoint_eq_l.\neapply set_disjoint_mori; [..| apply DISJW]; red; basic_solver.\n}\nremember (stc ∪₁ eq (mkTL ta_issue w)) as stc_w1.\nassert (sim_coherent stc_w1) as SCOHw1.\n{\nred.\nsubst stc_w1.\nrewrite sim_clos_dist; auto.\narewrite (sim_clos stc ≡₁ stc).\n{\nsymmetry.\nunfold stc at 2.\napply sim_clos_sim_coherent; auto.\n}\nunfold sim_clos.\nsplit; [basic_solver| ].\nrepeat (apply set_subset_union_l; split; try basic_solver).\n{\nunfold rmw_clos.\nunfold covered.\niord_dom_unfolder.\n}\nunfold rel_clos.\nunfold issued.\niord_dom_unfolder.\ninv d0.\n}\nassert (iord_coherent G sc stc_w1) as ICOHw1.\n{\nassert (stc_rw1 ≡₁ stc_w1 ∪₁ eq lbl) as STCrw1.\n{\nsubst stc_w1 stc_rw1 stc_r.\nbasic_solver.\n}\nrewrite STCrw1 in *.\nsubst stc_w1.\neapply iord_coh_intermediate; eauto using ICOHs, TCOHs.\n{\napply tls_coherent_ext; [| by vauto].\napply tls_coherent_ext; [by apply TCOHs | ].\nred.\nright.\nsplit; [by vauto| ].\nsplit; vauto.\n}\nrewrite set_interC, <- dom_eqv1.\nunfold iord_simpl.\nrepeat case_union _ _.\nrewrite !dom_union.\nsubst lbl a.\nrepeat (apply set_subset_union_l; split); try by iord_dom_solver.\nunfold FWBOB.\niord_dom_unfolder.\ninv d2.\nred in d0.\nunfold union in d0.\ndes.\nall: (apply seq_eqv_r in d0 || apply seq_eqv_l in d0); mode_solver.\n}\nenough (sim_clos_step^* stc stc_w1) as ISS_W_STEP.\n{\neapply rt_unit.\neexists.\nsplit; [by apply ISS_W_STEP| ].\ndo 2 red.\nsplits; eauto.\n2: {\nunfold stc'.\napply sim_clos_sim_coherent; auto.\n}\nexists [lbl; mkTL ta_cover w].\nsimpl.\nrewrite COVER.\nsplit; auto.\nexists stc_rw1.\nsplit; auto.\ndo 2 red.\nsplits; auto.\napply seq_eqv_l.\nsplit.\n2: {\nsubst stc_rw1 stc_w1 stc_r.\nbasic_solver.\n}\neapply set_equiv_compl.\n{\nsubst stc_w1.\nrewrite STC.\nreflexivity.\n}\nrepeat (apply set_compl_union; split); try by vauto.\nall: apply set_disjoint_eq_r; eapply set_disjoint_mori; [..| apply NCLOS];        red; basic_solver.\n}\ndestruct (classic (stc (mkTL ta_issue w))) as [Iw | NIw].\n{\nsubst.\nrewrite set_union_absorb_r; [apply reflexive_rt| basic_solver].\n}\napply rt_step.\ndo 2 red.\nsplits; auto.\n2: {\nunfold stc'.\napply sim_clos_sim_coherent; auto.\n}\nexists [mkTL ta_issue w].\nsimpl.\ndo 2 red.\nsplits; auto using ICOHs.\napply seq_eqv_l.\nsplit; subst; basic_solver.\n"},{"statement":"Lemma sim_clos_steps_cover:\n    sim_clos_step＊ stc stc'.","proof":"pose proof (lab_rwf lab e) as LABe.\ndes; auto using sim_clos_steps_cover_read,      sim_clos_steps_cover_write,      sim_clos_steps_cover_fence.\n"},{"statement":"Lemma sim_clos_steps_issue:\n    sim_clos_step＊ stc stc'.","proof":"rename e into w.\nassert (W w) as Ww.\n{\nreplace w with (event lbl); auto.\neapply (@tlsc_I_in_W _ tc'); eauto.\nsubst tc'.\nbasic_solver.\n}\nassert (~ tc (mkTL ta_cover w)) as NCw.\n{\nintros Cw.\nforward eapply (@tlsc_w_covered_issued tc) as WCI; eauto.\ndestruct NEW.\nspecialize (WCI (mkTL ta_cover w)).\nspecialize_full WCI.\n{\nbasic_solver.\n}\nunfolder in WCI.\ndesc.\nsubst lbl.\ndestruct y.\nins.\nvauto.\n}\nassert (rmw_clos (eq lbl) ≡₁ ∅) as NO_RMWC.\n{\napply set_subset_empty_r.\nunfold rmw_clos.\nrewrite set_pair_alt.\nerewrite wf_rmwD; eauto.\nsubst lbl.\nunfold covered.\ntype_solver.\n}\ngeneralize (set_equiv_refl2 stc),  (set_equiv_refl2 stc').\nunfold stc at 2, stc' at 2.\nunfold sim_clos, tc'.\nrewrite rmw_clos_dist, rel_clos_dist.\nrewrite NO_RMWC, set_union_empty_r.\nrewrite set_unionA with (s'' := _ ∪₁ _), set_unionC with (s := rmw_clos _).\nrewrite set_unionA with (s' := rel_clos _).\narewrite (rel_clos (eq lbl) ≡₁ (event ↓₁ Rel) ∩₁ eq (mkTL ta_cover w)).\n{\nunfold rel_clos, issued.\nrewrite set_pair_alt.\nred.\nsubst lbl.\nsplit; unfolder; ins; desc; destruct x; ins.\n{\nsubst.\nvauto.\n}\ninv H0.\nsplits; vauto.\n}\ndestruct (classic (codom_rel (⦗covered tc⦘ ⨾ rmw) w)) as [CRMWw | NCRMWw].\n{\napply set_subset_single_l in CRMWw.\nrewrite set_union_absorb_l with (s := _ ∩₁ _).\n2: {\nunfold rel_clos, rmw_clos, issued.\nrewrite !set_pair_alt.\nrewrite <- CRMWw.\nbasic_solver.\n}\nrewrite set_unionA with (s' := eq _).\nrewrite set_union_absorb_l with (s := eq _).\n2: {\napply set_subset_union_r.\nright.\nunfold rmw_clos.\nrewrite set_pair_alt.\nrewrite <- CRMWw.\nbasic_solver.\n}\nintros -> ->.\nrewrite set_unionC with (s := rel_clos _), <- set_unionA.\napply rt_refl.\n}\nintros STC STC'.\nassert (set_compl stc lbl) as LBL_NEW.\n{\neapply set_equiv_compl; [apply STC| ].\nsubst lbl.\nrepeat (apply set_compl_union; split); try basic_solver.\n{\nintros RMWC.\neapply set_subset_empty_r; [apply NO_RMWC| ]; basic_solver.\n}\nunfold rel_clos, issued, set_pair.\nred.\nrewrite ISSUE.\nintuition discriminate.\nUnshelve.\neconstructor; vauto.\n}\ndestruct (classic (Rel w)) as [RELw | NRELw].\n2: {\nerewrite (proj1 (set_disjointE _ _)), set_union_empty_l in STC'; [|basic_solver].\napply rt_step.\nred.\nred.\nsplits.\n2, 3: subst stc stc'; by apply sim_clos_sim_coherent.\nexists [lbl].\nsimpl.\nrewrite ISSUE.\ndo 2 red.\nsplits.\n2, 3: by apply sim_clos_iord_coherent; auto; apply CONS.\napply seq_eqv_l.\nsplit; auto.\nrewrite STC, STC'.\nbasic_solver.\n}\nrewrite set_inter_absorb_l in STC'; [| basic_solver].\napply rt_step.\ndo 2 red.\nsplits; try by subst stc stc'; apply sim_clos_sim_coherent.\nexists [mkTL ta_issue w; mkTL ta_cover w].\nsimpl.\nsplit; [by vauto| ].\nexists (stc ∪₁ eq (mkTL ta_issue w)).\nassert (stc' ≡₁ stc ∪₁ eq (mkTL ta_issue w) ∪₁ eq (mkTL ta_cover w)) as STC'_ALT.\n{\nrewrite STC, STC'.\nbasic_solver 10.\n}\nforward eapply iord_coh_intermediate with (tc := stc) as ICOHs_; eauto using TCOHs, ICOHs.\n1, 2: rewrite <- STC'_ALT; rename w into e; auto using TCOHs', ICOHs'.\n{\nrewrite set_interC, <- dom_eqv1.\nunfold iord_simpl.\nrepeat case_union _ _.\nrewrite !dom_union.\nrepeat (apply set_subset_union_l; split); try by iord_dom_solver.\niord_dom_unfolder.\ninv d.\ninv d2.\nedestruct sb_irr.\neapply fwbob_in_sb; eauto.\n}\nunfold iiord_step.\nsplit; red; splits; auto.\nall: try by subst stc stc'; apply sim_clos_iord_coherent; auto; apply CONS.\n{\napply seq_eqv_l.\nsplit; basic_solver.\n}\napply seq_eqv_l.\nsplit.\n2: {\nrewrite STC, STC'.\nbasic_solver 10.\n}\napply set_compl_union.\nsplit; vauto.\nintros STC_LBL'.\napply LBL_NEW.\nforward eapply tlsc_w_covered_issued with (x := (ta_cover, w))(tc := stc).\n1, 2: subst stc; eauto using sim_clos_iord_coherent, sim_clos_tls_coherent.\n{\nbasic_solver.\n}\nunfolder.\nins.\ndesc.\ndestruct y; ins; vauto.\n"},{"statement":"Lemma iord_step_implies_sim_clos_step WF CONS:\n  restr_rel (tls_coherent G) iord_step ⊆ sim_clos ↓ sim_clos_step^*.","proof":"unfolder; intros tc tc' (STEP & TCOH & TCOH').\nred in STEP.\ndestruct STEP as [[a e] STEP].\nremember STEP as AA.\nclear HeqAA.\ndo 2 red in AA.\ndestruct AA as [AA [ICOHT ICOHT']].\napply seq_eqv_l in AA.\ndestruct AA as [COMPL AA].\nrewrite AA in *.\nclear dependent tc'.\nassert (iord_coherent G sc (sim_clos tc)) as SIMCOH.\n{\napply sim_clos_iord_coherent; auto.\n}\nassert (sim_coherent (sim_clos tc)) as SIMSIM.\n{\napply sim_clos_sim_coherent; auto.\n}\ndestruct a.\n{\nnow apply sim_clos_steps_cover.\n}\n{\nnow apply sim_clos_steps_issue.\n}\n{\napply rt_step.\ndo 2 red.\nsplits; auto.\n2: now apply sim_clos_sim_coherent.\nexists [(ta_propagate tid, e)].\ndo 3 red.\nsplits; auto.\n2: now apply sim_clos_iord_coherent.\napply seq_eqv_l.\nsplits.\n{\nunfold sim_clos.\nrepeat (apply set_compl_union; split); auto.\nall: unfold rel_clos, rmw_clos, set_pair, covered, issued.\nall: clear; intros AA; desf; unfolder in AA; desf.\n}\nrewrite sim_clos_union.\napply set_union_more; auto.\nunfold sim_clos.\nsplit; eauto with hahn.\nunfold rel_clos, rmw_clos, set_pair, covered, issued.\nclear.\nunfolder; ins; do 2 desf.\n}\napply rt_step.\ndo 2 red.\nsplits; auto.\n2: now apply sim_clos_sim_coherent.\nexists [(ta_reserve, e)].\ndo 3 red.\nsplits; auto.\n2: now apply sim_clos_iord_coherent.\napply seq_eqv_l.\nsplits.\n{\nunfold sim_clos.\nrepeat (apply set_compl_union; split); auto.\nall: unfold rel_clos, rmw_clos, set_pair, covered, issued.\nall: clear; intros AA; desf; unfolder in AA; desf.\n}\nrewrite sim_clos_union.\napply set_union_more; auto.\nunfold sim_clos.\nsplit; eauto with hahn.\nunfold rel_clos, rmw_clos, set_pair, covered, issued.\nclear.\nunfolder; ins; do 2 desf.\n"},{"statement":"Lemma sim_clos_cover_no_dom_rmw WF r tc\n  (NCOV : ~ covered tc r)\n  (TCOH  : tls_coherent G tc)\n  (ICOH  : iord_coherent G sc tc)\n  (SCOH1 : sim_coherent tc)\n  (SCOH2 : sim_coherent (tc ∪₁ eq (ta_cover, r))) :\n  ~ dom_rel rmw r.","proof":"intros [w RMW].\nassert (~ covered tc w) as WNCOV.\n{\nintros AA.\napply NCOV.\neapply dom_sb_covered; eauto.\napply (rmw_in_sb WF) in RMW.\nclear -RMW AA.\nbasic_solver 10.\n}\nred in SCOH1.\nred in SCOH2.\nrewrite sim_clos_union in SCOH2.\nrewrite <- SCOH1 in SCOH2.\nunfold sim_clos in SCOH2.\nassert (rmw_clos (eq (ta_cover, r)) ⊆₁ tc ∪₁ eq (ta_cover, r)) as RMWC.\n{\nrewrite SCOH2.\neauto 10 with hahn.\n}\nunfold rmw_clos in RMWC.\nrewrite covered_single in RMWC.\nspecialize (RMWC (ta_cover, w)).\ndestruct RMWC as [AA|AA].\n{\nred.\nsplit.\nall: clear -RMW; basic_solver 10.\n}\n{\napply WNCOV.\nred.\nclear -AA.\nbasic_solver 10.\n}\ninv AA.\napply (wf_rmwD WF) in RMW.\ngeneralize RMW.\nclear.\ntype_solver.\n"},{"statement":"Lemma sim_clos_cover_no_codom_rmw WF w tc tc'\n  (NCOV : ~ covered tc w)\n  (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w)\n  (TCOH  : tls_coherent G tc')\n  (ICOH  : iord_coherent G sc tc)\n  (ICOH2 : iord_coherent G sc tc')\n  (SCOH1 : sim_coherent tc) :\n  ~ codom_rel rmw w.","proof":"intros [r RMW].\nassert (covered tc' r) as AA.\n{\neapply dom_sb_covered; eauto.\napply (rmw_in_sb WF) in RMW.\nexists w.\napply seq_eqv_r.\nsplit; auto.\napply COVEQ.\nnow right.\n}\napply COVEQ in AA.\nenough (~ covered tc r) as RNCOV.\n{\ndestruct AA as [AA|AA]; auto; desf.\napply (wf_rmwD WF) in RMW.\ngeneralize RMW.\nclear.\ntype_solver.\n}\nclear AA.\nintros RCOV.\nenough (covered (sim_clos tc) w) as AA.\n{\nred in SCOH1.\ngeneralize SCOH1 AA NCOV.\nunfold covered.\nclear.\nbasic_solver 10.\n}\nred.\nred.\neexists (_, _); ins.\nsplits; eauto.\nred.\nsplits.\n2: {\nclear.\nbasic_solver.\n}\nenough (rmw_clos tc (ta_cover, w)) as AA.\n{\nred.\nclear -AA.\nbasic_solver 10.\n}\nred.\nsplit.\n{\nclear.\nbasic_solver.\n}\nclear -RCOV RMW.\nbasic_solver 10.\n"},{"statement":"Lemma sim_clos_cover_no_rel w tc tc'\n  (WW    : W w)\n  (NCOV : ~ covered tc w)\n  (COVS : covered tc ∪₁ eq w ⊆₁ covered tc')\n  (ISSS : issued tc ≡₁ issued tc')\n  (TCOH  : tls_coherent G tc')\n  (SCOH1 : sim_coherent tc)\n  (ICOH2 : iord_coherent G sc tc')\n  (SCOH2 : sim_coherent tc') :\n  ~ Rel w.","proof":"intros REL.\nassert (issued tc' w) as ISSN.\n{\neapply w_covered_issued; eauto.\nsplit; auto.\napply COVS.\nclear.\nbasic_solver.\n}\nassert (issued tc w) as ISS by now apply ISSS.\napply NCOV.\nassert (covered (sim_clos tc) w) as HH.\n{\nunfold sim_clos.\napply covered_union.\nright.\nunfold rel_clos.\nred.\nunfolder.\neexists (_, _); ins.\n}\ngeneralize SCOH1 HH.\nunfold covered, sim_coherent.\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma iiord_fixed_reserve_step_minus_reserved\n  tl tc1 tc2 s\n  (NORES : action tl <> ta_reserve)\n  (SRES  : s ⊆₁ action ↓₁ (eq ta_reserve))\n  (STEP  : iiord_step tl tc1 tc2) :\n  iiord_step tl ((tc1 \\₁ action ↓₁ (eq ta_reserve)) ∪₁ s)\n                ((tc2 \\₁ action ↓₁ (eq ta_reserve)) ∪₁ s).","proof":"destruct tl as [ta a].\ndestruct ta.\n4: {\nexfalso.\napply NORES.\ndesf.\n}\nall: destruct STEP as [STEP [AA BB]].\nall: split; splits.\nall: try now eapply iord_coherent_equiv_wo_reserved; [|apply AA]; split; [|rewrite SRES]; basic_solver.\nall: try now eapply iord_coherent_equiv_wo_reserved; [|apply BB]; split; [|rewrite SRES]; basic_solver.\nall: apply seq_eqv_l in STEP; destruct STEP as [TT STEP].\nall: apply seq_eqv_l; split.\nall: try now intros [HH|HH]; [|now apply SRES in HH; inv HH]; apply TT; apply HH.\nall: rewrite STEP.\nall: split; unfolder; ins; desf; ins; splits; auto.\n"},{"statement":"Lemma iiord_no_reserve_step_minus_reserved\n  tl tc1 tc2\n  (NORES : action tl <> ta_reserve)\n  (STEP  : iiord_step tl tc1 tc2) :\n  iiord_step tl (tc1 \\₁ action ↓₁ (eq ta_reserve))\n                (tc2 \\₁ action ↓₁ (eq ta_reserve)).","proof":"apply iiord_fixed_reserve_step_minus_reserved with (s:=fun _ => False) in STEP; auto.\n2: basic_solver.\neapply iiord_step_more; [..| eauto]; auto.\nall: basic_solver.\n"},{"statement":"Lemma iiord_step_fixed_reserved s tl tc1 tc2\n  (SRES : s ⊆₁ action ↓₁ (eq ta_reserve))\n  (STEP : iiord_step tl tc1 tc2) :\n  (iiord_step tl)^? ((tc1 \\₁ action ↓₁ (eq ta_reserve)) ∪₁ s)\n                    ((tc2 \\₁ action ↓₁ (eq ta_reserve)) ∪₁ s).","proof":"destruct tl as [ta a].\ndestruct ta.\n4: {\nleft.\napply set_extensionality.\nerewrite iiord_step_incl with (tc1:=tc1) (tc2:=tc2); eauto.\nrewrite set_minus_union_l.\nsplit; [basic_solver|].\nunionL; clear; basic_solver.\n}\nall: right.\nall: apply iiord_fixed_reserve_step_minus_reserved; auto.\nall: intros HH; inv HH.\n"},{"statement":"Lemma iiord_step_minus_reserved tl tc1 tc2\n  (STEP : iiord_step tl tc1 tc2) :\n  (iiord_step tl)^? (tc1 \\₁ action ↓₁ (eq ta_reserve))\n                    (tc2 \\₁ action ↓₁ (eq ta_reserve)).","proof":"clear -STEP.\ndestruct tl as [ta a].\ndestruct ta.\n4: {\nleft.\napply set_extensionality.\nerewrite iiord_step_incl with (tc1:=tc1) (tc2:=tc2); eauto.\nrewrite set_minus_union_l.\nsplit; [basic_solver|].\nunionL; clear; basic_solver.\n}\nall: right.\nall: apply iiord_no_reserve_step_minus_reserved; auto.\nall: intros HH; inv HH.\n"},{"statement":"Lemma isim_clos_step_fixed_reserve s tl tc1 tc2\n  (SRES : s ⊆₁ action ↓₁ (eq ta_reserve))\n  (STEP : isim_clos_step tl tc1 tc2) :\n  (isim_clos_step tl)^? ((tc1 \\₁ action ↓₁ (eq ta_reserve)) ∪₁ s)\n                        ((tc2 \\₁ action ↓₁ (eq ta_reserve)) ∪₁ s).","proof":"unfold isim_clos_step in *.\ndesf.\nall: try now (apply iiord_step_fixed_reserved; auto).\nall: right.\nall: destruct STEP as [AA [y [STEP0 STEP1]]].\nall: split; auto.\nall: eexists; split.\nall: try now eapply iiord_fixed_reserve_step_minus_reserved; eauto.\ndestruct STEP1 as [z [STEP1 STEP2]].\neexists; split.\nall: try now eapply iiord_fixed_reserve_step_minus_reserved; eauto.\n"},{"statement":"Lemma isim_clos_step_minus_reserved tl tc1 tc2\n  (STEP : isim_clos_step tl tc1 tc2) :\n  (isim_clos_step tl)^? (tc1 \\₁ action ↓₁ (eq ta_reserve))\n                        (tc2 \\₁ action ↓₁ (eq ta_reserve)).","proof":"clear -STEP.\nunfold isim_clos_step in *.\ndesf.\nall: try now (apply iiord_step_minus_reserved; auto).\nall: right.\nall: destruct STEP as [AA [y [STEP0 STEP1]]].\nall: split; auto.\nall: eexists; split.\nall: try now eapply iiord_no_reserve_step_minus_reserved; eauto.\ndestruct STEP1 as [z [STEP1 STEP2]].\neexists; split.\nall: try now eapply iiord_no_reserve_step_minus_reserved; eauto.\n"}]