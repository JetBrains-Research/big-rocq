{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/simulation/PlainStepBasic.v","fileSamples":[{"statement":"(thread : Ident.t) (x y : Configuration.t) (STEP : plain_step MachineEvent.silent thread x y) (tt : {lang : language & Language.state lang} * Local.t) : IdentMap.add thread tt (Configuration.threads y) =\nIdentMap.add thread tt (Configuration.threads x).","proofString":"inv STEP; simpls.\nby rewrite IdentMap.add_add_eq."},{"statement":"(thread : Ident.t) (x : Configuration.t) (lang : language) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (STEP : plain_step MachineEvent.silent thread x\n  {|\n    Configuration.threads :=\n      IdentMap.add thread\n        (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n        (Configuration.threads x);\n    Configuration.sc := sc3;\n    Configuration.memory := memory3\n  |}) (tt : {lang0 : language & Language.state lang0} * Local.t) (pf : bool) (e : ThreadEvent.t) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (TID : IdentMap.find thread (Configuration.threads x) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc x;\n    Thread.memory := Configuration.memory x\n  |} e2) (STEP0 : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (H0 : ThreadEvent.get_machine_event e = MachineEvent.silent) : IdentMap.add thread tt\n  (IdentMap.add thread\n     (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n     (Configuration.threads x)) =\nIdentMap.add thread tt (Configuration.threads x).","proofString":"by rewrite IdentMap.add_add_eq."},{"statement":"(thread : Ident.t) (x y : Configuration.t) (H : plain_step MachineEvent.silent thread x y) : forall tt : {lang : language & Language.state lang} * Local.t,\nIdentMap.add thread tt (Configuration.threads y) =\nIdentMap.add thread tt (Configuration.threads x).","proofString":"by apply same_thread_modify_for_step."},{"statement":"(thread : Ident.t) (x y z : Configuration.t) (STEP1 : (plain_step MachineEvent.silent thread)＊ x y) (STEP2 : (plain_step MachineEvent.silent thread)＊ y z) (IHSTEP1 : forall tt : {lang : language & Language.state lang} * Local.t,\nIdentMap.add thread tt (Configuration.threads y) =\nIdentMap.add thread tt (Configuration.threads x)) (IHSTEP2 : forall tt : {lang : language & Language.state lang} * Local.t,\nIdentMap.add thread tt (Configuration.threads z) =\nIdentMap.add thread tt (Configuration.threads y)) : forall tt : {lang : language & Language.state lang} * Local.t,\nIdentMap.add thread tt (Configuration.threads z) =\nIdentMap.add thread tt (Configuration.threads x).","proofString":"ins.\nby rewrite IHSTEP2."},{"statement":"(thread : Ident.t) (x y z : Configuration.t) (STEP1 : (plain_step MachineEvent.silent thread)＊ x y) (STEP2 : (plain_step MachineEvent.silent thread)＊ y z) (IHSTEP1 : forall tt0 : {lang : language & Language.state lang} * Local.t,\nIdentMap.add thread tt0 (Configuration.threads y) =\nIdentMap.add thread tt0 (Configuration.threads x)) (IHSTEP2 : forall tt0 : {lang : language & Language.state lang} * Local.t,\nIdentMap.add thread tt0 (Configuration.threads z) =\nIdentMap.add thread tt0 (Configuration.threads y)) (tt : {lang : language & Language.state lang} * Local.t) : IdentMap.add thread tt (Configuration.threads z) =\nIdentMap.add thread tt (Configuration.threads x).","proofString":"by rewrite IHSTEP2."},{"statement":"(thread : Ident.t) : transitive (plain_step MachineEvent.silent thread).","proofString":"apply transitiveI.\napply plain_step_seq_plain_step_in_plain_step."},{"statement":"(thread : Ident.t) : plain_step MachineEvent.silent thread ⨾ plain_step MachineEvent.silent thread\n⊆ plain_step MachineEvent.silent thread.","proofString":"apply plain_step_seq_plain_step_in_plain_step."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (thread' : Ident.t) (TNEQ : thread' <> tid) (langst : {lang0 : language & Language.state lang0}) (local : Local.t) : IdentMap.find thread' (Configuration.threads c1) = Some (langst, local) <->\nIdentMap.find thread'\n  (Configuration.threads\n     {|\n       Configuration.threads :=\n         IdentMap.add tid\n           (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n           (Configuration.threads c1);\n       Configuration.sc := sc3;\n       Configuration.memory := memory3\n     |}) = Some (langst, local).","proofString":"simpls.\nrewrite IdentMap.gso; tauto."},{"statement":"(pf : bool) (e : ThreadEvent.t) (tid : IdentMap.key) (c1 : Configuration.t) (lang : language) (st1 : Language.state lang) (lc1 : Local.t) (e2 : Thread.t lang) (st3 : Language.state lang) (lc3 : Local.t) (sc3 : TimeMap.t) (memory3 : Memory.t) (TID : IdentMap.find tid (Configuration.threads c1) =\nSome (existT (fun lang0 : language => Language.state lang0) lang st1, lc1)) (STEPS : rtc (Thread.tau_step (lang:=lang))\n  {|\n    Thread.state := st1;\n    Thread.local := lc1;\n    Thread.sc := Configuration.sc c1;\n    Thread.memory := Configuration.memory c1\n  |} e2) (STEP : Thread.step pf e e2\n  {|\n    Thread.state := st3;\n    Thread.local := lc3;\n    Thread.sc := sc3;\n    Thread.memory := memory3\n  |}) (EVENT : e <> ThreadEvent.failure) (thread' : Ident.t) (TNEQ : thread' <> tid) (langst : {lang0 : language & Language.state lang0}) (local : Local.t) : IdentMap.find thread' (Configuration.threads c1) = Some (langst, local) <->\nIdentMap.find thread'\n  (IdentMap.add tid\n     (existT (Language.state (E:=ProgramEvent.t)) lang st3, lc3)\n     (Configuration.threads c1)) = Some (langst, local).","proofString":"rewrite IdentMap.gso; tauto."},{"statement":"(thread : Ident.t) (label : MachineEvent.t) (x y : Configuration.t) (H : plain_step label thread x y) (thread' : Ident.t) (TNEQ : thread' <> thread) (langst : {lang : language & Language.state lang}) (local : Local.t) : IdentMap.find thread' (Configuration.threads x) = Some (langst, local) <->\nIdentMap.find thread' (Configuration.threads y) = Some (langst, local).","proofString":"eapply same_other_threads_step; eauto."},{"statement":"(thread : Ident.t) (label : MachineEvent.t) (x y z : Configuration.t) (PCSTEPS1 : tc (plain_step label thread) x y) (PCSTEPS2 : tc (plain_step label thread) y z) (thread' : Ident.t) (TNEQ : thread' <> thread) (langst : {lang : language & Language.state lang}) (local : Local.t) (IHPCSTEPS1 : IdentMap.find thread' (Configuration.threads x) = Some (langst, local) <->\nIdentMap.find thread' (Configuration.threads y) = Some (langst, local)) (IHPCSTEPS2 : IdentMap.find thread' (Configuration.threads y) = Some (langst, local) <->\nIdentMap.find thread' (Configuration.threads z) = Some (langst, local)) : IdentMap.find thread' (Configuration.threads x) = Some (langst, local) <->\nIdentMap.find thread' (Configuration.threads z) = Some (langst, local).","proofString":"etransitivity; eauto."},{"statement":"(thread : positive) (PC PC' : Configuration.t) (T T' : trav_label -> Prop) (label : MachineEvent.t) (f_to f_from : actid -> Time.t) (COVE : covered T' ⊆₁ E) (ISSE : issued T' ⊆₁ E) (COVIN : covered T ⊆₁ covered T') (ISSIN : issued T ⊆₁ issued T') (SIN : reserved T ⊆₁ reserved T') (NINCOV : covered T' \\₁ covered T ⊆₁ Tid_ thread) (NINISS : issued T' \\₁ issued T ⊆₁ Tid_ thread) (NINS : reserved T' \\₁ reserved T ⊆₁ Tid_ thread) (SOT : forall thread' : positive,\nthread' <> thread ->\nforall (langst : {lang : language & Language.state lang}) (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) <->\nIdentMap.find thread' (Configuration.threads PC') = Some (langst, local)) (PCSTEP : tc (plain_step label thread) PC PC') (CLOSED_PRES : closedness_preserved (Configuration.memory PC) (Configuration.memory PC')) (MSG_PRES : msg_preserved (Configuration.memory PC) (Configuration.memory PC')) (TPEQ : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) <->\nIdentMap.In thread0 (Configuration.threads PC')) (SIMREL_THREAD : simrel_thread G sc PC' T' f_to f_from thread sim_normal) (SIMREL : simrel G sc PC T f_to f_from) : simrel_common G sc PC' T' f_to f_from sim_normal.","proofString":"apply SIMREL_THREAD."},{"statement":"(thread : positive) (PC PC' : Configuration.t) (T T' : trav_label -> Prop) (label : MachineEvent.t) (f_to f_from : actid -> Time.t) (COVE : covered T' ⊆₁ E) (ISSE : issued T' ⊆₁ E) (COVIN : covered T ⊆₁ covered T') (ISSIN : issued T ⊆₁ issued T') (SIN : reserved T ⊆₁ reserved T') (NINCOV : covered T' \\₁ covered T ⊆₁ Tid_ thread) (NINISS : issued T' \\₁ issued T ⊆₁ Tid_ thread) (NINS : reserved T' \\₁ reserved T ⊆₁ Tid_ thread) (SOT : forall thread' : positive,\nthread' <> thread ->\nforall (langst : {lang : language & Language.state lang}) (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) <->\nIdentMap.find thread' (Configuration.threads PC') = Some (langst, local)) (PCSTEP : tc (plain_step label thread) PC PC') (CLOSED_PRES : closedness_preserved (Configuration.memory PC) (Configuration.memory PC')) (MSG_PRES : msg_preserved (Configuration.memory PC) (Configuration.memory PC')) (TPEQ : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) <->\nIdentMap.In thread0 (Configuration.threads PC')) (SIMREL_THREAD : simrel_thread G sc PC' T' f_to f_from thread sim_normal) (SIMREL : simrel G sc PC T f_to f_from) : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC') ->\nsimrel_thread_local G sc PC' T' f_to f_from thread0 sim_normal.","proofString":"cdes SIMREL.\nintros thread' TP'.\ndestruct (Ident.eq_dec thread thread') as [|NEQ]; subst.\napply SIMREL_THREAD.\nassert (simrel_thread_local G sc PC T f_to f_from thread' sim_normal) as AA.\napply SIMREL.\nby apply TPEQ.\ncdes AA.\neapply simrel_thread_local_step; eauto.\ncdes COMMON.\nauto.\ncdes COMMON.\nauto.\nvauto.\nins.\nedestruct SIM_RES_MEM with (b:=b) as [_ HH]; eauto.\nby apply HH."},{"statement":"(thread : positive) (PC PC' : Configuration.t) (T T' : trav_label -> Prop) (label : MachineEvent.t) (f_to f_from : actid -> Time.t) (COVE : covered T' ⊆₁ E) (ISSE : issued T' ⊆₁ E) (COVIN : covered T ⊆₁ covered T') (ISSIN : issued T ⊆₁ issued T') (SIN : reserved T ⊆₁ reserved T') (NINCOV : covered T' \\₁ covered T ⊆₁ Tid_ thread) (NINISS : issued T' \\₁ issued T ⊆₁ Tid_ thread) (NINS : reserved T' \\₁ reserved T ⊆₁ Tid_ thread) (SOT : forall thread' : positive,\nthread' <> thread ->\nforall (langst : {lang : language & Language.state lang}) (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) <->\nIdentMap.find thread' (Configuration.threads PC') = Some (langst, local)) (PCSTEP : tc (plain_step label thread) PC PC') (CLOSED_PRES : closedness_preserved (Configuration.memory PC) (Configuration.memory PC')) (MSG_PRES : msg_preserved (Configuration.memory PC) (Configuration.memory PC')) (TPEQ : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) <->\nIdentMap.In thread0 (Configuration.threads PC')) (SIMREL_THREAD : simrel_thread G sc PC' T' f_to f_from thread sim_normal) (SIMREL : simrel G sc PC T f_to f_from) (COMMON : simrel_common G sc PC T f_to f_from sim_normal) (THREADS : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) ->\nsimrel_thread_local G sc PC T f_to f_from thread0 sim_normal) : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC') ->\nsimrel_thread_local G sc PC' T' f_to f_from thread0 sim_normal.","proofString":"intros thread' TP'.\ndestruct (Ident.eq_dec thread thread') as [|NEQ]; subst.\napply SIMREL_THREAD.\nassert (simrel_thread_local G sc PC T f_to f_from thread' sim_normal) as AA.\napply SIMREL.\nby apply TPEQ.\ncdes AA.\neapply simrel_thread_local_step; eauto.\ncdes COMMON.\nauto.\ncdes COMMON.\nauto.\nvauto.\nins.\nedestruct SIM_RES_MEM with (b:=b) as [_ HH]; eauto.\nby apply HH."},{"statement":"(thread : positive) (PC PC' : Configuration.t) (T T' : trav_label -> Prop) (label : MachineEvent.t) (f_to f_from : actid -> Time.t) (COVE : covered T' ⊆₁ E) (ISSE : issued T' ⊆₁ E) (COVIN : covered T ⊆₁ covered T') (ISSIN : issued T ⊆₁ issued T') (SIN : reserved T ⊆₁ reserved T') (NINCOV : covered T' \\₁ covered T ⊆₁ Tid_ thread) (NINISS : issued T' \\₁ issued T ⊆₁ Tid_ thread) (NINS : reserved T' \\₁ reserved T ⊆₁ Tid_ thread) (SOT : forall thread'0 : positive,\nthread'0 <> thread ->\nforall (langst : {lang : language & Language.state lang}) (local : Local.t),\nIdentMap.find thread'0 (Configuration.threads PC) = Some (langst, local) <->\nIdentMap.find thread'0 (Configuration.threads PC') = Some (langst, local)) (PCSTEP : tc (plain_step label thread) PC PC') (CLOSED_PRES : closedness_preserved (Configuration.memory PC) (Configuration.memory PC')) (MSG_PRES : msg_preserved (Configuration.memory PC) (Configuration.memory PC')) (TPEQ : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) <->\nIdentMap.In thread0 (Configuration.threads PC')) (SIMREL_THREAD : simrel_thread G sc PC' T' f_to f_from thread sim_normal) (SIMREL : simrel G sc PC T f_to f_from) (COMMON : simrel_common G sc PC T f_to f_from sim_normal) (THREADS : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) ->\nsimrel_thread_local G sc PC T f_to f_from thread0 sim_normal) (thread' : IdentMap.key) (TP' : IdentMap.In thread' (Configuration.threads PC')) : simrel_thread_local G sc PC' T' f_to f_from thread' sim_normal.","proofString":"destruct (Ident.eq_dec thread thread') as [|NEQ]; subst.\napply SIMREL_THREAD.\nassert (simrel_thread_local G sc PC T f_to f_from thread' sim_normal) as AA.\napply SIMREL.\nby apply TPEQ.\ncdes AA.\neapply simrel_thread_local_step; eauto.\ncdes COMMON.\nauto.\ncdes COMMON.\nauto.\nvauto.\nins.\nedestruct SIM_RES_MEM with (b:=b) as [_ HH]; eauto.\nby apply HH."},{"statement":"(PC PC' : Configuration.t) (T T' : trav_label -> Prop) (label : MachineEvent.t) (f_to f_from : actid -> Time.t) (COVE : covered T' ⊆₁ E) (ISSE : issued T' ⊆₁ E) (COVIN : covered T ⊆₁ covered T') (ISSIN : issued T ⊆₁ issued T') (SIN : reserved T ⊆₁ reserved T') (thread' : IdentMap.key) (PCSTEP : tc (plain_step label thread') PC PC') (SOT : forall thread'0 : positive,\nthread'0 <> thread' ->\nforall (langst : {lang : language & Language.state lang}) (local : Local.t),\nIdentMap.find thread'0 (Configuration.threads PC) = Some (langst, local) <->\nIdentMap.find thread'0 (Configuration.threads PC') = Some (langst, local)) (NINS : reserved T' \\₁ reserved T ⊆₁ Tid_ thread') (NINISS : issued T' \\₁ issued T ⊆₁ Tid_ thread') (NINCOV : covered T' \\₁ covered T ⊆₁ Tid_ thread') (CLOSED_PRES : closedness_preserved (Configuration.memory PC) (Configuration.memory PC')) (MSG_PRES : msg_preserved (Configuration.memory PC) (Configuration.memory PC')) (TPEQ : forall thread : IdentMap.key,\nIdentMap.In thread (Configuration.threads PC) <->\nIdentMap.In thread (Configuration.threads PC')) (SIMREL_THREAD : simrel_thread G sc PC' T' f_to f_from thread' sim_normal) (SIMREL : simrel G sc PC T f_to f_from) (COMMON : simrel_common G sc PC T f_to f_from sim_normal) (THREADS : forall thread : IdentMap.key,\nIdentMap.In thread (Configuration.threads PC) ->\nsimrel_thread_local G sc PC T f_to f_from thread sim_normal) (TP' : IdentMap.In thread' (Configuration.threads PC')) : simrel_thread_local G sc PC' T' f_to f_from thread' sim_normal.","proofString":"apply SIMREL_THREAD."},{"statement":"(thread : positive) (PC PC' : Configuration.t) (T T' : trav_label -> Prop) (label : MachineEvent.t) (f_to f_from : actid -> Time.t) (COVE : covered T' ⊆₁ E) (ISSE : issued T' ⊆₁ E) (COVIN : covered T ⊆₁ covered T') (ISSIN : issued T ⊆₁ issued T') (SIN : reserved T ⊆₁ reserved T') (NINCOV : covered T' \\₁ covered T ⊆₁ Tid_ thread) (NINISS : issued T' \\₁ issued T ⊆₁ Tid_ thread) (NINS : reserved T' \\₁ reserved T ⊆₁ Tid_ thread) (SOT : forall thread'0 : positive,\nthread'0 <> thread ->\nforall (langst : {lang : language & Language.state lang}) (local : Local.t),\nIdentMap.find thread'0 (Configuration.threads PC) = Some (langst, local) <->\nIdentMap.find thread'0 (Configuration.threads PC') = Some (langst, local)) (PCSTEP : tc (plain_step label thread) PC PC') (CLOSED_PRES : closedness_preserved (Configuration.memory PC) (Configuration.memory PC')) (MSG_PRES : msg_preserved (Configuration.memory PC) (Configuration.memory PC')) (TPEQ : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) <->\nIdentMap.In thread0 (Configuration.threads PC')) (SIMREL_THREAD : simrel_thread G sc PC' T' f_to f_from thread sim_normal) (SIMREL : simrel G sc PC T f_to f_from) (COMMON : simrel_common G sc PC T f_to f_from sim_normal) (THREADS : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) ->\nsimrel_thread_local G sc PC T f_to f_from thread0 sim_normal) (thread' : IdentMap.key) (TP' : IdentMap.In thread' (Configuration.threads PC')) (NEQ : thread <> thread') : simrel_thread_local G sc PC' T' f_to f_from thread' sim_normal.","proofString":"assert (simrel_thread_local G sc PC T f_to f_from thread' sim_normal) as AA.\napply SIMREL.\nby apply TPEQ.\ncdes AA.\neapply simrel_thread_local_step; eauto.\ncdes COMMON.\nauto.\ncdes COMMON.\nauto.\nvauto.\nins.\nedestruct SIM_RES_MEM with (b:=b) as [_ HH]; eauto.\nby apply HH."},{"statement":"(thread : positive) (PC PC' : Configuration.t) (T T' : trav_label -> Prop) (label : MachineEvent.t) (f_to f_from : actid -> Time.t) (COVE : covered T' ⊆₁ E) (ISSE : issued T' ⊆₁ E) (COVIN : covered T ⊆₁ covered T') (ISSIN : issued T ⊆₁ issued T') (SIN : reserved T ⊆₁ reserved T') (NINCOV : covered T' \\₁ covered T ⊆₁ Tid_ thread) (NINISS : issued T' \\₁ issued T ⊆₁ Tid_ thread) (NINS : reserved T' \\₁ reserved T ⊆₁ Tid_ thread) (SOT : forall thread'0 : positive,\nthread'0 <> thread ->\nforall (langst : {lang : language & Language.state lang}) (local : Local.t),\nIdentMap.find thread'0 (Configuration.threads PC) = Some (langst, local) <->\nIdentMap.find thread'0 (Configuration.threads PC') = Some (langst, local)) (PCSTEP : tc (plain_step label thread) PC PC') (CLOSED_PRES : closedness_preserved (Configuration.memory PC) (Configuration.memory PC')) (MSG_PRES : msg_preserved (Configuration.memory PC) (Configuration.memory PC')) (TPEQ : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) <->\nIdentMap.In thread0 (Configuration.threads PC')) (SIMREL_THREAD : simrel_thread G sc PC' T' f_to f_from thread sim_normal) (SIMREL : simrel G sc PC T f_to f_from) (COMMON : simrel_common G sc PC T f_to f_from sim_normal) (THREADS : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) ->\nsimrel_thread_local G sc PC T f_to f_from thread0 sim_normal) (thread' : IdentMap.key) (TP' : IdentMap.In thread' (Configuration.threads PC')) (NEQ : thread <> thread') : simrel_thread_local G sc PC T f_to f_from thread' sim_normal.","proofString":"apply SIMREL.\nby apply TPEQ."},{"statement":"(thread : positive) (PC PC' : Configuration.t) (T T' : trav_label -> Prop) (label : MachineEvent.t) (f_to f_from : actid -> Time.t) (COVE : covered T' ⊆₁ E) (ISSE : issued T' ⊆₁ E) (COVIN : covered T ⊆₁ covered T') (ISSIN : issued T ⊆₁ issued T') (SIN : reserved T ⊆₁ reserved T') (NINCOV : covered T' \\₁ covered T ⊆₁ Tid_ thread) (NINISS : issued T' \\₁ issued T ⊆₁ Tid_ thread) (NINS : reserved T' \\₁ reserved T ⊆₁ Tid_ thread) (SOT : forall thread'0 : positive,\nthread'0 <> thread ->\nforall (langst : {lang : language & Language.state lang}) (local : Local.t),\nIdentMap.find thread'0 (Configuration.threads PC) = Some (langst, local) <->\nIdentMap.find thread'0 (Configuration.threads PC') = Some (langst, local)) (PCSTEP : tc (plain_step label thread) PC PC') (CLOSED_PRES : closedness_preserved (Configuration.memory PC) (Configuration.memory PC')) (MSG_PRES : msg_preserved (Configuration.memory PC) (Configuration.memory PC')) (TPEQ : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) <->\nIdentMap.In thread0 (Configuration.threads PC')) (SIMREL_THREAD : simrel_thread G sc PC' T' f_to f_from thread sim_normal) (SIMREL : simrel G sc PC T f_to f_from) (COMMON : simrel_common G sc PC T f_to f_from sim_normal) (THREADS : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) ->\nsimrel_thread_local G sc PC T f_to f_from thread0 sim_normal) (thread' : IdentMap.key) (TP' : IdentMap.In thread' (Configuration.threads PC')) (NEQ : thread <> thread') : IdentMap.In thread' (Configuration.threads PC).","proofString":"by apply TPEQ."},{"statement":"(thread : positive) (PC PC' : Configuration.t) (T T' : trav_label -> Prop) (label : MachineEvent.t) (f_to f_from : actid -> Time.t) (COVE : covered T' ⊆₁ E) (ISSE : issued T' ⊆₁ E) (COVIN : covered T ⊆₁ covered T') (ISSIN : issued T ⊆₁ issued T') (SIN : reserved T ⊆₁ reserved T') (NINCOV : covered T' \\₁ covered T ⊆₁ Tid_ thread) (NINISS : issued T' \\₁ issued T ⊆₁ Tid_ thread) (NINS : reserved T' \\₁ reserved T ⊆₁ Tid_ thread) (SOT : forall thread'0 : positive,\nthread'0 <> thread ->\nforall (langst : {lang : language & Language.state lang}) (local : Local.t),\nIdentMap.find thread'0 (Configuration.threads PC) = Some (langst, local) <->\nIdentMap.find thread'0 (Configuration.threads PC') = Some (langst, local)) (PCSTEP : tc (plain_step label thread) PC PC') (CLOSED_PRES : closedness_preserved (Configuration.memory PC) (Configuration.memory PC')) (MSG_PRES : msg_preserved (Configuration.memory PC) (Configuration.memory PC')) (TPEQ : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) <->\nIdentMap.In thread0 (Configuration.threads PC')) (SIMREL_THREAD : simrel_thread G sc PC' T' f_to f_from thread sim_normal) (SIMREL : simrel G sc PC T f_to f_from) (COMMON : simrel_common G sc PC T f_to f_from sim_normal) (THREADS : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) ->\nsimrel_thread_local G sc PC T f_to f_from thread0 sim_normal) (thread' : IdentMap.key) (TP' : IdentMap.In thread' (Configuration.threads PC')) (NEQ : thread <> thread') (AA : simrel_thread_local G sc PC T f_to f_from thread' sim_normal) : simrel_thread_local G sc PC' T' f_to f_from thread' sim_normal.","proofString":"cdes AA.\neapply simrel_thread_local_step; eauto.\ncdes COMMON.\nauto.\ncdes COMMON.\nauto.\nvauto.\nins.\nedestruct SIM_RES_MEM with (b:=b) as [_ HH]; eauto.\nby apply HH."}]}