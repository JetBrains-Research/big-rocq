{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Determinism.v","fileSamples":[{"statement":"(t2 : trace) (w2 w : world) (H : possible_trace w t2 w2) : possible_trace w t2 w2.","proofString":"auto."},{"statement":"(t2 : trace) (w2 w1 : world) (ev : event) (w0 : world) (t : trace) (w3 : world) (H : possible_event w1 ev w0) (H0 : possible_trace w0 t w3) (IHpossible_trace : possible_trace w3 t2 w2 -> possible_trace w0 (t ** t2) w2) (H1 : possible_trace w3 t2 w2) : possible_trace w1 (ev :: t ** t2) w2.","proofString":"econstructor; eauto."},{"statement":"(t2 : trace) (w2 w0 : world) (H : possible_trace w0 t2 w2) : exists w1 : world, possible_trace w0 nil w1 /\\ possible_trace w1 t2 w2.","proofString":"exists w0; split.\nconstructor.\nauto."},{"statement":"(t2 : trace) (w2 w0 : world) (H : possible_trace w0 t2 w2) : possible_trace w0 nil w0.","proofString":"constructor."},{"statement":"(t2 : trace) (w2 w0 : world) (H : possible_trace w0 t2 w2) : possible_trace w0 t2 w2.","proofString":"auto."},{"statement":"(t2 : trace) (w2 : world) (a : event) (t1 : list event) (IHt1 : forall w1 : world,\npossible_trace w1 (t1 ** t2) w2 ->\nexists w3 : world, possible_trace w1 t1 w3 /\\ possible_trace w3 t2 w2) (w0 : world) (H : possible_trace w0 (a :: t1 ** t2) w2) : exists w1 : world, possible_trace w0 (a :: t1) w1 /\\ possible_trace w1 t2 w2.","proofString":"inv H.\nexploit IHt1; eauto.\nintros [w1 [A B]].\nexists w1; split.\neconstructor; eauto.\nauto."},{"statement":"(t2 : trace) (w2 : world) (a : event) (t1 : list event) (IHt1 : forall w1 : world,\npossible_trace w1 (t1 ** t2) w2 ->\nexists w4 : world, possible_trace w1 t1 w4 /\\ possible_trace w4 t2 w2) (w0 w3 : world) (H3 : possible_event w0 a w3) (H5 : possible_trace w3 (t1 ** t2) w2) : exists w1 : world, possible_trace w0 (a :: t1) w1 /\\ possible_trace w1 t2 w2.","proofString":"exploit IHt1; eauto.\nintros [w1 [A B]].\nexists w1; split.\neconstructor; eauto.\nauto."},{"statement":"(t2 : trace) (w2 : world) (a : event) (t1 : list event) (IHt1 : forall w1 : world,\npossible_trace w1 (t1 ** t2) w2 ->\nexists w4 : world, possible_trace w1 t1 w4 /\\ possible_trace w4 t2 w2) (w0 w3 : world) (H3 : possible_event w0 a w3) (H5 : possible_trace w3 (t1 ** t2) w2) : (exists w1 : world, possible_trace w3 t1 w1 /\\ possible_trace w1 t2 w2) ->\nexists w1 : world, possible_trace w0 (a :: t1) w1 /\\ possible_trace w1 t2 w2.","proofString":"intros [w1 [A B]].\nexists w1; split.\neconstructor; eauto.\nauto."},{"statement":"(t2 : trace) (w2 : world) (a : event) (t1 : list event) (IHt1 : forall w4 : world,\npossible_trace w4 (t1 ** t2) w2 ->\nexists w5 : world, possible_trace w4 t1 w5 /\\ possible_trace w5 t2 w2) (w0 w3 : world) (H3 : possible_event w0 a w3) (H5 : possible_trace w3 (t1 ** t2) w2) (w1 : world) (A : possible_trace w3 t1 w1) (B : possible_trace w1 t2 w2) : exists w4 : world, possible_trace w0 (a :: t1) w4 /\\ possible_trace w4 t2 w2.","proofString":"exists w1; split.\neconstructor; eauto.\nauto."},{"statement":"(t2 : trace) (w2 : world) (a : event) (t1 : list event) (IHt1 : forall w4 : world,\npossible_trace w4 (t1 ** t2) w2 ->\nexists w5 : world, possible_trace w4 t1 w5 /\\ possible_trace w5 t2 w2) (w0 w3 : world) (H3 : possible_event w0 a w3) (H5 : possible_trace w3 (t1 ** t2) w2) (w1 : world) (A : possible_trace w3 t1 w1) (B : possible_trace w1 t2 w2) : possible_trace w0 (a :: t1) w1.","proofString":"econstructor; eauto."},{"statement":"(t2 : trace) (w2 : world) (a : event) (t1 : list event) (IHt1 : forall w4 : world,\npossible_trace w4 (t1 ** t2) w2 ->\nexists w5 : world, possible_trace w4 t1 w5 /\\ possible_trace w5 t2 w2) (w0 w3 : world) (H3 : possible_event w0 a w3) (H5 : possible_trace w3 (t1 ** t2) w2) (w1 : world) (A : possible_trace w3 t1 w1) (B : possible_trace w1 t2 w2) : possible_trace w1 t2 w2.","proofString":"auto."},{"statement":"(ge : Senv.t) (t1 t2 : trace) (w0 w1 w2 : world) (H : match_traces ge t1 t2) (H0 : possible_trace w0 t1 w1) (H1 : possible_trace w0 t2 w2) : t1 = t2 /\\ w1 = w2.","proofString":"inv H; inv H1; inv H0.\nauto.\ninv H7; inv H6.\ninv H9; inv H10.\nsplit; congruence.\ninv H7; inv H6.\ninv H9; inv H10.\nsplit; congruence.\ninv H4; inv H3.\ninv H6; inv H7.\nsplit; congruence.\ninv H4; inv H3.\ninv H7; inv H6.\nauto."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (id : string) (args : list eventval) (res1 res2 : eventval) (H2 : eventval_valid ge res1) (H3 : eventval_valid ge res2) (H4 : eventval_type res1 = eventval_type res2) (w4 : world) (H7 : possible_event w0 (Event_syscall id args res2) w4) (H9 : possible_trace w4 nil w2) (w5 : world) (H6 : possible_event w0 (Event_syscall id args res1) w5) (H10 : possible_trace w5 nil w1) : Event_syscall id args res1 :: nil = Event_syscall id args res2 :: nil /\\\nw1 = w2.","proofString":"inv H7; inv H6.\ninv H9; inv H10.\nsplit; congruence."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (id : string) (args : list eventval) (res1 res2 : eventval) (H2 : eventval_valid ge res1) (H3 : eventval_valid ge res2) (H4 : eventval_type res1 = eventval_type res2) (w4 : world) (H9 : possible_trace w4 nil w2) (w5 : world) (H10 : possible_trace w5 nil w1) (H11 : nextworld_io w0 id args = Some (res2, w4)) (H8 : nextworld_io w0 id args = Some (res1, w5)) : Event_syscall id args res1 :: nil = Event_syscall id args res2 :: nil /\\\nw1 = w2.","proofString":"inv H9; inv H10.\nsplit; congruence."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (id : string) (args : list eventval) (res1 res2 : eventval) (H2 : eventval_valid ge res1) (H3 : eventval_valid ge res2) (H4 : eventval_type res1 = eventval_type res2) (H11 : nextworld_io w0 id args = Some (res2, w2)) (H8 : nextworld_io w0 id args = Some (res1, w1)) : Event_syscall id args res1 :: nil = Event_syscall id args res2 :: nil /\\\nw1 = w2.","proofString":"split; congruence."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (res1 res2 : eventval) (H2 : eventval_valid ge res1) (H3 : eventval_valid ge res2) (H4 : eventval_type res1 = eventval_type res2) (w4 : world) (H7 : possible_event w0 (Event_vload chunk id ofs res2) w4) (H9 : possible_trace w4 nil w2) (w5 : world) (H6 : possible_event w0 (Event_vload chunk id ofs res1) w5) (H10 : possible_trace w5 nil w1) : Event_vload chunk id ofs res1 :: nil = Event_vload chunk id ofs res2 :: nil /\\\nw1 = w2.","proofString":"inv H7; inv H6.\ninv H9; inv H10.\nsplit; congruence."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (res1 res2 : eventval) (H2 : eventval_valid ge res1) (H3 : eventval_valid ge res2) (H4 : eventval_type res1 = eventval_type res2) (w4 : world) (H9 : possible_trace w4 nil w2) (w5 : world) (H10 : possible_trace w5 nil w1) (H12 : nextworld_vload w0 chunk id ofs = Some (res2, w4)) (H11 : nextworld_vload w0 chunk id ofs = Some (res1, w5)) : Event_vload chunk id ofs res1 :: nil = Event_vload chunk id ofs res2 :: nil /\\\nw1 = w2.","proofString":"inv H9; inv H10.\nsplit; congruence."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (res1 res2 : eventval) (H2 : eventval_valid ge res1) (H3 : eventval_valid ge res2) (H4 : eventval_type res1 = eventval_type res2) (H12 : nextworld_vload w0 chunk id ofs = Some (res2, w2)) (H11 : nextworld_vload w0 chunk id ofs = Some (res1, w1)) : Event_vload chunk id ofs res1 :: nil = Event_vload chunk id ofs res2 :: nil /\\\nw1 = w2.","proofString":"split; congruence."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (arg : eventval) (w4 : world) (H4 : possible_event w0 (Event_vstore chunk id ofs arg) w4) (H6 : possible_trace w4 nil w2) (w5 : world) (H3 : possible_event w0 (Event_vstore chunk id ofs arg) w5) (H7 : possible_trace w5 nil w1) : Event_vstore chunk id ofs arg :: nil = Event_vstore chunk id ofs arg :: nil /\\\nw1 = w2.","proofString":"inv H4; inv H3.\ninv H6; inv H7.\nsplit; congruence."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (arg : eventval) (w4 : world) (H6 : possible_trace w4 nil w2) (w5 : world) (H7 : possible_trace w5 nil w1) (H9 : nextworld_vstore w0 chunk id ofs arg = Some w4) (H8 : nextworld_vstore w0 chunk id ofs arg = Some w5) : Event_vstore chunk id ofs arg :: nil = Event_vstore chunk id ofs arg :: nil /\\\nw1 = w2.","proofString":"inv H6; inv H7.\nsplit; congruence."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (arg : eventval) (H9 : nextworld_vstore w0 chunk id ofs arg = Some w2) (H8 : nextworld_vstore w0 chunk id ofs arg = Some w1) : Event_vstore chunk id ofs arg :: nil = Event_vstore chunk id ofs arg :: nil /\\\nw1 = w2.","proofString":"split; congruence."},{"statement":"(ge : Senv.t) (w0 w1 w2 : world) (id : string) (args : list eventval) (w4 : world) (H4 : possible_event w0 (Event_annot id args) w4) (H6 : possible_trace w4 nil w2) (w5 : world) (H3 : possible_event w0 (Event_annot id args) w5) (H7 : possible_trace w5 nil w1) : Event_annot id args :: nil = Event_annot id args :: nil /\\ w1 = w2.","proofString":"inv H4; inv H3.\ninv H7; inv H6.\nauto."},{"statement":"(ge : Senv.t) (w1 w2 : world) (id : string) (args : list eventval) (w5 : world) (H6 : possible_trace w5 nil w2) (H7 : possible_trace w5 nil w1) : Event_annot id args :: nil = Event_annot id args :: nil /\\ w1 = w2.","proofString":"inv H7; inv H6.\nauto."},{"statement":"(ge : Senv.t) (w2 : world) (id : string) (args : list eventval) : Event_annot id args :: nil = Event_annot id args :: nil /\\ w2 = w2.","proofString":"auto."},{"statement":"(t2 : traceinf) (w : world) (H : possible_traceinf w t2) : possible_traceinf w t2.","proofString":"auto."},{"statement":"(t2 : traceinf) (w1 : world) (ev : event) (w2 : world) (t : trace) (w3 : world) (H : possible_event w1 ev w2) (H0 : possible_trace w2 t w3) (IHpossible_trace : possible_traceinf w3 t2 -> possible_traceinf w2 (t *** t2)) (H1 : possible_traceinf w3 t2) : possible_traceinf w1 (Econsinf ev (t *** t2)).","proofString":"econstructor; eauto."},{"statement":"(t2 : traceinf) (w0 : world) (H : possible_traceinf w0 t2) : exists w1 : world, possible_trace w0 nil w1 /\\ possible_traceinf w1 t2.","proofString":"exists w0; split.\nconstructor.\nauto."},{"statement":"(t2 : traceinf) (w0 : world) (H : possible_traceinf w0 t2) : possible_trace w0 nil w0.","proofString":"constructor."},{"statement":"(t2 : traceinf) (w0 : world) (H : possible_traceinf w0 t2) : possible_traceinf w0 t2.","proofString":"auto."},{"statement":"(t2 : traceinf) (a : event) (t1 : list event) (IHt1 : forall w1 : world,\npossible_traceinf w1 (t1 *** t2) ->\nexists w2 : world, possible_trace w1 t1 w2 /\\ possible_traceinf w2 t2) (w0 : world) (H : possible_traceinf w0 (Econsinf a (t1 *** t2))) : exists w1 : world, possible_trace w0 (a :: t1) w1 /\\ possible_traceinf w1 t2.","proofString":"inv H.\nexploit IHt1; eauto.\nintros [w1 [A B]].\nexists w1; split.\neconstructor; eauto.\nauto."},{"statement":"(t2 : traceinf) (a : event) (t1 : list event) (IHt1 : forall w1 : world,\npossible_traceinf w1 (t1 *** t2) ->\nexists w3 : world, possible_trace w1 t1 w3 /\\ possible_traceinf w3 t2) (w0 w2 : world) (H3 : possible_event w0 a w2) (H4 : possible_traceinf w2 (t1 *** t2)) : exists w1 : world, possible_trace w0 (a :: t1) w1 /\\ possible_traceinf w1 t2.","proofString":"exploit IHt1; eauto.\nintros [w1 [A B]].\nexists w1; split.\neconstructor; eauto.\nauto."},{"statement":"(t2 : traceinf) (a : event) (t1 : list event) (IHt1 : forall w1 : world,\npossible_traceinf w1 (t1 *** t2) ->\nexists w3 : world, possible_trace w1 t1 w3 /\\ possible_traceinf w3 t2) (w0 w2 : world) (H3 : possible_event w0 a w2) (H4 : possible_traceinf w2 (t1 *** t2)) : (exists w1 : world, possible_trace w2 t1 w1 /\\ possible_traceinf w1 t2) ->\nexists w1 : world, possible_trace w0 (a :: t1) w1 /\\ possible_traceinf w1 t2.","proofString":"intros [w1 [A B]].\nexists w1; split.\neconstructor; eauto.\nauto."},{"statement":"(t2 : traceinf) (a : event) (t1 : list event) (IHt1 : forall w3 : world,\npossible_traceinf w3 (t1 *** t2) ->\nexists w4 : world, possible_trace w3 t1 w4 /\\ possible_traceinf w4 t2) (w0 w2 : world) (H3 : possible_event w0 a w2) (H4 : possible_traceinf w2 (t1 *** t2)) (w1 : world) (A : possible_trace w2 t1 w1) (B : possible_traceinf w1 t2) : exists w3 : world, possible_trace w0 (a :: t1) w3 /\\ possible_traceinf w3 t2.","proofString":"exists w1; split.\neconstructor; eauto.\nauto."},{"statement":"(t2 : traceinf) (a : event) (t1 : list event) (IHt1 : forall w3 : world,\npossible_traceinf w3 (t1 *** t2) ->\nexists w4 : world, possible_trace w3 t1 w4 /\\ possible_traceinf w4 t2) (w0 w2 : world) (H3 : possible_event w0 a w2) (H4 : possible_traceinf w2 (t1 *** t2)) (w1 : world) (A : possible_trace w2 t1 w1) (B : possible_traceinf w1 t2) : possible_trace w0 (a :: t1) w1.","proofString":"econstructor; eauto."},{"statement":"(t2 : traceinf) (a : event) (t1 : list event) (IHt1 : forall w3 : world,\npossible_traceinf w3 (t1 *** t2) ->\nexists w4 : world, possible_trace w3 t1 w4 /\\ possible_traceinf w4 t2) (w0 w2 : world) (H3 : possible_event w0 a w2) (H4 : possible_traceinf w2 (t1 *** t2)) (w1 : world) (A : possible_trace w2 t1 w1) (B : possible_traceinf w1 t2) : possible_traceinf w1 t2.","proofString":"auto."},{"statement":"(COINDHYP : forall (w0 : world) (T0 : traceinf),\npossible_traceinf' w0 T0 -> possible_traceinf w0 T0) (w : world) (T : traceinf) (H : possible_traceinf' w T) : possible_traceinf w T.","proofString":"inv H.\ninv H0.\ncongruence.\nsimpl.\neconstructor.\neauto.\napply COINDHYP.\ninv H3.\nsimpl.\nauto.\neconstructor; eauto.\neconstructor; eauto.\nunfold E0; congruence."},{"statement":"(COINDHYP : forall (w0 : world) (T : traceinf),\npossible_traceinf' w0 T -> possible_traceinf w0 T) (w : world) (t : trace) (w2 : world) (T0 : traceinf) (H0 : possible_trace w t w2) (H1 : t <> E0) (H2 : possible_traceinf' w2 T0) : possible_traceinf w (t *** T0).","proofString":"inv H0.\ncongruence.\nsimpl.\neconstructor.\neauto.\napply COINDHYP.\ninv H3.\nsimpl.\nauto.\neconstructor; eauto.\neconstructor; eauto.\nunfold E0; congruence."},{"statement":"(COINDHYP : forall (w : world) (T : traceinf),\npossible_traceinf' w T -> possible_traceinf w T) (w2 : world) (T0 : traceinf) (H1 : E0 <> E0) (H2 : possible_traceinf' w2 T0) : possible_traceinf w2 (E0 *** T0).","proofString":"congruence."},{"statement":"(COINDHYP : forall (w1 : world) (T : traceinf),\npossible_traceinf' w1 T -> possible_traceinf w1 T) (w w2 : world) (T0 : traceinf) (ev : event) (t0 : trace) (H1 : ev :: t0 <> E0) (H2 : possible_traceinf' w2 T0) (w0 : world) (H : possible_event w ev w0) (H3 : possible_trace w0 t0 w2) : possible_traceinf w ((ev :: t0) *** T0).","proofString":"simpl.\neconstructor.\neauto.\napply COINDHYP.\ninv H3.\nsimpl.\nauto.\neconstructor; eauto.\neconstructor; eauto.\nunfold E0; congruence."},{"statement":"(COINDHYP : forall (w1 : world) (T : traceinf),\npossible_traceinf' w1 T -> possible_traceinf w1 T) (w w2 : world) (T0 : traceinf) (ev : event) (t0 : trace) (H1 : ev :: t0 <> E0) (H2 : possible_traceinf' w2 T0) (w0 : world) (H : possible_event w ev w0) (H3 : possible_trace w0 t0 w2) : possible_traceinf w (Econsinf ev (t0 *** T0)).","proofString":"econstructor.\neauto.\napply COINDHYP.\ninv H3.\nsimpl.\nauto.\neconstructor; eauto.\neconstructor; eauto.\nunfold E0; congruence."},{"statement":"(COINDHYP : forall (w1 : world) (T : traceinf),\npossible_traceinf' w1 T -> possible_traceinf w1 T) (w w2 : world) (T0 : traceinf) (ev : event) (t0 : trace) (H1 : ev :: t0 <> E0) (H2 : possible_traceinf' w2 T0) (w0 : world) (H : possible_event w ev w0) (H3 : possible_trace w0 t0 w2) : possible_traceinf' w0 (t0 *** T0).","proofString":"inv H3.\nsimpl.\nauto.\neconstructor; eauto.\neconstructor; eauto.\nunfold E0; congruence."},{"statement":"(COINDHYP : forall (w0 : world) (T : traceinf),\npossible_traceinf' w0 T -> possible_traceinf w0 T) (w w2 : world) (T0 : traceinf) (ev : event) (H1 : ev :: E0 <> E0) (H2 : possible_traceinf' w2 T0) (H : possible_event w ev w2) : possible_traceinf' w2 (E0 *** T0).","proofString":"simpl.\nauto."},{"statement":"(COINDHYP : forall (w0 : world) (T : traceinf),\npossible_traceinf' w0 T -> possible_traceinf w0 T) (w w2 : world) (T0 : traceinf) (ev : event) (H1 : ev :: E0 <> E0) (H2 : possible_traceinf' w2 T0) (H : possible_event w ev w2) : possible_traceinf' w2 T0.","proofString":"auto."},{"statement":"(COINDHYP : forall (w1 : world) (T : traceinf),\npossible_traceinf' w1 T -> possible_traceinf w1 T) (w w2 : world) (T0 : traceinf) (ev ev0 : event) (t : trace) (H1 : ev :: ev0 :: t <> E0) (H2 : possible_traceinf' w2 T0) (w0 : world) (H : possible_event w ev w0) (w3 : world) (H0 : possible_event w0 ev0 w3) (H4 : possible_trace w3 t w2) : possible_traceinf' w0 ((ev0 :: t) *** T0).","proofString":"econstructor; eauto.\neconstructor; eauto.\nunfold E0; congruence."},{"statement":"(COINDHYP : forall (w1 : world) (T : traceinf),\npossible_traceinf' w1 T -> possible_traceinf w1 T) (w w2 : world) (T0 : traceinf) (ev ev0 : event) (t : trace) (H1 : ev :: ev0 :: t <> E0) (H2 : possible_traceinf' w2 T0) (w0 : world) (H : possible_event w ev w0) (w3 : world) (H0 : possible_event w0 ev0 w3) (H4 : possible_trace w3 t w2) : possible_trace w0 (ev0 :: t) w2.","proofString":"econstructor; eauto."},{"statement":"(COINDHYP : forall (w1 : world) (T : traceinf),\npossible_traceinf' w1 T -> possible_traceinf w1 T) (w w2 : world) (T0 : traceinf) (ev ev0 : event) (t : trace) (H1 : ev :: ev0 :: t <> E0) (H2 : possible_traceinf' w2 T0) (w0 : world) (H : possible_event w ev w0) (w3 : world) (H0 : possible_event w0 ev0 w3) (H4 : possible_trace w3 t w2) : ev0 :: t <> E0.","proofString":"unfold E0; congruence."},{"statement":"(s : state L) (t2 : trace) (s2 : state L) (H : Star L s t2 s2) : exists t : trace,\n  Star L s t s2 /\\ t2 = E0 ** t \\/ Star L s2 t s /\\ E0 = t2 ** t.","proofString":"exists t2; auto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (t : trace) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (t3 : trace) (s4 : state L),\nStar L s2 t3 s4 ->\nexists t4 : trace,\n  Star L s3 t4 s4 /\\ t3 = t2 ** t4 \\/ Star L s4 t4 s3 /\\ t2 = t3 ** t4) (t0 : trace) (s0 : state L) (H2 : Star L s1 t0 s0) : exists t3 : trace,\n  Star L s3 t3 s0 /\\ t0 = t ** t3 \\/ Star L s0 t3 s3 /\\ t = t0 ** t3.","proofString":"inv H2.\nexists (t1 ** t2); right.\nsplit.\neconstructor; eauto.\nauto.\nuse_step_deterministic.\nexploit IHstar.\neexact H4.\nintros [t A].\nexists t.\ndestruct A.\nleft; intuition.\ntraceEq.\nright; intuition.\ntraceEq."},{"statement":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s0 : state L) (H : Step L s0 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall (t0 : trace) (s1 : state L),\nStar L s2 t0 s1 ->\nexists t : trace,\n  Star L s3 t s1 /\\ t0 = t2 ** t \\/ Star L s1 t s3 /\\ t2 = t0 ** t) : exists t : trace,\n  Star L s3 t s0 /\\ E0 = (t1 ** t2) ** t \\/\n  Star L s0 t s3 /\\ t1 ** t2 = E0 ** t.","proofString":"exists (t1 ** t2); right.\nsplit.\neconstructor; eauto.\nauto."},{"statement":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s0 : state L) (H : Step L s0 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall (t0 : trace) (s1 : state L),\nStar L s2 t0 s1 ->\nexists t : trace,\n  Star L s3 t s1 /\\ t0 = t2 ** t \\/ Star L s1 t s3 /\\ t2 = t0 ** t) : Star L s0 (t1 ** t2) s3 /\\ t1 ** t2 = E0 ** t1 ** t2.","proofString":"split.\neconstructor; eauto.\nauto."},{"statement":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s0 : state L) (H : Step L s0 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall (t0 : trace) (s1 : state L),\nStar L s2 t0 s1 ->\nexists t : trace,\n  Star L s3 t s1 /\\ t0 = t2 ** t \\/ Star L s1 t s3 /\\ t2 = t0 ** t) : Star L s0 (t1 ** t2) s3.","proofString":"econstructor; eauto."},{"statement":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s0 : state L) (H : Step L s0 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall (t0 : trace) (s1 : state L),\nStar L s2 t0 s1 ->\nexists t : trace,\n  Star L s3 t s1 /\\ t0 = t2 ** t \\/ Star L s1 t s3 /\\ t2 = t0 ** t) : t1 ** t2 = E0 ** t1 ** t2.","proofString":"auto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall (t0 : trace) (s4 : state L),\nStar L s2 t0 s4 ->\nexists t : trace,\n  Star L s3 t s4 /\\ t0 = t2 ** t \\/ Star L s4 t s3 /\\ t2 = t0 ** t) (s0 : state L) (t3 : trace) (s5 : state L) (t4 : trace) (H3 : Step L s1 t3 s5) (H4 : Star L s5 t4 s0) : exists t : trace,\n  Star L s3 t s0 /\\ t3 ** t4 = (t1 ** t2) ** t \\/\n  Star L s0 t s3 /\\ t1 ** t2 = (t3 ** t4) ** t.","proofString":"use_step_deterministic.\nexploit IHstar.\neexact H4.\nintros [t A].\nexists t.\ndestruct A.\nleft; intuition.\ntraceEq.\nright; intuition.\ntraceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L),\nStar L s5 t0 s2 ->\nexists t : trace,\n  Star L s3 t s2 /\\ t0 = t2 ** t \\/ Star L s2 t s3 /\\ t2 = t0 ** t) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (s0 : state L) (t4 : trace) (H3 : Step L s1 t3 s5) (H4 : Star L s5 t4 s0) : exists t : trace,\n  Star L s3 t s0 /\\ t3 ** t4 = (t3 ** t2) ** t \\/\n  Star L s0 t s3 /\\ t3 ** t2 = (t3 ** t4) ** t.","proofString":"exploit IHstar.\neexact H4.\nintros [t A].\nexists t.\ndestruct A.\nleft; intuition.\ntraceEq.\nright; intuition.\ntraceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L),\nStar L s5 t0 s2 ->\nexists t1 : trace,\n  Star L s3 t1 s2 /\\ t0 = t2 ** t1 \\/ Star L s2 t1 s3 /\\ t2 = t0 ** t1) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (s0 : state L) (t4 : trace) (H3 : Step L s1 t3 s5) (H4 : Star L s5 t4 s0) (t : trace) (A : Star L s3 t s0 /\\ t4 = t2 ** t \\/ Star L s0 t s3 /\\ t2 = t4 ** t) : exists t0 : trace,\n  Star L s3 t0 s0 /\\ t3 ** t4 = (t3 ** t2) ** t0 \\/\n  Star L s0 t0 s3 /\\ t3 ** t2 = (t3 ** t4) ** t0.","proofString":"exists t.\ndestruct A.\nleft; intuition.\ntraceEq.\nright; intuition.\ntraceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L),\nStar L s5 t0 s2 ->\nexists t1 : trace,\n  Star L s3 t1 s2 /\\ t0 = t2 ** t1 \\/ Star L s2 t1 s3 /\\ t2 = t0 ** t1) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (s0 : state L) (t4 : trace) (H3 : Step L s1 t3 s5) (H4 : Star L s5 t4 s0) (t : trace) (A : Star L s3 t s0 /\\ t4 = t2 ** t \\/ Star L s0 t s3 /\\ t2 = t4 ** t) : Star L s3 t s0 /\\ t3 ** t4 = (t3 ** t2) ** t \\/\nStar L s0 t s3 /\\ t3 ** t2 = (t3 ** t4) ** t.","proofString":"destruct A.\nleft; intuition.\ntraceEq.\nright; intuition.\ntraceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L),\nStar L s5 t0 s2 ->\nexists t1 : trace,\n  Star L s3 t1 s2 /\\ t0 = t2 ** t1 \\/ Star L s2 t1 s3 /\\ t2 = t0 ** t1) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (s0 : state L) (t4 : trace) (H3 : Step L s1 t3 s5) (H4 : Star L s5 t4 s0) (t : trace) (H1 : Star L s3 t s0 /\\ t4 = t2 ** t) : Star L s3 t s0 /\\ t3 ** t4 = (t3 ** t2) ** t \\/\nStar L s0 t s3 /\\ t3 ** t2 = (t3 ** t4) ** t.","proofString":"left; intuition.\ntraceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L),\nStar L s5 t0 s2 ->\nexists t1 : trace,\n  Star L s3 t1 s2 /\\ t0 = t2 ** t1 \\/ Star L s2 t1 s3 /\\ t2 = t0 ** t1) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (s0 : state L) (t4 : trace) (H3 : Step L s1 t3 s5) (H4 : Star L s5 t4 s0) (t : trace) (H2 : Star L s3 t s0) (H5 : t4 = t2 ** t) : t3 ** t4 = (t3 ** t2) ** t.","proofString":"traceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L),\nStar L s5 t0 s2 ->\nexists t1 : trace,\n  Star L s3 t1 s2 /\\ t0 = t2 ** t1 \\/ Star L s2 t1 s3 /\\ t2 = t0 ** t1) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (s0 : state L) (t4 : trace) (H3 : Step L s1 t3 s5) (H4 : Star L s5 t4 s0) (t : trace) (H1 : Star L s0 t s3 /\\ t2 = t4 ** t) : Star L s3 t s0 /\\ t3 ** t4 = (t3 ** t2) ** t \\/\nStar L s0 t s3 /\\ t3 ** t2 = (t3 ** t4) ** t.","proofString":"right; intuition.\ntraceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L),\nStar L s5 t0 s2 ->\nexists t1 : trace,\n  Star L s3 t1 s2 /\\ t0 = t2 ** t1 \\/ Star L s2 t1 s3 /\\ t2 = t0 ** t1) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (s0 : state L) (t4 : trace) (H3 : Step L s1 t3 s5) (H4 : Star L s5 t4 s0) (t : trace) (H2 : Star L s0 t s3) (H5 : t2 = t4 ** t) : t3 ** t2 = (t3 ** t4) ** t.","proofString":"traceEq."},{"statement":"(s0 : state L) (t1 : trace) (s1 : state L) (t2 : trace) (s2 : state L) (H : Star L s0 t1 s1) (H0 : Star L s0 t2 s2) (H1 : Nostep L s2) : exists t : trace, Star L s1 t s2 /\\ t2 = t1 ** t.","proofString":"use_star_step_diamond.\nexists t; auto.\ninv P.\nexists E0.\nsplit.\nconstructor.\ntraceEq.\nuse_nostep."},{"statement":"(s0 : state L) (t1 : trace) (s1 s2 : state L) (H : Star L s0 t1 s1) (t : trace) (H0 : Star L s0 (t1 ** t) s2) (H1 : Nostep L s2) (P : Star L s1 t s2) : exists t0 : trace, Star L s1 t0 s2 /\\ t1 ** t = t1 ** t0.","proofString":"exists t; auto."},{"statement":"(s0 s1 : state L) (t2 : trace) (s2 : state L) (t : trace) (H : Star L s0 (t2 ** t) s1) (H0 : Star L s0 t2 s2) (H1 : Nostep L s2) (P : Star L s2 t s1) : exists t0 : trace, Star L s1 t0 s2 /\\ t2 = (t2 ** t) ** t0.","proofString":"inv P.\nexists E0.\nsplit.\nconstructor.\ntraceEq.\nuse_nostep."},{"statement":"(s0 s1 : state L) (t2 : trace) (H : Star L s0 (t2 ** E0) s1) (H1 : Nostep L s1) (H0 : Star L s0 t2 s1) : exists t : trace, Star L s1 t s1 /\\ t2 = (t2 ** E0) ** t.","proofString":"exists E0.\nsplit.\nconstructor.\ntraceEq."},{"statement":"(s0 s1 : state L) (t2 : trace) (H : Star L s0 (t2 ** E0) s1) (H1 : Nostep L s1) (H0 : Star L s0 t2 s1) : Star L s1 E0 s1 /\\ t2 = (t2 ** E0) ** E0.","proofString":"split.\nconstructor.\ntraceEq."},{"statement":"(s0 s1 : state L) (t2 : trace) (H : Star L s0 (t2 ** E0) s1) (H1 : Nostep L s1) (H0 : Star L s0 t2 s1) : Star L s1 E0 s1.","proofString":"constructor."},{"statement":"(s0 s1 : state L) (t2 : trace) (H : Star L s0 (t2 ** E0) s1) (H1 : Nostep L s1) (H0 : Star L s0 t2 s1) : t2 = (t2 ** E0) ** E0.","proofString":"traceEq."},{"statement":"(s0 s1 : state L) (t2 : trace) (s2 : state L) (t1 t0 : trace) (H : Star L s0 (t2 ** t1 ** t0) s1) (H0 : Star L s0 t2 s2) (H1 : Nostep L s2) (s4 : state L) (H2 : Step L s2 t1 s4) (H3 : Star L s4 t0 s1) : exists t : trace, Star L s1 t s2 /\\ t2 = (t2 ** t1 ** t0) ** t.","proofString":"use_nostep."},{"statement":"(s0 : state L) (t1 : trace) (s1 : state L) (t2 : trace) (s2 : state L) (H : Star L s0 t1 s1) (H0 : Star L s0 t2 s2) (H1 : Nostep L s1) (H2 : Nostep L s2) : t1 = t2 /\\ s1 = s2.","proofString":"use_star_step_triangle.\ninv P.\nsplit; auto; traceEq.\nuse_nostep."},{"statement":"(s0 : state L) (t1 : trace) (s1 s2 : state L) (H : Star L s0 t1 s1) (t : trace) (H0 : Star L s0 (t1 ** t) s2) (H1 : Nostep L s1) (H2 : Nostep L s2) (P : Star L s1 t s2) : t1 = t1 ** t /\\ s1 = s2.","proofString":"inv P.\nsplit; auto; traceEq.\nuse_nostep."},{"statement":"(s0 : state L) (t1 : trace) (s2 : state L) (H : Star L s0 t1 s2) (H0 : Star L s0 (t1 ** E0) s2) (H1 H2 : Nostep L s2) : t1 = t1 ** E0 /\\ s2 = s2.","proofString":"split; auto; traceEq."},{"statement":"(s0 : state L) (t1 : trace) (s1 s2 : state L) (H : Star L s0 t1 s1) (t0 t2 : trace) (H0 : Star L s0 (t1 ** t0 ** t2) s2) (H1 : Nostep L s1) (H2 : Nostep L s2) (s4 : state L) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t2 s2) : t1 = t1 ** t0 ** t2 /\\ s1 = s2.","proofString":"use_nostep."},{"statement":"(s : state L) (t1 : trace) (s1 : state L) (r : int) (t2 : trace) (s2 : state L) (H : Star L s t1 s1) (H0 : final_state L s1 r) (H1 : Star L s t2 s2) (H2 : Nostep L s2) (H3 : forall r0 : int, ~ final_state L s2 r0) : False.","proofString":"assert (t1 = t2 /\\ s1 = s2).\neapply steps_deterministic; eauto.\neapply det_final_nostep; eauto.\ndestruct H4; subst.\nelim (H3 _ H0)."},{"statement":"(s : state L) (t1 : trace) (s1 : state L) (r : int) (t2 : trace) (s2 : state L) (H : Star L s t1 s1) (H0 : final_state L s1 r) (H1 : Star L s t2 s2) (H2 : Nostep L s2) (H3 : forall r0 : int, ~ final_state L s2 r0) : t1 = t2 /\\ s1 = s2.","proofString":"eapply steps_deterministic; eauto.\neapply det_final_nostep; eauto."},{"statement":"(s : state L) (t1 : trace) (s1 : state L) (r : int) (t2 : trace) (s2 : state L) (H : Star L s t1 s1) (H0 : final_state L s1 r) (H1 : Star L s t2 s2) (H2 : Nostep L s2) (H3 : forall r0 : int, ~ final_state L s2 r0) : Nostep L s1.","proofString":"eapply det_final_nostep; eauto."},{"statement":"(s : state L) (t1 : trace) (s1 : state L) (r : int) (t2 : trace) (s2 : state L) (H : Star L s t1 s1) (H0 : final_state L s1 r) (H1 : Star L s t2 s2) (H2 : Nostep L s2) (H3 : forall r0 : int, ~ final_state L s2 r0) (H4 : t1 = t2 /\\ s1 = s2) : False.","proofString":"destruct H4; subst.\nelim (H3 _ H0)."},{"statement":"(s : state L) (r : int) (t2 : trace) (s2 : state L) (H0 : final_state L s2 r) (H H1 : Star L s t2 s2) (H2 : Nostep L s2) (H3 : forall r0 : int, ~ final_state L s2 r0) : False.","proofString":"elim (H3 _ H0)."},{"statement":"(s : state L) (H : Nostep L s) (H0 : Forever_silent L s) : False.","proofString":"inv H0.\nuse_nostep."},{"statement":"(s : state L) (H : Nostep L s) (s2 : state L) (H1 : Step L s E0 s2) (H2 : Forever_silent L s2) : False.","proofString":"use_nostep."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (t : trace) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : Nostep L s3 -> Forever_silent L s2 -> False) (H2 : Nostep L s3) (H3 : Forever_silent L s1) : False.","proofString":"inv H3.\nuse_step_deterministic.\neauto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : Nostep L s3 -> Forever_silent L s2 -> False) (H2 : Nostep L s3) (s4 : state L) (H4 : Step L s1 E0 s4) (H5 : Forever_silent L s4) : False.","proofString":"use_step_deterministic.\neauto."},{"statement":"(s1 : state L) (t2 : trace) (s3 s4 : state L) (IHstar : Nostep L s3 -> Forever_silent L s4 -> False) (H0 : Star L s4 t2 s3) (H : Step L s1 E0 s4) (H2 : Nostep L s3) (H4 : Step L s1 E0 s4) (H5 : Forever_silent L s4) : False.","proofString":"eauto."},{"statement":"(s : state L) (t1 : trace) (s1 : state L) (t2 : trace) (s2 : state L) (H : Star L s t1 s1) (H0 : Nostep L s1) (H1 : Star L s t2 s2) (H2 : Forever_silent L s2) : False.","proofString":"use_star_step_triangle.\neapply star_final_not_forever_silent.\neexact P.\neauto.\nauto."},{"statement":"(s s1 : state L) (t2 : trace) (s2 : state L) (t : trace) (H : Star L s (t2 ** t) s1) (H0 : Nostep L s1) (H1 : Star L s t2 s2) (H2 : Forever_silent L s2) (P : Star L s2 t s1) : False.","proofString":"eapply star_final_not_forever_silent.\neexact P.\neauto.\nauto."},{"statement":"(s : state L) (T : traceinf) (H : Nostep L s) (H0 : Forever_reactive L s T) : False.","proofString":"inv H0.\ninv H1.\ncongruence.\nuse_nostep."},{"statement":"(s : state L) (H : Nostep L s) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T0) : False.","proofString":"inv H1.\ncongruence.\nuse_nostep."},{"statement":"(s2 : state L) (H : Nostep L s2) (T0 : traceinf) (H2 : E0 <> E0) (H3 : Forever_reactive L s2 T0) : False.","proofString":"congruence."},{"statement":"(s : state L) (H : Nostep L s) (s2 : state L) (T0 : traceinf) (t1 t2 : trace) (H2 : t1 ** t2 <> E0) (H3 : Forever_reactive L s2 T0) (s0 : state L) (H0 : Step L s t1 s0) (H4 : Star L s0 t2 s2) : False.","proofString":"use_nostep."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall T : traceinf, Nostep L s3 -> Forever_reactive L s2 T -> False) (H2 : Nostep L s3) (s4 : state L) (t0 : trace) (T0 : traceinf) (H4 : Star L s1 t0 s4) (H5 : t0 <> E0) (H6 : Forever_reactive L s4 T0) : False.","proofString":"inv H4.\ncongruence.\nuse_step_deterministic.\neapply IHstar with (T := t4 *** T0).\neauto.\neapply star_forever_reactive; eauto."},{"statement":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s4 : state L) (H : Step L s4 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall T : traceinf, Nostep L s3 -> Forever_reactive L s2 T -> False) (H2 : Nostep L s3) (T0 : traceinf) (H5 : E0 <> E0) (H6 : Forever_reactive L s4 T0) : False.","proofString":"congruence."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall T : traceinf, Nostep L s3 -> Forever_reactive L s2 T -> False) (H2 : Nostep L s3) (s4 : state L) (T0 : traceinf) (t3 t4 : trace) (H5 : t3 ** t4 <> E0) (H6 : Forever_reactive L s4 T0) (s5 : state L) (H1 : Step L s1 t3 s5) (H3 : Star L s5 t4 s4) : False.","proofString":"use_step_deterministic.\neapply IHstar with (T := t4 *** T0).\neauto.\neapply star_forever_reactive; eauto."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall T : traceinf, Nostep L s3 -> Forever_reactive L s5 T -> False) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (H2 : Nostep L s3) (s4 : state L) (T0 : traceinf) (t4 : trace) (H5 : t3 ** t4 <> E0) (H6 : Forever_reactive L s4 T0) (H1 : Step L s1 t3 s5) (H3 : Star L s5 t4 s4) : False.","proofString":"eapply IHstar with (T := t4 *** T0).\neauto.\neapply star_forever_reactive; eauto."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall T : traceinf, Nostep L s3 -> Forever_reactive L s5 T -> False) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (H2 : Nostep L s3) (s4 : state L) (T0 : traceinf) (t4 : trace) (H5 : t3 ** t4 <> E0) (H6 : Forever_reactive L s4 T0) (H1 : Step L s1 t3 s5) (H3 : Star L s5 t4 s4) : Nostep L s3.","proofString":"eauto."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall T : traceinf, Nostep L s3 -> Forever_reactive L s5 T -> False) (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (H2 : Nostep L s3) (s4 : state L) (T0 : traceinf) (t4 : trace) (H5 : t3 ** t4 <> E0) (H6 : Forever_reactive L s4 T0) (H1 : Step L s1 t3 s5) (H3 : Star L s5 t4 s4) : Forever_reactive L s5 (t4 *** T0).","proofString":"eapply star_forever_reactive; eauto."},{"statement":"(s : state L) (H : Forever_silent L s) : E0 = E0 /\\ Forever_silent L s.","proofString":"auto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (t : trace) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : Forever_silent L s2 -> t2 = E0 /\\ Forever_silent L s3) (H2 : Forever_silent L s1) : t = E0 /\\ Forever_silent L s3.","proofString":"subst.\ninv H2.\nuse_step_deterministic.\neauto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : Forever_silent L s2 -> t2 = E0 /\\ Forever_silent L s3) (H2 : Forever_silent L s1) : t1 ** t2 = E0 /\\ Forever_silent L s3.","proofString":"inv H2.\nuse_step_deterministic.\neauto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : Forever_silent L s2 -> t2 = E0 /\\ Forever_silent L s3) (s4 : state L) (H1 : Step L s1 E0 s4) (H3 : Forever_silent L s4) : t1 ** t2 = E0 /\\ Forever_silent L s3.","proofString":"use_step_deterministic.\neauto."},{"statement":"(s1 : state L) (t2 : trace) (s3 s4 : state L) (IHstar : Forever_silent L s4 -> t2 = E0 /\\ Forever_silent L s3) (H0 : Star L s4 t2 s3) (H H1 : Step L s1 E0 s4) (H3 : Forever_silent L s4) : E0 ** t2 = E0 /\\ Forever_silent L s3.","proofString":"eauto."},{"statement":"(s : state L) (T : traceinf) (H : Forever_silent L s) (H0 : Forever_reactive L s T) : False.","proofString":"inv H0.\nexploit star_forever_silent_inv; eauto.\nintros [A B].\ncontradiction."},{"statement":"(s : state L) (H : Forever_silent L s) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T0) : False.","proofString":"exploit star_forever_silent_inv; eauto.\nintros [A B].\ncontradiction."},{"statement":"(s : state L) (H : Forever_silent L s) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T0) : t = E0 /\\ Forever_silent L s2 -> False.","proofString":"intros [A B].\ncontradiction."},{"statement":"(s : state L) (H : Forever_silent L s) (s2 : state L) (t : trace) (T0 : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T0) (A : t = E0) (B : Forever_silent L s2) : False.","proofString":"contradiction."},{"statement":"(s : state L) (t2 : trace) (s2 : state L) (T1 T2 : traceinf) (H : Star L s t2 s2) (H0 : E0 <> E0) (H1 : t2 <> E0) (H2 : Forever_reactive L s T1) (H3 : Forever_reactive L s2 T2) : exists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ E0 *** T1 = t *** T1' /\\ t2 *** T2 = t *** T2'.","proofString":"congruence."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (t : trace) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (t3 : trace) (s4 : state L) (T0 T3 : traceinf),\nStar L s2 t3 s4 ->\nt2 <> E0 ->\nt3 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s4 T3 ->\nexists (s' : state L) (t4 : trace) (T1' T2' : traceinf),\n  t4 <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\\n  t2 *** T0 = t4 *** T1' /\\ t3 *** T3 = t4 *** T2') (t0 : trace) (s0 : state L) (T1 T2 : traceinf) (H2 : Star L s1 t0 s0) (H3 : t <> E0) (H4 : t0 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) : exists (s' : state L) (t3 : trace) (T1' T2' : traceinf),\n  t3 <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\\n  t *** T1 = t3 *** T1' /\\ t0 *** T2 = t3 *** T2'.","proofString":"inv H2.\ncongruence.\nuse_step_deterministic.\ndestruct t3.\nsimpl in *.\neapply IHstar; eauto.\nexists s5; exists (e :: t3);  exists (t2 *** T1); exists (t4 *** T2).\nsplit.\nunfold E0; congruence.\nsplit.\neapply star_forever_reactive; eauto.\nsplit.\neapply star_forever_reactive; eauto.\nsplit; traceEq."},{"statement":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s0 : state L) (H : Step L s0 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall (t0 : trace) (s1 : state L) (T0 T3 : traceinf),\nStar L s2 t0 s1 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s1 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (T1 T2 : traceinf) (H3 : t1 ** t2 <> E0) (H4 : E0 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) : exists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\\n  (t1 ** t2) *** T1 = t *** T1' /\\ E0 *** T2 = t *** T2'.","proofString":"congruence."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall (t0 : trace) (s4 : state L) (T0 T3 : traceinf),\nStar L s2 t0 s4 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s4 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (s0 : state L) (T1 T2 : traceinf) (H3 : t1 ** t2 <> E0) (t3 t4 : trace) (H4 : t3 ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (s5 : state L) (H7 : Step L s1 t3 s5) (H8 : Star L s5 t4 s0) : exists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\\n  (t1 ** t2) *** T1 = t *** T1' /\\ (t3 ** t4) *** T2 = t *** T2'.","proofString":"use_step_deterministic.\ndestruct t3.\nsimpl in *.\neapply IHstar; eauto.\nexists s5; exists (e :: t3);  exists (t2 *** T1); exists (t4 *** T2).\nsplit.\nunfold E0; congruence.\nsplit.\neapply star_forever_reactive; eauto.\nsplit.\neapply star_forever_reactive; eauto.\nsplit; traceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (t3 : trace) (H : Step L s1 t3 s5) (s0 : state L) (T1 T2 : traceinf) (H3 : t3 ** t2 <> E0) (t4 : trace) (H4 : t3 ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 t3 s5) (H8 : Star L s5 t4 s0) : exists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\\n  (t3 ** t2) *** T1 = t *** T1' /\\ (t3 ** t4) *** T2 = t *** T2'.","proofString":"destruct t3.\nsimpl in *.\neapply IHstar; eauto.\nexists s5; exists (e :: t3);  exists (t2 *** T1); exists (t4 *** T2).\nsplit.\nunfold E0; congruence.\nsplit.\neapply star_forever_reactive; eauto.\nsplit.\neapply star_forever_reactive; eauto.\nsplit; traceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (H : Step L s1 nil s5) (s0 : state L) (T1 T2 : traceinf) (H3 : nil ** t2 <> E0) (t4 : trace) (H4 : nil ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 nil s5) (H8 : Star L s5 t4 s0) : exists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\\n  (nil ** t2) *** T1 = t *** T1' /\\ (nil ** t4) *** T2 = t *** T2'.","proofString":"simpl in *.\neapply IHstar; eauto."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (H : Step L s1 nil s5) (s0 : state L) (T1 T2 : traceinf) (H3 : t2 <> E0) (t4 : trace) (H4 : t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 nil s5) (H8 : Star L s5 t4 s0) : exists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T1 = t *** T1' /\\ t4 *** T2 = t *** T2'.","proofString":"eapply IHstar; eauto."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (e : event) (t3 : list event) (H : Step L s1 (e :: t3) s5) (s0 : state L) (T1 T2 : traceinf) (H3 : (e :: t3) ** t2 <> E0) (t4 : trace) (H4 : (e :: t3) ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 (e :: t3) s5) (H8 : Star L s5 t4 s0) : exists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\\n  ((e :: t3) ** t2) *** T1 = t *** T1' /\\\n  ((e :: t3) ** t4) *** T2 = t *** T2'.","proofString":"exists s5; exists (e :: t3);  exists (t2 *** T1); exists (t4 *** T2).\nsplit.\nunfold E0; congruence.\nsplit.\neapply star_forever_reactive; eauto.\nsplit.\neapply star_forever_reactive; eauto.\nsplit; traceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (e : event) (t3 : list event) (H : Step L s1 (e :: t3) s5) (s0 : state L) (T1 T2 : traceinf) (H3 : (e :: t3) ** t2 <> E0) (t4 : trace) (H4 : (e :: t3) ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 (e :: t3) s5) (H8 : Star L s5 t4 s0) : e :: t3 <> E0 /\\\nForever_reactive L s5 (t2 *** T1) /\\\nForever_reactive L s5 (t4 *** T2) /\\\n((e :: t3) ** t2) *** T1 = (e :: t3) *** t2 *** T1 /\\\n((e :: t3) ** t4) *** T2 = (e :: t3) *** t4 *** T2.","proofString":"split.\nunfold E0; congruence.\nsplit.\neapply star_forever_reactive; eauto.\nsplit.\neapply star_forever_reactive; eauto.\nsplit; traceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (e : event) (t3 : list event) (H : Step L s1 (e :: t3) s5) (s0 : state L) (T1 T2 : traceinf) (H3 : (e :: t3) ** t2 <> E0) (t4 : trace) (H4 : (e :: t3) ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 (e :: t3) s5) (H8 : Star L s5 t4 s0) : e :: t3 <> E0.","proofString":"unfold E0; congruence."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (e : event) (t3 : list event) (H : Step L s1 (e :: t3) s5) (s0 : state L) (T1 T2 : traceinf) (H3 : (e :: t3) ** t2 <> E0) (t4 : trace) (H4 : (e :: t3) ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 (e :: t3) s5) (H8 : Star L s5 t4 s0) : Forever_reactive L s5 (t2 *** T1) /\\\nForever_reactive L s5 (t4 *** T2) /\\\n((e :: t3) ** t2) *** T1 = (e :: t3) *** t2 *** T1 /\\\n((e :: t3) ** t4) *** T2 = (e :: t3) *** t4 *** T2.","proofString":"split.\neapply star_forever_reactive; eauto.\nsplit.\neapply star_forever_reactive; eauto.\nsplit; traceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (e : event) (t3 : list event) (H : Step L s1 (e :: t3) s5) (s0 : state L) (T1 T2 : traceinf) (H3 : (e :: t3) ** t2 <> E0) (t4 : trace) (H4 : (e :: t3) ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 (e :: t3) s5) (H8 : Star L s5 t4 s0) : Forever_reactive L s5 (t2 *** T1).","proofString":"eapply star_forever_reactive; eauto."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (e : event) (t3 : list event) (H : Step L s1 (e :: t3) s5) (s0 : state L) (T1 T2 : traceinf) (H3 : (e :: t3) ** t2 <> E0) (t4 : trace) (H4 : (e :: t3) ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 (e :: t3) s5) (H8 : Star L s5 t4 s0) : Forever_reactive L s5 (t4 *** T2) /\\\n((e :: t3) ** t2) *** T1 = (e :: t3) *** t2 *** T1 /\\\n((e :: t3) ** t4) *** T2 = (e :: t3) *** t4 *** T2.","proofString":"split.\neapply star_forever_reactive; eauto.\nsplit; traceEq."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (e : event) (t3 : list event) (H : Step L s1 (e :: t3) s5) (s0 : state L) (T1 T2 : traceinf) (H3 : (e :: t3) ** t2 <> E0) (t4 : trace) (H4 : (e :: t3) ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 (e :: t3) s5) (H8 : Star L s5 t4 s0) : Forever_reactive L s5 (t4 *** T2).","proofString":"eapply star_forever_reactive; eauto."},{"statement":"(s1 : state L) (t2 : trace) (s3 s5 : state L) (IHstar : forall (t0 : trace) (s2 : state L) (T0 T3 : traceinf),\nStar L s5 t0 s2 ->\nt2 <> E0 ->\nt0 <> E0 ->\nForever_reactive L s3 T0 ->\nForever_reactive L s2 T3 ->\nexists (s' : state L) (t : trace) (T1' T2' : traceinf),\n  t <> E0 /\\\n  Forever_reactive L s' T1' /\\\n  Forever_reactive L s' T2' /\\ t2 *** T0 = t *** T1' /\\ t0 *** T3 = t *** T2') (H0 : Star L s5 t2 s3) (e : event) (t3 : list event) (H : Step L s1 (e :: t3) s5) (s0 : state L) (T1 T2 : traceinf) (H3 : (e :: t3) ** t2 <> E0) (t4 : trace) (H4 : (e :: t3) ** t4 <> E0) (H5 : Forever_reactive L s3 T1) (H6 : Forever_reactive L s0 T2) (H7 : Step L s1 (e :: t3) s5) (H8 : Star L s5 t4 s0) : ((e :: t3) ** t2) *** T1 = (e :: t3) *** t2 *** T1 /\\\n((e :: t3) ** t4) *** T2 = (e :: t3) *** t4 *** T2.","proofString":"split; traceEq."},{"statement":"(COINDHYP : forall (s0 : state L) (T0 T3 : traceinf),\nForever_reactive L s0 T0 -> Forever_reactive L s0 T3 -> traceinf_sim' T0 T3) (s : state L) (T1 T2 : traceinf) (H : Forever_reactive L s T1) (H0 : Forever_reactive L s T2) : traceinf_sim' T1 T2.","proofString":"inv H.\ninv H0.\ndestruct (forever_reactive_inv2 _ _ _ H t s2 T0 T)  as [s' [t' [T1' [T2' [A [B [C [D E]]]]]]]]; auto.\nrewrite D; rewrite E.\nconstructor.\nauto.\neapply COINDHYP; eauto."},{"statement":"(COINDHYP : forall (s0 : state L) (T1 T0 : traceinf),\nForever_reactive L s0 T1 -> Forever_reactive L s0 T0 -> traceinf_sim' T1 T0) (s : state L) (T2 : traceinf) (H0 : Forever_reactive L s T2) (s2 : state L) (t : trace) (T : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T) : traceinf_sim' (t *** T) T2.","proofString":"inv H0.\ndestruct (forever_reactive_inv2 _ _ _ H t s2 T0 T)  as [s' [t' [T1' [T2' [A [B [C [D E]]]]]]]]; auto.\nrewrite D; rewrite E.\nconstructor.\nauto.\neapply COINDHYP; eauto."},{"statement":"(COINDHYP : forall (s1 : state L) (T1 T2 : traceinf),\nForever_reactive L s1 T1 -> Forever_reactive L s1 T2 -> traceinf_sim' T1 T2) (s s2 : state L) (t : trace) (T : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T) (s0 : state L) (t0 : trace) (T0 : traceinf) (H : Star L s t0 s0) (H4 : t0 <> E0) (H5 : Forever_reactive L s0 T0) : traceinf_sim' (t *** T) (t0 *** T0).","proofString":"destruct (forever_reactive_inv2 _ _ _ H t s2 T0 T)  as [s' [t' [T1' [T2' [A [B [C [D E]]]]]]]]; auto.\nrewrite D; rewrite E.\nconstructor.\nauto.\neapply COINDHYP; eauto."},{"statement":"(COINDHYP : forall (s1 : state L) (T1 T2 : traceinf),\nForever_reactive L s1 T1 -> Forever_reactive L s1 T2 -> traceinf_sim' T1 T2) (s s2 : state L) (t : trace) (T : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T) (s0 : state L) (t0 : trace) (T0 : traceinf) (H : Star L s t0 s0) (H4 : t0 <> E0) (H5 : Forever_reactive L s0 T0) (s' : state L) (t' : trace) (T1' T2' : traceinf) (A : t' <> E0) (B : Forever_reactive L s' T1') (C : Forever_reactive L s' T2') (D : t0 *** T0 = t' *** T1') (E : t *** T = t' *** T2') : traceinf_sim' (t *** T) (t0 *** T0).","proofString":"rewrite D; rewrite E.\nconstructor.\nauto.\neapply COINDHYP; eauto."},{"statement":"(COINDHYP : forall (s1 : state L) (T1 T2 : traceinf),\nForever_reactive L s1 T1 -> Forever_reactive L s1 T2 -> traceinf_sim' T1 T2) (s s2 : state L) (t : trace) (T : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T) (s0 : state L) (t0 : trace) (T0 : traceinf) (H : Star L s t0 s0) (H4 : t0 <> E0) (H5 : Forever_reactive L s0 T0) (s' : state L) (t' : trace) (T1' T2' : traceinf) (A : t' <> E0) (B : Forever_reactive L s' T1') (C : Forever_reactive L s' T2') (D : t0 *** T0 = t' *** T1') (E : t *** T = t' *** T2') : traceinf_sim' (t' *** T2') (t' *** T1').","proofString":"constructor.\nauto.\neapply COINDHYP; eauto."},{"statement":"(COINDHYP : forall (s1 : state L) (T1 T2 : traceinf),\nForever_reactive L s1 T1 -> Forever_reactive L s1 T2 -> traceinf_sim' T1 T2) (s s2 : state L) (t : trace) (T : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T) (s0 : state L) (t0 : trace) (T0 : traceinf) (H : Star L s t0 s0) (H4 : t0 <> E0) (H5 : Forever_reactive L s0 T0) (s' : state L) (t' : trace) (T1' T2' : traceinf) (A : t' <> E0) (B : Forever_reactive L s' T1') (C : Forever_reactive L s' T2') (D : t0 *** T0 = t' *** T1') (E : t *** T = t' *** T2') : t' <> E0.","proofString":"auto."},{"statement":"(COINDHYP : forall (s1 : state L) (T1 T2 : traceinf),\nForever_reactive L s1 T1 -> Forever_reactive L s1 T2 -> traceinf_sim' T1 T2) (s s2 : state L) (t : trace) (T : traceinf) (H1 : Star L s t s2) (H2 : t <> E0) (H3 : Forever_reactive L s2 T) (s0 : state L) (t0 : trace) (T0 : traceinf) (H : Star L s t0 s0) (H4 : t0 <> E0) (H5 : Forever_reactive L s0 T0) (s' : state L) (t' : trace) (T1' T2' : traceinf) (A : t' <> E0) (B : Forever_reactive L s' T1') (C : Forever_reactive L s' T2') (D : t0 *** T0 = t' *** T1') (E : t *** T = t' *** T2') : traceinf_sim' T2' T1'.","proofString":"eapply COINDHYP; eauto."},{"statement":"(s : state L) (T1 T2 : traceinf) (H : Forever_reactive L s T1) (H0 : Forever_reactive L s T2) : traceinf_sim T1 T2.","proofString":"apply traceinf_sim'_sim.\neapply forever_reactive_determ'; eauto."},{"statement":"(s : state L) (T1 T2 : traceinf) (H : Forever_reactive L s T1) (H0 : Forever_reactive L s T2) : traceinf_sim' T1 T2.","proofString":"eapply forever_reactive_determ'; eauto."},{"statement":"(s : state L) (t : trace) (s' : state L) (T : traceinf) (H : Star L s t s') (H0 : Forever_silent L s') (H1 : Forever_reactive L s T) : False.","proofString":"exploit star_forever_reactive_inv; eauto.\nintros [T' [A B]].\nsubst T.\neapply forever_silent_reactive_exclusive; eauto."},{"statement":"(s : state L) (t : trace) (s' : state L) (T : traceinf) (H : Star L s t s') (H0 : Forever_silent L s') (H1 : Forever_reactive L s T) : (exists T' : traceinf, Forever_reactive L s' T' /\\ T = t *** T') -> False.","proofString":"intros [T' [A B]].\nsubst T.\neapply forever_silent_reactive_exclusive; eauto."},{"statement":"(s : state L) (t : trace) (s' : state L) (T : traceinf) (H : Star L s t s') (H0 : Forever_silent L s') (H1 : Forever_reactive L s T) (T' : traceinf) (A : Forever_reactive L s' T') (B : T = t *** T') : False.","proofString":"subst T.\neapply forever_silent_reactive_exclusive; eauto."},{"statement":"(s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Forever_silent L s') (T' : traceinf) (H1 : Forever_reactive L s (t *** T')) (A : Forever_reactive L s' T') : False.","proofString":"eapply forever_silent_reactive_exclusive; eauto."},{"statement":"(dfns : forall (s : state L) (r : int), final_state L s r -> Nostep L s) : forall (s : state L) (beh1 beh2 : program_behavior),\nstate_behaves L s beh1 -> state_behaves L s beh2 -> same_behaviors beh1 beh2.","proofString":"intros until beh2; intros BEH1 BEH2.\ninv BEH1; inv BEH2; red.\nassert (t = t0 /\\ s' = s'0).\neapply steps_deterministic; eauto.\ndestruct H3.\nsplit; auto.\nsubst.\neapply det_final_state; eauto.\neapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto.\neapply star_final_not_forever_reactive; eauto.\neapply terminates_not_goes_wrong with (s1 := s') (s2 := s'0); eauto.\neapply star2_final_not_forever_silent with (s2 := s') (s1 := s'0); eauto.\nuse_star_step_diamond.\nexploit star_forever_silent_inv.\neexact P.\neauto.\nintros [A B].\nsubst; traceEq.\nexploit star_forever_silent_inv.\neexact P.\neauto.\nintros [A B].\nsubst; traceEq.\neapply forever_silent_reactive_exclusive2; eauto.\neapply star2_final_not_forever_silent with (s1 := s'0) (s2 := s'); eauto.\neapply star_final_not_forever_reactive; eauto.\neapply forever_silent_reactive_exclusive2; eauto.\neapply forever_reactive_determ; eauto.\neapply star_final_not_forever_reactive; eauto.\neapply terminates_not_goes_wrong with (s1 := s'0) (s2 := s'); eauto.\neapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto.\neapply star_final_not_forever_reactive; eauto.\nassert (t = t0 /\\ s' = s'0).\neapply steps_deterministic; eauto.\ntauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (beh1 beh2 : program_behavior) (BEH1 : state_behaves L s beh1) (BEH2 : state_behaves L s beh2) : same_behaviors beh1 beh2.","proofString":"inv BEH1; inv BEH2; red.\nassert (t = t0 /\\ s' = s'0).\neapply steps_deterministic; eauto.\ndestruct H3.\nsplit; auto.\nsubst.\neapply det_final_state; eauto.\neapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto.\neapply star_final_not_forever_reactive; eauto.\neapply terminates_not_goes_wrong with (s1 := s') (s2 := s'0); eauto.\neapply star2_final_not_forever_silent with (s2 := s') (s1 := s'0); eauto.\nuse_star_step_diamond.\nexploit star_forever_silent_inv.\neexact P.\neauto.\nintros [A B].\nsubst; traceEq.\nexploit star_forever_silent_inv.\neexact P.\neauto.\nintros [A B].\nsubst; traceEq.\neapply forever_silent_reactive_exclusive2; eauto.\neapply star2_final_not_forever_silent with (s1 := s'0) (s2 := s'); eauto.\neapply star_final_not_forever_reactive; eauto.\neapply forever_silent_reactive_exclusive2; eauto.\neapply forever_reactive_determ; eauto.\neapply star_final_not_forever_reactive; eauto.\neapply terminates_not_goes_wrong with (s1 := s'0) (s2 := s'); eauto.\neapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto.\neapply star_final_not_forever_reactive; eauto.\nassert (t = t0 /\\ s' = s'0).\neapply steps_deterministic; eauto.\ntauto."},{"statement":"(dfns : forall (s0 : state L) (r1 : int), final_state L s0 r1 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (r : int) (H : Star L s t s') (H0 : final_state L s' r) (t0 : trace) (s'0 : state L) (r0 : int) (H1 : Star L s t0 s'0) (H2 : final_state L s'0 r0) : t = t0 /\\ r = r0.","proofString":"assert (t = t0 /\\ s' = s'0).\neapply steps_deterministic; eauto.\ndestruct H3.\nsplit; auto.\nsubst.\neapply det_final_state; eauto."},{"statement":"(dfns : forall (s0 : state L) (r1 : int), final_state L s0 r1 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (r : int) (H : Star L s t s') (H0 : final_state L s' r) (t0 : trace) (s'0 : state L) (r0 : int) (H1 : Star L s t0 s'0) (H2 : final_state L s'0 r0) : t = t0 /\\ s' = s'0.","proofString":"eapply steps_deterministic; eauto."},{"statement":"(dfns : forall (s0 : state L) (r1 : int), final_state L s0 r1 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (r : int) (H : Star L s t s') (H0 : final_state L s' r) (t0 : trace) (s'0 : state L) (r0 : int) (H1 : Star L s t0 s'0) (H2 : final_state L s'0 r0) (H3 : t = t0 /\\ s' = s'0) : t = t0 /\\ r = r0.","proofString":"destruct H3.\nsplit; auto.\nsubst.\neapply det_final_state; eauto."},{"statement":"(dfns : forall (s0 : state L) (r1 : int), final_state L s0 r1 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (r : int) (H : Star L s t s') (H0 : final_state L s' r) (t0 : trace) (s'0 : state L) (r0 : int) (H1 : Star L s t0 s'0) (H2 : final_state L s'0 r0) (H3 : t = t0) (H4 : s' = s'0) : t = t0 /\\ r = r0.","proofString":"split; auto.\nsubst.\neapply det_final_state; eauto."},{"statement":"(dfns : forall (s0 : state L) (r1 : int), final_state L s0 r1 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (r : int) (H : Star L s t s') (H0 : final_state L s' r) (t0 : trace) (s'0 : state L) (r0 : int) (H1 : Star L s t0 s'0) (H2 : final_state L s'0 r0) (H3 : t = t0) (H4 : s' = s'0) : r = r0.","proofString":"subst.\neapply det_final_state; eauto."},{"statement":"(dfns : forall (s0 : state L) (r1 : int), final_state L s0 r1 -> Nostep L s0) (s : state L) (r : int) (t0 : trace) (s'0 : state L) (H0 : final_state L s'0 r) (H : Star L s t0 s'0) (r0 : int) (H1 : Star L s t0 s'0) (H2 : final_state L s'0 r0) : r = r0.","proofString":"eapply det_final_state; eauto."},{"statement":"(dfns : forall (s0 : state L) (r0 : int), final_state L s0 r0 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (r : int) (H : Star L s t s') (H0 : final_state L s' r) (t0 : trace) (s'0 : state L) (H1 : Star L s t0 s'0) (H2 : Forever_silent L s'0) : False.","proofString":"eapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto."},{"statement":"(dfns : forall (s0 : state L) (r0 : int), final_state L s0 r0 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (r : int) (H : Star L s t s') (H0 : final_state L s' r) (T : traceinf) (H1 : Forever_reactive L s T) : False.","proofString":"eapply star_final_not_forever_reactive; eauto."},{"statement":"(dfns : forall (s0 : state L) (r0 : int), final_state L s0 r0 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (r : int) (H : Star L s t s') (H0 : final_state L s' r) (t0 : trace) (s'0 : state L) (H1 : Star L s t0 s'0) (H2 : Nostep L s'0) (H3 : forall r0 : int, ~ final_state L s'0 r0) : False.","proofString":"eapply terminates_not_goes_wrong with (s1 := s') (s2 := s'0); eauto."},{"statement":"(dfns : forall (s0 : state L) (r0 : int), final_state L s0 r0 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Forever_silent L s') (t0 : trace) (s'0 : state L) (r : int) (H1 : Star L s t0 s'0) (H2 : final_state L s'0 r) : False.","proofString":"eapply star2_final_not_forever_silent with (s2 := s') (s1 := s'0); eauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Forever_silent L s') (t0 : trace) (s'0 : state L) (H1 : Star L s t0 s'0) (H2 : Forever_silent L s'0) : t = t0.","proofString":"use_star_step_diamond.\nexploit star_forever_silent_inv.\neexact P.\neauto.\nintros [A B].\nsubst; traceEq.\nexploit star_forever_silent_inv.\neexact P.\neauto.\nintros [A B].\nsubst; traceEq."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Forever_silent L s') (s'0 : state L) (t1 : trace) (H1 : Star L s (t ** t1) s'0) (H2 : Forever_silent L s'0) (P : Star L s' t1 s'0) : t = t ** t1.","proofString":"exploit star_forever_silent_inv.\neexact P.\neauto.\nintros [A B].\nsubst; traceEq."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Forever_silent L s') (s'0 : state L) (t1 : trace) (H1 : Star L s (t ** t1) s'0) (H2 : Forever_silent L s'0) (P : Star L s' t1 s'0) (A : t1 = E0) (B : Forever_silent L s'0) : t = t ** t1.","proofString":"subst; traceEq."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s s' : state L) (t0 t1 : trace) (H : Star L s (t0 ** t1) s') (H0 : Forever_silent L s') (s'0 : state L) (H1 : Star L s t0 s'0) (H2 : Forever_silent L s'0) (P : Star L s'0 t1 s') : t0 ** t1 = t0.","proofString":"exploit star_forever_silent_inv.\neexact P.\neauto.\nintros [A B].\nsubst; traceEq."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s s' : state L) (t0 t1 : trace) (H : Star L s (t0 ** t1) s') (H0 : Forever_silent L s') (s'0 : state L) (H1 : Star L s t0 s'0) (H2 : Forever_silent L s'0) (P : Star L s'0 t1 s') (A : t1 = E0) (B : Forever_silent L s') : t0 ** t1 = t0.","proofString":"subst; traceEq."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Forever_silent L s') (T : traceinf) (H1 : Forever_reactive L s T) : False.","proofString":"eapply forever_silent_reactive_exclusive2; eauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Forever_silent L s') (t0 : trace) (s'0 : state L) (H1 : Star L s t0 s'0) (H2 : Nostep L s'0) (H3 : forall r : int, ~ final_state L s'0 r) : False.","proofString":"eapply star2_final_not_forever_silent with (s1 := s'0) (s2 := s'); eauto."},{"statement":"(dfns : forall (s0 : state L) (r0 : int), final_state L s0 r0 -> Nostep L s0) (s : state L) (T : traceinf) (H : Forever_reactive L s T) (t : trace) (s' : state L) (r : int) (H0 : Star L s t s') (H1 : final_state L s' r) : False.","proofString":"eapply star_final_not_forever_reactive; eauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (T : traceinf) (H : Forever_reactive L s T) (t : trace) (s' : state L) (H0 : Star L s t s') (H1 : Forever_silent L s') : False.","proofString":"eapply forever_silent_reactive_exclusive2; eauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (T : traceinf) (H : Forever_reactive L s T) (T0 : traceinf) (H0 : Forever_reactive L s T0) : traceinf_sim T T0.","proofString":"eapply forever_reactive_determ; eauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (T : traceinf) (H : Forever_reactive L s T) (t : trace) (s' : state L) (H0 : Star L s t s') (H1 : Nostep L s') (H2 : forall r : int, ~ final_state L s' r) : False.","proofString":"eapply star_final_not_forever_reactive; eauto."},{"statement":"(dfns : forall (s0 : state L) (r0 : int), final_state L s0 r0 -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Nostep L s') (H1 : forall r0 : int, ~ final_state L s' r0) (t0 : trace) (s'0 : state L) (r : int) (H2 : Star L s t0 s'0) (H3 : final_state L s'0 r) : False.","proofString":"eapply terminates_not_goes_wrong with (s1 := s'0) (s2 := s'); eauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Nostep L s') (H1 : forall r : int, ~ final_state L s' r) (t0 : trace) (s'0 : state L) (H2 : Star L s t0 s'0) (H3 : Forever_silent L s'0) : False.","proofString":"eapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Nostep L s') (H1 : forall r : int, ~ final_state L s' r) (T : traceinf) (H2 : Forever_reactive L s T) : False.","proofString":"eapply star_final_not_forever_reactive; eauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Nostep L s') (H1 : forall r : int, ~ final_state L s' r) (t0 : trace) (s'0 : state L) (H2 : Star L s t0 s'0) (H3 : Nostep L s'0) (H4 : forall r : int, ~ final_state L s'0 r) : t = t0.","proofString":"assert (t = t0 /\\ s' = s'0).\neapply steps_deterministic; eauto.\ntauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Nostep L s') (H1 : forall r : int, ~ final_state L s' r) (t0 : trace) (s'0 : state L) (H2 : Star L s t0 s'0) (H3 : Nostep L s'0) (H4 : forall r : int, ~ final_state L s'0 r) : t = t0 /\\ s' = s'0.","proofString":"eapply steps_deterministic; eauto."},{"statement":"(dfns : forall (s0 : state L) (r : int), final_state L s0 r -> Nostep L s0) (s : state L) (t : trace) (s' : state L) (H : Star L s t s') (H0 : Nostep L s') (H1 : forall r : int, ~ final_state L s' r) (t0 : trace) (s'0 : state L) (H2 : Star L s t0 s'0) (H3 : Nostep L s'0) (H4 : forall r : int, ~ final_state L s'0 r) (H5 : t = t0 /\\ s' = s'0) : t = t0.","proofString":"tauto."},{"statement":"(beh1 beh2 : program_behavior) (BEH1 : program_behaves L beh1) (BEH2 : program_behaves L beh2) : same_behaviors beh1 beh2.","proofString":"inv BEH1; inv BEH2.\nassert (s = s0) by (eapply det_initial_state; eauto).\nsubst s0.\neapply state_behaves_deterministic; eauto.\nelim (H1 _ H).\nelim (H _ H0).\nred; auto."},{"statement":"(beh1 beh2 : program_behavior) (s : state L) (H : initial_state L s) (H0 : state_behaves L s beh1) (s0 : state L) (H1 : initial_state L s0) (H2 : state_behaves L s0 beh2) : same_behaviors beh1 beh2.","proofString":"assert (s = s0) by (eapply det_initial_state; eauto).\nsubst s0.\neapply state_behaves_deterministic; eauto."},{"statement":"(beh1 beh2 : program_behavior) (s : state L) (H : initial_state L s) (H0 : state_behaves L s beh1) (s0 : state L) (H1 : initial_state L s0) (H2 : state_behaves L s0 beh2) (H3 : s = s0) : same_behaviors beh1 beh2.","proofString":"subst s0.\neapply state_behaves_deterministic; eauto."},{"statement":"(beh1 beh2 : program_behavior) (s : state L) (H : initial_state L s) (H0 : state_behaves L s beh1) (H2 : state_behaves L s beh2) (H1 : initial_state L s) : same_behaviors beh1 beh2.","proofString":"eapply state_behaves_deterministic; eauto."},{"statement":"(beh1 : program_behavior) (s : state L) (H : initial_state L s) (H0 : state_behaves L s beh1) (H1 : forall s0 : state L, ~ initial_state L s0) : same_behaviors beh1 (Goes_wrong E0).","proofString":"elim (H1 _ H)."},{"statement":"(beh2 : program_behavior) (H : forall s0 : state L, ~ initial_state L s0) (s : state L) (H0 : initial_state L s) (H1 : state_behaves L s beh2) : same_behaviors (Goes_wrong E0) beh2.","proofString":"elim (H _ H0)."},{"statement":"(H H0 : forall s : state L, ~ initial_state L s) : same_behaviors (Goes_wrong E0) (Goes_wrong E0).","proofString":"red; auto."},{"statement":"(s0 : state L * world) (t1 : trace) (s1 : state L * world) (t2 : trace) (s2 : state L * world) (H : Step L s0#1 t1 s1#1 /\\ possible_trace s0#2 t1 s1#2) (H0 : Step L s0#1 t2 s2#1 /\\ possible_trace s0#2 t2 s2#2) : s1 = s2 /\\ t1 = t2.","proofString":"destruct H; destruct H0.\nexploit (sd_determ D).\neexact H.\neexact H0.\nintros [A B].\nexploit match_possible_traces; eauto.\nintros [EQ1 EQ2].\nsubst t2.\nsplit; auto.\nrewrite (surjective_pairing s1).\nrewrite (surjective_pairing s2).\nintuition congruence."},{"statement":"(s0 : state L * world) (t1 : trace) (s1 : state L * world) (t2 : trace) (s2 : state L * world) (H : Step L s0#1 t1 s1#1) (H1 : possible_trace s0#2 t1 s1#2) (H0 : Step L s0#1 t2 s2#1) (H2 : possible_trace s0#2 t2 s2#2) : s1 = s2 /\\ t1 = t2.","proofString":"exploit (sd_determ D).\neexact H.\neexact H0.\nintros [A B].\nexploit match_possible_traces; eauto.\nintros [EQ1 EQ2].\nsubst t2.\nsplit; auto.\nrewrite (surjective_pairing s1).\nrewrite (surjective_pairing s2).\nintuition congruence."},{"statement":"(s0 : state L * world) (t1 : trace) (s1 : state L * world) (t2 : trace) (s2 : state L * world) (H : Step L s0#1 t1 s1#1) (H1 : possible_trace s0#2 t1 s1#2) (H0 : Step L s0#1 t2 s2#1) (H2 : possible_trace s0#2 t2 s2#2) (A : match_traces (symbolenv L) t1 t2) (B : t1 = t2 -> s1#1 = s2#1) : s1 = s2 /\\ t1 = t2.","proofString":"exploit match_possible_traces; eauto.\nintros [EQ1 EQ2].\nsubst t2.\nsplit; auto.\nrewrite (surjective_pairing s1).\nrewrite (surjective_pairing s2).\nintuition congruence."},{"statement":"(s0 : state L * world) (t1 : trace) (s1 : state L * world) (t2 : trace) (s2 : state L * world) (H : Step L s0#1 t1 s1#1) (H1 : possible_trace s0#2 t1 s1#2) (H0 : Step L s0#1 t2 s2#1) (H2 : possible_trace s0#2 t2 s2#2) (A : match_traces (symbolenv L) t1 t2) (B : t1 = t2 -> s1#1 = s2#1) : t1 = t2 /\\ s1#2 = s2#2 -> s1 = s2 /\\ t1 = t2.","proofString":"intros [EQ1 EQ2].\nsubst t2.\nsplit; auto.\nrewrite (surjective_pairing s1).\nrewrite (surjective_pairing s2).\nintuition congruence."},{"statement":"(s0 : state L * world) (t1 : trace) (s1 : state L * world) (t2 : trace) (s2 : state L * world) (H : Step L s0#1 t1 s1#1) (H1 : possible_trace s0#2 t1 s1#2) (H0 : Step L s0#1 t2 s2#1) (H2 : possible_trace s0#2 t2 s2#2) (A : match_traces (symbolenv L) t1 t2) (B : t1 = t2 -> s1#1 = s2#1) (EQ1 : t1 = t2) (EQ2 : s1#2 = s2#2) : s1 = s2 /\\ t1 = t2.","proofString":"subst t2.\nsplit; auto.\nrewrite (surjective_pairing s1).\nrewrite (surjective_pairing s2).\nintuition congruence."},{"statement":"(s0 : state L * world) (t1 : trace) (s1 s2 : state L * world) (H : Step L s0#1 t1 s1#1) (H1 : possible_trace s0#2 t1 s1#2) (B : t1 = t1 -> s1#1 = s2#1) (A : match_traces (symbolenv L) t1 t1) (H2 : possible_trace s0#2 t1 s2#2) (H0 : Step L s0#1 t1 s2#1) (EQ2 : s1#2 = s2#2) : s1 = s2 /\\ t1 = t1.","proofString":"split; auto.\nrewrite (surjective_pairing s1).\nrewrite (surjective_pairing s2).\nintuition congruence."},{"statement":"(s0 : state L * world) (t1 : trace) (s1 s2 : state L * world) (H : Step L s0#1 t1 s1#1) (H1 : possible_trace s0#2 t1 s1#2) (B : t1 = t1 -> s1#1 = s2#1) (A : match_traces (symbolenv L) t1 t1) (H2 : possible_trace s0#2 t1 s2#2) (H0 : Step L s0#1 t1 s2#1) (EQ2 : s1#2 = s2#2) : s1 = s2.","proofString":"rewrite (surjective_pairing s1).\nrewrite (surjective_pairing s2).\nintuition congruence."},{"statement":"(s0 : state L * world) (t1 : trace) (s1 s2 : state L * world) (H : Step L s0#1 t1 s1#1) (H1 : possible_trace s0#2 t1 s1#2) (B : t1 = t1 -> s1#1 = s2#1) (A : match_traces (symbolenv L) t1 t1) (H2 : possible_trace s0#2 t1 s2#2) (H0 : Step L s0#1 t1 s2#1) (EQ2 : s1#2 = s2#2) : (s1#1, s1#2) = s2.","proofString":"rewrite (surjective_pairing s2).\nintuition congruence."},{"statement":"(s0 : state L * world) (t1 : trace) (s1 s2 : state L * world) (H : Step L s0#1 t1 s1#1) (H1 : possible_trace s0#2 t1 s1#2) (B : t1 = t1 -> s1#1 = s2#1) (A : match_traces (symbolenv L) t1 t1) (H2 : possible_trace s0#2 t1 s2#2) (H0 : Step L s0#1 t1 s2#1) (EQ2 : s1#2 = s2#2) : (s1#1, s1#2) = (s2#1, s2#2).","proofString":"intuition congruence."},{"statement":"(s1 s2 : state L * world) (H : initial_state L s1#1 /\\ s1#2 = initial_world) (H0 : initial_state L s2#1 /\\ s2#2 = initial_world) : s1 = s2.","proofString":"destruct H; destruct H0.\nrewrite (surjective_pairing s1).\nrewrite (surjective_pairing s2).\ndecEq.\neapply (sd_initial_determ D); eauto.\ncongruence."},{"statement":"(s1 s2 : state L * world) (H : initial_state L s1#1) (H1 : s1#2 = initial_world) (H0 : initial_state L s2#1) (H2 : s2#2 = initial_world) : s1 = s2.","proofString":"rewrite (surjective_pairing s1).\nrewrite (surjective_pairing s2).\ndecEq.\neapply (sd_initial_determ D); eauto.\ncongruence."},{"statement":"(s1 s2 : state L * world) (H : initial_state L s1#1) (H1 : s1#2 = initial_world) (H0 : initial_state L s2#1) (H2 : s2#2 = initial_world) : (s1#1, s1#2) = s2.","proofString":"rewrite (surjective_pairing s2).\ndecEq.\neapply (sd_initial_determ D); eauto.\ncongruence."},{"statement":"(s1 s2 : state L * world) (H : initial_state L s1#1) (H1 : s1#2 = initial_world) (H0 : initial_state L s2#1) (H2 : s2#2 = initial_world) : (s1#1, s1#2) = (s2#1, s2#2).","proofString":"decEq.\neapply (sd_initial_determ D); eauto.\ncongruence."},{"statement":"(s1 s2 : state L * world) (H : initial_state L s1#1) (H1 : s1#2 = initial_world) (H0 : initial_state L s2#1) (H2 : s2#2 = initial_world) : s1#1 = s2#1.","proofString":"eapply (sd_initial_determ D); eauto."},{"statement":"(s1 s2 : state L * world) (H : initial_state L s1#1) (H1 : s1#2 = initial_world) (H0 : initial_state L s2#1) (H2 : s2#2 = initial_world) : s1#2 = s2#2.","proofString":"congruence."},{"statement":"(s : state L * world) (r1 r2 : int) (H : final_state L s#1 r1) (H0 : final_state L s#1 r2) : r1 = r2.","proofString":"eapply (sd_final_determ D); eauto."},{"statement":"(s : state L * world) (r : int) (H : final_state L s#1 r) : nostep\n  (fun (ge : genvtype L) (s0 : state L * world) (t : trace)\n     (s' : state L * world) =>\n   step L ge s0#1 t s'#1 /\\ possible_trace s0#2 t s'#2) \n  (globalenv L) s.","proofString":"red; simpl; intros.\nred; intros [A B].\nexploit (sd_final_nostep D); eauto."},{"statement":"(s : state L * world) (r : int) (H : final_state L s#1 r) (t : trace) (s' : state L * world) : ~ (Step L s#1 t s'#1 /\\ possible_trace s#2 t s'#2).","proofString":"red; intros [A B].\nexploit (sd_final_nostep D); eauto."},{"statement":"(s : state L * world) (r : int) (H : final_state L s#1 r) (t : trace) (s' : state L * world) (A : Step L s#1 t s'#1) (B : possible_trace s#2 t s'#2) : False.","proofString":"exploit (sd_final_nostep D); eauto."}]}