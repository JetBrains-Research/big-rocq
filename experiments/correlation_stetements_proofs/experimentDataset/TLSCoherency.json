[{"statement":"Lemma tls_coherent_defs_equiv (G: execution) (tc: trav_label -> Prop):\n  tls_coherent G tc <-> tls_coherent_alt G tc.","proof":"split; intros COH.\n2: {\nred in COH.\ndesc.\nsplit; rewrite ?COH0, ?COH; basic_solver.\n}\ndestruct COH.\nred.\nexists (tc \\₁ init_tls G).\nsplit.\n{\nrewrite tls_coh_exec0.\nbasic_solver.\n}\nsplit; [| basic_solver].\nrewrite (set_split_complete (init_tls G) tc) at 1.\nbasic_solver.\n"},{"statement":"Lemma tlsc_I_in_W WF TCOH:\n    tc ∩₁ (action ↓₁ eq ta_issue) ⊆₁ event ↓₁ W.","proof":"apply tls_coherent_defs_equiv in TCOH as [tc' [INE TC']].\nrewrite TC', set_inter_union_l.\napply set_subset_union_l.\nsplit.\n{\netransitivity; [red; intro; apply proj1| ].\nunfold init_tls.\nerewrite set_pair_alt, init_w; eauto.\nbasic_solver.\n}\nrewrite INE.\nunfold exec_tls.\nrewrite !set_pair_alt.\nunfold action, event.\nunfolder.\nins; desf; congruence.\n"},{"statement":"Lemma tlsc_P_in_E thread (WF: Wf G) (TCOH: tls_coherent G tc) :\n    tc ∩₁ (action ↓₁ eq (ta_propagate thread)) ⊆₁ event ↓₁ acts_set G.","proof":"apply tls_coherent_defs_equiv in TCOH as [tc' [INE TC']].\nrewrite TC', set_inter_union_l.\napply set_subset_union_l.\nsplit.\n{\netransitivity; [red; intro; apply proj1| ].\nunfold init_tls.\nerewrite set_pair_alt, init_w; eauto.\nbasic_solver.\n}\nrewrite INE.\nunfold exec_tls.\nrewrite !set_pair_alt.\nunfold action, event.\nunfolder.\nins; desf; congruence.\n"},{"statement":"Lemma tlsc_P_in_W thread WF TCOH:\n    tc ∩₁ (action ↓₁ eq (ta_propagate thread)) ⊆₁ event ↓₁ W.","proof":"apply tls_coherent_defs_equiv in TCOH as [tc' [INE TC']].\nrewrite TC', set_inter_union_l.\napply set_subset_union_l.\nsplit.\n{\netransitivity; [red; intro; apply proj1| ].\nunfold init_tls.\nerewrite set_pair_alt, init_w; eauto.\nbasic_solver.\n}\nrewrite INE.\nunfold exec_tls.\nrewrite !set_pair_alt.\nunfold action, event.\nunfolder.\nins; desf; congruence.\n"},{"statement":"Lemma exec_tls_ENI:\n    exec_tls G ⊆₁ event ↓₁ (E \\₁ is_init).","proof":"unfold exec_tls.\nrewrite !set_pair_alt.\nbasic_solver.\n"},{"statement":"Lemma init_tls_EI:\n    init_tls G ⊆₁ event ↓₁ (E ∩₁ is_init).","proof":"unfold init_tls.\nrewrite !set_pair_alt.\nbasic_solver.\n"},{"statement":"Lemma tlsc_E WF TCOH:\n    tc ⊆₁ event ↓₁ E.","proof":"destruct TCOH.\nrewrite tls_coh_exec0, exec_tls_ENI, init_tls_EI.\nbasic_solver.\n"},{"statement":"Lemma tls_coherent_ext TCOH lbl\n        (ENI: exec_tls G lbl):\n    tls_coherent G (tc ∪₁ eq lbl).","proof":"destruct TCOH.\nsplit; try basic_solver.\napply set_subset_union_l.\nsplit; auto.\nbasic_solver.\n"},{"statement":"Lemma exec_tls_cip_alt:\n    exec_tls_cip G ≡₁ exec_tls G \\₁ action ↓₁ eq ta_reserve.","proof":"unfold exec_tls_cip, exec_tls.\nrewrite !set_pair_alt.\nsplit; try basic_solver 10.\nrewrite set_minus_union_l.\nunfolder.\nins.\ndestruct x; ins; des; subst; splits; try by vauto.\n{\nright.\nsplits; vauto.\n}\ndo 2 red in H.\ndesc.\nsubst.\nright.\nsplits; vauto.\n"},{"statement":"Lemma iord_exec_tls:\n    iord G sc ≡ restr_rel (exec_tls G) (iord G sc).","proof":"rewrite restr_relE.\napply dom_helper_3.\nunfold iord, exec_tls.\nrewrite !set_pair_alt.\nrewrite set_interC with (s' := W), set_map_inter, <- set_interA.\nrewrite <- set_inter_union_l.\nrewrite restr_rel_cross_inter.\napply restr_rel_mori; [basic_solver| ].\niord_parts_unfolder.\nrepeat apply inclusion_union_l; try basic_solver.\nall: unfolder; ins; destruct x, y; ins; desc; subst; intuition.\n"},{"statement":"Lemma iord_exec_tls_cip:\n    iord G sc ≡ restr_rel (exec_tls_cip G) (iord G sc).","proof":"rewrite restr_relE.\napply dom_helper_3.\nrewrite exec_tls_cip_alt, set_minusE.\nrewrite restr_rel_cross_inter.\nsplit.\n{\neapply iord_exec_tls; eauto.\n}\ndo 2 red in H.\ndesc.\nclear -H.\nunfolder in H.\ndes.\nall: apply seq_eqv_lr in H as (X & _ & Y); red in X, Y; vauto;      split; red; intros [=]; try congruence.\nall: do 2 red in Y; desc; congruence.\n"},{"statement":"Lemma init_exec_tls_disjoint:\n    set_disjoint (init_tls G) (exec_tls G).","proof":"unfold init_tls, exec_tls.\niord_dom_unfolder.\n"},{"statement":"Lemma init_tls_tls_coherent : tls_coherent G (init_tls G).","proof":"apply tls_coherent_defs_equiv.\nexists ∅.\nbasic_solver.\n"},{"statement":"Lemma tls_coherent_ext_union T1 T2\n  (TCOH1: tls_coherent G T1)\n  (EXEC2: T2 ⊆₁ init_tls G ∪₁ exec_tls G):\n  tls_coherent G (T1 ∪₁ T2).","proof":"destruct TCOH1.\nsplit; try basic_solver.\napply set_subset_union_l; auto.\n"}]