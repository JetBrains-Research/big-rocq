[{"statement":"Lemma fin_threads_bound G\n      (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e))\n      (FIN : fin_threads G) :\n  exists b, threads_bound G b.","proof":"do 2 red in FIN.\ndesf.\nunfold threads_bound.\nenough (exists b, forall t, List.In t findom -> BinPos.Pos.lt t b) as [b HH].\n{\nexists b.\nins.\napply HH.\napply FIN.\nnow apply ACTS.\n}\nclear.\ninduction findom.\n{\nexists BinPos.xH.\nins.\n}\ndesf.\nexists (Basic.Ident.add (BinPos.Pos.max a b) BinPos.xH).\nins.\ndesf.\n{\nlia.\n}\netransitivity.\n{\nnow apply IHfindom.\n}\nlia.\n"},{"statement":"Lemma BinPos_lt_fin b:\n  set_finite (fun t => BinPos.Pos.lt t b).","proof":"exists (map BinPos.Pos.of_nat (List.seq 0 (BinPos.Pos.to_nat b))).\nins.\napply Pnat.Pos2Nat.inj_lt in IN.\napply in_map_iff.\neexists.\nsplits.\n{\nby apply Pnat.Pos2Nat.id.\n}\napply in_seq.\nlia.\n"},{"statement":"Lemma dupE A (l : list A) (DUP: ~ NoDup l) :\n  exists l1 a l2 l3, l = l1 ++ a :: l2 ++ a :: l3.","proof":"induction l; ins.\nrewrite nodup_cons in *; clarify_not.\nby apply in_split in DUP; desf; exists nil; ins; eauto.\nspecialize (IHl DUP); desf; eexists (_ :: _); ins; eauto.\n"},{"statement":"Lemma has_finite_antichains_sb G\n      (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e))\n      (B : fin_threads G):\n  has_finite_antichains (acts_set G \\₁ is_init) (⦗set_compl is_init⦘ ⨾ sb G).","proof":"edestruct fin_threads_bound as [b HH]; eauto.\nset (nb := BinPos.Pos.to_nat b).\nred.\nexists nb.\nred.\nins.\ncut (exists a b, a <> b /\\ In a l /\\ In b l /\\ tid a = tid b).\n{\nintro X; desc.\ndestruct (INCL _ X0); destruct (INCL _ X1); desc.\neapply (same_thread G) in X2; unfolder in X2; desf.\n1: exists a, b0.\n2: exists b0, a.\nall: splits; eauto; basic_solver.\n}\nassert (M: incl (map tid l) (map BinPos.Pos.of_nat (List.seq 0 nb))).\n{\nred.\nintros n IN.\nrewrite in_map_iff in *.\ndestruct IN as [x [TT IN]]; subst.\nexists (BinPos.Pos.to_nat (tid x)).\nsplit.\n{\napply Pnat.Pos2Nat.id.\n}\napply in_seq0_iff.\nsubst nb.\napply Pnat.Pos2Nat.inj_lt.\napply HH.\nnow apply INCL.\n}\ndestruct (classic (NoDup (map tid l))).\n{\neapply NoDup_incl_length in M; ins.\nrewrite !length_map, length_seq in *.\nlia.\n}\napply dupE in H; desf.\napply map_eq_app_inv in H; desf.\ndestruct l2'; ins; desf.\napply map_eq_app_inv in H0; desf.\ndestruct l2'0; ins; desf.\nexists a0, a; splits; eauto with hahn.\nintro; desf; rewrite nodup_app, nodup_cons in *; desf; eauto with hahn.\n"},{"statement":"Lemma thread_bounds_fsupp_ninit_ct G r\n      (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e))\n      (TB : fin_threads G)\n      (SB_R: sb G ⊆ r)\n      (AC_R: acyclic r)\n      (R_NI: domb r (set_compl is_init))\n      (E_R: doma r (acts_set G))\n      (FS_R: fsupp (⦗set_compl is_init⦘ ⨾ r)):\n  fsupp (⦗set_compl is_init⦘ ⨾ r^+).","proof":"eapply fsupp_mori.\n{\nred.\nrewrite clos_trans_domb_l; auto.\neapply clos_trans_mori.\nrewrite <- seqA.\napply inclusion_seq_eqv_r.\n}\neapply fsupp_ct with (s := acts_set G \\₁ is_init); auto.\n{\neapply acyclic_mori; eauto.\nred.\nbasic_solver.\n}\n{\nerewrite doma_rewrite with (r := r); eauto.\nbasic_solver.\n}\neapply has_finite_antichains_mori; [reflexivity| ..]; eauto.\n2: {\neapply has_finite_antichains_sb; eauto.\n}\nbasic_solver.\n"}]