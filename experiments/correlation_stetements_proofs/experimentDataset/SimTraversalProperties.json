[{"statement":"Lemma sim_trav_step_coherence (C C' : trav_config) (T : sim_trav_step G sc C C')\n      (H : tc_coherent G sc C):\n  tc_coherent G sc C'.","proof":"red in T.\ndestruct T as [thread T].\ndestruct T.\n1-4: by eapply trav_step_coherence; eauto; eexists; eauto.\n{\neapply trav_step_coherence.\n{\neexists.\napply TS2.\n}\neapply trav_step_coherence; eauto.\neexists; eauto.\n}\n{\neapply trav_step_coherence.\n{\neexists.\napply TS2.\n}\neapply trav_step_coherence; eauto.\neexists; eauto.\n}\neapply trav_step_coherence.\n{\neexists.\napply TS3.\n}\neapply trav_step_coherence.\n{\neexists.\napply TS2.\n}\neapply trav_step_coherence; eauto.\neexists; eauto.\n"},{"statement":"Lemma sim_trav_steps_coherence (C C' : trav_config) (T : (sim_trav_step G sc)＊ C C')\n      (H : tc_coherent G sc C):\n  tc_coherent G sc C'.","proof":"generalize H.\ninduction T; auto.\nby apply sim_trav_step_coherence.\n"},{"statement":"Lemma sim_trav_step_issued_le (C C' : trav_config) (T : sim_trav_step G sc C C') :\n  issued C ⊆₁ issued C'.","proof":"red in T.\ndestruct T as [thread T].\ndestruct T.\nall: basic_solver.\n"},{"statement":"Lemma sim_trav_steps_issued_le (C C' : trav_config) (T : (sim_trav_step G sc)＊ C C') :\n  issued C ⊆₁ issued C'.","proof":"induction T; auto.\n{\nby apply sim_trav_step_issued_le.\n}\netransitivity; eauto.\n"},{"statement":"Lemma sim_trav_step_covered_le (C C' : trav_config) (T : sim_trav_step G sc C C') :\n  covered C ⊆₁ covered C'.","proof":"red in T.\ndestruct T as [thread T].\ndestruct T.\nall: basic_solver.\n"},{"statement":"Lemma sim_trav_steps_covered_le (C C' : trav_config) (T : (sim_trav_step G sc)＊ C C') :\n  covered C ⊆₁ covered C'.","proof":"induction T; auto.\n{\nby apply sim_trav_step_covered_le.\n}\netransitivity; eauto.\n"},{"statement":"Lemma sim_trav_step_rel_covered (C C' : trav_config) (T : sim_trav_step G sc C C')\n      (RELCOV : W ∩₁ Rel ∩₁ issued C ⊆₁ covered C) :\n  W ∩₁ Rel ∩₁ issued C' ⊆₁ covered C'.","proof":"red in T.\ndestruct T as [thread T].\ndestruct T; simpls.\n1,2,4,6: by etransitivity; eauto; basic_solver.\n{\netransitivity.\n2: by apply RELCOV.\nbasic_solver.\n}\n{\nrewrite set_inter_union_r.\nrewrite RELCOV.\nbasic_solver.\n}\nrewrite set_inter_union_r.\nrewrite RELCOV.\nbasic_solver.\n"},{"statement":"Lemma sim_trav_steps_rel_covered (C C' : trav_config) (T : (sim_trav_step G sc)＊ C C')\n      (RELCOV : W ∩₁ Rel ∩₁ issued C ⊆₁ covered C) :\n  W ∩₁ Rel ∩₁ issued C' ⊆₁ covered C'.","proof":"induction T.\n2: done.\n{\neapply sim_trav_step_rel_covered; eauto.\n}\napply IHT2.\nby apply IHT1.\n"},{"statement":"Lemma sim_trav_step_rmw_covered (C C' : trav_config) (T : sim_trav_step G sc C C')\n      (RMWCOV : forall r w (RMW : rmw r w), covered C r <-> covered C w) :\n  forall r w (RMW : rmw r w), covered C' r <-> covered C' w.","proof":"ins.\nred in T.\ndestruct T as [thread T].\napply (wf_rmwD WF) in RMW.\napply seq_eqv_l in RMW.\ndestruct RMW as [RR RMW].\napply seq_eqv_r in RMW.\ndestruct RMW as [RMW WW].\ndestruct T; simpls.\n{\nspecialize (RMWCOV r w RMW).\nsplit; intros [HH|HH]; left.\nall: type_solver.\n}\n{\nspecialize (RMWCOV r w RMW).\nsplit; intros [HH|HH]; subst; left.\nall: try type_solver.\nexfalso.\napply NRMW.\neexists; eauto.\n}\n{\nby apply RMWCOV.\n}\n{\nspecialize (RMWCOV r w RMW).\nsplit; intros [HH|HH]; subst; left.\nall: try type_solver.\nexfalso.\napply NRMW.\neexists; eauto.\n}\n{\nspecialize (RMWCOV r w RMW).\nsplit; intros [HH|HH]; subst; left.\nall: try type_solver.\nexfalso.\napply NRMW.\neexists; eauto.\n}\n{\nsplit; intros [[HH|HH]|HH]; subst.\n{\nleft.\nleft.\nby apply (RMWCOV r w RMW).\n}\n{\nright.\neapply (wf_rmwf WF); eauto.\n}\n{\napply (dom_r (wf_rmwD WF)) in RMW0.\napply seq_eqv_r in RMW0.\ntype_solver.\n}\n{\nleft.\nleft.\nby apply (RMWCOV r w RMW).\n}\n{\napply (dom_l (wf_rmwD WF)) in RMW0.\napply seq_eqv_l in RMW0.\ntype_solver.\n}\nleft.\nright.\neapply wf_rmw_invf; eauto.\n}\nsplit; intros [[HH|HH]|HH]; subst.\n{\nleft.\nleft.\nby apply (RMWCOV r w RMW).\n}\n{\nright.\neapply (wf_rmwf WF); eauto.\n}\n{\napply (dom_r (wf_rmwD WF)) in RMW0.\napply seq_eqv_r in RMW0.\ntype_solver.\n}\n{\nleft.\nleft.\nby apply (RMWCOV r w RMW).\n}\n{\napply (dom_l (wf_rmwD WF)) in RMW0.\napply seq_eqv_l in RMW0.\ntype_solver.\n}\nleft.\nright.\neapply wf_rmw_invf; eauto.\n"},{"statement":"Lemma sim_trav_steps_rmw_covered (C C' : trav_config) (T : (sim_trav_step G sc)＊ C C')\n      (RMWCOV : forall r w (RMW : rmw r w), covered C r <-> covered C w) :\n  forall r w (RMW : rmw r w), covered C' r <-> covered C' w.","proof":"induction T.\n2: done.\n{\neapply sim_trav_step_rmw_covered; eauto.\n}\napply IHT2.\nby apply IHT1.\n"},{"statement":"Lemma sim_trav_step_in_trav_steps : sim_trav_step G sc ⊆ (trav_step G sc)⁺.","proof":"intros C C' [tid TT].\ninv TT.\n1-4: by apply t_step; eexists; eauto.\n1,2: by eapply t_trans; apply t_step; eexists; eauto.\neapply t_trans.\n2: by apply t_step; eexists; eauto.\neapply t_trans; apply t_step; eexists; eauto.\n"},{"statement":"Lemma isim_trav_step_new_e_tid thread (C C' : trav_config)\n      (T : isim_trav_step G sc thread C C') :\n  covered C' ∪₁ issued C' ≡₁\n  covered C ∪₁ issued C ∪₁ (covered C' ∪₁ issued C') ∩₁ Tid_ thread.","proof":"inv T; simpls.\nall: split; [|basic_solver].\nall: unionL; eauto with hahn.\nall: unionR right.\n1-7,9: basic_solver.\nall: arewrite (tid r = tid w); [|basic_solver].\nall: eapply wf_rmwt; eauto.\n"},{"statement":"Lemma isim_trav_step_new_e_tid_alt thread TC TC' \n      (ITV : isim_trav_step G sc thread TC TC') : \n  covered TC' ∪₁ issued TC' ≡₁ \n    (covered TC ∪₁ issued TC) ∩₁ NTid_ thread ∪₁ (covered TC' ∪₁ issued TC') ∩₁ Tid_ thread.","proof":"assert (sim_trav_step G sc TC TC') as ST by (eexists; eauto).\nrewrite isim_trav_step_new_e_tid at 1; eauto.\nsplit; [|basic_solver].\nrewrite set_subset_union_l.\nsplits.\n2: basic_solver.\nrewrite <- sim_trav_step_covered_le with (C':=TC'); eauto.\nrewrite <- sim_trav_step_issued_le with (C':=TC'); eauto.\napply ntid_tid_set_inter.\n"},{"statement":"Lemma isim_trav_step_new_covered_tid thread TC TC' \n      (ITV : isim_trav_step G sc thread TC TC') : \n  covered TC' ≡₁ \n    covered TC ∩₁ NTid_ thread ∪₁ covered TC' ∩₁ Tid_ thread.","proof":"assert (covered TC ⊆₁ covered TC ∩₁ NTid_ thread ∪₁ covered TC ∩₁ Tid_ thread) as BB.\n{\napply ntid_tid_set_inter.\n}\nassert (sim_trav_step G sc TC TC') as ST by (eexists; eauto).\nsplit.\n2: {\nrewrite sim_trav_step_covered_le with (C':=TC'); eauto.\nbasic_solver.\n}\ninv ITV; simpls; unionL.\nall: try (rewrite BB at 1; basic_solver 10).\nall: try basic_solver 10.\nall: try (apply (wf_rmwt WF) in RMW; rewrite RMW).\nall: basic_solver 10.\n"},{"statement":"Lemma isim_trav_step_new_issued_tid thread TC TC' \n      (ITV : isim_trav_step G sc thread TC TC') : \n  issued TC' ≡₁ \n    issued TC ∩₁ NTid_ thread ∪₁ issued TC' ∩₁ Tid_ thread.","proof":"assert (issued TC ⊆₁ issued TC ∩₁ NTid_ thread ∪₁ issued TC ∩₁ Tid_ thread) as BB.\n{\napply ntid_tid_set_inter.\n}\nassert (sim_trav_step G sc TC TC') as ST by (eexists; eauto).\nsplit.\n2: {\nrewrite sim_trav_step_issued_le with (C':=TC'); eauto.\nbasic_solver.\n}\ninv ITV; simpls; unionL.\nall: try (rewrite BB at 1; basic_solver 10).\n1,2: basic_solver 10.\napply (wf_rmwt WF) in RMW.\nrewrite RMW.\nbasic_solver 10.\n"}]