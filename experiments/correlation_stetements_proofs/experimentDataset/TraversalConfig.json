[{"statement":"Lemma traversal_mon T T'\n        (ICOV : covered T ⊆₁ covered T')\n        (IISS : issued  T ⊆₁ issued  T'):\n    coverable T ⊆₁ coverable T' /\\\n    issuable  T ⊆₁ issuable T'.","proof":"split.\nby unfold coverable; rewrite ICOV, IISS.\nby unfold issuable; rewrite ICOV, IISS.\n"},{"statement":"Lemma same_trav_config_refl : reflexive same_trav_config.","proof":"split; basic_solver.\n"},{"statement":"Lemma same_trav_config_sym : symmetric same_trav_config.","proof":"unfold same_trav_config; split; ins; desf; symmetry; auto.\n"},{"statement":"Lemma same_trav_config_trans : transitive same_trav_config.","proof":"unfold same_trav_config; split; ins; desf; etransitivity; eauto.\n"},{"statement":"Lemma same_tc_extensionality tc1 tc2 (SAME: same_trav_config tc1 tc2):\n    tc1 = tc2.","proof":"destruct SAME.\ndestruct tc1, tc2.\nins.\napply set_extensionality in H, H0.\ncongruence.\n"},{"statement":"Lemma issued_in_issuable : issued T ⊆₁ issuable T.","proof":"apply TCCOH.\n"},{"statement":"Lemma issuableE :\n    issuable T ⊆₁ E.","proof":"unfold issuable; basic_solver.\n"},{"statement":"Lemma issuedE :\n    issued T ⊆₁ E.","proof":"rewrite issued_in_issuable.\nby apply issuableE.\n"},{"statement":"Lemma issuableW :\n    issuable T ⊆₁ W.","proof":"unfold issuable; basic_solver.\n"},{"statement":"Lemma issuedW :\n    issued T ⊆₁ W.","proof":"rewrite issued_in_issuable.\nby apply issuableW.\n"},{"statement":"Lemma covered_in_coverable :\n    covered T ⊆₁ coverable T.","proof":"apply TCCOH.\n"},{"statement":"Lemma coverableE :\n    coverable T ⊆₁ E.","proof":"unfold coverable; basic_solver.\n"},{"statement":"Lemma coveredE :\n    covered T ⊆₁ E.","proof":"rewrite covered_in_coverable.\nby apply coverableE.\n"},{"statement":"Lemma w_coverable_issued :\n    W ∩₁ coverable T ⊆₁ issued T.","proof":"unfold coverable; type_solver.\n"},{"statement":"Lemma w_covered_issued :\n    W ∩₁ covered T ⊆₁ issued T.","proof":"rewrite covered_in_coverable.\nby apply w_coverable_issued.\n"},{"statement":"Lemma init_issued : is_init ∩₁ E ⊆₁ issued T.","proof":"unfolder; ins; desf.\napply w_covered_issued.\nsplit.\n{\nby apply (init_w WF).\n}\ncdes TCCOH; unfolder in ICOV; basic_solver 21.\n"},{"statement":"Lemma init_covered : is_init ∩₁ E ⊆₁ covered T.","proof":"unfolder; ins; desf.\ncdes TCCOH; unfolder in ICOV; basic_solver 21.\n"},{"statement":"Lemma next_n_init e\n        (NEXT : next (covered T) e) :\n    ~ Init e.","proof":"intros HH.\napply NEXT.\napply init_covered.\nsplit; auto.\napply NEXT.\n"},{"statement":"Lemma ar_ct_issuable_is_issued  : \n    dom_rel (⦗W⦘ ⨾ ar⁺ ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"arewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc).\nunfold issuable.\nbasic_solver 20.\n"},{"statement":"Lemma ar_issuable_is_issued  : \n    dom_rel (⦗W⦘ ⨾ ar ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"rewrite ct_step with (r:=ar).\napply ar_ct_issuable_is_issued.\n"},{"statement":"Lemma dom_sb_coverable :\n    dom_rel (sb ⨾ ⦗ coverable T ⦘) ⊆₁ covered T.","proof":"unfold coverable, dom_cond; basic_solver 21.\n"},{"statement":"Lemma sb_coverable :\n    sb ⨾ ⦗ coverable T ⦘ ⊆ ⦗ covered T ⦘ ⨾ sb.","proof":"rewrite (dom_rel_helper dom_sb_coverable).\nbasic_solver.\n"},{"statement":"Lemma dom_sb_covered :\n    dom_rel (sb ⨾ ⦗ covered T ⦘) ⊆₁ covered T.","proof":"rewrite covered_in_coverable at 1.\nseq_rewrite (dom_rel_helper dom_sb_coverable).\nbasic_solver.\n"},{"statement":"Lemma sb_covered :\n    sb ⨾ ⦗ covered T ⦘ ≡ ⦗ covered T ⦘ ⨾ sb ⨾ ⦗ covered T ⦘.","proof":"rewrite (dom_rel_helper dom_sb_covered).\nbasic_solver.\n"},{"statement":"Lemma dom_rf_coverable :\n    dom_rel (rf ⨾ ⦗ coverable T ⦘) ⊆₁ issued T.","proof":"unfold coverable, dom_cond.\nrewrite (dom_r (wf_rfD WF)).\ntype_solver 40.\n"},{"statement":"Lemma dom_rf_covered :\n    dom_rel (rf ⨾ ⦗ covered  T ⦘) ⊆₁ issued T.","proof":"rewrite covered_in_coverable.\napply dom_rf_coverable.\n"},{"statement":"Lemma rf_coverable :\n    rf ⨾ ⦗ coverable T ⦘ ⊆ ⦗ issued T ⦘ ⨾ rf.","proof":"rewrite (dom_rel_helper dom_rf_coverable).\nbasic_solver.\n"},{"statement":"Lemma rf_covered :\n    rf ⨾ ⦗ covered T ⦘ ≡ ⦗ issued T ⦘ ⨾ rf ⨾ ⦗ covered T ⦘.","proof":"rewrite (dom_rel_helper dom_rf_covered).\nbasic_solver.\n"},{"statement":"Lemma dom_sc_coverable :\n    dom_rel (sc ⨾ ⦗ coverable T ⦘) ⊆₁ covered T.","proof":"cdes IMMCON.\nrewrite (dom_r (@wf_scD G sc Wf_sc)).\nunfold coverable, dom_cond; type_solver 42.\n"},{"statement":"Lemma dom_sc_covered :\n    dom_rel (sc ⨾ ⦗ covered T ⦘) ⊆₁ covered T.","proof":"rewrite covered_in_coverable at 1.\nseq_rewrite (dom_rel_helper dom_sc_coverable).\nbasic_solver.\n"},{"statement":"Lemma sc_coverable  :\n    sc ⨾ ⦗ coverable T ⦘ ⊆ ⦗covered T⦘ ⨾ sc.","proof":"seq_rewrite (dom_rel_helper dom_sc_coverable).\nbasic_solver.\n"},{"statement":"Lemma sc_covered  :\n    sc ⨾ ⦗ covered T ⦘ ⊆ ⦗covered T⦘ ⨾ sc.","proof":"rewrite covered_in_coverable at 1.\nby apply sc_coverable.\n"},{"statement":"Lemma ar_coverable_in_CI  :\n    dom_rel (ar ⨾ ⦗coverable T⦘) ⊆₁ covered T ∪₁ issued T.","proof":"unfold imm_s.ar.\nrewrite !seq_union_l.\nrewrite (ar_int_in_sb WF).\narewrite (rfe ⊆ rf).\nrewrite sb_coverable, rf_coverable.\nrewrite sc_coverable.\nbasic_solver.\n"},{"statement":"Lemma ar_C_in_CI  :\n    dom_rel (ar ⨾ ⦗covered T⦘) ⊆₁ covered T ∪₁ issued T.","proof":"rewrite covered_in_coverable at 1.\napply ar_coverable_in_CI.\n"},{"statement":"Lemma ar_rf_ppo_loc_ct_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ (ppo ∩ same_loc))⁺ ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"unfold issuable.\nbasic_solver 10.\n"},{"statement":"Lemma ar_rfrmw_ct_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw)⁺ ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\napply ar_rf_ppo_loc_ct_issuable_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_ct_I_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ (ppo ∩ same_loc))⁺ ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite issued_in_issuable at 1.\napply ar_rf_ppo_loc_ct_issuable_in_I.\n"},{"statement":"Lemma ar_rfrmw_ct_I_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw)⁺ ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply ar_rf_ppo_loc_ct_I_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_rt_I_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ (ppo ∩ same_loc))＊ ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite rtE.\nrewrite !seq_union_l, !seq_union_r, dom_union; unionL.\n{\nbasic_solver.\n}\napply ar_rf_ppo_loc_ct_I_in_I.\n"},{"statement":"Lemma ar_rfrmw_rt_I_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw)＊ ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply ar_rf_ppo_loc_rt_I_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ (ppo ∩ same_loc)) ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"rewrite ct_step with (r := ar ∪ rf ⨾ (ppo ∩ same_loc)).\nby apply ar_rf_ppo_loc_ct_issuable_in_I.\n"},{"statement":"Lemma ar_rfrmw_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw) ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply ar_rf_ppo_loc_issuable_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_I_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ (ppo ∩ same_loc)) ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite ct_step with (r := ar ∪ rf ⨾ (ppo ∩ same_loc)).\nby apply ar_rf_ppo_loc_ct_I_in_I.\n"},{"statement":"Lemma ar_rfrmw_I_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw) ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply ar_rf_ppo_loc_I_in_I.\n"},{"statement":"Lemma ar_ct_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ ar⁺ ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"arewrite (ar ⊆ ar ∪ rf ⨾ rmw).\nby apply ar_rfrmw_ct_issuable_in_I.\n"},{"statement":"Lemma ar_ct_I_in_I  :\n    dom_rel (⦗W⦘ ⨾ ar⁺ ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"arewrite (ar ⊆ ar ∪ rf ⨾ rmw).\nby apply ar_rfrmw_ct_I_in_I.\n"},{"statement":"Lemma ar_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ ar ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"rewrite ct_step with (r:=ar).\nby apply ar_ct_issuable_in_I.\n"},{"statement":"Lemma ar_I_in_I  :\n    dom_rel (⦗W⦘ ⨾ ar ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite ct_step with (r:=ar).\nby apply ar_ct_I_in_I.\n"},{"statement":"Lemma W_ar_coverable_in_I  :\n    dom_rel (⦗W⦘ ⨾ ar ⨾ ⦗coverable T⦘) ⊆₁ issued T.","proof":"rewrite dom_eqv1.\nrewrite ar_coverable_in_CI.\nrewrite set_inter_union_r; unionL.\n2: basic_solver.\napply w_covered_issued.\n"},{"statement":"Lemma W_ar_C_in_I  :\n    dom_rel (⦗W⦘ ⨾ ar ⨾ ⦗covered T⦘) ⊆₁ issued T.","proof":"rewrite covered_in_coverable.\napply W_ar_coverable_in_I.\n"},{"statement":"Lemma W_ar_coverable_issuable_in_CI  :\n    dom_rel (⦗W⦘ ⨾ ar ⨾ ⦗coverable T ∪₁ issuable T⦘) ⊆₁ issued T.","proof":"rewrite id_union, !seq_union_r, dom_union; unionL.\n{\nby apply W_ar_coverable_in_I.\n}\napply ar_issuable_in_I.\n"},{"statement":"Lemma ar_CI_in_CI  :\n    dom_rel (⦗W⦘ ⨾ ar ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite id_union, !seq_union_r, dom_union; unionL.\n{\nby apply W_ar_C_in_I.\n}\napply ar_I_in_I.\n"},{"statement":"Lemma ar_rt_I_in_I  :\n    dom_rel (⦗W⦘ ⨾ ar＊ ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite rtE, !seq_union_l, !seq_union_r, seq_id_l, dom_union.\nunionL; [basic_solver|].\nby apply ar_ct_I_in_I.\n"},{"statement":"Lemma dom_W_sb_coverable_in_I  :\n    dom_rel (⦗W⦘ ⨾ sb ⨾ ⦗coverable T⦘) ⊆₁ issued T.","proof":"rewrite sb_coverable; auto.\netransitivity.\n2: by apply w_covered_issued.\nbasic_solver.\n"},{"statement":"Lemma dom_W_sb_C_in_I  :\n    dom_rel (⦗W⦘ ⨾ sb ⨾ ⦗covered T⦘) ⊆₁ issued T.","proof":"rewrite covered_in_coverable.\napply dom_W_sb_coverable_in_I.\n"},{"statement":"Lemma rf_ppo_loc_coverable_in_I  :\n    dom_rel (rf ⨾ (ppo ∩ same_loc) ⨾ ⦗coverable T⦘) ⊆₁ issued T.","proof":"arewrite (ppo ∩ same_loc ⊆ ppo).\nrewrite (dom_l (wf_rfD WF)), seqA.\nrewrite rfi_union_rfe, !seq_union_l, !seq_union_r, dom_union.\nunionL.\n2: {\nrewrite (dom_r (@wf_ppoD G)), !seqA.\nrewrite <- id_inter.\nrewrite w_coverable_issued.\nsin_rewrite rfe_ppo_in_ar_ct; auto.\nby apply ar_ct_I_in_I.\n}\narewrite (rfi ⊆ sb).\nrewrite (ppo_in_sb WF).\nsin_rewrite sb_sb.\nrewrite dom_W_sb_coverable_in_I; auto.\n"},{"statement":"Lemma rfrmw_coverable_in_I  :\n    dom_rel (rf ⨾ rmw ⨾ ⦗coverable T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply rf_ppo_loc_coverable_in_I.\n"},{"statement":"Lemma rf_ppo_loc_C_in_I  :\n    dom_rel (rf ⨾ (ppo ∩ same_loc) ⨾ ⦗covered T⦘) ⊆₁ issued T.","proof":"rewrite covered_in_coverable.\napply rf_ppo_loc_coverable_in_I.\n"},{"statement":"Lemma rfrmw_C_in_I  :\n    dom_rel (rf ⨾ rmw ⨾ ⦗covered T⦘) ⊆₁ issued T.","proof":"rewrite covered_in_coverable.\napply rfrmw_coverable_in_I.\n"},{"statement":"Lemma rf_ppo_loc_coverable_issuable_in_I  :\n    dom_rel (rf ⨾ (ppo ∩ same_loc) ⨾ ⦗coverable T ∪₁ issuable T⦘) ⊆₁ issued T.","proof":"rewrite id_union, !seq_union_r, dom_union.\nunionL.\n{\napply rf_ppo_loc_coverable_in_I.\n}\nrewrite (dom_l (wf_rfD WF)), !seqA.\narewrite (rf ⨾ ppo ∩ same_loc ⊆ ar ∪ rf ⨾ ppo ∩ same_loc).\nby apply ar_rf_ppo_loc_issuable_in_I.\n"},{"statement":"Lemma rfrmw_coverable_issuable_in_I  :\n    dom_rel (rf ⨾ rmw ⨾ ⦗coverable T ∪₁ issuable T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply rf_ppo_loc_coverable_issuable_in_I.\n"},{"statement":"Lemma rf_ppo_loc_I_in_I  :\n    dom_rel (rf ⨾ (ppo ∩ same_loc) ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite (dom_l (wf_rfD WF)), seqA.\narewrite (rf ⨾ (ppo ∩ same_loc) ⊆ ar ∪ rf ⨾ (ppo ∩ same_loc)).\nby apply ar_rf_ppo_loc_I_in_I.\n"},{"statement":"Lemma rfrmw_I_in_I  :\n    dom_rel (rf ⨾ rmw ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply rf_ppo_loc_I_in_I.\n"},{"statement":"Lemma rf_ppo_loc_rt_I_in_I  :\n    dom_rel ((rf ⨾ ppo ∩ same_loc)＊ ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite rtE.\nrewrite !seq_union_l, !seq_id_l.\nrewrite dom_union.\nunionL; [basic_solver|].\nrewrite (dom_l (wf_rfD WF)).\nrewrite !seqA.\nrewrite inclusion_ct_seq_eqv_l.\nrewrite !seqA.\narewrite (rf ⨾ ppo ∩ same_loc ⊆ ar ∪ rf ⨾ ppo ∩ same_loc).\napply ar_rf_ppo_loc_ct_I_in_I.\n"},{"statement":"Lemma rfrmw_rt_I_in_I  :\n    dom_rel ((rf ⨾ rmw)＊ ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply rf_ppo_loc_rt_I_in_I.\n"},{"statement":"Lemma rf_ppo_loc_CI_in_I  :\n    dom_rel (rf ⨾ (ppo ∩ same_loc) ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite id_union, !seq_union_r, dom_union.\nunionL.\n{\nby apply rf_ppo_loc_C_in_I.\n}\nby apply rf_ppo_loc_I_in_I.\n"},{"statement":"Lemma rfrmw_CI_in_I  :\n    dom_rel (rf ⨾ rmw ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply rf_ppo_loc_CI_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_coverable_in_CI  :\n    dom_rel ((ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗coverable T⦘) ⊆₁ covered T ∪₁ issued T.","proof":"rewrite seq_union_l, dom_union, !seqA.\nunionL.\n{\nby apply ar_coverable_in_CI.\n}\nrewrite rf_ppo_loc_coverable_in_I; eauto with hahn.\n"},{"statement":"Lemma ar_rfrmw_coverable_in_CI  :\n    dom_rel ((ar ∪ rf ⨾ rmw) ⨾ ⦗coverable T⦘) ⊆₁ covered T ∪₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply ar_rf_ppo_loc_coverable_in_CI.\n"},{"statement":"Lemma ar_rf_ppo_loc_C_in_CI  :\n    dom_rel ((ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗covered T⦘) ⊆₁ covered T ∪₁ issued T.","proof":"rewrite covered_in_coverable at 1.\napply ar_rf_ppo_loc_coverable_in_CI.\n"},{"statement":"Lemma ar_rfrmw_C_in_CI  :\n    dom_rel ((ar ∪ rf ⨾ rmw) ⨾ ⦗covered T⦘) ⊆₁ covered T ∪₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply ar_rf_ppo_loc_C_in_CI.\n"},{"statement":"Lemma ar_rf_ppo_loc_coverable_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗coverable T ∪₁ issuable T⦘) ⊆₁ issued T.","proof":"rewrite seq_union_l, seq_union_r, dom_union; unionL.\n{\napply W_ar_coverable_issuable_in_CI.\n}\narewrite_id ⦗W⦘.\nrewrite seq_id_l.\napply rf_ppo_loc_coverable_issuable_in_I.\n"},{"statement":"Lemma ar_rfrmw_coverable_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw) ⨾ ⦗coverable T ∪₁ issuable T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply ar_rf_ppo_loc_coverable_issuable_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_CI_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite seq_union_l, seq_union_r, dom_union; unionL.\n{\napply ar_CI_in_CI.\n}\narewrite_id ⦗W⦘.\nrewrite seq_id_l.\napply rf_ppo_loc_CI_in_I.\n"},{"statement":"Lemma ar_rfrmw_CI_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw) ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\nby apply ar_rf_ppo_loc_CI_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_ct_coverable_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗coverable T ∪₁ issuable T⦘) ⊆₁ issued T.","proof":"intros x [y HH].\ndestruct_seq HH as [AA BB].\napply clos_trans_tn1 in HH.\ninduction HH as [y HH|y z QQ].\n{\neapply ar_rf_ppo_loc_coverable_issuable_in_I.\nbasic_solver 10.\n}\napply clos_tn1_trans in HH.\ndestruct QQ as [QQ|QQ].\n2: {\napply IHHH.\nright.\napply issued_in_issuable.\napply rf_ppo_loc_coverable_issuable_in_I.\nexists z.\napply seqA.\nbasic_solver.\n}\ndestruct BB as [BB|BB].\n2: {\napply ar_rf_ppo_loc_ct_issuable_in_I.\nexists z.\napply seq_eqv_lr.\nsplits; auto.\napply ct_end.\nexists y.\nsplit; auto.\n{\nby apply clos_trans_in_rt.\n}\nby left.\n}\napply IHHH.\ndestruct QQ as [[QQ|QQ]|QQ].\n{\nleft.\napply covered_in_coverable.\napply dom_sc_coverable.\nexists z.\nbasic_solver.\n}\n{\nright.\napply issued_in_issuable.\napply dom_rf_coverable.\nexists z.\ndo 2 red in QQ.\nbasic_solver.\n}\nleft.\napply covered_in_coverable.\napply dom_sb_coverable.\nexists z.\napply seq_eqv_r.\nsplit; auto.\nby apply ar_int_in_sb.\n"},{"statement":"Lemma ar_rfrmw_ct_coverable_issuable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw)⁺ ⨾ ⦗coverable T ∪₁ issuable T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\napply ar_rf_ppo_loc_ct_coverable_issuable_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_ct_CI_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite covered_in_coverable.\nrewrite issued_in_issuable at 1.\napply ar_rf_ppo_loc_ct_coverable_issuable_in_I.\n"},{"statement":"Lemma ar_rfrmw_ct_CI_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw)⁺ ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\napply ar_rf_ppo_loc_ct_CI_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_rt_coverable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊ ⨾ ⦗coverable T⦘) ⊆₁ issued T.","proof":"rewrite rtE.\nrewrite !seq_union_l, !seq_union_r, dom_union, seq_id_l.\nunionL.\n{\ngeneralize w_coverable_issued.\nbasic_solver.\n}\narewrite (coverable T ⊆₁ coverable T ∪₁ issuable T).\napply ar_rf_ppo_loc_ct_coverable_issuable_in_I.\n"},{"statement":"Lemma ar_rfrmw_rt_coverable_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw)＊ ⨾ ⦗coverable T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\napply ar_rf_ppo_loc_rt_coverable_in_I.\n"},{"statement":"Lemma ar_rf_ppo_loc_rt_CI_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊ ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite rtE.\nrewrite !seq_union_l, !seq_union_r, dom_union, seq_id_l.\nunionL.\n{\ngeneralize w_covered_issued.\nbasic_solver.\n}\napply ar_rf_ppo_loc_ct_CI_in_I.\n"},{"statement":"Lemma ar_rfrmw_rt_CI_in_I  :\n    dom_rel (⦗W⦘ ⨾ (ar ∪ rf ⨾ rmw)＊ ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite (rmw_in_ppo_loc WF).\napply ar_rf_ppo_loc_rt_CI_in_I.\n"},{"statement":"Lemma ar_rt_C_in_I  :\n    dom_rel (⦗W⦘ ⨾ ar＊ ⨾ ⦗covered T⦘) ⊆₁ issued T.","proof":"unfolder.\nins.\ndesf.\napply clos_rt_rtn1 in H0.\ninduction H0.\n{\napply w_covered_issued; basic_solver.\n}\napply clos_rtn1_rt in H2.\ndestruct H0 as [[AA|AA]|AA].\n3: {\napply ar_int_in_sb in AA; auto.\napply IHclos_refl_trans_n1.\neapply dom_sb_covered; basic_solver 10.\n}\n{\napply IHclos_refl_trans_n1.\neapply dom_sc_covered; basic_solver 10.\n}\napply ar_rt_I_in_I; auto.\nexists y.\nunfolder; splits; auto.\napply dom_rf_covered; auto.\neexists.\napply seq_eqv_r.\nby split; [apply AA|].\n"},{"statement":"Lemma ar_rt_CI_in_I  :\n    dom_rel (⦗W⦘ ⨾ ar＊ ⨾ ⦗covered T ∪₁ issued T⦘) ⊆₁ issued T.","proof":"rewrite id_union, !seq_union_r, dom_union; unionL.\n{\nby apply ar_rt_C_in_I.\n}\nby apply ar_rt_I_in_I.\n"},{"statement":"Lemma sbCsbI_CsbI   :\n    sb ⨾ ⦗covered T ∪₁ dom_rel (sb^? ⨾ ⦗issued T⦘)⦘ ⊆\n    ⦗covered T ∪₁ dom_rel (sb^? ⨾ ⦗issued T⦘)⦘ ⨾ sb.","proof":"rewrite id_union, !seq_union_r, !seq_union_l.\napply union_mori.\n{\nrewrite sb_covered; eauto.\nbasic_solver.\n}\ngeneralize (@sb_trans G).\nbasic_solver 10.\n"},{"statement":"Lemma issuable_next_w :\n    W ∩₁ next (covered T) ⊆₁ issuable T.","proof":"unfold issuable, next.\nrewrite fwbob_in_bob, bob_in_sb.\napply set_subset_inter_r; split.\n{\nbasic_solver 10.\n}\nrewrite !set_interA.\narewrite (dom_cond sb (covered T) ∩₁ set_compl (covered T) ⊆₁ dom_cond sb (covered T)).\n{\nbasic_solver 10.\n}\nintros e [WW [HH DD]].\nred in DD.\nred.\narewrite (⦗eq e⦘ ⊆ ⦗W⦘ ⨾ ⦗eq e⦘) by basic_solver.\nrewrite ct_end, !seqA.\narewrite (ar ∪ rf ⨾ ppo ∩ same_loc ⊆ (ar ∪ sb)^? ⨾ ar) at 2.\n{\napply inclusion_union_l; [basic_solver|].\nrewrite rfi_union_rfe.\nrewrite rfe_in_ar, ppo_in_ar.\narewrite (rfi ⊆ sb).\nbasic_solver 10.\n}\narewrite (ar ⨾ ⦗W⦘ ⊆ sb).\n{\nunfold imm_s.ar.\nrewrite !seq_union_l.\nrewrite (ar_int_in_sb WF).\nrewrite wf_scD with (sc:=sc); [|by apply IMMCON].\nrewrite (wf_rfeD WF).\ntype_solver.\n}\napply dom_rel_helper_in in DD.\nrewrite DD.\narewrite ((ar ∪ sb)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T ∪₁ issued T⦘ ⨾ (ar ∪ sb)^? ⨾ ⦗covered T⦘).\n2: {\netransitivity.\n2: by apply ar_rf_ppo_loc_rt_CI_in_I.\nbasic_solver 20.\n}\napply dom_rel_helper_in.\nrewrite crE, !seq_union_l, !dom_union, seq_id_l.\nunionL; [basic_solver| |].\n2: rewrite dom_sb_covered; basic_solver.\napply ar_C_in_CI.\n"},{"statement":"Lemma dom_rfe_ppo_issued :\n    dom_rel (rfe ⨾ ppo ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite (dom_l (wf_rfeD WF)).\narewrite (rfe ⊆ ar).\nrewrite ppo_in_ar.\nsin_rewrite ar_ar_in_ar_ct.\nby apply ar_ct_I_in_I.\n"},{"statement":"Lemma dom_ar_ct_issuable : dom_rel (⦗W⦘ ⨾ ar⁺ ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"arewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc).\nunfold issuable.\nbasic_solver 20.\n"},{"statement":"Lemma dom_detour_rfe_ppo_issuable :\n    dom_rel ((detour ∪ rfe) ⨾ ppo ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"rewrite (dom_l (wf_rfeD WF)).\nrewrite (dom_l (wf_detourD WF)).\narewrite (rfe ⊆ ar).\narewrite (detour ⊆ ar).\nrelsf.\nrewrite ppo_in_ar, !seqA.\nsin_rewrite ar_ar_in_ar_ct.\napply dom_ar_ct_issuable.\n"},{"statement":"Lemma dom_detour_rfe_ppo_issued :\n    dom_rel ((detour ∪ rfe) ⨾ ppo ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite issued_in_issuable at 1.\napply dom_detour_rfe_ppo_issuable.\n"},{"statement":"Lemma dom_detour_rfe_acq_sb_issuable :\n    dom_rel ((detour ∪ rfe) ⨾ ⦗R ∩₁ Acq⦘ ⨾ sb ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"rewrite (dom_l (wf_detourD WF)).\nrewrite (dom_l (wf_rfeD WF)).\narewrite (rfe ⊆ ar).\narewrite (detour ⊆ ar).\nrelsf.\narewrite (⦗R ∩₁ Acq⦘ ⨾ sb ⊆ ar).\n{\narewrite (⦗R ∩₁ Acq⦘ ⨾ sb ⊆ bob).\nunfold imm_s.ar, ar_int.\neauto with hahn.\n}\nsin_rewrite ar_ar_in_ar_ct.\napply dom_ar_ct_issuable.\n"},{"statement":"Lemma dom_detour_rfe_acq_sb_issued :\n    dom_rel ((detour ∪ rfe) ⨾ ⦗R ∩₁ Acq⦘ ⨾ sb ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite issued_in_issuable at 1.\napply dom_detour_rfe_acq_sb_issuable.\n"},{"statement":"Lemma dom_detour_rmwrfi_rfe_acq_sb_issuable :\n    dom_rel ((detour ∪ rfe) ⨾ (rmw ⨾ rfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ sb ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"arewrite (⦗R ∩₁ Acq⦘ ⊆ ⦗Acq⦘ ⨾ ⦗R ∩₁ Acq⦘) by basic_solver.\narewrite (rfi ⊆ rf).\nsin_rewrite (@rmwrf_rt_Acq_in_ar_rfrmw_rt G WF sc); auto.\nrewrite (dom_l (wf_detourD WF)).\nrewrite (dom_l (wf_rfeD WF)).\narewrite (rfe ⊆ ar).\narewrite (detour ⊆ ar).\nrelsf.\narewrite (⦗R ∩₁ Acq⦘ ⨾ sb ⊆ ar).\n{\narewrite (⦗R ∩₁ Acq⦘ ⨾ sb ⊆ bob).\nunfold imm_s.ar, ar_int.\neauto with hahn.\n}\narewrite (ar ⊆ ar ∪ rf ⨾ rmw) at 3.\narewrite (ar ⊆ ar ∪ rf ⨾ rmw) at 1.\nseq_rewrite <- ct_end.\narewrite ((ar ∪ rf ⨾ rmw) ⨾ (ar ∪ rf ⨾ rmw)⁺ ⊆ (ar ∪ rf ⨾ rmw)⁺).\n{\nrewrite ct_step with (r:= ar ∪ rf ⨾ rmw) at 1.\napply ct_ct.\n}\napply ar_rfrmw_ct_issuable_in_I.\n"},{"statement":"Lemma dom_detour_rmwrfi_rfe_acq_sb_issued :\n    dom_rel ((detour ∪ rfe) ⨾ (rmw ⨾ rfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ sb ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite issued_in_issuable at 1.\napply dom_detour_rmwrfi_rfe_acq_sb_issuable.\n"},{"statement":"Lemma dom_rfe_acq_sb_issuable :\n    dom_rel (rfe ⨾ ⦗R ∩₁ Acq⦘ ⨾ sb ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"arewrite (rfe ⊆ detour ∪ rfe).\napply dom_detour_rfe_acq_sb_issuable.\n"},{"statement":"Lemma dom_rfe_acq_sb_issued :\n    dom_rel (rfe ⨾ ⦗R ∩₁ Acq⦘ ⨾ sb ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite issued_in_issuable at 1.\napply dom_rfe_acq_sb_issuable.\n"},{"statement":"Lemma dom_wex_sb_issuable :\n    dom_rel (⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗issuable T⦘) ⊆₁ issued T.","proof":"arewrite (⦗W_ex_acq⦘ ⊆ ⦗W⦘ ⨾ ⦗W_ex_acq⦘).\n{\nrewrite <- seq_eqvK at 1.\nrewrite (W_ex_in_W WF) at 1.\nbasic_solver.\n}\narewrite (⦗issuable T⦘ ⊆ ⦗W⦘ ⨾ ⦗issuable T⦘).\n{\nunfold issuable.\nbasic_solver 10.\n}\narewrite (⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ar).\napply ar_issuable_is_issued.\n"},{"statement":"Lemma dom_wex_sb_issued :\n    dom_rel (⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗issued T⦘) ⊆₁ issued T.","proof":"rewrite issued_in_issuable at 1.\napply dom_wex_sb_issuable.\n"},{"statement":"Lemma rf_rmw_issued_rfi_rmw_issued : \n    (rf ⨾ rmw)＊ ⨾ ⦗issued T⦘ ⊆ (rfi ⨾ rmw)＊ ⨾ ⦗issued T⦘ ⨾ (rf ⨾ rmw)＊.","proof":"assert (transitive sb) as SBT by apply sb_trans.\neapply rt_ind_left with (P:= fun r => r ⨾ ⦗issued T⦘).\n{\nby eauto with hahn.\n}\n{\nbasic_solver 12.\n}\nintros k H; rewrite !seqA.\nsin_rewrite H.\nrewrite rfi_union_rfe at 1; relsf; unionL.\nrewrite <- seqA; seq_rewrite <- ct_begin; basic_solver 12.\nrewrite rtE at 2.\nrelsf; unionR left.\narewrite (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊ ⨾ ⦗issued T⦘ ⊆                  ⦗issued T⦘ ⨾ rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊ ⨾ ⦗issued T⦘).\n{\napply dom_rel_helper.\narewrite (rmw ⨾ (rfi ⨾ rmw)＊ ⊆ ar＊).\n{\narewrite (rfi ⊆ rf).\nrewrite (rmw_in_ppo WF) at 1.\nrewrite ppo_in_ar.\nrewrite rtE at 1.\nrewrite seq_union_r, seq_id_r.\napply inclusion_union_l.\n{\nrewrite ct_step at 1.\napply inclusion_t_rt.\n}\nrewrite rmw_in_ppo_loc; auto.\nrewrite ar_rf_ppo_loc_ct_in_ar_ct; auto.\napply inclusion_t_rt.\n}\nrewrite (dom_l (wf_rfeD WF)), !seqA.\narewrite (rfe ⊆ ar) at 1.\nseq_rewrite <- ct_begin.\nby apply ar_ct_I_in_I.\n}\narewrite (rfe ⨾ rmw ⊆ rf ⨾ rmw).\narewrite (rfi ⊆ rf).\narewrite (rf ⨾ rmw ⨾ (rf ⨾ rmw)＊ ⊆ (rf ⨾ rmw)⁺).\n{\nrewrite <- seqA.\napply ct_begin.\n}\narewrite_id ⦗issued T⦘ at 2.\nrewrite seq_id_l.\nrewrite ct_rt.\nby rewrite inclusion_t_rt.\n"},{"statement":"Lemma wex_rfi_rfe_rmw_issuable_is_issued :\n    dom_rel ((⦗ W_ex_acq ⦘ ⨾ rfi ∪ rfe) ⨾ rmw ⨾ ⦗ issuable T ⦘) ⊆₁ issued T.","proof":"rewrite seq_union_l.\nrewrite dom_union.\napply set_subset_union_l; split.\n{\nrewrite seqA.\nrewrite (rfi_in_sbloc' WF).\nrewrite (rmw_in_sb WF).\narewrite (sb ∩ same_loc ⨾ sb ⊆ sb).\n{\ngeneralize (@sb_trans G).\nbasic_solver.\n}\narewrite (⦗issuable T⦘ ⊆ ⦗W⦘ ⨾ ⦗issuable T⦘).\n{\nunfold issuable.\nbasic_solver 10.\n}\narewrite (⦗W_ex_acq⦘ ⊆ ⦗W⦘ ⨾ ⦗W_ex_acq⦘).\n{\nrewrite <- seq_eqvK at 1.\nrewrite (W_ex_in_W WF) at 1.\nbasic_solver.\n}\narewrite (⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ar).\nrewrite ct_step with (r:=ar).\nunfold issuable.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nbasic_solver 10.\n}\nrewrite (rmw_in_ppo WF).\nrewrite ppo_in_ar.\nrewrite (dom_l (wf_rfeD WF)), !seqA.\narewrite (rfe ⊆ ar).\nsin_rewrite ar_ar_in_ar_ct.\nunfold issuable.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nbasic_solver 10.\n"},{"statement":"Lemma wex_rfi_rfe_rmw_issued_is_issued :\n    dom_rel ((⦗ W_ex_acq ⦘ ⨾ rfi ∪ rfe) ⨾ rmw ⨾ ⦗ issued T ⦘) ⊆₁ issued T.","proof":"rewrite issued_in_issuable at 1; auto.\nby apply wex_rfi_rfe_rmw_issuable_is_issued.\n"},{"statement":"Lemma wex_rf_rmw_issued_is_issued :\n    dom_rel (⦗ W_ex_acq ⦘ ⨾ rf ⨾ rmw ⨾ ⦗ issued T ⦘) ⊆₁ issued T.","proof":"arewrite (⦗W_ex_acq⦘ ⨾ rf ⊆ (⦗ W_ex_acq ⦘ ⨾ rfi ∪ rfe)).\n{\nrewrite rfi_union_rfe.\nbasic_solver.\n}\nby apply wex_rfi_rfe_rmw_issued_is_issued.\n"},{"statement":"Lemma rf_rmw_issued :\n    (rf ⨾ rmw)＊ ⨾ ⦗issued T⦘ ⊆ (rf ⨾ rmw ⨾ ⦗issued T⦘)＊.","proof":"intros x y HH.\ndestruct_seq_r HH as II.\napply clos_rt_rtn1 in HH.\ninduction HH as [|y z TT].\n{\napply rt_refl.\n}\napply rt_end.\nright.\nexists y.\nsplit.\n2: apply seqA; basic_solver.\napply IHHH.\napply ar_rfrmw_I_in_I.\nexists z.\napply seq_eqv_lr.\nsplits; auto.\n2: by right.\nred in TT.\ndesf.\napply (wf_rfD WF) in TT.\nunfolder in TT.\ndesf.\n"},{"statement":"Lemma dom_W_Rel_sb_loc_I_in_C :\n    dom_rel (⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⨾ ⦗issued T⦘) ⊆₁ covered T.","proof":"rewrite issued_in_issuable.\narewrite (⦗issuable T⦘ ⊆ ⦗dom_cond fwbob (covered T)⦘).\n{\nunfold issuable.\nbasic_solver 10.\n}\nrewrite <- !seqA.\nrewrite dom_cond_elim1; [basic_solver 21|].\nunfold imm_bob.fwbob.\nbasic_solver 12.\n"},{"statement":"Lemma I_eq_EW_I : issued T ≡₁ E ∩₁ W ∩₁ issued T.","proof":"split; [|clear; basic_solver].\ngeneralize issuedW, issuedE.\nbasic_solver.\n"},{"statement":"Lemma W_rel_sb_loc_W_CI :\n    (⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘) ⨾ ⦗covered T ∪₁ issued T⦘ ⊆\n    ⦗covered T ∪₁ issued T⦘ ⨾ (⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘).","proof":"rewrite !seqA.\narewrite (⦗W⦘ ⨾ ⦗covered T ∪₁ issued T⦘ ⊆ ⦗W⦘ ⨾ ⦗issued T⦘).\n{\ngeneralize w_covered_issued.\nbasic_solver.\n}\ngeneralize dom_W_Rel_sb_loc_I_in_C.\nbasic_solver 12.\n"},{"statement":"Lemma sb_W_rel_CI (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) :\n    (sb ⨾ ⦗W ∩₁ Rel⦘) ⨾ ⦗covered T ∪₁ issued T⦘ ⊆ ⦗covered T ∪₁ issued T⦘ ⨾ (sb ⨾ ⦗W ∩₁ Rel⦘).","proof":"generalize RELCOV, dom_sb_covered.\nbasic_solver 12.\n"},{"statement":"Lemma W_Rel_sb_loc_I : dom_rel (⦗W ∩₁ Rel⦘ ⨾  (sb ∩ same_loc) ⨾ ⦗W ∩₁ issued T⦘) ⊆₁ issued T.","proof":"generalize dom_W_Rel_sb_loc_I_in_C, w_covered_issued.\nbasic_solver 21.\n"},{"statement":"Lemma sb_loc_issued  :\n    ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⨾ ⦗issued T⦘ ⊆ \n               ⦗covered T⦘ ⨾ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proof":"seq_rewrite (dom_rel_helper dom_W_Rel_sb_loc_I_in_C).\nbasic_solver.\n"},{"statement":"Lemma dom_F_sb_I_in_C :\n    dom_rel (⦗F ∩₁ Acq/Rel⦘ ⨾ sb ⨾ ⦗issued T⦘) ⊆₁ covered T.","proof":"rewrite issued_in_issuable.\narewrite (⦗issuable T⦘ ⊆ ⦗dom_cond fwbob (covered T)⦘).\n{\nunfold issuable.\nbasic_solver 10.\n}\nrewrite <- !seqA.\nrewrite dom_cond_elim1; [basic_solver 21|].\nunfold imm_bob.fwbob.\nbasic_solver 12.\n"},{"statement":"Lemma F_sb_I_in_C  :\n    ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ⨾ ⦗issued T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb.","proof":"seq_rewrite (dom_rel_helper dom_F_sb_I_in_C).\nbasic_solver.\n"},{"statement":"Lemma dom_F_Rel_sb_I_in_C :  dom_rel (⦗F ∩₁ Rel⦘ ⨾  sb ⨾ ⦗issued T⦘) ⊆₁ covered T.","proof":"etransitivity; [|apply dom_F_sb_I_in_C]; mode_solver 21.\n"},{"statement":"Lemma dom_F_Acq_sb_I_in_C :  dom_rel (⦗F ∩₁ Acq⦘ ⨾  sb ⨾ ⦗issued T⦘) ⊆₁ covered T.","proof":"etransitivity; [|apply dom_F_sb_I_in_C]; mode_solver 12.\n"},{"statement":"Lemma coverable_add_eq_iff e:\n    coverable T e <-> coverable (mkTC (covered T ∪₁ eq e) (issued T)) e.","proof":"split.\n{\neapply traversal_mon; simpls.\neauto with hahn.\n}\nunfold coverable; simpls.\nintros [[EE COVE] HH].\nsplit.\n{\nclear HH.\nsplit; auto.\nunfolder in *.\nins.\ndesf.\nedestruct COVE.\n{\neexists; eauto.\n}\n{\ndone.\n}\nexfalso.\ndesf.\neapply sb_irr; eauto.\n}\ndestruct HH as [[HH|HH]|[AA HH]]; [do 2 left| left;right|right]; auto.\nsplit; auto.\nunfolder in *.\nins.\ndesf.\nedestruct HH.\n{\neexists; eauto.\n}\n{\ndone.\n}\nexfalso.\ndesf.\neapply sc_irr; eauto.\napply IMMCON.\n"},{"statement":"Lemma issuable_add_eq_iff e :\n    issuable T e <-> issuable (mkTC (covered T) (issued T ∪₁ eq e)) e.","proof":"cdes IMMCON.\nsplit.\n{\neapply traversal_mon; simpls.\neauto with hahn.\n}\nunfold issuable; simpls.\nintros [[EE ISSE] HH].\nunfold dom_cond in *.\nsplit; [split|]; auto.\nall: intros x BB; set (CC:=BB).\napply HH in CC.\ndestruct CC; desf.\nexfalso; clear -BB WF IMMCON.\nunfolder in *; desf.\neapply ar_rf_ppo_loc_acyclic; eauto.\napply IMMCON.\n"},{"statement":"Lemma dom_release_issued :\n    dom_rel (release ⨾ ⦗ issued T ⦘) ⊆₁ covered T.","proof":"unfold imm_s_hb.release, imm_s_hb.rs.\nrewrite !seqA.\nsin_rewrite rf_rmw_issued_rfi_rmw_issued.\nrewrite (dom_r (wf_rmwD WF)) at 1.\narewrite (⦗W⦘ ⨾ (rfi ⨾ rmw ⨾ ⦗W⦘)＊ ⊆ (rfi ⨾ rmw)＊ ⨾ ⦗W⦘).\n{\nrewrite rtE; relsf; unionL; [basic_solver|].\nrewrite <- seqA; rewrite inclusion_ct_seq_eqv_r; basic_solver.\n}\nrewrite (rmw_in_sb_loc WF) at 1; rewrite (rfi_in_sbloc' WF).\ngeneralize (@sb_same_loc_trans G); ins; relsf.\nrewrite !crE; relsf; unionL; splits.\n{\nrevert RELCOV; basic_solver 21.\n}\n{\ngeneralize dom_W_Rel_sb_loc_I_in_C.\nbasic_solver 21.\n}\n2: generalize (@sb_trans G).\nall: generalize dom_F_Rel_sb_I_in_C; basic_solver 40.\n"},{"statement":"Lemma release_issued :\n    release ⨾ ⦗ issued T ⦘ ⊆ ⦗covered T⦘ ⨾ release.","proof":"seq_rewrite (dom_rel_helper dom_release_issued).\nbasic_solver.\n"},{"statement":"Lemma dom_release_rf_coverable :\n    dom_rel (release ⨾ rf ⨾ ⦗ coverable T ⦘) ⊆₁ covered T.","proof":"generalize dom_release_issued.\ngeneralize dom_rf_coverable.\nbasic_solver 21.\n"},{"statement":"Lemma release_rf_coverable :\n    release ⨾ rf ⨾ ⦗ coverable T ⦘ ⊆ ⦗ covered T ⦘ ⨾ release ⨾ rf.","proof":"seq_rewrite (dom_rel_helper dom_release_rf_coverable).\nbasic_solver.\n"},{"statement":"Lemma release_rf_covered :\n    release ⨾ rf ⨾ ⦗ covered T ⦘ ⊆ ⦗ covered T ⦘ ⨾ release ⨾ rf.","proof":"rewrite covered_in_coverable at 1.\nby apply release_rf_coverable.\n"},{"statement":"Lemma dom_sb_W_rel_issued  :\n    dom_rel (sb ⨾ ⦗W ∩₁ Rel⦘ ⨾ ⦗issued T⦘) ⊆₁ covered T.","proof":"rewrite issued_in_issuable.\narewrite (⦗issuable T⦘ ⊆ ⦗dom_cond fwbob (covered T)⦘).\n{\nunfold issuable.\nbasic_solver 10.\n}\nrewrite <- !seqA.\nrewrite dom_cond_elim1; [basic_solver 21|].\nunfold imm_bob.fwbob.\nbasic_solver 12.\n"},{"statement":"Lemma sb_W_rel_issued  :\n    sb ⨾ ⦗W ∩₁ Rel⦘ ⨾ ⦗issued T⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗W ∩₁ Rel⦘.","proof":"seq_rewrite (dom_rel_helper dom_sb_W_rel_issued).\nbasic_solver.\n"},{"statement":"Lemma dom_sw_coverable :\n    dom_rel (sw ⨾ ⦗ coverable T ⦘) ⊆₁ covered T.","proof":"unfold imm_s_hb.sw.\ngeneralize dom_sb_coverable.\ngeneralize dom_release_rf_coverable.\ngeneralize covered_in_coverable.\nbasic_solver 21.\n"},{"statement":"Lemma sw_coverable : sw ⨾ ⦗ coverable T ⦘ ⊆ ⦗covered T⦘ ⨾ sw.","proof":"seq_rewrite (dom_rel_helper dom_sw_coverable).\nbasic_solver.\n"},{"statement":"Lemma sw_covered : sw ⨾ ⦗ covered T ⦘ ⊆ ⦗covered T⦘ ⨾ sw.","proof":"rewrite covered_in_coverable at 1.\nby apply sw_coverable.\n"},{"statement":"Lemma hb_coverable : hb ⨾ ⦗ coverable T ⦘ ⊆ ⦗covered T⦘ ⨾ hb.","proof":"unfold imm_s_hb.hb.\nassert (A: (sb ∪ sw) ⨾ ⦗coverable T⦘ ⊆ ⦗covered T⦘ ⨾ (sb ∪ sw)⁺).\n{\nrelsf.\nrewrite sb_coverable, sw_coverable.\nrewrite <- ct_step; basic_solver.\n}\nunfold imm_s_hb.hb.\neapply ct_ind_left with (P:= fun r => r ⨾ ⦗coverable T⦘); eauto with hahn.\nintros k H; rewrite !seqA, H.\nrewrite covered_in_coverable at 1.\nsin_rewrite A.\narewrite ((sb ∪ sw)⁺ ⊆ (sb ∪ sw)＊) at 1.\nrelsf.\n"},{"statement":"Lemma sc_sb_I_dom_C  :\n  dom_rel (sc ⨾ sb ⨾ ⦗issued T⦘) ⊆₁ covered T.","proof":"cdes IMMCON.\nrewrite (dom_r (wf_scD Wf_sc)).\nunfolder.\nins.\ndesf.\ncdes TCCOH.\nassert (covered T z) as AA.\n2: {\napply CC in AA.\nred in AA.\nunfolder in AA.\ndesf.\n1,2: type_solver.\neapply AA2.\neexists.\napply seq_eqv_r.\nsplit; eauto.\n}\neapply II; eauto.\neexists.\napply seq_eqv_r.\nsplit; eauto.\napply sb_from_f_in_fwbob.\napply seq_eqv_l.\nsplit; [split|]; auto.\nmode_solver.\n"},{"statement":"Lemma dom_hb_coverable :\n    dom_rel (hb ⨾ ⦗ coverable T ⦘) ⊆₁ covered T.","proof":"rewrite hb_coverable; basic_solver 10.\n"},{"statement":"Lemma hb_covered :\n    hb ⨾ ⦗ covered T ⦘ ⊆ ⦗covered T⦘ ⨾ hb.","proof":"rewrite covered_in_coverable at 1.\nby apply hb_coverable.\n"},{"statement":"Lemma dom_urr_coverable l:\n    dom_rel (urr l ⨾ ⦗ coverable T ⦘) ⊆₁ issued T.","proof":"unfold CombRelations.urr.\ngeneralize dom_hb_coverable.\ngeneralize dom_sc_coverable.\ngeneralize dom_rf_coverable.\ngeneralize covered_in_coverable.\ngeneralize w_coverable_issued.\nbasic_solver 21.\n"},{"statement":"Lemma urr_coverable l:\n    urr l ⨾ ⦗ coverable T ⦘ ⊆ ⦗issued T⦘ ⨾ urr l.","proof":"rewrite (dom_rel_helper (@dom_urr_coverable l)).\nbasic_solver.\n"},{"statement":"Lemma urr_covered l:\n    urr l ⨾ ⦗ covered T ⦘ ⊆ ⦗issued T⦘ ⨾ urr l.","proof":"rewrite covered_in_coverable at 1.\nby apply urr_coverable.\n"},{"statement":"Lemma dom_c_acq_coverable i l A:\n    dom_rel (c_acq i l A ⨾ ⦗ coverable T ⦘) ⊆₁ issued T.","proof":"unfold CombRelations.c_acq.\ngeneralize (@dom_urr_coverable l).\ngeneralize covered_in_coverable.\ngeneralize dom_release_issued.\ngeneralize dom_rf_coverable.\nbasic_solver 21.\n"},{"statement":"Lemma c_acq_coverable i l A:\n    c_acq i l A ⨾ ⦗ coverable T ⦘ ⊆ ⦗issued T⦘ ⨾ c_acq i l A.","proof":"rewrite (dom_rel_helper (@dom_c_acq_coverable i l A)).\nbasic_solver.\n"},{"statement":"Lemma c_acq_covered i l A:\n    c_acq i l A ⨾ ⦗ covered T ⦘ ⊆ ⦗issued T⦘ ⨾ c_acq i l A.","proof":"rewrite covered_in_coverable  at 1.\nby apply c_acq_coverable.\n"},{"statement":"Lemma dom_c_cur_coverable i l A:\n    dom_rel (c_cur i l A ⨾ ⦗ coverable T ⦘) ⊆₁ issued T.","proof":"unfold CombRelations.c_cur.\ngeneralize (@dom_urr_coverable l).\nbasic_solver 21.\n"},{"statement":"Lemma c_cur_coverable i l A:\n    c_cur i l A ⨾ ⦗ coverable T ⦘ ⊆ ⦗issued T⦘ ⨾ c_cur i l A.","proof":"seq_rewrite (dom_rel_helper (@dom_c_cur_coverable i l A)).\nbasic_solver.\n"},{"statement":"Lemma c_cur_covered i l A:\n    c_cur i l A ⨾ ⦗ covered T ⦘ ⊆ ⦗issued T⦘ ⨾ c_cur i l A.","proof":"rewrite covered_in_coverable at 1.\nby apply c_cur_coverable.\n"},{"statement":"Lemma dom_c_rel_coverable i l l' A:\n    dom_rel (c_rel i l l' A ⨾ ⦗ coverable T ⦘) ⊆₁ issued T.","proof":"unfold CombRelations.c_rel.\ngeneralize (@dom_urr_coverable l).\nbasic_solver 21.\n"},{"statement":"Lemma c_rel_coverable i l l' A:\n    c_rel i l l' A ⨾ ⦗ coverable T ⦘ ⊆ ⦗issued T⦘ ⨾ c_rel i l l' A.","proof":"seq_rewrite (dom_rel_helper (@dom_c_rel_coverable i l l' A)).\nbasic_solver.\n"},{"statement":"Lemma c_rel_covered i l l' A:\n    c_rel i l l' A ⨾ ⦗ covered T ⦘ ⊆ ⦗issued T⦘ ⨾ c_rel i l l' A.","proof":"rewrite covered_in_coverable at 1.\nby apply c_rel_coverable.\n"},{"statement":"Lemma t_acq_coverable l thread:\n    t_acq thread l (coverable T) ⊆₁ issued T.","proof":"unfold CombRelations.t_acq.\nrewrite (dom_r (wf_c_acqD G sc thread l (coverable T))).\narewrite (⦗(Tid_ thread ∪₁ Init) ∩₁ coverable T⦘ ⊆ ⦗coverable T⦘) by basic_solver.\nrewrite c_acq_coverable.\nbasic_solver.\n"},{"statement":"Lemma t_acq_covered l thread:\n    t_acq thread l (covered T) ⊆₁ issued T.","proof":"rewrite covered_in_coverable at 1.\nby apply t_acq_coverable.\n"},{"statement":"Lemma t_cur_coverable l thread:\n    t_cur thread l (coverable T) ⊆₁ issued T.","proof":"etransitivity; [by apply t_cur_in_t_acq|].\nby apply t_acq_coverable.\n"},{"statement":"Lemma t_cur_covered l thread:\n    t_cur thread l (covered T) ⊆₁ issued T.","proof":"rewrite covered_in_coverable at 1.\nby apply t_cur_coverable.\n"},{"statement":"Lemma t_rel_coverable l l' thread:\n    t_rel thread l l' (coverable T) ⊆₁ issued T.","proof":"etransitivity; [by apply t_rel_in_t_cur|].\nby apply t_cur_coverable.\n"},{"statement":"Lemma t_rel_covered l l' thread:\n    t_rel thread l l' (covered T) ⊆₁ issued T.","proof":"rewrite covered_in_coverable at 1.\nby apply t_rel_coverable.\n"},{"statement":"Lemma S_tm_coverable l :\n    S_tm l (coverable T) ⊆₁ issued T.","proof":"unfold CombRelations.S_tm, CombRelations.S_tmr.\ngeneralize dom_hb_coverable.\ngeneralize w_coverable_issued.\ngeneralize covered_in_coverable.\ngeneralize dom_release_issued.\ngeneralize dom_rf_coverable.\nbasic_solver 21.\n"},{"statement":"Lemma S_tm_covered l:\n    S_tm l (covered T) ⊆₁ issued T.","proof":"rewrite covered_in_coverable at 1.\nby apply S_tm_coverable.\n"},{"statement":"Lemma msg_rel_issued l:\n    dom_rel (msg_rel l ⨾ ⦗ issued T ⦘) ⊆₁ issued T.","proof":"unfold CombRelations.msg_rel.\ngeneralize dom_release_issued.\ngeneralize (@dom_urr_coverable l).\ngeneralize covered_in_coverable.\nbasic_solver 21.\n"},{"statement":"Lemma exists_ncov thread (FINDOM : set_finite E) :\n  exists n, ~ covered T (ThreadEvent thread n).","proof":"destruct (exists_nE G FINDOM thread) as [n HH].\nexists n.\nintros CC.\napply HH.\neapply coveredE; eauto.\n"},{"statement":"Lemma sw_in_Csw_sb :\n  sw ⨾ ⦗C ∪₁ dom_rel (sb^? ⨾ ⦗ I ⦘)⦘ ⊆ ⦗ C ⦘ ⨾ sw ∪ sb.","proof":"rewrite !id_union.\nrewrite seq_union_r.\nunionL.\n{\nrewrite sw_covered; eauto.\nbasic_solver.\n}\nassert (forall (s : actid -> Prop), s ∪₁ set_compl s ≡₁ fun _ => True) as AA.\n{\nsplit; [basic_solver|].\nunfolder.\nins.\napply classic.\n}\narewrite (sw ⊆ ⦗ C ∪₁ set_compl C ⦘ ⨾ sw) at 1.\n{\nrewrite AA.\nby rewrite seq_id_l.\n}\nrewrite id_union, !seq_union_l.\napply union_mori; [basic_solver|].\nrewrite (dom_r (wf_swD WF)).\nrewrite sw_in_ar0; auto.\nremember (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⨾ (rfe ∪ ar_int G)⁺) as ax.\nrewrite !seq_union_l, !seq_union_r.\nunionL; [|basic_solver].\nsubst ax.\nrewrite !seqA.\narewrite ((sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⨾ ⦗W⦘) by basic_solver.\narewrite (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ release).\n{\nunfold imm_s_hb.release, imm_s_hb.rs.\nby rewrite <- inclusion_id_rt, seq_id_r.\n}\nenough (dom_rel (⦗W⦘ ⨾ (rfe ∪ ar_int G)⁺ ⨾ ⦗FR ∩₁ Acq⦘ ⨾ ⦗dom_rel (sb^? ⨾ ⦗I⦘)⦘) ⊆₁ I) as BB.\n{\nrewrite (dom_rel_helper BB).\nseq_rewrite (dom_rel_helper dom_release_issued).\nbasic_solver.\n}\nrewrite <- !seqA.\nrewrite dom_rel_eqv_dom_rel.\nrewrite !seqA.\narewrite (⦗FR ∩₁ Acq⦘ ⨾ sb^? ⊆ (rfe ∪ ar_int G)^?).\n{\nrewrite !crE, !seq_union_r.\napply union_mori; [basic_solver|].\nunionR right.\nrewrite set_inter_union_l, id_union, seq_union_l.\nrewrite sb_from_r_acq_in_bob.\narewrite (Acq ⊆₁ Acq/Rel) by mode_solver.\nrewrite sb_from_f_in_bob.\nrewrite bob_in_ar_int.\neauto with hahn.\n}\nseq_rewrite ct_cr.\narewrite (rfe ∪ ar_int G ⊆ ar).\nby apply ar_ct_I_in_I.\n"},{"statement":"Lemma hb_in_Chb_sb :\n  hb ⨾ ⦗C ∪₁ dom_rel (sb^? ⨾ ⦗ I ⦘)⦘ ⊆ ⦗ C ⦘ ⨾ hb ∪ sb.","proof":"unfold imm_s_hb.hb.\nintros x y HH.\ndestruct_seq_r HH as DOM.\napply clos_trans_tn1 in HH.\ninduction HH as [y [HH|HH]|y z AA].\n{\nby right.\n}\n{\nassert ((⦗C⦘ ⨾ sw ∪ sb) x y) as [ZZ|ZZ].\n3: by right.\n2: {\ndestruct_seq_l ZZ as CX.\nleft.\napply seq_eqv_l.\nsplit; auto.\napply ct_step.\nby right.\n}\napply sw_in_Csw_sb; auto.\napply seq_eqv_r.\nsplits; auto.\n}\nassert (sb y z -> (C ∪₁ dom_rel (sb^? ⨾ ⦗I⦘)) y) as DOMY.\n{\nintros SB.\ndestruct DOM as [DOM|DOM].\n2: {\nright.\ngeneralize (@sb_trans G) SB DOM.\nbasic_solver 10.\n}\nleft.\neapply dom_sb_covered; eauto.\neexists.\napply seq_eqv_r.\nsplit; eauto.\n}\nassert ((C ∪₁ dom_rel (sb^? ⨾ ⦗I⦘)) y) as BB.\n2: {\nset (CC:=BB).\napply IHHH in CC.\ndestruct CC as [CC|CC].\n{\nleft.\ndestruct_seq_l CC as XX.\napply seq_eqv_l.\nsplit; auto.\napply ct_ct.\nexists y.\nsplit; eauto; try by apply ct_step.\n}\ndestruct AA as [AA|AA].\n{\nright.\neapply (@sb_trans G); eauto.\n}\nassert ((sw ⨾ ⦗C ∪₁ dom_rel (sb^? ⨾ ⦗I⦘)⦘) y z) as DD.\n{\napply seq_eqv_r.\nby split.\n}\neapply sw_in_Csw_sb in DD; auto.\ndestruct DD as [DD|DD].\n2: {\nright.\neapply (@sb_trans G); eauto.\n}\nleft.\napply seq_eqv_l.\nsplit.\n2: {\napply ct_ct.\neexists.\nsplit; apply ct_step; [left|right]; eauto.\n}\nassert (C y) as CY.\n{\nby destruct_seq_l DD as XX.\n}\neapply dom_sb_covered; eauto.\neexists.\napply seq_eqv_r.\nsplit; eauto.\n}\ndestruct AA as [|AA]; [by intuition|].\nassert ((sw ⨾ ⦗C ∪₁ dom_rel (sb^? ⨾ ⦗I⦘)⦘) y z) as DD.\n{\napply seq_eqv_r.\nby split.\n}\neapply sw_in_Csw_sb in DD; auto.\ndestruct DD as [DD|]; [|by intuition].\nleft.\nby destruct_seq_l DD as CY.\n"}]