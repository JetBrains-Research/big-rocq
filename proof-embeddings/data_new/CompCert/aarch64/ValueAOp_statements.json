{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/ValueAOp.v","fileSamples":[{"statement":"(v : val) (av : aval) (s : shift) (n : amount32) (H : vmatch bc v av) : vmatch bc (eval_shift s v n) (eval_static_shift s av n).","conclusion":"vmatch bc (eval_shift s v n) (eval_static_shift s av n)","hypotheses":"(v : val) (av : aval) (s : shift) (n : amount32) (H : vmatch bc v av)","proofString":"unfold eval_shift, eval_static_shift; destruct s; auto with va."},{"statement":"(v : val) (av : aval) (s : shift) (n : amount64) (H : vmatch bc v av) : vmatch bc (eval_shiftl s v n) (eval_static_shiftl s av n).","conclusion":"vmatch bc (eval_shiftl s v n) (eval_static_shiftl s av n)","hypotheses":"(v : val) (av : aval) (s : shift) (n : amount64) (H : vmatch bc v av)","proofString":"unfold eval_shiftl, eval_static_shiftl; destruct s; auto with va."},{"statement":"(v : val) (av : aval) (x : extension) (n : amount64) (H : vmatch bc v av) : vmatch bc (eval_extend x v n) (eval_static_extend x av n).","conclusion":"vmatch bc (eval_extend x v n) (eval_static_extend x av n)","hypotheses":"(v : val) (av : aval) (x : extension) (n : amount64) (H : vmatch bc v av)","proofString":"unfold eval_extend, eval_static_extend; destruct x; auto with va."},{"statement":"(cond : condition) (vargs : list val) (m : mem) (aargs : list aval) (VM : list_forall2 (vmatch bc) vargs aargs) : cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs).","conclusion":"cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs)","hypotheses":"(cond : condition) (vargs : list val) (m : mem) (aargs : list aval) (VM : list_forall2 (vmatch bc) vargs aargs)","proofString":"inv VM.\ndestruct cond; auto with va.\ninv H0.\ndestruct cond; simpl; eauto with va.\nreplace (Val.cmp_bool Ceq (Val.and a1 (Vint n)) (Vint Int.zero))     with (Val.maskzero_bool a1 n) by (destruct a1; auto).\neauto with va.\nreplace (Val.cmp_bool Cne (Val.and a1 (Vint n)) (Vint Int.zero))     with (option_map negb (Val.maskzero_bool a1 n)) by (destruct a1; auto).\neauto with va.\ninv H2.\ndestruct cond; simpl; eauto with va.\ndestruct cond; auto with va."},{"statement":"(cond : condition) (m : mem) : cmatch (eval_condition cond nil m) (eval_static_condition cond nil).","conclusion":"cmatch (eval_condition cond nil m) (eval_static_condition cond nil)","hypotheses":"(cond : condition) (m : mem)","proofString":"destruct cond; auto with va."},{"statement":"(cond : condition) (m : mem) (a1 : val) (al : list val) (b1 : aval) (bl : list aval) (H : vmatch bc a1 b1) (H0 : list_forall2 (vmatch bc) al bl) : cmatch (eval_condition cond (a1 :: al) m)\n  (eval_static_condition cond (b1 :: bl)).","conclusion":"cmatch (eval_condition cond (a1 :: al) m)\n  (eval_static_condition cond (b1 :: bl))","hypotheses":"(cond : condition) (m : mem) (a1 : val) (al : list val) (b1 : aval) (bl : list aval) (H : vmatch bc a1 b1) (H0 : list_forall2 (vmatch bc) al bl)","proofString":"inv H0.\ndestruct cond; simpl; eauto with va.\nreplace (Val.cmp_bool Ceq (Val.and a1 (Vint n)) (Vint Int.zero))     with (Val.maskzero_bool a1 n) by (destruct a1; auto).\neauto with va.\nreplace (Val.cmp_bool Cne (Val.and a1 (Vint n)) (Vint Int.zero))     with (option_map negb (Val.maskzero_bool a1 n)) by (destruct a1; auto).\neauto with va.\ninv H2.\ndestruct cond; simpl; eauto with va.\ndestruct cond; auto with va."},{"statement":"(cond : condition) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) : cmatch (eval_condition cond (a1 :: nil) m)\n  (eval_static_condition cond (b1 :: nil)).","conclusion":"cmatch (eval_condition cond (a1 :: nil) m)\n  (eval_static_condition cond (b1 :: nil))","hypotheses":"(cond : condition) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1)","proofString":"destruct cond; simpl; eauto with va.\nreplace (Val.cmp_bool Ceq (Val.and a1 (Vint n)) (Vint Int.zero))     with (Val.maskzero_bool a1 n) by (destruct a1; auto).\neauto with va.\nreplace (Val.cmp_bool Cne (Val.and a1 (Vint n)) (Vint Int.zero))     with (option_map negb (Val.maskzero_bool a1 n)) by (destruct a1; auto).\neauto with va."},{"statement":"(n : int) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) : cmatch (Val.cmp_bool Ceq (Val.and a1 (Vint n)) (Vint Int.zero))\n  (maskzero b1 n).","conclusion":"cmatch (Val.cmp_bool Ceq (Val.and a1 (Vint n)) (Vint Int.zero))\n  (maskzero b1 n)","hypotheses":"(n : int) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1)","proofString":"replace (Val.cmp_bool Ceq (Val.and a1 (Vint n)) (Vint Int.zero))     with (Val.maskzero_bool a1 n) by (destruct a1; auto).\neauto with va."},{"statement":"(n : int) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) : cmatch (Val.maskzero_bool a1 n) (maskzero b1 n).","conclusion":"cmatch (Val.maskzero_bool a1 n) (maskzero b1 n)","hypotheses":"(n : int) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1)","proofString":"eauto with va."},{"statement":"(n : int) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) : cmatch (Val.cmp_bool Cne (Val.and a1 (Vint n)) (Vint Int.zero))\n  (cnot (maskzero b1 n)).","conclusion":"cmatch (Val.cmp_bool Cne (Val.and a1 (Vint n)) (Vint Int.zero))\n  (cnot (maskzero b1 n))","hypotheses":"(n : int) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1)","proofString":"replace (Val.cmp_bool Cne (Val.and a1 (Vint n)) (Vint Int.zero))     with (option_map negb (Val.maskzero_bool a1 n)) by (destruct a1; auto).\neauto with va."},{"statement":"(n : int) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) : cmatch (option_map negb (Val.maskzero_bool a1 n)) (cnot (maskzero b1 n)).","conclusion":"cmatch (option_map negb (Val.maskzero_bool a1 n)) (cnot (maskzero b1 n))","hypotheses":"(n : int) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1)","proofString":"eauto with va."},{"statement":"(cond : condition) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) (a0 : val) (al0 : list val) (b0 : aval) (bl0 : list aval) (H1 : vmatch bc a0 b0) (H2 : list_forall2 (vmatch bc) al0 bl0) : cmatch (eval_condition cond (a1 :: a0 :: al0) m)\n  (eval_static_condition cond (b1 :: b0 :: bl0)).","conclusion":"cmatch (eval_condition cond (a1 :: a0 :: al0) m)\n  (eval_static_condition cond (b1 :: b0 :: bl0))","hypotheses":"(cond : condition) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) (a0 : val) (al0 : list val) (b0 : aval) (bl0 : list aval) (H1 : vmatch bc a0 b0) (H2 : list_forall2 (vmatch bc) al0 bl0)","proofString":"inv H2.\ndestruct cond; simpl; eauto with va.\ndestruct cond; auto with va."},{"statement":"(cond : condition) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) (a0 : val) (b0 : aval) (H1 : vmatch bc a0 b0) : cmatch (eval_condition cond (a1 :: a0 :: nil) m)\n  (eval_static_condition cond (b1 :: b0 :: nil)).","conclusion":"cmatch (eval_condition cond (a1 :: a0 :: nil) m)\n  (eval_static_condition cond (b1 :: b0 :: nil))","hypotheses":"(cond : condition) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) (a0 : val) (b0 : aval) (H1 : vmatch bc a0 b0)","proofString":"destruct cond; simpl; eauto with va."},{"statement":"(cond : condition) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) (a0 : val) (b0 : aval) (H1 : vmatch bc a0 b0) (a2 : val) (al : list val) (b2 : aval) (bl : list aval) (H0 : vmatch bc a2 b2) (H3 : list_forall2 (vmatch bc) al bl) : cmatch (eval_condition cond (a1 :: a0 :: a2 :: al) m)\n  (eval_static_condition cond (b1 :: b0 :: b2 :: bl)).","conclusion":"cmatch (eval_condition cond (a1 :: a0 :: a2 :: al) m)\n  (eval_static_condition cond (b1 :: b0 :: b2 :: bl))","hypotheses":"(cond : condition) (m : mem) (a1 : val) (b1 : aval) (H : vmatch bc a1 b1) (a0 : val) (b0 : aval) (H1 : vmatch bc a0 b0) (a2 : val) (al : list val) (b2 : aval) (bl : list aval) (H0 : vmatch bc a2 b2) (H3 : list_forall2 (vmatch bc) al bl)","proofString":"destruct cond; auto with va."},{"statement":"(id : ident) (ofs : ptrofs) : vmatch bc (Genv.symbol_address ge id ofs) (Ifptr (Gl id ofs)).","conclusion":"vmatch bc (Genv.symbol_address ge id ofs) (Ifptr (Gl id ofs))","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:F.\nconstructor.\nconstructor.\napply GENV; auto.\nconstructor."},{"statement":"(id : ident) (ofs : ptrofs) : vmatch bc\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end (Ifptr (Gl id ofs)).","conclusion":"vmatch bc\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end (Ifptr (Gl id ofs))","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:F.\nconstructor.\nconstructor.\napply GENV; auto.\nconstructor."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (F : Genv.find_symbol ge id = Some b) : vmatch bc (Vptr b ofs) (Ifptr (Gl id ofs)).","conclusion":"vmatch bc (Vptr b ofs) (Ifptr (Gl id ofs))","hypotheses":"(id : ident) (ofs : ptrofs) (b : block) (F : Genv.find_symbol ge id = Some b)","proofString":"constructor.\nconstructor.\napply GENV; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (F : Genv.find_symbol ge id = Some b) : pmatch bc b ofs (Gl id ofs).","conclusion":"pmatch bc b ofs (Gl id ofs)","hypotheses":"(id : ident) (ofs : ptrofs) (b : block) (F : Genv.find_symbol ge id = Some b)","proofString":"constructor.\napply GENV; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (F : Genv.find_symbol ge id = Some b) : bc b = BCglob id.","conclusion":"bc b = BCglob id","hypotheses":"(id : ident) (ofs : ptrofs) (b : block) (F : Genv.find_symbol ge id = Some b)","proofString":"apply GENV; auto."},{"statement":"(id : ident) (ofs : ptrofs) (F : Genv.find_symbol ge id = None) : vmatch bc Vundef (Ifptr (Gl id ofs)).","conclusion":"vmatch bc Vundef (Ifptr (Gl id ofs))","hypotheses":"(id : ident) (ofs : ptrofs) (F : Genv.find_symbol ge id = None)","proofString":"constructor."},{"statement":"(ofs : ptrofs) : vmatch bc (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) (Ptr (Stk ofs)).","conclusion":"vmatch bc (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) (Ptr (Stk ofs))","hypotheses":"(ofs : ptrofs)","proofString":"rewrite Ptrofs.add_zero_l; eauto with va."},{"statement":"(n : float) (m : mem) : vmatch bc (Vfloat n) (if propagate_float_constants tt then F n else ntop).","conclusion":"vmatch bc (Vfloat n) (if propagate_float_constants tt then F n else ntop)","hypotheses":"(n : float) (m : mem)","proofString":"destruct (propagate_float_constants tt); constructor."},{"statement":"(n : float32) (m : mem) : vmatch bc (Vsingle n) (if propagate_float_constants tt then FS n else ntop).","conclusion":"vmatch bc (Vsingle n) (if propagate_float_constants tt then FS n else ntop)","hypotheses":"(n : float32) (m : mem)","proofString":"destruct (propagate_float_constants tt); constructor."},{"statement":"(ofs : ptrofs) (m : mem) : vmatch bc (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) (Ptr (Stk ofs)).","conclusion":"vmatch bc (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) (Ptr (Stk ofs))","hypotheses":"(ofs : ptrofs) (m : mem)","proofString":"rewrite Ptrofs.add_zero_l; eauto with va."},{"statement":"(cond : condition) (vargs : list val) (m : mem) (aargs : list aval) (H0 : list_forall2 (vmatch bc) vargs aargs) : vmatch bc (Val.of_optbool (eval_condition cond vargs m))\n  (of_optbool (eval_static_condition cond aargs)).","conclusion":"vmatch bc (Val.of_optbool (eval_condition cond vargs m))\n  (of_optbool (eval_static_condition cond aargs))","hypotheses":"(cond : condition) (vargs : list val) (m : mem) (aargs : list aval) (H0 : list_forall2 (vmatch bc) vargs aargs)","proofString":"apply of_optbool_sound.\neapply eval_static_condition_sound; eauto."},{"statement":"(cond : condition) (vargs : list val) (m : mem) (aargs : list aval) (H0 : list_forall2 (vmatch bc) vargs aargs) : cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs).","conclusion":"cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs)","hypotheses":"(cond : condition) (vargs : list val) (m : mem) (aargs : list aval) (H0 : list_forall2 (vmatch bc) vargs aargs)","proofString":"eapply eval_static_condition_sound; eauto."},{"statement":"(cond : condition) (ty : typ) (m : mem) (a1 a0 : val) (al0 : list val) (b1 : aval) (H1 : vmatch bc a1 b1) (b0 : aval) (bl0 : list aval) (H0 : vmatch bc a0 b0) (H3 : list_forall2 (vmatch bc) al0 bl0) : vmatch bc (Val.select (eval_condition cond al0 m) a1 a0 ty)\n  (select (eval_static_condition cond bl0) b1 b0 ty).","conclusion":"vmatch bc (Val.select (eval_condition cond al0 m) a1 a0 ty)\n  (select (eval_static_condition cond bl0) b1 b0 ty)","hypotheses":"(cond : condition) (ty : typ) (m : mem) (a1 a0 : val) (al0 : list val) (b1 : aval) (H1 : vmatch bc a1 b1) (b0 : aval) (bl0 : list aval) (H0 : vmatch bc a0 b0) (H3 : list_forall2 (vmatch bc) al0 bl0)","proofString":"apply select_sound; eauto using eval_static_condition_sound."}]}