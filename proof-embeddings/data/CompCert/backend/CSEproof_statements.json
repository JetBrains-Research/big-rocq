{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/CSEproof.v","fileSamples":[{"statement":"(prog tprog : program) (H : transf_program prog = OK tprog) : match_prog prog tprog.","proofString":"eapply match_transform_partial_program_contextual; eauto."},{"statement":"(next1 : valnum) (next2 : positive) (v : valnum) (strict : bool) (r : rhs) (H : Plt v next1 /\\ wf_rhs next1 r) (H0 : Ple next1 next2) : Plt v next2 /\\ wf_rhs next2 r.","proofString":"destruct H.\nsplit.\napply Pos.lt_le_trans with next1; auto.\nred; intros.\napply Pos.lt_le_trans with next1; auto.\napply H1; auto."},{"statement":"(next1 : valnum) (next2 : positive) (v : valnum) (strict : bool) (r : rhs) (H : Plt v next1) (H1 : wf_rhs next1 r) (H0 : Ple next1 next2) : Plt v next2 /\\ wf_rhs next2 r.","proofString":"split.\napply Pos.lt_le_trans with next1; auto.\nred; intros.\napply Pos.lt_le_trans with next1; auto.\napply H1; auto."},{"statement":"(next1 : valnum) (next2 : positive) (v : valnum) (strict : bool) (r : rhs) (H : Plt v next1) (H1 : wf_rhs next1 r) (H0 : Ple next1 next2) : Plt v next2.","proofString":"apply Pos.lt_le_trans with next1; auto."},{"statement":"(next1 : valnum) (next2 : positive) (v : valnum) (strict : bool) (r : rhs) (H : Plt v next1) (H1 : wf_rhs next1 r) (H0 : Ple next1 next2) : wf_rhs next2 r.","proofString":"red; intros.\napply Pos.lt_le_trans with next1; auto.\napply H1; auto."},{"statement":"(next1 : valnum) (next2 : positive) (v : valnum) (strict : bool) (r : rhs) (H : Plt v next1) (H1 : wf_rhs next1 r) (H0 : Ple next1 next2) (v0 : valnum) (H2 : In v0 (valnums_rhs r)) : Plt v0 next2.","proofString":"apply Pos.lt_le_trans with next1; auto.\napply H1; auto."},{"statement":"(next1 : valnum) (next2 : positive) (v : valnum) (strict : bool) (r : rhs) (H : Plt v next1) (H1 : wf_rhs next1 r) (H0 : Ple next1 next2) (v0 : valnum) (H2 : In v0 (valnums_rhs r)) : (v0 < next1)%positive.","proofString":"apply H1; auto."},{"statement":"(vl : list positive) (H : forall v : positive, In v vl -> Plt v upto) : map valu2 vl = map valu1 vl.","proofString":"apply list_map_exten.\nintros.\nsymmetry.\nauto."},{"statement":"(vl : list positive) (H : forall v : positive, In v vl -> Plt v upto) : forall x : valnum, In x vl -> valu1 x = valu2 x.","proofString":"intros.\nsymmetry.\nauto."},{"statement":"(vl : list positive) (H : forall v : positive, In v vl -> Plt v upto) (x : valnum) (H0 : In x vl) : valu1 x = valu2 x.","proofString":"symmetry.\nauto."},{"statement":"(vl : list positive) (H : forall v : positive, In v vl -> Plt v upto) (x : valnum) (H0 : In x vl) : valu2 x = valu1 x.","proofString":"auto."},{"statement":"(x : valnum) (H : forall vn : valnum, In vn (x :: nil) -> Plt vn upto) : eval_builtin_arg ge valu2 sp m (BA x) (valu1 x).","proofString":"rewrite <- AGREE by eauto with coqlib.\napply eval_BA."},{"statement":"(x : valnum) (H : forall vn : valnum, In vn (x :: nil) -> Plt vn upto) : eval_builtin_arg ge valu2 sp m (BA x) (valu2 x).","proofString":"apply eval_BA."},{"statement":"(r : rhs) (v : val) (H : rhs_eval_to valu1 ge sp m r v) (H0 : forall v0 : valnum, In v0 (valnums_rhs r) -> Plt v0 upto) : rhs_eval_to valu2 ge sp m r v.","proofString":"inv H; simpl in *.\nconstructor.\nrewrite valnums_val_exten by assumption.\nauto.\neconstructor; eauto.\nrewrite valnums_val_exten by assumption.\nauto.\neconstructor; eauto using builtin_args_val_exten."},{"statement":"(v : val) (op : operation) (vl : list valnum) (H0 : forall v0 : valnum, In v0 vl -> Plt v0 upto) (H1 : eval_operation ge sp op (map valu1 vl) m = Some v) : rhs_eval_to valu2 ge sp m (Op op vl) v.","proofString":"constructor.\nrewrite valnums_val_exten by assumption.\nauto."},{"statement":"(v : val) (op : operation) (vl : list valnum) (H0 : forall v0 : valnum, In v0 vl -> Plt v0 upto) (H1 : eval_operation ge sp op (map valu1 vl) m = Some v) : eval_operation ge sp op (map valu2 vl) m = Some v.","proofString":"rewrite valnums_val_exten by assumption.\nauto."},{"statement":"(v : val) (op : operation) (vl : list valnum) (H0 : forall v0 : valnum, In v0 vl -> Plt v0 upto) (H1 : eval_operation ge sp op (map valu1 vl) m = Some v) : eval_operation ge sp op (map valu1 vl) m = Some v.","proofString":"auto."},{"statement":"(v : val) (chunk : memory_chunk) (addr : addressing) (vl : list valnum) (p : aptr) (H0 : forall v0 : valnum, In v0 vl -> Plt v0 upto) (a : val) (H1 : eval_addressing ge sp addr (map valu1 vl) = Some a) (H2 : Mem.loadv chunk m a = Some v) : rhs_eval_to valu2 ge sp m (Load chunk addr vl p) v.","proofString":"econstructor; eauto.\nrewrite valnums_val_exten by assumption.\nauto."},{"statement":"(v : val) (chunk : memory_chunk) (addr : addressing) (vl : list valnum) (p : aptr) (H0 : forall v0 : valnum, In v0 vl -> Plt v0 upto) (a : val) (H1 : eval_addressing ge sp addr (map valu1 vl) = Some a) (H2 : Mem.loadv chunk m a = Some v) : eval_addressing ge sp addr (map valu2 vl) = Some a.","proofString":"rewrite valnums_val_exten by assumption.\nauto."},{"statement":"(v : val) (chunk : memory_chunk) (addr : addressing) (vl : list valnum) (p : aptr) (H0 : forall v0 : valnum, In v0 vl -> Plt v0 upto) (a : val) (H1 : eval_addressing ge sp addr (map valu1 vl) = Some a) (H2 : Mem.loadv chunk m a = Some v) : eval_addressing ge sp addr (map valu1 vl) = Some a.","proofString":"auto."},{"statement":"(v : val) (bf : builtin_function) (args : list (builtin_arg valnum)) (H0 : forall v0 : valnum, In v0 (params_of_builtin_args args) -> Plt v0 upto) (vargs : list val) (H1 : eval_builtin_args ge valu1 sp m args vargs) (H2 : builtin_function_sem bf vargs = Some v) : rhs_eval_to valu2 ge sp m (Builtin bf args) v.","proofString":"econstructor; eauto using builtin_args_val_exten."},{"statement":"(r : rhs) (H : rhs_valid valu1 ge sp r) (H0 : forall v : valnum, In v (valnums_rhs r) -> Plt v upto) : rhs_valid valu2 ge sp r.","proofString":"inv H; simpl in *.\nconstructor.\neconstructor; eauto.\nrewrite valnums_val_exten by assumption.\nauto.\nconstructor."},{"statement":"(op : operation) (vl : list valnum) (H0 : forall v : valnum, In v vl -> Plt v upto) : rhs_valid valu2 ge sp (Op op vl).","proofString":"constructor."},{"statement":"(chunk : memory_chunk) (addr : addressing) (vl : list valnum) (p : aptr) (H0 : forall v : valnum, In v vl -> Plt v upto) (sp0 b : block) (ofs : ptrofs) (bc : block_classification) (H1 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (map valu1 vl) =\nSome (Vptr b ofs)) (H2 : pmatch bc b ofs p) (H3 : genv_match bc ge) (H4 : bc sp0 = BCstack) : rhs_valid valu2 ge (Vptr sp0 Ptrofs.zero) (Load chunk addr vl p).","proofString":"econstructor; eauto.\nrewrite valnums_val_exten by assumption.\nauto."},{"statement":"(chunk : memory_chunk) (addr : addressing) (vl : list valnum) (p : aptr) (H0 : forall v : valnum, In v vl -> Plt v upto) (sp0 b : block) (ofs : ptrofs) (bc : block_classification) (H1 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (map valu1 vl) =\nSome (Vptr b ofs)) (H2 : pmatch bc b ofs p) (H3 : genv_match bc ge) (H4 : bc sp0 = BCstack) : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (map valu2 vl) =\nSome (Vptr b ofs).","proofString":"rewrite valnums_val_exten by assumption.\nauto."},{"statement":"(chunk : memory_chunk) (addr : addressing) (vl : list valnum) (p : aptr) (H0 : forall v : valnum, In v vl -> Plt v upto) (sp0 b : block) (ofs : ptrofs) (bc : block_classification) (H1 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (map valu1 vl) =\nSome (Vptr b ofs)) (H2 : pmatch bc b ofs p) (H3 : genv_match bc ge) (H4 : bc sp0 = BCstack) : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (map valu1 vl) =\nSome (Vptr b ofs).","proofString":"auto."},{"statement":"(bf : builtin_function) (args : list (builtin_arg valnum)) (H0 : forall v : valnum, In v (params_of_builtin_args args) -> Plt v upto) : rhs_valid valu2 ge sp (Builtin bf args).","proofString":"constructor."},{"statement":"(e : equation) (H : equation_holds valu1 ge sp m e) (H0 : wf_equation upto e) : equation_holds valu2 ge sp m e.","proofString":"destruct e.\ndestruct H0.\ninv H.\nconstructor.\nrewrite AGREE by auto.\napply rhs_eval_to_exten; auto.\napply rhs_valid_exten; auto.\neconstructor.\napply rhs_eval_to_exten; eauto.\nrewrite AGREE by auto.\nauto.\napply rhs_valid_exten; auto."},{"statement":"(v : valnum) (strict : bool) (r : rhs) (H : equation_holds valu1 ge sp m (Eq v strict r)) (H0 : wf_equation upto (Eq v strict r)) : equation_holds valu2 ge sp m (Eq v strict r).","proofString":"destruct H0.\ninv H.\nconstructor.\nrewrite AGREE by auto.\napply rhs_eval_to_exten; auto.\napply rhs_valid_exten; auto.\neconstructor.\napply rhs_eval_to_exten; eauto.\nrewrite AGREE by auto.\nauto.\napply rhs_valid_exten; auto."},{"statement":"(v : valnum) (strict : bool) (r : rhs) (H : equation_holds valu1 ge sp m (Eq v strict r)) (H0 : Plt v upto) (H1 : wf_rhs upto r) : equation_holds valu2 ge sp m (Eq v strict r).","proofString":"inv H.\nconstructor.\nrewrite AGREE by auto.\napply rhs_eval_to_exten; auto.\napply rhs_valid_exten; auto.\neconstructor.\napply rhs_eval_to_exten; eauto.\nrewrite AGREE by auto.\nauto.\napply rhs_valid_exten; auto."},{"statement":"(v : valnum) (r : rhs) (H0 : Plt v upto) (H1 : wf_rhs upto r) (H4 : rhs_eval_to valu1 ge sp m r (valu1 v)) (H6 : rhs_valid valu1 ge sp r) : equation_holds valu2 ge sp m (Eq v true r).","proofString":"constructor.\nrewrite AGREE by auto.\napply rhs_eval_to_exten; auto.\napply rhs_valid_exten; auto."},{"statement":"(v : valnum) (r : rhs) (H0 : Plt v upto) (H1 : wf_rhs upto r) (H4 : rhs_eval_to valu1 ge sp m r (valu1 v)) (H6 : rhs_valid valu1 ge sp r) : rhs_eval_to valu2 ge sp m r (valu2 v).","proofString":"rewrite AGREE by auto.\napply rhs_eval_to_exten; auto."},{"statement":"(v : valnum) (r : rhs) (H0 : Plt v upto) (H1 : wf_rhs upto r) (H4 : rhs_eval_to valu1 ge sp m r (valu1 v)) (H6 : rhs_valid valu1 ge sp r) : rhs_eval_to valu2 ge sp m r (valu1 v).","proofString":"apply rhs_eval_to_exten; auto."},{"statement":"(v : valnum) (r : rhs) (H0 : Plt v upto) (H1 : wf_rhs upto r) (H4 : rhs_eval_to valu1 ge sp m r (valu1 v)) (H6 : rhs_valid valu1 ge sp r) : rhs_valid valu2 ge sp r.","proofString":"apply rhs_valid_exten; auto."},{"statement":"(v : valnum) (r : rhs) (H0 : Plt v upto) (H1 : wf_rhs upto r) (v0 : val) (H5 : rhs_eval_to valu1 ge sp m r v0) (H6 : Val.lessdef v0 (valu1 v)) (H7 : rhs_valid valu1 ge sp r) : equation_holds valu2 ge sp m (Eq v false r).","proofString":"econstructor.\napply rhs_eval_to_exten; eauto.\nrewrite AGREE by auto.\nauto.\napply rhs_valid_exten; auto."},{"statement":"(v : valnum) (r : rhs) (H0 : Plt v upto) (H1 : wf_rhs upto r) (v0 : val) (H5 : rhs_eval_to valu1 ge sp m r v0) (H6 : Val.lessdef v0 (valu1 v)) (H7 : rhs_valid valu1 ge sp r) : Val.lessdef v0 (valu1 v).","proofString":"auto."},{"statement":"(v : valnum) (r : rhs) (H0 : Plt v upto) (H1 : wf_rhs upto r) (v0 : val) (H5 : rhs_eval_to valu1 ge sp m r v0) (H6 : Val.lessdef v0 (valu1 v)) (H7 : rhs_valid valu1 ge sp r) : rhs_valid valu2 ge sp r.","proofString":"apply rhs_valid_exten; auto."},{"statement":"(n : numbering) (H : numbering_holds valu1 ge sp rs m n) (H0 : Ple (num_next n) upto) : numbering_holds valu2 ge sp rs m n.","proofString":"destruct H.\nconstructor; intros.\nauto.\napply equation_holds_exten.\nauto.\neapply wf_equation_incr; eauto with cse.\nrewrite AGREE.\neauto.\neapply Pos.lt_le_trans; eauto.\neapply wf_num_reg; eauto."},{"statement":"(n : numbering) (num_holds_wf : wf_numbering n) (num_holds_eq : forall eq : equation, In eq (num_eqs n) -> equation_holds valu1 ge sp m eq) (num_holds_reg : forall (r : positive) (v : valnum),\n(num_reg n) ! r = Some v -> rs # r = valu1 v) (H0 : Ple (num_next n) upto) : numbering_holds valu2 ge sp rs m n.","proofString":"constructor; intros.\nauto.\napply equation_holds_exten.\nauto.\neapply wf_equation_incr; eauto with cse.\nrewrite AGREE.\neauto.\neapply Pos.lt_le_trans; eauto.\neapply wf_num_reg; eauto."},{"statement":"(n : numbering) (num_holds_wf : wf_numbering n) (num_holds_eq : forall eq : equation, In eq (num_eqs n) -> equation_holds valu1 ge sp m eq) (num_holds_reg : forall (r : positive) (v : valnum),\n(num_reg n) ! r = Some v -> rs # r = valu1 v) (H0 : Ple (num_next n) upto) : wf_numbering n.","proofString":"auto."},{"statement":"(n : numbering) (num_holds_wf : wf_numbering n) (num_holds_eq : forall eq0 : equation, In eq0 (num_eqs n) -> equation_holds valu1 ge sp m eq0) (num_holds_reg : forall (r : positive) (v : valnum),\n(num_reg n) ! r = Some v -> rs # r = valu1 v) (H0 : Ple (num_next n) upto) (eq : equation) (H : In eq (num_eqs n)) : equation_holds valu2 ge sp m eq.","proofString":"apply equation_holds_exten.\nauto.\neapply wf_equation_incr; eauto with cse."},{"statement":"(n : numbering) (num_holds_wf : wf_numbering n) (num_holds_eq : forall eq0 : equation, In eq0 (num_eqs n) -> equation_holds valu1 ge sp m eq0) (num_holds_reg : forall (r : positive) (v : valnum),\n(num_reg n) ! r = Some v -> rs # r = valu1 v) (H0 : Ple (num_next n) upto) (eq : equation) (H : In eq (num_eqs n)) : equation_holds valu1 ge sp m eq.","proofString":"auto."},{"statement":"(n : numbering) (num_holds_wf : wf_numbering n) (num_holds_eq : forall eq0 : equation, In eq0 (num_eqs n) -> equation_holds valu1 ge sp m eq0) (num_holds_reg : forall (r : positive) (v : valnum),\n(num_reg n) ! r = Some v -> rs # r = valu1 v) (H0 : Ple (num_next n) upto) (eq : equation) (H : In eq (num_eqs n)) : wf_equation upto eq.","proofString":"eapply wf_equation_incr; eauto with cse."},{"statement":"(n : numbering) (num_holds_wf : wf_numbering n) (num_holds_eq : forall eq : equation, In eq (num_eqs n) -> equation_holds valu1 ge sp m eq) (num_holds_reg : forall (r0 : positive) (v0 : valnum),\n(num_reg n) ! r0 = Some v0 -> rs # r0 = valu1 v0) (H0 : Ple (num_next n) upto) (r : positive) (v : valnum) (H : (num_reg n) ! r = Some v) : rs # r = valu2 v.","proofString":"rewrite AGREE.\neauto.\neapply Pos.lt_le_trans; eauto.\neapply wf_num_reg; eauto."},{"statement":"(n : numbering) (num_holds_wf : wf_numbering n) (num_holds_eq : forall eq : equation, In eq (num_eqs n) -> equation_holds valu1 ge sp m eq) (num_holds_reg : forall (r0 : positive) (v0 : valnum),\n(num_reg n) ! r0 = Some v0 -> rs # r0 = valu1 v0) (H0 : Ple (num_next n) upto) (r : positive) (v : valnum) (H : (num_reg n) ! r = Some v) : rs # r = valu1 v.","proofString":"eauto."},{"statement":"(n : numbering) (num_holds_wf : wf_numbering n) (num_holds_eq : forall eq : equation, In eq (num_eqs n) -> equation_holds valu1 ge sp m eq) (num_holds_reg : forall (r0 : positive) (v0 : valnum),\n(num_reg n) ! r0 = Some v0 -> rs # r0 = valu1 v0) (H0 : Ple (num_next n) upto) (r : positive) (v : valnum) (H : (num_reg n) ! r = Some v) : Plt v upto.","proofString":"eapply Pos.lt_le_trans; eauto.\neapply wf_num_reg; eauto."},{"statement":"(n : numbering) (num_holds_wf : wf_numbering n) (num_holds_eq : forall eq : equation, In eq (num_eqs n) -> equation_holds valu1 ge sp m eq) (num_holds_reg : forall (r0 : positive) (v0 : valnum),\n(num_reg n) ! r0 = Some v0 -> rs # r0 = valu1 v0) (H0 : Ple (num_next n) upto) (r : positive) (v : valnum) (H : (num_reg n) ! r = Some v) : (v < num_next n)%positive.","proofString":"eapply wf_num_reg; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (n' : numbering) (v : valnum) (H : numbering_holds valu1 ge sp rs m n) (H0 : match (num_reg n) ! r with\n| Some v0 => (n, v0)\n| None =>\n    ({|\n       num_next := Pos.succ (num_next n);\n       num_eqs := num_eqs n;\n       num_reg := PTree.set r (num_next n) (num_reg n);\n       num_val := (num_val n) # (num_next n) <- (r :: nil)\n     |}, num_next n)\nend = (n', v)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  rs # r = valu2 v /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  Plt v (num_next n') /\\ Ple (num_next n) (num_next n').","proofString":"destruct (num_reg n)!r as [v'|] eqn:NR.\ninv H0.\nexists valu1; splitall.\nauto.\neauto with cse.\nred; auto.\neauto with cse.\napply Ple_refl.\ninv H0; simpl.\nset (valu2 := fun vn => if peq vn n.(num_next) then rs#r else valu1 vn).\nassert (AG: valu_agree valu1 valu2 n.(num_next)).\nred; intros.\nunfold valu2.\napply peq_false.\napply Plt_ne; auto.\nexists valu2; splitall.\nconstructor; simpl; intros.\nconstructor; simpl; intros.\napply wf_equation_incr with (num_next n).\neauto with cse.\nextlia.\nrewrite PTree.gsspec in H0.\ndestruct (peq r0 r).\ninv H0; extlia.\napply Plt_trans_succ; eauto with cse.\nrewrite PMap.gsspec in H0.\ndestruct (peq v (num_next n)).\nreplace r0 with r by (simpl in H0; intuition).\nrewrite PTree.gss.\nsubst; auto.\nexploit wf_num_val; eauto with cse.\nintro.\nrewrite PTree.gso by congruence.\nauto.\neapply equation_holds_exten; eauto with cse.\nunfold valu2.\nrewrite PTree.gsspec in H0.\ndestruct (peq r0 r).\ninv H0.\nrewrite peq_true; auto.\nrewrite peq_false.\neauto with cse.\napply Plt_ne; eauto with cse.\nunfold valu2.\nrewrite peq_true; auto.\nauto.\nextlia.\nextlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (n' : numbering) (v : valnum) (H : numbering_holds valu1 ge sp rs m n) (v' : valnum) (NR : (num_reg n) ! r = Some v') (H0 : (n, v') = (n', v)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  rs # r = valu2 v /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  Plt v (num_next n') /\\ Ple (num_next n) (num_next n').","proofString":"inv H0.\nexists valu1; splitall.\nauto.\neauto with cse.\nred; auto.\neauto with cse.\napply Ple_refl."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (r : reg) (n' : numbering) (v : valnum) (H : numbering_holds valu1 ge sp rs m n') (NR : (num_reg n') ! r = Some v) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  rs # r = valu2 v /\\\n  valu_agree valu1 valu2 (num_next n') /\\\n  Plt v (num_next n') /\\ Ple (num_next n') (num_next n').","proofString":"exists valu1; splitall.\nauto.\neauto with cse.\nred; auto.\neauto with cse.\napply Ple_refl."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (r : reg) (n' : numbering) (v : valnum) (H : numbering_holds valu1 ge sp rs m n') (NR : (num_reg n') ! r = Some v) : numbering_holds valu1 ge sp rs m n'.","proofString":"auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (r : reg) (n' : numbering) (v : valnum) (H : numbering_holds valu1 ge sp rs m n') (NR : (num_reg n') ! r = Some v) : rs # r = valu1 v.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (r : reg) (n' : numbering) (v : valnum) (H : numbering_holds valu1 ge sp rs m n') (NR : (num_reg n') ! r = Some v) : valu_agree valu1 valu1 (num_next n').","proofString":"red; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (r : reg) (n' : numbering) (v : valnum) (H : numbering_holds valu1 ge sp rs m n') (NR : (num_reg n') ! r = Some v) : Plt v (num_next n').","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (r : reg) (n' : numbering) (v : valnum) (H : numbering_holds valu1 ge sp rs m n') (NR : (num_reg n') ! r = Some v) : Ple (num_next n') (num_next n').","proofString":"apply Ple_refl."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (n' : numbering) (v : valnum) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (H0 : ({|\n   num_next := Pos.succ (num_next n);\n   num_eqs := num_eqs n;\n   num_reg := PTree.set r (num_next n) (num_reg n);\n   num_val := (num_val n) # (num_next n) <- (r :: nil)\n |}, num_next n) = (n', v)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  rs # r = valu2 v /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  Plt v (num_next n') /\\ Ple (num_next n) (num_next n').","proofString":"inv H0; simpl.\nset (valu2 := fun vn => if peq vn n.(num_next) then rs#r else valu1 vn).\nassert (AG: valu_agree valu1 valu2 n.(num_next)).\nred; intros.\nunfold valu2.\napply peq_false.\napply Plt_ne; auto.\nexists valu2; splitall.\nconstructor; simpl; intros.\nconstructor; simpl; intros.\napply wf_equation_incr with (num_next n).\neauto with cse.\nextlia.\nrewrite PTree.gsspec in H0.\ndestruct (peq r0 r).\ninv H0; extlia.\napply Plt_trans_succ; eauto with cse.\nrewrite PMap.gsspec in H0.\ndestruct (peq v (num_next n)).\nreplace r0 with r by (simpl in H0; intuition).\nrewrite PTree.gss.\nsubst; auto.\nexploit wf_num_val; eauto with cse.\nintro.\nrewrite PTree.gso by congruence.\nauto.\neapply equation_holds_exten; eauto with cse.\nunfold valu2.\nrewrite PTree.gsspec in H0.\ndestruct (peq r0 r).\ninv H0.\nrewrite peq_true; auto.\nrewrite peq_false.\neauto with cse.\napply Plt_ne; eauto with cse.\nunfold valu2.\nrewrite peq_true; auto.\nauto.\nextlia.\nextlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m\n    {|\n      num_next := Pos.succ (num_next n);\n      num_eqs := num_eqs n;\n      num_reg := PTree.set r (num_next n) (num_reg n);\n      num_val := (num_val n) # (num_next n) <- (r :: nil)\n    |} /\\\n  rs # r = valu2 (num_next n) /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  Plt (num_next n) (Pos.succ (num_next n)) /\\\n  Ple (num_next n) (Pos.succ (num_next n)).","proofString":"set (valu2 := fun vn => if peq vn n.(num_next) then rs#r else valu1 vn).\nassert (AG: valu_agree valu1 valu2 n.(num_next)).\nred; intros.\nunfold valu2.\napply peq_false.\napply Plt_ne; auto.\nexists valu2; splitall.\nconstructor; simpl; intros.\nconstructor; simpl; intros.\napply wf_equation_incr with (num_next n).\neauto with cse.\nextlia.\nrewrite PTree.gsspec in H0.\ndestruct (peq r0 r).\ninv H0; extlia.\napply Plt_trans_succ; eauto with cse.\nrewrite PMap.gsspec in H0.\ndestruct (peq v (num_next n)).\nreplace r0 with r by (simpl in H0; intuition).\nrewrite PTree.gss.\nsubst; auto.\nexploit wf_num_val; eauto with cse.\nintro.\nrewrite PTree.gso by congruence.\nauto.\neapply equation_holds_exten; eauto with cse.\nunfold valu2.\nrewrite PTree.gsspec in H0.\ndestruct (peq r0 r).\ninv H0.\nrewrite peq_true; auto.\nrewrite peq_false.\neauto with cse.\napply Plt_ne; eauto with cse.\nunfold valu2.\nrewrite peq_true; auto.\nauto.\nextlia.\nextlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (v : positive) (H0 : Plt v (num_next n)) : (if peq v (num_next n) then rs # r else valu1 v) = valu1 v.","proofString":"apply peq_false.\napply Plt_ne; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (v : positive) (H0 : Plt v (num_next n)) : v <> num_next n.","proofString":"apply Plt_ne; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : wf_numbering\n  {|\n    num_next := Pos.succ (num_next n);\n    num_eqs := num_eqs n;\n    num_reg := PTree.set r (num_next n) (num_reg n);\n    num_val := (num_val n) # (num_next n) <- (r :: nil)\n  |}.","proofString":"constructor; simpl; intros.\napply wf_equation_incr with (num_next n).\neauto with cse.\nextlia.\nrewrite PTree.gsspec in H0.\ndestruct (peq r0 r).\ninv H0; extlia.\napply Plt_trans_succ; eauto with cse.\nrewrite PMap.gsspec in H0.\ndestruct (peq v (num_next n)).\nreplace r0 with r by (simpl in H0; intuition).\nrewrite PTree.gss.\nsubst; auto.\nexploit wf_num_val; eauto with cse.\nintro.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (e : equation) (H0 : In e (num_eqs n)) : wf_equation (Pos.succ (num_next n)) e.","proofString":"apply wf_equation_incr with (num_next n).\neauto with cse.\nextlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (e : equation) (H0 : In e (num_eqs n)) : wf_equation (num_next n) e.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (e : equation) (H0 : In e (num_eqs n)) : Ple (num_next n) (Pos.succ (num_next n)).","proofString":"extlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (H0 : (PTree.set r (num_next n) (num_reg n)) ! r0 = Some v) : Plt v (Pos.succ (num_next n)).","proofString":"rewrite PTree.gsspec in H0.\ndestruct (peq r0 r).\ninv H0; extlia.\napply Plt_trans_succ; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (H0 : (if peq r0 r then Some (num_next n) else (num_reg n) ! r0) = Some v) : Plt v (Pos.succ (num_next n)).","proofString":"destruct (peq r0 r).\ninv H0; extlia.\napply Plt_trans_succ; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (e : r0 = r) (H0 : Some (num_next n) = Some v) : Plt v (Pos.succ (num_next n)).","proofString":"inv H0; extlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (n0 : r0 <> r) (H0 : (num_reg n) ! r0 = Some v) : Plt v (Pos.succ (num_next n)).","proofString":"apply Plt_trans_succ; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : reg) (v : positive) (H0 : In r0 ((num_val n) # (num_next n) <- (r :: nil)) # v) : (PTree.set r (num_next n) (num_reg n)) ! r0 = Some v.","proofString":"rewrite PMap.gsspec in H0.\ndestruct (peq v (num_next n)).\nreplace r0 with r by (simpl in H0; intuition).\nrewrite PTree.gss.\nsubst; auto.\nexploit wf_num_val; eauto with cse.\nintro.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : reg) (v : positive) (H0 : In r0 (if peq v (num_next n) then r :: nil else (num_val n) # v)) : (PTree.set r (num_next n) (num_reg n)) ! r0 = Some v.","proofString":"destruct (peq v (num_next n)).\nreplace r0 with r by (simpl in H0; intuition).\nrewrite PTree.gss.\nsubst; auto.\nexploit wf_num_val; eauto with cse.\nintro.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : reg) (v : positive) (e : v = num_next n) (H0 : In r0 (r :: nil)) : (PTree.set r (num_next n) (num_reg n)) ! r0 = Some v.","proofString":"replace r0 with r by (simpl in H0; intuition).\nrewrite PTree.gss.\nsubst; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : reg) (v : positive) (e : v = num_next n) (H0 : In r0 (r :: nil)) : (PTree.set r (num_next n) (num_reg n)) ! r = Some v.","proofString":"rewrite PTree.gss.\nsubst; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : reg) (v : positive) (e : v = num_next n) (H0 : In r0 (r :: nil)) : Some (num_next n) = Some v.","proofString":"subst; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : reg) (v : positive) (n0 : v <> num_next n) (H0 : In r0 (num_val n) # v) : (PTree.set r (num_next n) (num_reg n)) ! r0 = Some v.","proofString":"exploit wf_num_val; eauto with cse.\nintro.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : reg) (v : positive) (n0 : v <> num_next n) (H0 : In r0 (num_val n) # v) : (num_reg n) ! r0 = Some v ->\n(PTree.set r (num_next n) (num_reg n)) ! r0 = Some v.","proofString":"intro.\nrewrite PTree.gso by congruence.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : reg) (v : positive) (n0 : v <> num_next n) (H0 : In r0 (num_val n) # v) (H1 : (num_reg n) ! r0 = Some v) : (PTree.set r (num_next n) (num_reg n)) ! r0 = Some v.","proofString":"rewrite PTree.gso by congruence.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : reg) (v : positive) (n0 : v <> num_next n) (H0 : In r0 (num_val n) # v) (H1 : (num_reg n) ! r0 = Some v) : (num_reg n) ! r0 = Some v.","proofString":"auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (eq : equation) (H0 : In eq (num_eqs n)) : equation_holds valu2 ge sp m eq.","proofString":"eapply equation_holds_exten; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (H0 : (PTree.set r (num_next n) (num_reg n)) ! r0 = Some v) : rs # r0 = (if peq v (num_next n) then rs # r else valu1 v).","proofString":"rewrite PTree.gsspec in H0.\ndestruct (peq r0 r).\ninv H0.\nrewrite peq_true; auto.\nrewrite peq_false.\neauto with cse.\napply Plt_ne; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (H0 : (if peq r0 r then Some (num_next n) else (num_reg n) ! r0) = Some v) : rs # r0 = (if peq v (num_next n) then rs # r else valu1 v).","proofString":"destruct (peq r0 r).\ninv H0.\nrewrite peq_true; auto.\nrewrite peq_false.\neauto with cse.\napply Plt_ne; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (e : r0 = r) (H0 : Some (num_next n) = Some v) : rs # r0 = (if peq v (num_next n) then rs # r else valu1 v).","proofString":"inv H0.\nrewrite peq_true; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : rs # r =\n(if peq (num_next n) (num_next n) then rs # r else valu1 (num_next n)).","proofString":"rewrite peq_true; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (n0 : r0 <> r) (H0 : (num_reg n) ! r0 = Some v) : rs # r0 = (if peq v (num_next n) then rs # r else valu1 v).","proofString":"rewrite peq_false.\neauto with cse.\napply Plt_ne; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (n0 : r0 <> r) (H0 : (num_reg n) ! r0 = Some v) : rs # r0 = valu1 v.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r0 : positive) (v : valnum) (n0 : r0 <> r) (H0 : (num_reg n) ! r0 = Some v) : v <> num_next n.","proofString":"apply Plt_ne; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : rs # r =\n(if peq (num_next n) (num_next n) then rs # r else valu1 (num_next n)).","proofString":"rewrite peq_true; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : valu_agree valu1 valu2 (num_next n).","proofString":"auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : Plt (num_next n) (Pos.succ (num_next n)).","proofString":"extlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : reg) (H : numbering_holds valu1 ge sp rs m n) (NR : (num_reg n) ! r = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : Ple (num_next n) (Pos.succ (num_next n)).","proofString":"extlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (vl : list valnum) (H : numbering_holds valu1 ge sp rs m n) (H0 : (n, nil) = (n', vl)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  nil = map valu2 vl /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"inv H0.\nexists valu1; splitall; auto.\nred; auto.\nsimpl; tauto.\nextlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n' : numbering) (H : numbering_holds valu1 ge sp rs m n') : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  nil = map valu2 nil /\\\n  valu_agree valu1 valu2 (num_next n') /\\\n  (forall v : valnum, In v nil -> Plt v (num_next n')) /\\\n  Ple (num_next n') (num_next n').","proofString":"exists valu1; splitall; auto.\nred; auto.\nsimpl; tauto.\nextlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n' : numbering) (H : numbering_holds valu1 ge sp rs m n') : valu_agree valu1 valu1 (num_next n').","proofString":"red; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n' : numbering) (H : numbering_holds valu1 ge sp rs m n') : forall v : valnum, In v nil -> Plt v (num_next n').","proofString":"simpl; tauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n' : numbering) (H : numbering_holds valu1 ge sp rs m n') : Ple (num_next n') (num_next n').","proofString":"extlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl0 : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl0) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu2 vl0 /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall v : valnum, In v vl0 -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (vl : list valnum) (H : numbering_holds valu1 ge sp rs m n) (H0 : (let (n1, v1) := valnum_reg n a in\n let (ns, vs) := valnum_regs n1 rl in (ns, v1 :: vs)) = (\nn', vl)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  rs # a :: rs ## rl = map valu2 vl /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"destruct (valnum_reg n a) as [n1 v1] eqn:V1.\ndestruct (valnum_regs n1 rl) as [n2 vs] eqn:V2.\ninv H0.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit (IHrl valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nsimpl; f_equal; auto.\nrewrite R; auto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\ndestruct H0; auto.\nsubst v1; extlia.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl0 : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl0) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu2 vl0 /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall v : valnum, In v vl0 -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (vl : list valnum) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (H0 : (let (ns, vs) := valnum_regs n1 rl in (ns, v1 :: vs)) = (n', vl)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  rs # a :: rs ## rl = map valu2 vl /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"destruct (valnum_regs n1 rl) as [n2 vs] eqn:V2.\ninv H0.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit (IHrl valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nsimpl; f_equal; auto.\nrewrite R; auto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\ndestruct H0; auto.\nsubst v1; extlia.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl0 : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl0) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu2 vl0 /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall v : valnum, In v vl0 -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (vl : list valnum) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (n2 : numbering) (vs : list valnum) (V2 : valnum_regs n1 rl = (n2, vs)) (H0 : (n2, v1 :: vs) = (n', vl)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  rs # a :: rs ## rl = map valu2 vl /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"inv H0.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit (IHrl valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nsimpl; f_equal; auto.\nrewrite R; auto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\ndestruct H0; auto.\nsubst v1; extlia.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu2 vl /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  rs # a :: rs ## rl = map valu2 (v1 :: vs) /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall v : valnum, In v (v1 :: vs) -> Plt v (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"exploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit (IHrl valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nsimpl; f_equal; auto.\nrewrite R; auto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\ndestruct H0; auto.\nsubst v1; extlia.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu2 vl /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) : (exists valu2 : valuation,\n   numbering_holds valu2 ge sp rs m n1 /\\\n   rs # a = valu2 v1 /\\\n   valu_agree valu1 valu2 (num_next n) /\\\n   Plt v1 (num_next n1) /\\ Ple (num_next n) (num_next n1)) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  rs # a :: rs ## rl = map valu2 (v1 :: vs) /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall v : valnum, In v (v1 :: vs) -> Plt v (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"intros (valu2 & A & B & C & D & E).\nexploit (IHrl valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nsimpl; f_equal; auto.\nrewrite R; auto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\ndestruct H0; auto.\nsubst v1; extlia.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu3 : valuation,\n  numbering_holds valu3 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu3 vl /\\\n  valu_agree valu0 valu3 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs m n' /\\\n  rs # a :: rs ## rl = map valu0 (v1 :: vs) /\\\n  valu_agree valu1 valu0 (num_next n) /\\\n  (forall v : valnum, In v (v1 :: vs) -> Plt v (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"exploit (IHrl valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nsimpl; f_equal; auto.\nrewrite R; auto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\ndestruct H0; auto.\nsubst v1; extlia.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu3 : valuation,\n  numbering_holds valu3 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu3 vl /\\\n  valu_agree valu0 valu3 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : (exists valu3 : valuation,\n   numbering_holds valu3 ge sp rs m n' /\\\n   rs ## rl = map valu3 vs /\\\n   valu_agree valu2 valu3 (num_next n1) /\\\n   (forall v : valnum, In v vs -> Plt v (num_next n')) /\\\n   Ple (num_next n1) (num_next n')) ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge sp rs m n' /\\\n  rs # a :: rs ## rl = map valu0 (v1 :: vs) /\\\n  valu_agree valu1 valu0 (num_next n) /\\\n  (forall v : valnum, In v (v1 :: vs) -> Plt v (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"intros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nsimpl; f_equal; auto.\nrewrite R; auto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\ndestruct H0; auto.\nsubst v1; extlia.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vs -> Plt v (num_next n')) (T : Ple (num_next n1) (num_next n')) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs m n' /\\\n  rs # a :: rs ## rl = map valu0 (v1 :: vs) /\\\n  valu_agree valu1 valu0 (num_next n) /\\\n  (forall v : valnum, In v (v1 :: vs) -> Plt v (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"exists valu3; splitall.\nauto.\nsimpl; f_equal; auto.\nrewrite R; auto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\ndestruct H0; auto.\nsubst v1; extlia.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vs -> Plt v (num_next n')) (T : Ple (num_next n1) (num_next n')) : numbering_holds valu3 ge sp rs m n'.","proofString":"auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vs -> Plt v (num_next n')) (T : Ple (num_next n1) (num_next n')) : rs # a :: rs ## rl = map valu3 (v1 :: vs).","proofString":"simpl; f_equal; auto.\nrewrite R; auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vs -> Plt v (num_next n')) (T : Ple (num_next n1) (num_next n')) : rs # a = valu3 v1.","proofString":"rewrite R; auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vs -> Plt v (num_next n')) (T : Ple (num_next n1) (num_next n')) : valu_agree valu1 valu3 (num_next n).","proofString":"red; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v0 : valnum, In v0 vl -> Plt v0 (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v0 : valnum, In v0 vs -> Plt v0 (num_next n')) (T : Ple (num_next n1) (num_next n')) (v : positive) (H0 : Plt v (num_next n)) : valu3 v = valu1 v.","proofString":"transitivity (valu2 v); auto.\napply R.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v0 : valnum, In v0 vl -> Plt v0 (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v0 : valnum, In v0 vs -> Plt v0 (num_next n')) (T : Ple (num_next n1) (num_next n')) (v : positive) (H0 : Plt v (num_next n)) : valu3 v = valu2 v.","proofString":"apply R.\nextlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v0 : valnum, In v0 vl -> Plt v0 (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v0 : valnum, In v0 vs -> Plt v0 (num_next n')) (T : Ple (num_next n1) (num_next n')) (v : positive) (H0 : Plt v (num_next n)) : Plt v (num_next n1).","proofString":"extlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vs -> Plt v (num_next n')) (T : Ple (num_next n1) (num_next n')) : forall v : valnum, In v (v1 :: vs) -> Plt v (num_next n').","proofString":"simpl; intros.\ndestruct H0; auto.\nsubst v1; extlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v0 : valnum, In v0 vl -> Plt v0 (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v0 : valnum, In v0 vs -> Plt v0 (num_next n')) (T : Ple (num_next n1) (num_next n')) (v : valnum) (H0 : v1 = v \\/ In v vs) : Plt v (num_next n').","proofString":"destruct H0; auto.\nsubst v1; extlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v0 : valnum, In v0 vl -> Plt v0 (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v0 : valnum, In v0 vs -> Plt v0 (num_next n')) (T : Ple (num_next n1) (num_next n')) (v : valnum) (H0 : v1 = v) : Plt v (num_next n').","proofString":"subst v1; extlia."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (valu0 : valuation) (ge0 : genv) (sp0 : val) \n  (rs0 : regset) (m0 : mem) (n0 n'0 : numbering) (vl : list valnum),\nnumbering_holds valu0 ge0 sp0 rs0 m0 n0 ->\nvalnum_regs n0 rl = (n'0, vl) ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge0 sp0 rs0 m0 n'0 /\\\n  rs0 ## rl = map valu4 vl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall v : valnum, In v vl -> Plt v (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n n' : numbering) (H : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (v1 : valnum) (V1 : valnum_reg n a = (n1, v1)) (vs : list valnum) (V2 : valnum_regs n1 rl = (n', vs)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # a = valu2 v1) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v1 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : rs ## rl = map valu3 vs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vs -> Plt v (num_next n')) (T : Ple (num_next n1) (num_next n')) : Ple (num_next n) (num_next n').","proofString":"extlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (valu1 : valuation) (n n' : numbering) (al' : list (builtin_arg valnum)) (H : numbering_holds valu1 ge sp rs m n) (H0 : (n, nil) = (n', al')) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) al' nil /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"inv H0.\nsimpl.\nexists valu1; intuition eauto using list_forall2, Ple_refl, valu_agree_refl."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (valu1 : valuation) (n' : numbering) (H : numbering_holds valu1 ge sp rs m n') : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) nil nil /\\\n  valu_agree valu1 valu2 (num_next n') /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args nil) -> Plt vn (num_next n')) /\\\n  Ple (num_next n') (num_next n').","proofString":"simpl.\nexists valu1; intuition eauto using list_forall2, Ple_refl, valu_agree_refl."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (valu1 : valuation) (n' : numbering) (H : numbering_holds valu1 ge sp rs m n') : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) nil nil /\\\n  valu_agree valu1 valu2 (num_next n') /\\\n  (forall vn : valnum, False -> Plt vn (num_next n')) /\\\n  Ple (num_next n') (num_next n').","proofString":"exists valu1; intuition eauto using list_forall2, Ple_refl, valu_agree_refl."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al'0 : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al'0) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) al'0 bl /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al'0) -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (al' : list (builtin_arg valnum)) (H1 : numbering_holds valu1 ge sp rs m n) (H2 : (let (n1, v1) := valnum_builtin_arg n a1 in\n let (ns, vs) := valnum_builtin_args n1 al in (ns, v1 :: vs)) = (\nn', al')) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) al' (b1 :: bl) /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"destruct (valnum_builtin_arg n a1) as [n1 a1'] eqn:V1.\ndestruct (valnum_builtin_args n1 al) as [n2 al''] eqn:V2.\ninv H2.\nexploit valnum_builtin_arg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit (IHlist_forall2 valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nconstructor; auto.\neapply builtin_arg_val_exten; eauto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\nrewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al'0 : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al'0) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) al'0 bl /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al'0) -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (al' : list (builtin_arg valnum)) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (H2 : (let (ns, vs) := valnum_builtin_args n1 al in (ns, a1' :: vs)) = (n', al')) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) al' (b1 :: bl) /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"destruct (valnum_builtin_args n1 al) as [n2 al''] eqn:V2.\ninv H2.\nexploit valnum_builtin_arg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit (IHlist_forall2 valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nconstructor; auto.\neapply builtin_arg_val_exten; eauto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\nrewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al'0 : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al'0) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) al'0 bl /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al'0) -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (al' : list (builtin_arg valnum)) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (n2 : numbering) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n2, al'')) (H2 : (n2, a1' :: al'') = (n', al')) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) al' (b1 :: bl) /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"inv H2.\nexploit valnum_builtin_arg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit (IHlist_forall2 valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nconstructor; auto.\neapply builtin_arg_val_exten; eauto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\nrewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) al' bl /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) (a1' :: al'') (b1 :: bl) /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args (a1' :: al'')) -> Plt vn (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"exploit valnum_builtin_arg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit (IHlist_forall2 valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nconstructor; auto.\neapply builtin_arg_val_exten; eauto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\nrewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) al' bl /\\\n  valu_agree valu0 valu2 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) : (exists valu2 : valuation,\n   numbering_holds valu2 ge sp rs m n1 /\\\n   eval_builtin_arg ge valu2 sp m a1' b1 /\\\n   valu_agree valu1 valu2 (num_next n) /\\\n   (forall vn : valnum,\n    In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) /\\\n   Ple (num_next n) (num_next n1)) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu2 sp m) (a1' :: al'') (b1 :: bl) /\\\n  valu_agree valu1 valu2 (num_next n) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args (a1' :: al'')) -> Plt vn (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"intros (valu2 & A & B & C & D & E).\nexploit (IHlist_forall2 valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nconstructor; auto.\neapply builtin_arg_val_exten; eauto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\nrewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu3 : valuation,\n  numbering_holds valu3 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu3 sp m) al' bl /\\\n  valu_agree valu0 valu3 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu0 sp m) (a1' :: al'') (b1 :: bl) /\\\n  valu_agree valu1 valu0 (num_next n) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args (a1' :: al'')) -> Plt vn (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"exploit (IHlist_forall2 valu2); eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nconstructor; auto.\neapply builtin_arg_val_exten; eauto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\nrewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu3 : valuation,\n  numbering_holds valu3 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu3 sp m) al' bl /\\\n  valu_agree valu0 valu3 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) : (exists valu3 : valuation,\n   numbering_holds valu3 ge sp rs m n' /\\\n   list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl /\\\n   valu_agree valu2 valu3 (num_next n1) /\\\n   (forall vn : valnum,\n    In vn (params_of_builtin_args al'') -> Plt vn (num_next n')) /\\\n   Ple (num_next n1) (num_next n')) ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu0 sp m) (a1' :: al'') (b1 :: bl) /\\\n  valu_agree valu1 valu0 (num_next n) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args (a1' :: al'')) -> Plt vn (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"intros (valu3 & P & Q & R & S & T).\nexists valu3; splitall.\nauto.\nconstructor; auto.\neapply builtin_arg_val_exten; eauto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\nrewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs m n' /\\\n  list_forall2 (eval_builtin_arg ge valu0 sp m) (a1' :: al'') (b1 :: bl) /\\\n  valu_agree valu1 valu0 (num_next n) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args (a1' :: al'')) -> Plt vn (num_next n')) /\\\n  Ple (num_next n) (num_next n').","proofString":"exists valu3; splitall.\nauto.\nconstructor; auto.\neapply builtin_arg_val_exten; eauto.\nred; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia.\nsimpl; intros.\nrewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) : numbering_holds valu3 ge sp rs m n'.","proofString":"auto."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) : list_forall2 (eval_builtin_arg ge valu3 sp m) (a1' :: al'') (b1 :: bl).","proofString":"constructor; auto.\neapply builtin_arg_val_exten; eauto."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) : eval_builtin_arg ge valu3 sp m a1' b1.","proofString":"eapply builtin_arg_val_exten; eauto."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) : valu_agree valu1 valu3 (num_next n).","proofString":"red; intros.\ntransitivity (valu2 v); auto.\napply R.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) (v : positive) (H2 : Plt v (num_next n)) : valu3 v = valu1 v.","proofString":"transitivity (valu2 v); auto.\napply R.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) (v : positive) (H2 : Plt v (num_next n)) : valu3 v = valu2 v.","proofString":"apply R.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) (v : positive) (H2 : Plt v (num_next n)) : Plt v (num_next n1).","proofString":"extlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) : forall vn : valnum,\nIn vn (params_of_builtin_args (a1' :: al'')) -> Plt vn (num_next n').","proofString":"simpl; intros.\nrewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn0 : valnum,\n   In vn0 (params_of_builtin_args al') -> Plt vn0 (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn0 : valnum,\nIn vn0 (params_of_builtin_arg a1') -> Plt vn0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn0 : valnum,\nIn vn0 (params_of_builtin_args al'') -> Plt vn0 (num_next n')) (T : Ple (num_next n1) (num_next n')) (vn : valnum) (H2 : In vn (params_of_builtin_arg a1' ++ params_of_builtin_args al'')) : Plt vn (num_next n').","proofString":"rewrite in_app_iff in H2.\ndestruct H2; auto.\napply D in H2.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn0 : valnum,\n   In vn0 (params_of_builtin_args al') -> Plt vn0 (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn0 : valnum,\nIn vn0 (params_of_builtin_arg a1') -> Plt vn0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn0 : valnum,\nIn vn0 (params_of_builtin_args al'') -> Plt vn0 (num_next n')) (T : Ple (num_next n1) (num_next n')) (vn : valnum) (H2 : In vn (params_of_builtin_arg a1') \\/ In vn (params_of_builtin_args al'')) : Plt vn (num_next n').","proofString":"destruct H2; auto.\napply D in H2.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn0 : valnum,\n   In vn0 (params_of_builtin_args al') -> Plt vn0 (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn0 : valnum,\nIn vn0 (params_of_builtin_arg a1') -> Plt vn0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn0 : valnum,\nIn vn0 (params_of_builtin_args al'') -> Plt vn0 (num_next n')) (T : Ple (num_next n1) (num_next n')) (vn : valnum) (H2 : In vn (params_of_builtin_arg a1')) : Plt vn (num_next n').","proofString":"apply D in H2.\nextlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn0 : valnum,\n   In vn0 (params_of_builtin_args al') -> Plt vn0 (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn0 : valnum,\nIn vn0 (params_of_builtin_arg a1') -> Plt vn0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn0 : valnum,\nIn vn0 (params_of_builtin_args al'') -> Plt vn0 (num_next n')) (T : Ple (num_next n1) (num_next n')) (vn : valnum) (H2 : Plt vn (num_next n1)) : Plt vn (num_next n').","proofString":"extlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (valu0 : valuation) (n0 n'0 : numbering)\n  (al' : list (builtin_arg valnum)),\nnumbering_holds valu0 ge sp rs m n0 ->\nvalnum_builtin_args n0 al = (n'0, al') ->\nexists valu4 : valuation,\n  numbering_holds valu4 ge sp rs m n'0 /\\\n  list_forall2 (eval_builtin_arg ge valu4 sp m) al' bl /\\\n  valu_agree valu0 valu4 (num_next n0) /\\\n  (forall vn : valnum,\n   In vn (params_of_builtin_args al') -> Plt vn (num_next n'0)) /\\\n  Ple (num_next n0) (num_next n'0)) (valu1 : valuation) (n n' : numbering) (H1 : numbering_holds valu1 ge sp rs m n) (n1 : numbering) (a1' : builtin_arg valnum) (V1 : valnum_builtin_arg n a1 = (n1, a1')) (al'' : list (builtin_arg valnum)) (V2 : valnum_builtin_args n1 al = (n', al'')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_arg ge valu2 sp m a1' b1) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum, In vn (params_of_builtin_arg a1') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge sp rs m n') (Q : list_forall2 (eval_builtin_arg ge valu3 sp m) al'' bl) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall vn : valnum,\nIn vn (params_of_builtin_args al'') -> Plt vn (num_next n')) (T : Ple (num_next n1) (num_next n')) : Ple (num_next n) (num_next n').","proofString":"extlia."},{"statement":"(ge : genv) (sp : val) (rs : Regmap.t val) (m : mem) (a : positive) (rl : list positive) (IHrl : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m)\n  (map (BA (A:=positive)) rl) rs ## rl) : eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA a) rs # a.","proofString":"constructor."},{"statement":"(rh : rhs) (v : valnum) (H : None = Some v) : exists rh' : rhs, False /\\ rhs_compat rh rh'.","proofString":"inv H."},{"statement":"(rh : rhs) (v : valnum) (a : equation) (eqs : list equation) (IHeqs : find_valnum_rhs rh eqs = Some v ->\nexists rh' : rhs, In (Eq v true rh') eqs /\\ rhs_compat rh rh') (H : match a with\n| Eq v0 str r' =>\n    if str && compat_rhs rh r' then Some v0 else find_valnum_rhs rh eqs\nend = Some v) : exists rh' : rhs,\n  (a = Eq v true rh' \\/ In (Eq v true rh') eqs) /\\ rhs_compat rh rh'.","proofString":"destruct a.\ndestruct (strict && compat_rhs rh r) eqn:T.\nInvBooleans.\ninv H.\nexists r; auto using compat_rhs_sound.\ndestruct IHeqs as (rh' & A & B); auto.\nexists rh'; auto."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs rh eqs = Some v ->\nexists rh' : rhs, In (Eq v true rh') eqs /\\ rhs_compat rh rh') (H : (if strict && compat_rhs rh r then Some v0 else find_valnum_rhs rh eqs) =\nSome v) : exists rh' : rhs,\n  (Eq v0 strict r = Eq v true rh' \\/ In (Eq v true rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"destruct (strict && compat_rhs rh r) eqn:T.\nInvBooleans.\ninv H.\nexists r; auto using compat_rhs_sound.\ndestruct IHeqs as (rh' & A & B); auto.\nexists rh'; auto."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs rh eqs = Some v ->\nexists rh' : rhs, In (Eq v true rh') eqs /\\ rhs_compat rh rh') (T : strict && compat_rhs rh r = true) (H : Some v0 = Some v) : exists rh' : rhs,\n  (Eq v0 strict r = Eq v true rh' \\/ In (Eq v true rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"InvBooleans.\ninv H.\nexists r; auto using compat_rhs_sound."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs rh eqs = Some v ->\nexists rh' : rhs, In (Eq v true rh') eqs /\\ rhs_compat rh rh') (H : Some v0 = Some v) (H0 : strict = true) (H1 : compat_rhs rh r = true) : exists rh' : rhs,\n  (Eq v0 strict r = Eq v true rh' \\/ In (Eq v true rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"inv H.\nexists r; auto using compat_rhs_sound."},{"statement":"(rh : rhs) (v : valnum) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs rh eqs = Some v ->\nexists rh' : rhs, In (Eq v true rh') eqs /\\ rhs_compat rh rh') (H1 : compat_rhs rh r = true) : exists rh' : rhs,\n  (Eq v true r = Eq v true rh' \\/ In (Eq v true rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"exists r; auto using compat_rhs_sound."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs rh eqs = Some v ->\nexists rh' : rhs, In (Eq v true rh') eqs /\\ rhs_compat rh rh') (T : strict && compat_rhs rh r = false) (H : find_valnum_rhs rh eqs = Some v) : exists rh' : rhs,\n  (Eq v0 strict r = Eq v true rh' \\/ In (Eq v true rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"destruct IHeqs as (rh' & A & B); auto.\nexists rh'; auto."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (T : strict && compat_rhs rh r = false) (H : find_valnum_rhs rh eqs = Some v) (rh' : rhs) (A : In (Eq v true rh') eqs) (B : rhs_compat rh rh') : exists rh'0 : rhs,\n  (Eq v0 strict r = Eq v true rh'0 \\/ In (Eq v true rh'0) eqs) /\\\n  rhs_compat rh rh'0.","proofString":"exists rh'; auto."},{"statement":"(rh : rhs) (v : valnum) (H : None = Some v) : exists (_ : bool) (rh' : rhs), False /\\ rhs_compat rh rh'.","proofString":"inv H."},{"statement":"(rh : rhs) (v : valnum) (a : equation) (eqs : list equation) (IHeqs : find_valnum_rhs' rh eqs = Some v ->\nexists (strict : bool) (rh' : rhs),\n  In (Eq v strict rh') eqs /\\ rhs_compat rh rh') (H : match a with\n| Eq v0 _ r' => if compat_rhs rh r' then Some v0 else find_valnum_rhs' rh eqs\nend = Some v) : exists (strict : bool) (rh' : rhs),\n  (a = Eq v strict rh' \\/ In (Eq v strict rh') eqs) /\\ rhs_compat rh rh'.","proofString":"destruct a.\ndestruct (compat_rhs rh r) eqn:T.\ninv H.\nexists strict, r; auto using compat_rhs_sound.\nexploit IHeqs; eauto.\nintros (s & rh' & A & B).\nexists s, rh'; auto."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs' rh eqs = Some v ->\nexists (strict0 : bool) (rh' : rhs),\n  In (Eq v strict0 rh') eqs /\\ rhs_compat rh rh') (H : (if compat_rhs rh r then Some v0 else find_valnum_rhs' rh eqs) = Some v) : exists (strict0 : bool) (rh' : rhs),\n  (Eq v0 strict r = Eq v strict0 rh' \\/ In (Eq v strict0 rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"destruct (compat_rhs rh r) eqn:T.\ninv H.\nexists strict, r; auto using compat_rhs_sound.\nexploit IHeqs; eauto.\nintros (s & rh' & A & B).\nexists s, rh'; auto."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs' rh eqs = Some v ->\nexists (strict0 : bool) (rh' : rhs),\n  In (Eq v strict0 rh') eqs /\\ rhs_compat rh rh') (T : compat_rhs rh r = true) (H : Some v0 = Some v) : exists (strict0 : bool) (rh' : rhs),\n  (Eq v0 strict r = Eq v strict0 rh' \\/ In (Eq v strict0 rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"inv H.\nexists strict, r; auto using compat_rhs_sound."},{"statement":"(rh : rhs) (v : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs' rh eqs = Some v ->\nexists (strict0 : bool) (rh' : rhs),\n  In (Eq v strict0 rh') eqs /\\ rhs_compat rh rh') (T : compat_rhs rh r = true) : exists (strict0 : bool) (rh' : rhs),\n  (Eq v strict r = Eq v strict0 rh' \\/ In (Eq v strict0 rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"exists strict, r; auto using compat_rhs_sound."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs' rh eqs = Some v ->\nexists (strict0 : bool) (rh' : rhs),\n  In (Eq v strict0 rh') eqs /\\ rhs_compat rh rh') (T : compat_rhs rh r = false) (H : find_valnum_rhs' rh eqs = Some v) : exists (strict0 : bool) (rh' : rhs),\n  (Eq v0 strict r = Eq v strict0 rh' \\/ In (Eq v strict0 rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"exploit IHeqs; eauto.\nintros (s & rh' & A & B).\nexists s, rh'; auto."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs' rh eqs = Some v ->\nexists (strict0 : bool) (rh' : rhs),\n  In (Eq v strict0 rh') eqs /\\ rhs_compat rh rh') (T : compat_rhs rh r = false) (H : find_valnum_rhs' rh eqs = Some v) : (exists (strict0 : bool) (rh' : rhs),\n   In (Eq v strict0 rh') eqs /\\ rhs_compat rh rh') ->\nexists (strict0 : bool) (rh' : rhs),\n  (Eq v0 strict r = Eq v strict0 rh' \\/ In (Eq v strict0 rh') eqs) /\\\n  rhs_compat rh rh'.","proofString":"intros (s & rh' & A & B).\nexists s, rh'; auto."},{"statement":"(rh : rhs) (v v0 : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : find_valnum_rhs' rh eqs = Some v ->\nexists (strict0 : bool) (rh'0 : rhs),\n  In (Eq v strict0 rh'0) eqs /\\ rhs_compat rh rh'0) (T : compat_rhs rh r = false) (H : find_valnum_rhs' rh eqs = Some v) (s : bool) (rh' : rhs) (A : In (Eq v s rh') eqs) (B : rhs_compat rh rh') : exists (strict0 : bool) (rh'0 : rhs),\n  (Eq v0 strict r = Eq v strict0 rh'0 \\/ In (Eq v strict0 rh'0) eqs) /\\\n  rhs_compat rh rh'0.","proofString":"exists s, rh'; auto."},{"statement":"(v : valnum) (r : rhs) (H : None = Some r) : False.","proofString":"inv H."},{"statement":"(v : valnum) (r : rhs) (a : equation) (eqs : list equation) (IHeqs : find_valnum_num v eqs = Some r -> In (Eq v true r) eqs) (H : match a with\n| Eq v' str r' => if str && peq v v' then Some r' else find_valnum_num v eqs\nend = Some r) : a = Eq v true r \\/ In (Eq v true r) eqs.","proofString":"destruct a.\ndestruct (strict && peq v v0) eqn:T.\nInvBooleans.\ninv H.\nauto.\neauto."},{"statement":"(v : valnum) (r : rhs) (v0 : valnum) (strict : bool) (r0 : rhs) (eqs : list equation) (IHeqs : find_valnum_num v eqs = Some r -> In (Eq v true r) eqs) (H : (if strict && peq v v0 then Some r0 else find_valnum_num v eqs) = Some r) : Eq v0 strict r0 = Eq v true r \\/ In (Eq v true r) eqs.","proofString":"destruct (strict && peq v v0) eqn:T.\nInvBooleans.\ninv H.\nauto.\neauto."},{"statement":"(v : valnum) (r : rhs) (v0 : valnum) (strict : bool) (r0 : rhs) (eqs : list equation) (IHeqs : find_valnum_num v eqs = Some r -> In (Eq v true r) eqs) (T : strict && peq v v0 = true) (H : Some r0 = Some r) : Eq v0 strict r0 = Eq v true r \\/ In (Eq v true r) eqs.","proofString":"InvBooleans.\ninv H.\nauto."},{"statement":"(v : valnum) (r : rhs) (v0 : valnum) (strict : bool) (r0 : rhs) (eqs : list equation) (IHeqs : find_valnum_num v eqs = Some r -> In (Eq v true r) eqs) (H : Some r0 = Some r) (H0 : strict = true) (H1 : v = v0) : Eq v0 strict r0 = Eq v true r \\/ In (Eq v true r) eqs.","proofString":"inv H.\nauto."},{"statement":"(r : rhs) (v0 : valnum) (eqs : list equation) (IHeqs : find_valnum_num v0 eqs = Some r -> In (Eq v0 true r) eqs) : Eq v0 true r = Eq v0 true r \\/ In (Eq v0 true r) eqs.","proofString":"auto."},{"statement":"(v : valnum) (r : rhs) (v0 : valnum) (strict : bool) (r0 : rhs) (eqs : list equation) (IHeqs : find_valnum_num v eqs = Some r -> In (Eq v true r) eqs) (T : strict && peq v v0 = false) (H : find_valnum_num v eqs = Some r) : Eq v0 strict r0 = Eq v true r \\/ In (Eq v true r) eqs.","proofString":"eauto."},{"statement":"(n : numbering) (v : valnum) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (H : match (num_val n) # v with\n| nil => None\n| r0 :: _ => Some r0\nend = Some r) (H0 : numbering_holds valu ge sp rs m n) : rs # r = valu v.","proofString":"destruct (num_val n)#v as [ | r1 rl] eqn:E; inv H.\neapply num_holds_reg; eauto.\neapply wf_num_val; eauto with cse.\nrewrite E; auto with coqlib."},{"statement":"(n : numbering) (v : valnum) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (rl : list reg) (E : (num_val n) # v = r :: rl) (H0 : numbering_holds valu ge sp rs m n) : rs # r = valu v.","proofString":"eapply num_holds_reg; eauto.\neapply wf_num_val; eauto with cse.\nrewrite E; auto with coqlib."},{"statement":"(n : numbering) (v : valnum) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (rl : list reg) (E : (num_val n) # v = r :: rl) (H0 : numbering_holds valu ge sp rs m n) : (num_reg n) ! r = Some v.","proofString":"eapply wf_num_val; eauto with cse.\nrewrite E; auto with coqlib."},{"statement":"(n : numbering) (v : valnum) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (rl : list reg) (E : (num_val n) # v = r :: rl) (H0 : numbering_holds valu ge sp rs m n) : In r (num_val n) # v.","proofString":"rewrite E; auto with coqlib."},{"statement":"(n : numbering) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (H : numbering_holds valu ge sp rs m n) (rl : list reg) (H0 : Some nil = Some rl) : rs ## rl = nil.","proofString":"inv H0; auto."},{"statement":"(n : numbering) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (H : numbering_holds valu ge sp rs m n) (a : valnum) (vl : list valnum) (IHvl : forall rl0 : list reg,\nregs_valnums n vl = Some rl0 -> rs ## rl0 = map valu vl) (rl : list reg) (H0 : match reg_valnum n a with\n| Some r1 =>\n    match regs_valnums n vl with\n    | Some rs0 => Some (r1 :: rs0)\n    | None => None\n    end\n| None => None\nend = Some rl) : rs ## rl = valu a :: map valu vl.","proofString":"destruct (reg_valnum n a) as [r1|] eqn:RV1; try discriminate.\ndestruct (regs_valnums n vl) as [rl1|] eqn:RVL; inv H0.\nsimpl; f_equal.\neapply reg_valnum_sound; eauto.\neauto."},{"statement":"(n : numbering) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (H : numbering_holds valu ge sp rs m n) (a : valnum) (vl : list valnum) (IHvl : forall rl0 : list reg,\nregs_valnums n vl = Some rl0 -> rs ## rl0 = map valu vl) (rl : list reg) (r1 : reg) (RV1 : reg_valnum n a = Some r1) (H0 : match regs_valnums n vl with\n| Some rs0 => Some (r1 :: rs0)\n| None => None\nend = Some rl) : rs ## rl = valu a :: map valu vl.","proofString":"destruct (regs_valnums n vl) as [rl1|] eqn:RVL; inv H0.\nsimpl; f_equal.\neapply reg_valnum_sound; eauto.\neauto."},{"statement":"(n : numbering) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (H : numbering_holds valu ge sp rs m n) (a : valnum) (vl : list valnum) (rl1 : list reg) (RVL : regs_valnums n vl = Some rl1) (IHvl : forall rl : list reg, Some rl1 = Some rl -> rs ## rl = map valu vl) (r1 : reg) (RV1 : reg_valnum n a = Some r1) : rs ## (r1 :: rl1) = valu a :: map valu vl.","proofString":"simpl; f_equal.\neapply reg_valnum_sound; eauto.\neauto."},{"statement":"(n : numbering) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (H : numbering_holds valu ge sp rs m n) (a : valnum) (vl : list valnum) (rl1 : list reg) (RVL : regs_valnums n vl = Some rl1) (IHvl : forall rl : list reg, Some rl1 = Some rl -> rs ## rl = map valu vl) (r1 : reg) (RV1 : reg_valnum n a = Some r1) : rs # r1 = valu a.","proofString":"eapply reg_valnum_sound; eauto."},{"statement":"(n : numbering) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (H : numbering_holds valu ge sp rs m n) (a : valnum) (vl : list valnum) (rl1 : list reg) (RVL : regs_valnums n vl = Some rl1) (IHvl : forall rl : list reg, Some rl1 = Some rl -> rs ## rl = map valu vl) (r1 : reg) (RV1 : reg_valnum n a = Some r1) : rs ## rl1 = map valu vl.","proofString":"eauto."},{"statement":"(n : numbering) (rh : rhs) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (H : match find_valnum_rhs' rh (num_eqs n) with\n| Some vres => reg_valnum n vres\n| None => None\nend = Some r) (H0 : numbering_holds valu ge sp rs m n) : exists v : val, rhs_eval_to valu ge sp m rh v /\\ Val.lessdef v rs # r.","proofString":"destruct (find_valnum_rhs' rh (num_eqs n)) as [vres|] eqn:E; try discriminate.\nexploit find_valnum_rhs'_charact; eauto.\nintros (strict & rh' & IN & COMPAT).\nerewrite reg_valnum_sound by eauto.\nexploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nexists (valu vres); eauto using rhs_eval_to_compat, rhs_compat_sym.\nexists v; eauto using rhs_eval_to_compat, rhs_compat_sym."},{"statement":"(n : numbering) (rh : rhs) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (vres : valnum) (E : find_valnum_rhs' rh (num_eqs n) = Some vres) (H : reg_valnum n vres = Some r) (H0 : numbering_holds valu ge sp rs m n) : exists v : val, rhs_eval_to valu ge sp m rh v /\\ Val.lessdef v rs # r.","proofString":"exploit find_valnum_rhs'_charact; eauto.\nintros (strict & rh' & IN & COMPAT).\nerewrite reg_valnum_sound by eauto.\nexploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nexists (valu vres); eauto using rhs_eval_to_compat, rhs_compat_sym.\nexists v; eauto using rhs_eval_to_compat, rhs_compat_sym."},{"statement":"(n : numbering) (rh : rhs) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (vres : valnum) (E : find_valnum_rhs' rh (num_eqs n) = Some vres) (H : reg_valnum n vres = Some r) (H0 : numbering_holds valu ge sp rs m n) : (exists (strict : bool) (rh' : rhs),\n   In (Eq vres strict rh') (num_eqs n) /\\ rhs_compat rh rh') ->\nexists v : val, rhs_eval_to valu ge sp m rh v /\\ Val.lessdef v rs # r.","proofString":"intros (strict & rh' & IN & COMPAT).\nerewrite reg_valnum_sound by eauto.\nexploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nexists (valu vres); eauto using rhs_eval_to_compat, rhs_compat_sym.\nexists v; eauto using rhs_eval_to_compat, rhs_compat_sym."},{"statement":"(n : numbering) (rh : rhs) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (vres : valnum) (E : find_valnum_rhs' rh (num_eqs n) = Some vres) (H : reg_valnum n vres = Some r) (H0 : numbering_holds valu ge sp rs m n) (strict : bool) (rh' : rhs) (IN : In (Eq vres strict rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') : exists v : val, rhs_eval_to valu ge sp m rh v /\\ Val.lessdef v rs # r.","proofString":"erewrite reg_valnum_sound by eauto.\nexploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nexists (valu vres); eauto using rhs_eval_to_compat, rhs_compat_sym.\nexists v; eauto using rhs_eval_to_compat, rhs_compat_sym."},{"statement":"(n : numbering) (rh : rhs) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (vres : valnum) (E : find_valnum_rhs' rh (num_eqs n) = Some vres) (H : reg_valnum n vres = Some r) (H0 : numbering_holds valu ge sp rs m n) (strict : bool) (rh' : rhs) (IN : In (Eq vres strict rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') : exists v : val, rhs_eval_to valu ge sp m rh v /\\ Val.lessdef v (valu vres).","proofString":"exploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nexists (valu vres); eauto using rhs_eval_to_compat, rhs_compat_sym.\nexists v; eauto using rhs_eval_to_compat, rhs_compat_sym."},{"statement":"(n : numbering) (rh : rhs) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (vres : valnum) (E : find_valnum_rhs' rh (num_eqs n) = Some vres) (H : reg_valnum n vres = Some r) (H0 : numbering_holds valu ge sp rs m n) (strict : bool) (rh' : rhs) (IN : In (Eq vres strict rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') : equation_holds valu ge sp m (Eq vres strict rh') ->\nexists v : val, rhs_eval_to valu ge sp m rh v /\\ Val.lessdef v (valu vres).","proofString":"intros EH.\ninv EH.\nexists (valu vres); eauto using rhs_eval_to_compat, rhs_compat_sym.\nexists v; eauto using rhs_eval_to_compat, rhs_compat_sym."},{"statement":"(n : numbering) (rh : rhs) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (vres : valnum) (E : find_valnum_rhs' rh (num_eqs n) = Some vres) (H : reg_valnum n vres = Some r) (H0 : numbering_holds valu ge sp rs m n) (strict : bool) (rh' : rhs) (IN : In (Eq vres strict rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (EH : equation_holds valu ge sp m (Eq vres strict rh')) : exists v : val, rhs_eval_to valu ge sp m rh v /\\ Val.lessdef v (valu vres).","proofString":"inv EH.\nexists (valu vres); eauto using rhs_eval_to_compat, rhs_compat_sym.\nexists v; eauto using rhs_eval_to_compat, rhs_compat_sym."},{"statement":"(n : numbering) (rh : rhs) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (vres : valnum) (E : find_valnum_rhs' rh (num_eqs n) = Some vres) (H : reg_valnum n vres = Some r) (H0 : numbering_holds valu ge sp rs m n) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (H3 : rhs_eval_to valu ge sp m rh' (valu vres)) (H5 : rhs_valid valu ge sp rh') : exists v : val, rhs_eval_to valu ge sp m rh v /\\ Val.lessdef v (valu vres).","proofString":"exists (valu vres); eauto using rhs_eval_to_compat, rhs_compat_sym."},{"statement":"(n : numbering) (rh : rhs) (r : reg) (valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (vres : valnum) (E : find_valnum_rhs' rh (num_eqs n) = Some vres) (H : reg_valnum n vres = Some r) (H0 : numbering_holds valu ge sp rs m n) (rh' : rhs) (IN : In (Eq vres false rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (v : val) (H4 : rhs_eval_to valu ge sp m rh' v) (H5 : Val.lessdef v (valu vres)) (H6 : rhs_valid valu ge sp rh') : exists v0 : val, rhs_eval_to valu ge sp m rh v0 /\\ Val.lessdef v0 (valu vres).","proofString":"exists v; eauto using rhs_eval_to_compat, rhs_compat_sym."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (H0 : In r\n  match (num_reg n) ! rd with\n  | Some v0 => (num_val n) # v0 <- (remove peq rd (num_val n) # v0)\n  | None => num_val n\n  end # v) : r <> rd /\\ In r (num_val n) # v.","proofString":"destruct (PTree.get rd n.(num_reg)) as [vd|] eqn:GET.\nrewrite PMap.gsspec in H0.\ndestruct (peq v vd).\nsubst v.\napply List.in_remove in H0.\ntauto.\nsplit; auto.\nexploit wf_num_val; eauto.\ncongruence.\nsplit; auto.\nexploit wf_num_val; eauto.\ncongruence."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (vd : valnum) (GET : (num_reg n) ! rd = Some vd) (H0 : In r ((num_val n) # vd <- (remove peq rd (num_val n) # vd)) # v) : r <> rd /\\ In r (num_val n) # v.","proofString":"rewrite PMap.gsspec in H0.\ndestruct (peq v vd).\nsubst v.\napply List.in_remove in H0.\ntauto.\nsplit; auto.\nexploit wf_num_val; eauto.\ncongruence."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (vd : valnum) (GET : (num_reg n) ! rd = Some vd) (H0 : In r (if peq v vd then remove peq rd (num_val n) # vd else (num_val n) # v)) : r <> rd /\\ In r (num_val n) # v.","proofString":"destruct (peq v vd).\nsubst v.\napply List.in_remove in H0.\ntauto.\nsplit; auto.\nexploit wf_num_val; eauto.\ncongruence."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (vd : valnum) (GET : (num_reg n) ! rd = Some vd) (e : v = vd) (H0 : In r (remove peq rd (num_val n) # vd)) : r <> rd /\\ In r (num_val n) # v.","proofString":"subst v.\napply List.in_remove in H0.\ntauto."},{"statement":"(n : numbering) (rd r : reg) (H : wf_numbering n) (vd : valnum) (GET : (num_reg n) ! rd = Some vd) (H0 : In r (remove peq rd (num_val n) # vd)) : r <> rd /\\ In r (num_val n) # vd.","proofString":"apply List.in_remove in H0.\ntauto."},{"statement":"(n : numbering) (rd r : reg) (H : wf_numbering n) (vd : valnum) (GET : (num_reg n) ! rd = Some vd) (H0 : In r (num_val n) # vd /\\ r <> rd) : r <> rd /\\ In r (num_val n) # vd.","proofString":"tauto."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (vd : valnum) (GET : (num_reg n) ! rd = Some vd) (n0 : v <> vd) (H0 : In r (num_val n) # v) : r <> rd /\\ In r (num_val n) # v.","proofString":"split; auto.\nexploit wf_num_val; eauto.\ncongruence."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (vd : valnum) (GET : (num_reg n) ! rd = Some vd) (n0 : v <> vd) (H0 : In r (num_val n) # v) : r <> rd.","proofString":"exploit wf_num_val; eauto.\ncongruence."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (vd : valnum) (GET : (num_reg n) ! rd = Some vd) (n0 : v <> vd) (H0 : In r (num_val n) # v) : (num_reg n) ! r = Some v -> r <> rd.","proofString":"congruence."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (GET : (num_reg n) ! rd = None) (H0 : In r (num_val n) # v) : r <> rd /\\ In r (num_val n) # v.","proofString":"split; auto.\nexploit wf_num_val; eauto.\ncongruence."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (GET : (num_reg n) ! rd = None) (H0 : In r (num_val n) # v) : r <> rd.","proofString":"exploit wf_num_val; eauto.\ncongruence."},{"statement":"(n : numbering) (rd r : reg) (v : positive) (H : wf_numbering n) (GET : (num_reg n) ! rd = None) (H0 : In r (num_val n) # v) : (num_reg n) ! r = Some v -> r <> rd.","proofString":"congruence."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (v : positive) (H : wf_numbering n) (H0 : In r ((forget_reg n rd) # vd <- (rd :: (forget_reg n rd) # vd)) # v) : (PTree.set rd vd (num_reg n)) ! r = Some v.","proofString":"rewrite PMap.gsspec in H0.\ndestruct (peq v vd).\nsubst v.\ndestruct H0.\nsubst r.\napply PTree.gss.\nexploit forget_reg_charact; eauto.\nintros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto.\nexploit forget_reg_charact; eauto.\nintros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (v : positive) (H : wf_numbering n) (H0 : In r\n  (if peq v vd then rd :: (forget_reg n rd) # vd else (forget_reg n rd) # v)) : (PTree.set rd vd (num_reg n)) ! r = Some v.","proofString":"destruct (peq v vd).\nsubst v.\ndestruct H0.\nsubst r.\napply PTree.gss.\nexploit forget_reg_charact; eauto.\nintros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto.\nexploit forget_reg_charact; eauto.\nintros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (v : positive) (H : wf_numbering n) (e : v = vd) (H0 : In r (rd :: (forget_reg n rd) # vd)) : (PTree.set rd vd (num_reg n)) ! r = Some v.","proofString":"subst v.\ndestruct H0.\nsubst r.\napply PTree.gss.\nexploit forget_reg_charact; eauto.\nintros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (H : wf_numbering n) (H0 : In r (rd :: (forget_reg n rd) # vd)) : (PTree.set rd vd (num_reg n)) ! r = Some vd.","proofString":"destruct H0.\nsubst r.\napply PTree.gss.\nexploit forget_reg_charact; eauto.\nintros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (H : wf_numbering n) (H0 : rd = r) : (PTree.set rd vd (num_reg n)) ! r = Some vd.","proofString":"subst r.\napply PTree.gss."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (H : wf_numbering n) : (PTree.set rd vd (num_reg n)) ! rd = Some vd.","proofString":"apply PTree.gss."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (H : wf_numbering n) (H0 : In r (forget_reg n rd) # vd) : (PTree.set rd vd (num_reg n)) ! r = Some vd.","proofString":"exploit forget_reg_charact; eauto.\nintros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (H : wf_numbering n) (H0 : In r (forget_reg n rd) # vd) : r <> rd /\\ In r (num_val n) # vd ->\n(PTree.set rd vd (num_reg n)) ! r = Some vd.","proofString":"intros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (H : wf_numbering n) (H0 : In r (forget_reg n rd) # vd) (A : r <> rd) (B : In r (num_val n) # vd) : (PTree.set rd vd (num_reg n)) ! r = Some vd.","proofString":"rewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (H : wf_numbering n) (H0 : In r (forget_reg n rd) # vd) (A : r <> rd) (B : In r (num_val n) # vd) : (num_reg n) ! r = Some vd.","proofString":"eapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (v : positive) (H : wf_numbering n) (n0 : v <> vd) (H0 : In r (forget_reg n rd) # v) : (PTree.set rd vd (num_reg n)) ! r = Some v.","proofString":"exploit forget_reg_charact; eauto.\nintros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (v : positive) (H : wf_numbering n) (n0 : v <> vd) (H0 : In r (forget_reg n rd) # v) : r <> rd /\\ In r (num_val n) # v -> (PTree.set rd vd (num_reg n)) ! r = Some v.","proofString":"intros [A B].\nrewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (v : positive) (H : wf_numbering n) (n0 : v <> vd) (H0 : In r (forget_reg n rd) # v) (A : r <> rd) (B : In r (num_val n) # v) : (PTree.set rd vd (num_reg n)) ! r = Some v.","proofString":"rewrite PTree.gso by auto.\neapply wf_num_val; eauto."},{"statement":"(n : numbering) (rd : reg) (vd : valnum) (r : reg) (v : positive) (H : wf_numbering n) (n0 : v <> vd) (H0 : In r (forget_reg n rd) # v) (A : r <> rd) (B : In r (num_val n) # v) : (num_reg n) ! r = Some v.","proofString":"eapply wf_num_val; eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (m : mem) (rh : rhs) (v1 v2 : val) (H : rhs_eval_to valu ge sp m rh v1) (H0 : rhs_eval_to valu ge sp m rh v2) : v1 = v2.","proofString":"inv H; inv H0.\ncongruence.\ncongruence.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\ncongruence."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (m : mem) (v1 v2 : val) (op : operation) (vl : list valnum) (H1 : eval_operation ge sp op (map valu vl) m = Some v1) (H4 : eval_operation ge sp op (map valu vl) m = Some v2) : v1 = v2.","proofString":"congruence."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (m : mem) (v1 v2 : val) (chunk : memory_chunk) (addr : addressing) (vl : list valnum) (p : aptr) (a : val) (H1 : eval_addressing ge sp addr (map valu vl) = Some a) (H2 : Mem.loadv chunk m a = Some v1) (a0 : val) (H7 : eval_addressing ge sp addr (map valu vl) = Some a0) (H8 : Mem.loadv chunk m a0 = Some v2) : v1 = v2.","proofString":"congruence."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (m : mem) (v1 v2 : val) (bf : builtin_function) (args : list (builtin_arg valnum)) (vargs : list val) (H1 : eval_builtin_args ge valu sp m args vargs) (H2 : builtin_function_sem bf vargs = Some v1) (vargs0 : list val) (H4 : eval_builtin_args ge valu sp m args vargs0) (H6 : builtin_function_sem bf vargs0 = Some v2) : v1 = v2.","proofString":"assert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\ncongruence."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (m : mem) (v1 v2 : val) (bf : builtin_function) (args : list (builtin_arg valnum)) (vargs : list val) (H1 : eval_builtin_args ge valu sp m args vargs) (H2 : builtin_function_sem bf vargs = Some v1) (vargs0 : list val) (H4 : eval_builtin_args ge valu sp m args vargs0) (H6 : builtin_function_sem bf vargs0 = Some v2) (H : vargs0 = vargs) : v1 = v2.","proofString":"congruence."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    match find_valnum_rhs rh (num_eqs n) with\n    | Some vres =>\n        {|\n          num_next := num_next n;\n          num_eqs := num_eqs n;\n          num_reg := PTree.set rd vres (num_reg n);\n          num_val := update_reg n rd vres\n        |}\n    | None =>\n        {|\n          num_next := Pos.succ (num_next n);\n          num_eqs := Eq (num_next n) true rh :: num_eqs n;\n          num_reg := PTree.set rd (num_next n) (num_reg n);\n          num_val := update_reg n rd (num_next n)\n        |}\n    end.","proofString":"destruct (find_valnum_rhs rh n.(num_eqs)) as [vres|] eqn:FIND.\nexploit find_valnum_rhs_charact; eauto.\nintros (rh' & IN & COMPAT).\nexploit wf_num_eqs; eauto with cse.\nintros [A B].\nexploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nassert (rs'#rd = valu1 vres) by    (eapply rhs_eval_to_inj; eauto using rhs_eval_to_compat, rhs_compat_sym).\nexists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse.\nset (valu2 := fun v => if peq v n.(num_next) then rs'#rd else valu1 v).\nassert (AG: valu_agree valu1 valu2 n.(num_next)).\nred; intros.\nunfold valu2.\napply peq_false.\napply Plt_ne; auto.\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros.\ndestruct H4.\ninv H4.\nsimpl; split.\nextlia.\nred; intros.\napply Plt_trans_succ; eauto.\napply wf_equation_incr with (num_next n).\neauto with cse.\nextlia.\nrewrite PTree.gsspec in H4.\ndestruct (peq r rd).\ninv H4.\nextlia.\napply Plt_trans_succ; eauto with cse.\napply update_reg_charact; eauto with cse.\ndestruct H4.\ninv H4.\nconstructor.\nunfold valu2 at 2; rewrite peq_true.\neapply rhs_eval_to_exten; eauto.\neapply rhs_valid_exten; eauto.\neapply equation_holds_exten; eauto with cse.\nrewrite PTree.gsspec in H4.\nunfold valu2.\ndestruct (peq r rd).\ninv H4.\nrewrite peq_true; auto.\nrewrite peq_false.\nrewrite H3 by auto.\neauto with cse.\napply Plt_ne; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := num_next n;\n      num_eqs := num_eqs n;\n      num_reg := PTree.set rd vres (num_reg n);\n      num_val := update_reg n rd vres\n    |}.","proofString":"exploit find_valnum_rhs_charact; eauto.\nintros (rh' & IN & COMPAT).\nexploit wf_num_eqs; eauto with cse.\nintros [A B].\nexploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nassert (rs'#rd = valu1 vres) by    (eapply rhs_eval_to_inj; eauto using rhs_eval_to_compat, rhs_compat_sym).\nexists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) : (exists rh' : rhs, In (Eq vres true rh') (num_eqs n) /\\ rhs_compat rh rh') ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := num_next n;\n      num_eqs := num_eqs n;\n      num_reg := PTree.set rd vres (num_reg n);\n      num_val := update_reg n rd vres\n    |}.","proofString":"intros (rh' & IN & COMPAT).\nexploit wf_num_eqs; eauto with cse.\nintros [A B].\nexploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nassert (rs'#rd = valu1 vres) by    (eapply rhs_eval_to_inj; eauto using rhs_eval_to_compat, rhs_compat_sym).\nexists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := num_next n;\n      num_eqs := num_eqs n;\n      num_reg := PTree.set rd vres (num_reg n);\n      num_val := update_reg n rd vres\n    |}.","proofString":"exploit wf_num_eqs; eauto with cse.\nintros [A B].\nexploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nassert (rs'#rd = valu1 vres) by    (eapply rhs_eval_to_inj; eauto using rhs_eval_to_compat, rhs_compat_sym).\nexists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') : wf_equation (num_next n) (Eq vres true rh') ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := num_next n;\n      num_eqs := num_eqs n;\n      num_reg := PTree.set rd vres (num_reg n);\n      num_val := update_reg n rd vres\n    |}.","proofString":"intros [A B].\nexploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nassert (rs'#rd = valu1 vres) by    (eapply rhs_eval_to_inj; eauto using rhs_eval_to_compat, rhs_compat_sym).\nexists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := num_next n;\n      num_eqs := num_eqs n;\n      num_reg := PTree.set rd vres (num_reg n);\n      num_val := update_reg n rd vres\n    |}.","proofString":"exploit num_holds_eq; eauto.\nintros EH.\ninv EH.\nassert (rs'#rd = valu1 vres) by    (eapply rhs_eval_to_inj; eauto using rhs_eval_to_compat, rhs_compat_sym).\nexists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') : equation_holds valu1 ge sp m (Eq vres true rh') ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := num_next n;\n      num_eqs := num_eqs n;\n      num_reg := PTree.set rd vres (num_reg n);\n      num_val := update_reg n rd vres\n    |}.","proofString":"intros EH.\ninv EH.\nassert (rs'#rd = valu1 vres) by    (eapply rhs_eval_to_inj; eauto using rhs_eval_to_compat, rhs_compat_sym).\nexists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (EH : equation_holds valu1 ge sp m (Eq vres true rh')) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := num_next n;\n      num_eqs := num_eqs n;\n      num_reg := PTree.set rd vres (num_reg n);\n      num_val := update_reg n rd vres\n    |}.","proofString":"inv EH.\nassert (rs'#rd = valu1 vres) by    (eapply rhs_eval_to_inj; eauto using rhs_eval_to_compat, rhs_compat_sym).\nexists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := num_next n;\n      num_eqs := num_eqs n;\n      num_reg := PTree.set rd vres (num_reg n);\n      num_val := update_reg n rd vres\n    |}.","proofString":"assert (rs'#rd = valu1 vres) by    (eapply rhs_eval_to_inj; eauto using rhs_eval_to_compat, rhs_compat_sym).\nexists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := num_next n;\n      num_eqs := num_eqs n;\n      num_reg := PTree.set rd vres (num_reg n);\n      num_val := update_reg n rd vres\n    |}.","proofString":"exists valu1; constructor; simpl; intros.\nconstructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) : wf_numbering\n  {|\n    num_next := num_next n;\n    num_eqs := num_eqs n;\n    num_reg := PTree.set rd vres (num_reg n);\n    num_val := update_reg n rd vres\n  |}.","proofString":"constructor; simpl; intros.\neauto with cse.\nrewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (e : equation) (H5 : In e (num_eqs n)) : wf_equation (num_next n) e.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : positive) (v : valnum) (H5 : (PTree.set rd vres (num_reg n)) ! r = Some v) : Plt v (num_next n).","proofString":"rewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ninv H5.\nauto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : positive) (v : valnum) (H5 : (if peq r rd then Some vres else (num_reg n) ! r) = Some v) : Plt v (num_next n).","proofString":"destruct (peq r rd).\ninv H5.\nauto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : positive) (v : valnum) (e : r = rd) (H5 : Some vres = Some v) : Plt v (num_next n).","proofString":"inv H5.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (v : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some v) (rh' : rhs) (IN : In (Eq v true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt v (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 v)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 v) : Plt v (num_next n).","proofString":"auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : positive) (v : valnum) (n0 : r <> rd) (H5 : (num_reg n) ! r = Some v) : Plt v (num_next n).","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : reg) (v : positive) (H5 : In r (update_reg n rd vres) # v) : (PTree.set rd vres (num_reg n)) ! r = Some v.","proofString":"eapply update_reg_charact; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (eq : equation) (H5 : In eq (num_eqs n)) : equation_holds valu1 ge sp m eq.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : positive) (v : valnum) (H5 : (PTree.set rd vres (num_reg n)) ! r = Some v) : rs' # r = valu1 v.","proofString":"rewrite PTree.gsspec in H5.\ndestruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : positive) (v : valnum) (H5 : (if peq r rd then Some vres else (num_reg n) ! r) = Some v) : rs' # r = valu1 v.","proofString":"destruct (peq r rd).\ncongruence.\nrewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : positive) (v : valnum) (e : r = rd) (H5 : Some vres = Some v) : rs' # r = valu1 v.","proofString":"congruence."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : positive) (v : valnum) (n0 : r <> rd) (H5 : (num_reg n) ! r = Some v) : rs' # r = valu1 v.","proofString":"rewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (vres : valnum) (FIND : find_valnum_rhs rh (num_eqs n) = Some vres) (rh' : rhs) (IN : In (Eq vres true rh') (num_eqs n)) (COMPAT : rhs_compat rh rh') (A : Plt vres (num_next n)) (B : wf_rhs (num_next n) rh') (H6 : rhs_eval_to valu1 ge sp m rh' (valu1 vres)) (H7 : rhs_valid valu1 ge sp rh') (H4 : rs' # rd = valu1 vres) (r : positive) (v : valnum) (n0 : r <> rd) (H5 : (num_reg n) ! r = Some v) : rs # r = valu1 v.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs' m\n    {|\n      num_next := Pos.succ (num_next n);\n      num_eqs := Eq (num_next n) true rh :: num_eqs n;\n      num_reg := PTree.set rd (num_next n) (num_reg n);\n      num_val := update_reg n rd (num_next n)\n    |}.","proofString":"set (valu2 := fun v => if peq v n.(num_next) then rs'#rd else valu1 v).\nassert (AG: valu_agree valu1 valu2 n.(num_next)).\nred; intros.\nunfold valu2.\napply peq_false.\napply Plt_ne; auto.\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros.\ndestruct H4.\ninv H4.\nsimpl; split.\nextlia.\nred; intros.\napply Plt_trans_succ; eauto.\napply wf_equation_incr with (num_next n).\neauto with cse.\nextlia.\nrewrite PTree.gsspec in H4.\ndestruct (peq r rd).\ninv H4.\nextlia.\napply Plt_trans_succ; eauto with cse.\napply update_reg_charact; eauto with cse.\ndestruct H4.\ninv H4.\nconstructor.\nunfold valu2 at 2; rewrite peq_true.\neapply rhs_eval_to_exten; eauto.\neapply rhs_valid_exten; eauto.\neapply equation_holds_exten; eauto with cse.\nrewrite PTree.gsspec in H4.\nunfold valu2.\ndestruct (peq r rd).\ninv H4.\nrewrite peq_true; auto.\nrewrite peq_false.\nrewrite H3 by auto.\neauto with cse.\napply Plt_ne; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (v : positive) (H4 : Plt v (num_next n)) : (if peq v (num_next n) then rs' # rd else valu1 v) = valu1 v.","proofString":"apply peq_false.\napply Plt_ne; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (v : positive) (H4 : Plt v (num_next n)) : v <> num_next n.","proofString":"apply Plt_ne; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : wf_numbering\n  {|\n    num_next := Pos.succ (num_next n);\n    num_eqs := Eq (num_next n) true rh :: num_eqs n;\n    num_reg := PTree.set rd (num_next n) (num_reg n);\n    num_val := update_reg n rd (num_next n)\n  |}.","proofString":"constructor; simpl; intros.\ndestruct H4.\ninv H4.\nsimpl; split.\nextlia.\nred; intros.\napply Plt_trans_succ; eauto.\napply wf_equation_incr with (num_next n).\neauto with cse.\nextlia.\nrewrite PTree.gsspec in H4.\ndestruct (peq r rd).\ninv H4.\nextlia.\napply Plt_trans_succ; eauto with cse.\napply update_reg_charact; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (e : equation) (H4 : Eq (num_next n) true rh = e \\/ In e (num_eqs n)) : wf_equation (Pos.succ (num_next n)) e.","proofString":"destruct H4.\ninv H4.\nsimpl; split.\nextlia.\nred; intros.\napply Plt_trans_succ; eauto.\napply wf_equation_incr with (num_next n).\neauto with cse.\nextlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (e : equation) (H4 : Eq (num_next n) true rh = e) : wf_equation (Pos.succ (num_next n)) e.","proofString":"inv H4.\nsimpl; split.\nextlia.\nred; intros.\napply Plt_trans_succ; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : wf_equation (Pos.succ (num_next n)) (Eq (num_next n) true rh).","proofString":"simpl; split.\nextlia.\nred; intros.\napply Plt_trans_succ; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : Plt (num_next n) (Pos.succ (num_next n)).","proofString":"extlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : wf_rhs (Pos.succ (num_next n)) rh.","proofString":"red; intros.\napply Plt_trans_succ; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (v : valnum) (H4 : In v (valnums_rhs rh)) : Plt v (Pos.succ (num_next n)).","proofString":"apply Plt_trans_succ; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (e : equation) (H4 : In e (num_eqs n)) : wf_equation (Pos.succ (num_next n)) e.","proofString":"apply wf_equation_incr with (num_next n).\neauto with cse.\nextlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (e : equation) (H4 : In e (num_eqs n)) : wf_equation (num_next n) e.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (e : equation) (H4 : In e (num_eqs n)) : Ple (num_next n) (Pos.succ (num_next n)).","proofString":"extlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (H4 : (PTree.set rd (num_next n) (num_reg n)) ! r = Some v) : Plt v (Pos.succ (num_next n)).","proofString":"rewrite PTree.gsspec in H4.\ndestruct (peq r rd).\ninv H4.\nextlia.\napply Plt_trans_succ; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (H4 : (if peq r rd then Some (num_next n) else (num_reg n) ! r) = Some v) : Plt v (Pos.succ (num_next n)).","proofString":"destruct (peq r rd).\ninv H4.\nextlia.\napply Plt_trans_succ; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (e : r = rd) (H4 : Some (num_next n) = Some v) : Plt v (Pos.succ (num_next n)).","proofString":"inv H4.\nextlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : Plt (num_next n) (Pos.succ (num_next n)).","proofString":"extlia."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (n0 : r <> rd) (H4 : (num_reg n) ! r = Some v) : Plt v (Pos.succ (num_next n)).","proofString":"apply Plt_trans_succ; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : reg) (v : positive) (H4 : In r (update_reg n rd (num_next n)) # v) : (PTree.set rd (num_next n) (num_reg n)) ! r = Some v.","proofString":"apply update_reg_charact; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : rhs_eval_to valu2 ge sp m rh rs' # rd.","proofString":"eapply rhs_eval_to_exten; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : rhs_valid valu2 ge sp rh.","proofString":"eapply rhs_valid_exten; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (eq : equation) (H4 : In eq (num_eqs n)) : equation_holds valu2 ge sp m eq.","proofString":"eapply equation_holds_exten; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (H4 : (if peq r rd then Some (num_next n) else (num_reg n) ! r) = Some v) : rs' # r = (if peq v (num_next n) then rs' # rd else valu1 v).","proofString":"destruct (peq r rd).\ninv H4.\nrewrite peq_true; auto.\nrewrite peq_false.\nrewrite H3 by auto.\neauto with cse.\napply Plt_ne; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (e : r = rd) (H4 : Some (num_next n) = Some v) : rs' # r = (if peq v (num_next n) then rs' # rd else valu1 v).","proofString":"inv H4.\nrewrite peq_true; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r : positive, r <> rd -> rs' # r = rs # r) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) : rs' # rd =\n(if peq (num_next n) (num_next n) then rs' # rd else valu1 (num_next n)).","proofString":"rewrite peq_true; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (n0 : r <> rd) (H4 : (num_reg n) ! r = Some v) : rs' # r = (if peq v (num_next n) then rs' # rd else valu1 v).","proofString":"rewrite peq_false.\nrewrite H3 by auto.\neauto with cse.\napply Plt_ne; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (n0 : r <> rd) (H4 : (num_reg n) ! r = Some v) : rs' # r = valu1 v.","proofString":"rewrite H3 by auto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (n0 : r <> rd) (H4 : (num_reg n) ! r = Some v) : rs # r = valu1 v.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (rd : positive) (rh : rhs) (rs' : Regmap.t val) (H : numbering_holds valu1 ge sp rs m n) (H0 : rhs_valid valu1 ge sp rh) (H1 : rhs_eval_to valu1 ge sp m rh rs' # rd) (H2 : wf_rhs (num_next n) rh) (H3 : forall r0 : positive, r0 <> rd -> rs' # r0 = rs # r0) (FIND : find_valnum_rhs rh (num_eqs n) = None) (valu2 : positive -> val) (AG : valu_agree valu1 valu2 (num_next n)) (r : positive) (v : valnum) (n0 : r <> rd) (H4 : (num_reg n) ! r = Some v) : v <> num_next n.","proofString":"apply Plt_ne; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- v m\n    match is_move_operation op args with\n    | Some r =>\n        let (n1, v0) := valnum_reg n r in\n        {|\n          num_next := num_next n1;\n          num_eqs := num_eqs n1;\n          num_reg := PTree.set dst v0 (num_reg n1);\n          num_val := update_reg n1 dst v0\n        |}\n    | None => let (n1, vs) := valnum_regs n args in add_rhs n1 dst (Op op vs)\n    end.","proofString":"destruct (is_move_operation op args) as [src|] eqn:ISMOVE.\nexploit is_move_operation_correct; eauto.\nintros [A B]; subst op args.\nsimpl in H0.\ninv H0.\ndestruct (valnum_reg n src) as [n1 vsrc] eqn:VN.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse.\ndestruct (valnum_regs n args) as [n1 vl] eqn:VN.\nexploit valnum_regs_holds; eauto.\nintros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\nconstructor.\nconstructor.\nrewrite Regmap.gss.\ncongruence.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (src : reg) (ISMOVE : is_move_operation op args = Some src) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- v m\n    (let (n1, v0) := valnum_reg n src in\n     {|\n       num_next := num_next n1;\n       num_eqs := num_eqs n1;\n       num_reg := PTree.set dst v0 (num_reg n1);\n       num_val := update_reg n1 dst v0\n     |}).","proofString":"exploit is_move_operation_correct; eauto.\nintros [A B]; subst op args.\nsimpl in H0.\ninv H0.\ndestruct (valnum_reg n src) as [n1 vsrc] eqn:VN.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (src : reg) (ISMOVE : is_move_operation op args = Some src) : op = Omove /\\ args = src :: nil ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- v m\n    (let (n1, v0) := valnum_reg n src in\n     {|\n       num_next := num_next n1;\n       num_eqs := num_eqs n1;\n       num_reg := PTree.set dst v0 (num_reg n1);\n       num_val := update_reg n1 dst v0\n     |}).","proofString":"intros [A B]; subst op args.\nsimpl in H0.\ninv H0.\ndestruct (valnum_reg n src) as [n1 vsrc] eqn:VN.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (H0 : eval_operation ge sp Omove rs ## (src :: nil) m = Some v) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- v m\n    (let (n1, v0) := valnum_reg n src in\n     {|\n       num_next := num_next n1;\n       num_eqs := num_eqs n1;\n       num_reg := PTree.set dst v0 (num_reg n1);\n       num_val := update_reg n1 dst v0\n     |}).","proofString":"simpl in H0.\ninv H0.\ndestruct (valnum_reg n src) as [n1 vsrc] eqn:VN.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (H0 : Some rs # src = Some v) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- v m\n    (let (n1, v0) := valnum_reg n src in\n     {|\n       num_next := num_next n1;\n       num_eqs := num_eqs n1;\n       num_reg := PTree.set dst v0 (num_reg n1);\n       num_val := update_reg n1 dst v0\n     |}).","proofString":"inv H0.\ndestruct (valnum_reg n src) as [n1 vsrc] eqn:VN.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- (rs # src) m\n    (let (n1, v) := valnum_reg n src in\n     {|\n       num_next := num_next n1;\n       num_eqs := num_eqs n1;\n       num_reg := PTree.set dst v (num_reg n1);\n       num_val := update_reg n1 dst v\n     |}).","proofString":"destruct (valnum_reg n src) as [n1 vsrc] eqn:VN.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- (rs # src) m\n    {|\n      num_next := num_next n1;\n      num_eqs := num_eqs n1;\n      num_reg := PTree.set dst vsrc (num_reg n1);\n      num_val := update_reg n1 dst vsrc\n    |}.","proofString":"exploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) : (exists valu2 : valuation,\n   numbering_holds valu2 ge sp rs m n1 /\\\n   rs # src = valu2 vsrc /\\\n   valu_agree valu1 valu2 (num_next n) /\\\n   Plt vsrc (num_next n1) /\\ Ple (num_next n) (num_next n1)) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- (rs # src) m\n    {|\n      num_next := num_next n1;\n      num_eqs := num_eqs n1;\n      num_reg := PTree.set dst vsrc (num_reg n1);\n      num_val := update_reg n1 dst vsrc\n    |}.","proofString":"intros (valu2 & A & B & C & D & E).\nexists valu2; constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # dst <- (rs # src) m\n    {|\n      num_next := num_next n1;\n      num_eqs := num_eqs n1;\n      num_reg := PTree.set dst vsrc (num_reg n1);\n      num_val := update_reg n1 dst vsrc\n    |}.","proofString":"exists valu2; constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse.\neauto with cse.\nrewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) : wf_numbering\n  {|\n    num_next := num_next n1;\n    num_eqs := num_eqs n1;\n    num_reg := PTree.set dst vsrc (num_reg n1);\n    num_val := update_reg n1 dst vsrc\n  |}.","proofString":"constructor; simpl; intros; eauto with cse.\nrewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse.\neapply update_reg_charact; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (v : valnum) (H0 : (PTree.set dst vsrc (num_reg n1)) ! r = Some v) : Plt v (num_next n1).","proofString":"rewrite PTree.gsspec in H0.\ndestruct (peq r dst).\ninv H0.\nauto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (v : valnum) (H0 : (if peq r dst then Some vsrc else (num_reg n1) ! r) = Some v) : Plt v (num_next n1).","proofString":"destruct (peq r dst).\ninv H0.\nauto.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (v : valnum) (e : r = dst) (H0 : Some vsrc = Some v) : Plt v (num_next n1).","proofString":"inv H0.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (v : valnum) (VN : valnum_reg n src = (n1, v)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 v) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt v (num_next n1)) (E : Ple (num_next n) (num_next n1)) : Plt v (num_next n1).","proofString":"auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (v : valnum) (n0 : r <> dst) (H0 : (num_reg n1) ! r = Some v) : Plt v (num_next n1).","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : reg) (v : positive) (H0 : In r (update_reg n1 dst vsrc) # v) : (PTree.set dst vsrc (num_reg n1)) ! r = Some v.","proofString":"eapply update_reg_charact; eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (eq : equation) (H0 : In eq (num_eqs n1)) : equation_holds valu2 ge sp m eq.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (v : valnum) (H0 : (PTree.set dst vsrc (num_reg n1)) ! r = Some v) : (rs # dst <- (rs # src)) # r = valu2 v.","proofString":"rewrite PTree.gsspec in H0.\nrewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (v : valnum) (H0 : (if peq r dst then Some vsrc else (num_reg n1) ! r) = Some v) : (rs # dst <- (rs # src)) # r = valu2 v.","proofString":"rewrite Regmap.gsspec.\ndestruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (v : valnum) (H0 : (if peq r dst then Some vsrc else (num_reg n1) ! r) = Some v) : (if peq r dst then rs # src else rs # r) = valu2 v.","proofString":"destruct (peq r dst).\ncongruence.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (v : valnum) (e : r = dst) (H0 : Some vsrc = Some v) : rs # src = valu2 v.","proofString":"congruence."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (src : reg) (ISMOVE : is_move_operation Omove (src :: nil) = Some src) (n1 : numbering) (vsrc : valnum) (VN : valnum_reg n src = (n1, vsrc)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (v : valnum) (n0 : r <> dst) (H0 : (num_reg n1) ! r = Some v) : rs # r = valu2 v.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- v m\n    (let (n1, vs) := valnum_regs n args in add_rhs n1 dst (Op op vs)).","proofString":"destruct (valnum_regs n args) as [n1 vl] eqn:VN.\nexploit valnum_regs_holds; eauto.\nintros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\nconstructor.\nconstructor.\nrewrite Regmap.gss.\ncongruence.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- v m (add_rhs n1 dst (Op op vl)).","proofString":"exploit valnum_regs_holds; eauto.\nintros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\nconstructor.\nconstructor.\nrewrite Regmap.gss.\ncongruence.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) : (exists valu2 : valuation,\n   numbering_holds valu2 ge sp rs m n1 /\\\n   rs ## args = map valu2 vl /\\\n   valu_agree valu1 valu2 (num_next n) /\\\n   (forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) /\\\n   Ple (num_next n) (num_next n1)) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # dst <- v m (add_rhs n1 dst (Op op vl)).","proofString":"intros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\nconstructor.\nconstructor.\nrewrite Regmap.gss.\ncongruence.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # dst <- v m (add_rhs n1 dst (Op op vl)).","proofString":"eapply add_rhs_holds; eauto.\nconstructor.\nconstructor.\nrewrite Regmap.gss.\ncongruence.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : rhs_valid valu2 ge sp (Op op vl).","proofString":"constructor."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : rhs_eval_to valu2 ge sp m (Op op vl) (rs # dst <- v) # dst.","proofString":"constructor.\nrewrite Regmap.gss.\ncongruence."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : eval_operation ge sp op (map valu2 vl) m = Some (rs # dst <- v) # dst.","proofString":"rewrite Regmap.gss.\ncongruence."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : eval_operation ge sp op (map valu2 vl) m = Some v.","proofString":"congruence."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : forall r : positive, r <> dst -> (rs # dst <- v) # r = rs # r.","proofString":"intros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (op : operation) (args : list reg) (v : val) (dst : positive) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_operation ge sp op rs ## args m = Some v) (ISMOVE : is_move_operation op args = None) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (H1 : r <> dst) : (rs # dst <- v) # r = rs # r.","proofString":"apply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list reg) (ap : aptr) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (dst : positive) (bc : block_classification) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b ofs)) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) (H2 : pmatch bc b ofs ap) (H3 : genv_match bc ge) (H4 : bc sp = BCstack) : exists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs # dst <- v m\n    (let (n1, vs) := valnum_regs n args in\n     add_rhs n1 dst (Load chunk addr vs ap)).","proofString":"destruct (valnum_regs n args) as [n1 vl] eqn:VN.\nexploit valnum_regs_holds; eauto.\nintros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\neconstructor; eauto.\nrewrite <- B; auto.\neconstructor.\nrewrite <- B; eauto.\nrewrite Regmap.gss; auto.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list reg) (ap : aptr) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (dst : positive) (bc : block_classification) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b ofs)) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) (H2 : pmatch bc b ofs ap) (H3 : genv_match bc ge) (H4 : bc sp = BCstack) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) : exists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs # dst <- v m\n    (add_rhs n1 dst (Load chunk addr vl ap)).","proofString":"exploit valnum_regs_holds; eauto.\nintros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\neconstructor; eauto.\nrewrite <- B; auto.\neconstructor.\nrewrite <- B; eauto.\nrewrite Regmap.gss; auto.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list reg) (ap : aptr) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (dst : positive) (bc : block_classification) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b ofs)) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) (H2 : pmatch bc b ofs ap) (H3 : genv_match bc ge) (H4 : bc sp = BCstack) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) : (exists valu2 : valuation,\n   numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m n1 /\\\n   rs ## args = map valu2 vl /\\\n   valu_agree valu1 valu2 (num_next n) /\\\n   (forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) /\\\n   Ple (num_next n) (num_next n1)) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs # dst <- v m\n    (add_rhs n1 dst (Load chunk addr vl ap)).","proofString":"intros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\neconstructor; eauto.\nrewrite <- B; auto.\neconstructor.\nrewrite <- B; eauto.\nrewrite Regmap.gss; auto.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list reg) (ap : aptr) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (dst : positive) (bc : block_classification) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b ofs)) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) (H2 : pmatch bc b ofs ap) (H3 : genv_match bc ge) (H4 : bc sp = BCstack) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) rs # dst <- v m\n    (add_rhs n1 dst (Load chunk addr vl ap)).","proofString":"eapply add_rhs_holds; eauto.\neconstructor; eauto.\nrewrite <- B; auto.\neconstructor.\nrewrite <- B; eauto.\nrewrite Regmap.gss; auto.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list reg) (ap : aptr) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (dst : positive) (bc : block_classification) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b ofs)) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) (H2 : pmatch bc b ofs ap) (H3 : genv_match bc ge) (H4 : bc sp = BCstack) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : rhs_valid valu2 ge (Vptr sp Ptrofs.zero) (Load chunk addr vl ap).","proofString":"econstructor; eauto.\nrewrite <- B; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list reg) (ap : aptr) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (dst : positive) (bc : block_classification) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b ofs)) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) (H2 : pmatch bc b ofs ap) (H3 : genv_match bc ge) (H4 : bc sp = BCstack) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu2 vl) =\nSome (Vptr b ofs).","proofString":"rewrite <- B; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list reg) (ap : aptr) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (dst : positive) (bc : block_classification) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b ofs)) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) (H2 : pmatch bc b ofs ap) (H3 : genv_match bc ge) (H4 : bc sp = BCstack) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : rhs_eval_to valu2 ge (Vptr sp Ptrofs.zero) m (Load chunk addr vl ap)\n  (rs # dst <- v) # dst.","proofString":"econstructor.\nrewrite <- B; eauto.\nrewrite Regmap.gss; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list reg) (ap : aptr) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (dst : positive) (bc : block_classification) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b ofs)) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) (H2 : pmatch bc b ofs ap) (H3 : genv_match bc ge) (H4 : bc sp = BCstack) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) : forall r : positive, r <> dst -> (rs # dst <- v) # r = rs # r.","proofString":"intros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list reg) (ap : aptr) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (dst : positive) (bc : block_classification) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b ofs)) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) (H2 : pmatch bc b ofs ap) (H3 : genv_match bc ge) (H4 : bc sp = BCstack) (n1 : numbering) (vl : list valnum) (VN : valnum_regs n args = (n1, vl)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m n1) (B : rs ## args = map valu2 vl) (C : valu_agree valu1 valu2 (num_next n)) (D : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (H5 : r <> dst) : (rs # dst <- v) # r = rs # r.","proofString":"apply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (res : builtin_res reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp (regmap_setres res vres rs) m\n    match res with\n    | BR rd =>\n        let (n1, args1) := valnum_builtin_args n args in\n        add_rhs n1 rd (Builtin bf args1)\n    | _ => n\n    end.","proofString":"destruct res; simpl; eauto.\ndestruct (valnum_builtin_args n args) as [n1 args'] eqn:VB.\nexploit valnum_builtin_args_holds; eauto.\nintros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Regmap.gss; eauto.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (x : reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # x <- vres m\n    (let (n1, args1) := valnum_builtin_args n args in\n     add_rhs n1 x (Builtin bf args1)).","proofString":"destruct (valnum_builtin_args n args) as [n1 args'] eqn:VB.\nexploit valnum_builtin_args_holds; eauto.\nintros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Regmap.gss; eauto.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (x : reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args n args = (n1, args')) : exists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # x <- vres m\n    (add_rhs n1 x (Builtin bf args')).","proofString":"exploit valnum_builtin_args_holds; eauto.\nintros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Regmap.gss; eauto.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (x : reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args n args = (n1, args')) : (exists valu2 : valuation,\n   numbering_holds valu2 ge sp rs m n1 /\\\n   eval_builtin_args ge valu2 sp m args' vargs /\\\n   valu_agree valu1 valu2 (num_next n) /\\\n   (forall vn : valnum,\n    In vn (params_of_builtin_args args') -> Plt vn (num_next n1)) /\\\n   Ple (num_next n) (num_next n1)) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge sp rs # x <- vres m\n    (add_rhs n1 x (Builtin bf args')).","proofString":"intros (valu2 & A & B & C & D & E).\neapply add_rhs_holds; eauto.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Regmap.gss; eauto.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (x : reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args n args = (n1, args')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_args ge valu2 sp m args' vargs) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # x <- vres m\n    (add_rhs n1 x (Builtin bf args')).","proofString":"eapply add_rhs_holds; eauto.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Regmap.gss; eauto.\nintros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (x : reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args n args = (n1, args')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_args ge valu2 sp m args' vargs) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) : rhs_valid valu2 ge sp (Builtin bf args').","proofString":"econstructor; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (x : reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args n args = (n1, args')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_args ge valu2 sp m args' vargs) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) : rhs_eval_to valu2 ge sp m (Builtin bf args') (rs # x <- vres) # x.","proofString":"econstructor; eauto.\nrewrite Regmap.gss; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (x : reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args n args = (n1, args')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_args ge valu2 sp m args' vargs) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) : builtin_function_sem bf vargs = Some (rs # x <- vres) # x.","proofString":"rewrite Regmap.gss; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (x : reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args n args = (n1, args')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_args ge valu2 sp m args' vargs) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) : forall r : positive, r <> x -> (rs # x <- vres) # r = rs # r.","proofString":"intros.\napply Regmap.gso; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (bf : builtin_function) (args : list (builtin_arg positive)) (x : reg) (vargs : list val) (vres : val) (H : numbering_holds valu1 ge sp rs m n) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m args vargs) (H1 : builtin_function_sem bf vargs = Some vres) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args n args = (n1, args')) (valu2 : valuation) (A : numbering_holds valu2 ge sp rs m n1) (B : eval_builtin_args ge valu2 sp m args' vargs) (C : valu_agree valu1 valu2 (num_next n)) (D : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (E : Ple (num_next n) (num_next n1)) (r : positive) (H2 : r <> x) : (rs # x <- vres) # r = rs # r.","proofString":"apply Regmap.gso; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) : wf_numbering (set_unknown n r).","proofString":"constructor; simpl; intros.\neauto with cse.\nrewrite PTree.grspec in H0.\ndestruct (PTree.elt_eq r0 r).\ndiscriminate.\neauto with cse.\nexploit forget_reg_charact; eauto with cse.\nintros [A B].\nrewrite PTree.gro; eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (e : equation) (H0 : In e (num_eqs n)) : wf_equation (num_next n) e.","proofString":"eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : positive) (v0 : valnum) (H0 : (PTree.remove r (num_reg n)) ! r0 = Some v0) : Plt v0 (num_next n).","proofString":"rewrite PTree.grspec in H0.\ndestruct (PTree.elt_eq r0 r).\ndiscriminate.\neauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : positive) (v0 : valnum) (H0 : (if PTree.elt_eq r0 r then None else (num_reg n) ! r0) = Some v0) : Plt v0 (num_next n).","proofString":"destruct (PTree.elt_eq r0 r).\ndiscriminate.\neauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : positive) (v0 : valnum) (e : r0 = r) (H0 : None = Some v0) : Plt v0 (num_next n).","proofString":"discriminate."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : positive) (v0 : valnum) (n0 : r0 <> r) (H0 : (num_reg n) ! r0 = Some v0) : Plt v0 (num_next n).","proofString":"eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : reg) (v0 : positive) (H0 : In r0 (forget_reg n r) # v0) : (PTree.remove r (num_reg n)) ! r0 = Some v0.","proofString":"exploit forget_reg_charact; eauto with cse.\nintros [A B].\nrewrite PTree.gro; eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : reg) (v0 : positive) (H0 : In r0 (forget_reg n r) # v0) : r0 <> r /\\ In r0 (num_val n) # v0 ->\n(PTree.remove r (num_reg n)) ! r0 = Some v0.","proofString":"intros [A B].\nrewrite PTree.gro; eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : reg) (v0 : positive) (H0 : In r0 (forget_reg n r) # v0) (A : r0 <> r) (B : In r0 (num_val n) # v0) : (PTree.remove r (num_reg n)) ! r0 = Some v0.","proofString":"rewrite PTree.gro; eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (eq : equation) (H0 : In eq (num_eqs n)) : equation_holds valu ge sp m eq.","proofString":"eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : positive) (v0 : valnum) (H0 : (PTree.remove r (num_reg n)) ! r0 = Some v0) : (rs # r <- v) # r0 = valu v0.","proofString":"rewrite PTree.grspec in H0.\ndestruct (PTree.elt_eq r0 r).\ndiscriminate.\nrewrite Regmap.gso; eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : positive) (v0 : valnum) (H0 : (if PTree.elt_eq r0 r then None else (num_reg n) ! r0) = Some v0) : (rs # r <- v) # r0 = valu v0.","proofString":"destruct (PTree.elt_eq r0 r).\ndiscriminate.\nrewrite Regmap.gso; eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : positive) (v0 : valnum) (e : r0 = r) (H0 : None = Some v0) : (rs # r <- v) # r0 = valu v0.","proofString":"discriminate."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : positive) (v : val) (H : numbering_holds valu ge sp rs m n) (r0 : positive) (v0 : valnum) (n0 : r0 <> r) (H0 : (num_reg n) ! r0 = Some v0) : (rs # r <- v) # r0 = valu v0.","proofString":"rewrite Regmap.gso; eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (r : builtin_res reg) (v : val) (H : numbering_holds valu ge sp rs m n) : numbering_holds valu ge sp (regmap_setres r v rs) m (set_res_unknown n r).","proofString":"destruct r; simpl; auto.\napply set_unknown_holds; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (x : reg) (v : val) (H : numbering_holds valu ge sp rs m n) : numbering_holds valu ge sp rs # x <- v m (set_unknown n x).","proofString":"apply set_unknown_holds; auto."},{"statement":"(pred : rhs -> bool) (l : valnum) (strict : bool) (r : rhs) (H : False) : pred r = false /\\ False.","proofString":"tauto."},{"statement":"(pred : rhs -> bool) (l : valnum) (strict : bool) (r : rhs) (a : equation) (eqs : list equation) (IHeqs : In (Eq l strict r) (kill_eqs pred eqs) ->\npred r = false /\\ In (Eq l strict r) eqs) (H : In (Eq l strict r)\n  match a with\n  | Eq _ _ r0 =>\n      if pred r0 then kill_eqs pred eqs else a :: kill_eqs pred eqs\n  end) : pred r = false /\\ (a = Eq l strict r \\/ In (Eq l strict r) eqs).","proofString":"destruct a.\ndestruct (pred r0) eqn:PRED.\ntauto.\ninv H.\ninv H0.\nauto.\ntauto."},{"statement":"(pred : rhs -> bool) (l : valnum) (strict : bool) (r : rhs) (v : valnum) (strict0 : bool) (r0 : rhs) (eqs : list equation) (IHeqs : In (Eq l strict r) (kill_eqs pred eqs) ->\npred r = false /\\ In (Eq l strict r) eqs) (H : In (Eq l strict r)\n  (if pred r0\n   then kill_eqs pred eqs\n   else Eq v strict0 r0 :: kill_eqs pred eqs)) : pred r = false /\\ (Eq v strict0 r0 = Eq l strict r \\/ In (Eq l strict r) eqs).","proofString":"destruct (pred r0) eqn:PRED.\ntauto.\ninv H.\ninv H0.\nauto.\ntauto."},{"statement":"(pred : rhs -> bool) (l : valnum) (strict : bool) (r : rhs) (v : valnum) (strict0 : bool) (r0 : rhs) (eqs : list equation) (IHeqs : In (Eq l strict r) (kill_eqs pred eqs) ->\npred r = false /\\ In (Eq l strict r) eqs) (PRED : pred r0 = true) (H : In (Eq l strict r) (kill_eqs pred eqs)) : pred r = false /\\ (Eq v strict0 r0 = Eq l strict r \\/ In (Eq l strict r) eqs).","proofString":"tauto."},{"statement":"(pred : rhs -> bool) (l : valnum) (strict : bool) (r : rhs) (v : valnum) (strict0 : bool) (r0 : rhs) (eqs : list equation) (IHeqs : In (Eq l strict r) (kill_eqs pred eqs) ->\npred r = false /\\ In (Eq l strict r) eqs) (PRED : pred r0 = false) (H : In (Eq l strict r) (Eq v strict0 r0 :: kill_eqs pred eqs)) : pred r = false /\\ (Eq v strict0 r0 = Eq l strict r \\/ In (Eq l strict r) eqs).","proofString":"inv H.\ninv H0.\nauto.\ntauto."},{"statement":"(pred : rhs -> bool) (l : valnum) (strict : bool) (r : rhs) (v : valnum) (strict0 : bool) (r0 : rhs) (eqs : list equation) (IHeqs : In (Eq l strict r) (kill_eqs pred eqs) ->\npred r = false /\\ In (Eq l strict r) eqs) (PRED : pred r0 = false) (H0 : Eq v strict0 r0 = Eq l strict r) : pred r = false /\\ (Eq v strict0 r0 = Eq l strict r \\/ In (Eq l strict r) eqs).","proofString":"inv H0.\nauto."},{"statement":"(pred : rhs -> bool) (l : valnum) (strict : bool) (r : rhs) (eqs : list equation) (IHeqs : In (Eq l strict r) (kill_eqs pred eqs) ->\npred r = false /\\ In (Eq l strict r) eqs) (PRED : pred r = false) : pred r = false /\\ (Eq l strict r = Eq l strict r \\/ In (Eq l strict r) eqs).","proofString":"auto."},{"statement":"(pred : rhs -> bool) (l : valnum) (strict : bool) (r : rhs) (v : valnum) (strict0 : bool) (r0 : rhs) (eqs : list equation) (IHeqs : In (Eq l strict r) (kill_eqs pred eqs) ->\npred r = false /\\ In (Eq l strict r) eqs) (PRED : pred r0 = false) (H0 : In (Eq l strict r) (kill_eqs pred eqs)) : pred r = false /\\ (Eq v strict0 r0 = Eq l strict r \\/ In (Eq l strict r) eqs).","proofString":"tauto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r : rhs) (v : val),\npred r = false ->\nrhs_valid valu ge sp r ->\nrhs_eval_to valu ge sp m r v -> rhs_eval_to valu ge sp m' r v) : wf_numbering (kill_equations pred n).","proofString":"constructor; simpl; intros; eauto with cse.\ndestruct e.\nexploit kill_eqs_charact; eauto.\nintros [A B].\neauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r : rhs) (v : val),\npred r = false ->\nrhs_valid valu ge sp r ->\nrhs_eval_to valu ge sp m r v -> rhs_eval_to valu ge sp m' r v) (e : equation) (H1 : In e (kill_eqs pred (num_eqs n))) : wf_equation (num_next n) e.","proofString":"destruct e.\nexploit kill_eqs_charact; eauto.\nintros [A B].\neauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r0 : rhs) (v0 : val),\npred r0 = false ->\nrhs_valid valu ge sp r0 ->\nrhs_eval_to valu ge sp m r0 v0 -> rhs_eval_to valu ge sp m' r0 v0) (v : valnum) (strict : bool) (r : rhs) (H1 : In (Eq v strict r) (kill_eqs pred (num_eqs n))) : wf_equation (num_next n) (Eq v strict r).","proofString":"exploit kill_eqs_charact; eauto.\nintros [A B].\neauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r0 : rhs) (v0 : val),\npred r0 = false ->\nrhs_valid valu ge sp r0 ->\nrhs_eval_to valu ge sp m r0 v0 -> rhs_eval_to valu ge sp m' r0 v0) (v : valnum) (strict : bool) (r : rhs) (H1 : In (Eq v strict r) (kill_eqs pred (num_eqs n))) : pred r = false /\\ In (Eq v strict r) (num_eqs n) ->\nwf_equation (num_next n) (Eq v strict r).","proofString":"intros [A B].\neauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r0 : rhs) (v0 : val),\npred r0 = false ->\nrhs_valid valu ge sp r0 ->\nrhs_eval_to valu ge sp m r0 v0 -> rhs_eval_to valu ge sp m' r0 v0) (v : valnum) (strict : bool) (r : rhs) (H1 : In (Eq v strict r) (kill_eqs pred (num_eqs n))) (A : pred r = false) (B : In (Eq v strict r) (num_eqs n)) : wf_equation (num_next n) (Eq v strict r).","proofString":"eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r : rhs) (v : val),\npred r = false ->\nrhs_valid valu ge sp r ->\nrhs_eval_to valu ge sp m r v -> rhs_eval_to valu ge sp m' r v) (eq : equation) (H1 : In eq (kill_eqs pred (num_eqs n))) : equation_holds valu ge sp m' eq.","proofString":"destruct eq.\nexploit kill_eqs_charact; eauto.\nintros [A B].\nexploit num_holds_eq; eauto.\nintro EH; inv EH; econstructor; eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r0 : rhs) (v0 : val),\npred r0 = false ->\nrhs_valid valu ge sp r0 ->\nrhs_eval_to valu ge sp m r0 v0 -> rhs_eval_to valu ge sp m' r0 v0) (v : valnum) (strict : bool) (r : rhs) (H1 : In (Eq v strict r) (kill_eqs pred (num_eqs n))) : equation_holds valu ge sp m' (Eq v strict r).","proofString":"exploit kill_eqs_charact; eauto.\nintros [A B].\nexploit num_holds_eq; eauto.\nintro EH; inv EH; econstructor; eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r0 : rhs) (v0 : val),\npred r0 = false ->\nrhs_valid valu ge sp r0 ->\nrhs_eval_to valu ge sp m r0 v0 -> rhs_eval_to valu ge sp m' r0 v0) (v : valnum) (strict : bool) (r : rhs) (H1 : In (Eq v strict r) (kill_eqs pred (num_eqs n))) : pred r = false /\\ In (Eq v strict r) (num_eqs n) ->\nequation_holds valu ge sp m' (Eq v strict r).","proofString":"intros [A B].\nexploit num_holds_eq; eauto.\nintro EH; inv EH; econstructor; eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r0 : rhs) (v0 : val),\npred r0 = false ->\nrhs_valid valu ge sp r0 ->\nrhs_eval_to valu ge sp m r0 v0 -> rhs_eval_to valu ge sp m' r0 v0) (v : valnum) (strict : bool) (r : rhs) (H1 : In (Eq v strict r) (kill_eqs pred (num_eqs n))) (A : pred r = false) (B : In (Eq v strict r) (num_eqs n)) : equation_holds valu ge sp m' (Eq v strict r).","proofString":"exploit num_holds_eq; eauto.\nintro EH; inv EH; econstructor; eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r0 : rhs) (v0 : val),\npred r0 = false ->\nrhs_valid valu ge sp r0 ->\nrhs_eval_to valu ge sp m r0 v0 -> rhs_eval_to valu ge sp m' r0 v0) (v : valnum) (strict : bool) (r : rhs) (H1 : In (Eq v strict r) (kill_eqs pred (num_eqs n))) (A : pred r = false) (B : In (Eq v strict r) (num_eqs n)) : equation_holds valu ge sp m (Eq v strict r) ->\nequation_holds valu ge sp m' (Eq v strict r).","proofString":"intro EH; inv EH; econstructor; eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (pred : rhs -> bool) (m' : mem) (H : numbering_holds valu ge sp rs m n) (H0 : forall (r0 : rhs) (v0 : val),\npred r0 = false ->\nrhs_valid valu ge sp r0 ->\nrhs_eval_to valu ge sp m r0 v0 -> rhs_eval_to valu ge sp m' r0 v0) (r : positive) (v : valnum) (H1 : (num_reg n) ! r = Some v) : rs # r = valu v.","proofString":"eauto with cse."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (m' : mem) (H : numbering_holds valu ge sp rs m n) : numbering_holds valu ge sp rs m' (kill_all_loads n).","proofString":"eapply kill_equations_hold; eauto.\nunfold filter_loads; intros.\ninv H2.\nconstructor.\nrewrite <- H3.\napply op_depends_on_memory_correct; auto.\ndiscriminate.\neconstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (m' : mem) (H : numbering_holds valu ge sp rs m n) : forall (r : rhs) (v : val),\nfilter_loads r = false ->\nrhs_valid valu ge sp r ->\nrhs_eval_to valu ge sp m r v -> rhs_eval_to valu ge sp m' r v.","proofString":"unfold filter_loads; intros.\ninv H2.\nconstructor.\nrewrite <- H3.\napply op_depends_on_memory_correct; auto.\ndiscriminate.\neconstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (m' : mem) (H : numbering_holds valu ge sp rs m n) (r : rhs) (v : val) (H0 : match r with\n| Op op _ => op_depends_on_memory op\n| Load _ _ _ _ => true\n| Builtin _ args => builtin_args_depends_on_memory args\nend = false) (H1 : rhs_valid valu ge sp r) (H2 : rhs_eval_to valu ge sp m r v) : rhs_eval_to valu ge sp m' r v.","proofString":"inv H2.\nconstructor.\nrewrite <- H3.\napply op_depends_on_memory_correct; auto.\ndiscriminate.\neconstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (m' : mem) (H : numbering_holds valu ge sp rs m n) (v : val) (op : operation) (vl : list valnum) (H1 : rhs_valid valu ge sp (Op op vl)) (H0 : op_depends_on_memory op = false) (H3 : eval_operation ge sp op (map valu vl) m = Some v) : rhs_eval_to valu ge sp m' (Op op vl) v.","proofString":"constructor.\nrewrite <- H3.\napply op_depends_on_memory_correct; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (m' : mem) (H : numbering_holds valu ge sp rs m n) (v : val) (op : operation) (vl : list valnum) (H1 : rhs_valid valu ge sp (Op op vl)) (H0 : op_depends_on_memory op = false) (H3 : eval_operation ge sp op (map valu vl) m = Some v) : eval_operation ge sp op (map valu vl) m' = Some v.","proofString":"rewrite <- H3.\napply op_depends_on_memory_correct; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (m' : mem) (H : numbering_holds valu ge sp rs m n) (v : val) (op : operation) (vl : list valnum) (H1 : rhs_valid valu ge sp (Op op vl)) (H0 : op_depends_on_memory op = false) (H3 : eval_operation ge sp op (map valu vl) m = Some v) : eval_operation ge sp op (map valu vl) m' =\neval_operation ge sp op (map valu vl) m.","proofString":"apply op_depends_on_memory_correct; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (m' : mem) (H : numbering_holds valu ge sp rs m n) (v : val) (chunk : memory_chunk) (addr : addressing) (vl : list valnum) (p : aptr) (H1 : rhs_valid valu ge sp (Load chunk addr vl p)) (H0 : true = false) (a : val) (H3 : eval_addressing ge sp addr (map valu vl) = Some a) (H4 : Mem.loadv chunk m a = Some v) : rhs_eval_to valu ge sp m' (Load chunk addr vl p) v.","proofString":"discriminate."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (m' : mem) (H : numbering_holds valu ge sp rs m n) (v : val) (args : list (builtin_arg valnum)) (bf : builtin_function) (H1 : rhs_valid valu ge sp (Builtin bf args)) (H0 : builtin_args_depends_on_memory args = false) (vargs : list val) (H3 : eval_builtin_args ge valu sp m args vargs) (H4 : builtin_function_sem bf vargs = Some v) : rhs_eval_to valu ge sp m' (Builtin bf args) v.","proofString":"econstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (approx : VA.t') (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  (kill_loads_after_store approx n chunk addr args).","proofString":"apply kill_equations_hold with m; auto.\nintros.\nunfold filter_after_store in H6; inv H8.\nconstructor.\nrewrite <- H9.\napply op_depends_on_memory_correct; auto.\neconstructor; eauto.\nrewrite <- H10.\ndestruct a; simpl in H1; try discriminate.\ndestruct a0; simpl in H10; try discriminate.\nsimpl.\nrewrite negb_false_iff in H6.\nunfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va.\neconstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (approx : VA.t') (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) : forall (r : rhs) (v0 : val),\nfilter_after_store n (aaddressing approx addr args) (size_chunk chunk) r =\nfalse ->\nrhs_valid valu ge (Vptr sp Ptrofs.zero) r ->\nrhs_eval_to valu ge (Vptr sp Ptrofs.zero) m r v0 ->\nrhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' r v0.","proofString":"intros.\nunfold filter_after_store in H6; inv H8.\nconstructor.\nrewrite <- H9.\napply op_depends_on_memory_correct; auto.\neconstructor; eauto.\nrewrite <- H10.\ndestruct a; simpl in H1; try discriminate.\ndestruct a0; simpl in H10; try discriminate.\nsimpl.\nrewrite negb_false_iff in H6.\nunfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va.\neconstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (approx : VA.t') (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (r : rhs) (v0 : val) (H6 : filter_after_store n (aaddressing approx addr args) (size_chunk chunk) r =\nfalse) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) r) (H8 : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m r v0) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' r v0.","proofString":"unfold filter_after_store in H6; inv H8.\nconstructor.\nrewrite <- H9.\napply op_depends_on_memory_correct; auto.\neconstructor; eauto.\nrewrite <- H10.\ndestruct a; simpl in H1; try discriminate.\ndestruct a0; simpl in H10; try discriminate.\nsimpl.\nrewrite negb_false_iff in H6.\nunfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va.\neconstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (op : operation) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Op op vl)) (H6 : op_depends_on_memory op = false) (H9 : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m = Some v0) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' (Op op vl) v0.","proofString":"constructor.\nrewrite <- H9.\napply op_depends_on_memory_correct; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (op : operation) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Op op vl)) (H6 : op_depends_on_memory op = false) (H9 : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m = Some v0) : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m' = Some v0.","proofString":"rewrite <- H9.\napply op_depends_on_memory_correct; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (op : operation) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Op op vl)) (H6 : op_depends_on_memory op = false) (H9 : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m = Some v0) : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m' =\neval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m.","proofString":"apply op_depends_on_memory_correct; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk0 addr0 vl p)) (H6 : negb\n  (pdisjoint p (size_chunk chunk0) (aaddressing (VA.State ae am) addr args)\n     (size_chunk chunk)) = false) (a0 : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) = Some a0) (H10 : Mem.loadv chunk0 m a0 = Some v0) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' (Load chunk0 addr0 vl p) v0.","proofString":"econstructor; eauto.\nrewrite <- H10.\ndestruct a; simpl in H1; try discriminate.\ndestruct a0; simpl in H10; try discriminate.\nsimpl.\nrewrite negb_false_iff in H6.\nunfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk0 addr0 vl p)) (H6 : negb\n  (pdisjoint p (size_chunk chunk0) (aaddressing (VA.State ae am) addr args)\n     (size_chunk chunk)) = false) (a0 : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) = Some a0) (H10 : Mem.loadv chunk0 m a0 = Some v0) : Mem.loadv chunk0 m' a0 = Some v0.","proofString":"rewrite <- H10.\ndestruct a; simpl in H1; try discriminate.\ndestruct a0; simpl in H10; try discriminate.\nsimpl.\nrewrite negb_false_iff in H6.\nunfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk0 addr0 vl p)) (H6 : negb\n  (pdisjoint p (size_chunk chunk0) (aaddressing (VA.State ae am) addr args)\n     (size_chunk chunk)) = false) (a0 : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) = Some a0) (H10 : Mem.loadv chunk0 m a0 = Some v0) : Mem.loadv chunk0 m' a0 = Mem.loadv chunk0 m a0.","proofString":"destruct a; simpl in H1; try discriminate.\ndestruct a0; simpl in H10; try discriminate.\nsimpl.\nrewrite negb_false_iff in H6.\nunfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk0 addr0 vl p)) (H6 : negb\n  (pdisjoint p (size_chunk chunk0) (aaddressing (VA.State ae am) addr args)\n     (size_chunk chunk)) = false) (a0 : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) = Some a0) (H10 : Mem.loadv chunk0 m a0 = Some v0) : Mem.loadv chunk0 m' a0 = Mem.loadv chunk0 m a0.","proofString":"destruct a0; simpl in H10; try discriminate.\nsimpl.\nrewrite negb_false_iff in H6.\nunfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk0 addr0 vl p)) (H6 : negb\n  (pdisjoint p (size_chunk chunk0) (aaddressing (VA.State ae am) addr args)\n     (size_chunk chunk)) = false) (b0 : block) (i0 : ptrofs) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b0 i0)) (H10 : Mem.load chunk0 m b0 (Ptrofs.unsigned i0) = Some v0) : Mem.loadv chunk0 m' (Vptr b0 i0) = Mem.loadv chunk0 m (Vptr b0 i0).","proofString":"simpl.\nrewrite negb_false_iff in H6.\nunfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk0 addr0 vl p)) (H6 : negb\n  (pdisjoint p (size_chunk chunk0) (aaddressing (VA.State ae am) addr args)\n     (size_chunk chunk)) = false) (b0 : block) (i0 : ptrofs) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b0 i0)) (H10 : Mem.load chunk0 m b0 (Ptrofs.unsigned i0) = Some v0) : Mem.load chunk0 m' b0 (Ptrofs.unsigned i0) =\nMem.load chunk0 m b0 (Ptrofs.unsigned i0).","proofString":"rewrite negb_false_iff in H6.\nunfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk0 addr0 vl p)) (H6 : pdisjoint p (size_chunk chunk0) (aaddressing (VA.State ae am) addr args)\n  (size_chunk chunk) = true) (b0 : block) (i0 : ptrofs) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b0 i0)) (H10 : Mem.load chunk0 m b0 (Ptrofs.unsigned i0) = Some v0) : Mem.load chunk0 m' b0 (Ptrofs.unsigned i0) =\nMem.load chunk0 m b0 (Ptrofs.unsigned i0).","proofString":"unfold aaddressing in H6.\ninv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk0 addr0 vl p)) (H6 : pdisjoint p (size_chunk chunk0)\n  (aptr_of_aval (eval_static_addressing addr (aregs ae args)))\n  (size_chunk chunk) = true) (b0 : block) (i0 : ptrofs) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b0 i0)) (H10 : Mem.load chunk0 m b0 (Ptrofs.unsigned i0) = Some v0) : Mem.load chunk0 m' b0 (Ptrofs.unsigned i0) =\nMem.load chunk0 m b0 (Ptrofs.unsigned i0).","proofString":"inv H7.\nrewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H6 : pdisjoint p (size_chunk chunk0)\n  (aptr_of_aval (eval_static_addressing addr (aregs ae args)))\n  (size_chunk chunk) = true) (b0 : block) (i0 : ptrofs) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b0 i0)) (H10 : Mem.load chunk0 m b0 (Ptrofs.unsigned i0) = Some v0) (b1 : block) (ofs : ptrofs) (bc0 : block_classification) (H14 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b1 ofs)) (H15 : pmatch bc0 b1 ofs p) (H16 : genv_match bc0 ge) (H17 : bc0 sp = BCstack) : Mem.load chunk0 m' b0 (Ptrofs.unsigned i0) =\nMem.load chunk0 m b0 (Ptrofs.unsigned i0).","proofString":"rewrite H9 in H14; inv H14.\neapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H6 : pdisjoint p (size_chunk chunk0)\n  (aptr_of_aval (eval_static_addressing addr (aregs ae args)))\n  (size_chunk chunk) = true) (b1 : block) (ofs : ptrofs) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b1 ofs)) (H10 : Mem.load chunk0 m b1 (Ptrofs.unsigned ofs) = Some v0) (bc0 : block_classification) (H15 : pmatch bc0 b1 ofs p) (H16 : genv_match bc0 ge) (H17 : bc0 sp = BCstack) : Mem.load chunk0 m' b1 (Ptrofs.unsigned ofs) =\nMem.load chunk0 m b1 (Ptrofs.unsigned ofs).","proofString":"eapply Mem.load_store_other.\neauto.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H6 : pdisjoint p (size_chunk chunk0)\n  (aptr_of_aval (eval_static_addressing addr (aregs ae args)))\n  (size_chunk chunk) = true) (b1 : block) (ofs : ptrofs) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b1 ofs)) (H10 : Mem.load chunk0 m b1 (Ptrofs.unsigned ofs) = Some v0) (bc0 : block_classification) (H15 : pmatch bc0 b1 ofs p) (H16 : genv_match bc0 ge) (H17 : bc0 sp = BCstack) : pmatch bc b i (aptr_of_aval (eval_static_addressing addr (aregs ae args))).","proofString":"apply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H6 : pdisjoint p (size_chunk chunk0)\n  (aptr_of_aval (eval_static_addressing addr (aregs ae args)))\n  (size_chunk chunk) = true) (b1 : block) (ofs : ptrofs) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b1 ofs)) (H10 : Mem.load chunk0 m b1 (Ptrofs.unsigned ofs) = Some v0) (bc0 : block_classification) (H15 : pmatch bc0 b1 ofs p) (H16 : genv_match bc0 ge) (H17 : bc0 sp = BCstack) : vmatch bc (Vptr b i) (eval_static_addressing addr (aregs ae args)).","proofString":"eapply eval_static_addressing_sound; eauto.\neauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (chunk0 : memory_chunk) (p : aptr) (addr0 : addressing) (vl : list valnum) (H6 : pdisjoint p (size_chunk chunk0)\n  (aptr_of_aval (eval_static_addressing addr (aregs ae args)))\n  (size_chunk chunk) = true) (b1 : block) (ofs : ptrofs) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr0 (map valu vl) =\nSome (Vptr b1 ofs)) (H10 : Mem.load chunk0 m b1 (Ptrofs.unsigned ofs) = Some v0) (bc0 : block_classification) (H15 : pmatch bc0 b1 ofs p) (H16 : genv_match bc0 ge) (H17 : bc0 sp = BCstack) : list_forall2 (vmatch bc) rs ## args (aregs ae args).","proofString":"eauto with va."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (v : val) (m' : mem) (bc : block_classification) (ae : aenv) (am : amem) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a v = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (v0 : val) (args0 : list (builtin_arg valnum)) (bf : builtin_function) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Builtin bf args0)) (H6 : builtin_args_depends_on_memory args0 = false) (vargs : list val) (H9 : eval_builtin_args ge valu (Vptr sp Ptrofs.zero) m args0 vargs) (H10 : builtin_function_sem bf vargs = Some v0) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' (Builtin bf args0) v0.","proofString":"econstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (n : numbering) (H : numbering_holds valu ge sp rs m n) : numbering_holds valu ge sp rs m (kill_cheap_computations n).","proofString":"eapply kill_equations_hold; eauto."},{"statement":"(bc : block_classification) (chunk : memory_chunk) (v : val) (H : vmatch bc v (store_normalized_range chunk)) : Val.lessdef (Val.load_result chunk v) v.","proofString":"unfold Val.load_result; remember Archi.ptr64 as ptr64.\ndestruct chunk; simpl in *; destruct v; auto.\ninv H.\napply is_uns_1 in H4; destruct H4; subst i; auto.\ninv H.\nrewrite is_sgn_sign_ext in H4 by lia.\nrewrite H4; auto.\ninv H.\nrewrite is_uns_zero_ext in H4 by lia.\nrewrite H4; auto.\ninv H.\nrewrite is_sgn_sign_ext in H4 by lia.\nrewrite H4; auto.\ninv H.\nrewrite is_uns_zero_ext in H4 by lia.\nrewrite H4; auto.\ndestruct ptr64; auto.\ndestruct ptr64; auto.\ndestruct ptr64; auto."},{"statement":"(bc : block_classification) (chunk : memory_chunk) (v : val) (H : vmatch bc v (store_normalized_range chunk)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : Val.lessdef\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end v.","proofString":"destruct chunk; simpl in *; destruct v; auto.\ninv H.\napply is_uns_1 in H4; destruct H4; subst i; auto.\ninv H.\nrewrite is_sgn_sign_ext in H4 by lia.\nrewrite H4; auto.\ninv H.\nrewrite is_uns_zero_ext in H4 by lia.\nrewrite H4; auto.\ninv H.\nrewrite is_sgn_sign_ext in H4 by lia.\nrewrite H4; auto.\ninv H.\nrewrite is_uns_zero_ext in H4 by lia.\nrewrite H4; auto.\ndestruct ptr64; auto.\ndestruct ptr64; auto.\ndestruct ptr64; auto."},{"statement":"(bc : block_classification) (i : int) (H : vmatch bc (Vint i) (Uns Ptop 1)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : Val.lessdef (Val.norm_bool (Vint (Int.zero_ext 8 i))) (Vint i).","proofString":"inv H.\napply is_uns_1 in H4; destruct H4; subst i; auto."},{"statement":"(bc : block_classification) (i : int) (H3 : 0 <= 1) (H4 : is_uns 1 i) : Val.lessdef (Val.norm_bool (Vint (Int.zero_ext 8 i))) (Vint i).","proofString":"apply is_uns_1 in H4; destruct H4; subst i; auto."},{"statement":"(bc : block_classification) (i : int) (H : vmatch bc (Vint i) (Sgn Ptop 8)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : Val.lessdef (Vint (Int.sign_ext 8 i)) (Vint i).","proofString":"inv H.\nrewrite is_sgn_sign_ext in H4 by lia.\nrewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H3 : 0 < 8) (H4 : is_sgn 8 i) : Val.lessdef (Vint (Int.sign_ext 8 i)) (Vint i).","proofString":"rewrite is_sgn_sign_ext in H4 by lia.\nrewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H3 : 0 < 8) (H4 : Int.sign_ext 8 i = i) : Val.lessdef (Vint (Int.sign_ext 8 i)) (Vint i).","proofString":"rewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H : vmatch bc (Vint i) (Uns Ptop 8)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : Val.lessdef (Vint (Int.zero_ext 8 i)) (Vint i).","proofString":"inv H.\nrewrite is_uns_zero_ext in H4 by lia.\nrewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H3 : 0 <= 8) (H4 : is_uns 8 i) : Val.lessdef (Vint (Int.zero_ext 8 i)) (Vint i).","proofString":"rewrite is_uns_zero_ext in H4 by lia.\nrewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H3 : 0 <= 8) (H4 : Int.zero_ext 8 i = i) : Val.lessdef (Vint (Int.zero_ext 8 i)) (Vint i).","proofString":"rewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H : vmatch bc (Vint i) (Sgn Ptop 16)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : Val.lessdef (Vint (Int.sign_ext 16 i)) (Vint i).","proofString":"inv H.\nrewrite is_sgn_sign_ext in H4 by lia.\nrewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H3 : 0 < 16) (H4 : is_sgn 16 i) : Val.lessdef (Vint (Int.sign_ext 16 i)) (Vint i).","proofString":"rewrite is_sgn_sign_ext in H4 by lia.\nrewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H3 : 0 < 16) (H4 : Int.sign_ext 16 i = i) : Val.lessdef (Vint (Int.sign_ext 16 i)) (Vint i).","proofString":"rewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H : vmatch bc (Vint i) (Uns Ptop 16)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : Val.lessdef (Vint (Int.zero_ext 16 i)) (Vint i).","proofString":"inv H.\nrewrite is_uns_zero_ext in H4 by lia.\nrewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H3 : 0 <= 16) (H4 : is_uns 16 i) : Val.lessdef (Vint (Int.zero_ext 16 i)) (Vint i).","proofString":"rewrite is_uns_zero_ext in H4 by lia.\nrewrite H4; auto."},{"statement":"(bc : block_classification) (i : int) (H3 : 0 <= 16) (H4 : Int.zero_ext 16 i = i) : Val.lessdef (Vint (Int.zero_ext 16 i)) (Vint i).","proofString":"rewrite H4; auto."},{"statement":"(bc : block_classification) (b : block) (i : ptrofs) (H : vmatch bc (Vptr b i) Vtop) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : Val.lessdef (if ptr64 then Vundef else Vptr b i) (Vptr b i).","proofString":"destruct ptr64; auto."},{"statement":"(bc : block_classification) (b : block) (i : ptrofs) (H : vmatch bc (Vptr b i) Vtop) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : Val.lessdef (if ptr64 then Vptr b i else Vundef) (Vptr b i).","proofString":"destruct ptr64; auto."},{"statement":"(bc : block_classification) (b : block) (i : ptrofs) (H : vmatch bc (Vptr b i) Vtop) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : Val.lessdef (if ptr64 then Vundef else Vptr b i) (Vptr b i).","proofString":"destruct ptr64; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) : exists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m'\n    (if vincl (avalue approx src) (store_normalized_range chunk)\n     then\n      let (n1, vsrc) := valnum_reg n src in\n      let (n2, vargs) := valnum_regs n1 args in\n      {|\n        num_next := num_next n2;\n        num_eqs :=\n          Eq vsrc false\n            (Load chunk addr vargs (aaddressing approx addr args))\n          :: num_eqs n2;\n        num_reg := num_reg n2;\n        num_val := num_val n2\n      |}\n     else n).","proofString":"unfold avalue; rewrite H5.\ndestruct (vincl (AE.get src ae) (store_normalized_range chunk)) eqn:INCL.\ndestruct (valnum_reg n src) as [n1 vsrc] eqn:VR1.\ndestruct (valnum_regs n1 args) as [n2 vargs] eqn:VR2.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit valnum_regs_holds; eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3.\nconstructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse.\nexists valu1; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) : exists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m'\n    (if vincl (AE.get src ae) (store_normalized_range chunk)\n     then\n      let (n1, vsrc) := valnum_reg n src in\n      let (n2, vargs) := valnum_regs n1 args in\n      {|\n        num_next := num_next n2;\n        num_eqs :=\n          Eq vsrc false\n            (Load chunk addr vargs (aaddressing (VA.State ae am) addr args))\n          :: num_eqs n2;\n        num_reg := num_reg n2;\n        num_val := num_val n2\n      |}\n     else n).","proofString":"destruct (vincl (AE.get src ae) (store_normalized_range chunk)) eqn:INCL.\ndestruct (valnum_reg n src) as [n1 vsrc] eqn:VR1.\ndestruct (valnum_regs n1 args) as [n2 vargs] eqn:VR2.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit valnum_regs_holds; eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3.\nconstructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse.\nexists valu1; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) : exists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m'\n    (let (n1, vsrc) := valnum_reg n src in\n     let (n2, vargs) := valnum_regs n1 args in\n     {|\n       num_next := num_next n2;\n       num_eqs :=\n         Eq vsrc false\n           (Load chunk addr vargs (aaddressing (VA.State ae am) addr args))\n         :: num_eqs n2;\n       num_reg := num_reg n2;\n       num_val := num_val n2\n     |}).","proofString":"destruct (valnum_reg n src) as [n1 vsrc] eqn:VR1.\ndestruct (valnum_regs n1 args) as [n2 vargs] eqn:VR2.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit valnum_regs_holds; eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3.\nconstructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) : exists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m'\n    (let (n2, vargs) := valnum_regs n1 args in\n     {|\n       num_next := num_next n2;\n       num_eqs :=\n         Eq vsrc false\n           (Load chunk addr vargs (aaddressing (VA.State ae am) addr args))\n         :: num_eqs n2;\n       num_reg := num_reg n2;\n       num_val := num_val n2\n     |}).","proofString":"destruct (valnum_regs n1 args) as [n2 vargs] eqn:VR2.\nexploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit valnum_regs_holds; eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3.\nconstructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) : exists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m'\n    {|\n      num_next := num_next n2;\n      num_eqs :=\n        Eq vsrc false\n          (Load chunk addr vargs (aaddressing (VA.State ae am) addr args))\n        :: num_eqs n2;\n      num_reg := num_reg n2;\n      num_val := num_val n2\n    |}.","proofString":"exploit valnum_reg_holds; eauto.\nintros (valu2 & A & B & C & D & E).\nexploit valnum_regs_holds; eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3.\nconstructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) : (exists valu2 : valuation,\n   numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1 /\\\n   rs # src = valu2 vsrc /\\\n   valu_agree valu1 valu2 (num_next n) /\\\n   Plt vsrc (num_next n1) /\\ Ple (num_next n) (num_next n1)) ->\nexists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m'\n    {|\n      num_next := num_next n2;\n      num_eqs :=\n        Eq vsrc false\n          (Load chunk addr vargs (aaddressing (VA.State ae am) addr args))\n        :: num_eqs n2;\n      num_reg := num_reg n2;\n      num_val := num_val n2\n    |}.","proofString":"intros (valu2 & A & B & C & D & E).\nexploit valnum_regs_holds; eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3.\nconstructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) rs m'\n    {|\n      num_next := num_next n2;\n      num_eqs :=\n        Eq vsrc false\n          (Load chunk addr vargs (aaddressing (VA.State ae am) addr args))\n        :: num_eqs n2;\n      num_reg := num_reg n2;\n      num_val := num_val n2\n    |}.","proofString":"exploit valnum_regs_holds; eauto.\nintros (valu3 & P & Q & R & S & T).\nexists valu3.\nconstructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) : (exists valu3 : valuation,\n   numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2 /\\\n   rs ## args = map valu3 vargs /\\\n   valu_agree valu2 valu3 (num_next n1) /\\\n   (forall v : valnum, In v vargs -> Plt v (num_next n2)) /\\\n   Ple (num_next n1) (num_next n2)) ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) rs m'\n    {|\n      num_next := num_next n2;\n      num_eqs :=\n        Eq vsrc false\n          (Load chunk addr vargs (aaddressing (VA.State ae am) addr args))\n        :: num_eqs n2;\n      num_reg := num_reg n2;\n      num_val := num_val n2\n    |}.","proofString":"intros (valu3 & P & Q & R & S & T).\nexists valu3.\nconstructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) rs m'\n    {|\n      num_next := num_next n2;\n      num_eqs :=\n        Eq vsrc false\n          (Load chunk addr vargs (aaddressing (VA.State ae am) addr args))\n        :: num_eqs n2;\n      num_reg := num_reg n2;\n      num_val := num_val n2\n    |}.","proofString":"exists valu3.\nconstructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m'\n  {|\n    num_next := num_next n2;\n    num_eqs :=\n      Eq vsrc false\n        (Load chunk addr vargs (aaddressing (VA.State ae am) addr args))\n      :: num_eqs n2;\n    num_reg := num_reg n2;\n    num_val := num_val n2\n  |}.","proofString":"constructor; simpl; intros.\nconstructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto.\ndestruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\neauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : wf_numbering\n  {|\n    num_next := num_next n2;\n    num_eqs :=\n      Eq vsrc false\n        (Load chunk addr vargs\n           (aptr_of_aval (eval_static_addressing addr (aregs ae args))))\n      :: num_eqs n2;\n    num_reg := num_reg n2;\n    num_val := num_val n2\n  |}.","proofString":"constructor; simpl; intros; eauto with cse.\ndestruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) (e : equation) (H6 : Eq vsrc false\n  (Load chunk addr vargs\n     (aptr_of_aval (eval_static_addressing addr (aregs ae args)))) = e \\/\nIn e (num_eqs n2)) : wf_equation (num_next n2) e.","proofString":"destruct H6; eauto with cse.\nsubst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) (e : equation) (H6 : Eq vsrc false\n  (Load chunk addr vargs\n     (aptr_of_aval (eval_static_addressing addr (aregs ae args)))) = e) : wf_equation (num_next n2) e.","proofString":"subst e.\nsplit.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : wf_equation (num_next n2)\n  (Eq vsrc false\n     (Load chunk addr vargs\n        (aptr_of_aval (eval_static_addressing addr (aregs ae args))))).","proofString":"split.\neapply Pos.lt_le_trans; eauto.\nred; simpl; intros.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : Plt vsrc (num_next n2).","proofString":"eapply Pos.lt_le_trans; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : wf_rhs (num_next n2)\n  (Load chunk addr vargs\n     (aptr_of_aval (eval_static_addressing addr (aregs ae args)))).","proofString":"red; simpl; intros.\nauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v0 : valnum, In v0 vargs -> Plt v0 (num_next n2)) (T : Ple (num_next n1) (num_next n2)) (v : valnum) (H6 : In v vargs) : Plt v (num_next n2).","proofString":"auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) (eq : equation) (H6 : Eq vsrc false\n  (Load chunk addr vargs\n     (aptr_of_aval (eval_static_addressing addr (aregs ae args)))) = eq \\/\nIn eq (num_eqs n2)) : equation_holds valu3 ge (Vptr sp Ptrofs.zero) m' eq.","proofString":"destruct H6; eauto with cse.\nsubst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) (eq : equation) (H6 : Eq vsrc false\n  (Load chunk addr vargs\n     (aptr_of_aval (eval_static_addressing addr (aregs ae args)))) = eq) : equation_holds valu3 ge (Vptr sp Ptrofs.zero) m' eq.","proofString":"subst eq.\napply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : equation_holds valu3 ge (Vptr sp Ptrofs.zero) m'\n  (Eq vsrc false\n     (Load chunk addr vargs\n        (aptr_of_aval (eval_static_addressing addr (aregs ae args))))).","proofString":"apply eq_holds_lessdef with (Val.load_result chunk rs#src).\napply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto.\nrewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4.\ndestruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : rhs_eval_to valu3 ge (Vptr sp Ptrofs.zero) m'\n  (Load chunk addr vargs\n     (aptr_of_aval (eval_static_addressing addr (aregs ae args))))\n  (Val.load_result chunk rs # src).","proofString":"apply load_eval_to with a.\nrewrite <- Q; auto.\ndestruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu3 vargs) = Some a.","proofString":"rewrite <- Q; auto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : Mem.loadv chunk m' a = Some (Val.load_result chunk rs # src).","proofString":"destruct a; try discriminate.\nsimpl.\neapply Mem.load_store_same; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.storev chunk m (Vptr b i) rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : Mem.loadv chunk m' (Vptr b i) = Some (Val.load_result chunk rs # src).","proofString":"simpl.\neapply Mem.load_store_same; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.storev chunk m (Vptr b i) rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : Mem.load chunk m' b (Ptrofs.unsigned i) =\nSome (Val.load_result chunk rs # src).","proofString":"eapply Mem.load_store_same; eauto."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : Val.lessdef (Val.load_result chunk rs # src) (valu3 vsrc).","proofString":"rewrite B.\nrewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : Val.lessdef (Val.load_result chunk (valu2 vsrc)) (valu3 vsrc).","proofString":"rewrite R by auto.\napply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : Val.lessdef (Val.load_result chunk (valu2 vsrc)) (valu2 vsrc).","proofString":"apply store_normalized_range_sound with bc.\nrewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : vmatch bc (valu2 vsrc) (store_normalized_range chunk).","proofString":"rewrite <- B.\neapply vmatch_ge.\napply vincl_ge; eauto.\napply H4."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : vmatch bc rs # src (store_normalized_range chunk).","proofString":"eapply vmatch_ge.\napply vincl_ge; eauto.\napply H4."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : rhs_valid valu3 ge (Vptr sp Ptrofs.zero)\n  (Load chunk addr vargs\n     (aptr_of_aval (eval_static_addressing addr (aregs ae args)))).","proofString":"destruct a; try discriminate.\neconstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.storev chunk m (Vptr b i) rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : rhs_valid valu3 ge (Vptr sp Ptrofs.zero)\n  (Load chunk addr vargs\n     (aptr_of_aval (eval_static_addressing addr (aregs ae args)))).","proofString":"econstructor; eauto.\nrewrite <- Q.\neassumption.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (b : block) (i : ptrofs) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.storev chunk m (Vptr b i) rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v : valnum, In v vargs -> Plt v (num_next n2)) (T : Ple (num_next n1) (num_next n2)) : vmatch bc (Vptr b i) (eval_static_addressing addr (aregs ae args)).","proofString":"eapply eval_static_addressing_sound; eauto with va."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = true) (n1 : numbering) (vsrc : valnum) (VR1 : valnum_reg n src = (n1, vsrc)) (n2 : numbering) (vargs : list valnum) (VR2 : valnum_regs n1 args = (n2, vargs)) (valu2 : valuation) (A : numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n1) (B : rs # src = valu2 vsrc) (C : valu_agree valu1 valu2 (num_next n)) (D : Plt vsrc (num_next n1)) (E : Ple (num_next n) (num_next n1)) (valu3 : valuation) (P : numbering_holds valu3 ge (Vptr sp Ptrofs.zero) rs m' n2) (Q : rs ## args = map valu3 vargs) (R : valu_agree valu2 valu3 (num_next n1)) (S : forall v0 : valnum, In v0 vargs -> Plt v0 (num_next n2)) (T : Ple (num_next n1) (num_next n2)) (r : positive) (v : valnum) (H6 : (num_reg n2) ! r = Some v) : rs # r = valu3 v.","proofString":"eauto with cse."},{"statement":"(valu1 : valuation) (ge : genv) (sp : block) (rs : regset) (m' : mem) (n : numbering) (addr : addressing) (args : list positive) (a : val) (chunk : memory_chunk) (m : mem) (src : positive) (bc : block_classification) (ae : aenv) (approx : VA.t') (am : amem) (H : numbering_holds valu1 ge (Vptr sp Ptrofs.zero) rs m' n) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : ematch bc rs ae) (H5 : approx = VA.State ae am) (INCL : vincl (AE.get src ae) (store_normalized_range chunk) = false) : exists valu2 : valuation,\n  numbering_holds valu2 ge (Vptr sp Ptrofs.zero) rs m' n.","proofString":"exists valu1; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  (kill_loads_after_storebytes n dst sz).","proofString":"apply kill_equations_hold with m; auto.\nintros.\nunfold filter_after_store in H6; inv H8.\nconstructor.\nrewrite <- H9.\napply op_depends_on_memory_correct; auto.\ninv H7.\nrewrite H9 in H15; inv H15.\neconstructor; eauto.\nrewrite <- H10.\nsimpl.\nrewrite negb_false_iff in H6.\neapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\neconstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) : forall (r : rhs) (v : val),\nfilter_after_store n dst sz r = false ->\nrhs_valid valu ge (Vptr sp Ptrofs.zero) r ->\nrhs_eval_to valu ge (Vptr sp Ptrofs.zero) m r v ->\nrhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' r v.","proofString":"intros.\nunfold filter_after_store in H6; inv H8.\nconstructor.\nrewrite <- H9.\napply op_depends_on_memory_correct; auto.\ninv H7.\nrewrite H9 in H15; inv H15.\neconstructor; eauto.\nrewrite <- H10.\nsimpl.\nrewrite negb_false_iff in H6.\neapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\neconstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (r : rhs) (v : val) (H6 : filter_after_store n dst sz r = false) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) r) (H8 : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m r v) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' r v.","proofString":"unfold filter_after_store in H6; inv H8.\nconstructor.\nrewrite <- H9.\napply op_depends_on_memory_correct; auto.\ninv H7.\nrewrite H9 in H15; inv H15.\neconstructor; eauto.\nrewrite <- H10.\nsimpl.\nrewrite negb_false_iff in H6.\neapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto.\neconstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (op : operation) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Op op vl)) (H6 : op_depends_on_memory op = false) (H9 : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m = Some v) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' (Op op vl) v.","proofString":"constructor.\nrewrite <- H9.\napply op_depends_on_memory_correct; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (op : operation) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Op op vl)) (H6 : op_depends_on_memory op = false) (H9 : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m = Some v) : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m' = Some v.","proofString":"rewrite <- H9.\napply op_depends_on_memory_correct; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (op : operation) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Op op vl)) (H6 : op_depends_on_memory op = false) (H9 : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m = Some v) : eval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m' =\neval_operation ge (Vptr sp Ptrofs.zero) op (map valu vl) m.","proofString":"apply op_depends_on_memory_correct; auto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (chunk : memory_chunk) (p : aptr) (addr : addressing) (vl : list valnum) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk addr vl p)) (H6 : negb (pdisjoint p (size_chunk chunk) dst sz) = false) (a : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) = Some a) (H10 : Mem.loadv chunk m a = Some v) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' (Load chunk addr vl p) v.","proofString":"inv H7.\nrewrite H9 in H15; inv H15.\neconstructor; eauto.\nrewrite <- H10.\nsimpl.\nrewrite negb_false_iff in H6.\neapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (chunk : memory_chunk) (p : aptr) (addr : addressing) (vl : list valnum) (H6 : negb (pdisjoint p (size_chunk chunk) dst sz) = false) (a : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) = Some a) (H10 : Mem.loadv chunk m a = Some v) (b0 : block) (ofs0 : ptrofs) (bc0 : block_classification) (H15 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) =\nSome (Vptr b0 ofs0)) (H16 : pmatch bc0 b0 ofs0 p) (H17 : genv_match bc0 ge) (H18 : bc0 sp = BCstack) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' (Load chunk addr vl p) v.","proofString":"rewrite H9 in H15; inv H15.\neconstructor; eauto.\nrewrite <- H10.\nsimpl.\nrewrite negb_false_iff in H6.\neapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (chunk : memory_chunk) (p : aptr) (addr : addressing) (vl : list valnum) (H6 : negb (pdisjoint p (size_chunk chunk) dst sz) = false) (b0 : block) (ofs0 : ptrofs) (H10 : Mem.loadv chunk m (Vptr b0 ofs0) = Some v) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) =\nSome (Vptr b0 ofs0)) (bc0 : block_classification) (H16 : pmatch bc0 b0 ofs0 p) (H17 : genv_match bc0 ge) (H18 : bc0 sp = BCstack) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' (Load chunk addr vl p) v.","proofString":"econstructor; eauto.\nrewrite <- H10.\nsimpl.\nrewrite negb_false_iff in H6.\neapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (chunk : memory_chunk) (p : aptr) (addr : addressing) (vl : list valnum) (H6 : negb (pdisjoint p (size_chunk chunk) dst sz) = false) (b0 : block) (ofs0 : ptrofs) (H10 : Mem.loadv chunk m (Vptr b0 ofs0) = Some v) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) =\nSome (Vptr b0 ofs0)) (bc0 : block_classification) (H16 : pmatch bc0 b0 ofs0 p) (H17 : genv_match bc0 ge) (H18 : bc0 sp = BCstack) : Mem.loadv chunk m' (Vptr b0 ofs0) = Some v.","proofString":"rewrite <- H10.\nsimpl.\nrewrite negb_false_iff in H6.\neapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (chunk : memory_chunk) (p : aptr) (addr : addressing) (vl : list valnum) (H6 : negb (pdisjoint p (size_chunk chunk) dst sz) = false) (b0 : block) (ofs0 : ptrofs) (H10 : Mem.loadv chunk m (Vptr b0 ofs0) = Some v) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) =\nSome (Vptr b0 ofs0)) (bc0 : block_classification) (H16 : pmatch bc0 b0 ofs0 p) (H17 : genv_match bc0 ge) (H18 : bc0 sp = BCstack) : Mem.loadv chunk m' (Vptr b0 ofs0) = Mem.loadv chunk m (Vptr b0 ofs0).","proofString":"simpl.\nrewrite negb_false_iff in H6.\neapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (chunk : memory_chunk) (p : aptr) (addr : addressing) (vl : list valnum) (H6 : negb (pdisjoint p (size_chunk chunk) dst sz) = false) (b0 : block) (ofs0 : ptrofs) (H10 : Mem.loadv chunk m (Vptr b0 ofs0) = Some v) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) =\nSome (Vptr b0 ofs0)) (bc0 : block_classification) (H16 : pmatch bc0 b0 ofs0 p) (H17 : genv_match bc0 ge) (H18 : bc0 sp = BCstack) : Mem.load chunk m' b0 (Ptrofs.unsigned ofs0) =\nMem.load chunk m b0 (Ptrofs.unsigned ofs0).","proofString":"rewrite negb_false_iff in H6.\neapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (chunk : memory_chunk) (p : aptr) (addr : addressing) (vl : list valnum) (H6 : pdisjoint p (size_chunk chunk) dst sz = true) (b0 : block) (ofs0 : ptrofs) (H10 : Mem.loadv chunk m (Vptr b0 ofs0) = Some v) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) =\nSome (Vptr b0 ofs0)) (bc0 : block_classification) (H16 : pmatch bc0 b0 ofs0 p) (H17 : genv_match bc0 ge) (H18 : bc0 sp = BCstack) : Mem.load chunk m' b0 (Ptrofs.unsigned ofs0) =\nMem.load chunk m b0 (Ptrofs.unsigned ofs0).","proofString":"eapply Mem.load_storebytes_other.\neauto.\nrewrite H4.\nrewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (chunk : memory_chunk) (p : aptr) (addr : addressing) (vl : list valnum) (H6 : pdisjoint p (size_chunk chunk) dst sz = true) (b0 : block) (ofs0 : ptrofs) (H10 : Mem.loadv chunk m (Vptr b0 ofs0) = Some v) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) =\nSome (Vptr b0 ofs0)) (bc0 : block_classification) (H16 : pmatch bc0 b0 ofs0 p) (H17 : genv_match bc0 ge) (H18 : bc0 sp = BCstack) : b0 <> b \\/\nPtrofs.unsigned ofs0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Z.to_nat sz) <= Ptrofs.unsigned ofs0.","proofString":"rewrite Z2Nat.id by lia.\neapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (chunk : memory_chunk) (p : aptr) (addr : addressing) (vl : list valnum) (H6 : pdisjoint p (size_chunk chunk) dst sz = true) (b0 : block) (ofs0 : ptrofs) (H10 : Mem.loadv chunk m (Vptr b0 ofs0) = Some v) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) addr (map valu vl) =\nSome (Vptr b0 ofs0)) (bc0 : block_classification) (H16 : pmatch bc0 b0 ofs0 p) (H17 : genv_match bc0 ge) (H18 : bc0 sp = BCstack) : b0 <> b \\/\nPtrofs.unsigned ofs0 + size_chunk chunk <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sz <= Ptrofs.unsigned ofs0.","proofString":"eapply pdisjoint_sound_strong with (bc1 := bc0) (bc2 := bc); eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : block) (rs : regset) (m : mem) (n : numbering) (dst : aptr) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (sz : Z) (H : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (H0 : pmatch bc b ofs dst) (H1 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : Datatypes.length bytes = Z.to_nat sz) (H5 : sz >= 0) (v : val) (args : list (builtin_arg valnum)) (bf : builtin_function) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Builtin bf args)) (H6 : builtin_args_depends_on_memory args = false) (vargs : list val) (H9 : eval_builtin_args ge valu (Vptr sp Ptrofs.zero) m args vargs) (H10 : builtin_function_sem bf vargs = Some v) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m' (Builtin bf args) v.","proofString":"econstructor; eauto using builtin_args_depends_on_memory_correct."},{"statement":"(m : mem) (b1 : block) (ofs1 sz : Z) (bytes : list memval) (b2 : block) (ofs2 : Z) (m' : mem) (chunk : memory_chunk) (i : Z) (v : val) (H : Mem.loadbytes m b1 ofs1 sz = Some bytes) (H0 : Mem.storebytes m b2 ofs2 bytes = Some m') (H1 : Mem.load chunk m b1 i = Some v) (H2 : ofs1 <= i) (H3 : i + size_chunk chunk <= ofs1 + sz) (H4 : (align_chunk chunk | ofs2 - ofs1)) : Mem.load chunk m' b2 (i + (ofs2 - ofs1)) = Some v.","proofString":"generalize (size_chunk_pos chunk); intros SPOS.\nset (n1 := i - ofs1).\nset (n2 := size_chunk chunk).\nset (n3 := sz - (n1 + n2)).\nreplace sz with (n1 + (n2 + n3)) in H by (unfold n3, n2, n1; lia).\nexploit Mem.loadbytes_split; eauto.\nunfold n1; lia.\nunfold n3, n2, n1; lia.\nintros (bytes1 & bytes23 & LB1 & LB23 & EQ).\nclear H.\nexploit Mem.loadbytes_split; eauto.\nunfold n2; lia.\nunfold n3, n2, n1; lia.\nintros (bytes2 & bytes3 & LB2 & LB3 & EQ').\nsubst bytes23; subst bytes.\nexploit Mem.load_loadbytes; eauto.\nintros (bytes2' & A & B).\nassert (bytes2' = bytes2).\nreplace (ofs1 + n1) with i in LB2 by (unfold n1; lia).\nunfold n2 in LB2.\ncongruence.\nsubst bytes2'.\nexploit Mem.storebytes_split; eauto.\nintros (m1 & SB1 & SB23).\nclear H0.\nexploit Mem.storebytes_split; eauto.\nintros (m2 & SB2 & SB3).\nclear SB23.\nassert (L1: Z.of_nat (length bytes1) = n1).\nerewrite Mem.loadbytes_length by eauto.\napply Z2Nat.id.\nunfold n1; lia.\nassert (L2: Z.of_nat (length bytes2) = n2).\nerewrite Mem.loadbytes_length by eauto.\napply Z2Nat.id.\nunfold n2; lia.\nrewrite L1 in *.\nrewrite L2 in *.\nassert (LB': Mem.loadbytes m2 b2 (ofs2 + n1) n2 = Some bytes2).\nrewrite <- L2.\neapply Mem.loadbytes_storebytes_same; eauto.\nassert (LB'': Mem.loadbytes m' b2 (ofs2 + n1) n2 = Some bytes2).\nrewrite <- LB'.\neapply Mem.loadbytes_storebytes_other; eauto.\nunfold n2; lia.\nright; left; lia.\nexploit Mem.load_valid_access; eauto.\nintros [P Q].\nrewrite B.\napply Mem.loadbytes_load.\nreplace (i + (ofs2 - ofs1)) with (ofs2 + n1) by (unfold n1; lia).\nexact LB''.\napply Z.divide_add_r; auto."},{"statement":"(m : mem) (b1 : block) (ofs1 sz : Z) (bytes : list memval) (b2 : block) (ofs2 : Z) (m' : mem) (chunk : memory_chunk) (i : Z) (v : val) (H : Mem.loadbytes m b1 ofs1 sz = Some bytes) (H0 : Mem.storebytes m b2 ofs2 bytes = Some m') (H1 : Mem.load chunk m b1 i = Some v) (H2 : ofs1 <= i) (H3 : i + size_chunk chunk <= ofs1 + sz) (H4 : (align_chunk chunk | ofs2 - ofs1)) (SPOS : size_chunk chunk > 0) : Mem.load chunk m' b2 (i + (ofs2 - ofs1)) = Some v.","proofString":"set (n1 := i - ofs1).\nset (n2 := size_chunk chunk).\nset (n3 := sz - (n1 + n2)).\nreplace sz with (n1 + (n2 + n3)) in H by (unfold n3, n2, n1; lia).\nexploit Mem.loadbytes_split; eauto.\nunfold n1; lia.\nunfold n3, n2, n1; lia.\nintros (bytes1 & bytes23 & LB1 & LB23 & EQ).\nclear H.\nexploit Mem.loadbytes_split; eauto.\nunfold n2; lia.\nunfold n3, n2, n1; lia.\nintros (bytes2 & bytes3 & LB2 & LB3 & EQ').\nsubst bytes23; subst bytes.\nexploit Mem.load_loadbytes; eauto.\nintros (bytes2' & A & B).\nassert (bytes2' = bytes2).\nreplace (ofs1 + n1) with i in LB2 by (unfold n1; lia).\nunfold n2 in LB2.\ncongruence.\nsubst bytes2'.\nexploit Mem.storebytes_split; eauto.\nintros (m1 & SB1 & SB23).\nclear H0.\nexploit Mem.storebytes_split; eauto.\nintros (m2 & SB2 & SB3).\nclear SB23.\nassert (L1: Z.of_nat (length bytes1) = n1).\nerewrite Mem.loadbytes_length by eauto.\napply Z2Nat.id.\nunfold n1; lia.\nassert (L2: Z.of_nat (length bytes2) = n2).\nerewrite Mem.loadbytes_length by eauto.\napply Z2Nat.id.\nunfold n2; lia.\nrewrite L1 in *.\nrewrite L2 in *.\nassert (LB': Mem.loadbytes m2 b2 (ofs2 + n1) n2 = Some bytes2).\nrewrite <- L2.\neapply Mem.loadbytes_storebytes_same; eauto.\nassert (LB'': Mem.loadbytes m' b2 (ofs2 + n1) n2 = Some bytes2).\nrewrite <- LB'.\neapply Mem.loadbytes_storebytes_other; eauto.\nunfold n2; lia.\nright; left; lia.\nexploit Mem.load_valid_access; eauto.\nintros [P Q].\nrewrite B.\napply Mem.loadbytes_load.\nreplace (i + (ofs2 - ofs1)) with (ofs2 + n1) by (unfold n1; lia).\nexact LB''.\napply Z.divide_add_r; auto."},{"statement":"(m : mem) (b1 : block) (ofs1 sz : Z) (b2 : block) (ofs2 : Z) (m' : mem) (chunk : memory_chunk) (i : Z) (v : val) (n1 : Z) (n2 : Z) (n3 : Z) (bytes1 bytes2 bytes3 : list memval) (H0 : Mem.storebytes m b2 ofs2 (bytes1 ++ bytes2 ++ bytes3) = Some m') (H1 : Mem.load chunk m b1 i = Some v) (H2 : ofs1 <= i) (H3 : i + size_chunk chunk <= ofs1 + sz) (H4 : (align_chunk chunk | ofs2 - ofs1)) (SPOS : size_chunk chunk > 0) (LB1 : Mem.loadbytes m b1 ofs1 n1 = Some bytes1) (LB23 : Mem.loadbytes m b1 (ofs1 + n1) (n2 + n3) = Some (bytes2 ++ bytes3)) (LB2 : Mem.loadbytes m b1 i (size_chunk chunk) = Some bytes2) (LB3 : Mem.loadbytes m b1 (ofs1 + n1 + n2) n3 = Some bytes3) (bytes2' : list memval) (A : Mem.loadbytes m b1 i (size_chunk chunk) = Some bytes2') (B : v = decode_val chunk bytes2') : bytes2' = bytes2.","proofString":"congruence."},{"statement":"(m : mem) (b1 : block) (ofs1 sz : Z) (b2 : block) (ofs2 : Z) (m' : mem) (chunk : memory_chunk) (i : Z) (v : val) (n1 : Z) (n2 : Z) (n3 : Z) (bytes1 bytes2 bytes3 : list memval) (H1 : Mem.load chunk m b1 i = Some v) (H2 : ofs1 <= i) (H3 : i + size_chunk chunk <= ofs1 + sz) (H4 : (align_chunk chunk | ofs2 - ofs1)) (SPOS : size_chunk chunk > 0) (LB1 : Mem.loadbytes m b1 ofs1 n1 = Some bytes1) (LB23 : Mem.loadbytes m b1 (ofs1 + n1) (n2 + n3) = Some (bytes2 ++ bytes3)) (LB2 : Mem.loadbytes m b1 (ofs1 + n1) n2 = Some bytes2) (LB3 : Mem.loadbytes m b1 (ofs1 + n1 + n2) n3 = Some bytes3) (B : v = decode_val chunk bytes2) (A : Mem.loadbytes m b1 i (size_chunk chunk) = Some bytes2) (m1 : mem) (SB1 : Mem.storebytes m b2 ofs2 bytes1 = Some m1) (m2 : mem) (SB2 : Mem.storebytes m1 b2 (ofs2 + n1) bytes2 = Some m2) (SB3 : Mem.storebytes m2 b2 (ofs2 + n1 + n2) bytes3 = Some m') (L1 : Z.of_nat (Datatypes.length bytes1) = n1) (L2 : Z.of_nat (Datatypes.length bytes2) = n2) : Mem.loadbytes m2 b2 (ofs2 + n1) n2 = Some bytes2.","proofString":"rewrite <- L2.\neapply Mem.loadbytes_storebytes_same; eauto."},{"statement":"(m : mem) (b1 : block) (ofs1 sz : Z) (b2 : block) (ofs2 : Z) (m' : mem) (chunk : memory_chunk) (i : Z) (v : val) (n1 : Z) (n2 : Z) (n3 : Z) (bytes1 bytes2 bytes3 : list memval) (H1 : Mem.load chunk m b1 i = Some v) (H2 : ofs1 <= i) (H3 : i + size_chunk chunk <= ofs1 + sz) (H4 : (align_chunk chunk | ofs2 - ofs1)) (SPOS : size_chunk chunk > 0) (LB1 : Mem.loadbytes m b1 ofs1 n1 = Some bytes1) (LB23 : Mem.loadbytes m b1 (ofs1 + n1) (n2 + n3) = Some (bytes2 ++ bytes3)) (LB2 : Mem.loadbytes m b1 (ofs1 + n1) n2 = Some bytes2) (LB3 : Mem.loadbytes m b1 (ofs1 + n1 + n2) n3 = Some bytes3) (B : v = decode_val chunk bytes2) (A : Mem.loadbytes m b1 i (size_chunk chunk) = Some bytes2) (m1 : mem) (SB1 : Mem.storebytes m b2 ofs2 bytes1 = Some m1) (m2 : mem) (SB2 : Mem.storebytes m1 b2 (ofs2 + n1) bytes2 = Some m2) (SB3 : Mem.storebytes m2 b2 (ofs2 + n1 + n2) bytes3 = Some m') (L1 : Z.of_nat (Datatypes.length bytes1) = n1) (L2 : Z.of_nat (Datatypes.length bytes2) = n2) : Mem.loadbytes m2 b2 (ofs2 + n1) (Z.of_nat (Datatypes.length bytes2)) =\nSome bytes2.","proofString":"eapply Mem.loadbytes_storebytes_same; eauto."},{"statement":"(m : mem) (b1 : block) (ofs1 sz : Z) (b2 : block) (ofs2 : Z) (m' : mem) (chunk : memory_chunk) (i : Z) (v : val) (n1 : Z) (n2 : Z) (n3 : Z) (bytes1 bytes2 bytes3 : list memval) (H1 : Mem.load chunk m b1 i = Some v) (H2 : ofs1 <= i) (H3 : i + size_chunk chunk <= ofs1 + sz) (H4 : (align_chunk chunk | ofs2 - ofs1)) (SPOS : size_chunk chunk > 0) (LB1 : Mem.loadbytes m b1 ofs1 n1 = Some bytes1) (LB23 : Mem.loadbytes m b1 (ofs1 + n1) (n2 + n3) = Some (bytes2 ++ bytes3)) (LB2 : Mem.loadbytes m b1 (ofs1 + n1) n2 = Some bytes2) (LB3 : Mem.loadbytes m b1 (ofs1 + n1 + n2) n3 = Some bytes3) (B : v = decode_val chunk bytes2) (A : Mem.loadbytes m b1 i (size_chunk chunk) = Some bytes2) (m1 : mem) (SB1 : Mem.storebytes m b2 ofs2 bytes1 = Some m1) (m2 : mem) (SB2 : Mem.storebytes m1 b2 (ofs2 + n1) bytes2 = Some m2) (SB3 : Mem.storebytes m2 b2 (ofs2 + n1 + n2) bytes3 = Some m') (L1 : Z.of_nat (Datatypes.length bytes1) = n1) (L2 : Z.of_nat (Datatypes.length bytes2) = n2) (LB' : Mem.loadbytes m2 b2 (ofs2 + n1) n2 = Some bytes2) : b2 <> b2 \\/\nofs2 + n1 + n2 <= ofs2 + n1 + n2 \\/\nofs2 + n1 + n2 + Z.of_nat (Datatypes.length bytes3) <= ofs2 + n1.","proofString":"right; left; lia."},{"statement":"(m : mem) (b1 : block) (ofs1 sz : Z) (b2 : block) (ofs2 : Z) (m' : mem) (chunk : memory_chunk) (i : Z) (v : val) (n1 : Z) (n2 : Z) (n3 : Z) (bytes1 bytes2 bytes3 : list memval) (H1 : Mem.load chunk m b1 i = Some v) (H2 : ofs1 <= i) (H3 : i + size_chunk chunk <= ofs1 + sz) (H4 : (align_chunk chunk | ofs2 - ofs1)) (SPOS : size_chunk chunk > 0) (LB1 : Mem.loadbytes m b1 ofs1 n1 = Some bytes1) (LB23 : Mem.loadbytes m b1 (ofs1 + n1) (n2 + n3) = Some (bytes2 ++ bytes3)) (LB2 : Mem.loadbytes m b1 (ofs1 + n1) n2 = Some bytes2) (LB3 : Mem.loadbytes m b1 (ofs1 + n1 + n2) n3 = Some bytes3) (B : v = decode_val chunk bytes2) (A : Mem.loadbytes m b1 i (size_chunk chunk) = Some bytes2) (m1 : mem) (SB1 : Mem.storebytes m b2 ofs2 bytes1 = Some m1) (m2 : mem) (SB2 : Mem.storebytes m1 b2 (ofs2 + n1) bytes2 = Some m2) (SB3 : Mem.storebytes m2 b2 (ofs2 + n1 + n2) bytes3 = Some m') (L1 : Z.of_nat (Datatypes.length bytes1) = n1) (L2 : Z.of_nat (Datatypes.length bytes2) = n2) (LB' : Mem.loadbytes m2 b2 (ofs2 + n1) n2 = Some bytes2) (LB'' : Mem.loadbytes m' b2 (ofs2 + n1) n2 = Some bytes2) (P : Mem.range_perm m b1 i (i + size_chunk chunk) Cur Readable) (Q : (align_chunk chunk | i)) : (align_chunk chunk | i + (ofs2 - ofs1)).","proofString":"apply Z.divide_add_r; auto."},{"statement":"(src sz delta : Z) (v : valnum) (strict : bool) (m : memory_chunk) (ofs : ptrofs) (l : list valnum) (a0 : aptr) (e' : equation) (next : valnum) (H : Some\n  (Eq v strict\n     (Load m (Ainstack (Ptrofs.repr (Ptrofs.unsigned ofs + delta))) nil\n        (Stk (Ptrofs.repr (Ptrofs.unsigned ofs + delta))))) = \nSome e') (H0 : wf_equation next (Eq v strict (Load m (Ainstack ofs) l a0))) : wf_equation next e'.","proofString":"inv H.\ndestruct H0.\nsplit.\nauto.\nred; simpl; tauto."},{"statement":"(src sz delta : Z) (v : valnum) (strict : bool) (m : memory_chunk) (ofs : ptrofs) (l : list valnum) (a0 : aptr) (next : valnum) (H0 : wf_equation next (Eq v strict (Load m (Ainstack ofs) l a0))) : wf_equation next\n  (Eq v strict\n     (Load m (Ainstack (Ptrofs.repr (Ptrofs.unsigned ofs + delta))) nil\n        (Stk (Ptrofs.repr (Ptrofs.unsigned ofs + delta))))).","proofString":"destruct H0.\nsplit.\nauto.\nred; simpl; tauto."},{"statement":"(src sz delta : Z) (v : valnum) (strict : bool) (m : memory_chunk) (ofs : ptrofs) (l : list valnum) (a0 : aptr) (next : valnum) (H : Plt v next) (H0 : wf_rhs next (Load m (Ainstack ofs) l a0)) : wf_equation next\n  (Eq v strict\n     (Load m (Ainstack (Ptrofs.repr (Ptrofs.unsigned ofs + delta))) nil\n        (Stk (Ptrofs.repr (Ptrofs.unsigned ofs + delta))))).","proofString":"split.\nauto.\nred; simpl; tauto."},{"statement":"(src sz delta : Z) (v : valnum) (strict : bool) (m : memory_chunk) (ofs : ptrofs) (l : list valnum) (a0 : aptr) (next : valnum) (H : Plt v next) (H0 : wf_rhs next (Load m (Ainstack ofs) l a0)) : Plt v next.","proofString":"auto."},{"statement":"(src sz delta : Z) (v : valnum) (strict : bool) (m : memory_chunk) (ofs : ptrofs) (l : list valnum) (a0 : aptr) (next : valnum) (H : Plt v next) (H0 : wf_rhs next (Load m (Ainstack ofs) l a0)) : wf_rhs next\n  (Load m (Ainstack (Ptrofs.repr (Ptrofs.unsigned ofs + delta))) nil\n     (Stk (Ptrofs.repr (Ptrofs.unsigned ofs + delta)))).","proofString":"red; simpl; tauto."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (strict : bool) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (a : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (H2 : equation_holds valu ge (Vptr sp Ptrofs.zero) m\n  (Eq l strict (Load chunk (Ainstack ofs) vl a))) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned ofs) = Some v) : align_chunk chunk <> 0.","proofString":"generalize (align_chunk_pos chunk); lia."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (strict : bool) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (a : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (H2 : equation_holds valu ge (Vptr sp Ptrofs.zero) m\n  (Eq l strict (Load chunk (Ainstack ofs) vl a))) (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l strict\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"rename a into ap.\nassert (eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil = Some (Vptr sp (Ptrofs.repr j))).\nrewrite eval_addressing_Ainstack.\nsimpl.\nrewrite Ptrofs.add_zero_l.\nauto.\ninv H2.\ninv H5.\nexploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_strict.\neconstructor; eauto.\ninv H7.\neconstructor; eauto with va.\ninv H6.\nexploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_lessdef with v; auto.\neconstructor; eauto.\ninv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (strict : bool) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (H2 : equation_holds valu ge (Vptr sp Ptrofs.zero) m\n  (Eq l strict (Load chunk (Ainstack ofs) vl ap))) (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l strict\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"assert (eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil = Some (Vptr sp (Ptrofs.repr j))).\nrewrite eval_addressing_Ainstack.\nsimpl.\nrewrite Ptrofs.add_zero_l.\nauto.\ninv H2.\ninv H5.\nexploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_strict.\neconstructor; eauto.\ninv H7.\neconstructor; eauto with va.\ninv H6.\nexploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_lessdef with v; auto.\neconstructor; eauto.\ninv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (strict : bool) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (H2 : equation_holds valu ge (Vptr sp Ptrofs.zero) m\n  (Eq l strict (Load chunk (Ainstack ofs) vl ap))) (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j)).","proofString":"rewrite eval_addressing_Ainstack.\nsimpl.\nrewrite Ptrofs.add_zero_l.\nauto."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (strict : bool) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (H2 : equation_holds valu ge (Vptr sp Ptrofs.zero) m\n  (Eq l strict (Load chunk (Ainstack ofs) vl ap))) (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) : Some (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr j)) =\nSome (Vptr sp (Ptrofs.repr j)).","proofString":"simpl.\nrewrite Ptrofs.add_zero_l.\nauto."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (strict : bool) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (H2 : equation_holds valu ge (Vptr sp Ptrofs.zero) m\n  (Eq l strict (Load chunk (Ainstack ofs) vl ap))) (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) : Some (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.repr j))) =\nSome (Vptr sp (Ptrofs.repr j)).","proofString":"rewrite Ptrofs.add_zero_l.\nauto."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (strict : bool) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (H2 : equation_holds valu ge (Vptr sp Ptrofs.zero) m\n  (Eq l strict (Load chunk (Ainstack ofs) vl ap))) (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) : Some (Vptr sp (Ptrofs.repr j)) = Some (Vptr sp (Ptrofs.repr j)).","proofString":"auto."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (strict : bool) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (H2 : equation_holds valu ge (Vptr sp Ptrofs.zero) m\n  (Eq l strict (Load chunk (Ainstack ofs) vl ap))) (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l strict\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"inv H2.\ninv H5.\nexploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_strict.\neconstructor; eauto.\ninv H7.\neconstructor; eauto with va.\ninv H6.\nexploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_lessdef with v; auto.\neconstructor; eauto.\ninv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (H5 : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m (Load chunk (Ainstack ofs) vl ap)\n  (valu l)) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l true\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"inv H5.\nexploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_strict.\neconstructor; eauto.\ninv H7.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (a : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome a) (H10 : Mem.loadv chunk m a = Some (valu l)) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l true\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"exploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_strict.\neconstructor; eauto.\ninv H7.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (a : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome a) (H10 : Mem.loadv chunk m a = Some (valu l)) : map valu vl = nil /\\ a = Val.offset_ptr (Vptr sp Ptrofs.zero) ofs ->\nequation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l true\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"intros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_strict.\neconstructor; eauto.\ninv H7.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (a : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome a) (H10 : Mem.loadv chunk m a = Some (valu l)) (E1 : map valu vl = nil) (E2 : a = Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l true\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"simpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_strict.\neconstructor; eauto.\ninv H7.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (a : val) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome a) (H10 : Mem.loadv chunk m a = Some (valu l)) (E1 : map valu vl = nil) (E2 : a = Vptr sp ofs) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l true\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"subst a.\napply eq_holds_strict.\neconstructor; eauto.\ninv H7.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (H10 : Mem.loadv chunk m (Vptr sp ofs) = Some (valu l)) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr sp ofs)) (E1 : map valu vl = nil) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l true\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"apply eq_holds_strict.\neconstructor; eauto.\ninv H7.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (H10 : Mem.loadv chunk m (Vptr sp ofs) = Some (valu l)) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr sp ofs)) (E1 : map valu vl = nil) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m'\n  (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j))) \n  (valu l).","proofString":"econstructor; eauto."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (H7 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (H10 : Mem.loadv chunk m (Vptr sp ofs) = Some (valu l)) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr sp ofs)) (E1 : map valu vl = nil) : rhs_valid valu ge (Vptr sp Ptrofs.zero)\n  (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j))).","proofString":"inv H7.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (H10 : Mem.loadv chunk m (Vptr sp ofs) = Some (valu l)) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr sp ofs)) (E1 : map valu vl = nil) (b : block) (ofs0 : ptrofs) (bc : block_classification) (H8 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr b ofs0)) (H11 : pmatch bc b ofs0 ap) (H12 : genv_match bc ge) (H13 : bc sp = BCstack) : rhs_valid valu ge (Vptr sp Ptrofs.zero)\n  (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j))).","proofString":"econstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v0 : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v0 ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v0) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (v : val) (H6 : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m (Load chunk (Ainstack ofs) vl ap)\n  v) (H7 : Val.lessdef v (valu l)) (H8 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l false\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"inv H6.\nexploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_lessdef with v; auto.\neconstructor; eauto.\ninv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v0 : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v0 ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v0) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (v : val) (H7 : Val.lessdef v (valu l)) (H8 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (a : val) (H10 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome a) (H11 : Mem.loadv chunk m a = Some v) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l false\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"exploit eval_addressing_Ainstack_inv; eauto.\nintros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_lessdef with v; auto.\neconstructor; eauto.\ninv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v0 : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v0 ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v0) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (v : val) (H7 : Val.lessdef v (valu l)) (H8 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (a : val) (H10 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome a) (H11 : Mem.loadv chunk m a = Some v) : map valu vl = nil /\\ a = Val.offset_ptr (Vptr sp Ptrofs.zero) ofs ->\nequation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l false\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"intros [E1 E2].\nsimpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_lessdef with v; auto.\neconstructor; eauto.\ninv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v0 : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v0 ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v0) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (v : val) (H7 : Val.lessdef v (valu l)) (H8 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (a : val) (H10 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome a) (H11 : Mem.loadv chunk m a = Some v) (E1 : map valu vl = nil) (E2 : a = Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l false\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"simpl in E2; rewrite Ptrofs.add_zero_l in E2.\nsubst a.\napply eq_holds_lessdef with v; auto.\neconstructor; eauto.\ninv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v0 : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v0 ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v0) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (v : val) (H7 : Val.lessdef v (valu l)) (H8 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (a : val) (H10 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome a) (H11 : Mem.loadv chunk m a = Some v) (E1 : map valu vl = nil) (E2 : a = Vptr sp ofs) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l false\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"subst a.\napply eq_holds_lessdef with v; auto.\neconstructor; eauto.\ninv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v0 : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v0 ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v0) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (v : val) (H7 : Val.lessdef v (valu l)) (H8 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (H11 : Mem.loadv chunk m (Vptr sp ofs) = Some v) (H10 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr sp ofs)) (E1 : map valu vl = nil) : equation_holds valu ge (Vptr sp Ptrofs.zero) m'\n  (Eq l false\n     (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j)))).","proofString":"apply eq_holds_lessdef with v; auto.\neconstructor; eauto.\ninv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v0 : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v0 ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v0) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (v : val) (H7 : Val.lessdef v (valu l)) (H8 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (H11 : Mem.loadv chunk m (Vptr sp ofs) = Some v) (H10 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr sp ofs)) (E1 : map valu vl = nil) : rhs_eval_to valu ge (Vptr sp Ptrofs.zero) m'\n  (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j))) v.","proofString":"econstructor; eauto."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v0 : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v0 ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v0) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (v : val) (H7 : Val.lessdef v (valu l)) (H8 : rhs_valid valu ge (Vptr sp Ptrofs.zero) (Load chunk (Ainstack ofs) vl ap)) (H11 : Mem.loadv chunk m (Vptr sp ofs) = Some v) (H10 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr sp ofs)) (E1 : map valu vl = nil) : rhs_valid valu ge (Vptr sp Ptrofs.zero)\n  (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j))).","proofString":"inv H8.\neconstructor; eauto with va."},{"statement":"(src dst sz : Z) (m : mem) (sp : block) (bytes : list memval) (m' : mem) (valu : valuation) (ge : genv) (delta : Z) (l : valnum) (chunk : memory_chunk) (ofs : ptrofs) (vl : list valnum) (ap : aptr) (i1 : Z) (j : Z) (l0 : src <= i1) (l1 : i1 + size_chunk chunk <= src + sz) (e0 : delta mod align_chunk chunk = 0) (l2 : 0 <= j) (l3 : j <= Ptrofs.max_unsigned) (H0 : Mem.loadbytes m sp src sz = Some bytes) (H1 : Mem.storebytes m sp dst bytes = Some m') (LD : forall v0 : val,\nMem.loadv chunk m (Vptr sp ofs) = Some v0 ->\nMem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v0) (H : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack (Ptrofs.repr j)) nil =\nSome (Vptr sp (Ptrofs.repr j))) (v : val) (H7 : Val.lessdef v (valu l)) (H11 : Mem.loadv chunk m (Vptr sp ofs) = Some v) (H10 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr sp ofs)) (E1 : map valu vl = nil) (b : block) (ofs0 : ptrofs) (bc : block_classification) (H9 : eval_addressing ge (Vptr sp Ptrofs.zero) (Ainstack ofs) (map valu vl) =\nSome (Vptr b ofs0)) (H12 : pmatch bc b ofs0 ap) (H13 : genv_match bc ge) (H14 : bc sp = BCstack) : rhs_valid valu ge (Vptr sp Ptrofs.zero)\n  (Load chunk (Ainstack (Ptrofs.repr j)) nil (Stk (Ptrofs.repr j))).","proofString":"econstructor; eauto with va."},{"statement":"(e' : equation) (src sz delta : Z) (eqs2 : list equation) (H : In e' eqs2) : In e' eqs2 \\/\n(exists e : equation, False /\\ shift_memcpy_eq src sz delta e = Some e').","proofString":"auto."},{"statement":"(e' : equation) (src sz delta : Z) (eqs2 : list equation) (a : equation) (eqs1 : list equation) (IHeqs1 : In e' (add_memcpy_eqs src sz delta eqs1 eqs2) ->\nIn e' eqs2 \\/\n(exists e : equation, In e eqs1 /\\ shift_memcpy_eq src sz delta e = Some e')) (H : In e'\n  match shift_memcpy_eq src sz delta a with\n  | Some e'0 => e'0 :: add_memcpy_eqs src sz delta eqs1 eqs2\n  | None => add_memcpy_eqs src sz delta eqs1 eqs2\n  end) : In e' eqs2 \\/\n(exists e : equation,\n   (a = e \\/ In e eqs1) /\\ shift_memcpy_eq src sz delta e = Some e').","proofString":"destruct (shift_memcpy_eq src sz delta a) as [e''|] eqn:SHIFT.\ndestruct H.\nsubst e''.\nright; exists a; auto.\ndestruct IHeqs1 as [A | [e [A B]]]; auto.\nright; exists e; auto.\ndestruct IHeqs1 as [A | [e [A B]]]; auto.\nright; exists e; auto."},{"statement":"(e' : equation) (src sz delta : Z) (eqs2 : list equation) (a : equation) (eqs1 : list equation) (IHeqs1 : In e' (add_memcpy_eqs src sz delta eqs1 eqs2) ->\nIn e' eqs2 \\/\n(exists e : equation, In e eqs1 /\\ shift_memcpy_eq src sz delta e = Some e')) (e'' : equation) (SHIFT : shift_memcpy_eq src sz delta a = Some e'') (H : In e' (e'' :: add_memcpy_eqs src sz delta eqs1 eqs2)) : In e' eqs2 \\/\n(exists e : equation,\n   (a = e \\/ In e eqs1) /\\ shift_memcpy_eq src sz delta e = Some e').","proofString":"destruct H.\nsubst e''.\nright; exists a; auto.\ndestruct IHeqs1 as [A | [e [A B]]]; auto.\nright; exists e; auto."},{"statement":"(e' : equation) (src sz delta : Z) (eqs2 : list equation) (a : equation) (eqs1 : list equation) (IHeqs1 : In e' (add_memcpy_eqs src sz delta eqs1 eqs2) ->\nIn e' eqs2 \\/\n(exists e : equation, In e eqs1 /\\ shift_memcpy_eq src sz delta e = Some e')) (e'' : equation) (SHIFT : shift_memcpy_eq src sz delta a = Some e'') (H : e'' = e') : In e' eqs2 \\/\n(exists e : equation,\n   (a = e \\/ In e eqs1) /\\ shift_memcpy_eq src sz delta e = Some e').","proofString":"subst e''.\nright; exists a; auto."},{"statement":"(e' : equation) (src sz delta : Z) (eqs2 : list equation) (a : equation) (eqs1 : list equation) (IHeqs1 : In e' (add_memcpy_eqs src sz delta eqs1 eqs2) ->\nIn e' eqs2 \\/\n(exists e : equation, In e eqs1 /\\ shift_memcpy_eq src sz delta e = Some e')) (SHIFT : shift_memcpy_eq src sz delta a = Some e') : In e' eqs2 \\/\n(exists e : equation,\n   (a = e \\/ In e eqs1) /\\ shift_memcpy_eq src sz delta e = Some e').","proofString":"right; exists a; auto."},{"statement":"(e' : equation) (src sz delta : Z) (eqs2 : list equation) (a : equation) (eqs1 : list equation) (IHeqs1 : In e' (add_memcpy_eqs src sz delta eqs1 eqs2) ->\nIn e' eqs2 \\/\n(exists e : equation, In e eqs1 /\\ shift_memcpy_eq src sz delta e = Some e')) (e'' : equation) (SHIFT : shift_memcpy_eq src sz delta a = Some e'') (H : In e' (add_memcpy_eqs src sz delta eqs1 eqs2)) : In e' eqs2 \\/\n(exists e : equation,\n   (a = e \\/ In e eqs1) /\\ shift_memcpy_eq src sz delta e = Some e').","proofString":"destruct IHeqs1 as [A | [e [A B]]]; auto.\nright; exists e; auto."},{"statement":"(e' : equation) (src sz delta : Z) (eqs2 : list equation) (a : equation) (eqs1 : list equation) (e'' : equation) (SHIFT : shift_memcpy_eq src sz delta a = Some e'') (H : In e' (add_memcpy_eqs src sz delta eqs1 eqs2)) (e : equation) (A : In e eqs1) (B : shift_memcpy_eq src sz delta e = Some e') : In e' eqs2 \\/\n(exists e0 : equation,\n   (a = e0 \\/ In e0 eqs1) /\\ shift_memcpy_eq src sz delta e0 = Some e').","proofString":"right; exists e; auto."},{"statement":"(e' : equation) (src sz delta : Z) (eqs2 : list equation) (a : equation) (eqs1 : list equation) (IHeqs1 : In e' (add_memcpy_eqs src sz delta eqs1 eqs2) ->\nIn e' eqs2 \\/\n(exists e : equation, In e eqs1 /\\ shift_memcpy_eq src sz delta e = Some e')) (SHIFT : shift_memcpy_eq src sz delta a = None) (H : In e' (add_memcpy_eqs src sz delta eqs1 eqs2)) : In e' eqs2 \\/\n(exists e : equation,\n   (a = e \\/ In e eqs1) /\\ shift_memcpy_eq src sz delta e = Some e').","proofString":"destruct IHeqs1 as [A | [e [A B]]]; auto.\nright; exists e; auto."},{"statement":"(e' : equation) (src sz delta : Z) (eqs2 : list equation) (a : equation) (eqs1 : list equation) (SHIFT : shift_memcpy_eq src sz delta a = None) (H : In e' (add_memcpy_eqs src sz delta eqs1 eqs2)) (e : equation) (A : In e eqs1) (B : shift_memcpy_eq src sz delta e = Some e') : In e' eqs2 \\/\n(exists e0 : equation,\n   (a = e0 \\/ In e0 eqs1) /\\ shift_memcpy_eq src sz delta e0 = Some e').","proofString":"right; exists e; auto."},{"statement":"(m : mem) (bsrc : block) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (asrc adst : aptr) (H : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : pmatch bc bsrc osrc asrc) (H4 : pmatch bc bdst odst adst) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  (add_memcpy n1 n2 asrc adst sz).","proofString":"unfold add_memcpy.\ndestruct asrc; auto; destruct adst; auto.\nassert (A: forall b o i, pmatch bc b o (Stk i) -> b = sp /\\ i = o).\nintros.\ninv H7.\nsplit; auto.\neapply bc_stack; eauto.\napply A in H3; destruct H3.\nsubst bsrc ofs.\napply A in H4; destruct H4.\nsubst bdst ofs0.\nconstructor; simpl; intros; eauto with cse.\nconstructor; simpl; eauto with cse.\nintros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (bsrc : block) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (asrc adst : aptr) (H : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : pmatch bc bsrc osrc asrc) (H4 : pmatch bc bdst odst adst) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  match asrc with\n  | Stk src =>\n      match adst with\n      | Stk dst =>\n          {|\n            num_next := num_next n2;\n            num_eqs :=\n              add_memcpy_eqs (Ptrofs.unsigned src) sz\n                (Ptrofs.unsigned dst - Ptrofs.unsigned src) \n                (num_eqs n1) (num_eqs n2);\n            num_reg := num_reg n2;\n            num_val := num_val n2\n          |}\n      | _ => n2\n      end\n  | _ => n2\n  end.","proofString":"destruct asrc; auto; destruct adst; auto.\nassert (A: forall b o i, pmatch bc b o (Stk i) -> b = sp /\\ i = o).\nintros.\ninv H7.\nsplit; auto.\neapply bc_stack; eauto.\napply A in H3; destruct H3.\nsubst bsrc ofs.\napply A in H4; destruct H4.\nsubst bdst ofs0.\nconstructor; simpl; intros; eauto with cse.\nconstructor; simpl; eauto with cse.\nintros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (bsrc : block) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (ofs ofs0 : ptrofs) (H : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : pmatch bc bsrc osrc (Stk ofs)) (H4 : pmatch bc bdst odst (Stk ofs0)) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  {|\n    num_next := num_next n2;\n    num_eqs :=\n      add_memcpy_eqs (Ptrofs.unsigned ofs) sz\n        (Ptrofs.unsigned ofs0 - Ptrofs.unsigned ofs) \n        (num_eqs n1) (num_eqs n2);\n    num_reg := num_reg n2;\n    num_val := num_val n2\n  |}.","proofString":"assert (A: forall b o i, pmatch bc b o (Stk i) -> b = sp /\\ i = o).\nintros.\ninv H7.\nsplit; auto.\neapply bc_stack; eauto.\napply A in H3; destruct H3.\nsubst bsrc ofs.\napply A in H4; destruct H4.\nsubst bdst ofs0.\nconstructor; simpl; intros; eauto with cse.\nconstructor; simpl; eauto with cse.\nintros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (bsrc : block) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (ofs ofs0 : ptrofs) (H : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : pmatch bc bsrc osrc (Stk ofs)) (H4 : pmatch bc bdst odst (Stk ofs0)) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o.","proofString":"intros.\ninv H7.\nsplit; auto.\neapply bc_stack; eauto."},{"statement":"(m : mem) (bsrc : block) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (ofs ofs0 : ptrofs) (H : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : pmatch bc bsrc osrc (Stk ofs)) (H4 : pmatch bc bdst odst (Stk ofs0)) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (b : block) (o i : ptrofs) (H7 : pmatch bc b o (Stk i)) : b = sp /\\ i = o.","proofString":"inv H7.\nsplit; auto.\neapply bc_stack; eauto."},{"statement":"(m : mem) (bsrc : block) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (ofs ofs0 : ptrofs) (H : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : pmatch bc bsrc osrc (Stk ofs)) (H4 : pmatch bc bdst odst (Stk ofs0)) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (b : block) (i : ptrofs) (H9 : bc b = BCstack) : b = sp /\\ i = i.","proofString":"split; auto.\neapply bc_stack; eauto."},{"statement":"(m : mem) (bsrc : block) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (ofs ofs0 : ptrofs) (H : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : pmatch bc bsrc osrc (Stk ofs)) (H4 : pmatch bc bdst odst (Stk ofs0)) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (b : block) (i : ptrofs) (H9 : bc b = BCstack) : b = sp.","proofString":"eapply bc_stack; eauto."},{"statement":"(m : mem) (bsrc : block) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (ofs ofs0 : ptrofs) (H : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : pmatch bc bsrc osrc (Stk ofs)) (H4 : pmatch bc bdst odst (Stk ofs0)) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  {|\n    num_next := num_next n2;\n    num_eqs :=\n      add_memcpy_eqs (Ptrofs.unsigned ofs) sz\n        (Ptrofs.unsigned ofs0 - Ptrofs.unsigned ofs) \n        (num_eqs n1) (num_eqs n2);\n    num_reg := num_reg n2;\n    num_val := num_val n2\n  |}.","proofString":"apply A in H3; destruct H3.\nsubst bsrc ofs.\napply A in H4; destruct H4.\nsubst bdst ofs0.\nconstructor; simpl; intros; eauto with cse.\nconstructor; simpl; eauto with cse.\nintros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (bsrc : block) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (ofs ofs0 : ptrofs) (H : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : bsrc = sp) (H7 : ofs = osrc) (H4 : pmatch bc bdst odst (Stk ofs0)) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  {|\n    num_next := num_next n2;\n    num_eqs :=\n      add_memcpy_eqs (Ptrofs.unsigned ofs) sz\n        (Ptrofs.unsigned ofs0 - Ptrofs.unsigned ofs) \n        (num_eqs n1) (num_eqs n2);\n    num_reg := num_reg n2;\n    num_val := num_val n2\n  |}.","proofString":"subst bsrc ofs.\napply A in H4; destruct H4.\nsubst bdst ofs0.\nconstructor; simpl; intros; eauto with cse.\nconstructor; simpl; eauto with cse.\nintros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (ofs0 : ptrofs) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H4 : pmatch bc bdst odst (Stk ofs0)) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  {|\n    num_next := num_next n2;\n    num_eqs :=\n      add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n        (Ptrofs.unsigned ofs0 - Ptrofs.unsigned osrc) \n        (num_eqs n1) (num_eqs n2);\n    num_reg := num_reg n2;\n    num_val := num_val n2\n  |}.","proofString":"apply A in H4; destruct H4.\nsubst bdst ofs0.\nconstructor; simpl; intros; eauto with cse.\nconstructor; simpl; eauto with cse.\nintros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (bdst : block) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (ofs0 : ptrofs) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H3 : bdst = sp) (H4 : ofs0 = odst) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  {|\n    num_next := num_next n2;\n    num_eqs :=\n      add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n        (Ptrofs.unsigned ofs0 - Ptrofs.unsigned osrc) \n        (num_eqs n1) (num_eqs n2);\n    num_reg := num_reg n2;\n    num_val := num_val n2\n  |}.","proofString":"subst bdst ofs0.\nconstructor; simpl; intros; eauto with cse.\nconstructor; simpl; eauto with cse.\nintros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  {|\n    num_next := num_next n2;\n    num_eqs :=\n      add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n        (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n        (num_eqs n1) (num_eqs n2);\n    num_reg := num_reg n2;\n    num_val := num_val n2\n  |}.","proofString":"constructor; simpl; intros; eauto with cse.\nconstructor; simpl; eauto with cse.\nintros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) : wf_numbering\n  {|\n    num_next := num_next n2;\n    num_eqs :=\n      add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n        (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n        (num_eqs n1) (num_eqs n2);\n    num_reg := num_reg n2;\n    num_val := num_val n2\n  |}.","proofString":"constructor; simpl; eauto with cse.\nintros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) : forall e : equation,\nIn e\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2)) -> wf_equation (num_next n2) e.","proofString":"intros.\nexploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) (e : equation) (H3 : In e\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2))) : wf_equation (num_next n2) e.","proofString":"exploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) (e : equation) (H3 : In e\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2))) : In e (num_eqs n2) \\/\n(exists e0 : equation,\n   In e0 (num_eqs n1) /\\\n   shift_memcpy_eq (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) e0 = \n   Some e) -> wf_equation (num_next n2) e.","proofString":"intros [X | (e0 & X & Y)].\neauto with cse.\napply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) (e : equation) (H3 : In e\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2))) (X : In e (num_eqs n2)) : wf_equation (num_next n2) e.","proofString":"eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) (e : equation) (H3 : In e\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2))) (e0 : equation) (X : In e0 (num_eqs n1)) (Y : shift_memcpy_eq (Ptrofs.unsigned osrc) sz\n  (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) e0 = \nSome e) : wf_equation (num_next n2) e.","proofString":"apply wf_equation_incr with (num_next n1); auto.\neapply shift_memcpy_eq_wf; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) (e : equation) (H3 : In e\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2))) (e0 : equation) (X : In e0 (num_eqs n1)) (Y : shift_memcpy_eq (Ptrofs.unsigned osrc) sz\n  (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) e0 = \nSome e) : wf_equation (num_next n1) e.","proofString":"eapply shift_memcpy_eq_wf; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) (eq : equation) (H3 : In eq\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2))) : equation_holds valu ge (Vptr sp Ptrofs.zero) m' eq.","proofString":"exploit add_memcpy_eqs_charact; eauto.\nintros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) (eq : equation) (H3 : In eq\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2))) : In eq (num_eqs n2) \\/\n(exists e : equation,\n   In e (num_eqs n1) /\\\n   shift_memcpy_eq (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) e = \n   Some eq) -> equation_holds valu ge (Vptr sp Ptrofs.zero) m' eq.","proofString":"intros [X | (e0 & X & Y)].\neauto with cse.\neapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) (eq : equation) (H3 : In eq\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2))) (X : In eq (num_eqs n2)) : equation_holds valu ge (Vptr sp Ptrofs.zero) m' eq.","proofString":"eauto with cse."},{"statement":"(m : mem) (osrc : ptrofs) (sz : Z) (bytes : list memval) (odst : ptrofs) (m' : mem) (valu : valuation) (ge : genv) (sp : block) (rs : regset) (n1 n2 : numbering) (bc : block_classification) (H : Mem.loadbytes m sp (Ptrofs.unsigned osrc) sz = Some bytes) (H0 : Mem.storebytes m sp (Ptrofs.unsigned odst) bytes = Some m') (H1 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1) (H2 : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n2) (H5 : bc sp = BCstack) (H6 : Ple (num_next n1) (num_next n2)) (A : forall (b : block) (o i : ptrofs), pmatch bc b o (Stk i) -> b = sp /\\ i = o) (eq : equation) (H3 : In eq\n  (add_memcpy_eqs (Ptrofs.unsigned osrc) sz\n     (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) \n     (num_eqs n1) (num_eqs n2))) (e0 : equation) (X : In e0 (num_eqs n1)) (Y : shift_memcpy_eq (Ptrofs.unsigned osrc) sz\n  (Ptrofs.unsigned odst - Ptrofs.unsigned osrc) e0 = \nSome eq) : equation_holds valu ge (Vptr sp Ptrofs.zero) m' eq.","proofString":"eapply shift_memcpy_eq_holds; eauto with cse."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (transfer f dm vapprox pc n).","proofString":"unfold transfer; rewrite CODEAT.\nassert (CASE1: exists valu, numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m' empty_numbering).\nexists valu; apply empty_numbering_holds.\nassert (CASE2: m' = m -> exists valu, numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m' (set_res_unknown n res)).\nintros.\nsubst m'.\nexists valu.\napply set_res_unknown_holds; auto.\nassert (CASE3: exists valu, numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m'                         (set_res_unknown (kill_all_loads n) res)).\nexists valu.\napply set_res_unknown_holds.\neapply kill_all_loads_hold; eauto.\ndestruct ef.\napply CASE1.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK.\nhnf in EC; rewrite LK in EC; inv EC.\neapply add_builtin_holds; eauto.\napply CASE3.\napply CASE1.\napply CASE2; inv EC; auto.\napply CASE3.\napply CASE1.\napply CASE1.\ninv BA; auto.\ninv H0; auto.\ninv H2; auto.\nsimpl in EC; inv EC.\nexists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl.\napply CASE2; inv EC; auto.\napply CASE2; inv EC; auto.\napply CASE1.\napply CASE2; inv EC; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m'\n    match ef with\n    | EF_builtin name sg =>\n        match lookup_builtin_function name sg with\n        | Some bf => add_builtin n res bf args\n        | None => set_res_unknown (kill_all_loads n) res\n        end\n    | EF_vstore _ => set_res_unknown (kill_all_loads n) res\n    | EF_memcpy sz _ =>\n        match args with\n        | nil => empty_numbering\n        | dst :: nil => empty_numbering\n        | dst :: src :: nil =>\n            set_res_unknown\n              (add_memcpy n\n                 (kill_loads_after_storebytes n (aaddr_arg vapprox # pc dst)\n                    sz) (aaddr_arg vapprox # pc src)\n                 (aaddr_arg vapprox # pc dst) sz) res\n        | dst :: src :: _ :: _ => empty_numbering\n        end\n    | EF_vload _ | EF_annot _ _ _ | EF_annot_val _ _ _ | EF_debug _ _ _ =>\n        set_res_unknown n res\n    | _ => empty_numbering\n    end.","proofString":"assert (CASE1: exists valu, numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m' empty_numbering).\nexists valu; apply empty_numbering_holds.\nassert (CASE2: m' = m -> exists valu, numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m' (set_res_unknown n res)).\nintros.\nsubst m'.\nexists valu.\napply set_res_unknown_holds; auto.\nassert (CASE3: exists valu, numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m'                         (set_res_unknown (kill_all_loads n) res)).\nexists valu.\napply set_res_unknown_holds.\neapply kill_all_loads_hold; eauto.\ndestruct ef.\napply CASE1.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK.\nhnf in EC; rewrite LK in EC; inv EC.\neapply add_builtin_holds; eauto.\napply CASE3.\napply CASE1.\napply CASE2; inv EC; auto.\napply CASE3.\napply CASE1.\napply CASE1.\ninv BA; auto.\ninv H0; auto.\ninv H2; auto.\nsimpl in EC; inv EC.\nexists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl.\napply CASE2; inv EC; auto.\napply CASE2; inv EC; auto.\napply CASE1.\napply CASE2; inv EC; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering.","proofString":"exists valu; apply empty_numbering_holds."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m'\n    match ef with\n    | EF_builtin name sg =>\n        match lookup_builtin_function name sg with\n        | Some bf => add_builtin n res bf args\n        | None => set_res_unknown (kill_all_loads n) res\n        end\n    | EF_vstore _ => set_res_unknown (kill_all_loads n) res\n    | EF_memcpy sz _ =>\n        match args with\n        | nil => empty_numbering\n        | dst :: nil => empty_numbering\n        | dst :: src :: nil =>\n            set_res_unknown\n              (add_memcpy n\n                 (kill_loads_after_storebytes n (aaddr_arg vapprox # pc dst)\n                    sz) (aaddr_arg vapprox # pc src)\n                 (aaddr_arg vapprox # pc dst) sz) res\n        | dst :: src :: _ :: _ => empty_numbering\n        end\n    | EF_vload _ | EF_annot _ _ _ | EF_annot_val _ _ _ | EF_debug _ _ _ =>\n        set_res_unknown n res\n    | _ => empty_numbering\n    end.","proofString":"assert (CASE2: m' = m -> exists valu, numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m' (set_res_unknown n res)).\nintros.\nsubst m'.\nexists valu.\napply set_res_unknown_holds; auto.\nassert (CASE3: exists valu, numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m'                         (set_res_unknown (kill_all_loads n) res)).\nexists valu.\napply set_res_unknown_holds.\neapply kill_all_loads_hold; eauto.\ndestruct ef.\napply CASE1.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK.\nhnf in EC; rewrite LK in EC; inv EC.\neapply add_builtin_holds; eauto.\napply CASE3.\napply CASE1.\napply CASE2; inv EC; auto.\napply CASE3.\napply CASE1.\napply CASE1.\ninv BA; auto.\ninv H0; auto.\ninv H2; auto.\nsimpl in EC; inv EC.\nexists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl.\napply CASE2; inv EC; auto.\napply CASE2; inv EC; auto.\napply CASE1.\napply CASE2; inv EC; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res).","proofString":"intros.\nsubst m'.\nexists valu.\napply set_res_unknown_holds; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (H : m' = m) : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res).","proofString":"subst m'.\nexists valu.\napply set_res_unknown_holds; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m empty_numbering) : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m (set_res_unknown n res).","proofString":"exists valu.\napply set_res_unknown_holds; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m empty_numbering) : numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m\n  (set_res_unknown n res).","proofString":"apply set_res_unknown_holds; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m'\n    match ef with\n    | EF_builtin name sg =>\n        match lookup_builtin_function name sg with\n        | Some bf => add_builtin n res bf args\n        | None => set_res_unknown (kill_all_loads n) res\n        end\n    | EF_vstore _ => set_res_unknown (kill_all_loads n) res\n    | EF_memcpy sz _ =>\n        match args with\n        | nil => empty_numbering\n        | dst :: nil => empty_numbering\n        | dst :: src :: nil =>\n            set_res_unknown\n              (add_memcpy n\n                 (kill_loads_after_storebytes n (aaddr_arg vapprox # pc dst)\n                    sz) (aaddr_arg vapprox # pc src)\n                 (aaddr_arg vapprox # pc dst) sz) res\n        | dst :: src :: _ :: _ => empty_numbering\n        end\n    | EF_vload _ | EF_annot _ _ _ | EF_annot_val _ _ _ | EF_debug _ _ _ =>\n        set_res_unknown n res\n    | _ => empty_numbering\n    end.","proofString":"assert (CASE3: exists valu, numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m'                         (set_res_unknown (kill_all_loads n) res)).\nexists valu.\napply set_res_unknown_holds.\neapply kill_all_loads_hold; eauto.\ndestruct ef.\napply CASE1.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK.\nhnf in EC; rewrite LK in EC; inv EC.\neapply add_builtin_holds; eauto.\napply CASE3.\napply CASE1.\napply CASE2; inv EC; auto.\napply CASE3.\napply CASE1.\napply CASE1.\ninv BA; auto.\ninv H0; auto.\ninv H2; auto.\nsimpl in EC; inv EC.\nexists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl.\napply CASE2; inv EC; auto.\napply CASE2; inv EC; auto.\napply CASE1.\napply CASE2; inv EC; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res).","proofString":"exists valu.\napply set_res_unknown_holds.\neapply kill_all_loads_hold; eauto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) : numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs) m'\n  (set_res_unknown (kill_all_loads n) res).","proofString":"apply set_res_unknown_holds.\neapply kill_all_loads_hold; eauto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' (kill_all_loads n).","proofString":"eapply kill_all_loads_hold; eauto."},{"statement":"(ge : genv) (f : function) (pc : positive) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call ef ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m'\n    match ef with\n    | EF_builtin name sg =>\n        match lookup_builtin_function name sg with\n        | Some bf => add_builtin n res bf args\n        | None => set_res_unknown (kill_all_loads n) res\n        end\n    | EF_vstore _ => set_res_unknown (kill_all_loads n) res\n    | EF_memcpy sz _ =>\n        match args with\n        | nil => empty_numbering\n        | dst :: nil => empty_numbering\n        | dst :: src :: nil =>\n            set_res_unknown\n              (add_memcpy n\n                 (kill_loads_after_storebytes n (aaddr_arg vapprox # pc dst)\n                    sz) (aaddr_arg vapprox # pc src)\n                 (aaddr_arg vapprox # pc dst) sz) res\n        | dst :: src :: _ :: _ => empty_numbering\n        end\n    | EF_vload _ | EF_annot _ _ _ | EF_annot_val _ _ _ | EF_debug _ _ _ =>\n        set_res_unknown n res\n    | _ => empty_numbering\n    end.","proofString":"destruct ef.\napply CASE1.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK.\nhnf in EC; rewrite LK in EC; inv EC.\neapply add_builtin_holds; eauto.\napply CASE3.\napply CASE1.\napply CASE2; inv EC; auto.\napply CASE3.\napply CASE1.\napply CASE1.\ninv BA; auto.\ninv H0; auto.\ninv H2; auto.\nsimpl in EC; inv EC.\nexists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl.\napply CASE2; inv EC; auto.\napply CASE2; inv EC; auto.\napply CASE1.\napply CASE2; inv EC; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_external name sg) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_external name sg) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering.","proofString":"apply CASE1."},{"statement":"(ge : genv) (f : function) (pc : positive) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_builtin name sg) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m'\n    match lookup_builtin_function name sg with\n    | Some bf => add_builtin n res bf args\n    | None => set_res_unknown (kill_all_loads n) res\n    end.","proofString":"destruct (lookup_builtin_function name sg) as [bf|] eqn:LK.\nhnf in EC; rewrite LK in EC; inv EC.\neapply add_builtin_holds; eauto.\napply CASE3."},{"statement":"(ge : genv) (f : function) (pc : positive) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_builtin name sg) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) (bf : builtin_function) (LK : lookup_builtin_function name sg = Some bf) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (add_builtin n res bf args).","proofString":"hnf in EC; rewrite LK in EC; inv EC.\neapply add_builtin_holds; eauto."},{"statement":"(ge : genv) (f : function) (pc : positive) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (vargs : list val) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m' args vargs) (bf : builtin_function) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m' n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RM : romatch bc m' rm) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m' ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) (LK : lookup_builtin_function name sg = Some bf) (H : builtin_function_sem bf vargs = Some vres) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (add_builtin n res bf args).","proofString":"eapply add_builtin_holds; eauto."},{"statement":"(ge : genv) (f : function) (pc : positive) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_builtin name sg) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) (LK : lookup_builtin_function name sg = None) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res).","proofString":"apply CASE3."},{"statement":"(ge : genv) (f : function) (pc : positive) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_runtime name sg) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_runtime name sg) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering.","proofString":"apply CASE1."},{"statement":"(ge : genv) (f : function) (pc : positive) (chunk : memory_chunk) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_vload chunk) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res).","proofString":"apply CASE2; inv EC; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (chunk : memory_chunk) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_vstore chunk) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_vstore chunk) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res).","proofString":"apply CASE3."},{"statement":"(ge : genv) (f : function) (pc : positive) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin EF_malloc args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call EF_malloc ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering.","proofString":"apply CASE1."},{"statement":"(ge : genv) (f : function) (pc : positive) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin EF_free args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call EF_free ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering.","proofString":"apply CASE1."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_memcpy sz al) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_memcpy sz al) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m'\n    match args with\n    | nil => empty_numbering\n    | dst :: nil => empty_numbering\n    | dst :: src :: nil =>\n        set_res_unknown\n          (add_memcpy n\n             (kill_loads_after_storebytes n (aaddr_arg vapprox # pc dst) sz)\n             (aaddr_arg vapprox # pc src) (aaddr_arg vapprox # pc dst) sz)\n          res\n    | dst :: src :: _ :: _ => empty_numbering\n    end.","proofString":"inv BA; auto.\ninv H0; auto.\ninv H2; auto.\nsimpl in EC; inv EC.\nexists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 : builtin_arg positive) (al0 : list (builtin_arg positive)) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_memcpy sz al) (a1 :: al0) res pc')) (b1 : val) (bl : list val) (EC : external_call (EF_memcpy sz al) ge (b1 :: bl) m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H0 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al0 bl) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m'\n    match al0 with\n    | nil => empty_numbering\n    | src :: nil =>\n        set_res_unknown\n          (add_memcpy n\n             (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz)\n             (aaddr_arg vapprox # pc src) (aaddr_arg vapprox # pc a1) sz) res\n    | src :: _ :: _ => empty_numbering\n    end.","proofString":"inv H0; auto.\ninv H2; auto.\nsimpl in EC; inv EC.\nexists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (al1 : list (builtin_arg positive)) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: al1) res pc')) (b1 b0 : val) (bl0 : list val) (EC : external_call (EF_memcpy sz al) ge (b1 :: b0 :: bl0) m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  b0) (H2 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al1 bl0) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m'\n    match al1 with\n    | nil =>\n        set_res_unknown\n          (add_memcpy n\n             (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz)\n             (aaddr_arg vapprox # pc a0) (aaddr_arg vapprox # pc a1) sz) res\n    | _ :: _ => empty_numbering\n    end.","proofString":"inv H2; auto.\nsimpl in EC; inv EC.\nexists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (b1 b0 : val) (EC : external_call (EF_memcpy sz al) ge (b1 :: b0 :: nil) m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  b0) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m'\n    (set_res_unknown\n       (add_memcpy n\n          (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz)\n          (aaddr_arg vapprox # pc a0) (aaddr_arg vapprox # pc a1) sz) res).","proofString":"simpl in EC; inv EC.\nexists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown (kill_all_loads n) res)) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown n res)) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' empty_numbering) (bdst : block) (odst : ptrofs) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H14 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m'\n    (set_res_unknown\n       (add_memcpy n\n          (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz)\n          (aaddr_arg vapprox # pc a0) (aaddr_arg vapprox # pc a1) sz) res).","proofString":"exists valu.\napply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown (kill_all_loads n) res)) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown n res)) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' empty_numbering) (bdst : block) (odst : ptrofs) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H14 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : numbering_holds valu ge (Vptr sp Ptrofs.zero) (regmap_setres res Vundef rs)\n  m'\n  (set_res_unknown\n     (add_memcpy n\n        (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz)\n        (aaddr_arg vapprox # pc a0) (aaddr_arg vapprox # pc a1) sz) res).","proofString":"apply set_res_unknown_holds.\nassert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown (kill_all_loads n) res)) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown n res)) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' empty_numbering) (bdst : block) (odst : ptrofs) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H14 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  (add_memcpy n\n     (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz)\n     (aaddr_arg vapprox # pc a0) (aaddr_arg vapprox # pc a1) sz).","proofString":"assert (pmatch bc bsrc osrc (aaddr_arg vapprox#pc a0))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\nassert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown (kill_all_loads n) res)) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown n res)) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' empty_numbering) (bdst : block) (odst : ptrofs) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H14 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H0 : pmatch bc bsrc osrc (aaddr_arg vapprox # pc a0)) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  (add_memcpy n\n     (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz)\n     (aaddr_arg vapprox # pc a0) (aaddr_arg vapprox # pc a1) sz).","proofString":"assert (pmatch bc bdst odst (aaddr_arg vapprox#pc a1))    by (rewrite APPROX; eapply aaddr_arg_sound_1; eauto).\neapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown (kill_all_loads n) res)) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown n res)) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' empty_numbering) (bdst : block) (odst : ptrofs) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H14 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H0 : pmatch bc bsrc osrc (aaddr_arg vapprox # pc a0)) (H2 : pmatch bc bdst odst (aaddr_arg vapprox # pc a1)) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  (add_memcpy n\n     (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz)\n     (aaddr_arg vapprox # pc a0) (aaddr_arg vapprox # pc a1) sz).","proofString":"eapply add_memcpy_holds; eauto.\neapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto.\nsimpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown (kill_all_loads n) res)) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown n res)) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' empty_numbering) (bdst : block) (odst : ptrofs) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H14 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H0 : pmatch bc bsrc osrc (aaddr_arg vapprox # pc a0)) (H2 : pmatch bc bdst odst (aaddr_arg vapprox # pc a1)) : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m'\n  (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz).","proofString":"eapply kill_loads_after_storebytes_holds; eauto.\neapply Mem.loadbytes_length; eauto."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown (kill_all_loads n) res)) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown n res)) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' empty_numbering) (bdst : block) (odst : ptrofs) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H14 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H0 : pmatch bc bsrc osrc (aaddr_arg vapprox # pc a0)) (H2 : pmatch bc bdst odst (aaddr_arg vapprox # pc a1)) : Datatypes.length bytes = Z.to_nat sz.","proofString":"eapply Mem.loadbytes_length; eauto."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown (kill_all_loads n) res)) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown n res)) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' empty_numbering) (bdst : block) (odst : ptrofs) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H14 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H0 : pmatch bc bsrc osrc (aaddr_arg vapprox # pc a0)) (H2 : pmatch bc bdst odst (aaddr_arg vapprox # pc a1)) : Ple (num_next n)\n  (num_next (kill_loads_after_storebytes n (aaddr_arg vapprox # pc a1) sz)).","proofString":"simpl.\napply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc : positive) (sz al : Z) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (a1 a0 : builtin_arg positive) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown (kill_all_loads n) res)) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' (set_res_unknown n res)) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero)\n    (regmap_setres res Vundef rs) m' empty_numbering) (bdst : block) (odst : ptrofs) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H1 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H14 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (H0 : pmatch bc bsrc osrc (aaddr_arg vapprox # pc a0)) (H2 : pmatch bc bdst odst (aaddr_arg vapprox # pc a1)) : Ple (num_next n) (num_next n).","proofString":"apply Ple_refl."},{"statement":"(ge : genv) (f : function) (pc kind : positive) (text : string) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_annot kind text targs) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_annot kind text targs) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res).","proofString":"apply CASE2; inv EC; auto."},{"statement":"(ge : genv) (f : function) (pc kind : positive) (text : string) (targ : typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val kind text targ) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_annot_val kind text targ) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res).","proofString":"apply CASE2; inv EC; auto."},{"statement":"(ge : genv) (f : function) (pc : positive) (text : string) (sg : signature) (clobbers : list string) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc =\nSome (Ibuiltin (EF_inline_asm text sg clobbers) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_inline_asm text sg clobbers) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering.","proofString":"apply CASE1."},{"statement":"(ge : genv) (f : function) (pc kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (rs : Regmap.t val) (sp : block) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (valu : valuation) (n : numbering) (dm : defmap) (vapprox : PMap.t VA.t') (ae : aenv) (am : amem) (bc : block_classification) (rm : romem) (CODEAT : (fn_code f) ! pc = Some (Ibuiltin (EF_debug kind text targs) args res pc')) (BA : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m args vargs) (EC : external_call (EF_debug kind text targs) ge vargs m t vres m') (NH : numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n) (APPROX : vapprox # pc = VA.State ae am) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SM : bc sp = BCstack) (CASE1 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' empty_numbering) (CASE2 : m' = m ->\nexists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res)) (CASE3 : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown (kill_all_loads n) res)) : exists valu' : valuation,\n  numbering_holds valu' ge (Vptr sp Ptrofs.zero) (regmap_setres res vres rs)\n    m' (set_res_unknown n res).","proofString":"apply CASE2; inv EC; auto."},{"statement":"(op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (H : None = Some (op', rl')) (H0 : sem op (map valu args) = Some res) : sem op' rs ## rl' = Some res.","proofString":"discriminate."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (H : match f (fun v : valnum => find_valnum_num v (num_eqs n)) op args with\n| Some (op'0, args') =>\n    match reduce_rec A f n niter op'0 args' with\n    | Some p0 => Some p0\n    | None =>\n        match regs_valnums n args' with\n        | Some rl => Some (op'0, rl)\n        | None => None\n        end\n    end\n| None => None\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some res) : sem op' rs ## rl' = Some res.","proofString":"destruct (f (fun v : valnum => find_valnum_num v (num_eqs n)) op args)           as [[op1 args1] | ] eqn:?.\nassert (sem op1 (map valu args1) = Some res).\nrewrite <- H0.\neapply f_sound; eauto.\nsimpl; intros.\nexploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto.\ndestruct (reduce_rec A f n niter op1 args1) as [[op2 rl2] | ] eqn:?.\ninv H.\neapply IHniter; eauto.\ndestruct (regs_valnums n args1) as [rl|] eqn:?.\ninv H.\nerewrite regs_valnums_sound; eauto.\ndiscriminate.\ndiscriminate."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some res) : sem op' rs ## rl' = Some res.","proofString":"assert (sem op1 (map valu args1) = Some res).\nrewrite <- H0.\neapply f_sound; eauto.\nsimpl; intros.\nexploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto.\ndestruct (reduce_rec A f n niter op1 args1) as [[op2 rl2] | ] eqn:?.\ninv H.\neapply IHniter; eauto.\ndestruct (regs_valnums n args1) as [rl|] eqn:?.\ninv H.\nerewrite regs_valnums_sound; eauto.\ndiscriminate."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some res) : sem op1 (map valu args1) = Some res.","proofString":"rewrite <- H0.\neapply f_sound; eauto.\nsimpl; intros.\nexploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some res) : sem op1 (map valu args1) = sem op (map valu args).","proofString":"eapply f_sound; eauto.\nsimpl; intros.\nexploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some res) : forall (v : valnum) (rhs : rhs),\n(fun v0 : valnum => find_valnum_num v0 (num_eqs n)) v = Some rhs ->\nrhs_eval_to valu ge sp m rhs (valu v).","proofString":"simpl; intros.\nexploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v0 : valnum => find_valnum_num v0 (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some res) (v : valnum) (rhs : CSEdomain.rhs) (H1 : find_valnum_num v (num_eqs n) = Some rhs) : rhs_eval_to valu ge sp m rhs (valu v).","proofString":"exploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some res) (H1 : sem op1 (map valu args1) = Some res) : sem op' rs ## rl' = Some res.","proofString":"destruct (reduce_rec A f n niter op1 args1) as [[op2 rl2] | ] eqn:?.\ninv H.\neapply IHniter; eauto.\ndestruct (regs_valnums n args1) as [rl|] eqn:?.\ninv H.\nerewrite regs_valnums_sound; eauto.\ndiscriminate."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (op2 : A) (rl2 : list reg) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op2, rl2)) (H : Some (op2, rl2) = Some (op', rl')) (H0 : sem op (map valu args) = Some res) (H1 : sem op1 (map valu args1) = Some res) : sem op' rs ## rl' = Some res.","proofString":"inv H.\neapply IHniter; eauto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op', rl')) (H0 : sem op (map valu args) = Some res) (H1 : sem op1 (map valu args1) = Some res) : sem op' rs ## rl' = Some res.","proofString":"eapply IHniter; eauto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = None) (H : match regs_valnums n args1 with\n| Some rl => Some (op1, rl)\n| None => None\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some res) (H1 : sem op1 (map valu args1) = Some res) : sem op' rs ## rl' = Some res.","proofString":"destruct (regs_valnums n args1) as [rl|] eqn:?.\ninv H.\nerewrite regs_valnums_sound; eauto.\ndiscriminate."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = None) (rl : list reg) (Heqo1 : regs_valnums n args1 = Some rl) (H : Some (op1, rl) = Some (op', rl')) (H0 : sem op (map valu args) = Some res) (H1 : sem op1 (map valu args1) = Some res) : sem op' rs ## rl' = Some res.","proofString":"inv H.\nerewrite regs_valnums_sound; eauto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (args1 : list valnum) (Heqo0 : reduce_rec A f n niter op' args1 = None) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op', args1)) (Heqo1 : regs_valnums n args1 = Some rl') (H0 : sem op (map valu args) = Some res) (H1 : sem op' (map valu args1) = Some res) : sem op' rs ## rl' = Some res.","proofString":"erewrite regs_valnums_sound; eauto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = None) (Heqo1 : regs_valnums n args1 = None) (H : None = Some (op', rl')) (H0 : sem op (map valu args) = Some res) (H1 : sem op1 (map valu args1) = Some res) : sem op' rs ## rl' = Some res.","proofString":"discriminate."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (res0 : V),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some res0 -> sem op'0 rs ## rl'0 = Some res0) (op : A) (args : list valnum) (op' : A) (rl' : list reg) (res : V) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args = None) (H : None = Some (op', rl')) (H0 : sem op (map valu args) = Some res) : sem op' rs ## rl' = Some res.","proofString":"discriminate."},{"statement":"(op : A) (rl : list reg) (vl : list valnum) (op' : A) (rl' : list reg) (res : V) (H : match reduce_rec A f n 4 op vl with\n| Some res0 => res0\n| None => (op, rl)\nend = (op', rl')) (H0 : map valu vl = rs ## rl) (H1 : sem op rs ## rl = Some res) : sem op' rs ## rl' = Some res.","proofString":"destruct (reduce_rec A f n 4%nat op vl) as [[op1 rl1] | ] eqn:?; inv H.\neapply reduce_rec_sound; eauto.\ncongruence.\nauto."},{"statement":"(op : A) (rl : list reg) (vl : list valnum) (op' : A) (rl' : list reg) (res : V) (Heqo : reduce_rec A f n 4 op vl = Some (op', rl')) (H0 : map valu vl = rs ## rl) (H1 : sem op rs ## rl = Some res) : sem op' rs ## rl' = Some res.","proofString":"eapply reduce_rec_sound; eauto.\ncongruence."},{"statement":"(op : A) (rl : list reg) (vl : list valnum) (op' : A) (rl' : list reg) (res : V) (Heqo : reduce_rec A f n 4 op vl = Some (op', rl')) (H0 : map valu vl = rs ## rl) (H1 : sem op rs ## rl = Some res) : sem op (map valu vl) = Some res.","proofString":"congruence."},{"statement":"(vl : list valnum) (op' : A) (rl' : list reg) (res : V) (Heqo : reduce_rec A f n 4 op' vl = None) (H1 : sem op' rs ## rl' = Some res) (H0 : map valu vl = rs ## rl') : sem op' rs ## rl' = Some res.","proofString":"auto."},{"statement":"(op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (H : None = Some (op', rl')) (H0 : sem op (map valu args) = Some r) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"discriminate."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (H : match f (fun v : valnum => find_valnum_num v (num_eqs n)) op args with\n| Some (op'0, args') =>\n    match reduce_rec A f n niter op'0 args' with\n    | Some p0 => Some p0\n    | None =>\n        match regs_valnums n args' with\n        | Some rl => Some (op'0, rl)\n        | None => None\n        end\n    end\n| None => None\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some r) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"destruct (f (fun v : valnum => find_valnum_num v (num_eqs n)) op args)           as [[op1 args1] | ] eqn:?; try discriminate.\nassert (exists r': val, sem op1 (map valu args1) = Some r' /\\ Val.lessdef r r').\nexploit f_sound; eauto.\nsimpl; intros.\nexploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto.\ndestruct (reduce_rec A f n niter op1 args1) as [[op2 rl2] | ] eqn:?.\ndestruct H1.\ndestruct H1.\nexploit IHniter.\neexact Heqo0.\neexact H1.\ninv H.\nintros.\ndestruct H.\ndestruct H.\nexists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3.\ndestruct (regs_valnums n args1) as [rl|] eqn:?; try discriminate.\ninv H.\nerewrite regs_valnums_sound; eauto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some r) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"assert (exists r': val, sem op1 (map valu args1) = Some r' /\\ Val.lessdef r r').\nexploit f_sound; eauto.\nsimpl; intros.\nexploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto.\ndestruct (reduce_rec A f n niter op1 args1) as [[op2 rl2] | ] eqn:?.\ndestruct H1.\ndestruct H1.\nexploit IHniter.\neexact Heqo0.\neexact H1.\ninv H.\nintros.\ndestruct H.\ndestruct H.\nexists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3.\ndestruct (regs_valnums n args1) as [rl|] eqn:?; try discriminate.\ninv H.\nerewrite regs_valnums_sound; eauto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some r) : exists r' : val, sem op1 (map valu args1) = Some r' /\\ Val.lessdef r r'.","proofString":"exploit f_sound; eauto.\nsimpl; intros.\nexploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some r) : forall (v : valnum) (rhs : rhs),\n(fun v0 : valnum => find_valnum_num v0 (num_eqs n)) v = Some rhs ->\nrhs_eval_to valu ge sp m rhs (valu v).","proofString":"simpl; intros.\nexploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v0 : valnum => find_valnum_num v0 (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (v : valnum) (rhs : CSEdomain.rhs) (H1 : find_valnum_num v (num_eqs n) = Some rhs) : rhs_eval_to valu ge sp m rhs (valu v).","proofString":"exploit num_holds_eq; eauto.\neapply find_valnum_num_charact; eauto with cse.\nintros EH; inv EH; auto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (H : match reduce_rec A f n niter op1 args1 with\n| Some p => Some p\n| None =>\n    match regs_valnums n args1 with\n    | Some rl => Some (op1, rl)\n    | None => None\n    end\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (H1 : exists r' : val, sem op1 (map valu args1) = Some r' /\\ Val.lessdef r r') : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"destruct (reduce_rec A f n niter op1 args1) as [[op2 rl2] | ] eqn:?.\ndestruct H1.\ndestruct H1.\nexploit IHniter.\neexact Heqo0.\neexact H1.\ninv H.\nintros.\ndestruct H.\ndestruct H.\nexists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3.\ndestruct (regs_valnums n args1) as [rl|] eqn:?; try discriminate.\ninv H.\nerewrite regs_valnums_sound; eauto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (op2 : A) (rl2 : list reg) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op2, rl2)) (H : Some (op2, rl2) = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (H1 : exists r' : val, sem op1 (map valu args1) = Some r' /\\ Val.lessdef r r') : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"destruct H1.\ndestruct H1.\nexploit IHniter.\neexact Heqo0.\neexact H1.\ninv H.\nintros.\ndestruct H.\ndestruct H.\nexists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (op2 : A) (rl2 : list reg) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op2, rl2)) (H : Some (op2, rl2) = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (x : val) (H1 : sem op1 (map valu args1) = Some x /\\ Val.lessdef r x) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"destruct H1.\nexploit IHniter.\neexact Heqo0.\neexact H1.\ninv H.\nintros.\ndestruct H.\ndestruct H.\nexists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (op2 : A) (rl2 : list reg) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op2, rl2)) (H : Some (op2, rl2) = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (x : val) (H1 : sem op1 (map valu args1) = Some x) (H2 : Val.lessdef r x) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"exploit IHniter.\neexact Heqo0.\neexact H1.\ninv H.\nintros.\ndestruct H.\ndestruct H.\nexists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (x : val) (H1 : sem op1 (map valu args1) = Some x) (H2 : Val.lessdef r x) : (exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef x r') ->\nexists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"intros.\ndestruct H.\ndestruct H.\nexists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (x : val) (H1 : sem op1 (map valu args1) = Some x) (H2 : Val.lessdef r x) (H : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef x r') : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"destruct H.\ndestruct H.\nexists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (x : val) (H1 : sem op1 (map valu args1) = Some x) (H2 : Val.lessdef r x) (x0 : val) (H : sem op' rs ## rl' = Some x0 /\\ Val.lessdef x x0) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"destruct H.\nexists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (x : val) (H1 : sem op1 (map valu args1) = Some x) (H2 : Val.lessdef r x) (x0 : val) (H : sem op' rs ## rl' = Some x0) (H3 : Val.lessdef x x0) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"exists x0.\nsplit; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (x : val) (H1 : sem op1 (map valu args1) = Some x) (H2 : Val.lessdef r x) (x0 : val) (H : sem op' rs ## rl' = Some x0) (H3 : Val.lessdef x x0) : sem op' rs ## rl' = Some x0 /\\ Val.lessdef r x0.","proofString":"split; eauto.\neapply Val.lessdef_trans.\neexact H2.\neexact H3."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (x : val) (H1 : sem op1 (map valu args1) = Some x) (H2 : Val.lessdef r x) (x0 : val) (H : sem op' rs ## rl' = Some x0) (H3 : Val.lessdef x x0) : Val.lessdef r x0.","proofString":"eapply Val.lessdef_trans.\neexact H2.\neexact H3."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = None) (H : match regs_valnums n args1 with\n| Some rl => Some (op1, rl)\n| None => None\nend = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (H1 : exists r' : val, sem op1 (map valu args1) = Some r' /\\ Val.lessdef r r') : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"destruct (regs_valnums n args1) as [rl|] eqn:?; try discriminate.\ninv H.\nerewrite regs_valnums_sound; eauto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (args1 : list valnum) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op1, args1)) (Heqo0 : reduce_rec A f n niter op1 args1 = None) (rl : list reg) (Heqo1 : regs_valnums n args1 = Some rl) (H : Some (op1, rl) = Some (op', rl')) (H0 : sem op (map valu args) = Some r) (H1 : exists r' : val, sem op1 (map valu args1) = Some r' /\\ Val.lessdef r r') : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"inv H.\nerewrite regs_valnums_sound; eauto."},{"statement":"(niter : nat) (IHniter : forall (op0 : A) (args0 : list valnum) (op'0 : A) \n  (rl'0 : list reg) (r0 : val),\nreduce_rec A f n niter op0 args0 = Some (op'0, rl'0) ->\nsem op0 (map valu args0) = Some r0 ->\nexists r' : val, sem op'0 rs ## rl'0 = Some r' /\\ Val.lessdef r0 r') (op : A) (args : list valnum) (op' : A) (rl' : list reg) (r : val) (args1 : list valnum) (Heqo0 : reduce_rec A f n niter op' args1 = None) (Heqo : f (fun v : valnum => find_valnum_num v (num_eqs n)) op args =\nSome (op', args1)) (Heqo1 : regs_valnums n args1 = Some rl') (H0 : sem op (map valu args) = Some r) (H1 : exists r' : val, sem op' (map valu args1) = Some r' /\\ Val.lessdef r r') : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"erewrite regs_valnums_sound; eauto."},{"statement":"(op : A) (rl : list reg) (vl : list valnum) (op' : A) (rl' : list reg) (r : val) (H : match reduce_rec A f n 4 op vl with\n| Some res => res\n| None => (op, rl)\nend = (op', rl')) (H0 : map valu vl = rs ## rl) (H1 : sem op rs ## rl = Some r) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"destruct (reduce_rec A f n 4%nat op vl) as [[op1 rl1] | ] eqn:?.\neapply reduce_rec_lessdef_sound; eauto.\ninv H.\neexact Heqo.\ncongruence.\nexists r.\ninv H.\nauto."},{"statement":"(op : A) (rl : list reg) (vl : list valnum) (op' : A) (rl' : list reg) (r : val) (op1 : A) (rl1 : list reg) (Heqo : reduce_rec A f n 4 op vl = Some (op1, rl1)) (H : (op1, rl1) = (op', rl')) (H0 : map valu vl = rs ## rl) (H1 : sem op rs ## rl = Some r) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"eapply reduce_rec_lessdef_sound; eauto.\ninv H.\neexact Heqo.\ncongruence."},{"statement":"(op : A) (rl : list reg) (vl : list valnum) (op' : A) (rl' : list reg) (r : val) (Heqo : reduce_rec A f n 4 op vl = None) (H : (op, rl) = (op', rl')) (H0 : map valu vl = rs ## rl) (H1 : sem op rs ## rl = Some r) : exists r' : val, sem op' rs ## rl' = Some r' /\\ Val.lessdef r r'.","proofString":"exists r.\ninv H.\nauto."},{"statement":"(op : A) (rl : list reg) (vl : list valnum) (op' : A) (rl' : list reg) (r : val) (Heqo : reduce_rec A f n 4 op vl = None) (H : (op, rl) = (op', rl')) (H0 : map valu vl = rs ## rl) (H1 : sem op rs ## rl = Some r) : sem op' rs ## rl' = Some r /\\ Val.lessdef r r.","proofString":"inv H.\nauto."},{"statement":"(vl : list valnum) (op' : A) (rl' : list reg) (r : val) (Heqo : reduce_rec A f n 4 op' vl = None) (H1 : sem op' rs ## rl' = Some r) (H0 : map valu vl = rs ## rl') : sem op' rs ## rl' = Some r /\\ Val.lessdef r r.","proofString":"auto."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (pc : positive) (pc' : node) (i : instruction) (H : analyze f dm vapprox = Some approx) (H0 : (fn_code f) ! pc = Some i) (H1 : In pc' (successors_instr i)) (H2 : exists valu : valuation,\n  numbering_holds valu ge sp rs m (transfer f dm vapprox pc approx # pc)) : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc'.","proofString":"assert (Numbering.ge approx!!pc' (transfer f dm vapprox pc approx!!pc)).\neapply Solver.fixpoint_solution; eauto.\ndestruct H2 as [valu NH].\nexists valu; apply H3.\nauto."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (pc : positive) (pc' : node) (i : instruction) (H : analyze f dm vapprox = Some approx) (H0 : (fn_code f) ! pc = Some i) (H1 : In pc' (successors_instr i)) (H2 : exists valu : valuation,\n  numbering_holds valu ge sp rs m (transfer f dm vapprox pc approx # pc)) : Numbering.ge approx # pc' (transfer f dm vapprox pc approx # pc).","proofString":"eapply Solver.fixpoint_solution; eauto."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (pc : positive) (pc' : node) (i : instruction) (H : analyze f dm vapprox = Some approx) (H0 : (fn_code f) ! pc = Some i) (H1 : In pc' (successors_instr i)) (H2 : exists valu : valuation,\n  numbering_holds valu ge sp rs m (transfer f dm vapprox pc approx # pc)) (H3 : Numbering.ge approx # pc' (transfer f dm vapprox pc approx # pc)) : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc'.","proofString":"destruct H2 as [valu NH].\nexists valu; apply H3.\nauto."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (pc : positive) (pc' : node) (i : instruction) (H : analyze f dm vapprox = Some approx) (H0 : (fn_code f) ! pc = Some i) (H1 : In pc' (successors_instr i)) (valu : valuation) (NH : numbering_holds valu ge sp rs m (transfer f dm vapprox pc approx # pc)) (H3 : Numbering.ge approx # pc' (transfer f dm vapprox pc approx # pc)) : exists valu0 : valuation, numbering_holds valu0 ge sp rs m approx # pc'.","proofString":"exists valu; apply H3.\nauto."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (pc : positive) (pc' : node) (i : instruction) (H : analyze f dm vapprox = Some approx) (H0 : (fn_code f) ! pc = Some i) (H1 : In pc' (successors_instr i)) (valu : valuation) (NH : numbering_holds valu ge sp rs m (transfer f dm vapprox pc approx # pc)) (H3 : Numbering.ge approx # pc' (transfer f dm vapprox pc approx # pc)) : numbering_holds valu ge sp rs m (transfer f dm vapprox pc approx # pc).","proofString":"auto."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (H : analyze f dm vapprox = Some approx) : exists valu : valuation,\n  numbering_holds valu ge sp rs m approx # (fn_entrypoint f).","proofString":"replace (approx!!(f.(fn_entrypoint))) with Solver.L.top.\nexists (fun v => Vundef).\napply empty_numbering_holds.\nsymmetry.\neapply Solver.fixpoint_entry; eauto."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (H : analyze f dm vapprox = Some approx) : exists valu : valuation, numbering_holds valu ge sp rs m Solver.L.top.","proofString":"exists (fun v => Vundef).\napply empty_numbering_holds."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (H : analyze f dm vapprox = Some approx) : numbering_holds (fun _ : valnum => Vundef) ge sp rs m Solver.L.top.","proofString":"apply empty_numbering_holds."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (H : analyze f dm vapprox = Some approx) : Solver.L.top = approx # (fn_entrypoint f).","proofString":"symmetry.\neapply Solver.fixpoint_entry; eauto."},{"statement":"(ge : genv) (sp : val) (rs : regset) (m : mem) (f : function) (dm : defmap) (vapprox : PMap.t VA.t) (approx : PMap.t numbering) (H : analyze f dm vapprox = Some approx) : approx # (fn_entrypoint f) = Solver.L.top.","proofString":"eapply Solver.fixpoint_entry; eauto."},{"statement":"(dm : defmap) (rm : romem) (f tf : fundef) (H : transf_partial_fundef (transf_function dm rm) f = OK tf) : funsig tf = funsig f.","proofString":"destruct f; monadInv H; auto.\nunfold transf_function in EQ.\ndestruct analyze; try discriminate.\ninv EQ; auto."},{"statement":"(dm : defmap) (rm : romem) (f x : function) (EQ : transf_function dm rm f = OK x) : funsig (Internal x) = funsig (Internal f).","proofString":"unfold transf_function in EQ.\ndestruct analyze; try discriminate.\ninv EQ; auto."},{"statement":"(dm : defmap) (rm : romem) (f x : function) (EQ : match analyze f dm (vanalyze rm f) with\n| Some approxs =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code := transf_code dm approxs (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"CSE failure\")\nend = OK x) : funsig (Internal x) = funsig (Internal f).","proofString":"destruct analyze; try discriminate.\ninv EQ; auto."},{"statement":"(dm : defmap) (rm : romem) (f x : function) (t : PMap.t numbering) (EQ : OK\n  {|\n    fn_sig := fn_sig f;\n    fn_params := fn_params f;\n    fn_stacksize := fn_stacksize f;\n    fn_code := transf_code dm t (fn_code f);\n    fn_entrypoint := fn_entrypoint f\n  |} = OK x) : funsig (Internal x) = funsig (Internal f).","proofString":"inv EQ; auto."},{"statement":"(r : positive) (v1 v2 : val) (rs1 rs2 : regset) (H : Val.lessdef v1 v2) (H0 : regs_lessdef rs1 rs2) (r0 : positive) : Val.lessdef (rs1 # r <- v1) # r0 (rs2 # r <- v2) # r0.","proofString":"repeat rewrite Regmap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(r : positive) (v1 v2 : val) (rs1 rs2 : regset) (H : Val.lessdef v1 v2) (H0 : regs_lessdef rs1 rs2) (r0 : positive) : Val.lessdef (if peq r0 r then v1 else rs1 # r0)\n  (if peq r0 r then v2 else rs2 # r0).","proofString":"destruct (peq r0 r); auto."},{"statement":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) : regs_lessdef (Regmap.init Vundef) (Regmap.init Vundef).","proofString":"red; intros.\nrewrite Regmap.gi.\nauto."},{"statement":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) (r : positive) : Val.lessdef (Regmap.init Vundef) # r (Regmap.init Vundef) # r.","proofString":"rewrite Regmap.gi.\nauto."},{"statement":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) (r : positive) : Val.lessdef Vundef Vundef.","proofString":"auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl0 vl3 : list val,\nVal.lessdef_list vl0 vl3 ->\nregs_lessdef (init_regs vl0 rl) (init_regs vl3 rl)) (vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) : regs_lessdef\n  match vl1 with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs rl) # a <- v1\n  end\n  match vl2 with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs rl) # a <- v1\n  end.","proofString":"inv H.\nred; intros.\nrewrite Regmap.gi.\nauto.\napply set_reg_lessdef; auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl1 vl2 : list val,\nVal.lessdef_list vl1 vl2 ->\nregs_lessdef (init_regs vl1 rl) (init_regs vl2 rl)) : regs_lessdef (Regmap.init Vundef) (Regmap.init Vundef).","proofString":"red; intros.\nrewrite Regmap.gi.\nauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl1 vl2 : list val,\nVal.lessdef_list vl1 vl2 ->\nregs_lessdef (init_regs vl1 rl) (init_regs vl2 rl)) (r : positive) : Val.lessdef (Regmap.init Vundef) # r (Regmap.init Vundef) # r.","proofString":"rewrite Regmap.gi.\nauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl1 vl2 : list val,\nVal.lessdef_list vl1 vl2 ->\nregs_lessdef (init_regs vl1 rl) (init_regs vl2 rl)) (r : positive) : Val.lessdef Vundef Vundef.","proofString":"auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl1 vl2 : list val,\nVal.lessdef_list vl1 vl2 ->\nregs_lessdef (init_regs vl1 rl) (init_regs vl2 rl)) (v1 v2 : val) (vl0 vl3 : list val) (H0 : Val.lessdef v1 v2) (H1 : Val.lessdef_list vl0 vl3) : regs_lessdef (init_regs vl0 rl) # a <- v1 (init_regs vl3 rl) # a <- v2.","proofString":"apply set_reg_lessdef; auto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (rs' : regset) (H : Genv.find_funct ge rs # r = Some fd) (H0 : regs_lessdef rs rs') : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct tge rs' # r = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"specialize (H0 r).\ninv H0.\napply functions_translated; auto.\nrewrite <- H2 in H; discriminate."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (rs' : regset) (H : Genv.find_funct ge rs # r = Some fd) (H0 : Val.lessdef rs # r rs' # r) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct tge rs' # r = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"inv H0.\napply functions_translated; auto.\nrewrite <- H2 in H; discriminate."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (rs' : regset) (H : Genv.find_funct ge rs # r = Some fd) (H3 : rs # r = rs' # r) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct tge rs # r = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"apply functions_translated; auto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (rs' : regset) (H : Genv.find_funct ge rs # r = Some fd) (H2 : Vundef = rs # r) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct tge rs' # r = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"rewrite <- H2 in H; discriminate."},{"statement":"(i : ident) (rs : regset) (fd : fundef) (rs' : regset) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H0 : regs_lessdef rs rs') : exists (cu : AST.program fundef unit) (tfd : fundef),\n  match Genv.find_symbol tge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge i).\napply funct_ptr_translated; auto.\ndiscriminate."},{"statement":"(i : ident) (rs : regset) (fd : fundef) (rs' : regset) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H0 : regs_lessdef rs rs') : exists (cu : AST.program fundef unit) (tfd : fundef),\n  match Genv.find_symbol ge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"destruct (Genv.find_symbol ge i).\napply funct_ptr_translated; auto.\ndiscriminate."},{"statement":"(i : ident) (rs : regset) (fd : fundef) (rs' : regset) (b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : regs_lessdef rs rs') : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct_ptr tge b = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"apply funct_ptr_translated; auto."},{"statement":"(i : ident) (rs : regset) (fd : fundef) (rs' : regset) (H : None = Some fd) (H0 : regs_lessdef rs rs') : exists (cu : AST.program fundef unit) (tfd : fundef),\n  None = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"discriminate."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Inop pc')) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Inop; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Inop pc')) : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Inop pc')) : In pc' (successors_instr (Inop pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Inop pc')) : exists valu : valuation,\n  numbering_holds valu ge sp rs m\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (if is_trivial_op op\n   then Iop op args res pc'\n   else\n    let (n1, vl) := valnum_regs approx # pc args in\n    match find_rhs n1 (Op op vl) with\n    | Some r => Iop Omove (r :: nil) res pc'\n    | None =>\n        let (op', args') := reduce operation combine_op n1 op args vl in\n        Iop op' args' res pc'\n    end)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (is_trivial_op op) eqn:TRIV.\nexploit eval_operation_lessdef.\neapply regs_lessdef_regs; eauto.\neauto.\neauto.\nintros [v' [A B]].\nleft; econstructor; split.\neapply exec_Iop with (v := v'); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct SAT as [valu NH].\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\ndestruct (valnum_regs approx!!pc args) as [n1 vl] eqn:?.\ndestruct SAT as [valu1 NH1].\nexploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (find_rhs n1 (Op op vl)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce operation combine_op n1 op args vl) as [op' args'] eqn:?.\nexploit (reduce_lessdef_sound operation combine_op ge sp rs m (fun op vl => eval_operation ge sp op vl m)); intros;eauto.\nexploit combine_op_sound; eauto.\ndestruct H1 as (v' & EV' & LD').\nexploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit eval_operation_lessdef.\neapply regs_lessdef_regs; eauto.\neauto.\neauto.\nintros [v' [A B]].\nleft; econstructor; split.\neapply exec_Iop with (v := v'); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct SAT as [valu NH].\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Iop with (v := v'); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct SAT as [valu NH].\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : eval_operation tge sp op rs' ## args m' = Some v'.","proofString":"rewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : eval_operation tge sp op rs' ## args m' =\neval_operation ge sp op rs' ## args m'.","proofString":"apply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : exists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct SAT as [valu NH].\neapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : In pc' (successors_instr (Iop op args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : exists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H.\ndestruct SAT as [valu NH].\neapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : exists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m (add_op approx # pc res op args).","proofString":"destruct SAT as [valu NH].\neapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v m\n    (add_op approx # pc res op args).","proofString":"eapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = true) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op args res pc')) (v' : val) (A : eval_operation ge sp op rs' ## args m' = Some v') (B : Val.lessdef v v') : regs_lessdef rs # res <- v rs' # res <- v'.","proofString":"apply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, vl) := valnum_regs approx # pc args in\n   match find_rhs n1 (Op op vl) with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None =>\n       let (op', args') := reduce operation combine_op n1 op args vl in\n       Iop op' args' res pc'\n   end)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (valnum_regs approx!!pc args) as [n1 vl] eqn:?.\ndestruct SAT as [valu1 NH1].\nexploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (find_rhs n1 (Op op vl)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce operation combine_op n1 op args vl) as [op' args'] eqn:?.\nexploit (reduce_lessdef_sound operation combine_op ge sp rs m (fun op vl => eval_operation ge sp op vl m)); intros;eauto.\nexploit combine_op_sound; eauto.\ndestruct H1 as (v' & EV' & LD').\nexploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Op op vl) with\n  | Some r => Iop Omove (r :: nil) res pc'\n  | None =>\n      let (op', args') := reduce operation combine_op n1 op args vl in\n      Iop op' args' res pc'\n  end) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct SAT as [valu1 NH1].\nexploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (find_rhs n1 (Op op vl)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce operation combine_op n1 op args vl) as [op' args'] eqn:?.\nexploit (reduce_lessdef_sound operation combine_op ge sp rs m (fun op vl => eval_operation ge sp op vl m)); intros;eauto.\nexploit combine_op_sound; eauto.\ndestruct H1 as (v' & EV' & LD').\nexploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Op op vl) with\n  | Some r => Iop Omove (r :: nil) res pc'\n  | None =>\n      let (op', args') := reduce operation combine_op n1 op args vl in\n      Iop op' args' res pc'\n  end) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (find_rhs n1 (Op op vl)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce operation combine_op n1 op args vl) as [op' args'] eqn:?.\nexploit (reduce_lessdef_sound operation combine_op ge sp rs m (fun op vl => eval_operation ge sp op vl m)); intros;eauto.\nexploit combine_op_sound; eauto.\ndestruct H1 as (v' & EV' & LD').\nexploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Op op vl) with\n  | Some r => Iop Omove (r :: nil) res pc'\n  | None =>\n      let (op', args') := reduce operation combine_op n1 op args vl in\n      Iop op' args' res pc'\n  end) : (exists valu2 : valuation,\n   numbering_holds valu2 ge sp rs m n1 /\\\n   rs ## args = map valu2 vl /\\\n   valu_agree valu1 valu2 (num_next approx # pc) /\\\n   (forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) /\\\n   Ple (num_next approx # pc) (num_next n1)) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (find_rhs n1 (Op op vl)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce operation combine_op n1 op args vl) as [op' args'] eqn:?.\nexploit (reduce_lessdef_sound operation combine_op ge sp rs m (fun op vl => eval_operation ge sp op vl m)); intros;eauto.\nexploit combine_op_sound; eauto.\ndestruct H1 as (v' & EV' & LD').\nexploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Op op vl) with\n  | Some r => Iop Omove (r :: nil) res pc'\n  | None =>\n      let (op', args') := reduce operation combine_op n1 op args vl in\n      Iop op' args' res pc'\n  end) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (find_rhs n1 (Op op vl)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce operation combine_op n1 op args vl) as [op' args'] eqn:?.\nexploit (reduce_lessdef_sound operation combine_op ge sp rs m (fun op vl => eval_operation ge sp op vl m)); intros;eauto.\nexploit combine_op_sound; eauto.\ndestruct H1 as (v' & EV' & LD').\nexploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists v0 : val,\n   rhs_eval_to valu2 ge sp m (Op op vl) v0 /\\ Val.lessdef v0 rs # r) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV : rhs_eval_to valu2 ge sp m (Op op vl) v') (LD : Val.lessdef v' rs # r) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV : rhs_eval_to valu2 ge sp m (Op op vl) v') (LD : Val.lessdef v' rs # r) (H1 : v' = v) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"subst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Op op vl) v) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Op op vl) v) : exists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Op op vl) v) : In pc' (successors_instr (Iop op args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Op op vl) v) : exists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H.\neapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Op op vl) v) : exists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m (add_op approx # pc res op args).","proofString":"eapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Op op vl) v) : regs_lessdef rs # res <- v rs' # res <- (rs' # r).","proofString":"apply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Op op vl) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Op op vl) v) : Val.lessdef v rs' # r.","proofString":"eapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (op', args') := reduce operation combine_op n1 op args vl in\n   Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (reduce operation combine_op n1 op args vl) as [op' args'] eqn:?.\nexploit (reduce_lessdef_sound operation combine_op ge sp rs m (fun op vl => eval_operation ge sp op vl m)); intros;eauto.\nexploit combine_op_sound; eauto.\ndestruct H1 as (v' & EV' & LD').\nexploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit (reduce_lessdef_sound operation combine_op ge sp rs m (fun op vl => eval_operation ge sp op vl m)); intros;eauto.\nexploit combine_op_sound; eauto.\ndestruct H1 as (v' & EV' & LD').\nexploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (eqs : valnum -> option rhs) (valu : valuation) (op0 : operation) (args0 : list valnum) (op'0 : operation) (args'0 : list valnum) (r : val) (H1 : forall (v0 : valnum) (rhs : rhs),\neqs v0 = Some rhs -> rhs_eval_to valu ge sp m rhs (valu v0)) (H2 : combine_op eqs op0 args0 = Some (op'0, args'0)) (H3 : eval_operation ge sp op0 (map valu args0) m = Some r) : exists r' : val,\n  eval_operation ge sp op'0 (map valu args'0) m = Some r' /\\ Val.lessdef r r'.","proofString":"exploit combine_op_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (H1 : exists r' : val,\n  eval_operation ge sp op' rs ## args' m = Some r' /\\ Val.lessdef v r') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct H1 as (v' & EV' & LD').\nexploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV' : eval_operation ge sp op' rs ## args' m = Some v') (LD' : Val.lessdef v v') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit (eval_operation_lessdef).\neapply regs_lessdef_regs; eauto.\neexact MEXT.\neexact EV'.\nintros [v'' [EV'' LD'']].\nleft; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV' : eval_operation ge sp op' rs ## args' m = Some v') (LD' : Val.lessdef v v') (v'' : val) (EV'' : eval_operation ge sp op' rs' ## args' m' = Some v'') (LD'' : Val.lessdef v' v'') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # res <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # res <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Iop.\neexact C.\nerewrite eval_operation_preserved.\neexact EV''.\nexact symbols_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto.\napply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV' : eval_operation ge sp op' rs ## args' m = Some v') (LD' : Val.lessdef v v') (v'' : val) (EV'' : eval_operation ge sp op' rs' ## args' m' = Some v'') (LD'' : Val.lessdef v' v'') : exists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV' : eval_operation ge sp op' rs ## args' m = Some v') (LD' : Val.lessdef v v') (v'' : val) (EV'' : eval_operation ge sp op' rs' ## args' m' = Some v'') (LD'' : Val.lessdef v' v'') : In pc' (successors_instr (Iop op args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV' : eval_operation ge sp op' rs ## args' m = Some v') (LD' : Val.lessdef v v') (v'' : val) (EV'' : eval_operation ge sp op' rs' ## args' m' = Some v'') (LD'' : Val.lessdef v' v'') : exists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H.\neapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV' : eval_operation ge sp op' rs ## args' m = Some v') (LD' : Val.lessdef v v') (v'' : val) (EV'' : eval_operation ge sp op' rs' ## args' m' = Some v'') (LD'' : Val.lessdef v' v'') : exists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m (add_op approx # pc res op args).","proofString":"eapply add_op_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV' : eval_operation ge sp op' rs ## args' m = Some v') (LD' : Val.lessdef v v') (v'' : val) (EV'' : eval_operation ge sp op' rs' ## args' m' = Some v'') (LD'' : Val.lessdef v' v'') : regs_lessdef rs # res <- v rs' # res <- v''.","proofString":"apply set_reg_lessdef; auto.\neapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (TRIV : is_trivial_op op = false) (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Op op vl) = None) (op' : operation) (args' : list reg) (Heqp0 : reduce operation combine_op n1 op args vl = (op', args')) (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Iop op' args' res pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV' : eval_operation ge sp op' rs ## args' m = Some v') (LD' : Val.lessdef v v') (v'' : val) (EV'' : eval_operation ge sp op' rs' ## args' m' = Some v'') (LD'' : Val.lessdef v' v'') : Val.lessdef v v''.","proofString":"eapply (Val.lessdef_trans v v' v''); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, vl) := valnum_regs approx # pc args in\n   match find_rhs n1 (Load chunk addr vl Ptop) with\n   | Some r => Iop Omove (r :: nil) dst pc'\n   | None =>\n       let (addr', args') :=\n         reduce addressing combine_addr n1 addr args vl in\n       Iload chunk addr' args' dst pc'\n   end)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (valnum_regs approx!!pc args) as [n1 vl] eqn:?.\ndestruct SAT as [valu1 NH1].\nexploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (find_rhs n1 (Load chunk addr vl Ptop)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Load chunk addr vl Ptop) with\n  | Some r => Iop Omove (r :: nil) dst pc'\n  | None =>\n      let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n      Iload chunk addr' args' dst pc'\n  end) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct SAT as [valu1 NH1].\nexploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (find_rhs n1 (Load chunk addr vl Ptop)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Load chunk addr vl Ptop) with\n  | Some r => Iop Omove (r :: nil) dst pc'\n  | None =>\n      let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n      Iload chunk addr' args' dst pc'\n  end) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (find_rhs n1 (Load chunk addr vl Ptop)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Load chunk addr vl Ptop) with\n  | Some r => Iop Omove (r :: nil) dst pc'\n  | None =>\n      let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n      Iload chunk addr' args' dst pc'\n  end) : (exists valu2 : valuation,\n   numbering_holds valu2 ge sp rs m n1 /\\\n   rs ## args = map valu2 vl /\\\n   valu_agree valu1 valu2 (num_next approx # pc) /\\\n   (forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) /\\\n   Ple (num_next approx # pc) (num_next n1)) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (find_rhs n1 (Load chunk addr vl Ptop)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Load chunk addr vl Ptop) with\n  | Some r => Iop Omove (r :: nil) dst pc'\n  | None =>\n      let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n      Iload chunk addr' args' dst pc'\n  end) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (find_rhs n1 (Load chunk addr vl Ptop)) as [r|] eqn:?.\nexploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto.\ndestruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit find_rhs_sound; eauto.\nintros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists v0 : val,\n   rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v0 /\\\n   Val.lessdef v0 rs # r) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (v' & EV & LD).\nassert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v') (LD : Val.lessdef v' rs # r) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (v' = v) by (inv EV; congruence).\nsubst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (v' : val) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v') (LD : Val.lessdef v' rs # r) (H2 : v' = v) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"subst v'.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v) : exists valu : valuation,\n  numbering_holds valu ge sp rs # dst <- v m approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v) : In pc' (successors_instr (Iload chunk addr args dst pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v) : exists valu : valuation,\n  numbering_holds valu ge sp rs # dst <- v m\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v) : exists valu : valuation,\n  numbering_holds valu ge sp rs # dst <- v m\n    (add_load approx # pc dst chunk addr args\n       (aaddressing (vanalyze (romem_for cu) f) # pc addr args)).","proofString":"destruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v) : exists valu : valuation,\n  numbering_holds valu ge sp rs # dst <- v m\n    (add_load approx # pc dst chunk addr args\n       (aaddressing (vanalyze (romem_for cu) f) # pc addr args)).","proofString":"InvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge (Vptr sp0 Ptrofs.zero) m (Load chunk addr vl Ptop) v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : exists valu : valuation,\n  numbering_holds valu ge (Vptr sp0 Ptrofs.zero) rs # dst <- v m\n    (add_load approx # pc dst chunk addr args\n       (aaddressing (vanalyze (romem_for cu) f) # pc addr args)).","proofString":"eapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge (Vptr sp0 Ptrofs.zero) m (Load chunk addr vl Ptop) v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : pmatch bc b i (aaddressing (vanalyze (romem_for cu) f) # pc addr args).","proofString":"unfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge (Vptr sp0 Ptrofs.zero) m (Load chunk addr vl Ptop) v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : pmatch bc b i\n  match (ValueAnalysis.analyze (romem_for cu) f) # pc with\n  | VA.Bot => Pbot\n  | VA.State ae0 _ =>\n      aptr_of_aval (eval_static_addressing addr (aregs ae0 args))\n  end.","proofString":"rewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge (Vptr sp0 Ptrofs.zero) m (Load chunk addr vl Ptop) v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : pmatch bc b i (aptr_of_aval (eval_static_addressing addr (aregs ae args))).","proofString":"apply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge (Vptr sp0 Ptrofs.zero) m (Load chunk addr vl Ptop) v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : vmatch bc (Vptr b i) (eval_static_addressing addr (aregs ae args)).","proofString":"eapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v) : regs_lessdef rs # dst <- v rs' # dst <- (rs' # r).","proofString":"apply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (r : reg) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (LD : Val.lessdef v rs # r) (EV : rhs_eval_to valu2 ge sp m (Load chunk addr vl Ptop) v) : Val.lessdef v rs' # r.","proofString":"eapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n   Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : eval_addressing ge sp addr' rs ## args' = Some a.","proofString":"eapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : forall (eqs : valnum -> option rhs) (valu : valuation) \n  (op : addressing) (args0 : list valnum) (op' : addressing)\n  (args'0 : list valnum),\n(forall (v0 : valnum) (rhs0 : rhs),\n eqs v0 = Some rhs0 -> rhs_eval_to valu ge sp m rhs0 (valu v0)) ->\ncombine_addr eqs op args0 = Some (op', args'0) ->\neval_addressing ge sp op' (map valu args'0) =\neval_addressing ge sp op (map valu args0).","proofString":"intros; eapply combine_addr_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') : eval_addressing tge sp addr' rs' ## args' = Some a'.","proofString":"rewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') : eval_addressing tge sp addr' rs' ## args' =\neval_addressing ge sp addr' rs' ## args'.","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit Mem.loadv_extends; eauto.\nintros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') : (exists v2 : val, Mem.loadv chunk m' a' = Some v2 /\\ Val.lessdef v v2) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros [v' [X Y]].\nleft; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs # dst <- v m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp pc' rs # dst <- v m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') : exists valu : valuation,\n  numbering_holds valu ge sp rs # dst <- v m approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') : In pc' (successors_instr (Iload chunk addr args dst pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') : exists valu : valuation,\n  numbering_holds valu ge sp rs # dst <- v m\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H.\ndestruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') : exists valu : valuation,\n  numbering_holds valu ge sp rs # dst <- v m\n    (add_load approx # pc dst chunk addr args\n       (aaddressing (vanalyze (romem_for cu) f) # pc addr args)).","proofString":"destruct a; try discriminate.\nInvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some (Vptr b i)) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef (Vptr b i) a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') : exists valu : valuation,\n  numbering_holds valu ge sp rs # dst <- v m\n    (add_load approx # pc dst chunk addr args\n       (aaddressing (vanalyze (romem_for cu) f) # pc addr args)).","proofString":"InvSoundState.\neapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs ## args' = Some (Vptr b i)) (a' : val) (A : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (B : Val.lessdef (Vptr b i) a') (ADDR' : eval_addressing tge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : exists valu : valuation,\n  numbering_holds valu ge (Vptr sp0 Ptrofs.zero) rs # dst <- v m\n    (add_load approx # pc dst chunk addr args\n       (aaddressing (vanalyze (romem_for cu) f) # pc addr args)).","proofString":"eapply add_load_holds; eauto.\nunfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs ## args' = Some (Vptr b i)) (a' : val) (A : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (B : Val.lessdef (Vptr b i) a') (ADDR' : eval_addressing tge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : pmatch bc b i (aaddressing (vanalyze (romem_for cu) f) # pc addr args).","proofString":"unfold aaddressing, vanalyze.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs ## args' = Some (Vptr b i)) (a' : val) (A : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (B : Val.lessdef (Vptr b i) a') (ADDR' : eval_addressing tge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : pmatch bc b i\n  match (ValueAnalysis.analyze (romem_for cu) f) # pc with\n  | VA.Bot => Pbot\n  | VA.State ae0 _ =>\n      aptr_of_aval (eval_static_addressing addr (aregs ae0 args))\n  end.","proofString":"rewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs ## args' = Some (Vptr b i)) (a' : val) (A : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (B : Val.lessdef (Vptr b i) a') (ADDR' : eval_addressing tge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : pmatch bc b i (aptr_of_aval (eval_static_addressing addr (aregs ae args))).","proofString":"apply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (b : block) (i : ptrofs) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs ## args' = Some (Vptr b i)) (a' : val) (A : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (B : Val.lessdef (Vptr b i) a') (ADDR' : eval_addressing tge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : vmatch bc (Vptr b i) (eval_static_addressing addr (aregs ae args)).","proofString":"eapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : find_rhs n1 (Load chunk addr vl Ptop) = None) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iload chunk addr' args' dst pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v0 : valnum, In v0 vl -> Plt v0 (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (v' : val) (X : Mem.loadv chunk m' a' = Some v') (Y : Val.lessdef v v') : regs_lessdef rs # dst <- v rs' # dst <- v'.","proofString":"apply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, vl) := valnum_regs approx # pc args in\n   let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n   Istore chunk addr' args' src pc')) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (valnum_regs approx!!pc args) as [n1 vl] eqn:?.\ndestruct SAT as [valu1 NH1].\nexploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends; eauto.\nintros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n   Istore chunk addr' args' src pc')) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct SAT as [valu1 NH1].\nexploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends; eauto.\nintros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n   Istore chunk addr' args' src pc')) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends; eauto.\nintros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n   Istore chunk addr' args' src pc')) : (exists valu2 : valuation,\n   numbering_holds valu2 ge sp rs m n1 /\\\n   rs ## args = map valu2 vl /\\\n   valu_agree valu1 valu2 (num_next approx # pc) /\\\n   (forall v : valnum, In v vl -> Plt v (num_next n1)) /\\\n   Ple (num_next approx # pc) (num_next n1)) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends; eauto.\nintros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (addr', args') := reduce addressing combine_addr n1 addr args vl in\n   Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (reduce addressing combine_addr n1 addr args vl) as [addr' args'] eqn:?.\nassert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends; eauto.\nintros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (ADDR: eval_addressing ge sp addr' rs##args' = Some a).\neapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto.\nexploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends; eauto.\nintros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : eval_addressing ge sp addr' rs ## args' = Some a.","proofString":"eapply reduce_sound with (sem := fun addr vl => eval_addressing ge sp addr vl); eauto.\nintros; eapply combine_addr_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : forall (eqs : valnum -> option rhs) (valu : valuation) \n  (op : addressing) (args0 : list valnum) (op' : addressing)\n  (args'0 : list valnum),\n(forall (v : valnum) (rhs0 : rhs),\n eqs v = Some rhs0 -> rhs_eval_to valu ge sp m rhs0 (valu v)) ->\ncombine_addr eqs op args0 = Some (op', args'0) ->\neval_addressing ge sp op' (map valu args'0) =\neval_addressing ge sp op (map valu args0).","proofString":"intros; eapply combine_addr_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit eval_addressing_lessdef.\napply regs_lessdef_regs; eauto.\neexact ADDR.\nintros [a' [A B]].\nassert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends; eauto.\nintros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (ADDR': eval_addressing tge sp addr' rs'##args' = Some a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends; eauto.\nintros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') : eval_addressing tge sp addr' rs' ## args' = Some a'.","proofString":"rewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') : eval_addressing tge sp addr' rs' ## args' =\neval_addressing ge sp addr' rs' ## args'.","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit Mem.storev_extends; eauto.\nintros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') : (exists m2' : mem,\n   Mem.storev chunk m'0 a' rs' # src = Some m2' /\\ Mem.extends m' m2') ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros [m'' [X Y]].\nleft; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (m'' : mem) (X : Mem.storev chunk m'0 a' rs' # src = Some m'') (Y : Mem.extends m' m'') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' rs m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' rs m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (m'' : mem) (X : Mem.storev chunk m'0 a' rs' # src = Some m'') (Y : Mem.extends m' m'') : exists valu : valuation, numbering_holds valu ge sp rs m' approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (m'' : mem) (X : Mem.storev chunk m'0 a' rs' # src = Some m'') (Y : Mem.extends m' m'') : In pc' (successors_instr (Istore chunk addr args src pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (m'' : mem) (X : Mem.storev chunk m'0 a' rs' # src = Some m'') (Y : Mem.extends m' m'') : exists valu : valuation,\n  numbering_holds valu ge sp rs m'\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H.\nInvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge sp addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge sp addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge sp addr' rs' ## args' = Some a') (m'' : mem) (X : Mem.storev chunk m'0 a' rs' # src = Some m'') (Y : Mem.extends m' m'') : exists valu : valuation,\n  numbering_holds valu ge sp rs m'\n    (add_store_result (vanalyze (romem_for cu) f) # pc\n       (kill_loads_after_store (vanalyze (romem_for cu) f) # pc \n          approx # pc chunk addr args) chunk addr args src).","proofString":"InvSoundState.\neapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu1 : valuation) (NH1 : numbering_holds valu1 ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (addr' : addressing) (args' : list reg) (Heqp0 : reduce addressing combine_addr n1 addr args vl = (addr', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Istore chunk addr' args' src pc')) (valu2 : valuation) (NH2 : numbering_holds valu2 ge (Vptr sp0 Ptrofs.zero) rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (ADDR : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs ## args' = Some a) (a' : val) (A : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (B : Val.lessdef a a') (ADDR' : eval_addressing tge (Vptr sp0 Ptrofs.zero) addr' rs' ## args' = Some a') (m'' : mem) (X : Mem.storev chunk m'0 a' rs' # src = Some m'') (Y : Mem.extends m' m'') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : exists valu : valuation,\n  numbering_holds valu ge (Vptr sp0 Ptrofs.zero) rs m'\n    (add_store_result (vanalyze (romem_for cu) f) # pc\n       (kill_loads_after_store (vanalyze (romem_for cu) f) # pc \n          approx # pc chunk addr args) chunk addr args src).","proofString":"eapply add_store_result_hold; eauto.\neapply kill_loads_after_store_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match is_known_runtime_function (prog_defmap cu) ros with\n  | Some bf =>\n      let (n1, args') :=\n        valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n      match find_rhs n1 (Builtin bf args') with\n      | Some r => Iop Omove (r :: nil) res pc'\n      | None => Icall (funsig fd) ros args res pc'\n      end\n  | None => Icall (funsig fd) ros args res pc'\n  end) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit find_function_translated; eauto.\nintros (cu' & tf & FIND' & TRANSF' & LINK').\ndestruct SAT as [valu NH].\ndestruct (is_known_runtime_function (prog_defmap cu) ros) as [bf|] eqn:IK.\nexploit is_known_runtime_function_sound; eauto.\nintros (name & sg & E1 & E2).\nsubst fd.\nsimpl in TRANSF'.\ninv TRANSF'.\nassert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence.\nleft; econstructor; split.\neapply exec_Icall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\neapply match_stackframes_cons with (cu := cu); eauto.\nintros.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\nexists (fun _ => Vundef); apply empty_numbering_holds.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match is_known_runtime_function (prog_defmap cu) ros with\n  | Some bf =>\n      let (n1, args') :=\n        valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n      match find_rhs n1 (Builtin bf args') with\n      | Some r => Iop Omove (r :: nil) res pc'\n      | None => Icall (funsig fd) ros args res pc'\n      end\n  | None => Icall (funsig fd) ros args res pc'\n  end) : (exists (cu0 : AST.program fundef unit) (tfd : fundef),\n   find_function tge ros rs' = Some tfd /\\\n   transf_fundef (prog_defmap cu0) (romem_for cu0) fd = OK tfd /\\\n   linkorder cu0 prog) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (cu' & tf & FIND' & TRANSF' & LINK').\ndestruct SAT as [valu NH].\ndestruct (is_known_runtime_function (prog_defmap cu) ros) as [bf|] eqn:IK.\nexploit is_known_runtime_function_sound; eauto.\nintros (name & sg & E1 & E2).\nsubst fd.\nsimpl in TRANSF'.\ninv TRANSF'.\nassert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence.\nleft; econstructor; split.\neapply exec_Icall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\neapply match_stackframes_cons with (cu := cu); eauto.\nintros.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\nexists (fun _ => Vundef); apply empty_numbering_holds.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match is_known_runtime_function (prog_defmap cu) ros with\n  | Some bf =>\n      let (n1, args') :=\n        valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n      match find_rhs n1 (Builtin bf args') with\n      | Some r => Iop Omove (r :: nil) res pc'\n      | None => Icall (funsig fd) ros args res pc'\n      end\n  | None => Icall (funsig fd) ros args res pc'\n  end) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct SAT as [valu NH].\ndestruct (is_known_runtime_function (prog_defmap cu) ros) as [bf|] eqn:IK.\nexploit is_known_runtime_function_sound; eauto.\nintros (name & sg & E1 & E2).\nsubst fd.\nsimpl in TRANSF'.\ninv TRANSF'.\nassert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence.\nleft; econstructor; split.\neapply exec_Icall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\neapply match_stackframes_cons with (cu := cu); eauto.\nintros.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\nexists (fun _ => Vundef); apply empty_numbering_holds.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match is_known_runtime_function (prog_defmap cu) ros with\n  | Some bf =>\n      let (n1, args') :=\n        valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n      match find_rhs n1 (Builtin bf args') with\n      | Some r => Iop Omove (r :: nil) res pc'\n      | None => Icall (funsig fd) ros args res pc'\n      end\n  | None => Icall (funsig fd) ros args res pc'\n  end) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (is_known_runtime_function (prog_defmap cu) ros) as [bf|] eqn:IK.\nexploit is_known_runtime_function_sound; eauto.\nintros (name & sg & E1 & E2).\nsubst fd.\nsimpl in TRANSF'.\ninv TRANSF'.\nassert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence.\nleft; econstructor; split.\neapply exec_Icall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\neapply match_stackframes_cons with (cu := cu); eauto.\nintros.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\nexists (fun _ => Vundef); apply empty_numbering_holds.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig fd) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit is_known_runtime_function_sound; eauto.\nintros (name & sg & E1 & E2).\nsubst fd.\nsimpl in TRANSF'.\ninv TRANSF'.\nassert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig fd) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : (exists (name : string) (sg : signature),\n   fd = External (EF_runtime name sg) /\\\n   lookup_builtin_function name sg = Some bf) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (name & sg & E1 & E2).\nsubst fd.\nsimpl in TRANSF'.\ninv TRANSF'.\nassert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig fd) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) (name : string) (sg : signature) (E1 : fd = External (EF_runtime name sg)) (E2 : lookup_builtin_function name sg = Some bf) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"subst fd.\nsimpl in TRANSF'.\ninv TRANSF'.\nassert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu')\n  (External (EF_runtime name sg)) = OK tf) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"simpl in TRANSF'.\ninv TRANSF'.\nassert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : OK (External (EF_runtime name sg)) = OK tf) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"inv TRANSF'.\nassert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (EV: forall (P: state -> Prop),    (forall v, builtin_function_sem bf rs##args = Some v ->               P (State s f sp pc' (rs#res <- v) m)) ->    eventually 2%nat      (Callstate (Stackframe res f sp pc' rs :: s) (External (EF_runtime name sg)) rs##args m) P).\nintros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) : forall P : state -> Prop,\n(forall v : val,\n builtin_function_sem bf rs ## args = Some v ->\n P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P.","proofString":"intros P PSPEC.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m)) : eventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P.","proofString":"apply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m)) : forall r : int,\n~\nfinal_state\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) r.","proofString":"intros rr F; inv F."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m)) : forall (t : trace) (s'0 : state),\nstep ge\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) t s'0 ->\nt = E0 /\\ Smallstep.eventually step final_state ge 1 s'0 P.","proofString":"intros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m)) (t : trace) (s1 : state) (S1 : step ge\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) t s1) : t = E0 /\\ Smallstep.eventually step final_state ge 1 s1 P.","proofString":"inv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m)) (t : trace) (res0 : val) (m'0 : mem) (H7 : external_call (EF_runtime name sg) ge rs ## args m t res0 m'0) : t = E0 /\\\nSmallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0) P.","proofString":"hnf in H7.\nrewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m)) (t : trace) (res0 : val) (m'0 : mem) (H7 : match lookup_builtin_function name sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem name sg\nend ge rs ## args m t res0 m'0) : t = E0 /\\\nSmallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0) P.","proofString":"rewrite E2 in H7.\ninv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m)) (t : trace) (res0 : val) (m'0 : mem) (H7 : known_builtin_sem bf ge rs ## args m t res0 m'0) : t = E0 /\\\nSmallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0) P.","proofString":"inv H7.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (m'0 : mem) (SOUND : sound_state prog (State s f sp pc rs m'0)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m'0 approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m'0 m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m'0)) (res0 : val) (H1 : builtin_function_sem bf rs ## args = Some res0) : E0 = E0 /\\\nSmallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0) P.","proofString":"split; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (m'0 : mem) (SOUND : sound_state prog (State s f sp pc rs m'0)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m'0 approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m'0 m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m'0)) (res0 : val) (H1 : builtin_function_sem bf rs ## args = Some res0) : Smallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0) P.","proofString":"apply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (m'0 : mem) (SOUND : sound_state prog (State s f sp pc rs m'0)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m'0 approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m'0 m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m'0)) (res0 : val) (H1 : builtin_function_sem bf rs ## args = Some res0) : forall r : int,\n~ final_state (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0) r.","proofString":"intros rr F; inv F."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (m'0 : mem) (SOUND : sound_state prog (State s f sp pc rs m'0)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m'0 approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m'0 m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m'0)) (res0 : val) (H1 : builtin_function_sem bf rs ## args = Some res0) : forall (t : trace) (s'0 : state),\nstep ge (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0) t s'0 ->\nt = E0 /\\ Smallstep.eventually step final_state ge 0 s'0 P.","proofString":"intros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (m'0 : mem) (SOUND : sound_state prog (State s f sp pc rs m'0)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m'0 approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m'0 m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m'0)) (res0 : val) (H1 : builtin_function_sem bf rs ## args = Some res0) (t : trace) (s2 : state) (S2 : step ge (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0) t s2) : t = E0 /\\ Smallstep.eventually step final_state ge 0 s2 P.","proofString":"inv S2.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (m'0 : mem) (SOUND : sound_state prog (State s f sp pc rs m'0)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m'0 approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m'0 m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m'0)) (res0 : val) (H1 : builtin_function_sem bf rs ## args = Some res0) : E0 = E0 /\\\nSmallstep.eventually step final_state ge 0\n  (State s f sp pc' rs # res <- res0 m'0) P.","proofString":"split; auto.\napply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (m'0 : mem) (SOUND : sound_state prog (State s f sp pc rs m'0)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m'0 approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m'0 m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m'0)) (res0 : val) (H1 : builtin_function_sem bf rs ## args = Some res0) : Smallstep.eventually step final_state ge 0\n  (State s f sp pc' rs # res <- res0 m'0) P.","proofString":"apply eventually_now.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (m'0 : mem) (SOUND : sound_state prog (State s f sp pc rs m'0)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m'0 approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m'0 m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (PSPEC : forall v : val,\nbuiltin_function_sem bf rs ## args = Some v ->\nP (State s f sp pc' rs # res <- v m'0)) (res0 : val) (H1 : builtin_function_sem bf rs ## args = Some res0) : P (State s f sp pc' rs # res <- res0 m'0).","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') :=\n     valnum_builtin_args approx # pc (map (BA (A:=reg)) args) in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) res pc'\n   | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n   end)) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v : val,\n builtin_function_sem bf rs ## args = Some v ->\n P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (valnum_builtin_args approx#pc (map (BA (A:=reg)) args)) as [n1 args'] eqn: VA.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Builtin bf args') with\n  | Some r => Iop Omove (r :: nil) res pc'\n  | None => Icall (funsig (External (EF_runtime name sg))) ros args res pc'\n  end) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v : val,\n builtin_function_sem bf rs ## args = Some v ->\n P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FRH.\nexploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v : val,\n builtin_function_sem bf rs ## args = Some v ->\n P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit valnum_builtin_args_holds.\neapply eval_builtin_args_trivial with (rl := args).\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v : val,\n builtin_function_sem bf rs ## args = Some v ->\n P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v : val,\n builtin_function_sem bf rs ## args = Some v ->\n P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) : (exists v : val,\n   rhs_eval_to valu1 ge sp m (Builtin bf args') v /\\ Val.lessdef v rs # r) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (v & D & E).\ninv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v0 : val,\n builtin_function_sem bf rs ## args = Some v0 ->\n P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (D : rhs_eval_to valu1 ge sp m (Builtin bf args') v) (E : Val.lessdef v rs # r) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"inv D.\nassert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v0 : val,\n builtin_function_sem bf rs ## args = Some v0 ->\n P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (vargs : list val) (H3 : eval_builtin_args ge valu1 sp m args' vargs) (H5 : builtin_function_sem bf vargs = Some v) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (vargs = rs##args) by eauto using eval_builtin_args_determ.\nsubst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v0 : val,\n builtin_function_sem bf rs ## args = Some v0 ->\n P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (vargs : list val) (H3 : eval_builtin_args ge valu1 sp m args' vargs) (H5 : builtin_function_sem bf vargs = Some v) (H1 : vargs = rs ## args) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"subst vargs.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v0 : val,\n builtin_function_sem bf rs ## args = Some v0 ->\n P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"right; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Iop; eauto.\nsimpl; eauto.\napply EV.\nintros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v0 : val,\n builtin_function_sem bf rs ## args = Some v0 ->\n P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) : forall v0 : val,\nbuiltin_function_sem bf rs ## args = Some v0 ->\nmatch_states (State s f sp pc' rs # res <- v0 m)\n  (State s' (transf_function' f cu approx) sp pc' rs' # res <- (rs' # r) m').","proofString":"intros.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v1 : val,\n builtin_function_sem bf rs ## args = Some v1 ->\n P (State s f sp pc' rs # res <- v1 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) (v0 : val) (H1 : builtin_function_sem bf rs ## args = Some v0) : match_states (State s f sp pc' rs # res <- v0 m)\n  (State s' (transf_function' f cu approx) sp pc' rs' # res <- (rs' # r) m').","proofString":"econstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\nreplace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v1 : val,\n builtin_function_sem bf rs ## args = Some v1 ->\n P (State s f sp pc' rs # res <- v1 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) (v0 : val) (H1 : builtin_function_sem bf rs ## args = Some v0) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v0 m approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v1 : val,\n builtin_function_sem bf rs ## args = Some v1 ->\n P (State s f sp pc' rs # res <- v1 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) (v0 : val) (H1 : builtin_function_sem bf rs ## args = Some v0) : In pc'\n  (successors_instr\n     (Icall (funsig (External (EF_runtime name sg))) ros args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v1 : val,\n builtin_function_sem bf rs ## args = Some v1 ->\n P (State s f sp pc' rs # res <- v1 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) (v0 : val) (H1 : builtin_function_sem bf rs ## args = Some v0) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v0 m\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v1 : val,\n builtin_function_sem bf rs ## args = Some v1 ->\n P (State s f sp pc' rs # res <- v1 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) (v0 : val) (H1 : builtin_function_sem bf rs ## args = Some v0) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v0 m\n    (add_builtin (kill_cheap_computations approx # pc) \n       (BR res) bf (map (BA (A:=reg)) args)).","proofString":"eapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v1 : val,\n builtin_function_sem bf rs ## args = Some v1 ->\n P (State s f sp pc' rs # res <- v1 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) (v0 : val) (H1 : builtin_function_sem bf rs ## args = Some v0) : regs_lessdef rs # res <- v0 rs' # res <- (rs' # r).","proofString":"replace v0 with v by congruence.\napply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v1 : val,\n builtin_function_sem bf rs ## args = Some v1 ->\n P (State s f sp pc' rs # res <- v1 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) (v0 : val) (H1 : builtin_function_sem bf rs ## args = Some v0) : regs_lessdef rs # res <- v rs' # res <- (rs' # r).","proofString":"apply set_reg_lessdef; auto.\napply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (r : reg) (FRH : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v1 : val,\n builtin_function_sem bf rs ## args = Some v1 ->\n P (State s f sp pc' rs # res <- v1 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m n1) (Y : eval_builtin_args ge valu1 sp m args' rs ## args) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H5 : builtin_function_sem bf rs ## args = Some v) (H3 : eval_builtin_args ge valu1 sp m args' rs ## args) (v0 : val) (H1 : builtin_function_sem bf rs ## args = Some v0) : Val.lessdef v rs' # r.","proofString":"apply Val.lessdef_trans with (rs#r); auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall v : val,\n builtin_function_sem bf rs ## args = Some v ->\n P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (builtin_function_sem bf rs##args) as [vres|] eqn:SEM.\nexploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto.\nright.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (vres : val) (SEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall v : val, Some vres = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit builtin_function_sem_lessdef; eauto using regs_lessdef_regs.\nintros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (vres : val) (SEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall v : val, Some vres = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists vres' : val,\n   builtin_function_sem bf rs' ## args = Some vres' /\\ Val.lessdef vres vres') ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (vres' & SEM' & LDRES).\nright.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (vres : val) (SEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall v : val, Some vres = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef vres vres') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"right.\neconstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (vres : val) (SEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall v : val, Some vres = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef vres vres') : exists (s2' : state) (n : nat),\n  plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n  eventually n\n    (Callstate (Stackframe res f sp pc' rs :: s)\n       (External (EF_runtime name sg)) rs ## args m)\n    (fun s3 : state => match_states s3 s2').","proofString":"econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\neapply exec_function_external.\nhnf.\nrewrite E2.\neconstructor; eauto.\neapply exec_return.\ntraceEq.\napply EV.\nintros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (vres : val) (SEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall v : val, Some vres = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef vres vres') : forall v : val,\nSome vres = Some v ->\nmatch_states (State s f sp pc' rs # res <- v m)\n  (State s' (transf_function' f cu approx) sp pc' rs' # res <- vres' m').","proofString":"intros.\ninv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (vres : val) (SEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall v0 : val,\n Some vres = Some v0 -> P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef vres vres') (v : val) (H1 : Some vres = Some v) : match_states (State s f sp pc' rs # res <- v m)\n  (State s' (transf_function' f cu approx) sp pc' rs' # res <- vres' m').","proofString":"inv H1.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (v : val) (EV : forall P : state -> Prop,\n(forall v0 : val, Some v = Some v0 -> P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (SEM : builtin_function_sem bf rs ## args = Some v) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef v vres') : match_states (State s f sp pc' rs # res <- v m)\n  (State s' (transf_function' f cu approx) sp pc' rs' # res <- vres' m').","proofString":"econstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial.\napply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (v : val) (EV : forall P : state -> Prop,\n(forall v0 : val, Some v = Some v0 -> P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (SEM : builtin_function_sem bf rs ## args = Some v) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef v vres') : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v m approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (v : val) (EV : forall P : state -> Prop,\n(forall v0 : val, Some v = Some v0 -> P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (SEM : builtin_function_sem bf rs ## args = Some v) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef v vres') : In pc'\n  (successors_instr\n     (Icall (funsig (External (EF_runtime name sg))) ros args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (v : val) (EV : forall P : state -> Prop,\n(forall v0 : val, Some v = Some v0 -> P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (SEM : builtin_function_sem bf rs ## args = Some v) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef v vres') : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v m\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H, IK.\neapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (v : val) (EV : forall P : state -> Prop,\n(forall v0 : val, Some v = Some v0 -> P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (SEM : builtin_function_sem bf rs ## args = Some v) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef v vres') : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v m\n    (add_builtin (kill_cheap_computations approx # pc) \n       (BR res) bf (map (BA (A:=reg)) args)).","proofString":"eapply add_builtin_holds with (res := BR res); eauto using kill_cheap_computations_hold, eval_builtin_args_trivial."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (v : val) (EV : forall P : state -> Prop,\n(forall v0 : val, Some v = Some v0 -> P (State s f sp pc' rs # res <- v0 m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (SEM : builtin_function_sem bf rs ## args = Some v) (vres' : val) (SEM' : builtin_function_sem bf rs' ## args = Some vres') (LDRES : Val.lessdef v vres') : regs_lessdef rs # res <- v rs' # res <- vres'.","proofString":"apply set_reg_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (SEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall v : val, None = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n\n     (Callstate (Stackframe res f sp pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"right.\neconstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (SEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall v : val, None = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : exists (s2' : state) (n : nat),\n  plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n  eventually n\n    (Callstate (Stackframe res f sp pc' rs :: s)\n       (External (EF_runtime name sg)) rs ## args m)\n    (fun s3 : state => match_states s3 s2').","proofString":"econstructor; exists 1%nat; split.\neapply plus_one.\neapply exec_Icall; eauto.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (SEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall v : val, None = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : forall r : int,\n~\nfinal_state\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) r.","proofString":"intros rr F; inv F."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (SEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall v : val, None = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : forall (t : trace) (s'0 : state),\nstep ge\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) t s'0 ->\nt = E0 /\\\nSmallstep.eventually step final_state ge 0 s'0\n  (fun s3 : state =>\n   match_states s3\n     (Callstate\n        (Stackframe res (transf_function' f cu approx) sp pc' rs' :: s')\n        (External (EF_runtime name sg)) rs' ## args m')).","proofString":"intros t s1 S1.\ninv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (SEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall v : val, None = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (t : trace) (s1 : state) (S1 : step ge\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) t s1) : t = E0 /\\\nSmallstep.eventually step final_state ge 0 s1\n  (fun s3 : state =>\n   match_states s3\n     (Callstate\n        (Stackframe res (transf_function' f cu approx) sp pc' rs' :: s')\n        (External (EF_runtime name sg)) rs' ## args m')).","proofString":"inv S1.\nhnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (SEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall v : val, None = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (t : trace) (res0 : val) (m'0 : mem) (H7 : external_call (EF_runtime name sg) ge rs ## args m t res0 m'0) : t = E0 /\\\nSmallstep.eventually step final_state ge 0\n  (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0)\n  (fun s3 : state =>\n   match_states s3\n     (Callstate\n        (Stackframe res (transf_function' f cu approx) sp pc' rs' :: s')\n        (External (EF_runtime name sg)) rs' ## args m')).","proofString":"hnf in H7.\nrewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (SEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall v : val, None = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (t : trace) (res0 : val) (m'0 : mem) (H7 : match lookup_builtin_function name sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem name sg\nend ge rs ## args m t res0 m'0) : t = E0 /\\\nSmallstep.eventually step final_state ge 0\n  (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0)\n  (fun s3 : state =>\n   match_states s3\n     (Callstate\n        (Stackframe res (transf_function' f cu approx) sp pc' rs' :: s')\n        (External (EF_runtime name sg)) rs' ## args m')).","proofString":"rewrite E2 in H7.\ninv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (SEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall v : val, None = Some v -> P (State s f sp pc' rs # res <- v m)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (t : trace) (res0 : val) (m'0 : mem) (H7 : known_builtin_sem bf ge rs ## args m t res0 m'0) : t = E0 /\\\nSmallstep.eventually step final_state ge 0\n  (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0)\n  (fun s3 : state =>\n   match_states s3\n     (Callstate\n        (Stackframe res (transf_function' f cu approx) sp pc' rs' :: s')\n        (External (EF_runtime name sg)) rs' ## args m')).","proofString":"inv H7.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (m'0 : mem) (SOUND : sound_state prog (State s f sp pc rs m'0)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m'0 approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m'0 m') (STACKS : match_stackframes s s') (bf : builtin_function) (IK : is_known_runtime_function (prog_defmap cu) ros = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VA : valnum_builtin_args approx # pc (map (BA (A:=reg)) args) = (n1, args')) (FRH : find_rhs n1 (Builtin bf args') = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (cu' : AST.program fundef unit) (FIND' : find_function tge ros rs' = Some (External (EF_runtime name sg))) (LINK' : linkorder cu' prog) (E2 : lookup_builtin_function name sg = Some bf) (SEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall v : val, None = Some v -> P (State s f sp pc' rs # res <- v m'0)) ->\neventually 2\n  (Callstate (Stackframe res f sp pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m'0) P) (res0 : val) (H1 : builtin_function_sem bf rs ## args = Some res0) : E0 = E0 /\\\nSmallstep.eventually step final_state ge 0\n  (Returnstate (Stackframe res f sp pc' rs :: s) res0 m'0)\n  (fun s3 : state =>\n   match_states s3\n     (Callstate\n        (Stackframe res (transf_function' f cu approx) sp pc' rs' :: s')\n        (External (EF_runtime name sg)) rs' ## args m')).","proofString":"congruence."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (IK : is_known_runtime_function (prog_defmap cu) ros = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Icall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\neapply match_stackframes_cons with (cu := cu); eauto.\nintros.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\nexists (fun _ => Vundef); apply empty_numbering_holds.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (IK : is_known_runtime_function (prog_defmap cu) ros = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : funsig tf = funsig fd.","proofString":"eapply sig_preserved; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (IK : is_known_runtime_function (prog_defmap cu) ros = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : match_stackframes (Stackframe res f sp pc' rs :: s)\n  (Stackframe res (transf_function' f cu approx) sp pc' rs' :: s').","proofString":"eapply match_stackframes_cons with (cu := cu); eauto.\nintros.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\nexists (fun _ => Vundef); apply empty_numbering_holds."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (IK : is_known_runtime_function (prog_defmap cu) ros = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : forall (v : val) (m0 : mem),\nexists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v m0 approx # pc'.","proofString":"intros.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\nexists (fun _ => Vundef); apply empty_numbering_holds."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (IK : is_known_runtime_function (prog_defmap cu) ros = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) (v : val) (m0 : mem) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v m0 approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, IK.\nexists (fun _ => Vundef); apply empty_numbering_holds."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (IK : is_known_runtime_function (prog_defmap cu) ros = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) (v : val) (m0 : mem) : In pc' (successors_instr (Icall (funsig fd) ros args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (IK : is_known_runtime_function (prog_defmap cu) ros = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) (v : val) (m0 : mem) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v m0\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H, IK.\nexists (fun _ => Vundef); apply empty_numbering_holds."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (IK : is_known_runtime_function (prog_defmap cu) ros = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) (v : val) (m0 : mem) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp rs # res <- v m0 empty_numbering.","proofString":"exists (fun _ => Vundef); apply empty_numbering_holds."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (IK : is_known_runtime_function (prog_defmap cu) ros = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : Val.lessdef_list rs ## args rs' ## args.","proofString":"apply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Itailcall (funsig fd) ros args)) : (exists s2' : state,\n   step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\ match_states (Callstate s fd rs ## args m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   eventually n (Callstate s fd rs ## args m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit find_function_translated; eauto.\nintros (cu' & tf & FIND' & TRANSF' & LINK').\nexploit Mem.free_parallel_extends; eauto.\nintros [m'' [A B]].\nleft; econstructor; split.\neapply exec_Itailcall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Itailcall (funsig fd) ros args)) : (exists (cu0 : AST.program fundef unit) (tfd : fundef),\n   find_function tge ros rs' = Some tfd /\\\n   transf_fundef (prog_defmap cu0) (romem_for cu0) fd = OK tfd /\\\n   linkorder cu0 prog) ->\n(exists s2' : state,\n   step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\ match_states (Callstate s fd rs ## args m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   eventually n (Callstate s fd rs ## args m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (cu' & tf & FIND' & TRANSF' & LINK').\nexploit Mem.free_parallel_extends; eauto.\nintros [m'' [A B]].\nleft; econstructor; split.\neapply exec_Itailcall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : (exists s2' : state,\n   step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\ match_states (Callstate s fd rs ## args m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   eventually n (Callstate s fd rs ## args m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit Mem.free_parallel_extends; eauto.\nintros [m'' [A B]].\nleft; econstructor; split.\neapply exec_Itailcall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) : (exists m2' : mem,\n   Mem.free m'0 stk 0 (fn_stacksize f) = Some m2' /\\ Mem.extends m' m2') ->\n(exists s2' : state,\n   step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\ match_states (Callstate s fd rs ## args m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   eventually n (Callstate s fd rs ## args m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros [m'' [A B]].\nleft; econstructor; split.\neapply exec_Itailcall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) (m'' : mem) (A : Mem.free m'0 stk 0 (fn_stacksize f) = Some m'') (B : Mem.extends m' m'') : (exists s2' : state,\n   step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\ match_states (Callstate s fd rs ## args m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   eventually n (Callstate s fd rs ## args m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Itailcall; eauto.\neapply sig_preserved; eauto.\neconstructor; eauto.\napply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) (m'' : mem) (A : Mem.free m'0 stk 0 (fn_stacksize f) = Some m'') (B : Mem.extends m' m'') : funsig tf = funsig fd.","proofString":"eapply sig_preserved; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tf : fundef) (FIND' : find_function tge ros rs' = Some tf) (TRANSF' : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tf) (LINK' : linkorder cu' prog) (m'' : mem) (A : Mem.free m'0 stk 0 (fn_stacksize f) = Some m'') (B : Mem.extends m' m'') : Val.lessdef_list rs ## args rs' ## args.","proofString":"apply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres res vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres res vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit (@eval_builtin_args_lessdef _ ge (fun r => rs#r) (fun r => rs'#r)); eauto.\nintros (vargs' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (v' & m1' & P & Q & R & S).\nassert (DEFAULT:    (fn_code (transf_function' f cu approx)) ! pc = Some(Ibuiltin ef args res pc') ->    exists s2', step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2'             /\\ match_states (State s f sp pc' (regmap_setres res vres rs) m') s2').\nintros C'.\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\ndestruct SAT as [valu NH].\nInvSoundState.\neapply transfer_builtin_holds; eauto.\napply set_res_lessdef; auto.\ndestruct ef; auto.\ndestruct res; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (valnum_builtin_args approx#pc args) as (n1 & args') eqn:VB.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) : (exists vl2 : list val,\n   eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vl2 /\\\n   Val.lessdef_list vargs vl2) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres res vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres res vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (vargs' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (v' & m1' & P & Q & R & S).\nassert (DEFAULT:    (fn_code (transf_function' f cu approx)) ! pc = Some(Ibuiltin ef args res pc') ->    exists s2', step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2'             /\\ match_states (State s f sp pc' (regmap_setres res vres rs) m') s2').\nintros C'.\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\ndestruct SAT as [valu NH].\nInvSoundState.\neapply transfer_builtin_holds; eauto.\napply set_res_lessdef; auto.\ndestruct ef; auto.\ndestruct res; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (valnum_builtin_args approx#pc args) as (n1 & args') eqn:VB.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres res vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres res vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit external_call_mem_extends; eauto.\nintros (v' & m1' & P & Q & R & S).\nassert (DEFAULT:    (fn_code (transf_function' f cu approx)) ! pc = Some(Ibuiltin ef args res pc') ->    exists s2', step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2'             /\\ match_states (State s f sp pc' (regmap_setres res vres rs) m') s2').\nintros C'.\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\ndestruct SAT as [valu NH].\nInvSoundState.\neapply transfer_builtin_holds; eauto.\napply set_res_lessdef; auto.\ndestruct ef; auto.\ndestruct res; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (valnum_builtin_args approx#pc args) as (n1 & args') eqn:VB.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') : (exists (vres' : val) (m2' : mem),\n   external_call ef ge vargs' m'0 t vres' m2' /\\\n   Val.lessdef vres vres' /\\\n   Mem.extends m' m2' /\\ Mem.unchanged_on (loc_out_of_bounds m) m'0 m2') ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres res vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres res vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (v' & m1' & P & Q & R & S).\nassert (DEFAULT:    (fn_code (transf_function' f cu approx)) ! pc = Some(Ibuiltin ef args res pc') ->    exists s2', step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2'             /\\ match_states (State s f sp pc' (regmap_setres res vres rs) m') s2').\nintros C'.\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\ndestruct SAT as [valu NH].\nInvSoundState.\neapply transfer_builtin_holds; eauto.\napply set_res_lessdef; auto.\ndestruct ef; auto.\ndestruct res; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (valnum_builtin_args approx#pc args) as (n1 & args') eqn:VB.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres res vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres res vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (DEFAULT:    (fn_code (transf_function' f cu approx)) ! pc = Some(Ibuiltin ef args res pc') ->    exists s2', step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2'             /\\ match_states (State s f sp pc' (regmap_setres res vres rs) m') s2').\nintros C'.\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\ndestruct SAT as [valu NH].\nInvSoundState.\neapply transfer_builtin_holds; eauto.\napply set_res_lessdef; auto.\ndestruct ef; auto.\ndestruct res; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (valnum_builtin_args approx#pc args) as (n1 & args') eqn:VB.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres res vres rs) m') s2'.","proofString":"intros C'.\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\ndestruct SAT as [valu NH].\nInvSoundState.\neapply transfer_builtin_holds; eauto.\napply set_res_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (C' : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc')) : exists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres res vres rs) m') s2'.","proofString":"econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\ndestruct SAT as [valu NH].\nInvSoundState.\neapply transfer_builtin_holds; eauto.\napply set_res_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (C' : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc')) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (C' : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc')) : Senv.equiv ge tge.","proofString":"apply senv_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (C' : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc')) : exists valu : valuation,\n  numbering_holds valu ge sp (regmap_setres res vres rs) m' approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\ndestruct SAT as [valu NH].\nInvSoundState.\neapply transfer_builtin_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (C' : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc')) : In pc' (successors_instr (Ibuiltin ef args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (C' : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc')) : exists valu : valuation,\n  numbering_holds valu ge sp (regmap_setres res vres rs) m'\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"destruct SAT as [valu NH].\nInvSoundState.\neapply transfer_builtin_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (C' : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc')) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp (regmap_setres res vres rs) m'\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"InvSoundState.\neapply transfer_builtin_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge (Vptr sp0 Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) \n  (Vptr sp0 Ptrofs.zero) m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (C' : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : exists valu0 : valuation,\n  numbering_holds valu0 ge (Vptr sp0 Ptrofs.zero) \n    (regmap_setres res vres rs) m'\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"eapply transfer_builtin_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (C' : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc')) : regs_lessdef (regmap_setres res vres rs) (regmap_setres res v' rs').","proofString":"apply set_res_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match res with\n      | BR res0 =>\n          match lookup_builtin_function name sg with\n          | Some bf =>\n              let (n1, args') := valnum_builtin_args approx # pc args in\n              match find_rhs n1 (Builtin bf args') with\n              | Some r => Iop Omove (r :: nil) res0 pc'\n              | None => Ibuiltin ef args res pc'\n              end\n          | None => Ibuiltin ef args res pc'\n          end\n      | _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call ef ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin ef args res pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres res vres rs) m') s2') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres res vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres res vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct ef; auto.\ndestruct res; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (valnum_builtin_args approx#pc args) as (n1 & args') eqn:VB.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call (EF_builtin name sg) ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match res with\n  | BR res0 =>\n      match lookup_builtin_function name sg with\n      | Some bf =>\n          let (n1, args') := valnum_builtin_args approx # pc args in\n          match find_rhs n1 (Builtin bf args') with\n          | Some r => Iop Omove (r :: nil) res0 pc'\n          | None => Ibuiltin (EF_builtin name sg) args res pc'\n          end\n      | None => Ibuiltin (EF_builtin name sg) args res pc'\n      end\n  | _ => Ibuiltin (EF_builtin name sg) args res pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args res pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres res vres rs) m') s2') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres res vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres res vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct res; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (valnum_builtin_args approx#pc args) as (n1 & args') eqn:VB.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call (EF_builtin name sg) ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some bf =>\n      let (n1, args') := valnum_builtin_args approx # pc args in\n      match find_rhs n1 (Builtin bf args') with\n      | Some r => Iop Omove (r :: nil) x pc'\n      | None => Ibuiltin (EF_builtin name sg) args (BR x) pc'\n      end\n  | None => Ibuiltin (EF_builtin name sg) args (BR x) pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (valnum_builtin_args approx#pc args) as (n1 & args') eqn:VB.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call (EF_builtin name sg) ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (bf : builtin_function) (LK : lookup_builtin_function name sg = Some bf) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, args') := valnum_builtin_args approx # pc args in\n   match find_rhs n1 (Builtin bf args') with\n   | Some r => Iop Omove (r :: nil) x pc'\n   | None => Ibuiltin (EF_builtin name sg) args (BR x) pc'\n   end)) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (valnum_builtin_args approx#pc args) as (n1 & args') eqn:VB.\ndestruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call (EF_builtin name sg) ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (bf : builtin_function) (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match find_rhs n1 (Builtin bf args') with\n  | Some r => Iop Omove (r :: nil) x pc'\n  | None => Ibuiltin (EF_builtin name sg) args (BR x) pc'\n  end) (vargs' : list val) (A : eval_builtin_args ge (fun r : positive => rs' # r) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (find_rhs n1 (Builtin bf args')) as [r|] eqn:FIND; auto.\nhnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m args vargs) (H1 : external_call (EF_builtin name sg) ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (bf : builtin_function) (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"hnf in H1.\nrewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m args vargs) (H1 : match lookup_builtin_function name sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem name sg\nend ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (bf : builtin_function) (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"rewrite LK in H1.\ninv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m args vargs) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 t v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) t\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"inv H1.\ndestruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct SAT as [valu NH].\nexploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit valnum_builtin_args_holds.\neexact H0.\neauto.\neauto.\nintros (valu1 & X & Y & Z & U & V).\nexploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit find_rhs_sound; eauto.\nintros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) : (exists v : val,\n   rhs_eval_to valu1 ge sp m' (Builtin bf args') v /\\ Val.lessdef v rs # r) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (v & D & E).\ninv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (D : rhs_eval_to valu1 ge sp m' (Builtin bf args') v) (E : Val.lessdef v rs # r) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"inv D.\nassert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (vargs0 : list val) (H4 : eval_builtin_args ge valu1 sp m' args' vargs0) (H6 : builtin_function_sem bf vargs0 = Some v) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (vargs0 = vargs) by eauto using eval_builtin_args_determ.\nsubst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (vargs0 : list val) (H4 : eval_builtin_args ge valu1 sp m' args' vargs0) (H6 : builtin_function_sem bf vargs0 = Some v) (H1 : vargs0 = vargs) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"subst vargs0.\nassert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H6 : builtin_function_sem bf vargs = Some v) (H4 : eval_builtin_args ge valu1 sp m' args' vargs) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (v = vres) by congruence.\nsubst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (v : val) (E : Val.lessdef v rs # r) (H6 : builtin_function_sem bf vargs = Some v) (H4 : eval_builtin_args ge valu1 sp m' args' vargs) (H1 : v = vres) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"subst v.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (H6 : builtin_function_sem bf vargs = Some vres) (E : Val.lessdef vres rs # r) (H4 : eval_builtin_args ge valu1 sp m' args' vargs) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n   match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0\n     s2' /\\\n   eventually n (State s f sp pc' (regmap_setres (BR x) vres rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto.\napply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (H6 : builtin_function_sem bf vargs = Some vres) (E : Val.lessdef vres rs # r) (H4 : eval_builtin_args ge valu1 sp m' args' vargs) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp (regmap_setres (BR x) vres rs) m' approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl; auto.\nunfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (H6 : builtin_function_sem bf vargs = Some vres) (E : Val.lessdef vres rs # r) (H4 : eval_builtin_args ge valu1 sp m' args' vargs) : In pc' (successors_instr (Ibuiltin (EF_builtin name sg) args (BR x) pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (H6 : builtin_function_sem bf vargs = Some vres) (E : Val.lessdef vres rs # r) (H4 : eval_builtin_args ge valu1 sp m' args' vargs) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp (regmap_setres (BR x) vres rs) m'\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H, LK.\neapply add_builtin_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (H6 : builtin_function_sem bf vargs = Some vres) (E : Val.lessdef vres rs # r) (H4 : eval_builtin_args ge valu1 sp m' args' vargs) : exists valu0 : valuation,\n  numbering_holds valu0 ge sp (regmap_setres (BR x) vres rs) m'\n    (add_builtin approx # pc (BR x) bf args).","proofString":"eapply add_builtin_holds; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (H6 : builtin_function_sem bf vargs = Some vres) (E : Val.lessdef vres rs # r) (H4 : eval_builtin_args ge valu1 sp m' args' vargs) : regs_lessdef (regmap_setres (BR x) vres rs) rs' # x <- (rs' # r).","proofString":"apply set_reg_lessdef; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (x : reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args (BR x) pc')) (H0 : eval_builtin_args ge (fun r0 : positive => rs # r0) sp m' args vargs) (bf : builtin_function) (SOUND : sound_state prog (State s f sp pc rs m')) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (valu : valuation) (NH : numbering_holds valu ge sp rs m' approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m' m'0) (STACKS : match_stackframes s s') (LK : lookup_builtin_function name sg = Some bf) (n1 : numbering) (args' : list (builtin_arg valnum)) (VB : valnum_builtin_args approx # pc args = (n1, args')) (r : reg) (FIND : find_rhs n1 (Builtin bf args') = Some r) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Iop Omove (r :: nil) x pc')) (vargs' : list val) (A : eval_builtin_args ge (fun r0 : positive => rs' # r0) sp m'0 args vargs') (B : Val.lessdef_list vargs vargs') (v' : val) (m1' : mem) (P : external_call (EF_builtin name sg) ge vargs' m'0 E0 v' m1') (Q : Val.lessdef vres v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m') m'0 m1') (DEFAULT : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Ibuiltin (EF_builtin name sg) args (BR x) pc') ->\nexists s2' : state,\n  step tge (State s' (transf_function' f cu approx) sp pc rs' m'0) E0 s2' /\\\n  match_states (State s f sp pc' (regmap_setres (BR x) vres rs) m') s2') (H2 : builtin_function_sem bf vargs = Some vres) (valu1 : valuation) (X : numbering_holds valu1 ge sp rs m' n1) (Y : eval_builtin_args ge valu1 sp m' args' vargs) (Z : valu_agree valu valu1 (num_next approx # pc)) (U : forall vn : valnum,\nIn vn (params_of_builtin_args args') -> Plt vn (num_next n1)) (V : Ple (num_next approx # pc) (num_next n1)) (H6 : builtin_function_sem bf vargs = Some vres) (E : Val.lessdef vres rs # r) (H4 : eval_builtin_args ge valu1 sp m' args' vargs) : Val.lessdef vres rs' # r.","proofString":"eapply Val.lessdef_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (n1, vl) := valnum_regs approx # pc args in\n   match combine_cond' cond vl with\n   | Some b0 => Inop (if b0 then ifso else ifnot)\n   | None =>\n       let (cond', args') := reduce condition combine_cond n1 cond args vl in\n       Icond cond' args' ifso ifnot\n   end)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp (if b then ifso else ifnot) rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp (if b then ifso else ifnot) rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (valnum_regs approx!!pc args) as [n1 vl] eqn:?.\nelim SAT; intros valu1 NH1.\nexploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (combine_cond' cond vl) eqn:?; auto.\nleft; econstructor; split.\neapply exec_Inop; eauto.\nassert (eval_condition cond (map valu2 vl) m = Some b) by (rewrite <- EQ; auto).\nrewrite (combine_cond'_sound m valu2 cond vl b b0); eauto.\neconstructor; eauto.\ndestruct b0; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto.\ndestruct (reduce condition combine_cond n1 cond args vl) as [cond' args'] eqn:?.\nassert (RES: eval_condition cond' rs##args' m = Some b).\neapply reduce_sound with (sem := fun cond vl => eval_condition cond vl m); eauto.\nintros; eapply combine_cond_sound; eauto.\nleft; econstructor; split.\neapply exec_Icond; eauto.\neapply eval_condition_lessdef; eauto.\napply regs_lessdef_regs; auto.\neconstructor; eauto.\ndestruct b; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match combine_cond' cond vl with\n  | Some b0 => Inop (if b0 then ifso else ifnot)\n  | None =>\n      let (cond', args') := reduce condition combine_cond n1 cond args vl in\n      Icond cond' args' ifso ifnot\n  end) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp (if b then ifso else ifnot) rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp (if b then ifso else ifnot) rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"elim SAT; intros valu1 NH1.\nexploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (combine_cond' cond vl) eqn:?; auto.\nleft; econstructor; split.\neapply exec_Inop; eauto.\nassert (eval_condition cond (map valu2 vl) m = Some b) by (rewrite <- EQ; auto).\nrewrite (combine_cond'_sound m valu2 cond vl b b0); eauto.\neconstructor; eauto.\ndestruct b0; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto.\ndestruct (reduce condition combine_cond n1 cond args vl) as [cond' args'] eqn:?.\nassert (RES: eval_condition cond' rs##args' m = Some b).\neapply reduce_sound with (sem := fun cond vl => eval_condition cond vl m); eauto.\nintros; eapply combine_cond_sound; eauto.\nleft; econstructor; split.\neapply exec_Icond; eauto.\neapply eval_condition_lessdef; eauto.\napply regs_lessdef_regs; auto.\neconstructor; eauto.\ndestruct b; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match combine_cond' cond vl with\n  | Some b0 => Inop (if b0 then ifso else ifnot)\n  | None =>\n      let (cond', args') := reduce condition combine_cond n1 cond args vl in\n      Icond cond' args' ifso ifnot\n  end) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp (if b then ifso else ifnot) rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp (if b then ifso else ifnot) rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit valnum_regs_holds; eauto.\nintros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (combine_cond' cond vl) eqn:?; auto.\nleft; econstructor; split.\neapply exec_Inop; eauto.\nassert (eval_condition cond (map valu2 vl) m = Some b) by (rewrite <- EQ; auto).\nrewrite (combine_cond'_sound m valu2 cond vl b b0); eauto.\neconstructor; eauto.\ndestruct b0; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto.\ndestruct (reduce condition combine_cond n1 cond args vl) as [cond' args'] eqn:?.\nassert (RES: eval_condition cond' rs##args' m = Some b).\neapply reduce_sound with (sem := fun cond vl => eval_condition cond vl m); eauto.\nintros; eapply combine_cond_sound; eauto.\nleft; econstructor; split.\neapply exec_Icond; eauto.\neapply eval_condition_lessdef; eauto.\napply regs_lessdef_regs; auto.\neconstructor; eauto.\ndestruct b; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match combine_cond' cond vl with\n  | Some b0 => Inop (if b0 then ifso else ifnot)\n  | None =>\n      let (cond', args') := reduce condition combine_cond n1 cond args vl in\n      Icond cond' args' ifso ifnot\n  end) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) : (exists valu2 : valuation,\n   numbering_holds valu2 ge sp rs m n1 /\\\n   rs ## args = map valu2 vl /\\\n   valu_agree valu1 valu2 (num_next approx # pc) /\\\n   (forall v : valnum, In v vl -> Plt v (num_next n1)) /\\\n   Ple (num_next approx # pc) (num_next n1)) ->\n(exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp (if b then ifso else ifnot) rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp (if b then ifso else ifnot) rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (valu2 & NH2 & EQ & AG & P & Q).\ndestruct (combine_cond' cond vl) eqn:?; auto.\nleft; econstructor; split.\neapply exec_Inop; eauto.\nassert (eval_condition cond (map valu2 vl) m = Some b) by (rewrite <- EQ; auto).\nrewrite (combine_cond'_sound m valu2 cond vl b b0); eauto.\neconstructor; eauto.\ndestruct b0; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto.\ndestruct (reduce condition combine_cond n1 cond args vl) as [cond' args'] eqn:?.\nassert (RES: eval_condition cond' rs##args' m = Some b).\neapply reduce_sound with (sem := fun cond vl => eval_condition cond vl m); eauto.\nintros; eapply combine_cond_sound; eauto.\nleft; econstructor; split.\neapply exec_Icond; eauto.\neapply eval_condition_lessdef; eauto.\napply regs_lessdef_regs; auto.\neconstructor; eauto.\ndestruct b; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  match combine_cond' cond vl with\n  | Some b0 => Inop (if b0 then ifso else ifnot)\n  | None =>\n      let (cond', args') := reduce condition combine_cond n1 cond args vl in\n      Icond cond' args' ifso ifnot\n  end) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp (if b then ifso else ifnot) rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp (if b then ifso else ifnot) rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (combine_cond' cond vl) eqn:?; auto.\nleft; econstructor; split.\neapply exec_Inop; eauto.\nassert (eval_condition cond (map valu2 vl) m = Some b) by (rewrite <- EQ; auto).\nrewrite (combine_cond'_sound m valu2 cond vl b b0); eauto.\neconstructor; eauto.\ndestruct b0; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto.\ndestruct (reduce condition combine_cond n1 cond args vl) as [cond' args'] eqn:?.\nassert (RES: eval_condition cond' rs##args' m = Some b).\neapply reduce_sound with (sem := fun cond vl => eval_condition cond vl m); eauto.\nintros; eapply combine_cond_sound; eauto.\nleft; econstructor; split.\neapply exec_Icond; eauto.\neapply eval_condition_lessdef; eauto.\napply regs_lessdef_regs; auto.\neconstructor; eauto.\ndestruct b; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (b0 : bool) (Heqo : combine_cond' cond vl = Some b0) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Inop (if b0 then ifso else ifnot))) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp (if b then ifso else ifnot) rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp (if b then ifso else ifnot) rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Inop; eauto.\nassert (eval_condition cond (map valu2 vl) m = Some b) by (rewrite <- EQ; auto).\nrewrite (combine_cond'_sound m valu2 cond vl b b0); eauto.\neconstructor; eauto.\ndestruct b0; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (b0 : bool) (Heqo : combine_cond' cond vl = Some b0) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Inop (if b0 then ifso else ifnot))) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (H1 : eval_condition cond (map valu2 vl) m = Some b) : match_states (State s f sp (if b then ifso else ifnot) rs m)\n  (State s' (transf_function' f cu approx) sp (if b0 then ifso else ifnot)\n     rs' m').","proofString":"rewrite (combine_cond'_sound m valu2 cond vl b b0); eauto.\neconstructor; eauto.\ndestruct b0; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (b0 : bool) (Heqo : combine_cond' cond vl = Some b0) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Inop (if b0 then ifso else ifnot))) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (H1 : eval_condition cond (map valu2 vl) m = Some b) : match_states (State s f sp (if b0 then ifso else ifnot) rs m)\n  (State s' (transf_function' f cu approx) sp (if b0 then ifso else ifnot)\n     rs' m').","proofString":"econstructor; eauto.\ndestruct b0; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (b0 : bool) (Heqo : combine_cond' cond vl = Some b0) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Inop (if b0 then ifso else ifnot))) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (H1 : eval_condition cond (map valu2 vl) m = Some b) : exists valu : valuation,\n  numbering_holds valu ge sp rs m approx # (if b0 then ifso else ifnot).","proofString":"destruct b0; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : combine_cond' cond vl = None) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome\n  (let (cond', args') := reduce condition combine_cond n1 cond args vl in\n   Icond cond' args' ifso ifnot)) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp (if b then ifso else ifnot) rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp (if b then ifso else ifnot) rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (reduce condition combine_cond n1 cond args vl) as [cond' args'] eqn:?.\nassert (RES: eval_condition cond' rs##args' m = Some b).\neapply reduce_sound with (sem := fun cond vl => eval_condition cond vl m); eauto.\nintros; eapply combine_cond_sound; eauto.\nleft; econstructor; split.\neapply exec_Icond; eauto.\neapply eval_condition_lessdef; eauto.\napply regs_lessdef_regs; auto.\neconstructor; eauto.\ndestruct b; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : combine_cond' cond vl = None) (cond' : condition) (args' : list reg) (Heqp0 : reduce condition combine_cond n1 cond args vl = (cond', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icond cond' args' ifso ifnot)) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp (if b then ifso else ifnot) rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp (if b then ifso else ifnot) rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"assert (RES: eval_condition cond' rs##args' m = Some b).\neapply reduce_sound with (sem := fun cond vl => eval_condition cond vl m); eauto.\nintros; eapply combine_cond_sound; eauto.\nleft; econstructor; split.\neapply exec_Icond; eauto.\neapply eval_condition_lessdef; eauto.\napply regs_lessdef_regs; auto.\neconstructor; eauto.\ndestruct b; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : combine_cond' cond vl = None) (cond' : condition) (args' : list reg) (Heqp0 : reduce condition combine_cond n1 cond args vl = (cond', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icond cond' args' ifso ifnot)) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : eval_condition cond' rs ## args' m = Some b.","proofString":"eapply reduce_sound with (sem := fun cond vl => eval_condition cond vl m); eauto.\nintros; eapply combine_cond_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : combine_cond' cond vl = None) (cond' : condition) (args' : list reg) (Heqp0 : reduce condition combine_cond n1 cond args vl = (cond', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icond cond' args' ifso ifnot)) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) : forall (eqs : valnum -> option rhs) (valu : valuation) \n  (op : condition) (args0 : list valnum) (op' : condition)\n  (args'0 : list valnum),\n(forall (v : valnum) (rhs0 : rhs),\n eqs v = Some rhs0 -> rhs_eval_to valu ge sp m rhs0 (valu v)) ->\ncombine_cond eqs op args0 = Some (op', args'0) ->\neval_condition op' (map valu args'0) m = eval_condition op (map valu args0) m.","proofString":"intros; eapply combine_cond_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : combine_cond' cond vl = None) (cond' : condition) (args' : list reg) (Heqp0 : reduce condition combine_cond n1 cond args vl = (cond', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icond cond' args' ifso ifnot)) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (RES : eval_condition cond' rs ## args' m = Some b) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp (if b then ifso else ifnot) rs m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n (State s f sp (if b then ifso else ifnot) rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Icond; eauto.\neapply eval_condition_lessdef; eauto.\napply regs_lessdef_regs; auto.\neconstructor; eauto.\ndestruct b; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : combine_cond' cond vl = None) (cond' : condition) (args' : list reg) (Heqp0 : reduce condition combine_cond n1 cond args vl = (cond', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icond cond' args' ifso ifnot)) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (RES : eval_condition cond' rs ## args' m = Some b) : Val.lessdef_list rs ## args' rs' ## args'.","proofString":"apply regs_lessdef_regs; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (n1 : numbering) (vl : list valnum) (Heqp : valnum_regs approx # pc args = (n1, vl)) (Heqo : combine_cond' cond vl = None) (cond' : condition) (args' : list reg) (Heqp0 : reduce condition combine_cond n1 cond args vl = (cond', args')) (C : (fn_code (transf_function' f cu approx)) ! pc =\nSome (Icond cond' args' ifso ifnot)) (valu1 : valuation) (NH1 : numbering_holds valu1 ge sp rs m approx # pc) (valu2 : valuation) (NH2 : numbering_holds valu2 ge sp rs m n1) (EQ : rs ## args = map valu2 vl) (AG : valu_agree valu1 valu2 (num_next approx # pc)) (P : forall v : valnum, In v vl -> Plt v (num_next n1)) (Q : Ple (num_next approx # pc) (num_next n1)) (RES : eval_condition cond' rs ## args' m = Some b) : exists valu : valuation,\n  numbering_holds valu ge sp rs m approx # (if b then ifso else ifnot).","proofString":"destruct b; eapply analysis_correct_1; eauto; simpl; auto;    unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ijumptable arg tbl)) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs m) s2') \\/\n(exists (s2' : state) (n0 : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n0 (State s f sp pc' rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"generalize (RLD arg); rewrite H0; intro LD; inv LD.\nleft; econstructor; split.\neapply exec_Ijumptable; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl.\neapply list_nth_z_in; eauto.\nunfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ijumptable arg tbl)) (H4 : Vint n = rs' # arg) : (exists s2' : state,\n   step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0 s2' /\\\n   match_states (State s f sp pc' rs m) s2') \\/\n(exists (s2' : state) (n0 : nat),\n   plus step tge (State s' (transf_function' f cu approx) sp pc rs' m') E0\n     s2' /\\\n   eventually n0 (State s f sp pc' rs m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Ijumptable; eauto.\neconstructor; eauto.\neapply analysis_correct_1; eauto.\nsimpl.\neapply list_nth_z_in; eauto.\nunfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ijumptable arg tbl)) (H4 : Vint n = rs' # arg) : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc'.","proofString":"eapply analysis_correct_1; eauto.\nsimpl.\neapply list_nth_z_in; eauto.\nunfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ijumptable arg tbl)) (H4 : Vint n = rs' # arg) : In pc' (successors_instr (Ijumptable arg tbl)).","proofString":"simpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ijumptable arg tbl)) (H4 : Vint n = rs' # arg) : In pc' tbl.","proofString":"eapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (SOUND : sound_state prog (State s f sp pc rs m)) (s' : list stackframe) (rs' : regset) (m' : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation, numbering_holds valu ge sp rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m') (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ijumptable arg tbl)) (H4 : Vint n = rs' # arg) : exists valu : valuation,\n  numbering_holds valu ge sp rs m\n    (transfer f (prog_defmap cu) (vanalyze (romem_for cu) f) pc approx # pc).","proofString":"unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ireturn or)) : (exists s2' : state,\n   step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   eventually n (Returnstate s (regmap_optget or Vundef rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit Mem.free_parallel_extends; eauto.\nintros [m'' [A B]].\nleft; econstructor; split.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\ndestruct or; simpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ireturn or)) : (exists m2' : mem,\n   Mem.free m'0 stk 0 (fn_stacksize f) = Some m2' /\\ Mem.extends m' m2') ->\n(exists s2' : state,\n   step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   eventually n (Returnstate s (regmap_optget or Vundef rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros [m'' [A B]].\nleft; econstructor; split.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\ndestruct or; simpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ireturn or)) (m'' : mem) (A : Mem.free m'0 stk 0 (fn_stacksize f) = Some m'') (B : Mem.extends m' m'') : (exists s2' : state,\n   step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (State s' (transf_function' f cu approx) (Vptr stk Ptrofs.zero) pc rs'\n        m'0) E0 s2' /\\\n   eventually n (Returnstate s (regmap_optget or Vundef rs) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\ndestruct or; simpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SOUND : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (s' : list stackframe) (rs' : regset) (m'0 : mem) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero) rs m approx # pc) (RLD : regs_lessdef rs rs') (MEXT : Mem.extends m m'0) (STACKS : match_stackframes s s') (C : (fn_code (transf_function' f cu approx)) ! pc = Some (Ireturn or)) (m'' : mem) (A : Mem.free m'0 stk 0 (fn_stacksize f) = Some m'') (B : Mem.extends m' m'') : Val.lessdef (regmap_optget or Vundef rs) (regmap_optget or Vundef rs').","proofString":"destruct or; simpl; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SOUND : sound_state prog (Callstate s (Internal f) args m)) (tf : fundef) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (TFD : transf_fundef (prog_defmap cu) (romem_for cu) (Internal f) = OK tf) (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) : (exists s2' : state,\n   step tge (Callstate s' tf args' m'0) E0 s2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (Callstate s' tf args' m'0) E0 s2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"monadInv TFD.\nunfold transf_function in EQ.\nfold (analyze cu f) in EQ.\ndestruct (analyze cu f) as [approx|] eqn:?; inv EQ.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (m'' & A & B).\nleft; econstructor; split.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neapply analysis_correct_entry; eauto.\napply init_regs_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SOUND : sound_state prog (Callstate s (Internal f) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (x : function) (EQ : transf_function (prog_defmap cu) (romem_for cu) f = OK x) : (exists s2' : state,\n   step tge (Callstate s' (Internal x) args' m'0) E0 s2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (Callstate s' (Internal x) args' m'0) E0 s2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"unfold transf_function in EQ.\nfold (analyze cu f) in EQ.\ndestruct (analyze cu f) as [approx|] eqn:?; inv EQ.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (m'' & A & B).\nleft; econstructor; split.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neapply analysis_correct_entry; eauto.\napply init_regs_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SOUND : sound_state prog (Callstate s (Internal f) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (x : function) (EQ : match CSE.analyze f (prog_defmap cu) (vanalyze (romem_for cu) f) with\n| Some approxs =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code := transf_code (prog_defmap cu) approxs (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"CSE failure\")\nend = OK x) : (exists s2' : state,\n   step tge (Callstate s' (Internal x) args' m'0) E0 s2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (Callstate s' (Internal x) args' m'0) E0 s2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"fold (analyze cu f) in EQ.\ndestruct (analyze cu f) as [approx|] eqn:?; inv EQ.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (m'' & A & B).\nleft; econstructor; split.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neapply analysis_correct_entry; eauto.\napply init_regs_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SOUND : sound_state prog (Callstate s (Internal f) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (x : function) (EQ : match analyze cu f with\n| Some approxs =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code := transf_code (prog_defmap cu) approxs (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"CSE failure\")\nend = OK x) : (exists s2' : state,\n   step tge (Callstate s' (Internal x) args' m'0) E0 s2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (Callstate s' (Internal x) args' m'0) E0 s2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"destruct (analyze cu f) as [approx|] eqn:?; inv EQ.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (m'' & A & B).\nleft; econstructor; split.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neapply analysis_correct_entry; eauto.\napply init_regs_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SOUND : sound_state prog (Callstate s (Internal f) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (approx : PMap.t numbering) (Heqo : analyze cu f = Some approx) : (exists s2' : state,\n   step tge\n     (Callstate s'\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_params := fn_params f;\n             fn_stacksize := fn_stacksize f;\n             fn_code := transf_code (prog_defmap cu) approx (fn_code f);\n             fn_entrypoint := fn_entrypoint f\n           |}) args' m'0) E0 s2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (Callstate s'\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_params := fn_params f;\n             fn_stacksize := fn_stacksize f;\n             fn_code := transf_code (prog_defmap cu) approx (fn_code f);\n             fn_entrypoint := fn_entrypoint f\n           |}) args' m'0) E0 s2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (m'' & A & B).\nleft; econstructor; split.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neapply analysis_correct_entry; eauto.\napply init_regs_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SOUND : sound_state prog (Callstate s (Internal f) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (approx : PMap.t numbering) (Heqo : analyze cu f = Some approx) (m'' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f) = (m'', stk)) (B : Mem.extends m' m'') : (exists s2' : state,\n   step tge\n     (Callstate s'\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_params := fn_params f;\n             fn_stacksize := fn_stacksize f;\n             fn_code := transf_code (prog_defmap cu) approx (fn_code f);\n             fn_entrypoint := fn_entrypoint f\n           |}) args' m'0) E0 s2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (Callstate s'\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_params := fn_params f;\n             fn_stacksize := fn_stacksize f;\n             fn_code := transf_code (prog_defmap cu) approx (fn_code f);\n             fn_entrypoint := fn_entrypoint f\n           |}) args' m'0) E0 s2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neapply analysis_correct_entry; eauto.\napply init_regs_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SOUND : sound_state prog (Callstate s (Internal f) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (approx : PMap.t numbering) (Heqo : analyze cu f = Some approx) (m'' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f) = (m'', stk)) (B : Mem.extends m' m'') : match_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State s'\n     {|\n       fn_sig := fn_sig f;\n       fn_params := fn_params f;\n       fn_stacksize := fn_stacksize f;\n       fn_code := transf_code (prog_defmap cu) approx (fn_code f);\n       fn_entrypoint := fn_entrypoint f\n     |} (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args' (fn_params f)) m'').","proofString":"econstructor; eauto.\neapply analysis_correct_entry; eauto.\napply init_regs_lessdef; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SOUND : sound_state prog (Callstate s (Internal f) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (approx : PMap.t numbering) (Heqo : analyze cu f = Some approx) (m'' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f) = (m'', stk)) (B : Mem.extends m' m'') : exists valu : valuation,\n  numbering_holds valu ge (Vptr stk Ptrofs.zero)\n    (init_regs args (fn_params f)) m' approx # (fn_entrypoint f).","proofString":"eapply analysis_correct_entry; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SOUND : sound_state prog (Callstate s (Internal f) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (approx : PMap.t numbering) (Heqo : analyze cu f = Some approx) (m'' : Mem.mem') (A : Mem.alloc m'0 0 (fn_stacksize f) = (m'', stk)) (B : Mem.extends m' m'') : regs_lessdef (init_regs args (fn_params f)) (init_regs args' (fn_params f)).","proofString":"apply init_regs_lessdef; auto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SOUND : sound_state prog (Callstate s (External ef) args m)) (tf : fundef) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (TFD : transf_fundef (prog_defmap cu) (romem_for cu) (External ef) = OK tf) (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) : (exists s2' : state,\n   step tge (Callstate s' tf args' m'0) t s2' /\\\n   match_states (Returnstate s res m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (Callstate s' tf args' m'0) t s2' /\\\n   eventually n (Returnstate s res m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"monadInv TFD.\nexploit external_call_mem_extends; eauto.\nintros (v' & m1' & P & Q & R & S).\nleft; econstructor; split.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SOUND : sound_state prog (Callstate s (External ef) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) : (exists s2' : state,\n   step tge (Callstate s' (External ef) args' m'0) t s2' /\\\n   match_states (Returnstate s res m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (Callstate s' (External ef) args' m'0) t s2' /\\\n   eventually n (Returnstate s res m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"exploit external_call_mem_extends; eauto.\nintros (v' & m1' & P & Q & R & S).\nleft; econstructor; split.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SOUND : sound_state prog (Callstate s (External ef) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) : (exists (vres' : val) (m2' : mem),\n   external_call ef ge args' m'0 t vres' m2' /\\\n   Val.lessdef res vres' /\\\n   Mem.extends m' m2' /\\ Mem.unchanged_on (loc_out_of_bounds m) m'0 m2') ->\n(exists s2' : state,\n   step tge (Callstate s' (External ef) args' m'0) t s2' /\\\n   match_states (Returnstate s res m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (Callstate s' (External ef) args' m'0) t s2' /\\\n   eventually n (Returnstate s res m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"intros (v' & m1' & P & Q & R & S).\nleft; econstructor; split.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SOUND : sound_state prog (Callstate s (External ef) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (v' : val) (m1' : mem) (P : external_call ef ge args' m'0 t v' m1') (Q : Val.lessdef res v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') : (exists s2' : state,\n   step tge (Callstate s' (External ef) args' m'0) t s2' /\\\n   match_states (Returnstate s res m') s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (Callstate s' (External ef) args' m'0) t s2' /\\\n   eventually n (Returnstate s res m')\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SOUND : sound_state prog (Callstate s (External ef) args m)) (s' : list stackframe) (args' : list val) (m'0 : mem) (cu : program) (LINK : linkorder cu prog) (STACKS : match_stackframes s s') (ARGS : Val.lessdef_list args args') (MEXT : Mem.extends m m'0) (v' : val) (m1' : mem) (P : external_call ef ge args' m'0 t v' m1') (Q : Val.lessdef res v') (R : Mem.extends m' m1') (S : Mem.unchanged_on (loc_out_of_bounds m) m'0 m1') : Senv.equiv ge tge.","proofString":"apply senv_preserved."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (SOUND : sound_state prog (Returnstate (Stackframe res f sp pc rs :: s) vres m)) (s' : list stackframe) (v' : val) (m' : mem) (STACK : match_stackframes (Stackframe res f sp pc rs :: s) s') (RES : Val.lessdef vres v') (MEXT : Mem.extends m m') : (exists s2' : state,\n   step tge (Returnstate s' v' m') E0 s2' /\\\n   match_states (State s f sp pc rs # res <- vres m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge (Returnstate s' v' m') E0 s2' /\\\n   eventually n (State s f sp pc rs # res <- vres m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"inv STACK.\nleft; econstructor; split.\neapply exec_return; eauto.\neconstructor; eauto.\napply set_reg_lessdef; auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (SOUND : sound_state prog (Returnstate (Stackframe res f sp pc rs :: s) vres m)) (v' : val) (m' : mem) (RES : Val.lessdef vres v') (MEXT : Mem.extends m m') (rs' : regset) (s'0 : list stackframe) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : forall (v : val) (m0 : mem),\nexists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m0 approx # pc) (RLD : regs_lessdef rs rs') (STACKS : match_stackframes s s'0) : (exists s2' : state,\n   step tge\n     (Returnstate\n        (Stackframe res (transf_function' f cu approx) sp pc rs' :: s'0) v'\n        m') E0 s2' /\\ match_states (State s f sp pc rs # res <- vres m) s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge\n     (Returnstate\n        (Stackframe res (transf_function' f cu approx) sp pc rs' :: s'0) v'\n        m') E0 s2' /\\\n   eventually n (State s f sp pc rs # res <- vres m)\n     (fun s3 : state => match_states s3 s2')).","proofString":"left; econstructor; split.\neapply exec_return; eauto.\neconstructor; eauto.\napply set_reg_lessdef; auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (SOUND : sound_state prog (Returnstate (Stackframe res f sp pc rs :: s) vres m)) (v' : val) (m' : mem) (RES : Val.lessdef vres v') (MEXT : Mem.extends m m') (rs' : regset) (s'0 : list stackframe) (cu : program) (approx : PMap.t numbering) (LINK : linkorder cu prog) (ANALYZE : analyze cu f = Some approx) (SAT : forall (v : val) (m0 : mem),\nexists valu : valuation,\n  numbering_holds valu ge sp rs # res <- v m0 approx # pc) (RLD : regs_lessdef rs rs') (STACKS : match_stackframes s s'0) : regs_lessdef rs # res <- vres rs' # res <- v'.","proofString":"apply set_reg_lessdef; auto."},{"statement":"(st1 : state) (H : initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","proofString":"inversion H.\nexploit funct_ptr_translated; eauto.\nintros (cu & tf & A & B & C).\nexists (Callstate nil tf nil m0); split.\neconstructor; eauto.\neapply (Genv.init_mem_match TRANSF); eauto.\nreplace (prog_main tprog) with (prog_main prog).\nrewrite symbols_preserved.\neauto.\nsymmetry.\neapply match_program_main; eauto.\nrewrite <- H3.\neapply sig_preserved; eauto.\neconstructor.\neauto.\nconstructor.\nauto.\nauto.\napply Mem.extends_refl."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : Genv.init_mem tprog = Some m0.","proofString":"eapply (Genv.init_mem_match TRANSF); eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : prog_main prog = prog_main tprog.","proofString":"symmetry.\neapply match_program_main; eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : prog_main tprog = prog_main prog.","proofString":"eapply match_program_main; eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : funsig tf = signature_main.","proofString":"rewrite <- H3.\neapply sig_preserved; eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : funsig tf = funsig f.","proofString":"eapply sig_preserved; eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : match_states (Callstate nil f nil m0) (Callstate nil tf nil m0).","proofString":"econstructor.\neauto.\nconstructor.\nauto.\nauto.\napply Mem.extends_refl."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : match_stackframes nil nil.","proofString":"constructor."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : Val.lessdef_list nil nil.","proofString":"auto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : Mem.extends m0 m0.","proofString":"apply Mem.extends_refl."},{"statement":"(st1 st2 : state) (r : int) (H : match_states st1 st2) (H0 : final_state st1 r) : final_state st2 r.","proofString":"inv H0.\ninv H.\ninv RES.\ninv STACK.\nconstructor."},{"statement":"(st2 : state) (r : int) (m : mem) (H : match_states (Returnstate nil (Vint r) m) st2) : final_state st2 r.","proofString":"inv H.\ninv RES.\ninv STACK.\nconstructor."},{"statement":"(r : int) (m : mem) (s' : list stackframe) (v' : val) (m' : mem) (STACK : match_stackframes nil s') (RES : Val.lessdef (Vint r) v') (MEXT : Mem.extends m m') : final_state (Returnstate s' v' m') r.","proofString":"inv RES.\ninv STACK.\nconstructor."},{"statement":"(r : int) (m : mem) (s' : list stackframe) (m' : mem) (STACK : match_stackframes nil s') (MEXT : Mem.extends m m') : final_state (Returnstate s' (Vint r) m') r.","proofString":"inv STACK.\nconstructor."},{"statement":"(r : int) (m m' : mem) (MEXT : Mem.extends m m') : final_state (Returnstate nil (Vint r) m') r.","proofString":"constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","proofString":"apply senv_preserved."},{"statement":"forall s1 : Smallstep.state (semantics prog),\nSmallstep.initial_state (semantics prog) s1 ->\nexists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states s1 s2 /\\ sound_state prog s1.","proofString":"intros.\nexploit transf_initial_states; eauto.\nintros [s2 [A B]].\nexists s2.\nauto using sound_initial."},{"statement":"(s1 : Smallstep.state (semantics prog)) (H : Smallstep.initial_state (semantics prog) s1) : exists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states s1 s2 /\\ sound_state prog s1.","proofString":"exploit transf_initial_states; eauto.\nintros [s2 [A B]].\nexists s2.\nauto using sound_initial."},{"statement":"(s1 : Smallstep.state (semantics prog)) (H : Smallstep.initial_state (semantics prog) s1) : (exists st2 : state, initial_state tprog st2 /\\ match_states s1 st2) ->\nexists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states s1 s2 /\\ sound_state prog s1.","proofString":"intros [s2 [A B]].\nexists s2.\nauto using sound_initial."},{"statement":"(s1 : Smallstep.state (semantics prog)) (H : Smallstep.initial_state (semantics prog) s1) (s2 : state) (A : initial_state tprog s2) (B : match_states s1 s2) : exists s0 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s0 /\\\n  match_states s1 s0 /\\ sound_state prog s1.","proofString":"exists s2.\nauto using sound_initial."},{"statement":"(s1 : Smallstep.state (semantics prog)) (H : Smallstep.initial_state (semantics prog) s1) (s2 : state) (A : initial_state tprog s2) (B : match_states s1 s2) : Smallstep.initial_state (semantics tprog) s2 /\\\nmatch_states s1 s2 /\\ sound_state prog s1.","proofString":"auto using sound_initial."},{"statement":"forall (s1 : Smallstep.state (semantics prog))\n  (s2 : Smallstep.state (semantics tprog)) (r : int),\nmatch_states s1 s2 /\\ sound_state prog s1 ->\nSmallstep.final_state (semantics prog) s1 r ->\nSmallstep.final_state (semantics tprog) s2 r.","proofString":"intros.\ndestruct H.\neapply transf_final_states; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (s2 : Smallstep.state (semantics tprog)) (r : int) (H : match_states s1 s2 /\\ sound_state prog s1) (H0 : Smallstep.final_state (semantics prog) s1 r) : Smallstep.final_state (semantics tprog) s2 r.","proofString":"destruct H.\neapply transf_final_states; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (s2 : Smallstep.state (semantics tprog)) (r : int) (H : match_states s1 s2) (H1 : sound_state prog s1) (H0 : Smallstep.final_state (semantics prog) s1 r) : Smallstep.final_state (semantics tprog) s2 r.","proofString":"eapply transf_final_states; eauto."},{"statement":"forall (s1 : Smallstep.state (semantics prog)) (t : trace)\n  (s1' : Smallstep.state (semantics prog)),\nStep (semantics prog) s1 t s1' ->\nforall s2 : Smallstep.state (semantics tprog),\nmatch_states s1 s2 /\\ sound_state prog s1 ->\nexists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2' /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"intros.\ndestruct H0.\nexploit transf_step_correct; eauto.\nintros [(s2' & A & B) | (s2' & n & A & B)].\nexists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step.\nexists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2 /\\ sound_state prog s1) : exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2' /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"destruct H0.\nexploit transf_step_correct; eauto.\nintros [(s2' & A & B) | (s2' & n & A & B)].\nexists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step.\nexists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) : exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2' /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"exploit transf_step_correct; eauto.\nintros [(s2' & A & B) | (s2' & n & A & B)].\nexists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step.\nexists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) : (exists s2' : state, step tge s2 t s2' /\\ match_states s1' s2') \\/\n(exists (s2' : state) (n : nat),\n   plus step tge s2 t s2' /\\\n   eventually n s1' (fun s3 : state => match_states s3 s2')) ->\nexists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2' /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"intros [(s2' & A & B) | (s2' & n & A & B)].\nexists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step.\nexists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (A : step tge s2 t s2') (B : match_states s1' s2') : exists (n : nat) (s2'0 : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2'0 /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2'0 /\\ sound_state prog s1'').","proofString":"exists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (A : step tge s2 t s2') (B : match_states s1' s2') : Plus (semantics tprog) s2 t s2'.","proofString":"apply plus_one; auto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (A : step tge s2 t s2') (B : match_states s1' s2') : Eventually (semantics prog) 0 s1'\n  (fun s1'' : Smallstep.state (semantics prog) =>\n   match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"apply eventually_now.\neauto using sound_step."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (A : step tge s2 t s2') (B : match_states s1' s2') : match_states s1' s2' /\\ sound_state prog s1'.","proofString":"eauto using sound_step."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (n : nat) (A : plus step tge s2 t s2') (B : eventually n s1' (fun s3 : state => match_states s3 s2')) : exists (n0 : nat) (s2'0 : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2'0 /\\\n  Eventually (semantics prog) n0 s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2'0 /\\ sound_state prog s1'').","proofString":"exists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (n : nat) (A : plus step tge s2 t s2') (B : eventually n s1' (fun s3 : state => match_states s3 s2')) : Eventually (semantics prog) n s1'\n  (fun s1'' : Smallstep.state (semantics prog) =>\n   match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"apply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (n : nat) (A : plus step tge s2 t s2') (B : eventually n s1' (fun s3 : state => match_states s3 s2')) : forall (s : Smallstep.state (semantics prog)) (t0 : trace)\n  (s' : Smallstep.state (semantics prog)),\nStep (semantics prog) s t0 s' -> sound_state prog s -> sound_state prog s'.","proofString":"apply sound_step."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (n : nat) (A : plus step tge s2 t s2') (B : eventually n s1' (fun s3 : state => match_states s3 s2')) : sound_state prog s1'.","proofString":"eapply sound_step; eauto."}]}