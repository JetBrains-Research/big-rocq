[{"statement":"Lemma CON_WF CON : Wf G.","proof":"apply CON.\n"},{"statement":"Lemma wf_hbE WF: hb ≡ ⦗E⦘ ⨾ hb ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold hb.\nrewrite (wf_ppoE WF) at 1.\nrewrite (wf_fenceE WF) at 1.\nrewrite (wf_rfeE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_prop1E WF: prop1 ≡ ⦗E⦘ ⨾ prop1 ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold prop1.\nrewrite (wf_rfeE WF) at 1.\nrewrite (wf_fenceE WF) at 1.\nrewrite <- cr_of_ct.\nrewrite inclusion_t_t at 1; [|eapply (wf_hbE WF)].\narewrite ((⦗E⦘ ⨾ hb ⨾ ⦗E⦘)⁺ ⊆ ⦗E⦘ ⨾ hb⁺ ⨾ ⦗E⦘).\nby rewrite <- inclusion_ct_seq_eqv_r; rewrite <- inclusion_ct_seq_eqv_l.\nbasic_solver 42.\n"},{"statement":"Lemma wf_prop2E WF: prop2 ≡ ⦗E⦘ ⨾ prop2 ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold prop2.\nrewrite (wf_coeE WF) at 1.\nrewrite (wf_freE WF) at 1.\nrewrite (wf_rfeE WF) at 1.\nrewrite (wf_fenceE WF) at 1.\nrewrite (wf_syncE WF) at 1.\nrewrite <- cr_of_ct.\nrewrite inclusion_t_t at 2; [|eapply (wf_hbE WF)].\narewrite ((⦗E⦘ ⨾ hb ⨾ ⦗E⦘)⁺ ⊆ ⦗E⦘ ⨾ hb⁺ ⨾ ⦗E⦘).\nby rewrite <- inclusion_ct_seq_eqv_r; rewrite <- inclusion_ct_seq_eqv_l.\nbasic_solver 42.\n"},{"statement":"Lemma wf_propE WF: prop ≡ ⦗E⦘ ⨾ prop ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold prop.\nrewrite (wf_prop1E WF) at 1.\nrewrite (wf_prop2E WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_hbD WF: hb ≡ ⦗RW⦘ ⨾ hb ⨾ ⦗RW⦘.","proof":"split; [|basic_solver].\nunfold hb.\nrewrite (wf_ppoD WF) at 1.\nrewrite (wf_fenceD WF) at 1.\nrewrite (wf_rfeD WF) at 1.\ntype_solver 42.\n"},{"statement":"Lemma wf_cthbD WF: hb⁺ ≡ ⦗RW⦘ ⨾ hb⁺ ⨾ ⦗RW⦘.","proof":"split; [|basic_solver].\nrewrite (dom_r (wf_hbD WF)) at 1.\nrewrite inclusion_ct_seq_eqv_r at 1.\nrewrite (dom_l (wf_hbD WF)) at 1.\nrewrite inclusion_ct_seq_eqv_l at 1.\nbasic_solver.\n"},{"statement":"Lemma rfe_in_hb : rfe ⊆ hb.","proof":"vauto.\n"},{"statement":"Lemma fence_in_hb : fence ⊆ hb.","proof":"vauto.\n"},{"statement":"Lemma ctrli_RW_in_hb WF : ctrli ⨾ ⦗RW⦘ ⊆ hb.","proof":"unfold hb; rewrite ctrli_RW_in_ppo; basic_solver.\n"},{"statement":"Lemma hb_helper WF: hb＊ ⊆ sb^? ∪ sb^? ⨾ rfe ⨾ hb＊.","proof":"rewrite rtE; relsf; unionL; [basic_solver|].\nunfold hb.\nrewrite path_ut_first at 1.\nrewrite (ppo_in_sb WF) at 1 2.\nrewrite (fence_in_sb) at 1 2.\ngeneralize (@sb_trans G); ins; relsf.\nbasic_solver 12.\n"},{"statement":"Lemma sync_hb_rbi WF: \n  sync ⨾ hb＊ ⨾ fri ⊆ sync ⨾ hb＊ ⨾ co^?.","proof":"rewrite rtEE at 1; relsf; unionL; ins.\ninduction x.\n- simpl; rels.\nrewrite (sync_fri_in_sync WF).\nbasic_solver 42.\n- simpl; rewrite seqA; unfold hb at 2; relsf; unionL.\n+ rewrite ppo_fri; auto.\narewrite (ppo ⊆ hb).\nrelsf; unionL; try (by rewrite IHx); rewrite pow_rt.\nall: generalize (ct_end hb); basic_solver 12.\n+ rewrite (fence_fri_in_fence WF).\narewrite (fence ⊆ hb).\nrewrite pow_seq, pow_rt; basic_solver 12.\n+ rewrite pow_rt.\narewrite (rfe ⨾ fri ⊆ co).\ngeneralize (rf_fr WF).\nie_unfolder.\nbasic_solver 42.\nbasic_solver 12.\n"},{"statement":"Lemma lwsync_hb_rbi WF: \n  lwsync ⨾ hb＊ ⨾ fri ⊆ lwsync ⨾ hb＊ ⨾ co^?.","proof":"rewrite rtEE at 1; relsf; unionL; ins.\ninduction x.\n- simpl; rels.\nrewrite (lwsync_fri_in_lwsync WF).\nbasic_solver 42.\n- simpl; rewrite seqA; unfold hb at 2; relsf; unionL.\n+ rewrite ppo_fri; auto.\narewrite (ppo ⊆ hb).\nrelsf; unionL; try (by rewrite IHx); rewrite pow_rt.\nall: generalize (ct_end hb); basic_solver 12.\n+ rewrite (fence_fri_in_fence WF).\narewrite (fence ⊆ hb).\nrewrite pow_seq, pow_rt; basic_solver 12.\n+ rewrite pow_rt.\narewrite (rfe ⨾ fri ⊆ co).\ngeneralize (rf_fr WF).\nie_unfolder.\nbasic_solver 42.\nbasic_solver 12.\n"},{"statement":"Proposition fence_hb_fri WF: \n  fence ⨾ hb＊ ⨾ fri ⊆ fence ⨾ hb＊ ⨾ co^?.","proof":"unfold Power_fences.fence.\ngeneralize (sync_hb_rbi WF) (lwsync_hb_rbi WF).\nrelsf.\nbasic_solver 12.\n"},{"statement":"Proposition fence_hb WF: \n  fence ⨾ hb＊ ⊆ sb ∪ fence ⨾ ⦗W⦘ ⨾ hb＊.","proof":"rewrite rtE at 1.\nrelsf.\napply inclusion_union_l.\n- rewrite fence_in_sb at 1; basic_solver.\n- unfold hb.\nrewrite path_ut_first with (r:=ppo ∪ fence) (r':=rfe).\nrewrite (ppo_in_sb WF) at 1 2.\nrelsf; apply inclusion_union_l.\n+ rewrite fence_in_sb at 1 2.\nrels.\ngeneralize (@sb_trans G) (ct_of_trans (@sb_trans G)).\nbasic_solver 42.\n+ rewrite (dom_l (wf_rfeD WF)) at 1.\narewrite (rfe ⊆ (ppo ∪ fence ∪ rfe)＊) at 1.\nrewrite rt_rt.\nrewrite fence_in_sb at 2.\nrels.\nrewrite rtE at 1.\nrewrite (ct_of_trans (@sb_trans G)).\nrelsf.\nsin_rewrite (fence_sb_w_in_fence WF).\nbasic_solver 12.\n"},{"statement":"Proposition RW_sb_fence_hb_sync WF:\n  ⦗RW⦘ ⨾ sb ⨾ (fence ⨾ hb＊)^? ⨾ sync ⊆ (fence ⨾ hb＊)^? ⨾ sync.","proof":"rewrite (fence_hb WF) at 1; auto.\nrewrite cr_union_r.\nrelsf.\nsin_rewrite !(rewrite_trans (@sb_trans G)).\ngeneralize (@RW_sb_sync_in_sync G) (RW_sb_fence_in_fence WF).\nbasic_solver 42.\n"},{"statement":"Proposition eco_fench_hb_acyclic CON:\n  acyclic (eco^? ⨾ (fence ⨾ hb＊)^? ⨾ sync ⨾ hb＊).","proof":"rewrite eco_refl, seq_union_l.\nremember (((co ∪ fre)^? ⨾ rf^? ∪ fri ⨾ (rfi)^?) ⨾ (fence ⨾ hb＊)^? ⨾ sync ⨾ hb＊) as A.\nremember ((fri ⨾ rfe) ⨾ (fence ⨾ hb＊)^? ⨾ sync ⨾ hb＊) as B.\nassert (H: A ⨾ B ⊆ A ⨾ A /\\ B ⨾ B ⊆ B ⨾ A).\n{\nsplit; subst; rewrite !seqA;    sin_rewrite (sync_hb_rbi (CON_WF CON)); auto;    rewrite !seqA;    (arewrite (co^? ⨾ rfe ⊆ (co ∪ fre)^? ⨾ rf^? ∪ fri ⨾ (rfi)^?)       by (unionR left; arewrite (co^? ⊆ (co ∪ fre)^?);           arewrite (rfe ⊆ rf^?); done));    done.\n}\ndestruct H.\napply acyclic_specific_absorb; try done.\n- arewrite (A ⊆ co^? ⨾ prop2).\n{\nclear H H0; subst.\nunfold prop2.\nrewrite cr_union_l.\nrewrite (@rfi_union_rfe G) at 1.\nrewrite cr_union_r.\narewrite (rf ∩ sb ⊆ ⦗RW⦘ ⨾ sb) at 1.\nie_unfolder; rewrite (wf_rfD (CON_WF CON)); basic_solver.\narewrite (fri ⨾ rfi^? ⊆ ⦗RW⦘ ⨾ sb).\nie_unfolder; rewrite (wf_frD (CON_WF CON)).\ngeneralize (@sb_trans G).\nbasic_solver.\nrelsf; rewrite !seqA.\nsin_rewrite !(RW_sb_fence_hb_sync (CON_WF CON)).\nbasic_solver 42.\n}\narewrite (prop2 ⊆ prop).\narewrite (prop ⊆ (co ∪ prop)⁺).\narewrite (co ⊆ (co ∪ prop)⁺) at 1.\nrelsf; cdes CON; red; relsf.\n- clear H H0; subst.\nrotate 9.\nsin_rewrite (sync_hb_rbi (CON_WF CON)).\narewrite (rfe ⨾ (fence ⨾ hb＊)^? ⨾ sync ⨾ hb＊ ⊆ prop).\nby unfold prop, prop2; basic_solver 25.\narewrite (prop ⊆ (co ∪ prop)⁺).\narewrite (co ⊆ (co ∪ prop)⁺) at 2.\nrelsf; cdes CON; red; relsf.\n"},{"statement":"Lemma S_helper_1 WF: rfe ⨾ hb＊ ⊆ rfe ⨾ hb＊ ⨾ ⦗RW⦘.","proof":"rewrite (dom_r (wf_rfeD WF)) at 1.\nrewrite rtE.\nrewrite (dom_r (wf_cthbD WF)) at 1.\nbasic_solver 12.\n"},{"statement":"Lemma S_helper_2: \n ⦗RW⦘ ⨾ (sb ⨾ ⦗F^lwsync⦘ ∪ eco ∩ sb)^? ⨾ sb^? ⨾ ⦗F^lwsync⦘ ⨾ sb ⨾ ⦗W⦘  ⊆ fence.","proof":"unfold Power_fences.fence; rewrite lwsync_alt.\narewrite ((sb ⨾ ⦗F^lwsync⦘ ∪ eco ∩ sb)^? ⨾ sb^? ⊆ sb^?).\ngeneralize (@sb_trans G); basic_solver.\narewrite (⦗RW⦘ ⨾ sb^? ⨾ ⦗F^lwsync⦘ ⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗F^lwsync⦘) by type_solver.\nbasic_solver 20.\n"},{"statement":"Lemma S_trans WF : transitive S.","proof":"apply transitiveI.\nunfold S.\nsin_rewrite (S_helper_1 WF).\nrewrite (dom_l (wf_rfeD WF)) at 2.\nrewrite !seqA.\nsin_rewrite S_helper_2.\narewrite (fence ⊆ hb＊).\narewrite (rfe ⊆ hb＊) at 2.\nrels.\n"},{"statement":"Lemma S_irr CON : irreflexive (S ⨾ sb^?).","proof":"unfold S.\nsin_rewrite (S_helper_1 (CON_WF CON)).\nrewrite (dom_l (wf_rfeD (CON_WF CON))) at 1.\nrotate 4.\narewrite (sb^? ⨾ sb^? ⊆ sb^?).\nby generalize (@sb_trans G); basic_solver.\nsin_rewrite S_helper_2.\narewrite (fence ⊆ hb＊).\narewrite (rfe ⊆ hb⁺).\nrels.\napply CON.\n"},{"statement":"Lemma eco_fence_hb_irr CON: irreflexive (eco ⨾ fence ⨾ hb＊).","proof":"rewrite (fence_hb (CON_WF CON)).\nrelsf; unionL.\nby rotate 1; apply CON.\nrewrite (eco_alt4 (CON_WF CON)).\nrelsf; unionL.\nall: simpl_rels.\n+ sin_rewrite (RW_sb_fence_in_fence (CON_WF CON)).\narewrite (fence ⊆ hb).\nrewrite <- ct_begin.\napply CON.\n+ arewrite (rfe ⊆ hb); arewrite (fence ⊆ hb); arewrite_id ⦗W⦘; simpl_rels.\nrewrite <- ct_begin, ct_step with (r := hb) at 1; rewrite ct_ct.\napply CON.\n+ sin_rewrite (rf_fence_W_in_fence (CON_WF CON)); simpl_rels.\nrewrite (wf_coD (CON_WF CON)); rewrite !seqA.\nrotate 6.\narewrite (⦗W⦘ ⨾ rfe^? ⨾ fence ⨾ ⦗W⦘ ⨾ hb＊ ⨾ ⦗W⦘ ⊆ prop1).\narewrite (co ⊆ (co ∪ prop)⁺).\narewrite (prop1 ⊆ (co ∪ prop)＊).\nrels; apply CON.\n+ sin_rewrite (rf_fence_W_in_fence (CON_WF CON)); simpl_rels.\nrewrite (dom_r (wf_freD (CON_WF CON))); rewrite !seqA.\narewrite (⦗W⦘ ⨾ rfe^? ⨾ fence ⨾ ⦗W⦘  ⊆ prop1).\nby unfold prop1; basic_solver 42.\narewrite (prop1 ⊆ prop).\napply CON.\n+ cut(irreflexive (⦗W⦘ ⨾ rfe ⨾ fence ⨾ hb＊ ⨾ fri ⨾ ⦗W⦘)).\nrewrite (dom_r (wf_friD (CON_WF CON))) at 2.\nbasic_solver 42.\nsin_rewrite (fence_hb_fri (CON_WF CON)).\nrewrite (dom_l (wf_coD (CON_WF CON))).\nrewrite !seqA.\narewrite ((⦗W⦘ ⨾ co)^? ⨾ ⦗W⦘ ⊆ ⦗W⦘ ⨾ co^?) by basic_solver 12.\narewrite (⦗W⦘ ⨾ rfe ⨾ fence ⨾ hb＊ ⨾ ⦗W⦘ ⊆ prop1).\narewrite (prop1 ⊆ (co ∪ prop)⁺).\narewrite (co^? ⊆ (co ∪ prop)＊).\nrels; apply CON.\n"},{"statement":"Lemma rw_S CON : ⦗RW⦘ ⨾ S ⊆ fence ⨾ rfe ⨾ hb＊ ⨾ (sb ⨾ ⦗F^lwsync⦘ ∪ eco ∩ sb)^?.","proof":"unfold S.\narewrite (⦗RW⦘ ⨾ sb^? ⨾ ⦗F^lwsync⦘ ⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗F^lwsync⦘) by type_solver.\nrewrite (dom_l (wf_rfeD (CON_WF CON))) at 1; rewrite !seqA.\nby sin_rewrite (@RW_sb_F_sb_W_in_fence G).\n"},{"statement":"Lemma S_rw CON : S ⨾ ⦗RW⦘ ⊆ sb^? ⨾ ⦗F^lwsync⦘ ⨾ sb ⨾ rfe ⨾ hb＊ ⨾ (eco ∩ sb)^?.","proof":"unfold S; rewrite !seqA.\narewrite ((sb ⨾ ⦗F^lwsync⦘ ∪ eco ∩ sb)^? ⨾ ⦗RW⦘ ⊆ (eco ∩ sb)^?).\ntype_solver 12.\ndone.\n"},{"statement":"Lemma S_eco_irr CON : irreflexive (S ⨾ eco).","proof":"rewrite (dom_r (wf_ecoD (CON_WF CON))).\nrotate 1.\nsin_rewrite (rw_S CON).\nrewrite !seqA.\narewrite ((sb ⨾ ⦗F^lwsync⦘ ∪ eco ∩ sb)^? ⨾ eco ⊆ eco).\nby rewrite (dom_l (wf_ecoD (CON_WF CON))); generalize (eco_trans (CON_WF CON)); type_solver.\nsin_rewrite rfe_in_hb.\nrotate 1.\nrewrite <- ct_begin.\nrewrite inclusion_t_rt.\nby apply eco_fence_hb_irr.\n"},{"statement":"Proposition eco_sb_fence_hb_irr CON : \n  irreflexive (eco ⨾ (sb ∪ fence ⨾ hb＊)).","proof":"relsf.\ncdes CON; red in SC_PER_LOC; unfolder in SC_PER_LOC.\ngeneralize (eco_fence_hb_irr CON).\nbasic_solver 15.\n"},{"statement":"Proposition eco_sb_fence_hb_eco_R_irr CON:\n  irreflexive (eco ⨾ (sb ∪ (fence ⨾ hb＊ ⨾ (sb ⨾ ⦗F⦘ ∪ eco)^?))).","proof":"relsf; unionL.\nby rotate 1; apply CON.\nrewrite crE.\nrelsf; unionL.\napply (eco_fence_hb_irr CON).\nrewrite (dom_l (wf_ecoD (CON_WF CON))); type_solver.\ngeneralize (eco_fence_hb_irr CON), (eco_trans (CON_WF CON)); basic_solver 12.\n"}]