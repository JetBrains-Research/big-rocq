{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/travorder/TraversalOrder.v","fileSamples":[{"statement":"(y : actid) : exists x : trav_label, y = event x.","conclusion":"exists x : trav_label, y = event x","hypotheses":"(y : actid)","proofString":"exists (mkTL ta_cover y); ins."},{"statement":"(y : actid) : set_finite (fun x : trav_label => y = event x /\\ (action ↓₁ eq ta_cover) x).","conclusion":"set_finite (fun x : trav_label => y = event x /\\ (action ↓₁ eq ta_cover) x)","hypotheses":"(y : actid)","proofString":"exists [mkTL ta_cover y].\nins.\ndesf.\nred in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(y : actid) (x : trav_label) (IN : y = event x /\\ (action ↓₁ eq ta_cover) x) : mkTL ta_cover y = x \\/ False.","conclusion":"mkTL ta_cover y = x \\/ False","hypotheses":"(y : actid) (x : trav_label) (IN : y = event x /\\ (action ↓₁ eq ta_cover) x)","proofString":"desf.\nred in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(x : trav_label) (IN0 : (action ↓₁ eq ta_cover) x) : mkTL ta_cover (event x) = x \\/ False.","conclusion":"mkTL ta_cover (event x) = x \\/ False","hypotheses":"(x : trav_label) (IN0 : (action ↓₁ eq ta_cover) x)","proofString":"red in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(x : trav_label) (IN0 : ta_cover = action x) : mkTL ta_cover (event x) = x \\/ False.","conclusion":"mkTL ta_cover (event x) = x \\/ False","hypotheses":"(x : trav_label) (IN0 : ta_cover = action x)","proofString":"destruct x as [[]]; ins; auto."},{"statement":"(y : actid) : set_finite (fun x : trav_label => y = event x /\\ (action ↓₁ eq ta_issue) x).","conclusion":"set_finite (fun x : trav_label => y = event x /\\ (action ↓₁ eq ta_issue) x)","hypotheses":"(y : actid)","proofString":"exists [mkTL ta_issue y].\nins.\ndesf.\nred in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(y : actid) (x : trav_label) (IN : y = event x /\\ (action ↓₁ eq ta_issue) x) : mkTL ta_issue y = x \\/ False.","conclusion":"mkTL ta_issue y = x \\/ False","hypotheses":"(y : actid) (x : trav_label) (IN : y = event x /\\ (action ↓₁ eq ta_issue) x)","proofString":"desf.\nred in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(x : trav_label) (IN0 : (action ↓₁ eq ta_issue) x) : mkTL ta_issue (event x) = x \\/ False.","conclusion":"mkTL ta_issue (event x) = x \\/ False","hypotheses":"(x : trav_label) (IN0 : (action ↓₁ eq ta_issue) x)","proofString":"red in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(x : trav_label) (IN0 : ta_issue = action x) : mkTL ta_issue (event x) = x \\/ False.","conclusion":"mkTL ta_issue (event x) = x \\/ False","hypotheses":"(x : trav_label) (IN0 : ta_issue = action x)","proofString":"destruct x as [[]]; ins; auto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) : forall x : actid,\n(exists y : actid, r x y /\\ (exists y0 : trav_label, A y0 /\\ event y0 = y)) ->\nexists y : trav_label, B y /\\ event y = x.","conclusion":"forall x : actid,\n(exists y : actid, r x y /\\ (exists y0 : trav_label, A y0 /\\ event y0 = y)) ->\nexists y : trav_label, B y /\\ event y = x","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B)","proofString":"ins.\ndesf.\nexists (mkTL b x); ins.\nsplit; auto.\napply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (H : exists y : actid, r x y /\\ (exists y0 : trav_label, A y0 /\\ event y0 = y)) : exists y : trav_label, B y /\\ event y = x.","conclusion":"exists y : trav_label, B y /\\ event y = x","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (H : exists y : actid, r x y /\\ (exists y0 : trav_label, A y0 /\\ event y0 = y))","proofString":"desf.\nexists (mkTL b x); ins.\nsplit; auto.\napply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : exists y : trav_label, B y /\\ event y = x.","conclusion":"exists y : trav_label, B y /\\ event y = x","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0)","proofString":"exists (mkTL b x); ins.\nsplit; auto.\napply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : B (mkTL b x) /\\ x = x.","conclusion":"B (mkTL b x) /\\ x = x","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0)","proofString":"split; auto.\napply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : B (mkTL b x).","conclusion":"B (mkTL b x)","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0)","proofString":"apply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) (mkTL b x).","conclusion":"dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) (mkTL b x)","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0)","proofString":"unfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : exists y z : trav_label,\n  (mkTL b x = z /\\ b = action (mkTL b x)) /\\\n  (exists z0 : trav_label, r (event z) (event z0) /\\ z0 = y /\\ A z0).","conclusion":"exists y z : trav_label,\n  (mkTL b x = z /\\ b = action (mkTL b x)) /\\\n  (exists z0 : trav_label, r (event z) (event z0) /\\ z0 = y /\\ A z0)","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0)","proofString":"do 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B ->\ndom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B.","conclusion":"dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B ->\ndom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b)","proofString":"ins.\nunfolder.\nins.\ndesf.\ndestruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B.","conclusion":"dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B)","proofString":"unfolder.\nins.\ndesf.\ndestruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) : forall x : trav_label,\n(exists y : trav_label, b = action x /\\ r (event x) (event y) /\\ A y) -> B x.","conclusion":"forall x : trav_label,\n(exists y : trav_label, b = action x /\\ r (event x) (event y) /\\ A y) -> B x","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B)","proofString":"ins.\ndesf.\ndestruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (x : trav_label) (H0 : exists y : trav_label, b = action x /\\ r (event x) (event y) /\\ A y) : B x.","conclusion":"B x","hypotheses":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (x : trav_label) (H0 : exists y : trav_label, b = action x /\\ r (event x) (event y) /\\ A y)","proofString":"desf.\ndestruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (x : trav_label) (UU : B ⊆₁ action ↓₁ eq (action x)) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (y : trav_label) (H1 : r (event x) (event y)) (H2 : A y) : B x.","conclusion":"B x","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (x : trav_label) (UU : B ⊆₁ action ↓₁ eq (action x)) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (y : trav_label) (H1 : r (event x) (event y)) (H2 : A y)","proofString":"destruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq (action (a1, e1))) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (a2 : trav_action) (e2 : actid) (H1 : r (event (a1, e1)) (event (a2, e2))) (H2 : A (a2, e2)) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq (action (a1, e1))) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (a2 : trav_action) (e2 : actid) (H1 : r (event (a1, e1)) (event (a2, e2))) (H2 : A (a2, e2))","proofString":"ins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2))","proofString":"specialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) e1 -> (event ↑₁ B) e1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) e1 -> (event ↑₁ B) e1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2))","proofString":"specialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) e1 -> (event ↑₁ B) e1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) : dom_rel (r ⨾ ⦗event ↑₁ A⦘) e1.","conclusion":"dom_rel (r ⨾ ⦗event ↑₁ A⦘) e1","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) e1 -> (event ↑₁ B) e1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2))","proofString":"eexists.\napply seq_eqv_r.\nsplit; vauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : (event ↑₁ B) e1) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : (event ↑₁ B) e1)","proofString":"red in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : exists y : trav_label, B y /\\ event y = e1) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : exists y : trav_label, B y /\\ event y = e1)","proofString":"desc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (y : trav_label) (H : B y) (H0 : event y = e1) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (y : trav_label) (H : B y) (H0 : event y = e1)","proofString":"specialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (y : trav_label) (UU : (action ↓₁ eq a1) y) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B y) (H0 : event y = e1) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (y : trav_label) (UU : (action ↓₁ eq a1) y) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B y) (H0 : event y = e1)","proofString":"destruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (UU : (action ↓₁ eq a1) (a3, e3)) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e3)) (H0 : event (a3, e3) = e1) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (UU : (action ↓₁ eq a1) (a3, e3)) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e3)) (H0 : event (a3, e3) = e1)","proofString":"red in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (UU : a1 = action (a3, e3)) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e3)) (H0 : event (a3, e3) = e1) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (UU : a1 = action (a3, e3)) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e3)) (H0 : event (a3, e3) = e1)","proofString":"ins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (UU : a1 = a3) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e3)) (H0 : e3 = e1) : B (a1, e1).","conclusion":"B (a1, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (UU : a1 = a3) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e3)) (H0 : e3 = e1)","proofString":"subst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (e1 : actid) (a3 a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e1)) : B (a3, e1).","conclusion":"B (a3, e1)","hypotheses":"(A B : trav_label -> Prop) (r : relation actid) (e1 : actid) (a3 a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e1))","proofString":"auto."},{"statement":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)) : dom_rel (⦗action ↓₁ eq a1⦘ ⨾ event ↓ r ⨾ ⦗action ↓₁ eq a2 ∩₁ T⦘) ⊆₁ T.","conclusion":"dom_rel (⦗action ↓₁ eq a1⦘ ⨾ event ↓ r ⨾ ⦗action ↓₁ eq a2 ∩₁ T⦘) ⊆₁ T","hypotheses":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1))","proofString":"transitivity (T ∩₁ action ↓₁ eq a1); [| basic_solver].\napply dom_rel_collect_event2; [basic_solver| ].\ngeneralize DOM.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)) : dom_rel (⦗action ↓₁ eq a1⦘ ⨾ event ↓ r ⨾ ⦗action ↓₁ eq a2 ∩₁ T⦘)\n⊆₁ T ∩₁ action ↓₁ eq a1.","conclusion":"dom_rel (⦗action ↓₁ eq a1⦘ ⨾ event ↓ r ⨾ ⦗action ↓₁ eq a2 ∩₁ T⦘)\n⊆₁ T ∩₁ action ↓₁ eq a1","hypotheses":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1))","proofString":"apply dom_rel_collect_event2; [basic_solver| ].\ngeneralize DOM.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)) : dom_rel (r ⨾ ⦗event ↑₁ (action ↓₁ eq a2 ∩₁ T)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1).","conclusion":"dom_rel (r ⨾ ⦗event ↑₁ (action ↓₁ eq a2 ∩₁ T)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)","hypotheses":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1))","proofString":"generalize DOM.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)) : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1) ->\ndom_rel (r ⨾ ⦗event ↑₁ (action ↓₁ eq a2 ∩₁ T)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1).","conclusion":"dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1) ->\ndom_rel (r ⨾ ⦗event ↑₁ (action ↓₁ eq a2 ∩₁ T)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)","hypotheses":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1))","proofString":"basic_solver 10."},{"statement":"(a : trav_action) (B : actid -> Prop) : event ↑₁ (fst ↓₁ eq a ∩₁ snd ↓₁ B) ≡₁ B.","conclusion":"event ↑₁ (fst ↓₁ eq a ∩₁ snd ↓₁ B) ≡₁ B","hypotheses":"(a : trav_action) (B : actid -> Prop)","proofString":"split; try basic_solver.\nintros b Bb.\nexists (mkTL a b).\nvauto."},{"statement":"(a : trav_action) (B : actid -> Prop) : B ⊆₁ event ↑₁ (fst ↓₁ eq a ∩₁ snd ↓₁ B).","conclusion":"B ⊆₁ event ↑₁ (fst ↓₁ eq a ∩₁ snd ↓₁ B)","hypotheses":"(a : trav_action) (B : actid -> Prop)","proofString":"intros b Bb.\nexists (mkTL a b).\nvauto."},{"statement":"(a : trav_action) (B : actid -> Prop) (b : actid) (Bb : B b) : (event ↑₁ (fst ↓₁ eq a ∩₁ snd ↓₁ B)) b.","conclusion":"(event ↑₁ (fst ↓₁ eq a ∩₁ snd ↓₁ B)) b","hypotheses":"(a : trav_action) (B : actid -> Prop) (b : actid) (Bb : B b)","proofString":"exists (mkTL a b).\nvauto."},{"statement":"(a : trav_action) (B : actid -> Prop) (b : actid) (Bb : B b) : (fst ↓₁ eq a ∩₁ snd ↓₁ B) (mkTL a b) /\\ event (mkTL a b) = b.","conclusion":"(fst ↓₁ eq a ∩₁ snd ↓₁ B) (mkTL a b) /\\ event (mkTL a b) = b","hypotheses":"(a : trav_action) (B : actid -> Prop) (b : actid) (Bb : B b)","proofString":"vauto."},{"statement":"(a : trav_action) (e : actid) : (fun ab : trav_action * actid => let (a0, b) := ab in a = a0 /\\ e = b)\n≡₁ eq (mkTL a e).","conclusion":"(fun ab : trav_action * actid => let (a0, b) := ab in a = a0 /\\ e = b)\n≡₁ eq (mkTL a e)","hypotheses":"(a : trav_action) (e : actid)","proofString":"split; try basic_solver.\nintros [? ?] [-> ->].\nauto."},{"statement":"(a : trav_action) (e : actid) : (fun ab : trav_action * actid => let (a0, b) := ab in a = a0 /\\ e = b)\n⊆₁ eq (mkTL a e).","conclusion":"(fun ab : trav_action * actid => let (a0, b) := ab in a = a0 /\\ e = b)\n⊆₁ eq (mkTL a e)","hypotheses":"(a : trav_action) (e : actid)","proofString":"intros [? ?] [-> ->].\nauto."},{"statement":"(t : trav_action) (a0 : actid) : mkTL t a0 = (t, a0).","conclusion":"mkTL t a0 = (t, a0)","hypotheses":"(t : trav_action) (a0 : actid)","proofString":"auto."},{"statement":"(G : execution) (sc : relation actid) : iord G sc\n≡ ⦗set_compl (action ↓₁ eq ta_reserve)⦘\n  ⨾ iord G sc ⨾ ⦗set_compl (action ↓₁ eq ta_reserve)⦘.","conclusion":"iord G sc\n≡ ⦗set_compl (action ↓₁ eq ta_reserve)⦘\n  ⨾ iord G sc ⨾ ⦗set_compl (action ↓₁ eq ta_reserve)⦘","hypotheses":"(G : execution) (sc : relation actid)","proofString":"split; [| basic_solver].\napply dom_helper_3.\nunfold iord.\niord_dom_unfolder; ins; subst; vauto."},{"statement":"(G : execution) (sc : relation actid) : iord G sc\n⊆ ⦗set_compl (action ↓₁ eq ta_reserve)⦘\n  ⨾ iord G sc ⨾ ⦗set_compl (action ↓₁ eq ta_reserve)⦘.","conclusion":"iord G sc\n⊆ ⦗set_compl (action ↓₁ eq ta_reserve)⦘\n  ⨾ iord G sc ⨾ ⦗set_compl (action ↓₁ eq ta_reserve)⦘","hypotheses":"(G : execution) (sc : relation actid)","proofString":"apply dom_helper_3.\nunfold iord.\niord_dom_unfolder; ins; subst; vauto."},{"statement":"(G : execution) (sc : relation actid) : iord G sc\n⊆ set_compl (action ↓₁ eq ta_reserve) × set_compl (action ↓₁ eq ta_reserve).","conclusion":"iord G sc\n⊆ set_compl (action ↓₁ eq ta_reserve) × set_compl (action ↓₁ eq ta_reserve)","hypotheses":"(G : execution) (sc : relation actid)","proofString":"unfold iord.\niord_dom_unfolder; ins; subst; vauto."},{"statement":"(G : execution) (sc : relation actid) : restr_rel (event ↓₁ (acts_set G \\₁ (fun a : actid => is_init a)))\n  (SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc)\n⊆ set_compl (action ↓₁ eq ta_reserve) × set_compl (action ↓₁ eq ta_reserve).","conclusion":"restr_rel (event ↓₁ (acts_set G \\₁ (fun a : actid => is_init a)))\n  (SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc)\n⊆ set_compl (action ↓₁ eq ta_reserve) × set_compl (action ↓₁ eq ta_reserve)","hypotheses":"(G : execution) (sc : relation actid)","proofString":"iord_dom_unfolder; ins; subst; vauto."},{"statement":"restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n  (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP)\n≡ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP).","conclusion":"restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n  (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP)\n≡ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP)","hypotheses":"","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP).","conclusion":"irreflexive (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP)","hypotheses":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"iord_simpl_dom_unfolder.\neapply sb_sc_acyclic; eauto.\napply CONS.\neapply ar_rf_ppo_loc_acyclic; eauto."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (a : actid) (b0 : (fun x y : actid => sb x y \\/ sc x y)⁺ a a) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (a : actid) (b0 : (fun x y : actid => sb x y \\/ sc x y)⁺ a a)","proofString":"eapply sb_sc_acyclic; eauto.\napply CONS."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (a : actid) (b0 : (fun x y : actid => sb x y \\/ sc x y)⁺ a a) : acyc_ext G sc.","conclusion":"acyc_ext G sc","hypotheses":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (a : actid) (b0 : (fun x y : actid => sb x y \\/ sc x y)⁺ a a)","proofString":"apply CONS."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (a : actid) (b5 : true) (b2 : (fun x y : actid =>\n ar x y \\/ (exists z : actid, rf x z /\\ ppo z y /\\ same_loc z y))⁺ a a) (b4 : is_w lab a) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (a : actid) (b5 : true) (b2 : (fun x y : actid =>\n ar x y \\/ (exists z : actid, rf x z /\\ ppo z y /\\ same_loc z y))⁺ a a) (b4 : is_w lab a)","proofString":"eapply ar_rf_ppo_loc_acyclic; eauto."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP).","conclusion":"irreflexive (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP)","hypotheses":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"auto using iord_simpl_irreflexive."},{"statement":"transitive\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘).","conclusion":"transitive\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)","hypotheses":"","proofString":"rewrite <- restr_relE.\napply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\napply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"transitive\n  (restr_rel (action ↓₁ eq ta_issue)\n     (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘))).","conclusion":"transitive\n  (restr_rel (action ↓₁ eq ta_issue)\n     (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)))","hypotheses":"","proofString":"apply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\napply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"transitive (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)).","conclusion":"transitive (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘))","hypotheses":"","proofString":"apply transitiveI.\nrewrite map_rel_seq.\napply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","conclusion":"event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)","hypotheses":"","proofString":"rewrite map_rel_seq.\napply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"event\n↓ ((⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n   ⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","conclusion":"event\n↓ ((⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n   ⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)","hypotheses":"","proofString":"apply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"(⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘\n⊆ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘.","conclusion":"(⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘\n⊆ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘","hypotheses":"","proofString":"hahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"(ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘ ⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"(ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘ ⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"","proofString":"arewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"(ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⨾ ⦗fun _ : actid => True⦘\n  ⨾ ⦗fun _ : actid => True⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"(ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⨾ ⦗fun _ : actid => True⦘\n  ⨾ ⦗fun _ : actid => True⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"","proofString":"now rewrite !seq_id_l, ct_ct."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘).","conclusion":"irreflexive\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)","hypotheses":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite <- restr_relE.\napply irreflexive_restr.\napply map_rel_irr.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive\n  (restr_rel (action ↓₁ eq ta_issue)\n     (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘))).","conclusion":"irreflexive\n  (restr_rel (action ↓₁ eq ta_issue)\n     (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)))","hypotheses":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"apply irreflexive_restr.\napply map_rel_irr.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)).","conclusion":"irreflexive (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘))","hypotheses":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"apply map_rel_irr.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","conclusion":"irreflexive (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)","hypotheses":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"arewrite_id ⦗W⦘.\nrewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive\n  (⦗fun _ : actid => True⦘\n   ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗fun _ : actid => True⦘).","conclusion":"irreflexive\n  (⦗fun _ : actid => True⦘\n   ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗fun _ : actid => True⦘)","hypotheses":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"irreflexive (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"apply ar_rf_ppo_loc_acyclic; auto."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ (sb ∪ sc)⁺.","conclusion":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ (sb ∪ sc)⁺","hypotheses":"","proofString":"clear.\nbasic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ (sb ∪ sc)⁺.","conclusion":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ (sb ∪ sc)⁺","hypotheses":"","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyclic (event ↑ SB).","conclusion":"acyclic (event ↑ SB)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite eSB_in_sb_sc_ct.\nred.\nrewrite ct_of_ct.\napply sb_sc_acyclic; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyclic (sb ∪ sc)⁺.","conclusion":"acyclic (sb ∪ sc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"red.\nrewrite ct_of_ct.\napply sb_sc_acyclic; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive ((sb ∪ sc)⁺)⁺.","conclusion":"irreflexive ((sb ∪ sc)⁺)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite ct_of_ct.\napply sb_sc_acyclic; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive (sb ∪ sc)⁺.","conclusion":"irreflexive (sb ∪ sc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"apply sb_sc_acyclic; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyc_ext G sc.","conclusion":"acyc_ext G sc","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"apply CONS."},{"statement":"transitive\n  (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘).","conclusion":"transitive\n  (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)","hypotheses":"","proofString":"rewrite <- restr_relE.\napply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\nnow rewrite ct_ct."},{"statement":"transitive (restr_rel (action ↓₁ eq ta_cover) (event ↓ (sb ∪ sc)⁺)).","conclusion":"transitive (restr_rel (action ↓₁ eq ta_cover) (event ↓ (sb ∪ sc)⁺))","hypotheses":"","proofString":"apply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\nnow rewrite ct_ct."},{"statement":"transitive (event ↓ (sb ∪ sc)⁺).","conclusion":"transitive (event ↓ (sb ∪ sc)⁺)","hypotheses":"","proofString":"apply transitiveI.\nrewrite map_rel_seq.\nnow rewrite ct_ct."},{"statement":"event ↓ (sb ∪ sc)⁺ ⨾ event ↓ (sb ∪ sc)⁺ ⊆ event ↓ (sb ∪ sc)⁺.","conclusion":"event ↓ (sb ∪ sc)⁺ ⨾ event ↓ (sb ∪ sc)⁺ ⊆ event ↓ (sb ∪ sc)⁺","hypotheses":"","proofString":"rewrite map_rel_seq.\nnow rewrite ct_ct."},{"statement":"event ↓ ((sb ∪ sc)⁺ ⨾ (sb ∪ sc)⁺) ⊆ event ↓ (sb ∪ sc)⁺.","conclusion":"event ↓ ((sb ∪ sc)⁺ ⨾ (sb ∪ sc)⁺) ⊆ event ↓ (sb ∪ sc)⁺","hypotheses":"","proofString":"now rewrite ct_ct."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive SB⁺.","conclusion":"irreflexive SB⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"now apply SB_acyclic."},{"statement":"FWBOB ⨾ FWBOB ⊆ FWBOB.","conclusion":"FWBOB ⨾ FWBOB ⊆ FWBOB","hypotheses":"","proofString":"rewrite FWBOBFWBOB.\nclear; basic_solver 1."},{"statement":"∅₂ ⊆ FWBOB.","conclusion":"∅₂ ⊆ FWBOB","hypotheses":"","proofString":"clear; basic_solver 1."},{"statement":"IPROP ⨾ IPROP ⊆ IPROP.","conclusion":"IPROP ⨾ IPROP ⊆ IPROP","hypotheses":"","proofString":"iord_dom_solver."},{"statement":"PROP ⨾ PROP ⊆ PROP.","conclusion":"PROP ⨾ PROP ⊆ PROP","hypotheses":"","proofString":"iord_dom_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyclic (SB ⨾ RF).","conclusion":"acyclic (SB ⨾ RF)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite SBRF.\napply false_acyclic."},{"statement":"(RF ⨾ SB) ⨾ RF ⨾ SB ⊆ RF ⨾ SB.","conclusion":"(RF ⨾ SB) ⨾ RF ⨾ SB ⊆ RF ⨾ SB","hypotheses":"","proofString":"rewrite !seqA.\nsin_rewrite SBRF.\nclear.\nbasic_solver 1."},{"statement":"RF ⨾ SB ⨾ RF ⨾ SB ⊆ RF ⨾ SB.","conclusion":"RF ⨾ SB ⨾ RF ⨾ SB ⊆ RF ⨾ SB","hypotheses":"","proofString":"sin_rewrite SBRF.\nclear.\nbasic_solver 1."},{"statement":"RF ⨾ ∅₂ ⨾ SB ⊆ RF ⨾ SB.","conclusion":"RF ⨾ ∅₂ ⨾ SB ⊆ RF ⨾ SB","hypotheses":"","proofString":"clear.\nbasic_solver 1."},{"statement":"RF ⨾ ∅₂ ⨾ SB ⊆ RF ⨾ SB.","conclusion":"RF ⨾ ∅₂ ⨾ SB ⊆ RF ⨾ SB","hypotheses":"","proofString":"basic_solver 1."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ rf^?.","conclusion":"event\n↑ (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ rf^?","hypotheses":"","proofString":"clear.\nbasic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ rf^?.","conclusion":"event\n↑ (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ rf^?","hypotheses":"","proofString":"basic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘)\n⊆ fwbob.","conclusion":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘)\n⊆ fwbob","hypotheses":"","proofString":"clear.\nbasic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘)\n⊆ fwbob.","conclusion":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘)\n⊆ fwbob","hypotheses":"","proofString":"basic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘) ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"event\n↑ (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘) ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"","proofString":"clear.\nbasic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘) ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"event\n↑ (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘) ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⨾ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)^?\n  ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","conclusion":"(⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⨾ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)^?\n  ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite !seqA.\nhahn_frame.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : ⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ rf^?)\n  ⨾ ⦗action ↓₁ eq ta_cover⦘\n    ⨾ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)^?\n      ⨾ ⦗action ↓₁ eq ta_cover⦘\n        ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ rf^?)\n  ⨾ ⦗action ↓₁ eq ta_cover⦘\n    ⨾ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)^?\n      ⨾ ⦗action ↓₁ eq ta_cover⦘\n        ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"hahn_frame.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ (⦗W⦘ ⨾ rf^?)\n⨾ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)^?\n    ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","conclusion":"event ↓ (⦗W⦘ ⨾ rf^?)\n⨾ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)^?\n    ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"arewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ (⦗W⦘ ⨾ rf^?)\n⨾ ⦗fun _ : trav_label => True⦘\n  ⨾ (⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗fun _ : trav_label => True⦘)^?\n    ⨾ ⦗fun _ : trav_label => True⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","conclusion":"event ↓ (⦗W⦘ ⨾ rf^?)\n⨾ ⦗fun _ : trav_label => True⦘\n  ⨾ (⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗fun _ : trav_label => True⦘)^?\n    ⨾ ⦗fun _ : trav_label => True⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite !seq_id_l, !seq_id_r.\nrewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ (⦗W⦘ ⨾ rf^?) ⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ (fwbob ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","conclusion":"event ↓ (⦗W⦘ ⨾ rf^?) ⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ (fwbob ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : (event ↓ ⦗W⦘ ⨾ event ↓ rf^?)\n⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ fwbob ⨾ event ↓ ⦗W⦘\n⊆ event ↓ ⦗W⦘ ⨾ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ event ↓ ⦗W⦘.","conclusion":"(event ↓ ⦗W⦘ ⨾ event ↓ rf^?)\n⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ fwbob ⨾ event ↓ ⦗W⦘\n⊆ event ↓ ⦗W⦘ ⨾ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ event ↓ ⦗W⦘","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ ⦗W⦘\n⨾ event ↓ rf^? ⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ fwbob ⨾ event ↓ ⦗W⦘\n⊆ event ↓ ⦗W⦘ ⨾ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ event ↓ ⦗W⦘.","conclusion":"event ↓ ⦗W⦘\n⨾ event ↓ rf^? ⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ fwbob ⨾ event ↓ ⦗W⦘\n⊆ event ↓ ⦗W⦘ ⨾ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ event ↓ ⦗W⦘","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"hahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ rf^? ⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ fwbob\n⊆ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"event ↓ rf^? ⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ fwbob\n⊆ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ (rf^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob) ⊆ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"event ↓ (rf^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob) ⊆ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"apply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"rf^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ (sb ∪ sc)＊ ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"rf^? ⨾ (sb ∪ sc)＊ ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"rf^? ⨾ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ sb^? ⨾ sc^? ⨾ sb^? ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"rf^? ⨾ sb^? ⨾ sc^? ⨾ sb^? ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : ar⁺ ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"ar⁺ ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"apply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc.","conclusion":"ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"eauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : (event ↑ RF)^? ⨾ (event ↑ SB)^? ⨾ event ↑ FWBOB ⊆ ar⁺.","conclusion":"(event ↑ RF)^? ⨾ (event ↑ SB)^? ⨾ event ↑ FWBOB ⊆ ar⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite ERF, eSB_in_sb_sc_ct, EFWBOB.\nrewrite cr_of_cr.\nrewrite cr_of_ct.\napply rf_sb_sc_rt_sb_fwbob_in_ar; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : (rf^?)^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob ⊆ ar⁺.","conclusion":"(rf^?)^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob ⊆ ar⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite cr_of_cr.\nrewrite cr_of_ct.\napply rf_sb_sc_rt_sb_fwbob_in_ar; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob ⊆ ar⁺.","conclusion":"rf^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob ⊆ ar⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"rewrite cr_of_ct.\napply rf_sb_sc_rt_sb_fwbob_in_ar; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ (sb ∪ sc)＊ ⨾ fwbob ⊆ ar⁺.","conclusion":"rf^? ⨾ (sb ∪ sc)＊ ⨾ fwbob ⊆ ar⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"apply rf_sb_sc_rt_sb_fwbob_in_ar; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyc_ext G sc.","conclusion":"acyc_ext G sc","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc)","proofString":"apply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB ∪ RF)⁺ ⨾ FWBOB).","conclusion":"acyclic ((SB ∪ RF)⁺ ⨾ FWBOB)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite path_ut2; auto with lbase.\nrewrite ct_of_trans; auto with lbase.\nrepeat (rewrite rt_of_trans; auto with lbase).\narewrite (SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF).\nrewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1.\nrewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB⁺ ∪ SB＊ ⨾ (RF ⨾ SB⁺)＊ ⨾ RF ⨾ SB＊) ⨾ FWBOB).","conclusion":"acyclic ((SB⁺ ∪ SB＊ ⨾ (RF ⨾ SB⁺)＊ ⨾ RF ⨾ SB＊) ⨾ FWBOB)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite ct_of_trans; auto with lbase.\nrepeat (rewrite rt_of_trans; auto with lbase).\narewrite (SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF).\nrewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1.\nrewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB ∪ SB＊ ⨾ (RF ⨾ SB)＊ ⨾ RF ⨾ SB＊) ⨾ FWBOB).","conclusion":"acyclic ((SB ∪ SB＊ ⨾ (RF ⨾ SB)＊ ⨾ RF ⨾ SB＊) ⨾ FWBOB)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"repeat (rewrite rt_of_trans; auto with lbase).\narewrite (SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF).\nrewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1.\nrewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB ∪ SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⨾ SB^?) ⨾ FWBOB).","conclusion":"acyclic ((SB ∪ SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⨾ SB^?) ⨾ FWBOB)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"arewrite (SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF).\nrewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1.\nrewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF.","conclusion":"SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : ⦗fun _ : trav_label => True⦘\n⨾ (⦗fun _ : trav_label => True⦘ ⨾ RF ∪ RF ⨾ SB ⨾ RF)\n∪ SB ⨾ (⦗fun _ : trav_label => True⦘ ⨾ RF ∪ RF ⨾ SB ⨾ RF) ⊆ RF.","conclusion":"⦗fun _ : trav_label => True⦘\n⨾ (⦗fun _ : trav_label => True⦘ ⨾ RF ∪ RF ⨾ SB ⨾ RF)\n∪ SB ⨾ (⦗fun _ : trav_label => True⦘ ⨾ RF ∪ RF ⨾ SB ⨾ RF) ⊆ RF","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : RF ∪ RF ⨾ SB ⨾ RF ∪ (SB ⨾ RF ∪ SB ⨾ RF ⨾ SB ⨾ RF) ⊆ RF.","conclusion":"RF ∪ RF ⨾ SB ⨾ RF ∪ (SB ⨾ RF ∪ SB ⨾ RF ⨾ SB ⨾ RF) ⊆ RF","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite SBRF.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : RF ∪ RF ⨾ ∅₂ ∪ (∅₂ ∪ SB ⨾ RF ⨾ ∅₂) ⊆ RF.","conclusion":"RF ∪ RF ⨾ ∅₂ ∪ (∅₂ ∪ SB ⨾ RF ⨾ ∅₂) ⊆ RF","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"clear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB ∪ RF ⨾ SB^?) ⨾ FWBOB).","conclusion":"acyclic ((SB ∪ RF ⨾ SB^?) ⨾ FWBOB)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic (FWBOB ⨾ (SB ∪ RF ⨾ SB^?)).","conclusion":"acyclic (FWBOB ⨾ (SB ∪ RF ⨾ SB^?))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic (FWBOB ⨾ SB ∪ FWBOB ⨾ RF ⨾ SB^?).","conclusion":"acyclic (FWBOB ⨾ SB ∪ FWBOB ⨾ RF ⨾ SB^?)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic (FWBOB ⨾ RF ⨾ SB^?).","conclusion":"acyclic (FWBOB ⨾ RF ⨾ SB^?)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic (RF ⨾ SB^? ⨾ FWBOB).","conclusion":"acyclic (RF ⨾ SB^? ⨾ FWBOB)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"rewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic AR.","conclusion":"acyclic AR","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"apply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : transitive sb.","conclusion":"transitive sb","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc)","proofString":"apply sb_trans."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic\n  (PROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP) ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP)＊).","conclusion":"acyclic\n  (PROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP) ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP)＊)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"arewrite (PROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP) ⊆ ∅₂).\niord_dom_solver.\nrewrite seq_false_l.\napply false_acyclic."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : PROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP) ⊆ ∅₂.","conclusion":"PROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP) ⊆ ∅₂","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"iord_dom_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (∅₂ ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP)＊).","conclusion":"acyclic (∅₂ ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP)＊)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite seq_false_l.\napply false_acyclic."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (IPROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR) ⨾ (SB ∪ RF ∪ FWBOB ∪ AR)＊).","conclusion":"acyclic (IPROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR) ⨾ (SB ∪ RF ∪ FWBOB ∪ AR)＊)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"arewrite (IPROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR) ⊆ ∅₂).\niord_dom_solver.\nrewrite seq_false_l.\napply false_acyclic."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : IPROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR) ⊆ ∅₂.","conclusion":"IPROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR) ⊆ ∅₂","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"iord_dom_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (∅₂ ⨾ (SB ∪ RF ∪ FWBOB ∪ AR)＊).","conclusion":"acyclic (∅₂ ⨾ (SB ∪ RF ∪ FWBOB ∪ AR)＊)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite seq_false_l.\napply false_acyclic."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : FWBOB ⊆ SB^? ⨾ FWBOB.","conclusion":"FWBOB ⊆ SB^? ⨾ FWBOB","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"clear.\nbasic_solver 10."},{"statement":"FWBOB ⊆ SB^? ⨾ FWBOB.","conclusion":"FWBOB ⊆ SB^? ⨾ FWBOB","hypotheses":"","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ (RF ∪ SB^? ⨾ FWBOB) ⊆ RF ∪ SB^? ⨾ FWBOB.","conclusion":"SB ⨾ (RF ∪ SB^? ⨾ FWBOB) ⊆ RF ∪ SB^? ⨾ FWBOB","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite seq_union_r.\nrewrite SBRF, union_false_l.\nunionR right.\nhahn_frame_r.\nrewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ RF ∪ SB ⨾ SB^? ⨾ FWBOB ⊆ RF ∪ SB^? ⨾ FWBOB.","conclusion":"SB ⨾ RF ∪ SB ⨾ SB^? ⨾ FWBOB ⊆ RF ∪ SB^? ⨾ FWBOB","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite SBRF, union_false_l.\nunionR right.\nhahn_frame_r.\nrewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ SB^? ⨾ FWBOB ⊆ RF ∪ SB^? ⨾ FWBOB.","conclusion":"SB ⨾ SB^? ⨾ FWBOB ⊆ RF ∪ SB^? ⨾ FWBOB","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"unionR right.\nhahn_frame_r.\nrewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ SB^? ⨾ FWBOB ⊆ SB^? ⨾ FWBOB.","conclusion":"SB ⨾ SB^? ⨾ FWBOB ⊆ SB^? ⨾ FWBOB","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"hahn_frame_r.\nrewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ SB^? ⊆ SB^?.","conclusion":"SB ⨾ SB^? ⊆ SB^?","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB⁺ ⊆ SB.","conclusion":"SB⁺ ⊆ SB","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"apply ct_of_trans; auto with lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (((RF ∪ SB^? ⨾ FWBOB)⁺ ∪ SB ∪ (RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ SB) ⨾ AR).","conclusion":"acyclic (((RF ∪ SB^? ⨾ FWBOB)⁺ ∪ SB ∪ (RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ SB) ⨾ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite !seq_union_l, !seqA.\nrewrite !SBAR.\nrewrite seq_false_r, !union_false_r.\nrewrite path_union, !seq_union_l.\narewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic\n  ((RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ AR ∪ SB ⨾ AR ∪ (RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ SB ⨾ AR).","conclusion":"acyclic\n  ((RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ AR ∪ SB ⨾ AR ∪ (RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ SB ⨾ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite !SBAR.\nrewrite seq_false_r, !union_false_r.\nrewrite path_union, !seq_union_l.\narewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ AR ∪ ∅₂ ∪ (RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ ∅₂).","conclusion":"acyclic ((RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ AR ∪ ∅₂ ∪ (RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ ∅₂)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite seq_false_r, !union_false_r.\nrewrite path_union, !seq_union_l.\narewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ AR).","conclusion":"acyclic ((RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite path_union, !seq_union_l.\narewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (RF⁺ ⨾ AR ∪ ((RF＊ ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF＊) ⨾ AR).","conclusion":"acyclic (RF⁺ ⨾ AR ∪ ((RF＊ ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF＊) ⨾ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"arewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : RF⁺ ⊆ RF.","conclusion":"RF⁺ ⊆ RF","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"apply ct_of_trans; auto with lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (RF ⨾ AR ∪ (RF＊ ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF＊ ⨾ AR).","conclusion":"acyclic (RF ⨾ AR ∪ (RF＊ ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF＊ ⨾ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF＊ ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF＊ ⨾ AR).","conclusion":"acyclic ((RF＊ ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF＊ ⨾ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF^? ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF^? ⨾ AR).","conclusion":"acyclic ((RF^? ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF^? ⨾ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"arewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : RF^? ⨾ AR ⊆ AR.","conclusion":"RF^? ⨾ AR ⊆ AR","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : AR ∪ RF ⨾ AR ⊆ AR.","conclusion":"AR ∪ RF ⨾ AR ⊆ AR","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite RFAR.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : AR ∪ ∅₂ ⊆ AR.","conclusion":"AR ∪ ∅₂ ⊆ AR","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"clear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF^? ⨾ SB^? ⨾ FWBOB)⁺ ⨾ AR).","conclusion":"acyclic ((RF^? ⨾ SB^? ⨾ FWBOB)⁺ ⨾ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"eapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (event ↑ ((RF^? ⨾ SB^? ⨾ FWBOB)⁺ ⨾ AR)).","conclusion":"acyclic (event ↑ ((RF^? ⨾ SB^? ⨾ FWBOB)⁺ ⨾ AR))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((event ↑ (RF^? ⨾ SB^? ⨾ FWBOB))⁺ ⨾ event ↑ AR).","conclusion":"acyclic ((event ↑ (RF^? ⨾ SB^? ⨾ FWBOB))⁺ ⨾ event ↑ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((ar⁺)⁺ ⨾ event ↑ AR).","conclusion":"acyclic ((ar⁺)⁺ ⨾ event ↑ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (ar⁺ ⨾ event ↑ AR).","conclusion":"acyclic (ar⁺ ⨾ event ↑ AR)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (ar⁺ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺).","conclusion":"acyclic (ar⁺ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"arewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺).","conclusion":"acyclic ((ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"acyclic (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"red.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : irreflexive ((ar ∪ rf ⨾ ppo ∩ same_loc)⁺)⁺.","conclusion":"irreflexive ((ar ∪ rf ⨾ ppo ∩ same_loc)⁺)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"rewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : irreflexive (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"irreflexive (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb)","proofString":"apply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","conclusion":"fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc)","proofString":"now apply fsupp_sb."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) SB).","conclusion":"fsupp (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) SB)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"unfold \"SB\".\nrewrite inclusion_t_rt.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite restr_seq_eqv_l.\narewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)).","conclusion":"fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite inclusion_t_rt.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite restr_seq_eqv_l.\narewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)＊ ⨾ ⦗action ↓₁ eq ta_cover⦘)).","conclusion":"fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)＊ ⨾ ⦗action ↓₁ eq ta_cover⦘))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite sb_sc_rt; auto; try apply CONS.\nrewrite restr_seq_eqv_l.\narewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)).","conclusion":"fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ ⦗action ↓₁ eq ta_cover⦘))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite restr_seq_eqv_l.\narewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ ⦗action ↓₁ eq ta_cover⦘))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"arewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ ⦗fun _ : trav_label => True⦘)).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ ⦗fun _ : trav_label => True⦘))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb^? ⨾ sc^? ⨾ sb^?))).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb^? ⨾ sc^? ⨾ sb^?)))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ restr_rel (E \\₁ (fun a : actid => is_init a)) (sb^? ⨾ sc^? ⨾ sb^?)).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ restr_rel (E \\₁ (fun a : actid => is_init a)) (sb^? ⨾ sc^? ⨾ sb^?))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"apply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (restr_rel (E \\₁ (fun a : actid => is_init a)) (sb^? ⨾ sc^? ⨾ sb^?)).","conclusion":"fsupp (restr_rel (E \\₁ (fun a : actid => is_init a)) (sb^? ⨾ sc^? ⨾ sb^?))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (E \\₁ (fun a : actid => is_init a))\n     (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))).","conclusion":"fsupp\n  (restr_rel (E \\₁ (fun a : actid => is_init a))\n     (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb))))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗E \\₁ (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))\n     ⨾ ⦗E \\₁ (fun a : actid => is_init a)⦘).","conclusion":"fsupp\n  (⦗E \\₁ (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))\n     ⨾ ⦗E \\₁ (fun a : actid => is_init a)⦘)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"arewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗E \\₁ (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb))) ⨾ ⦗\n     fun _ : actid => True⦘).","conclusion":"fsupp\n  (⦗E \\₁ (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb))) ⨾ ⦗\n     fun _ : actid => True⦘)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗E \\₁ (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))).","conclusion":"fsupp\n  (⦗E \\₁ (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb))))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"arewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : E \\₁ (fun a : actid => is_init a) ⊆₁ set_compl (fun a : actid => is_init a).","conclusion":"E \\₁ (fun a : actid => is_init a) ⊆₁ set_compl (fun a : actid => is_init a)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"clear; basic_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb))))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb))))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"arewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : sc ⨾ sb ⊆ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb.","conclusion":"sc ⨾ sb ⊆ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : (sc ⨾ ⦗F ∩₁ Sc⦘) ⨾ sb ⊆ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb.","conclusion":"(sc ⨾ ⦗F ∩₁ Sc⦘) ⨾ sb ⊆ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"arewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : F ∩₁ Sc ⊆₁ set_compl (fun a : actid => is_init a).","conclusion":"F ∩₁ Sc ⊆₁ set_compl (fun a : actid => is_init a)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite (init_w WF).\nclear.\nmode_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : F ∩₁ Sc ⊆₁ set_compl W.","conclusion":"F ∩₁ Sc ⊆₁ set_compl W","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"clear.\nmode_solver."},{"statement":"F ∩₁ Sc ⊆₁ set_compl W.","conclusion":"F ∩₁ Sc ⊆₁ set_compl W","hypotheses":"","proofString":"mode_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb\n      ∪ (sc ∪ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n      ∪ (sb ∪ sb\n         ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)))).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb\n      ∪ (sc ∪ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n      ∪ (sb ∪ sb\n         ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n        ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc\n         ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n           ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n        ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc\n         ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n           ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"assert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp ⦗set_compl (fun a : actid => is_init a)⦘.","conclusion":"fsupp ⦗set_compl (fun a : actid => is_init a)⦘","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"now apply fsupp_eqv."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n        ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc\n         ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n           ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n        ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc\n         ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n           ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘)","proofString":"assert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc).","conclusion":"fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘)","proofString":"apply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n        ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc\n         ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n           ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n        ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc\n         ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n           ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)))","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc))","proofString":"repeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc))","proofString":"rewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)\n    ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ sb).","conclusion":"fsupp\n  (((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)\n    ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ sb)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc))","proofString":"rewrite seqA.\napply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  ((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)\n   ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","conclusion":"fsupp\n  ((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)\n   ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc))","proofString":"apply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc).","conclusion":"fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc))","proofString":"rewrite <- !seqA.\napply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp ((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) ⨾ sc).","conclusion":"fsupp ((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) ⨾ sc)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc))","proofString":"apply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc))","proofString":"rewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  ((((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) ⨾ sc)\n    ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ sb).","conclusion":"fsupp\n  ((((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) ⨾ sc)\n    ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ sb)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc))","proofString":"rewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) ⨾ sc)\n   ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","conclusion":"fsupp\n  (((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) ⨾ sc)\n   ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc))","proofString":"repeat (apply fsupp_seq; auto)."},{"statement":"(FSUPPRF : fsupp rf) : fsupp\n  (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)","hypotheses":"(FSUPPRF : fsupp rf)","proofString":"arewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite seq_id_r.\napply fsupp_seq_l_map_rel; auto with lbase.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗fun _ : trav_label => True⦘).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗fun _ : trav_label => True⦘)","hypotheses":"(FSUPPRF : fsupp rf)","proofString":"rewrite seq_id_r.\napply fsupp_seq_l_map_rel; auto with lbase.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?)).","conclusion":"fsupp (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?))","hypotheses":"(FSUPPRF : fsupp rf)","proofString":"apply fsupp_seq_l_map_rel; auto with lbase.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp (⦗W⦘ ⨾ rf^?).","conclusion":"fsupp (⦗W⦘ ⨾ rf^?)","hypotheses":"(FSUPPRF : fsupp rf)","proofString":"arewrite_id ⦗W⦘.\nrewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp (⦗fun _ : actid => True⦘ ⨾ rf^?).","conclusion":"fsupp (⦗fun _ : actid => True⦘ ⨾ rf^?)","hypotheses":"(FSUPPRF : fsupp rf)","proofString":"rewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp rf^?.","conclusion":"fsupp rf^?","hypotheses":"(FSUPPRF : fsupp rf)","proofString":"now apply fsupp_cr."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) : ⦗set_compl (fun a : actid => is_init a)⦘\n⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","conclusion":"⦗set_compl (fun a : actid => is_init a)⦘\n⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺","hypotheses":"(WF : Wf G) (WFSC : wf_sc G sc) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc)","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","conclusion":"fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)","hypotheses":"(WF : Wf G)","proofString":"now apply fsupp_sb."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) FWBOB).","conclusion":"fsupp (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) FWBOB)","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"unfold \"FWBOB\".\narewrite_id ⦗action ↓₁ eq ta_issue⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_r.\nrewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘)).","conclusion":"fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘))","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"arewrite_id ⦗action ↓₁ eq ta_issue⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_r.\nrewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗fun _ : trav_label => True⦘)).","conclusion":"fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗fun _ : trav_label => True⦘))","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"arewrite_id ⦗W⦘.\nrewrite !seq_id_r.\nrewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (fwbob ⨾ ⦗fun _ : actid => True⦘)\n        ⨾ ⦗fun _ : trav_label => True⦘)).","conclusion":"fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (fwbob ⨾ ⦗fun _ : actid => True⦘)\n        ⨾ ⦗fun _ : trav_label => True⦘))","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite !seq_id_r.\nrewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ fwbob)).","conclusion":"fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ fwbob))","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (event ↓ fwbob)).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (event ↓ fwbob))","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (((⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘)\n    ⨾ event ↓ fwbob) ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘).","conclusion":"fsupp\n  (((⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘)\n    ⨾ event ↓ fwbob) ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘)","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"apply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  ((⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘)\n   ⨾ event ↓ fwbob).","conclusion":"fsupp\n  ((⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘)\n   ⨾ event ↓ fwbob)","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  ((⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ ⦗E \\₁ (fun a : actid => is_init a)⦘)\n   ⨾ event ↓ fwbob).","conclusion":"fsupp\n  ((⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ ⦗E \\₁ (fun a : actid => is_init a)⦘)\n   ⨾ event ↓ fwbob)","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ event ↓ fwbob).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ event ↓ fwbob)","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ fwbob)).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ fwbob))","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"apply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ fwbob).","conclusion":"fsupp (⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ fwbob)","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"rewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ sb).","conclusion":"fsupp (⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ sb)","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"arewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : E \\₁ (fun a : actid => is_init a) ⊆₁ set_compl (fun a : actid => is_init a).","conclusion":"E \\₁ (fun a : actid => is_init a) ⊆₁ set_compl (fun a : actid => is_init a)","hypotheses":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))","proofString":"clear; basic_solver."},{"statement":"fsupp\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘).","conclusion":"fsupp\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)","hypotheses":"","proofString":"rewrite <- seqA.\napply fsupp_seq; auto using fsupp_eqv.\napply fsupp_seq_l_map_rel; auto with lbase.\nrepeat (apply fsupp_seq); auto using fsupp_eqv.\nred; ins.\nexists [y]; ins; eauto."},{"statement":"fsupp\n  ((⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (eq ⨾ ⦗W⦘))\n   ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘).","conclusion":"fsupp\n  ((⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (eq ⨾ ⦗W⦘))\n   ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)","hypotheses":"","proofString":"apply fsupp_seq; auto using fsupp_eqv.\napply fsupp_seq_l_map_rel; auto with lbase.\nrepeat (apply fsupp_seq); auto using fsupp_eqv.\nred; ins.\nexists [y]; ins; eauto."},{"statement":"fsupp (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (eq ⨾ ⦗W⦘)).","conclusion":"fsupp (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (eq ⨾ ⦗W⦘))","hypotheses":"","proofString":"apply fsupp_seq_l_map_rel; auto with lbase.\nrepeat (apply fsupp_seq); auto using fsupp_eqv.\nred; ins.\nexists [y]; ins; eauto."},{"statement":"fsupp (eq ⨾ ⦗W⦘).","conclusion":"fsupp (eq ⨾ ⦗W⦘)","hypotheses":"","proofString":"repeat (apply fsupp_seq); auto using fsupp_eqv.\nred; ins.\nexists [y]; ins; eauto."},{"statement":"(y : actid) : exists findom : list actid, forall x : actid, x = y -> In x findom.","conclusion":"exists findom : list actid, forall x : actid, x = y -> In x findom","hypotheses":"(y : actid)","proofString":"exists [y]; ins; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?).","conclusion":"fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G)","proofString":"rewrite crE, seq_union_r.\napply fsupp_union; auto using fsupp_seq, fsupp_eqv, fsupp_sb."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗fun _ : actid => True⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗fun _ : actid => True⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G)","proofString":"apply fsupp_union; auto using fsupp_seq, fsupp_eqv, fsupp_sb."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?))","proofString":"rewrite rtE, seq_union_r.\napply fsupp_union; auto using fsupp_seq, fsupp_eqv.\neapply fsupp_ar_implies_fsupp_ar_rf_ppo_loc; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗fun _ : actid => True⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗fun _ : actid => True⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?))","proofString":"apply fsupp_union; auto using fsupp_seq, fsupp_eqv.\neapply fsupp_ar_implies_fsupp_ar_rf_ppo_loc; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺).","conclusion":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?))","proofString":"eapply fsupp_ar_implies_fsupp_ar_rf_ppo_loc; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) : fsupp sc.","conclusion":"fsupp sc","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊))","proofString":"eapply imm_s_fair_fsupp_sc; eauto.\napply CONS."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) : wf_sc G sc.","conclusion":"wf_sc G sc","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊))","proofString":"apply CONS."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) : sc_per_loc G.","conclusion":"sc_per_loc G","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc)","proofString":"apply coherence_sc_per_loc.\napply CONS."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) : coherence G.","conclusion":"coherence G","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc)","proofString":"apply CONS."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : fsupp co.","conclusion":"fsupp co","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G)","proofString":"apply MF."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ furr G sc).","conclusion":"fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ furr G sc)","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G)","proofString":"eapply fsupp_furr; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : Basics.flip inclusion fr (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr).","conclusion":"Basics.flip inclusion fr (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr)","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G)","proofString":"red.\nclear.\nbasic_solver."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr ⊆ fr.","conclusion":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr ⊆ fr","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G)","proofString":"clear.\nbasic_solver."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr ⊆ fr.","conclusion":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr ⊆ fr","hypotheses":"","proofString":"basic_solver."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : fsupp fr.","conclusion":"fsupp fr","hypotheses":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G)","proofString":"apply MF."},{"statement":"(WF : Wf G) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF\n⊆ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n  ⨾ RF ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","conclusion":"⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF\n⊆ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n  ⨾ RF ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘","hypotheses":"(WF : Wf G)","proofString":"rewrite <- seqA.\napply domb_helper.\nunfold \"RF\".\nrewrite crE.\nrepeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF\n⊆ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF)\n  ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","conclusion":"⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF\n⊆ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF)\n  ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘","hypotheses":"(WF : Wf G)","proofString":"apply domb_helper.\nunfold \"RF\".\nrewrite crE.\nrepeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G)","proofString":"unfold \"RF\".\nrewrite crE.\nrepeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G)","proofString":"rewrite crE.\nrepeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ rf))\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ rf))\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G)","proofString":"repeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘ ∪ ⦗W⦘ ⨾ rf)\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘ ∪ ⦗W⦘ ⨾ rf)\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G)","proofString":"rewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ (event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ∪ event ↓ (⦗W⦘ ⨾ rf))\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ (event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ∪ event ↓ (⦗W⦘ ⨾ rf))\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G)","proofString":"repeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_cover⦘\n   ∪ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_cover⦘\n   ∪ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G)","proofString":"apply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G)","proofString":"unfolder.\nins.\ndesc.\ncongruence."},{"statement":"(WF : Wf G) : forall x y : trav_label,\n(~ is_init (event x) /\\ ta_issue = action x) /\\\n(event x = event y /\\ is_w lab (event x) /\\ True) /\\ ta_cover = action y ->\n~ is_init (event y).","conclusion":"forall x y : trav_label,\n(~ is_init (event x) /\\ ta_issue = action x) /\\\n(event x = event y /\\ is_w lab (event x) /\\ True) /\\ ta_cover = action y ->\n~ is_init (event y)","hypotheses":"(WF : Wf G)","proofString":"ins.\ndesc.\ncongruence."},{"statement":"(WF : Wf G) (x y : trav_label) (REL : (~ is_init (event x) /\\ ta_issue = action x) /\\\n(event x = event y /\\ is_w lab (event x) /\\ True) /\\ ta_cover = action y) : ~ is_init (event y).","conclusion":"~ is_init (event y)","hypotheses":"(WF : Wf G) (x y : trav_label) (REL : (~ is_init (event x) /\\ ta_issue = action x) /\\\n(event x = event y /\\ is_w lab (event x) /\\ True) /\\ ta_cover = action y)","proofString":"desc.\ncongruence."},{"statement":"(WF : Wf G) (x y : trav_label) (REL : ~ is_init (event x)) (REL4 : ta_issue = action x) (REL0 : event x = event y) (REL2 : is_w lab (event x)) (REL3 : True) (REL1 : ta_cover = action y) : ~ is_init (event y).","conclusion":"~ is_init (event y)","hypotheses":"(WF : Wf G) (x y : trav_label) (REL : ~ is_init (event x)) (REL4 : ta_issue = action x) (REL0 : event x = event y) (REL2 : is_w lab (event x)) (REL3 : True) (REL1 : ta_cover = action y)","proofString":"congruence."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G)","proofString":"rewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ rf ⨾ ⦗fun x : actid => ~ is_init x⦘)\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ rf ⨾ ⦗fun x : actid => ~ is_init x⦘)\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : AR ⊆ AR ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","conclusion":"AR ⊆ AR ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"apply domb_helper.\nforward eapply no_ar_rf_ppo_loc_to_init as AR'_NI; eauto.\napply seq_eqv_compl in AR'_NI.\nunfold \"AR\".\nrewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb AR (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb AR (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"forward eapply no_ar_rf_ppo_loc_to_init as AR'_NI; eauto.\napply seq_eqv_compl in AR'_NI.\nunfold \"AR\".\nrewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗fun a : actid => is_init a⦘ ≡ ∅₂) : domb AR (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb AR (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗fun a : actid => is_init a⦘ ≡ ∅₂)","proofString":"apply seq_eqv_compl in AR'_NI.\nunfold \"AR\".\nrewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) : domb AR (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb AR (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)","proofString":"unfold \"AR\".\nrewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) : domb\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)","proofString":"rewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) : domb\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event\n     ↓ (⦗W⦘\n        ⨾ ((ar ∪ rf ⨾ ppo ∩ same_loc)\n           ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event\n     ↓ (⦗W⦘\n        ⨾ ((ar ∪ rf ⨾ ppo ∩ same_loc)\n           ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)","proofString":"rewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) : domb\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event\n     ↓ (⦗W⦘\n        ⨾ (((ar ∪ rf ⨾ ppo ∩ same_loc)\n            ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)＊\n           ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)\n             ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event\n     ↓ (⦗W⦘\n        ⨾ (((ar ∪ rf ⨾ ppo ∩ same_loc)\n            ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)＊\n           ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)\n             ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP\n⊆ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n  ⨾ PROP ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","conclusion":"⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP\n⊆ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n  ⨾ PROP ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"rewrite <- !seqA.\napply domb_helper.\nunfold \"PROP\".\nrewrite inclusion_inter_l1.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP\n⊆ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP)\n  ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","conclusion":"⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP\n⊆ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP)\n  ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"apply domb_helper.\nunfold \"PROP\".\nrewrite inclusion_inter_l1.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"unfold \"PROP\".\nrewrite inclusion_inter_l1.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n       ∩ (fun ta1 ta2 : trav_label =>\n          tid (event ta1) = ta_propagate_tid (action ta2))\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n       ∩ (fun ta1 ta2 : trav_label =>\n          tid (event ta1) = ta_propagate_tid (action ta2))\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"rewrite inclusion_inter_l1.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"arewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"arewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘) ⨾ ⦗fun _ : trav_label => True⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘) ⨾ ⦗fun _ : trav_label => True⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"arewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗fun _ : actid => True⦘)\n       ⨾ ⦗fun _ : trav_label => True⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗fun _ : actid => True⦘)\n       ⨾ ⦗fun _ : trav_label => True⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"rewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^?))\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^?))\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"rewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (event\n   ↓ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr^? ⨾ furr G sc ⨾ co^?))\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (event\n   ↓ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr^? ⨾ furr G sc ⨾ co^?))\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"assert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : sc_per_loc G.","conclusion":"sc_per_loc G","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc)","proofString":"apply coherence_sc_per_loc, CONS."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb\n  (event\n   ↓ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr^? ⨾ furr G sc ⨾ co^?))\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (event\n   ↓ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr^? ⨾ furr G sc ⨾ co^?))\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G)","proofString":"apply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr^? ⨾ furr G sc ⨾ co^?)\n  (set_compl (fun a : actid => is_init a)).","conclusion":"domb (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr^? ⨾ furr G sc ⨾ co^?)\n  (set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G)","proofString":"rewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ fr^? ⨾ furr G sc ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?)\n  (set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ fr^? ⨾ furr G sc ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?)\n  (set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G)","proofString":"rewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (fr ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n     ⨾ furr G sc ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?)\n  (set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (fr ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n     ⨾ furr G sc ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?)\n  (set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G)","proofString":"rewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (fr ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n     ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘\n        ∪ ⦗fun a : actid => is_init a⦘)\n       ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?)\n  (set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (fr ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n     ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘\n        ∪ ⦗fun a : actid => is_init a⦘)\n       ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?)\n  (set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G)","proofString":"basic_solver 10."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) : forall x y z : A, (⦗s⦘ ⨾ r) x y -> (⦗s⦘ ⨾ r) y z -> (⦗s⦘ ⨾ r) x z.","conclusion":"forall x y z : A, (⦗s⦘ ⨾ r) x y -> (⦗s⦘ ⨾ r) y z -> (⦗s⦘ ⨾ r) x z","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r)","proofString":"intros ? ? ? ?%seq_eqv_l ?%seq_eqv_l.\ndesc.\napply seq_eqv_l.\nsplit; auto.\neapply TRANS; eauto."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x /\\ r x y) (H0 : s y /\\ r y z) : (⦗s⦘ ⨾ r) x z.","conclusion":"(⦗s⦘ ⨾ r) x z","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x /\\ r x y) (H0 : s y /\\ r y z)","proofString":"desc.\napply seq_eqv_l.\nsplit; auto.\neapply TRANS; eauto."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x) (H2 : r x y) (H0 : s y) (H1 : r y z) : (⦗s⦘ ⨾ r) x z.","conclusion":"(⦗s⦘ ⨾ r) x z","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x) (H2 : r x y) (H0 : s y) (H1 : r y z)","proofString":"apply seq_eqv_l.\nsplit; auto.\neapply TRANS; eauto."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x) (H2 : r x y) (H0 : s y) (H1 : r y z) : s x /\\ r x z.","conclusion":"s x /\\ r x z","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x) (H2 : r x y) (H0 : s y) (H1 : r y z)","proofString":"split; auto.\neapply TRANS; eauto."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x) (H2 : r x y) (H0 : s y) (H1 : r y z) : r x z.","conclusion":"r x z","hypotheses":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x) (H2 : r x y) (H0 : s y) (H1 : r y z)","proofString":"eapply TRANS; eauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : PROP ⊆ PROP ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","conclusion":"PROP ⊆ PROP ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"apply domb_helper.\nunfold PROP.\nrewrite furr_to_ninit; auto.\nrelsf.\nrewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb PROP (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb PROP (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"unfold PROP.\nrewrite furr_to_ninit; auto.\nrelsf.\nrewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"rewrite furr_to_ninit; auto.\nrelsf.\nrewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘\n           ∪ ⦗fun a : actid => is_init a⦘) ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘\n           ∪ ⦗fun a : actid => is_init a⦘) ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"relsf.\nrewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ co^? ⨾ ⦗W⦘\n        ∪ fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ co^? ⨾ ⦗W⦘\n        ∪ fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"rewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ (event\n      ↓ (fr^?\n         ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)\n           ⨾ co^? ⨾ ⦗W⦘)\n      ∪ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘))\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ (event\n      ↓ (fr^?\n         ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)\n           ⨾ co^? ⨾ ⦗W⦘)\n      ∪ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘))\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"rewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ (event\n      ↓ (fr^?\n         ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)\n           ⨾ co^? ⨾ ⦗W⦘)\n      ∩ (fun ta1 ta2 : trav_label =>\n         tid (event ta1) = ta_propagate_tid (action ta2))\n      ∪ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n        ∩ (fun ta1 ta2 : trav_label =>\n           tid (event ta1) = ta_propagate_tid (action ta2)))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ (event\n      ↓ (fr^?\n         ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)\n           ⨾ co^? ⨾ ⦗W⦘)\n      ∩ (fun ta1 ta2 : trav_label =>\n         tid (event ta1) = ta_propagate_tid (action ta2))\n      ∪ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n        ∩ (fun ta1 ta2 : trav_label =>\n           tid (event ta1) = ta_propagate_tid (action ta2)))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"repeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n   ∪ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n       ∩ (fun ta1 ta2 : trav_label =>\n          tid (event ta1) = ta_propagate_tid (action ta2))\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n   ∪ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n       ∩ (fun ta1 ta2 : trav_label =>\n          tid (event ta1) = ta_propagate_tid (action ta2))\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"apply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"rewrite no_co_to_init; auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)\n          ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)\n          ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"rewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ ((⦗fun _ : actid => True⦘ ∪ fr)\n        ⨾ ⦗fun a : actid => is_init a⦘\n          ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ ((⦗fun _ : actid => True⦘ ∪ fr)\n        ⨾ ⦗fun a : actid => is_init a⦘\n          ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"rewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ ((⦗fun _ : actid => True⦘ ∪ fr ⨾ ⦗fun x : actid => ~ is_init x⦘)\n        ⨾ ⦗fun a : actid => is_init a⦘\n          ⨾ (⦗fun _ : actid => True⦘\n             ∪ co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ ((⦗fun _ : actid => True⦘ ∪ fr ⨾ ⦗fun x : actid => ~ is_init x⦘)\n        ⨾ ⦗fun a : actid => is_init a⦘\n          ⨾ (⦗fun _ : actid => True⦘\n             ∪ co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"unfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ ((⦗fun _ : actid => True⦘ ∪ fr ⨾ ⦗fun x : actid => ~ is_init x⦘)\n        ⨾ ⦗fun a : actid => is_init a⦘\n          ⨾ (⦗fun _ : actid => True⦘\n             ∪ co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ (⋃₁t ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t))⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","conclusion":"domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ ((⦗fun _ : actid => True⦘ ∪ fr ⨾ ⦗fun x : actid => ~ is_init x⦘)\n        ⨾ ⦗fun a : actid => is_init a⦘\n          ⨾ (⦗fun _ : actid => True⦘\n             ∪ co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ (⋃₁t ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t))⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a))","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"unfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : forall x y : trav_label,\nta_cover = action x /\\\n((exists z : actid,\n    (event x = z /\\ True \\/\n     (exists z0 : actid, fr (event x) z0 /\\ z0 = z /\\ ~ is_init z0)) /\\\n    (exists z0 : actid,\n       (z = z0 /\\ is_init z) /\\\n       (exists z1 : actid,\n          (z0 = z1 /\\ True \\/\n           (exists z2 : actid, co z0 z2 /\\ z2 = z1 /\\ ~ is_init z2)) /\\\n          z1 = event y /\\ is_w lab z1))) /\\\n tid (event x) = ta_propagate_tid (action y)) /\\\n(exists y0 : thread_id,\n   (threads_set G y0 /\\ tid_init <> y0) /\\ ta_propagate y0 = action y) ->\n~ is_init (event y).","conclusion":"forall x y : trav_label,\nta_cover = action x /\\\n((exists z : actid,\n    (event x = z /\\ True \\/\n     (exists z0 : actid, fr (event x) z0 /\\ z0 = z /\\ ~ is_init z0)) /\\\n    (exists z0 : actid,\n       (z = z0 /\\ is_init z) /\\\n       (exists z1 : actid,\n          (z0 = z1 /\\ True \\/\n           (exists z2 : actid, co z0 z2 /\\ z2 = z1 /\\ ~ is_init z2)) /\\\n          z1 = event y /\\ is_w lab z1))) /\\\n tid (event x) = ta_propagate_tid (action y)) /\\\n(exists y0 : thread_id,\n   (threads_set G y0 /\\ tid_init <> y0) /\\ ta_propagate y0 = action y) ->\n~ is_init (event y)","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G)","proofString":"ins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) (a0 : actid) (REL11 : True) (REL9 : is_init a0) (REL10 : True) (REL8 : is_w lab a0) (y0 : thread_id) (REL1 : threads_set G y0) (REL3 : tid_init <> y0) (REL2 : ta_propagate y0 = ta_propagate (tid a0)) : ~ is_init a0.","conclusion":"~ is_init a0","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) (a0 : actid) (REL11 : True) (REL9 : is_init a0) (REL10 : True) (REL8 : is_w lab a0) (y0 : thread_id) (REL1 : threads_set G y0) (REL3 : tid_init <> y0) (REL2 : ta_propagate y0 = ta_propagate (tid a0))","proofString":"destruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP ⊆ event ↓ (E × E)^?.","conclusion":"SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"unfold SB, RF, FWBOB, AR, IPROP, PROP.\nrewrite ppo_in_sb, fwbob_in_sb; auto.\nrepeat rewrite inclusion_seq_eqv_l with (dom := action ↓₁ eq _).\nrepeat rewrite inclusion_seq_eqv_r with (dom := action ↓₁ eq _).\nrewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"rewrite ppo_in_sb, fwbob_in_sb; auto.\nrepeat rewrite inclusion_seq_eqv_l with (dom := action ↓₁ eq _).\nrepeat rewrite inclusion_seq_eqv_r with (dom := action ↓₁ eq _).\nrewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"repeat rewrite inclusion_seq_eqv_l with (dom := action ↓₁ eq _).\nrepeat rewrite inclusion_seq_eqv_r with (dom := action ↓₁ eq _).\nrewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ event ↓ (sb ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb ∩ same_loc)⁺ ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ event ↓ (sb ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb ∩ same_loc)⁺ ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"repeat rewrite inclusion_seq_eqv_r with (dom := action ↓₁ eq _).\nrewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (sb ∪ sc)⁺ ∪ event ↓ (⦗W⦘ ⨾ rf^?) ∪ event ↓ (sb ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb ∩ same_loc)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"event ↓ (sb ∪ sc)⁺ ∪ event ↓ (⦗W⦘ ⨾ rf^?) ∪ event ↓ (sb ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb ∩ same_loc)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"rewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (sb ∪ sc)⁺ ∪ event ↓ (⦗W⦘ ⨾ rf^?) ∪ event ↓ (sb ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"event ↓ (sb ∪ sc)⁺ ∪ event ↓ (⦗W⦘ ⨾ rf^?) ∪ event ↓ (sb ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"rewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ∪ sc)⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (ar\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ furr G sc ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ∪ sc)⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (ar\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ furr G sc ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"rewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ∪ sc)⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (ar\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ∪ sc)⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (ar\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"rewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ∪ sc)⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (E × (E \\₁ (fun a : actid => is_init a))\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ∪ sc)⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (E × (E \\₁ (fun a : actid => is_init a))\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"rewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event\n↓ (E × (E \\₁ (fun a : actid => is_init a))\n   ∪ E × (E \\₁ (fun a : actid => is_init a)))⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (E × (E \\₁ (fun a : actid => is_init a))\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"event\n↓ (E × (E \\₁ (fun a : actid => is_init a))\n   ∪ E × (E \\₁ (fun a : actid => is_init a)))⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (E × (E \\₁ (fun a : actid => is_init a))\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"rewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event\n↓ (E × (E \\₁ (fun a : actid => is_init a))\n   ∪ E × (E \\₁ (fun a : actid => is_init a)))⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (E × (E \\₁ (fun a : actid => is_init a))\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"event\n↓ (E × (E \\₁ (fun a : actid => is_init a))\n   ∪ E × (E \\₁ (fun a : actid => is_init a)))⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (E × (E \\₁ (fun a : actid => is_init a))\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"arewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (E × E ∪ E × E)⁺ ∪ event ↓ (⦗W⦘ ⨾ (E × E)^?) ∪ event ↓ (E × E ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (E × E ∪ E × E ⨾ E × E)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","conclusion":"event ↓ (E × E ∪ E × E)⁺ ∪ event ↓ (⦗W⦘ ⨾ (E × E)^?) ∪ event ↓ (E × E ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (E × E ∪ E × E ⨾ E × E)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"remember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) : event ↓ (E_E ∪ E_E)⁺ ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (E_E ∪ E_E ⨾ E_E)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (E_E^? ⨾ E_E^? ⨾ E_E^? ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ event ↓ E_E^?.","conclusion":"event ↓ (E_E ∪ E_E)⁺ ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (E_E ∪ E_E ⨾ E_E)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (E_E^? ⨾ E_E^? ⨾ E_E^? ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ event ↓ E_E^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E)","proofString":"assert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) : transitive E_E.","conclusion":"transitive E_E","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E)","proofString":"apply transitiveI.\nsubst E_E.\nclear.\nbasic_solver."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) : E_E ⨾ E_E ⊆ E_E.","conclusion":"E_E ⨾ E_E ⊆ E_E","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E)","proofString":"subst E_E.\nclear.\nbasic_solver."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : E × E ⨾ E × E ⊆ E × E.","conclusion":"E × E ⨾ E × E ⊆ E × E","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc)","proofString":"clear.\nbasic_solver."},{"statement":"E × E ⨾ E × E ⊆ E × E.","conclusion":"E × E ⨾ E × E ⊆ E × E","hypotheses":"","proofString":"basic_solver."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) (TEE : transitive E_E) : event ↓ (E_E ∪ E_E)⁺ ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (E_E ∪ E_E ⨾ E_E)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (E_E^? ⨾ E_E^? ⨾ E_E^? ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ event ↓ E_E^?.","conclusion":"event ↓ (E_E ∪ E_E)⁺ ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (E_E ∪ E_E ⨾ E_E)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (E_E^? ⨾ E_E^? ⨾ E_E^? ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ event ↓ E_E^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) (TEE : transitive E_E)","proofString":"rewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) (TEE : transitive E_E) : event ↓ (E_E ∪ E_E)⁺ ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ ((⦗W⦘ ⨾ (E_E ∪ E_E ⨾ E_E)⁺) ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (((E_E^? ⨾ E_E^?) ⨾ E_E^?) ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ E_E^?.","conclusion":"event ↓ (E_E ∪ E_E)⁺ ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ ((⦗W⦘ ⨾ (E_E ∪ E_E ⨾ E_E)⁺) ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (((E_E^? ⨾ E_E^?) ⨾ E_E^?) ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ E_E^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) (TEE : transitive E_E)","proofString":"rewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) (TEE : transitive E_E) : event ↓ E_E ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ ((⦗W⦘ ⨾ E_E) ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (E_E^? ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ \nevent ↓ E_E^?.","conclusion":"event ↓ E_E ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ ((⦗W⦘ ⨾ E_E) ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (E_E^? ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ \nevent ↓ E_E^?","hypotheses":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) (TEE : transitive E_E)","proofString":"basic_solver 10."}]}