{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/travorder/TlsEventSets.v","fileSamples":[{"statement":"(T : trav_label -> Prop) (a : trav_action) (e : actid) : (exists y : trav_label, (T y /\\ a = action y) /\\ event y = e) <->\nT (mkTL a e).","proofString":"split; ins; desc; eauto.\ndestruct y; ins; by subst."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (e : actid) (y : trav_label) (H : T y) (H1 : a = action y) (H0 : event y = e) : T (mkTL a e).","proofString":"destruct y; ins; by subst."},{"statement":"(G : execution) (T : trav_label -> Prop) : event\n↑₁ (T ∩₁ action ↓₁ (⋃₁t ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t)))\n≡₁ (⋃₁t ∈ threads_set G \\₁ eq tid_init,\n     event ↑₁ (T ∩₁ action ↓₁ eq (ta_propagate t))).","proofString":"basic_solver 10."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_cover e) ∩₁ action ↓₁ eq ta_cover) ≡₁ eq e.","proofString":"rewrite set_inter_absorb_r; basic_solver."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_reserve <*> s ∩₁ action ↓₁ eq ta_reserve) ≡₁ s.","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\neexists (_, _).\nsplits; ins; eauto."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_reserve <*> s) y) (H1 : ta_reserve = action y) : s (event y).","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_reserve = t /\\ s a) (H1 : ta_reserve = t) : s a.","proofString":"desf."},{"statement":"(s : actid -> Prop) (x : actid) (H : s x) : exists y : trav_label,\n  ((eq ta_reserve <*> s) y /\\ ta_reserve = action y) /\\ event y = x.","proofString":"eexists (_, _).\nsplits; ins; eauto."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_reserve e) ∩₁ action ↓₁ eq ta_reserve) ≡₁ eq e.","proofString":"unfolder; split; ins; desf.\neexists (_, _).\nsplits; ins; eauto."},{"statement":"(x : actid) : exists y : trav_label,\n  (mkTL ta_reserve x = y /\\ ta_reserve = action y) /\\ event y = x.","proofString":"eexists (_, _).\nsplits; ins; eauto."},{"statement":"(tid : thread_id) (e : actid) : event ↑₁ (eq (mkTL (ta_propagate tid) e) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","proofString":"unfolder; split; ins; desf."},{"statement":"(tid : thread_id) (s : actid -> Prop) : event ↑₁ (eq (ta_propagate tid) <*> s ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(tid : thread_id) (s : actid -> Prop) (y : trav_label) (H : (eq (ta_propagate tid) <*> s) y) (H1 : ta_reserve = action y) : False.","proofString":"destruct y; ins.\ndesf."},{"statement":"(tid : thread_id) (s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_propagate tid = t /\\ s a) (H1 : ta_reserve = t) : False.","proofString":"desf."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_reserve <*> s ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_reserve <*> s) y) (H1 : ta_issue = action y) : False.","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_reserve = t /\\ s a) (H1 : ta_issue = t) : False.","proofString":"desf."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_issue <*> s ∩₁ action ↓₁ eq ta_issue) ≡₁ s.","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\neexists (_, _).\nsplits; ins; eauto."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_issue <*> s) y) (H1 : ta_issue = action y) : s (event y).","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_issue = t /\\ s a) (H1 : ta_issue = t) : s a.","proofString":"desf."},{"statement":"(s : actid -> Prop) (x : actid) (H : s x) : exists y : trav_label,\n  ((eq ta_issue <*> s) y /\\ ta_issue = action y) /\\ event y = x.","proofString":"eexists (_, _).\nsplits; ins; eauto."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_cover <*> s ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_cover <*> s) y) (H1 : ta_issue = action y) : False.","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_cover = t /\\ s a) (H1 : ta_issue = t) : False.","proofString":"desf."},{"statement":"(G : execution) (s : actid -> Prop) : event\n↑₁ ((⋃₁t ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t)) <*> s\n    ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(G : execution) (s : actid -> Prop) (y : trav_label) (H : ((fun x : trav_action =>\n  exists y0 : thread_id,\n    (threads_set G y0 /\\ tid_init <> y0) /\\ ta_propagate y0 = x) <*> s) y) (H1 : ta_issue = action y) : False.","proofString":"destruct y; ins.\ndesf."},{"statement":"(G : execution) (s : actid -> Prop) (t : trav_action) (a : actid) (H : (exists y : thread_id,\n   (threads_set G y /\\ tid_init <> y) /\\ ta_propagate y = t) /\\ \ns a) (H1 : ta_issue = t) : False.","proofString":"desf."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_reserve <*> s ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_reserve <*> s) y) (H1 : ta_cover = action y) : False.","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_reserve = t /\\ s a) (H1 : ta_cover = t) : False.","proofString":"desf."},{"statement":"event ↑₁ (action ↓₁ eq ta_reserve ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(y : trav_label) (H : ta_reserve = action y) (H1 : ta_cover = action y) : False.","proofString":"destruct y; ins.\ndesf."},{"statement":"(t : trav_action) (a : actid) (H : ta_reserve = t) (H1 : ta_cover = t) : False.","proofString":"desf."},{"statement":"(w : actid) : event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ eq w.","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ eq w.","proofString":"basic_solver 10."},{"statement":"(tid : thread_id) (e : actid) : event ↑₁ (eq (mkTL (ta_propagate tid) e) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","proofString":"unfolder; split; ins; desf."},{"statement":"(tid : thread_id) (e : actid) : event ↑₁ (eq (mkTL (ta_propagate tid) e) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","proofString":"unfolder; split; ins; desf."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","proofString":"basic_solver 10."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) : event ↑₁ (T1 ∩₁ action ↓₁ eq a) ∩₁ event ↑₁ (T2 ∩₁ action ↓₁ eq a)\n⊆₁ event ↑₁ (T1 ∩₁ T2 ∩₁ action ↓₁ eq a).","proofString":"unfolder.\nins.\ndesc.\ndestruct y, y0; ins; subst.\neauto."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) : forall x : actid,\n(exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n(exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x) ->\nexists y : trav_label, ((T1 y /\\ T2 y) /\\ a = action y) /\\ event y = x.","proofString":"ins.\ndesc.\ndestruct y, y0; ins; subst.\neauto."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) (x : actid) (H : (exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n(exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x)) : exists y : trav_label, ((T1 y /\\ T2 y) /\\ a = action y) /\\ event y = x.","proofString":"desc.\ndestruct y, y0; ins; subst.\neauto."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) (x : actid) (y0 : trav_label) (H : T1 y0) (H4 : a = action y0) (H3 : event y0 = x) (y : trav_label) (H0 : T2 y) (H2 : a = action y) (H1 : event y = x) : exists y1 : trav_label, ((T1 y1 /\\ T2 y1) /\\ a = action y1) /\\ event y1 = x.","proofString":"destruct y, y0; ins; subst.\neauto."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H : T1 (t, x)) (H0 : T2 (t, x)) : exists y : trav_label, ((T1 y /\\ T2 y) /\\ t = action y) /\\ event y = x.","proofString":"eauto."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) : event ↑₁ ((T1 \\₁ T2) ∩₁ action ↓₁ eq a)\n⊆₁ event ↑₁ (T1 ∩₁ action ↓₁ eq a) \\₁ event ↑₁ (T2 ∩₁ action ↓₁ eq a).","proofString":"unfolder.\nins.\ndesc.\ndestruct y; ins; subst.\nsplits; try by eauto.\nintro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) : forall x : actid,\n(exists y : trav_label, ((T1 y /\\ ~ T2 y) /\\ a = action y) /\\ event y = x) ->\n(exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n~ (exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x).","proofString":"ins.\ndesc.\ndestruct y; ins; subst.\nsplits; try by eauto.\nintro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) (x : actid) (H : exists y : trav_label, ((T1 y /\\ ~ T2 y) /\\ a = action y) /\\ event y = x) : (exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n~ (exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x).","proofString":"desc.\ndestruct y; ins; subst.\nsplits; try by eauto.\nintro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) : (exists y : trav_label, (T1 y /\\ t = action y) /\\ event y = x) /\\\n~ (exists y : trav_label, (T2 y /\\ t = action y) /\\ event y = x).","proofString":"splits; try by eauto.\nintro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) : ~ (exists y : trav_label, (T2 y /\\ t = action y) /\\ event y = x).","proofString":"intro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (H0 : exists y : trav_label, (T2 y /\\ t = action y) /\\ event y = x) : False.","proofString":"desc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (y : trav_label) (H0 : T2 y) (H3 : t = action y) (H1 : event y = x) : False.","proofString":"ins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (y : trav_label) (H0 : T2 y) (H3 : t = action y) (H1 : event y = x) : False.","proofString":"desc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (y : trav_label) (H0 : T2 y) (H3 : t = action y) (H1 : event y = x) : False.","proofString":"destruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t0 : trav_action) (H : T1 (t0, x)) (H2 : ~ T2 (t0, x)) (H0 : T2 (t0, x)) : False.","proofString":"done."},{"statement":"(A : actid -> Prop) : event ↑₁ (event ↓₁ A ∩₁ action ↓₁ eq ta_cover) ⊆₁ A.","proofString":"basic_solver."},{"statement":"(A : actid -> Prop) : event ↑₁ (event ↓₁ A ∩₁ action ↓₁ eq ta_issue) ⊆₁ A.","proofString":"basic_solver."},{"statement":"(A : actid -> Prop) : event ↑₁ (event ↓₁ A ∩₁ action ↓₁ eq ta_reserve) ⊆₁ A.","proofString":"basic_solver."},{"statement":"(G : execution) (A : actid -> Prop) : event ↑₁ (event ↓₁ A ∩₁ action ↓₁ is_ta_propagate_to_G G) ⊆₁ A.","proofString":"basic_solver."},{"statement":"(T1 T2 : trav_label -> Prop) : event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ eq ta_cover)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ eq ta_cover)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ eq ta_cover).","proofString":"basic_solver 10."},{"statement":"(T1 T2 : trav_label -> Prop) : event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ eq ta_issue)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ eq ta_issue)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ eq ta_issue).","proofString":"basic_solver 10."},{"statement":"(T1 T2 : trav_label -> Prop) : event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ eq ta_reserve)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ eq ta_reserve)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ eq ta_reserve).","proofString":"basic_solver 10."},{"statement":"(G : execution) (T1 T2 : trav_label -> Prop) : event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ is_ta_propagate_to_G G)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ is_ta_propagate_to_G G)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ is_ta_propagate_to_G G).","proofString":"basic_solver 10."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_cover e) ∩₁ action ↓₁ eq ta_cover) ≡₁ eq e.","proofString":"split; basic_solver."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_issue e) ∩₁ action ↓₁ eq ta_issue) ≡₁ eq e.","proofString":"split; basic_solver."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_reserve e) ∩₁ action ↓₁ eq ta_reserve) ≡₁ eq e.","proofString":"split; basic_solver."},{"statement":"(S : trav_label -> Prop) (NONCOVER : set_disjoint S (action ↓₁ eq ta_cover)) : event ↑₁ (S ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","proofString":"split; basic_solver."},{"statement":"(S : trav_label -> Prop) (NONISSUE : set_disjoint S (action ↓₁ eq ta_issue)) : event ↑₁ (S ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","proofString":"split; basic_solver."},{"statement":"(S : trav_label -> Prop) (NONISSUE : set_disjoint S (action ↓₁ eq ta_reserve)) : event ↑₁ (S ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","proofString":"split; basic_solver."},{"statement":"(G : execution) (S : trav_label -> Prop) (NONPROP : set_disjoint S (action ↓₁ is_ta_propagate_to_G G)) : event ↑₁ (S ∩₁ action ↓₁ is_ta_propagate_to_G G) ≡₁ ∅.","proofString":"split; basic_solver."},{"statement":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover) : event ↑₁ (M ∩₁ action ↓₁ eq ta_cover) ≡₁ event ↑₁ M.","proofString":"split; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize COV.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover) : event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ eq ta_cover).","proofString":"apply set_collect_mori; auto.\ngeneralize COV.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover) : M ⊆₁ M ∩₁ action ↓₁ eq ta_cover.","proofString":"generalize COV.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover) : M ⊆₁ action ↓₁ eq ta_cover -> M ⊆₁ M ∩₁ action ↓₁ eq ta_cover.","proofString":"basic_solver."},{"statement":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue) : event ↑₁ (M ∩₁ action ↓₁ eq ta_issue) ≡₁ event ↑₁ M.","proofString":"split; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize ISS.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue) : event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ eq ta_issue).","proofString":"apply set_collect_mori; auto.\ngeneralize ISS.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue) : M ⊆₁ M ∩₁ action ↓₁ eq ta_issue.","proofString":"generalize ISS.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue) : M ⊆₁ action ↓₁ eq ta_issue -> M ⊆₁ M ∩₁ action ↓₁ eq ta_issue.","proofString":"basic_solver."},{"statement":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve) : event ↑₁ (M ∩₁ action ↓₁ eq ta_reserve) ≡₁ event ↑₁ M.","proofString":"split; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize RES.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve) : event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ eq ta_reserve).","proofString":"apply set_collect_mori; auto.\ngeneralize RES.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve) : M ⊆₁ M ∩₁ action ↓₁ eq ta_reserve.","proofString":"generalize RES.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve) : M ⊆₁ action ↓₁ eq ta_reserve -> M ⊆₁ M ∩₁ action ↓₁ eq ta_reserve.","proofString":"basic_solver."},{"statement":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G) : event ↑₁ (M ∩₁ action ↓₁ is_ta_propagate_to_G G) ≡₁ event ↑₁ M.","proofString":"split; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize PROP.\nbasic_solver."},{"statement":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G) : event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ is_ta_propagate_to_G G).","proofString":"apply set_collect_mori; auto.\ngeneralize PROP.\nbasic_solver."},{"statement":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G) : M ⊆₁ M ∩₁ action ↓₁ is_ta_propagate_to_G G.","proofString":"generalize PROP.\nbasic_solver."},{"statement":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G) : M ⊆₁ action ↓₁ is_ta_propagate_to_G G ->\nM ⊆₁ M ∩₁ action ↓₁ is_ta_propagate_to_G G.","proofString":"basic_solver."},{"statement":"(T : trav_label -> Prop) (e : actid) : reserved T ∪₁ eq e ≡₁ reserved T ∪₁ eq e.","proofString":"basic_solver."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W.","proofString":"rewrite tlsc_I_in_W; eauto.\nbasic_solver."},{"statement":"event ↑₁ (event ↓₁ W) ⊆₁ W.","proofString":"basic_solver."},{"statement":"E ∩₁ W ⊆₁ E.","proofString":"basic_solver 1."},{"statement":"E ∩₁ W ⊆₁ W.","proofString":"basic_solver 1."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E.","proofString":"rewrite (tlsc_E WF TLSCOH).\nbasic_solver."},{"statement":"event ↑₁ (event ↓₁ E ∩₁ action ↓₁ eq ta_issue) ⊆₁ E.","proofString":"basic_solver."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover) ⊆₁ E.","proofString":"rewrite (tlsc_E WF TLSCOH).\nbasic_solver."},{"statement":"event ↑₁ (event ↓₁ E ∩₁ action ↓₁ eq ta_cover) ⊆₁ E.","proofString":"basic_solver."},{"statement":"W ∩₁ event ↑₁ (T ∩₁ action ↓₁ eq ta_cover) ⊆₁ issued T.","proofString":"unfolder.\nins.\ndesc.\nforward eapply tlsc_w_covered_issued with (x := mkTL ta_cover x); eauto.\ndestruct y; ins; vauto."},{"statement":"forall x : actid,\nis_w (lab G) x /\\\n(exists y : trav_label, (T y /\\ ta_cover = action y) /\\ event y = x) ->\nissued T x.","proofString":"ins.\ndesc.\nforward eapply tlsc_w_covered_issued with (x := mkTL ta_cover x); eauto.\ndestruct y; ins; vauto."},{"statement":"(x : actid) (H : is_w (lab G) x /\\\n(exists y : trav_label, (T y /\\ ta_cover = action y) /\\ event y = x)) : issued T x.","proofString":"desc.\nforward eapply tlsc_w_covered_issued with (x := mkTL ta_cover x); eauto.\ndestruct y; ins; vauto."},{"statement":"(x : actid) (H : is_w (lab G) x) (y : trav_label) (H0 : T y) (H2 : ta_cover = action y) (H1 : event y = x) : issued T x.","proofString":"forward eapply tlsc_w_covered_issued with (x := mkTL ta_cover x); eauto.\ndestruct y; ins; vauto."},{"statement":"(x : actid) (H : is_w (lab G) x) (y : trav_label) (H0 : T y) (H2 : ta_cover = action y) (H1 : event y = x) : (T ∩₁ action ↓₁ eq ta_cover ∩₁ event ↓₁ W) (mkTL ta_cover x).","proofString":"destruct y; ins; vauto."},{"statement":"IPROP G ⊆ SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc.","proofString":"eauto with hahn."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : issued T x.","proofString":"red.\nexists (mkTL ta_issue x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)) x.","proofString":"exists (mkTL ta_issue x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (T ∩₁ action ↓₁ eq ta_issue) (mkTL ta_issue x) /\\ event (mkTL ta_issue x) = x.","proofString":"repeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : T (mkTL ta_issue x).","proofString":"destruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : T (mkTL ta_issue x).","proofString":"apply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : init_tls G (mkTL ta_issue x).","proofString":"red.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ (fun a : actid => is_init a))) (mkTL ta_issue x).","proofString":"split; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : covered T x.","proofString":"red.\nexists (mkTL ta_cover x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (event ↑₁ (T ∩₁ action ↓₁ eq ta_cover)) x.","proofString":"exists (mkTL ta_cover x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (T ∩₁ action ↓₁ eq ta_cover) (mkTL ta_cover x) /\\ event (mkTL ta_cover x) = x.","proofString":"repeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : T (mkTL ta_cover x).","proofString":"destruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : T (mkTL ta_cover x).","proofString":"apply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : init_tls G (mkTL ta_cover x).","proofString":"red.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ (fun a : actid => is_init a))) (mkTL ta_cover x).","proofString":"split; basic_solver."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) : exists y : trav_label, (T y /\\ ta_propagate t = action y) /\\ event y = x.","proofString":"exists (mkTL (ta_propagate t) x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) : (T (mkTL (ta_propagate t) x) /\\\n ta_propagate t = action (mkTL (ta_propagate t) x)) /\\\nevent (mkTL (ta_propagate t) x) = x.","proofString":"repeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) : T (mkTL (ta_propagate t) x).","proofString":"destruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : T (mkTL (ta_propagate t) x).","proofString":"apply tls_coh_init.\nred.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : init_tls G (mkTL (ta_propagate t) x).","proofString":"red.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ (fun a : actid => is_init a))) (mkTL (ta_propagate t) x).","proofString":"split; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n  (ta_propagate t).","proofString":"right.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : is_ta_propagate_to_G G (ta_propagate t).","proofString":"red.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : (⋃₁t0 ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t0)) (ta_propagate t).","proofString":"exists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : (threads_set G \\₁ eq tid_init) t /\\ ta_propagate t = ta_propagate t.","proofString":"split; auto."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover)\n⊆₁ E ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover).","proofString":"apply set_subset_inter_r.\nsplit; [apply coveredE|].\napply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover) ⊆₁ E /\\\nevent ↑₁ (T ∩₁ action ↓₁ eq ta_cover)\n⊆₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover).","proofString":"split; [apply coveredE|].\napply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover)\n⊆₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover).","proofString":"apply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"T ∩₁ action ↓₁ eq ta_cover ⊆₁ dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover.","proofString":"apply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"T ⊆₁ dom_cond (iord G sc) T.","proofString":"by apply dom_rel_to_cond."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)\n⊆₁ E ∩₁ W ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue).","proofString":"repeat (apply set_subset_inter_r; split); auto using issuedE, issuedW.\napply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)\n⊆₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue).","proofString":"apply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"T ∩₁ action ↓₁ eq ta_issue ⊆₁ dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue.","proofString":"apply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"T ⊆₁ dom_cond (iord G sc) T.","proofString":"by apply dom_rel_to_cond."},{"statement":"E ∩₁ W ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E.","proofString":"basic_solver."},{"statement":"E ∩₁ W ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W.","proofString":"basic_solver."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E ∩₁ W.","proofString":"apply set_subset_inter_r.\nsplit.\napply issuedE; auto.\napply issuedW; auto."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E /\\\nevent ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W.","proofString":"split.\napply issuedE; auto.\napply issuedW; auto."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E.","proofString":"apply issuedE; auto."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W.","proofString":"apply issuedW; auto."},{"statement":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (COV : (acts_set G ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover)) e) : dom_cond (iord G sc) T (mkTL ta_cover e).","proofString":"apply proj2 in COV as [[a e_] [[AA [=]] [=]]].\nby subst."},{"statement":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (a : trav_action) (e_ : actid) (AA : dom_cond (iord G sc) T (a, e_)) (H0 : ta_cover = a) (H2 : e_ = e) : dom_cond (iord G sc) T (mkTL ta_cover e).","proofString":"by subst."},{"statement":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (ISS : (acts_set G ∩₁ (fun a : actid => is_w (lab G) a)\n ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue)) e) : dom_cond (iord G sc) T (mkTL ta_issue e).","proofString":"apply proj2 in ISS as [[a e_] [[AA [=]] [=]]].\nby subst."},{"statement":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (a : trav_action) (e_ : actid) (AA : dom_cond (iord G sc) T (a, e_)) (H0 : ta_issue = a) (H2 : e_ = e) : dom_cond (iord G sc) T (mkTL ta_issue e).","proofString":"by subst."}]}