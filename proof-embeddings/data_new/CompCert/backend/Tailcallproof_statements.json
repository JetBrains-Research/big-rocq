{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Tailcallproof.v","fileSamples":[{"statement":"(f : code) : forall pc : node, (return_measure f pc <= niter)%nat.","conclusion":"forall pc : node, (return_measure f pc <= niter)%nat","hypotheses":"(f : code)","proofString":"assert (forall n pc, (return_measure_rec n f pc <= n)%nat).\ninduction n; intros; simpl.\nlia.\ndestruct (f!pc); try lia.\ndestruct i; try lia.\ngeneralize (IHn n0).\nlia.\ngeneralize (IHn n0).\nlia.\nintros.\nunfold return_measure.\napply H."},{"statement":"(f : code) : forall (n : nat) (pc : node), (return_measure_rec n f pc <= n)%nat.","conclusion":"forall (n : nat) (pc : node), (return_measure_rec n f pc <= n)%nat","hypotheses":"(f : code)","proofString":"induction n; intros; simpl.\nlia.\ndestruct (f!pc); try lia.\ndestruct i; try lia.\ngeneralize (IHn n0).\nlia.\ngeneralize (IHn n0).\nlia."},{"statement":"(f : code) (pc : node) : (0 <= 0)%nat.","conclusion":"(0 <= 0)%nat","hypotheses":"(f : code) (pc : node)","proofString":"lia."},{"statement":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc : node) : (match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n f s)\n | _ => 0\n end <= S n)%nat.","conclusion":"(match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n f s)\n | _ => 0\n end <= S n)%nat","hypotheses":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc : node)","proofString":"destruct (f!pc); try lia.\ndestruct i; try lia.\ngeneralize (IHn n0).\nlia.\ngeneralize (IHn n0).\nlia."},{"statement":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc : node) (i : instruction) : (match i with\n | Inop s | Iop _ _ _ s => S (return_measure_rec n f s)\n | _ => 0\n end <= S n)%nat.","conclusion":"(match i with\n | Inop s | Iop _ _ _ s => S (return_measure_rec n f s)\n | _ => 0\n end <= S n)%nat","hypotheses":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc : node) (i : instruction)","proofString":"destruct i; try lia.\ngeneralize (IHn n0).\nlia.\ngeneralize (IHn n0).\nlia."},{"statement":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc n0 : node) : (S (return_measure_rec n f n0) <= S n)%nat.","conclusion":"(S (return_measure_rec n f n0) <= S n)%nat","hypotheses":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc n0 : node)","proofString":"generalize (IHn n0).\nlia."},{"statement":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc n0 : node) : (return_measure_rec n f n0 <= n)%nat ->\n(S (return_measure_rec n f n0) <= S n)%nat.","conclusion":"(return_measure_rec n f n0 <= n)%nat ->\n(S (return_measure_rec n f n0) <= S n)%nat","hypotheses":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc n0 : node)","proofString":"lia."},{"statement":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc : node) (o : operation) (l : list reg) (r : reg) (n0 : node) : (S (return_measure_rec n f n0) <= S n)%nat.","conclusion":"(S (return_measure_rec n f n0) <= S n)%nat","hypotheses":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc : node) (o : operation) (l : list reg) (r : reg) (n0 : node)","proofString":"generalize (IHn n0).\nlia."},{"statement":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc : node) (o : operation) (l : list reg) (r : reg) (n0 : node) : (return_measure_rec n f n0 <= n)%nat ->\n(S (return_measure_rec n f n0) <= S n)%nat.","conclusion":"(return_measure_rec n f n0 <= n)%nat ->\n(S (return_measure_rec n f n0) <= S n)%nat","hypotheses":"(f : code) (n : nat) (IHn : forall pc0 : node, (return_measure_rec n f pc0 <= n)%nat) (pc : node) (o : operation) (l : list reg) (r : reg) (n0 : node)","proofString":"lia."},{"statement":"(f : code) (H : forall (n : nat) (pc : node), (return_measure_rec n f pc <= n)%nat) : forall pc : node, (return_measure f pc <= niter)%nat.","conclusion":"forall pc : node, (return_measure f pc <= niter)%nat","hypotheses":"(f : code) (H : forall (n : nat) (pc : node), (return_measure_rec n f pc <= n)%nat)","proofString":"intros.\nunfold return_measure.\napply H."},{"statement":"(f : code) (H : forall (n : nat) (pc0 : node), (return_measure_rec n f pc0 <= n)%nat) (pc : node) : (return_measure f pc <= niter)%nat.","conclusion":"(return_measure f pc <= niter)%nat","hypotheses":"(f : code) (H : forall (n : nat) (pc0 : node), (return_measure_rec n f pc0 <= n)%nat) (pc : node)","proofString":"unfold return_measure.\napply H."},{"statement":"(f : code) (H : forall (n : nat) (pc0 : node), (return_measure_rec n f pc0 <= n)%nat) (pc : node) : (return_measure_rec niter f pc <= niter)%nat.","conclusion":"(return_measure_rec niter f pc <= niter)%nat","hypotheses":"(f : code) (H : forall (n : nat) (pc0 : node), (return_measure_rec n f pc0 <= n)%nat) (pc : node)","proofString":"apply H."},{"statement":"(f : code) (n2 : nat) (pc : node) (H : (0 <= n2)%nat) : (0 <= return_measure_rec n2 f pc)%nat.","conclusion":"(0 <= return_measure_rec n2 f pc)%nat","hypotheses":"(f : code) (n2 : nat) (pc : node) (H : (0 <= n2)%nat)","proofString":"lia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= n2)%nat) : (match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <= return_measure_rec n2 f pc)%nat.","conclusion":"(match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <= return_measure_rec n2 f pc)%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= n2)%nat)","proofString":"destruct n2.\nextlia.\nassert (n1 <= n2)%nat by lia.\nsimpl.\ndestruct f!pc; try lia.\ndestruct i; try lia.\ngeneralize (IHn1 n2 n H0).\nlia.\ngeneralize (IHn1 n2 n H0).\nlia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n2 : nat) (pc0 : node),\n(n1 <= n2)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n2 f pc0)%nat) (pc : node) (H : (S n1 <= 0)%nat) : (match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <= return_measure_rec 0 f pc)%nat.","conclusion":"(match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <= return_measure_rec 0 f pc)%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n2 : nat) (pc0 : node),\n(n1 <= n2)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n2 f pc0)%nat) (pc : node) (H : (S n1 <= 0)%nat)","proofString":"extlia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) : (match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <= return_measure_rec (S n2) f pc)%nat.","conclusion":"(match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <= return_measure_rec (S n2) f pc)%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat)","proofString":"assert (n1 <= n2)%nat by lia.\nsimpl.\ndestruct f!pc; try lia.\ndestruct i; try lia.\ngeneralize (IHn1 n2 n H0).\nlia.\ngeneralize (IHn1 n2 n H0).\nlia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) : (match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <= return_measure_rec (S n2) f pc)%nat.","conclusion":"(match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <= return_measure_rec (S n2) f pc)%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat)","proofString":"simpl.\ndestruct f!pc; try lia.\ndestruct i; try lia.\ngeneralize (IHn1 n2 n H0).\nlia.\ngeneralize (IHn1 n2 n H0).\nlia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) : (match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <=\n match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n2 f s)\n | _ => 0\n end)%nat.","conclusion":"(match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n1 f s)\n | _ => 0\n end <=\n match f ! pc with\n | Some (Inop s) | Some (Iop _ _ _ s) => S (return_measure_rec n2 f s)\n | _ => 0\n end)%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat)","proofString":"destruct f!pc; try lia.\ndestruct i; try lia.\ngeneralize (IHn1 n2 n H0).\nlia.\ngeneralize (IHn1 n2 n H0).\nlia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (i : instruction) : (match i with\n | Inop s | Iop _ _ _ s => S (return_measure_rec n1 f s)\n | _ => 0\n end <=\n match i with\n | Inop s | Iop _ _ _ s => S (return_measure_rec n2 f s)\n | _ => 0\n end)%nat.","conclusion":"(match i with\n | Inop s | Iop _ _ _ s => S (return_measure_rec n1 f s)\n | _ => 0\n end <=\n match i with\n | Inop s | Iop _ _ _ s => S (return_measure_rec n2 f s)\n | _ => 0\n end)%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (i : instruction)","proofString":"destruct i; try lia.\ngeneralize (IHn1 n2 n H0).\nlia.\ngeneralize (IHn1 n2 n H0).\nlia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (n : node) : (S (return_measure_rec n1 f n) <= S (return_measure_rec n2 f n))%nat.","conclusion":"(S (return_measure_rec n1 f n) <= S (return_measure_rec n2 f n))%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (n : node)","proofString":"generalize (IHn1 n2 n H0).\nlia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (n : node) : (return_measure_rec n1 f n <= return_measure_rec n2 f n)%nat ->\n(S (return_measure_rec n1 f n) <= S (return_measure_rec n2 f n))%nat.","conclusion":"(return_measure_rec n1 f n <= return_measure_rec n2 f n)%nat ->\n(S (return_measure_rec n1 f n) <= S (return_measure_rec n2 f n))%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (n : node)","proofString":"lia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (o : operation) (l : list reg) (r : reg) (n : node) : (S (return_measure_rec n1 f n) <= S (return_measure_rec n2 f n))%nat.","conclusion":"(S (return_measure_rec n1 f n) <= S (return_measure_rec n2 f n))%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (o : operation) (l : list reg) (r : reg) (n : node)","proofString":"generalize (IHn1 n2 n H0).\nlia."},{"statement":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (o : operation) (l : list reg) (r : reg) (n : node) : (return_measure_rec n1 f n <= return_measure_rec n2 f n)%nat ->\n(S (return_measure_rec n1 f n) <= S (return_measure_rec n2 f n))%nat.","conclusion":"(return_measure_rec n1 f n <= return_measure_rec n2 f n)%nat ->\n(S (return_measure_rec n1 f n) <= S (return_measure_rec n2 f n))%nat","hypotheses":"(f : code) (n1 : nat) (IHn1 : forall (n0 : nat) (pc0 : node),\n(n1 <= n0)%nat ->\n(return_measure_rec n1 f pc0 <= return_measure_rec n0 f pc0)%nat) (n2 : nat) (pc : node) (H : (S n1 <= S n2)%nat) (H0 : (n1 <= n2)%nat) (o : operation) (l : list reg) (r : reg) (n : node)","proofString":"lia."},{"statement":"(f : function) (n' : nat) (pc : node) (r : reg) (H : false = true) (H0 : (0 <= n')%nat) : 0%nat = return_measure_rec n' (fn_code f) pc.","conclusion":"0%nat = return_measure_rec n' (fn_code f) pc","hypotheses":"(f : function) (n' : nat) (pc : node) (r : reg) (H : false = true) (H0 : (0 <= n')%nat)","proofString":"congruence."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (H : match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s r\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r0)) => Reg.eq r0 r\n| Some (Ireturn None) => true\n| _ => false\nend = true) (H0 : (S n <= n')%nat) : match (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend = return_measure_rec n' (fn_code f) pc.","conclusion":"match (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend = return_measure_rec n' (fn_code f) pc","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (H : match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s r\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r0)) => Reg.eq r0 r\n| Some (Ireturn None) => true\n| _ => false\nend = true) (H0 : (S n <= n')%nat)","proofString":"destruct n'.\nextlia.\nsimpl.\ndestruct (fn_code f)!pc; try congruence.\ndestruct i; try congruence.\ndecEq.\napply IHn with r.\nauto.\nlia.\ndestruct (is_move_operation o l); try congruence.\ndestruct (Reg.eq r r1); try congruence.\ndecEq.\napply IHn with r0.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n' : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n')%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n' (fn_code f) pc0) (pc : node) (r : reg) (H : match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s r\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r0)) => Reg.eq r0 r\n| Some (Ireturn None) => true\n| _ => false\nend = true) (H0 : (S n <= 0)%nat) : match (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend = return_measure_rec 0 (fn_code f) pc.","conclusion":"match (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend = return_measure_rec 0 (fn_code f) pc","hypotheses":"(f : function) (n : nat) (IHn : forall (n' : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n')%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n' (fn_code f) pc0) (pc : node) (r : reg) (H : match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s r\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r0)) => Reg.eq r0 r\n| Some (Ireturn None) => true\n| _ => false\nend = true) (H0 : (S n <= 0)%nat)","proofString":"extlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (H : match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s r\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r0)) => Reg.eq r0 r\n| Some (Ireturn None) => true\n| _ => false\nend = true) (H0 : (S n <= S n')%nat) : match (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend = return_measure_rec (S n') (fn_code f) pc.","conclusion":"match (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend = return_measure_rec (S n') (fn_code f) pc","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (H : match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s r\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r0)) => Reg.eq r0 r\n| Some (Ireturn None) => true\n| _ => false\nend = true) (H0 : (S n <= S n')%nat)","proofString":"simpl.\ndestruct (fn_code f)!pc; try congruence.\ndestruct i; try congruence.\ndecEq.\napply IHn with r.\nauto.\nlia.\ndestruct (is_move_operation o l); try congruence.\ndestruct (Reg.eq r r1); try congruence.\ndecEq.\napply IHn with r0.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (H : match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s r\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r0)) => Reg.eq r0 r\n| Some (Ireturn None) => true\n| _ => false\nend = true) (H0 : (S n <= S n')%nat) : match (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend =\nmatch (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n' (fn_code f) s)\n| _ => 0%nat\nend.","conclusion":"match (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend =\nmatch (fn_code f) ! pc with\n| Some (Inop s) | Some (Iop _ _ _ s) =>\n    S (return_measure_rec n' (fn_code f) s)\n| _ => 0%nat\nend","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (H : match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s r\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r0)) => Reg.eq r0 r\n| Some (Ireturn None) => true\n| _ => false\nend = true) (H0 : (S n <= S n')%nat)","proofString":"destruct (fn_code f)!pc; try congruence.\ndestruct i; try congruence.\ndecEq.\napply IHn with r.\nauto.\nlia.\ndestruct (is_move_operation o l); try congruence.\ndestruct (Reg.eq r r1); try congruence.\ndecEq.\napply IHn with r0.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (i : instruction) (H : match i with\n| Inop s => is_return n f s r\n| Iop op args dst s =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Ireturn (Some r0) => Reg.eq r0 r\n| Ireturn None => true\n| _ => false\nend = true) (H0 : (S n <= S n')%nat) : match i with\n| Inop s | Iop _ _ _ s => S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend =\nmatch i with\n| Inop s | Iop _ _ _ s => S (return_measure_rec n' (fn_code f) s)\n| _ => 0%nat\nend.","conclusion":"match i with\n| Inop s | Iop _ _ _ s => S (return_measure_rec n (fn_code f) s)\n| _ => 0%nat\nend =\nmatch i with\n| Inop s | Iop _ _ _ s => S (return_measure_rec n' (fn_code f) s)\n| _ => 0%nat\nend","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (i : instruction) (H : match i with\n| Inop s => is_return n f s r\n| Iop op args dst s =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq r src then is_return n f s dst else false\n    | None => false\n    end\n| Ireturn (Some r0) => Reg.eq r0 r\n| Ireturn None => true\n| _ => false\nend = true) (H0 : (S n <= S n')%nat)","proofString":"destruct i; try congruence.\ndecEq.\napply IHn with r.\nauto.\nlia.\ndestruct (is_move_operation o l); try congruence.\ndestruct (Reg.eq r r1); try congruence.\ndecEq.\napply IHn with r0.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (n0 : node) (H : is_return n f n0 r = true) (H0 : (S n <= S n')%nat) : S (return_measure_rec n (fn_code f) n0) =\nS (return_measure_rec n' (fn_code f) n0).","conclusion":"S (return_measure_rec n (fn_code f) n0) =\nS (return_measure_rec n' (fn_code f) n0)","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (n0 : node) (H : is_return n f n0 r = true) (H0 : (S n <= S n')%nat)","proofString":"decEq.\napply IHn with r.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (n0 : node) (H : is_return n f n0 r = true) (H0 : (S n <= S n')%nat) : return_measure_rec n (fn_code f) n0 = return_measure_rec n' (fn_code f) n0.","conclusion":"return_measure_rec n (fn_code f) n0 = return_measure_rec n' (fn_code f) n0","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (n0 : node) (H : is_return n f n0 r = true) (H0 : (S n <= S n')%nat)","proofString":"apply IHn with r.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (n0 : node) (H : is_return n f n0 r = true) (H0 : (S n <= S n')%nat) : is_return n f n0 r = true.","conclusion":"is_return n f n0 r = true","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (n0 : node) (H : is_return n f n0 r = true) (H0 : (S n <= S n')%nat)","proofString":"auto."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (n0 : node) (H : is_return n f n0 r = true) (H0 : (S n <= S n')%nat) : (n <= n')%nat.","conclusion":"(n <= n')%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r0 : reg),\nis_return n f pc0 r0 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (n0 : node) (H : is_return n f n0 r = true) (H0 : (S n <= S n')%nat)","proofString":"lia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r1 : reg),\nis_return n f pc0 r1 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (H : match is_move_operation o l with\n| Some src => if Reg.eq r src then is_return n f n0 r0 else false\n| None => false\nend = true) (H0 : (S n <= S n')%nat) : S (return_measure_rec n (fn_code f) n0) =\nS (return_measure_rec n' (fn_code f) n0).","conclusion":"S (return_measure_rec n (fn_code f) n0) =\nS (return_measure_rec n' (fn_code f) n0)","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r1 : reg),\nis_return n f pc0 r1 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (H : match is_move_operation o l with\n| Some src => if Reg.eq r src then is_return n f n0 r0 else false\n| None => false\nend = true) (H0 : (S n <= S n')%nat)","proofString":"destruct (is_move_operation o l); try congruence.\ndestruct (Reg.eq r r1); try congruence.\ndecEq.\napply IHn with r0.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (H : (if Reg.eq r r1 then is_return n f n0 r0 else false) = true) (H0 : (S n <= S n')%nat) : S (return_measure_rec n (fn_code f) n0) =\nS (return_measure_rec n' (fn_code f) n0).","conclusion":"S (return_measure_rec n (fn_code f) n0) =\nS (return_measure_rec n' (fn_code f) n0)","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (H : (if Reg.eq r r1 then is_return n f n0 r0 else false) = true) (H0 : (S n <= S n')%nat)","proofString":"destruct (Reg.eq r r1); try congruence.\ndecEq.\napply IHn with r0.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (e : r = r1) (H : is_return n f n0 r0 = true) (H0 : (S n <= S n')%nat) : S (return_measure_rec n (fn_code f) n0) =\nS (return_measure_rec n' (fn_code f) n0).","conclusion":"S (return_measure_rec n (fn_code f) n0) =\nS (return_measure_rec n' (fn_code f) n0)","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (e : r = r1) (H : is_return n f n0 r0 = true) (H0 : (S n <= S n')%nat)","proofString":"decEq.\napply IHn with r0.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (e : r = r1) (H : is_return n f n0 r0 = true) (H0 : (S n <= S n')%nat) : return_measure_rec n (fn_code f) n0 = return_measure_rec n' (fn_code f) n0.","conclusion":"return_measure_rec n (fn_code f) n0 = return_measure_rec n' (fn_code f) n0","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (e : r = r1) (H : is_return n f n0 r0 = true) (H0 : (S n <= S n')%nat)","proofString":"apply IHn with r0.\nauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (e : r = r1) (H : is_return n f n0 r0 = true) (H0 : (S n <= S n')%nat) : is_return n f n0 r0 = true.","conclusion":"is_return n f n0 r0 = true","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (e : r = r1) (H : is_return n f n0 r0 = true) (H0 : (S n <= S n')%nat)","proofString":"auto."},{"statement":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (e : r = r1) (H : is_return n f n0 r0 = true) (H0 : (S n <= S n')%nat) : (n <= n')%nat.","conclusion":"(n <= n')%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (n'0 : nat) (pc0 : node) (r2 : reg),\nis_return n f pc0 r2 = true ->\n(n <= n'0)%nat ->\nreturn_measure_rec n (fn_code f) pc0 = return_measure_rec n'0 (fn_code f) pc0) (n' : nat) (pc : node) (r : reg) (o : operation) (l : list reg) (r0 : reg) (n0 : node) (r1 : reg) (e : r = r1) (H : is_return n f n0 r0 = true) (H0 : (S n <= S n')%nat)","proofString":"lia."},{"statement":"(f : function) (pc : node) (rret : reg) (H : is_return 0 f pc rret = true) (H0 : (0 <= niter)%nat) : is_return_spec f pc rret.","conclusion":"is_return_spec f pc rret","hypotheses":"(f : function) (pc : node) (rret : reg) (H : is_return 0 f pc rret = true) (H0 : (0 <= niter)%nat)","proofString":"simpl in H.\ncongruence."},{"statement":"(f : function) (pc : node) (rret : reg) (H : false = true) (H0 : (0 <= niter)%nat) : is_return_spec f pc rret.","conclusion":"is_return_spec f pc rret","hypotheses":"(f : function) (pc : node) (rret : reg) (H : false = true) (H0 : (0 <= niter)%nat)","proofString":"congruence."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) : is_return_spec f pc rret.","conclusion":"is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat)","proofString":"generalize H.\nsimpl.\ncaseEq ((fn_code f)!pc); try congruence.\nintro i.\ncaseEq i; try congruence.\nintros s; intros.\neapply is_return_nop; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc rret); auto.\nrewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia.\nintros op args dst s EQ1 EQ2.\ncaseEq (is_move_operation op args); try congruence.\nintros src IMO.\ndestruct (Reg.eq rret src); try congruence.\nsubst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia.\nintros or EQ1 EQ2.\ndestruct or; intros.\nassert (r = rret).\neapply proj_sumbool_true; eauto.\nsubst r.\napply is_return_some; auto.\napply is_return_none; auto."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) : is_return (S n) f pc rret = true -> is_return_spec f pc rret.","conclusion":"is_return (S n) f pc rret = true -> is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat)","proofString":"simpl.\ncaseEq ((fn_code f)!pc); try congruence.\nintro i.\ncaseEq i; try congruence.\nintros s; intros.\neapply is_return_nop; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc rret); auto.\nrewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia.\nintros op args dst s EQ1 EQ2.\ncaseEq (is_move_operation op args); try congruence.\nintros src IMO.\ndestruct (Reg.eq rret src); try congruence.\nsubst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia.\nintros or EQ1 EQ2.\ndestruct or; intros.\nassert (r = rret).\neapply proj_sumbool_true; eauto.\nsubst r.\napply is_return_some; auto.\napply is_return_none; auto."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) : match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s rret\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq rret src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r)) => Reg.eq r rret\n| Some (Ireturn None) => true\n| _ => false\nend = true -> is_return_spec f pc rret.","conclusion":"match (fn_code f) ! pc with\n| Some (Inop s) => is_return n f s rret\n| Some (Iop op args dst s) =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq rret src then is_return n f s dst else false\n    | None => false\n    end\n| Some (Ireturn (Some r)) => Reg.eq r rret\n| Some (Ireturn None) => true\n| _ => false\nend = true -> is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat)","proofString":"caseEq ((fn_code f)!pc); try congruence.\nintro i.\ncaseEq i; try congruence.\nintros s; intros.\neapply is_return_nop; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc rret); auto.\nrewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia.\nintros op args dst s EQ1 EQ2.\ncaseEq (is_move_operation op args); try congruence.\nintros src IMO.\ndestruct (Reg.eq rret src); try congruence.\nsubst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia.\nintros or EQ1 EQ2.\ndestruct or; intros.\nassert (r = rret).\neapply proj_sumbool_true; eauto.\nsubst r.\napply is_return_some; auto.\napply is_return_none; auto."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) : forall i : instruction,\n(fn_code f) ! pc = Some i ->\nmatch i with\n| Inop s => is_return n f s rret\n| Iop op args dst s =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq rret src then is_return n f s dst else false\n    | None => false\n    end\n| Ireturn (Some r) => Reg.eq r rret\n| Ireturn None => true\n| _ => false\nend = true -> is_return_spec f pc rret.","conclusion":"forall i : instruction,\n(fn_code f) ! pc = Some i ->\nmatch i with\n| Inop s => is_return n f s rret\n| Iop op args dst s =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq rret src then is_return n f s dst else false\n    | None => false\n    end\n| Ireturn (Some r) => Reg.eq r rret\n| Ireturn None => true\n| _ => false\nend = true -> is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat)","proofString":"intro i.\ncaseEq i; try congruence.\nintros s; intros.\neapply is_return_nop; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc rret); auto.\nrewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia.\nintros op args dst s EQ1 EQ2.\ncaseEq (is_move_operation op args); try congruence.\nintros src IMO.\ndestruct (Reg.eq rret src); try congruence.\nsubst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia.\nintros or EQ1 EQ2.\ndestruct or; intros.\nassert (r = rret).\neapply proj_sumbool_true; eauto.\nsubst r.\napply is_return_some; auto.\napply is_return_none; auto."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) : (fn_code f) ! pc = Some i ->\nmatch i with\n| Inop s => is_return n f s rret\n| Iop op args dst s =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq rret src then is_return n f s dst else false\n    | None => false\n    end\n| Ireturn (Some r) => Reg.eq r rret\n| Ireturn None => true\n| _ => false\nend = true -> is_return_spec f pc rret.","conclusion":"(fn_code f) ! pc = Some i ->\nmatch i with\n| Inop s => is_return n f s rret\n| Iop op args dst s =>\n    match is_move_operation op args with\n    | Some src => if Reg.eq rret src then is_return n f s dst else false\n    | None => false\n    end\n| Ireturn (Some r) => Reg.eq r rret\n| Ireturn None => true\n| _ => false\nend = true -> is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction)","proofString":"caseEq i; try congruence.\nintros s; intros.\neapply is_return_nop; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc rret); auto.\nrewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia.\nintros op args dst s EQ1 EQ2.\ncaseEq (is_move_operation op args); try congruence.\nintros src IMO.\ndestruct (Reg.eq rret src); try congruence.\nsubst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia.\nintros or EQ1 EQ2.\ndestruct or; intros.\nassert (r = rret).\neapply proj_sumbool_true; eauto.\nsubst r.\napply is_return_some; auto.\napply is_return_none; auto."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) : forall n0 : node,\ni = Inop n0 ->\n(fn_code f) ! pc = Some (Inop n0) ->\nis_return n f n0 rret = true -> is_return_spec f pc rret.","conclusion":"forall n0 : node,\ni = Inop n0 ->\n(fn_code f) ! pc = Some (Inop n0) ->\nis_return n f n0 rret = true -> is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction)","proofString":"intros s; intros.\neapply is_return_nop; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc rret); auto.\nrewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : is_return_spec f pc rret.","conclusion":"is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"eapply is_return_nop; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc rret); auto.\nrewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : is_return_spec f s rret.","conclusion":"is_return_spec f s rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"eapply IHn; eauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : (n <= niter)%nat.","conclusion":"(n <= niter)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"lia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : (return_measure (fn_code f) s < return_measure (fn_code f) pc)%nat.","conclusion":"(return_measure (fn_code f) s < return_measure (fn_code f) pc)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"unfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc rret); auto.\nrewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : (return_measure_rec niter (fn_code f) s <\n return_measure_rec niter (fn_code f) pc)%nat.","conclusion":"(return_measure_rec niter (fn_code f) s <\n return_measure_rec niter (fn_code f) pc)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"rewrite <- (is_return_measure_rec f (S n) niter pc rret); auto.\nrewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : (return_measure_rec niter (fn_code f) s <\n return_measure_rec (S n) (fn_code f) pc)%nat.","conclusion":"(return_measure_rec niter (fn_code f) s <\n return_measure_rec (S n) (fn_code f) pc)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"rewrite <- (is_return_measure_rec f n niter s rret); auto.\nsimpl.\nrewrite H2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : (return_measure_rec n (fn_code f) s < return_measure_rec (S n) (fn_code f) pc)%nat.","conclusion":"(return_measure_rec n (fn_code f) s < return_measure_rec (S n) (fn_code f) pc)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"simpl.\nrewrite H2.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : (return_measure_rec n (fn_code f) s <\n match (fn_code f) ! pc with\n | Some (Inop s0) | Some (Iop _ _ _ s0) =>\n     S (return_measure_rec n (fn_code f) s0)\n | _ => 0\n end)%nat.","conclusion":"(return_measure_rec n (fn_code f) s <\n match (fn_code f) ! pc with\n | Some (Inop s0) | Some (Iop _ _ _ s0) =>\n     S (return_measure_rec n (fn_code f) s0)\n | _ => 0\n end)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"rewrite H2.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : (return_measure_rec n (fn_code f) s < S (return_measure_rec n (fn_code f) s))%nat.","conclusion":"(return_measure_rec n (fn_code f) s < S (return_measure_rec n (fn_code f) s))%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"lia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true) : (n <= niter)%nat.","conclusion":"(n <= niter)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (s : node) (H1 : i = Inop s) (H2 : (fn_code f) ! pc = Some (Inop s)) (H3 : is_return n f s rret = true)","proofString":"lia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) : forall (o : operation) (l : list reg) (r : reg) (n0 : node),\ni = Iop o l r n0 ->\n(fn_code f) ! pc = Some (Iop o l r n0) ->\nmatch is_move_operation o l with\n| Some src => if Reg.eq rret src then is_return n f n0 r else false\n| None => false\nend = true -> is_return_spec f pc rret.","conclusion":"forall (o : operation) (l : list reg) (r : reg) (n0 : node),\ni = Iop o l r n0 ->\n(fn_code f) ! pc = Some (Iop o l r n0) ->\nmatch is_move_operation o l with\n| Some src => if Reg.eq rret src then is_return n f n0 r else false\n| None => false\nend = true -> is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction)","proofString":"intros op args dst s EQ1 EQ2.\ncaseEq (is_move_operation op args); try congruence.\nintros src IMO.\ndestruct (Reg.eq rret src); try congruence.\nsubst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) : match is_move_operation op args with\n| Some src => if Reg.eq rret src then is_return n f s dst else false\n| None => false\nend = true -> is_return_spec f pc rret.","conclusion":"match is_move_operation op args with\n| Some src => if Reg.eq rret src then is_return n f s dst else false\n| None => false\nend = true -> is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s))","proofString":"caseEq (is_move_operation op args); try congruence.\nintros src IMO.\ndestruct (Reg.eq rret src); try congruence.\nsubst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) : forall r : reg,\nis_move_operation op args = Some r ->\n(if Reg.eq rret r then is_return n f s dst else false) = true ->\nis_return_spec f pc rret.","conclusion":"forall r : reg,\nis_move_operation op args = Some r ->\n(if Reg.eq rret r then is_return n f s dst else false) = true ->\nis_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s))","proofString":"intros src IMO.\ndestruct (Reg.eq rret src); try congruence.\nsubst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (src : reg) (IMO : is_move_operation op args = Some src) : (if Reg.eq rret src then is_return n f s dst else false) = true ->\nis_return_spec f pc rret.","conclusion":"(if Reg.eq rret src then is_return n f s dst else false) = true ->\nis_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (src : reg) (IMO : is_move_operation op args = Some src)","proofString":"destruct (Reg.eq rret src); try congruence.\nsubst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (src : reg) (IMO : is_move_operation op args = Some src) (e : rret = src) : is_return n f s dst = true -> is_return_spec f pc rret.","conclusion":"is_return n f s dst = true -> is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (src : reg) (IMO : is_move_operation op args = Some src) (e : rret = src)","proofString":"subst rret.\nintro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (IMO : is_move_operation op args = Some src) : is_return n f s dst = true -> is_return_spec f pc src.","conclusion":"is_return n f s dst = true -> is_return_spec f pc src","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (IMO : is_move_operation op args = Some src)","proofString":"intro.\nexploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (IMO : is_move_operation op args = Some src) (H1 : is_return n f s dst = true) : is_return_spec f pc src.","conclusion":"is_return_spec f pc src","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (IMO : is_move_operation op args = Some src) (H1 : is_return n f s dst = true)","proofString":"exploit is_move_operation_correct; eauto.\nintros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (IMO : is_move_operation op args = Some src) (H1 : is_return n f s dst = true) : op = Omove /\\ args = src :: nil -> is_return_spec f pc src.","conclusion":"op = Omove /\\ args = src :: nil -> is_return_spec f pc src","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (IMO : is_move_operation op args = Some src) (H1 : is_return n f s dst = true)","proofString":"intros [A B].\nsubst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (IMO : is_move_operation op args = Some src) (H1 : is_return n f s dst = true) (A : op = Omove) (B : args = src :: nil) : is_return_spec f pc src.","conclusion":"is_return_spec f pc src","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (i : instruction) (op : operation) (args : list reg) (dst : reg) (s : node) (EQ1 : i = Iop op args dst s) (EQ2 : (fn_code f) ! pc = Some (Iop op args dst s)) (IMO : is_move_operation op args = Some src) (H1 : is_return n f s dst = true) (A : op = Omove) (B : args = src :: nil)","proofString":"subst.\neapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : is_return_spec f pc src.","conclusion":"is_return_spec f pc src","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"eapply is_return_move; eauto.\neapply IHn; eauto.\nlia.\nunfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : is_return_spec f s dst.","conclusion":"is_return_spec f s dst","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"eapply IHn; eauto.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : (n <= niter)%nat.","conclusion":"(n <= niter)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"lia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : (return_measure (fn_code f) s < return_measure (fn_code f) pc)%nat.","conclusion":"(return_measure (fn_code f) s < return_measure (fn_code f) pc)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"unfold return_measure.\nrewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : (return_measure_rec niter (fn_code f) s <\n return_measure_rec niter (fn_code f) pc)%nat.","conclusion":"(return_measure_rec niter (fn_code f) s <\n return_measure_rec niter (fn_code f) pc)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"rewrite <- (is_return_measure_rec f (S n) niter pc src); auto.\nrewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : (return_measure_rec niter (fn_code f) s <\n return_measure_rec (S n) (fn_code f) pc)%nat.","conclusion":"(return_measure_rec niter (fn_code f) s <\n return_measure_rec (S n) (fn_code f) pc)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"rewrite <- (is_return_measure_rec f n niter s dst); auto.\nsimpl.\nrewrite EQ2.\nlia.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : (return_measure_rec n (fn_code f) s < return_measure_rec (S n) (fn_code f) pc)%nat.","conclusion":"(return_measure_rec n (fn_code f) s < return_measure_rec (S n) (fn_code f) pc)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"simpl.\nrewrite EQ2.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : (return_measure_rec n (fn_code f) s <\n match (fn_code f) ! pc with\n | Some (Inop s0) | Some (Iop _ _ _ s0) =>\n     S (return_measure_rec n (fn_code f) s0)\n | _ => 0\n end)%nat.","conclusion":"(return_measure_rec n (fn_code f) s <\n match (fn_code f) ! pc with\n | Some (Inop s0) | Some (Iop _ _ _ s0) =>\n     S (return_measure_rec n (fn_code f) s0)\n | _ => 0\n end)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"rewrite EQ2.\nlia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : (return_measure_rec n (fn_code f) s < S (return_measure_rec n (fn_code f) s))%nat.","conclusion":"(return_measure_rec n (fn_code f) s < S (return_measure_rec n (fn_code f) s))%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"lia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true) : (n <= niter)%nat.","conclusion":"(n <= niter)%nat","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret : reg),\nis_return n f pc0 rret = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret) (pc : node) (src : reg) (H : is_return (S n) f pc src = true) (H0 : (S n <= niter)%nat) (dst : reg) (s : node) (EQ2 : (fn_code f) ! pc = Some (Iop Omove (src :: nil) dst s)) (IMO : is_move_operation Omove (src :: nil) = Some src) (H1 : is_return n f s dst = true)","proofString":"lia."},{"statement":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (EQ1 : i = Ireturn None) (EQ2 : (fn_code f) ! pc = Some (Ireturn None)) (H1 : true = true) : is_return_spec f pc rret.","conclusion":"is_return_spec f pc rret","hypotheses":"(f : function) (n : nat) (IHn : forall (pc0 : node) (rret0 : reg),\nis_return n f pc0 rret0 = true ->\n(n <= niter)%nat -> is_return_spec f pc0 rret0) (pc : node) (rret : reg) (H : is_return (S n) f pc rret = true) (H0 : (S n <= niter)%nat) (i : instruction) (EQ1 : i = Ireturn None) (EQ2 : (fn_code f) ! pc = Some (Ireturn None)) (H1 : true = true)","proofString":"apply is_return_none; auto."},{"statement":"(f : function) (pc : node) (instr : instruction) (H : fn_stacksize f = 0) : transf_instr_spec f instr (transf_instr f pc instr).","conclusion":"transf_instr_spec f instr (transf_instr f pc instr)","hypotheses":"(f : function) (pc : node) (instr : instruction) (H : fn_stacksize f = 0)","proofString":"unfold transf_instr.\ndestruct instr; try constructor.\ndestruct (is_return niter f n r && tailcall_is_possible s &&            xtype_eq (sig_res s) (sig_res (fn_sig f))) eqn:B.\nInvBooleans.\neapply transf_instr_tailcall; eauto.\neapply is_return_charact; eauto.\nconstructor."},{"statement":"(f : function) (pc : node) (instr : instruction) (H : fn_stacksize f = 0) : transf_instr_spec f instr\n  match instr with\n  | Icall sig ros args res s =>\n      if\n       is_return niter f s res && tailcall_is_possible sig &&\n       xtype_eq (sig_res sig) (sig_res (fn_sig f))\n      then Itailcall sig ros args\n      else instr\n  | _ => instr\n  end.","conclusion":"transf_instr_spec f instr\n  match instr with\n  | Icall sig ros args res s =>\n      if\n       is_return niter f s res && tailcall_is_possible sig &&\n       xtype_eq (sig_res sig) (sig_res (fn_sig f))\n      then Itailcall sig ros args\n      else instr\n  | _ => instr\n  end","hypotheses":"(f : function) (pc : node) (instr : instruction) (H : fn_stacksize f = 0)","proofString":"destruct instr; try constructor.\ndestruct (is_return niter f n r && tailcall_is_possible s &&            xtype_eq (sig_res s) (sig_res (fn_sig f))) eqn:B.\nInvBooleans.\neapply transf_instr_tailcall; eauto.\neapply is_return_charact; eauto.\nconstructor."},{"statement":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0) : transf_instr_spec f (Icall s s0 l r n)\n  (if\n    is_return niter f n r && tailcall_is_possible s &&\n    xtype_eq (sig_res s) (sig_res (fn_sig f))\n   then Itailcall s s0 l\n   else Icall s s0 l r n).","conclusion":"transf_instr_spec f (Icall s s0 l r n)\n  (if\n    is_return niter f n r && tailcall_is_possible s &&\n    xtype_eq (sig_res s) (sig_res (fn_sig f))\n   then Itailcall s s0 l\n   else Icall s s0 l r n)","hypotheses":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0)","proofString":"destruct (is_return niter f n r && tailcall_is_possible s &&            xtype_eq (sig_res s) (sig_res (fn_sig f))) eqn:B.\nInvBooleans.\neapply transf_instr_tailcall; eauto.\neapply is_return_charact; eauto.\nconstructor."},{"statement":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0) (B : is_return niter f n r && tailcall_is_possible s &&\nxtype_eq (sig_res s) (sig_res (fn_sig f)) = true) : transf_instr_spec f (Icall s s0 l r n) (Itailcall s s0 l).","conclusion":"transf_instr_spec f (Icall s s0 l r n) (Itailcall s s0 l)","hypotheses":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0) (B : is_return niter f n r && tailcall_is_possible s &&\nxtype_eq (sig_res s) (sig_res (fn_sig f)) = true)","proofString":"InvBooleans.\neapply transf_instr_tailcall; eauto.\neapply is_return_charact; eauto."},{"statement":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0) (H2 : is_return niter f n r = true) (H3 : tailcall_is_possible s = true) (H0 : sig_res s = sig_res (fn_sig f)) : transf_instr_spec f (Icall s s0 l r n) (Itailcall s s0 l).","conclusion":"transf_instr_spec f (Icall s s0 l r n) (Itailcall s s0 l)","hypotheses":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0) (H2 : is_return niter f n r = true) (H3 : tailcall_is_possible s = true) (H0 : sig_res s = sig_res (fn_sig f))","proofString":"eapply transf_instr_tailcall; eauto.\neapply is_return_charact; eauto."},{"statement":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0) (H2 : is_return niter f n r = true) (H3 : tailcall_is_possible s = true) (H0 : sig_res s = sig_res (fn_sig f)) : is_return_spec f n r.","conclusion":"is_return_spec f n r","hypotheses":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0) (H2 : is_return niter f n r = true) (H3 : tailcall_is_possible s = true) (H0 : sig_res s = sig_res (fn_sig f))","proofString":"eapply is_return_charact; eauto."},{"statement":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0) (B : is_return niter f n r && tailcall_is_possible s &&\nxtype_eq (sig_res s) (sig_res (fn_sig f)) = false) : transf_instr_spec f (Icall s s0 l r n) (Icall s s0 l r n).","conclusion":"transf_instr_spec f (Icall s s0 l r n) (Icall s s0 l r n)","hypotheses":"(f : function) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : node) (H : fn_stacksize f = 0) (B : is_return niter f n r && tailcall_is_possible s &&\nxtype_eq (sig_res s) (sig_res (fn_sig f)) = false)","proofString":"constructor."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) : exists i' : instruction,\n  (fn_code (transf_function f)) ! pc = Some i' /\\ transf_instr_spec f i i'.","conclusion":"exists i' : instruction,\n  (fn_code (transf_function f)) ! pc = Some i' /\\ transf_instr_spec f i i'","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i)","proofString":"unfold transf_function.\ndestruct (zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None) eqn:B.\nInvBooleans.\nsimpl.\nrewrite PTree.gmap.\nrewrite H.\nsimpl.\nexists (transf_instr f pc i); split.\nauto.\napply transf_instr_charact; auto.\nexists i; split.\nauto.\nconstructor."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) : exists i' : instruction,\n  (fn_code\n     (if\n       zeq (fn_stacksize f) 0 &&\n       option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None\n      then RTL.transf_function (transf_instr f) f\n      else f)) ! pc = Some i' /\\ transf_instr_spec f i i'.","conclusion":"exists i' : instruction,\n  (fn_code\n     (if\n       zeq (fn_stacksize f) 0 &&\n       option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None\n      then RTL.transf_function (transf_instr f) f\n      else f)) ! pc = Some i' /\\ transf_instr_spec f i i'","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i)","proofString":"destruct (zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None) eqn:B.\nInvBooleans.\nsimpl.\nrewrite PTree.gmap.\nrewrite H.\nsimpl.\nexists (transf_instr f pc i); split.\nauto.\napply transf_instr_charact; auto.\nexists i; split.\nauto.\nconstructor."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (B : zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None =\ntrue) : exists i' : instruction,\n  (fn_code (RTL.transf_function (transf_instr f) f)) ! pc = Some i' /\\\n  transf_instr_spec f i i'.","conclusion":"exists i' : instruction,\n  (fn_code (RTL.transf_function (transf_instr f) f)) ! pc = Some i' /\\\n  transf_instr_spec f i i'","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (B : zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None =\ntrue)","proofString":"InvBooleans.\nsimpl.\nrewrite PTree.gmap.\nrewrite H.\nsimpl.\nexists (transf_instr f pc i); split.\nauto.\napply transf_instr_charact; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0) : exists i' : instruction,\n  (fn_code (RTL.transf_function (transf_instr f) f)) ! pc = Some i' /\\\n  transf_instr_spec f i i'.","conclusion":"exists i' : instruction,\n  (fn_code (RTL.transf_function (transf_instr f) f)) ! pc = Some i' /\\\n  transf_instr_spec f i i'","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0)","proofString":"simpl.\nrewrite PTree.gmap.\nrewrite H.\nsimpl.\nexists (transf_instr f pc i); split.\nauto.\napply transf_instr_charact; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0) : exists i' : instruction,\n  (PTree.map (transf_instr f) (fn_code f)) ! pc = Some i' /\\\n  transf_instr_spec f i i'.","conclusion":"exists i' : instruction,\n  (PTree.map (transf_instr f) (fn_code f)) ! pc = Some i' /\\\n  transf_instr_spec f i i'","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0)","proofString":"rewrite PTree.gmap.\nrewrite H.\nsimpl.\nexists (transf_instr f pc i); split.\nauto.\napply transf_instr_charact; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0) : exists i' : instruction,\n  option_map (transf_instr f pc) (fn_code f) ! pc = Some i' /\\\n  transf_instr_spec f i i'.","conclusion":"exists i' : instruction,\n  option_map (transf_instr f pc) (fn_code f) ! pc = Some i' /\\\n  transf_instr_spec f i i'","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0)","proofString":"rewrite H.\nsimpl.\nexists (transf_instr f pc i); split.\nauto.\napply transf_instr_charact; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0) : exists i' : instruction,\n  option_map (transf_instr f pc) (Some i) = Some i' /\\\n  transf_instr_spec f i i'.","conclusion":"exists i' : instruction,\n  option_map (transf_instr f pc) (Some i) = Some i' /\\\n  transf_instr_spec f i i'","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0)","proofString":"simpl.\nexists (transf_instr f pc i); split.\nauto.\napply transf_instr_charact; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0) : exists i' : instruction,\n  Some (transf_instr f pc i) = Some i' /\\ transf_instr_spec f i i'.","conclusion":"exists i' : instruction,\n  Some (transf_instr f pc i) = Some i' /\\ transf_instr_spec f i i'","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0)","proofString":"exists (transf_instr f pc i); split.\nauto.\napply transf_instr_charact; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0) : Some (transf_instr f pc i) = Some (transf_instr f pc i).","conclusion":"Some (transf_instr f pc i) = Some (transf_instr f pc i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0)","proofString":"auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0) : transf_instr_spec f i (transf_instr f pc i).","conclusion":"transf_instr_spec f i (transf_instr f pc i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H1 : cc_vararg (sig_cc (fn_sig f)) = None) (H0 : fn_stacksize f = 0)","proofString":"apply transf_instr_charact; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (B : zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None =\nfalse) : exists i' : instruction,\n  (fn_code f) ! pc = Some i' /\\ transf_instr_spec f i i'.","conclusion":"exists i' : instruction,\n  (fn_code f) ! pc = Some i' /\\ transf_instr_spec f i i'","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (B : zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None =\nfalse)","proofString":"exists i; split.\nauto.\nconstructor."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (B : zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None =\nfalse) : (fn_code f) ! pc = Some i.","conclusion":"(fn_code f) ! pc = Some i","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (B : zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None =\nfalse)","proofString":"auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (B : zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None =\nfalse) : transf_instr_spec f i i.","conclusion":"transf_instr_spec f i i","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (B : zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None =\nfalse)","proofString":"constructor."},{"statement":"(vl vl' : list val) (H : Val.lessdef_list vl vl') : regs_lessdef (init_regs vl nil) (init_regs vl' nil).","conclusion":"regs_lessdef (init_regs vl nil) (init_regs vl' nil)","hypotheses":"(vl vl' : list val) (H : Val.lessdef_list vl vl')","proofString":"simpl.\nred; intros.\nrewrite Regmap.gi.\nconstructor."},{"statement":"(vl vl' : list val) (H : Val.lessdef_list vl vl') : regs_lessdef (Regmap.init Vundef) (Regmap.init Vundef).","conclusion":"regs_lessdef (Regmap.init Vundef) (Regmap.init Vundef)","hypotheses":"(vl vl' : list val) (H : Val.lessdef_list vl vl')","proofString":"red; intros.\nrewrite Regmap.gi.\nconstructor."},{"statement":"(vl vl' : list val) (H : Val.lessdef_list vl vl') (r : positive) : Val.lessdef (Regmap.init Vundef) # r (Regmap.init Vundef) # r.","conclusion":"Val.lessdef (Regmap.init Vundef) # r (Regmap.init Vundef) # r","hypotheses":"(vl vl' : list val) (H : Val.lessdef_list vl vl') (r : positive)","proofString":"rewrite Regmap.gi.\nconstructor."},{"statement":"(vl vl' : list val) (H : Val.lessdef_list vl vl') (r : positive) : Val.lessdef Vundef Vundef.","conclusion":"Val.lessdef Vundef Vundef","hypotheses":"(vl vl' : list val) (H : Val.lessdef_list vl vl') (r : positive)","proofString":"constructor."},{"statement":"(a : reg) (params : list reg) (IHparams : forall vl0 vl'0 : list val,\nVal.lessdef_list vl0 vl'0 ->\nregs_lessdef (init_regs vl0 params) (init_regs vl'0 params)) (vl vl' : list val) (H : Val.lessdef_list vl vl') : regs_lessdef (init_regs vl (a :: params)) (init_regs vl' (a :: params)).","conclusion":"regs_lessdef (init_regs vl (a :: params)) (init_regs vl' (a :: params))","hypotheses":"(a : reg) (params : list reg) (IHparams : forall vl0 vl'0 : list val,\nVal.lessdef_list vl0 vl'0 ->\nregs_lessdef (init_regs vl0 params) (init_regs vl'0 params)) (vl vl' : list val) (H : Val.lessdef_list vl vl')","proofString":"simpl.\ninv H.\nred; intros.\nrewrite Regmap.gi.\nconstructor.\napply set_reg_lessdef.\nauto.\nauto."},{"statement":"(a : reg) (params : list reg) (IHparams : forall vl0 vl'0 : list val,\nVal.lessdef_list vl0 vl'0 ->\nregs_lessdef (init_regs vl0 params) (init_regs vl'0 params)) (vl vl' : list val) (H : Val.lessdef_list vl vl') : regs_lessdef\n  match vl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs params) # a <- v1\n  end\n  match vl' with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs params) # a <- v1\n  end.","conclusion":"regs_lessdef\n  match vl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs params) # a <- v1\n  end\n  match vl' with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs params) # a <- v1\n  end","hypotheses":"(a : reg) (params : list reg) (IHparams : forall vl0 vl'0 : list val,\nVal.lessdef_list vl0 vl'0 ->\nregs_lessdef (init_regs vl0 params) (init_regs vl'0 params)) (vl vl' : list val) (H : Val.lessdef_list vl vl')","proofString":"inv H.\nred; intros.\nrewrite Regmap.gi.\nconstructor.\napply set_reg_lessdef.\nauto.\nauto."},{"statement":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) : regs_lessdef (Regmap.init Vundef) (Regmap.init Vundef).","conclusion":"regs_lessdef (Regmap.init Vundef) (Regmap.init Vundef)","hypotheses":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params))","proofString":"red; intros.\nrewrite Regmap.gi.\nconstructor."},{"statement":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (r : positive) : Val.lessdef (Regmap.init Vundef) # r (Regmap.init Vundef) # r.","conclusion":"Val.lessdef (Regmap.init Vundef) # r (Regmap.init Vundef) # r","hypotheses":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (r : positive)","proofString":"rewrite Regmap.gi.\nconstructor."},{"statement":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (r : positive) : Val.lessdef Vundef Vundef.","conclusion":"Val.lessdef Vundef Vundef","hypotheses":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (r : positive)","proofString":"constructor."},{"statement":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (v1 v2 : val) (vl1 vl2 : list val) (H0 : Val.lessdef v1 v2) (H1 : Val.lessdef_list vl1 vl2) : regs_lessdef (init_regs vl1 params) # a <- v1\n  (init_regs vl2 params) # a <- v2.","conclusion":"regs_lessdef (init_regs vl1 params) # a <- v1\n  (init_regs vl2 params) # a <- v2","hypotheses":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (v1 v2 : val) (vl1 vl2 : list val) (H0 : Val.lessdef v1 v2) (H1 : Val.lessdef_list vl1 vl2)","proofString":"apply set_reg_lessdef.\nauto.\nauto."},{"statement":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (v1 v2 : val) (vl1 vl2 : list val) (H0 : Val.lessdef v1 v2) (H1 : Val.lessdef_list vl1 vl2) : Val.lessdef v1 v2.","conclusion":"Val.lessdef v1 v2","hypotheses":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (v1 v2 : val) (vl1 vl2 : list val) (H0 : Val.lessdef v1 v2) (H1 : Val.lessdef_list vl1 vl2)","proofString":"auto."},{"statement":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (v1 v2 : val) (vl1 vl2 : list val) (H0 : Val.lessdef v1 v2) (H1 : Val.lessdef_list vl1 vl2) : regs_lessdef (init_regs vl1 params) (init_regs vl2 params).","conclusion":"regs_lessdef (init_regs vl1 params) (init_regs vl2 params)","hypotheses":"(a : reg) (params : list reg) (IHparams : forall vl vl' : list val,\nVal.lessdef_list vl vl' ->\nregs_lessdef (init_regs vl params) (init_regs vl' params)) (v1 v2 : val) (vl1 vl2 : list val) (H0 : Val.lessdef v1 v2) (H1 : Val.lessdef_list vl1 vl2)","proofString":"auto."},{"statement":"(p : program) : match_prog p (transf_program p).","conclusion":"match_prog p (transf_program p)","hypotheses":"(p : program)","proofString":"apply match_transform_program; auto."},{"statement":"(f : function) : funsig (transf_fundef (Internal f)) = funsig (Internal f).","conclusion":"funsig (transf_fundef (Internal f)) = funsig (Internal f)","hypotheses":"(f : function)","proofString":"simpl.\nunfold transf_function.\ndestruct (zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None); auto."},{"statement":"(f : function) : fn_sig (transf_function f) = fn_sig f.","conclusion":"fn_sig (transf_function f) = fn_sig f","hypotheses":"(f : function)","proofString":"unfold transf_function.\ndestruct (zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None); auto."},{"statement":"(f : function) : fn_sig\n  (if\n    zeq (fn_stacksize f) 0 &&\n    option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None\n   then RTL.transf_function (transf_instr f) f\n   else f) = fn_sig f.","conclusion":"fn_sig\n  (if\n    zeq (fn_stacksize f) 0 &&\n    option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None\n   then RTL.transf_function (transf_instr f) f\n   else f) = fn_sig f","hypotheses":"(f : function)","proofString":"destruct (zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None); auto."},{"statement":"forall f : function,\nfn_stacksize\n  (if\n    zeq (fn_stacksize f) 0 &&\n    option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None\n   then RTL.transf_function (transf_instr f) f\n   else f) = fn_stacksize f.","conclusion":"forall f : function,\nfn_stacksize\n  (if\n    zeq (fn_stacksize f) 0 &&\n    option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None\n   then RTL.transf_function (transf_instr f) f\n   else f) = fn_stacksize f","hypotheses":"","proofString":"intros.\ndestruct (zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None); auto."},{"statement":"(f : function) : fn_stacksize\n  (if\n    zeq (fn_stacksize f) 0 &&\n    option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None\n   then RTL.transf_function (transf_instr f) f\n   else f) = fn_stacksize f.","conclusion":"fn_stacksize\n  (if\n    zeq (fn_stacksize f) 0 &&\n    option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None\n   then RTL.transf_function (transf_instr f) f\n   else f) = fn_stacksize f","hypotheses":"(f : function)","proofString":"destruct (zeq (fn_stacksize f) 0 && option_eq zeq (cc_vararg (sig_cc (fn_sig f))) None); auto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) : Genv.find_funct ge rs # r = Some f ->\nregs_lessdef rs rs' -> Genv.find_funct tge rs' # r = Some (transf_fundef f).","conclusion":"Genv.find_funct ge rs # r = Some f ->\nregs_lessdef rs rs' -> Genv.find_funct tge rs' # r = Some (transf_fundef f)","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef)","proofString":"intros.\nassert (rs'#r = rs#r).\nexploit Genv.find_funct_inv; eauto.\nintros [b EQ].\ngeneralize (H0 r).\nrewrite EQ.\nintro LD.\ninv LD.\nauto.\nrewrite H1.\napply functions_translated; auto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') : Genv.find_funct tge rs' # r = Some (transf_fundef f).","conclusion":"Genv.find_funct tge rs' # r = Some (transf_fundef f)","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs')","proofString":"assert (rs'#r = rs#r).\nexploit Genv.find_funct_inv; eauto.\nintros [b EQ].\ngeneralize (H0 r).\nrewrite EQ.\nintro LD.\ninv LD.\nauto.\nrewrite H1.\napply functions_translated; auto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') : rs' # r = rs # r.","conclusion":"rs' # r = rs # r","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs')","proofString":"exploit Genv.find_funct_inv; eauto.\nintros [b EQ].\ngeneralize (H0 r).\nrewrite EQ.\nintro LD.\ninv LD.\nauto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') : (exists b : block, rs # r = Vptr b Ptrofs.zero) -> rs' # r = rs # r.","conclusion":"(exists b : block, rs # r = Vptr b Ptrofs.zero) -> rs' # r = rs # r","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs')","proofString":"intros [b EQ].\ngeneralize (H0 r).\nrewrite EQ.\nintro LD.\ninv LD.\nauto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) : rs' # r = rs # r.","conclusion":"rs' # r = rs # r","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero)","proofString":"generalize (H0 r).\nrewrite EQ.\nintro LD.\ninv LD.\nauto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) : Val.lessdef rs # r rs' # r -> rs' # r = rs # r.","conclusion":"Val.lessdef rs # r rs' # r -> rs' # r = rs # r","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero)","proofString":"rewrite EQ.\nintro LD.\ninv LD.\nauto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) : Val.lessdef (Vptr b Ptrofs.zero) rs' # r -> rs' # r = Vptr b Ptrofs.zero.","conclusion":"Val.lessdef (Vptr b Ptrofs.zero) rs' # r -> rs' # r = Vptr b Ptrofs.zero","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero)","proofString":"intro LD.\ninv LD.\nauto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (LD : Val.lessdef (Vptr b Ptrofs.zero) rs' # r) : rs' # r = Vptr b Ptrofs.zero.","conclusion":"rs' # r = Vptr b Ptrofs.zero","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (LD : Val.lessdef (Vptr b Ptrofs.zero) rs' # r)","proofString":"inv LD.\nauto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (H3 : Vptr b Ptrofs.zero = rs' # r) : Vptr b Ptrofs.zero = Vptr b Ptrofs.zero.","conclusion":"Vptr b Ptrofs.zero = Vptr b Ptrofs.zero","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (b : block) (EQ : rs # r = Vptr b Ptrofs.zero) (H3 : Vptr b Ptrofs.zero = rs' # r)","proofString":"auto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (H1 : rs' # r = rs # r) : Genv.find_funct tge rs' # r = Some (transf_fundef f).","conclusion":"Genv.find_funct tge rs' # r = Some (transf_fundef f)","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (H1 : rs' # r = rs # r)","proofString":"rewrite H1.\napply functions_translated; auto."},{"statement":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (H1 : rs' # r = rs # r) : Genv.find_funct tge rs # r = Some (transf_fundef f).","conclusion":"Genv.find_funct tge rs # r = Some (transf_fundef f)","hypotheses":"(r : reg) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : Genv.find_funct ge rs # r = Some f) (H0 : regs_lessdef rs rs') (H1 : rs' # r = rs # r)","proofString":"apply functions_translated; auto."},{"statement":"(i : ident) (rs : regset) (rs' : Regmap.t val) (f : fundef) : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f ->\nregs_lessdef rs rs' ->\nmatch Genv.find_symbol tge i with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef f).","conclusion":"match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f ->\nregs_lessdef rs rs' ->\nmatch Genv.find_symbol tge i with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef f)","hypotheses":"(i : ident) (rs : regset) (rs' : Regmap.t val) (f : fundef)","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge i); intros.\napply funct_ptr_translated; auto.\ndiscriminate."},{"statement":"(i : ident) (rs : regset) (rs' : Regmap.t val) (f : fundef) : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f ->\nregs_lessdef rs rs' ->\nmatch Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef f).","conclusion":"match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f ->\nregs_lessdef rs rs' ->\nmatch Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef f)","hypotheses":"(i : ident) (rs : regset) (rs' : Regmap.t val) (f : fundef)","proofString":"destruct (Genv.find_symbol ge i); intros.\napply funct_ptr_translated; auto.\ndiscriminate."},{"statement":"(i : ident) (rs : regset) (rs' : Regmap.t val) (f : fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some f) (H0 : regs_lessdef rs rs') : Genv.find_funct_ptr tge b = Some (transf_fundef f).","conclusion":"Genv.find_funct_ptr tge b = Some (transf_fundef f)","hypotheses":"(i : ident) (rs : regset) (rs' : Regmap.t val) (f : fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some f) (H0 : regs_lessdef rs rs')","proofString":"apply funct_ptr_translated; auto."},{"statement":"(i : ident) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : None = Some f) (H0 : regs_lessdef rs rs') : None = Some (transf_fundef f).","conclusion":"None = Some (transf_fundef f)","hypotheses":"(i : ident) (rs : regset) (rs' : Regmap.t val) (f : fundef) (H : None = Some f) (H0 : regs_lessdef rs rs')","proofString":"discriminate."},{"statement":"(st1 : state) (H : initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","conclusion":"exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2","hypotheses":"(st1 : state) (H : initial_state prog st1)","proofString":"inv H.\nexploit funct_ptr_translated; eauto.\nintro FIND.\nexists (Callstate nil (transf_fundef f) nil m0); split.\neconstructor; eauto.\napply (Genv.init_mem_transf TRANSL).\nauto.\nreplace (prog_main tprog) with (prog_main prog).\nrewrite symbols_preserved.\neauto.\nsymmetry; eapply match_program_main; eauto.\nrewrite <- H3.\napply sig_preserved.\nconstructor.\nconstructor.\nconstructor.\napply Mem.extends_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f)) : Genv.init_mem tprog = Some m0.","conclusion":"Genv.init_mem tprog = Some m0","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f))","proofString":"apply (Genv.init_mem_transf TRANSL).\nauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f)) : Genv.init_mem prog = Some m0.","conclusion":"Genv.init_mem prog = Some m0","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f))","proofString":"auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f)) : prog_main prog = prog_main tprog.","conclusion":"prog_main prog = prog_main tprog","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f))","proofString":"symmetry; eapply match_program_main; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f)) : funsig (transf_fundef f) = signature_main.","conclusion":"funsig (transf_fundef f) = signature_main","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f))","proofString":"rewrite <- H3.\napply sig_preserved."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f)) : funsig (transf_fundef f) = funsig f.","conclusion":"funsig (transf_fundef f) = funsig f","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f))","proofString":"apply sig_preserved."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f)) : match_states (Callstate nil f nil m0)\n  (Callstate nil (transf_fundef f) nil m0).","conclusion":"match_states (Callstate nil f nil m0)\n  (Callstate nil (transf_fundef f) nil m0)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f))","proofString":"constructor.\nconstructor.\nconstructor.\napply Mem.extends_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f)) : match_stackframes nil nil.","conclusion":"match_stackframes nil nil","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f))","proofString":"constructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f)) : Val.lessdef_list nil nil.","conclusion":"Val.lessdef_list nil nil","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f))","proofString":"constructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f)) : Mem.extends m0 m0.","conclusion":"Mem.extends m0 m0","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef f))","proofString":"apply Mem.extends_refl."},{"statement":"(st1 st2 : state) (r : int) (H : match_states st1 st2) (H0 : final_state st1 r) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st1 st2 : state) (r : int) (H : match_states st1 st2) (H0 : final_state st1 r)","proofString":"inv H0.\ninv H.\ninv H5.\ninv H3.\nconstructor."},{"statement":"(st2 : state) (r : int) (m : mem) (H : match_states (Returnstate nil (Vint r) m) st2) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st2 : state) (r : int) (m : mem) (H : match_states (Returnstate nil (Vint r) m) st2)","proofString":"inv H.\ninv H5.\ninv H3.\nconstructor."},{"statement":"(r : int) (m : mem) (s' : list stackframe) (v' : val) (m' : mem) (H3 : match_stackframes nil s') (H5 : Val.lessdef (Vint r) v') (H6 : Mem.extends m m') : final_state (Returnstate s' v' m') r.","conclusion":"final_state (Returnstate s' v' m') r","hypotheses":"(r : int) (m : mem) (s' : list stackframe) (v' : val) (m' : mem) (H3 : match_stackframes nil s') (H5 : Val.lessdef (Vint r) v') (H6 : Mem.extends m m')","proofString":"inv H5.\ninv H3.\nconstructor."},{"statement":"(r : int) (m : mem) (s' : list stackframe) (m' : mem) (H3 : match_stackframes nil s') (H6 : Mem.extends m m') : final_state (Returnstate s' (Vint r) m') r.","conclusion":"final_state (Returnstate s' (Vint r) m') r","hypotheses":"(r : int) (m : mem) (s' : list stackframe) (m' : mem) (H3 : match_stackframes nil s') (H6 : Mem.extends m m')","proofString":"inv H3.\nconstructor."},{"statement":"(r : int) (m m' : mem) (H6 : Mem.extends m m') : final_state (Returnstate nil (Vint r) m') r.","conclusion":"final_state (Returnstate nil (Vint r) m') r","hypotheses":"(r : int) (m m' : mem) (H6 : Mem.extends m m')","proofString":"constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id","hypotheses":"","proofString":"apply senv_preserved."}]}