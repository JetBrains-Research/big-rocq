{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/xmm/src/reordering/ReorderingEq.v","fileSamples":[{"statement":"eq_dom (dom_rel (sb_t ⨾ ⦗eq b_t⦘)) mapper' id.","conclusion":"eq_dom (dom_rel (sb_t ⨾ ⦗eq b_t⦘)) mapper' id","hypotheses":"","proofString":"unfolder.\nintros x (y & SB & YEQ).\nsubst y.\nassert (XIN : E_t x).\napply wf_sbE in SB.\nunfolder in SB.\ndesf.\nrewrite (rsr_mapper SIMREL'); auto.\nrewrite updo; [| intro FALSO; desf; eapply sb_irr; eauto].\nrewrite updo; auto.\nintro FALSO.\nsubst x.\napply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"forall x : actid, (exists y : actid, sb_t x y /\\ b_t = y) -> mapper' x = id x.","conclusion":"forall x : actid, (exists y : actid, sb_t x y /\\ b_t = y) -> mapper' x = id x","hypotheses":"","proofString":"intros x (y & SB & YEQ).\nsubst y.\nassert (XIN : E_t x).\napply wf_sbE in SB.\nunfolder in SB.\ndesf.\nrewrite (rsr_mapper SIMREL'); auto.\nrewrite updo; [| intro FALSO; desf; eapply sb_irr; eauto].\nrewrite updo; auto.\nintro FALSO.\nsubst x.\napply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(x y : actid) (SB : sb_t x y) (YEQ : b_t = y) : mapper' x = id x.","conclusion":"mapper' x = id x","hypotheses":"(x y : actid) (SB : sb_t x y) (YEQ : b_t = y)","proofString":"subst y.\nassert (XIN : E_t x).\napply wf_sbE in SB.\nunfolder in SB.\ndesf.\nrewrite (rsr_mapper SIMREL'); auto.\nrewrite updo; [| intro FALSO; desf; eapply sb_irr; eauto].\nrewrite updo; auto.\nintro FALSO.\nsubst x.\napply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(x : actid) (SB : sb_t x b_t) : mapper' x = id x.","conclusion":"mapper' x = id x","hypotheses":"(x : actid) (SB : sb_t x b_t)","proofString":"assert (XIN : E_t x).\napply wf_sbE in SB.\nunfolder in SB.\ndesf.\nrewrite (rsr_mapper SIMREL'); auto.\nrewrite updo; [| intro FALSO; desf; eapply sb_irr; eauto].\nrewrite updo; auto.\nintro FALSO.\nsubst x.\napply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(x : actid) (SB : sb_t x b_t) : E_t x.","conclusion":"E_t x","hypotheses":"(x : actid) (SB : sb_t x b_t)","proofString":"apply wf_sbE in SB.\nunfolder in SB.\ndesf."},{"statement":"(x : actid) (SB : (⦗E_t⦘ ⨾ sb_t ⨾ ⦗E_t⦘) x b_t) : E_t x.","conclusion":"E_t x","hypotheses":"(x : actid) (SB : (⦗E_t⦘ ⨾ sb_t ⨾ ⦗E_t⦘) x b_t)","proofString":"unfolder in SB.\ndesf."},{"statement":"(x : actid) (SB : E_t x /\\ sb_t x b_t /\\ E_t b_t) : E_t x.","conclusion":"E_t x","hypotheses":"(x : actid) (SB : E_t x /\\ sb_t x b_t /\\ E_t b_t)","proofString":"desf."},{"statement":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x) : mapper' x = id x.","conclusion":"mapper' x = id x","hypotheses":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x)","proofString":"rewrite (rsr_mapper SIMREL'); auto.\nrewrite updo; [| intro FALSO; desf; eapply sb_irr; eauto].\nrewrite updo; auto.\nintro FALSO.\nsubst x.\napply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x) : upd (upd id a_t b_t) b_t a_t x = id x.","conclusion":"upd (upd id a_t b_t) b_t a_t x = id x","hypotheses":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x)","proofString":"rewrite updo; [| intro FALSO; desf; eapply sb_irr; eauto].\nrewrite updo; auto.\nintro FALSO.\nsubst x.\napply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x) : upd id a_t b_t x = id x.","conclusion":"upd id a_t b_t x = id x","hypotheses":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x)","proofString":"rewrite updo; auto.\nintro FALSO.\nsubst x.\napply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x) : x <> a_t.","conclusion":"x <> a_t","hypotheses":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x)","proofString":"intro FALSO.\nsubst x.\napply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x) (FALSO : x = a_t) : False.","conclusion":"False","hypotheses":"(x : actid) (SB : sb_t x b_t) (XIN : E_t x) (FALSO : x = a_t)","proofString":"subst x.\napply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(XIN : E_t a_t) (SB : sb_t a_t b_t) : False.","conclusion":"False","hypotheses":"(XIN : E_t a_t) (SB : sb_t a_t b_t)","proofString":"apply ext_sb_irr with a_t.\napply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(XIN : E_t a_t) (SB : sb_t a_t b_t) : ext_sb a_t a_t.","conclusion":"ext_sb a_t a_t","hypotheses":"(XIN : E_t a_t) (SB : sb_t a_t b_t)","proofString":"apply ext_sb_trans with b_t.\nunfold sb in SB; unfolder in SB; desf.\napply PRED."},{"statement":"(XIN : E_t a_t) (SB : sb_t a_t b_t) : ext_sb a_t b_t.","conclusion":"ext_sb a_t b_t","hypotheses":"(XIN : E_t a_t) (SB : sb_t a_t b_t)","proofString":"unfold sb in SB; unfolder in SB; desf."},{"statement":"(XIN : E_t a_t) (SB : sb_t a_t b_t) : ext_sb b_t a_t.","conclusion":"ext_sb b_t a_t","hypotheses":"(XIN : E_t a_t) (SB : sb_t a_t b_t)","proofString":"apply PRED."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : sb_t ≡ sb_t ⨾ ⦗eq b_t⦘ ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘.","conclusion":"sb_t ≡ sb_t ⨾ ⦗eq b_t⦘ ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"clear.\nunfolder; split; ins; desf.\ntauto."},{"statement":"sb_t ≡ sb_t ⨾ ⦗eq b_t⦘ ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘.","conclusion":"sb_t ≡ sb_t ⨾ ⦗eq b_t⦘ ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘","hypotheses":"","proofString":"unfolder; split; ins; desf.\ntauto."},{"statement":"(x y : actid) (H : sb_t x y) : sb_t x y /\\ b_t = y \\/ sb_t x y /\\ b_t <> y.","conclusion":"sb_t x y /\\ b_t = y \\/ sb_t x y /\\ b_t <> y","hypotheses":"(x y : actid) (H : sb_t x y)","proofString":"tauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : mapper' ↑ (sb_t ⨾ ⦗eq b_t⦘ ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘.","conclusion":"mapper' ↑ (sb_t ⨾ ⦗eq b_t⦘ ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"rewrite collect_rel_union.\narewrite (    sb_t ⨾ ⦗eq b_t⦘ ≡      dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq b_t  ) at 1.\nbasic_solver.\nrewrite collect_rel_cross,          rsr_sbs_dom_disjunct,          set_collect_eq; auto.\nrewrite (rsr_map_bt INB SIMREL'); auto.\napply union_more; auto with hahn.\nrewrite collect_rel_eq_dom     with (g := id); [basic_solver 11 |].\narewrite (    dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nunfolder.\nintros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto.\narewrite (    codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nrewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf.\nrewrite set_unionK.\nunfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : mapper' ↑ (sb_t ⨾ ⦗eq b_t⦘) ∪ mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘.","conclusion":"mapper' ↑ (sb_t ⨾ ⦗eq b_t⦘) ∪ mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"arewrite (    sb_t ⨾ ⦗eq b_t⦘ ≡      dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq b_t  ) at 1.\nbasic_solver.\nrewrite collect_rel_cross,          rsr_sbs_dom_disjunct,          set_collect_eq; auto.\nrewrite (rsr_map_bt INB SIMREL'); auto.\napply union_more; auto with hahn.\nrewrite collect_rel_eq_dom     with (g := id); [basic_solver 11 |].\narewrite (    dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nunfolder.\nintros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto.\narewrite (    codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nrewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf.\nrewrite set_unionK.\nunfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : sb_t ⨾ ⦗eq b_t⦘ ≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq b_t.","conclusion":"sb_t ⨾ ⦗eq b_t⦘ ≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq b_t","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"basic_solver."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : mapper' ↑ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq b_t\n∪ mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘.","conclusion":"mapper' ↑ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq b_t\n∪ mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"rewrite collect_rel_cross,          rsr_sbs_dom_disjunct,          set_collect_eq; auto.\nrewrite (rsr_map_bt INB SIMREL'); auto.\napply union_more; auto with hahn.\nrewrite collect_rel_eq_dom     with (g := id); [basic_solver 11 |].\narewrite (    dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nunfolder.\nintros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto.\narewrite (    codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nrewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf.\nrewrite set_unionK.\nunfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq (mapper' b_t)\n∪ mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘.","conclusion":"dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq (mapper' b_t)\n∪ mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"rewrite (rsr_map_bt INB SIMREL'); auto.\napply union_more; auto with hahn.\nrewrite collect_rel_eq_dom     with (g := id); [basic_solver 11 |].\narewrite (    dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nunfolder.\nintros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto.\narewrite (    codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nrewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf.\nrewrite set_unionK.\nunfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘.","conclusion":"dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n≡ dom_rel (sb_t ⨾ ⦗eq b_t⦘) × eq a_t ∪ sb_t ⨾ ⦗set_compl (eq b_t)⦘","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"apply union_more; auto with hahn.\nrewrite collect_rel_eq_dom     with (g := id); [basic_solver 11 |].\narewrite (    dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nunfolder.\nintros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto.\narewrite (    codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nrewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf.\nrewrite set_unionK.\nunfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ≡ sb_t ⨾ ⦗set_compl (eq b_t)⦘.","conclusion":"mapper' ↑ (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ≡ sb_t ⨾ ⦗set_compl (eq b_t)⦘","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"rewrite collect_rel_eq_dom     with (g := id); [basic_solver 11 |].\narewrite (    dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nunfolder.\nintros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto.\narewrite (    codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nrewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf.\nrewrite set_unionK.\nunfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : eq_dom\n  (dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n   ∪₁ codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘)) mapper' id.","conclusion":"eq_dom\n  (dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘)\n   ∪₁ codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘)) mapper' id","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"arewrite (    dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nunfolder.\nintros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto.\narewrite (    codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nrewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf.\nrewrite set_unionK.\nunfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t).","conclusion":"dom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"rewrite wf_sbE, !seqA.\nunfolder.\nintros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : dom_rel (⦗E_t⦘ ⨾ sb_t ⨾ ⦗E_t⦘ ⨾ ⦗set_compl (eq b_t)⦘)\n⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t).","conclusion":"dom_rel (⦗E_t⦘ ⨾ sb_t ⨾ ⦗E_t⦘ ⨾ ⦗set_compl (eq b_t)⦘)\n⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"unfolder.\nintros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : forall x : actid,\n(exists y : actid, E_t x /\\ sb_t x y /\\ E_t y /\\ b_t <> y) ->\nE_t x /\\ ~ (a_t = x \\/ b_t = x).","conclusion":"forall x : actid,\n(exists y : actid, E_t x /\\ sb_t x y /\\ E_t y /\\ b_t <> y) ->\nE_t x /\\ ~ (a_t = x \\/ b_t = x)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"intros x (y & XIN & SB & YIN & NEQ).\nsplit; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x y : actid) (XIN : E_t x) (SB : sb_t x y) (YIN : E_t y) (NEQ : b_t <> y) : E_t x /\\ ~ (a_t = x \\/ b_t = x).","conclusion":"E_t x /\\ ~ (a_t = x \\/ b_t = x)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x y : actid) (XIN : E_t x) (SB : sb_t x y) (YIN : E_t y) (NEQ : b_t <> y)","proofString":"split; auto.\nintro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x y : actid) (XIN : E_t x) (SB : sb_t x y) (YIN : E_t y) (NEQ : b_t <> y) : ~ (a_t = x \\/ b_t = x).","conclusion":"~ (a_t = x \\/ b_t = x)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x y : actid) (XIN : E_t x) (SB : sb_t x y) (YIN : E_t y) (NEQ : b_t <> y)","proofString":"intro FALSO; desf.\neapply (rsr_bt_max PRED); eauto.\nunfolder.\nsplits; eauto."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : eq_dom (E_t \\₁ (eq a_t ∪₁ eq b_t) ∪₁ codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘))\n  mapper' id.","conclusion":"eq_dom (E_t \\₁ (eq a_t ∪₁ eq b_t) ∪₁ codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘))\n  mapper' id","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"arewrite (    codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁      E_t \\₁ (eq a_t ∪₁ eq b_t)  ).\nrewrite wf_sbE, !seqA.\nrewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf.\nrewrite set_unionK.\nunfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t).","conclusion":"codom_rel (sb_t ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"rewrite wf_sbE, !seqA.\nrewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : codom_rel (⦗E_t⦘ ⨾ sb_t ⨾ ⦗E_t⦘ ⨾ ⦗set_compl (eq b_t)⦘)\n⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t).","conclusion":"codom_rel (⦗E_t⦘ ⨾ sb_t ⨾ ⦗E_t⦘ ⨾ ⦗set_compl (eq b_t)⦘)\n⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"rewrite 2!codom_seq.\nunfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : codom_rel (⦗E_t⦘ ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t).","conclusion":"codom_rel (⦗E_t⦘ ⨾ ⦗set_compl (eq b_t)⦘) ⊆₁ E_t \\₁ (eq a_t ∪₁ eq b_t)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"unfolder.\nins.\ndesf.\nsplit; auto.\nintro FALSO; desf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : forall x : actid,\n(exists x0 : actid, x0 = x /\\ E_t x0 /\\ b_t <> x0) ->\nE_t x /\\ ~ (a_t = x \\/ b_t = x).","conclusion":"forall x : actid,\n(exists x0 : actid, x0 = x /\\ E_t x0 /\\ b_t <> x0) ->\nE_t x /\\ ~ (a_t = x \\/ b_t = x)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"ins.\ndesf.\nsplit; auto.\nintro FALSO; desf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (H : exists x0 : actid, x0 = x /\\ E_t x0 /\\ b_t <> x0) : E_t x /\\ ~ (a_t = x \\/ b_t = x).","conclusion":"E_t x /\\ ~ (a_t = x \\/ b_t = x)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (H : exists x0 : actid, x0 = x /\\ E_t x0 /\\ b_t <> x0)","proofString":"desf.\nsplit; auto.\nintro FALSO; desf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (H1 : b_t <> x) (H0 : E_t x) : E_t x /\\ ~ (a_t = x \\/ b_t = x).","conclusion":"E_t x /\\ ~ (a_t = x \\/ b_t = x)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (H1 : b_t <> x) (H0 : E_t x)","proofString":"split; auto.\nintro FALSO; desf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (H1 : b_t <> x) (H0 : E_t x) : ~ (a_t = x \\/ b_t = x).","conclusion":"~ (a_t = x \\/ b_t = x)","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (H1 : b_t <> x) (H0 : E_t x)","proofString":"intro FALSO; desf."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : eq_dom (E_t \\₁ (eq a_t ∪₁ eq b_t) ∪₁ E_t \\₁ (eq a_t ∪₁ eq b_t)) mapper' id.","conclusion":"eq_dom (E_t \\₁ (eq a_t ∪₁ eq b_t) ∪₁ E_t \\₁ (eq a_t ∪₁ eq b_t)) mapper' id","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"rewrite set_unionK.\nunfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : eq_dom (E_t \\₁ (eq a_t ∪₁ eq b_t)) mapper' id.","conclusion":"eq_dom (E_t \\₁ (eq a_t ∪₁ eq b_t)) mapper' id","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"unfolder.\nintros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) : forall x : actid, E_t x /\\ ~ (a_t = x \\/ b_t = x) -> mapper' x = id x.","conclusion":"forall x : actid, E_t x /\\ ~ (a_t = x \\/ b_t = x) -> mapper' x = id x","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t)","proofString":"intros x (XIN & NEQ).\nrewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XIN : E_t x) (NEQ : ~ (a_t = x \\/ b_t = x)) : mapper' x = id x.","conclusion":"mapper' x = id x","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XIN : E_t x) (NEQ : ~ (a_t = x \\/ b_t = x))","proofString":"rewrite (rsr_mapper SIMREL'); auto.\nassert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XIN : E_t x) (NEQ : ~ (a_t = x \\/ b_t = x)) : upd (upd id a_t b_t) b_t a_t x = id x.","conclusion":"upd (upd id a_t b_t) b_t a_t x = id x","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XIN : E_t x) (NEQ : ~ (a_t = x \\/ b_t = x))","proofString":"assert (NEQ': a_t <> x /\\ b_t <> x) by tauto.\ndesf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XIN : E_t x) (NEQ : ~ (a_t = x \\/ b_t = x)) (NEQ' : a_t <> x /\\ b_t <> x) : upd (upd id a_t b_t) b_t a_t x = id x.","conclusion":"upd (upd id a_t b_t) b_t a_t x = id x","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XIN : E_t x) (NEQ : ~ (a_t = x \\/ b_t = x)) (NEQ' : a_t <> x /\\ b_t <> x)","proofString":"desf.\nnow rewrite !updo by congruence."},{"statement":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XIN : E_t x) (NEQ : ~ (a_t = x \\/ b_t = x)) (NEQ' : a_t <> x) (NEQ'0 : b_t <> x) : upd (upd id a_t b_t) b_t a_t x = id x.","conclusion":"upd (upd id a_t b_t) b_t a_t x = id x","hypotheses":"(INB : E_t b_t) (NINA : ~ E_t a_t) (x : actid) (XIN : E_t x) (NEQ : ~ (a_t = x \\/ b_t = x)) (NEQ' : a_t <> x) (NEQ'0 : b_t <> x)","proofString":"now rewrite !updo by congruence."},{"statement":"⦗fun e : actid => ~ is_init e⦘ ⨾ sb_s\n≡ ⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t ∪ extra_sb.","conclusion":"⦗fun e : actid => ~ is_init e⦘ ⨾ sb_s\n≡ ⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t ∪ extra_sb","hypotheses":"","proofString":"rewrite rsr_sbE; eauto.\nrewrite !seq_union_r.\napply union_more; [reflexivity |].\nrewrite <- cross_inter_l, set_inter_union_r.\narewrite ((fun x => ~is_init x) ∩₁ is_init ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l.\nunfold extra_sb.\napply cross_more; [| reflexivity].\nsplit; [basic_solver |].\nunfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"⦗fun e : actid => ~ is_init e⦘\n⨾ (sb_t\n   ∪ ((fun a : actid => is_init a) ∪₁ E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t)\n≡ ⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t ∪ extra_sb.","conclusion":"⦗fun e : actid => ~ is_init e⦘\n⨾ (sb_t\n   ∪ ((fun a : actid => is_init a) ∪₁ E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t)\n≡ ⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t ∪ extra_sb","hypotheses":"","proofString":"rewrite !seq_union_r.\napply union_more; [reflexivity |].\nrewrite <- cross_inter_l, set_inter_union_r.\narewrite ((fun x => ~is_init x) ∩₁ is_init ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l.\nunfold extra_sb.\napply cross_more; [| reflexivity].\nsplit; [basic_solver |].\nunfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t\n∪ ⦗fun e : actid => ~ is_init e⦘\n  ⨾ ((fun a : actid => is_init a) ∪₁ E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t\n≡ ⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t ∪ extra_sb.","conclusion":"⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t\n∪ ⦗fun e : actid => ~ is_init e⦘\n  ⨾ ((fun a : actid => is_init a) ∪₁ E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t\n≡ ⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t ∪ extra_sb","hypotheses":"","proofString":"apply union_more; [reflexivity |].\nrewrite <- cross_inter_l, set_inter_union_r.\narewrite ((fun x => ~is_init x) ∩₁ is_init ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l.\nunfold extra_sb.\napply cross_more; [| reflexivity].\nsplit; [basic_solver |].\nunfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"⦗fun e : actid => ~ is_init e⦘\n⨾ ((fun a : actid => is_init a) ∪₁ E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t\n≡ extra_sb.","conclusion":"⦗fun e : actid => ~ is_init e⦘\n⨾ ((fun a : actid => is_init a) ∪₁ E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t\n≡ extra_sb","hypotheses":"","proofString":"rewrite <- cross_inter_l, set_inter_union_r.\narewrite ((fun x => ~is_init x) ∩₁ is_init ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l.\nunfold extra_sb.\napply cross_more; [| reflexivity].\nsplit; [basic_solver |].\nunfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"((fun e : actid => ~ is_init e) ∩₁ (fun a : actid => is_init a)\n ∪₁ (fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t))) × \nextra_a a_t ≡ extra_sb.","conclusion":"((fun e : actid => ~ is_init e) ∩₁ (fun a : actid => is_init a)\n ∪₁ (fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t))) × \nextra_a a_t ≡ extra_sb","hypotheses":"","proofString":"arewrite ((fun x => ~is_init x) ∩₁ is_init ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l.\nunfold extra_sb.\napply cross_more; [| reflexivity].\nsplit; [basic_solver |].\nunfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"(fun x : actid => ~ is_init x) ∩₁ (fun a : actid => is_init a) ≡₁ ∅.","conclusion":"(fun x : actid => ~ is_init x) ∩₁ (fun a : actid => is_init a) ≡₁ ∅","hypotheses":"","proofString":"basic_solver."},{"statement":"(∅ ∪₁ (fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t)))\n× extra_a a_t ≡ extra_sb.","conclusion":"(∅ ∪₁ (fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t)))\n× extra_a a_t ≡ extra_sb","hypotheses":"","proofString":"rewrite set_union_empty_l.\nunfold extra_sb.\napply cross_more; [| reflexivity].\nsplit; [basic_solver |].\nunfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"((fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t))) × extra_a a_t\n≡ extra_sb.","conclusion":"((fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t))) × extra_a a_t\n≡ extra_sb","hypotheses":"","proofString":"unfold extra_sb.\napply cross_more; [| reflexivity].\nsplit; [basic_solver |].\nunfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"((fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t))) × extra_a a_t\n≡ (E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t.","conclusion":"((fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t))) × extra_a a_t\n≡ (E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t","hypotheses":"","proofString":"apply cross_more; [| reflexivity].\nsplit; [basic_solver |].\nunfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"(fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t))\n≡₁ E_t ∩₁ Tid_ (tid b_t).","conclusion":"(fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t))\n≡₁ E_t ∩₁ Tid_ (tid b_t)","hypotheses":"","proofString":"split; [basic_solver |].\nunfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"E_t ∩₁ Tid_ (tid b_t)\n⊆₁ (fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t)).","conclusion":"E_t ∩₁ Tid_ (tid b_t)\n⊆₁ (fun e : actid => ~ is_init e) ∩₁ (E_t ∩₁ Tid_ (tid b_t))","hypotheses":"","proofString":"unfolder.\nins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"forall x : actid,\nE_t x /\\ tid x = tid b_t -> ~ is_init x /\\ E_t x /\\ tid x = tid b_t.","conclusion":"forall x : actid,\nE_t x /\\ tid x = tid b_t -> ~ is_init x /\\ E_t x /\\ tid x = tid b_t","hypotheses":"","proofString":"ins.\ndesf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"(x : actid) (H : E_t x /\\ tid x = tid b_t) : ~ is_init x /\\ E_t x /\\ tid x = tid b_t.","conclusion":"~ is_init x /\\ E_t x /\\ tid x = tid b_t","hypotheses":"(x : actid) (H : E_t x /\\ tid x = tid b_t)","proofString":"desf.\nsplits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"(x : actid) (H : E_t x) (H0 : tid x = tid b_t) : ~ is_init x /\\ E_t x /\\ tid x = tid b_t.","conclusion":"~ is_init x /\\ E_t x /\\ tid x = tid b_t","hypotheses":"(x : actid) (H : E_t x) (H0 : tid x = tid b_t)","proofString":"splits; auto.\nunfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"(x : actid) (H : E_t x) (H0 : tid x = tid b_t) : ~ is_init x.","conclusion":"~ is_init x","hypotheses":"(x : actid) (H : E_t x) (H0 : tid x = tid b_t)","proofString":"unfold tid, is_init in *.\ndesf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"(x : actid) (H : E_t x) (H0 : match x with\n| InitEvent _ => tid_init\n| ThreadEvent i _ => i\nend = match b_t with\n      | InitEvent _ => tid_init\n      | ThreadEvent i _ => i\n      end) : ~ match x with\n  | InitEvent _ => true\n  | ThreadEvent _ _ => false\n  end.","conclusion":"~ match x with\n  | InitEvent _ => true\n  | ThreadEvent _ _ => false\n  end","hypotheses":"(x : actid) (H : E_t x) (H0 : match x with\n| InitEvent _ => tid_init\n| ThreadEvent i _ => i\nend = match b_t with\n      | InitEvent _ => tid_init\n      | ThreadEvent i _ => i\n      end)","proofString":"desf.\nexfalso.\napply (rsr_bt_ninit PRED).\nunfold is_init; desf.\nexfalso.\napply (rsr_bt_tid PRED).\nunfold tid.\ndesf."},{"statement":"(l0 : location) (l : location) (H : E_t (InitEvent l)) (H0 : tid_init = tid_init) : is_init (InitEvent l0).","conclusion":"is_init (InitEvent l0)","hypotheses":"(l0 : location) (l : location) (H : E_t (InitEvent l)) (H0 : tid_init = tid_init)","proofString":"unfold is_init; desf."},{"statement":"(index : nat) (l : location) (H : E_t (InitEvent l)) : tid (ThreadEvent tid_init index) = tid_init.","conclusion":"tid (ThreadEvent tid_init index) = tid_init","hypotheses":"(index : nat) (l : location) (H : E_t (InitEvent l))","proofString":"unfold tid.\ndesf."},{"statement":"(index : nat) (l : location) (H : E_t (InitEvent l)) : tid_init = tid_init.","conclusion":"tid_init = tid_init","hypotheses":"(index : nat) (l : location) (H : E_t (InitEvent l))","proofString":"desf."},{"statement":"(NINA : ~ E_t a_t) (INB : E_t b_t) : (E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t ≡ (E_t ∩₁ Tid_ (tid b_t)) × eq a_t.","conclusion":"(E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t ≡ (E_t ∩₁ Tid_ (tid b_t)) × eq a_t","hypotheses":"(NINA : ~ E_t a_t) (INB : E_t b_t)","proofString":"rewrite extra_a_some; auto with hahn."},{"statement":"(INA : E_t a_t) : (E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t ≡ ∅₂.","conclusion":"(E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t ≡ ∅₂","hypotheses":"(INA : E_t a_t)","proofString":"rewrite extra_a_none_l; auto.\nbasic_solver."},{"statement":"(INA : E_t a_t) : (E_t ∩₁ Tid_ (tid b_t)) × ∅ ≡ ∅₂.","conclusion":"(E_t ∩₁ Tid_ (tid b_t)) × ∅ ≡ ∅₂","hypotheses":"(INA : E_t a_t)","proofString":"basic_solver."},{"statement":"(INA : ~ E_t b_t) : (E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t ≡ ∅₂.","conclusion":"(E_t ∩₁ Tid_ (tid b_t)) × extra_a a_t ≡ ∅₂","hypotheses":"(INA : ~ E_t b_t)","proofString":"rewrite extra_a_none_r; auto.\nbasic_solver."},{"statement":"(INA : ~ E_t b_t) : (E_t ∩₁ Tid_ (tid b_t)) × ∅ ≡ ∅₂.","conclusion":"(E_t ∩₁ Tid_ (tid b_t)) × ∅ ≡ ∅₂","hypotheses":"(INA : ~ E_t b_t)","proofString":"basic_solver."},{"statement":"(eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s) ⊆ immediate (nin_sb G_s).","conclusion":"(eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s) ⊆ immediate (nin_sb G_s)","hypotheses":"","proofString":"rewrite rsr_sbE_imm, extra_sbE.\nunfold extra_a; desf.\nbasic_solver.\nrewrite cross_false_l, union_false_r.\nrewrite rsr_actsE, extra_a_none; auto.\nrewrite set_union_empty_r, imm_nin_sbE.\nassert (BNINI : ~is_init b_t) by apply PRED.\nrewrite <- (rsr_at_bt_imm PRED).\nbasic_solver."},{"statement":"(eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s)\n⊆ immediate (nin_sb G_t) ∪ extra_a b_t × eq a_t.","conclusion":"(eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s)\n⊆ immediate (nin_sb G_t) ∪ extra_a b_t × eq a_t","hypotheses":"","proofString":"unfold extra_a; desf.\nbasic_solver.\nrewrite cross_false_l, union_false_r.\nrewrite rsr_actsE, extra_a_none; auto.\nrewrite set_union_empty_r, imm_nin_sbE.\nassert (BNINI : ~is_init b_t) by apply PRED.\nrewrite <- (rsr_at_bt_imm PRED).\nbasic_solver."},{"statement":"(a : ~ E_t a_t /\\ E_t b_t) : (eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s) ⊆ immediate (nin_sb G_t) ∪ eq b_t × eq a_t.","conclusion":"(eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s) ⊆ immediate (nin_sb G_t) ∪ eq b_t × eq a_t","hypotheses":"(a : ~ E_t a_t /\\ E_t b_t)","proofString":"basic_solver."},{"statement":"(n : ~ (~ E_t a_t /\\ E_t b_t)) : (eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s) ⊆ immediate (nin_sb G_t) ∪ ∅ × eq a_t.","conclusion":"(eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s) ⊆ immediate (nin_sb G_t) ∪ ∅ × eq a_t","hypotheses":"(n : ~ (~ E_t a_t /\\ E_t b_t))","proofString":"rewrite cross_false_l, union_false_r.\nrewrite rsr_actsE, extra_a_none; auto.\nrewrite set_union_empty_r, imm_nin_sbE.\nassert (BNINI : ~is_init b_t) by apply PRED.\nrewrite <- (rsr_at_bt_imm PRED).\nbasic_solver."},{"statement":"(n : ~ (~ E_t a_t /\\ E_t b_t)) : (eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s) ⊆ immediate (nin_sb G_t).","conclusion":"(eq b_t ∩₁ E_s) × (eq a_t ∩₁ E_s) ⊆ immediate (nin_sb G_t)","hypotheses":"(n : ~ (~ E_t a_t /\\ E_t b_t))","proofString":"rewrite rsr_actsE, extra_a_none; auto.\nrewrite set_union_empty_r, imm_nin_sbE.\nassert (BNINI : ~is_init b_t) by apply PRED.\nrewrite <- (rsr_at_bt_imm PRED).\nbasic_solver."},{"statement":"(n : ~ (~ E_t a_t /\\ E_t b_t)) : (eq b_t ∩₁ (E_t ∪₁ ∅)) × (eq a_t ∩₁ (E_t ∪₁ ∅)) ⊆ immediate (nin_sb G_t).","conclusion":"(eq b_t ∩₁ (E_t ∪₁ ∅)) × (eq a_t ∩₁ (E_t ∪₁ ∅)) ⊆ immediate (nin_sb G_t)","hypotheses":"(n : ~ (~ E_t a_t /\\ E_t b_t))","proofString":"rewrite set_union_empty_r, imm_nin_sbE.\nassert (BNINI : ~is_init b_t) by apply PRED.\nrewrite <- (rsr_at_bt_imm PRED).\nbasic_solver."},{"statement":"(n : ~ (~ E_t a_t /\\ E_t b_t)) : (eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t)\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ immediate sb_t.","conclusion":"(eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t)\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ immediate sb_t","hypotheses":"(n : ~ (~ E_t a_t /\\ E_t b_t))","proofString":"assert (BNINI : ~is_init b_t) by apply PRED.\nrewrite <- (rsr_at_bt_imm PRED).\nbasic_solver."},{"statement":"(n : ~ (~ E_t a_t /\\ E_t b_t)) (BNINI : ~ is_init b_t) : (eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t)\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ immediate sb_t.","conclusion":"(eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t)\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ immediate sb_t","hypotheses":"(n : ~ (~ E_t a_t /\\ E_t b_t)) (BNINI : ~ is_init b_t)","proofString":"rewrite <- (rsr_at_bt_imm PRED).\nbasic_solver."},{"statement":"(n : ~ (~ E_t a_t /\\ E_t b_t)) (BNINI : ~ is_init b_t) : (eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t)\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ (eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t).","conclusion":"(eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t)\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ (eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t)","hypotheses":"(n : ~ (~ E_t a_t /\\ E_t b_t)) (BNINI : ~ is_init b_t)","proofString":"basic_solver."}]}