{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Calc/Bracket.v","fileSamples":[{"statement":"(Hx : (d <= x < u)%R) : inbetween inbetween_loc.","proofString":"unfold inbetween_loc.\ndestruct (Rcompare_spec x d) as [H|H|H].\nnow elim Rle_not_lt with (1 := proj1 Hx).\nnow constructor.\nconstructor.\nnow split.\neasy."},{"statement":"(Hx : (d <= x < u)%R) : inbetween\n  match Rcompare x d with\n  | Gt => SpecFloat.loc_Inexact (Rcompare x ((d + u) / 2))\n  | _ => SpecFloat.loc_Exact\n  end.","proofString":"destruct (Rcompare_spec x d) as [H|H|H].\nnow elim Rle_not_lt with (1 := proj1 Hx).\nnow constructor.\nconstructor.\nnow split.\neasy."},{"statement":"(Hx : (d <= x < u)%R) (H : (x < d)%R) : inbetween SpecFloat.loc_Exact.","proofString":"now elim Rle_not_lt with (1 := proj1 Hx)."},{"statement":"(Hx : (d <= x < u)%R) (H : x = d) : inbetween SpecFloat.loc_Exact.","proofString":"now constructor."},{"statement":"(Hx : (d <= x < u)%R) (H : (d < x)%R) : inbetween (SpecFloat.loc_Inexact (Rcompare x ((d + u) / 2))).","proofString":"constructor.\nnow split.\neasy."},{"statement":"(Hx : (d <= x < u)%R) (H : (d < x)%R) : (d < x < u)%R.","proofString":"now split."},{"statement":"(Hx : (d <= x < u)%R) (H : (d < x)%R) : Rcompare x ((d + u) / 2) = Rcompare x ((d + u) / 2).","proofString":"easy."},{"statement":"(l l' : SpecFloat.location) (Hl : inbetween l) (Hl' : inbetween l') : l = l'.","proofString":"inversion_clear Hl ; inversion_clear Hl'.\napply refl_equal.\nrewrite H in H0.\nelim Rlt_irrefl with (1 := proj1 H0).\nrewrite H1 in H.\nelim Rlt_irrefl with (1 := proj1 H).\napply f_equal.\nnow rewrite <- H0."},{"statement":"(l l' : SpecFloat.location) (H H0 : x = d) : SpecFloat.loc_Exact = SpecFloat.loc_Exact.","proofString":"apply refl_equal."},{"statement":"(l l' : SpecFloat.location) (H : x = d) (l0 : comparison) (H0 : (d < x < u)%R) (H1 : Rcompare x ((d + u) / 2) = l0) : SpecFloat.loc_Exact = SpecFloat.loc_Inexact l0.","proofString":"rewrite H in H0.\nelim Rlt_irrefl with (1 := proj1 H0)."},{"statement":"(l l' : SpecFloat.location) (H : x = d) (l0 : comparison) (H0 : (d < d < u)%R) (H1 : Rcompare x ((d + u) / 2) = l0) : SpecFloat.loc_Exact = SpecFloat.loc_Inexact l0.","proofString":"elim Rlt_irrefl with (1 := proj1 H0)."},{"statement":"(l l' : SpecFloat.location) (l0 : comparison) (H : (d < x < u)%R) (H0 : Rcompare x ((d + u) / 2) = l0) (H1 : x = d) : SpecFloat.loc_Inexact l0 = SpecFloat.loc_Exact.","proofString":"rewrite H1 in H.\nelim Rlt_irrefl with (1 := proj1 H)."},{"statement":"(l l' : SpecFloat.location) (l0 : comparison) (H : (d < d < u)%R) (H0 : Rcompare x ((d + u) / 2) = l0) (H1 : x = d) : SpecFloat.loc_Inexact l0 = SpecFloat.loc_Exact.","proofString":"elim Rlt_irrefl with (1 := proj1 H)."},{"statement":"(l l' : SpecFloat.location) (l0 : comparison) (H : (d < x < u)%R) (H0 : Rcompare x ((d + u) / 2) = l0) (l1 : comparison) (H1 : (d < x < u)%R) (H2 : Rcompare x ((d + u) / 2) = l1) : SpecFloat.loc_Inexact l0 = SpecFloat.loc_Inexact l1.","proofString":"apply f_equal.\nnow rewrite <- H0."},{"statement":"(l l' : SpecFloat.location) (l0 : comparison) (H : (d < x < u)%R) (H0 : Rcompare x ((d + u) / 2) = l0) (l1 : comparison) (H1 : (d < x < u)%R) (H2 : Rcompare x ((d + u) / 2) = l1) : l0 = l1.","proofString":"now rewrite <- H0."},{"statement":"(Hx : x = d) : (d <= x < u)%R.","proofString":"rewrite Hx.\nsplit.\napply Rle_refl.\nexact Hdu."},{"statement":"(Hx : x = d) : (d <= d < u)%R.","proofString":"split.\napply Rle_refl.\nexact Hdu."},{"statement":"(Hx : x = d) : (d <= d)%R.","proofString":"apply Rle_refl."},{"statement":"(Hx : x = d) : (d < u)%R.","proofString":"exact Hdu."},{"statement":"(l' : comparison) (Hx : (d < x < u)%R) (Hl : Rcompare x ((d + u) / 2) = l') : (d <= x < u)%R.","proofString":"now split ; try apply Rlt_le."},{"statement":"(Hx : x = d) (H : SpecFloat.loc_Exact <> SpecFloat.loc_Exact) : (d < x < u)%R.","proofString":"now elim H."},{"statement":"(l' : comparison) (Hx : (d < x < u)%R) (Hl : Rcompare x ((d + u) / 2) = l') (H : SpecFloat.loc_Inexact l' <> SpecFloat.loc_Exact) : (d < x < u)%R.","proofString":"exact Hx."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : Rcompare (x - d) (u - x) = l.","proofString":"inversion_clear Hl as [|l' Hl' Hx].\nnow rewrite Rcompare_middle."},{"statement":"(l : comparison) (Hl' : (d < x < u)%R) (Hx : Rcompare x ((d + u) / 2) = l) : Rcompare (x - d) (u - x) = l.","proofString":"now rewrite Rcompare_middle."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : Rcompare (Rabs (d - x)) (Rabs (u - x)) = l.","proofString":"rewrite Rabs_left1.\nrewrite Rabs_pos_eq.\nrewrite Ropp_minus_distr.\nnow apply inbetween_distance_inexact.\napply Rle_0_minus.\napply Rlt_le.\napply (inbetween_bounds _ Hl).\napply Rle_minus.\napply (inbetween_bounds _ Hl)."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : Rcompare (- (d - x)) (Rabs (u - x)) = l.","proofString":"rewrite Rabs_pos_eq.\nrewrite Ropp_minus_distr.\nnow apply inbetween_distance_inexact.\napply Rle_0_minus.\napply Rlt_le.\napply (inbetween_bounds _ Hl)."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : Rcompare (- (d - x)) (u - x) = l.","proofString":"rewrite Ropp_minus_distr.\nnow apply inbetween_distance_inexact."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : Rcompare (x - d) (u - x) = l.","proofString":"now apply inbetween_distance_inexact."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : (0 <= u - x)%R.","proofString":"apply Rle_0_minus.\napply Rlt_le.\napply (inbetween_bounds _ Hl)."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : (x <= u)%R.","proofString":"apply Rlt_le.\napply (inbetween_bounds _ Hl)."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : (x < u)%R.","proofString":"apply (inbetween_bounds _ Hl)."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : (d - x <= 0)%R.","proofString":"apply Rle_minus.\napply (inbetween_bounds _ Hl)."},{"statement":"(l : comparison) (Hl : inbetween (SpecFloat.loc_Inexact l)) : (d <= x)%R.","proofString":"apply (inbetween_bounds _ Hl)."},{"statement":"(k : Z) : (start + IZR k * step < start + IZR (k + 1) * step)%R.","proofString":"apply Rplus_lt_compat_l.\napply Rmult_lt_compat_r.\nexact Hstep.\napply IZR_lt.\napply Zlt_succ."},{"statement":"(k : Z) : (IZR k * step < IZR (k + 1) * step)%R.","proofString":"apply Rmult_lt_compat_r.\nexact Hstep.\napply IZR_lt.\napply Zlt_succ."},{"statement":"(k : Z) : (0 < step)%R.","proofString":"exact Hstep."},{"statement":"(k : Z) : (IZR k < IZR (k + 1))%R.","proofString":"apply IZR_lt.\napply Zlt_succ."},{"statement":"(k : Z) : (k < k + 1)%Z.","proofString":"apply Zlt_succ."},{"statement":"(k : Z) : ((start + (start + IZR k * step)) / 2)%R = (start + IZR k / 2 * step)%R.","proofString":"field."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact l').","proofString":"constructor.\nassert (Hx' := inbetween_bounds _ _ (ordered_steps _) _ _ Hx).\nsplit.\napply Rlt_le_trans with (2 := proj1 Hx').\nrewrite <- (Rplus_0_r start) at 1.\napply Rplus_lt_compat_l.\napply Rmult_lt_0_compat.\nnow apply IZR_lt.\nexact Hstep.\napply Rlt_le_trans with (1 := proj2 Hx').\napply Rplus_le_compat_l.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\napply IZR_le.\nlia.\nnow rewrite middle_range."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') : (start < x < start + IZR nb_steps * step)%R.","proofString":"assert (Hx' := inbetween_bounds _ _ (ordered_steps _) _ _ Hx).\nsplit.\napply Rlt_le_trans with (2 := proj1 Hx').\nrewrite <- (Rplus_0_r start) at 1.\napply Rplus_lt_compat_l.\napply Rmult_lt_0_compat.\nnow apply IZR_lt.\nexact Hstep.\napply Rlt_le_trans with (1 := proj2 Hx').\napply Rplus_le_compat_l.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\napply IZR_le.\nlia."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (start < x < start + IZR nb_steps * step)%R.","proofString":"split.\napply Rlt_le_trans with (2 := proj1 Hx').\nrewrite <- (Rplus_0_r start) at 1.\napply Rplus_lt_compat_l.\napply Rmult_lt_0_compat.\nnow apply IZR_lt.\nexact Hstep.\napply Rlt_le_trans with (1 := proj2 Hx').\napply Rplus_le_compat_l.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\napply IZR_le.\nlia."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (start < x)%R.","proofString":"apply Rlt_le_trans with (2 := proj1 Hx').\nrewrite <- (Rplus_0_r start) at 1.\napply Rplus_lt_compat_l.\napply Rmult_lt_0_compat.\nnow apply IZR_lt.\nexact Hstep."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (start < start + IZR k * step)%R.","proofString":"rewrite <- (Rplus_0_r start) at 1.\napply Rplus_lt_compat_l.\napply Rmult_lt_0_compat.\nnow apply IZR_lt.\nexact Hstep."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (start + 0 < start + IZR k * step)%R.","proofString":"apply Rplus_lt_compat_l.\napply Rmult_lt_0_compat.\nnow apply IZR_lt.\nexact Hstep."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (0 < IZR k * step)%R.","proofString":"apply Rmult_lt_0_compat.\nnow apply IZR_lt.\nexact Hstep."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (0 < IZR k)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (0 < step)%R.","proofString":"exact Hstep."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (x < start + IZR nb_steps * step)%R.","proofString":"apply Rlt_le_trans with (1 := proj2 Hx').\napply Rplus_le_compat_l.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\napply IZR_le.\nlia."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (start + IZR (k + 1) * step <= start + IZR nb_steps * step)%R.","proofString":"apply Rplus_le_compat_l.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\napply IZR_le.\nlia."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (IZR (k + 1) * step <= IZR nb_steps * step)%R.","proofString":"apply Rmult_le_compat_r.\nnow apply Rlt_le.\napply IZR_le.\nlia."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (0 <= step)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (IZR (k + 1) <= IZR nb_steps)%R.","proofString":"apply IZR_le.\nlia."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') (Hx' : (start + IZR k * step <= x < start + IZR (k + 1) * step)%R) : (k + 1 <= nb_steps)%Z.","proofString":"lia."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (l' : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk : (0 < k < nb_steps)%Z) (Hl' : Rcompare x (start + IZR nb_steps / 2 * step) = l') : Rcompare x ((start + (start + IZR nb_steps * step)) / 2) = l'.","proofString":"now rewrite middle_range."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk1 : (0 < k)%Z) (Hk2 : (2 * k + 1 < nb_steps)%Z) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Lt).","proofString":"apply inbetween_step_not_Eq with (1 := Hx).\nlia.\napply Rcompare_Lt.\nassert (Hx' := inbetween_bounds _ _ (ordered_steps _) _ _ Hx).\napply Rlt_le_trans with (1 := proj2 Hx').\napply Rcompare_not_Lt_inv.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\napply Rcompare_not_Lt.\nrewrite <- mult_IZR.\napply IZR_le.\nlia.\nexact Hstep."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk1 : (nb_steps < 2 * k)%Z) (Hk2 : (k < nb_steps)%Z) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Gt).","proofString":"apply inbetween_step_not_Eq with (1 := Hx).\nlia.\napply Rcompare_Gt.\nassert (Hx' := inbetween_bounds _ _ (ordered_steps _) _ _ Hx).\napply Rlt_le_trans with (2 := proj1 Hx').\napply Rcompare_Lt_inv.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\napply Rcompare_Lt.\nrewrite <- mult_IZR.\napply IZR_lt.\nlia.\nexact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Lt).","proofString":"assert (Hx' := inbetween_bounds_not_Eq _ _ _ _ Hx Hl).\nconstructor.\nsplit.\napply Hx'.\napply Rlt_trans with (1 := proj2 Hx').\napply Rplus_lt_compat_l.\nrewrite <- (Rmult_1_l step) at 1.\napply Rmult_lt_compat_r.\nexact Hstep.\nnow apply IZR_lt.\napply Rcompare_Lt.\napply Rlt_le_trans with (1 := proj2 Hx').\nrewrite middle_range.\napply Rcompare_not_Lt_inv.\nrewrite <- (Rmult_1_l step) at 2.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\nrewrite Rmult_1_r.\napply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1).\nexact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Lt).","proofString":"constructor.\nsplit.\napply Hx'.\napply Rlt_trans with (1 := proj2 Hx').\napply Rplus_lt_compat_l.\nrewrite <- (Rmult_1_l step) at 1.\napply Rmult_lt_compat_r.\nexact Hstep.\nnow apply IZR_lt.\napply Rcompare_Lt.\napply Rlt_le_trans with (1 := proj2 Hx').\nrewrite middle_range.\napply Rcompare_not_Lt_inv.\nrewrite <- (Rmult_1_l step) at 2.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\nrewrite Rmult_1_r.\napply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1).\nexact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (start < x < start + IZR nb_steps * step)%R.","proofString":"split.\napply Hx'.\napply Rlt_trans with (1 := proj2 Hx').\napply Rplus_lt_compat_l.\nrewrite <- (Rmult_1_l step) at 1.\napply Rmult_lt_compat_r.\nexact Hstep.\nnow apply IZR_lt."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (start < x)%R.","proofString":"apply Hx'."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (x < start + IZR nb_steps * step)%R.","proofString":"apply Rlt_trans with (1 := proj2 Hx').\napply Rplus_lt_compat_l.\nrewrite <- (Rmult_1_l step) at 1.\napply Rmult_lt_compat_r.\nexact Hstep.\nnow apply IZR_lt."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (start + step < start + IZR nb_steps * step)%R.","proofString":"apply Rplus_lt_compat_l.\nrewrite <- (Rmult_1_l step) at 1.\napply Rmult_lt_compat_r.\nexact Hstep.\nnow apply IZR_lt."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (step < IZR nb_steps * step)%R.","proofString":"rewrite <- (Rmult_1_l step) at 1.\napply Rmult_lt_compat_r.\nexact Hstep.\nnow apply IZR_lt."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (1 * step < IZR nb_steps * step)%R.","proofString":"apply Rmult_lt_compat_r.\nexact Hstep.\nnow apply IZR_lt."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (0 < step)%R.","proofString":"exact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (1 < IZR nb_steps)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : Rcompare x ((start + (start + IZR nb_steps * step)) / 2) = Lt.","proofString":"apply Rcompare_Lt.\napply Rlt_le_trans with (1 := proj2 Hx').\nrewrite middle_range.\napply Rcompare_not_Lt_inv.\nrewrite <- (Rmult_1_l step) at 2.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\nrewrite Rmult_1_r.\napply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1).\nexact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (x < (start + (start + IZR nb_steps * step)) / 2)%R.","proofString":"apply Rlt_le_trans with (1 := proj2 Hx').\nrewrite middle_range.\napply Rcompare_not_Lt_inv.\nrewrite <- (Rmult_1_l step) at 2.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\nrewrite Rmult_1_r.\napply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1).\nexact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (start + step <= (start + (start + IZR nb_steps * step)) / 2)%R.","proofString":"rewrite middle_range.\napply Rcompare_not_Lt_inv.\nrewrite <- (Rmult_1_l step) at 2.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\nrewrite Rmult_1_r.\napply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1).\nexact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (start + step <= start + IZR nb_steps / 2 * step)%R.","proofString":"apply Rcompare_not_Lt_inv.\nrewrite <- (Rmult_1_l step) at 2.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\nrewrite Rmult_1_r.\napply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1).\nexact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : Rcompare (start + IZR nb_steps / 2 * step) (start + step) <> Lt.","proofString":"rewrite <- (Rmult_1_l step) at 2.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\nrewrite Rmult_1_r.\napply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1).\nexact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : Rcompare (start + IZR nb_steps / 2 * step) (start + 1 * step) <> Lt.","proofString":"rewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_l.\nrewrite Rmult_1_r.\napply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1).\nexact Hstep."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : Rcompare (IZR nb_steps) (2 * 1) <> Lt.","proofString":"rewrite Rmult_1_r.\napply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1)."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : Rcompare (IZR nb_steps) 2 <> Lt.","proofString":"apply Rcompare_not_Lt.\napply IZR_le.\nnow apply (Zlt_le_succ 1)."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (2 <= IZR nb_steps)%R.","proofString":"apply IZR_le.\nnow apply (Zlt_le_succ 1)."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (2 <= nb_steps)%Z.","proofString":"now apply (Zlt_le_succ 1)."},{"statement":"(x : R) (l : SpecFloat.location) (Hx : inbetween start (start + step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hx' : (start < x < start + step)%R) : (0 < step)%R.","proofString":"exact Hstep."},{"statement":"(k : Z) (Hk : (2 * k + 1)%Z = nb_steps) : ((start + IZR k * step + (start + IZR (k + 1) * step)) / 2)%R =\n(start + IZR nb_steps / 2 * step)%R.","proofString":"rewrite <- Hk.\nrewrite 2!plus_IZR, mult_IZR.\nsimpl.\nfield."},{"statement":"(k : Z) (Hk : (2 * k + 1)%Z = nb_steps) : ((start + IZR k * step + (start + IZR (k + 1) * step)) / 2)%R =\n(start + IZR (2 * k + 1) / 2 * step)%R.","proofString":"rewrite 2!plus_IZR, mult_IZR.\nsimpl.\nfield."},{"statement":"(k : Z) (Hk : (2 * k + 1)%Z = nb_steps) : ((start + IZR k * step + (start + (IZR k + 1) * step)) / 2)%R =\n(start + (2 * IZR k + 1) / 2 * step)%R.","proofString":"simpl.\nfield."},{"statement":"(k : Z) (Hk : (2 * k + 1)%Z = nb_steps) : ((start + IZR k * step + (start + (IZR k + 1) * step)) / 2)%R =\n(start + (2 * IZR k + 1) / 2 * step)%R.","proofString":"field."},{"statement":"(x : R) (k : Z) (l : comparison) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x\n  (SpecFloat.loc_Inexact l)) (Hk : (2 * k + 1)%Z = nb_steps) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact l).","proofString":"apply inbetween_step_not_Eq with (1 := Hx).\nlia.\ninversion_clear Hx as [|l' _ Hl].\nnow rewrite (middle_odd _ Hk) in Hl."},{"statement":"(x : R) (k : Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x\n  SpecFloat.loc_Exact) (Hk : (2 * k + 1)%Z = nb_steps) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Lt).","proofString":"apply inbetween_step_not_Eq with (1 := Hx).\nlia.\ninversion_clear Hx as [Hl|].\nrewrite Hl.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_r.\napply Rcompare_Lt.\nrewrite <- mult_IZR.\napply IZR_lt.\nrewrite <- Hk.\napply Zlt_succ.\nexact Hstep."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hl : l <> SpecFloat.loc_Exact) (Hk : (2 * k)%Z = nb_steps) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Gt).","proofString":"apply inbetween_step_not_Eq with (1 := Hx).\nlia.\napply Rcompare_Gt.\nassert (Hx' := inbetween_bounds_not_Eq _ _ _ _ Hx Hl).\napply Rle_lt_trans with (2 := proj1 Hx').\napply Rcompare_not_Lt_inv.\nrewrite Rcompare_plus_l, Rcompare_mult_r, Rcompare_half_r.\nrewrite <- mult_IZR.\napply Rcompare_not_Lt.\napply IZR_le.\nrewrite Hk.\napply Z.le_refl.\nexact Hstep."},{"statement":"(x : R) (k : Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x\n  SpecFloat.loc_Exact) (Hk : (2 * k)%Z = nb_steps) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Eq).","proofString":"apply inbetween_step_not_Eq with (1 := Hx).\nlia.\napply Rcompare_Eq.\ninversion_clear Hx as [Hx'|].\nrewrite Hx', <- Hk, mult_IZR.\nfield."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : inbetween start (start + IZR nb_steps * step) x (new_location_even k l).","proofString":"unfold new_location_even.\ndestruct (Zeq_bool_spec k 0) as [Hk0|Hk0].\nrewrite Hk0 in Hx.\nrewrite Rmult_0_l, Rplus_0_r, Rmult_1_l in Hx.\nset (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1).\ndestruct (Zcompare_spec (2 * k) nb_steps) as [Hk1|Hk1|Hk1].\napply inbetween_step_Lo with (1 := Hx).\nlia.\ndestruct (Zeven_ex nb_steps).\nrewrite He in H.\nlia.\nset (l' := match l with loc_Exact => Eq | _ => Gt end).\nassert ((l = loc_Exact /\\ l' = Eq) \\/ (l <> loc_Exact /\\ l' = Gt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nrewrite H1 in Hx.\nnow apply inbetween_step_Mi_Mi_even with (1 := Hx).\nnow apply inbetween_step_Hi_Mi_even with (1 := Hx).\napply inbetween_step_Hi with (1 := Hx).\nexact Hk1.\napply Hk."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : inbetween start (start + IZR nb_steps * step) x\n  (if Zeq_bool k 0\n   then\n    match l with\n    | SpecFloat.loc_Exact => l\n    | SpecFloat.loc_Inexact _ => SpecFloat.loc_Inexact Lt\n    end\n   else\n    SpecFloat.loc_Inexact\n      match (2 * k ?= nb_steps)%Z with\n      | Eq =>\n          match l with\n          | SpecFloat.loc_Exact => Eq\n          | SpecFloat.loc_Inexact _ => Gt\n          end\n      | Lt => Lt\n      | Gt => Gt\n      end).","proofString":"destruct (Zeq_bool_spec k 0) as [Hk0|Hk0].\nrewrite Hk0 in Hx.\nrewrite Rmult_0_l, Rplus_0_r, Rmult_1_l in Hx.\nset (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1).\ndestruct (Zcompare_spec (2 * k) nb_steps) as [Hk1|Hk1|Hk1].\napply inbetween_step_Lo with (1 := Hx).\nlia.\ndestruct (Zeven_ex nb_steps).\nrewrite He in H.\nlia.\nset (l' := match l with loc_Exact => Eq | _ => Gt end).\nassert ((l = loc_Exact /\\ l' = Eq) \\/ (l <> loc_Exact /\\ l' = Gt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nrewrite H1 in Hx.\nnow apply inbetween_step_Mi_Mi_even with (1 := Hx).\nnow apply inbetween_step_Hi_Mi_even with (1 := Hx).\napply inbetween_step_Hi with (1 := Hx).\nexact Hk1.\napply Hk."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk0 : k = 0%Z) : inbetween start (start + IZR nb_steps * step) x\n  match l with\n  | SpecFloat.loc_Exact => l\n  | SpecFloat.loc_Inexact _ => SpecFloat.loc_Inexact Lt\n  end.","proofString":"rewrite Hk0 in Hx.\nrewrite Rmult_0_l, Rplus_0_r, Rmult_1_l in Hx.\nset (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + 0 * step) (start + IZR (0 + 1) * step) x l) (Hk0 : k = 0%Z) : inbetween start (start + IZR nb_steps * step) x\n  match l with\n  | SpecFloat.loc_Exact => l\n  | SpecFloat.loc_Inexact _ => SpecFloat.loc_Inexact Lt\n  end.","proofString":"rewrite Rmult_0_l, Rplus_0_r, Rmult_1_l in Hx.\nset (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) : inbetween start (start + IZR nb_steps * step) x\n  match l with\n  | SpecFloat.loc_Exact => l\n  | SpecFloat.loc_Inexact _ => SpecFloat.loc_Inexact Lt\n  end.","proofString":"set (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H : l = SpecFloat.loc_Exact /\\ l' = SpecFloat.loc_Exact \\/\nl <> SpecFloat.loc_Exact /\\ l' = SpecFloat.loc_Inexact Lt) : inbetween start (start + IZR nb_steps * step) x l'.","proofString":"destruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H1 : l = SpecFloat.loc_Exact) (H2 : l' = SpecFloat.loc_Exact) : inbetween start (start + IZR nb_steps * step) x SpecFloat.loc_Exact.","proofString":"constructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H1 : l = SpecFloat.loc_Exact) (H2 : l' = SpecFloat.loc_Exact) : x = start.","proofString":"rewrite H1 in Hx.\nnow inversion_clear Hx."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x SpecFloat.loc_Exact) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H1 : l = SpecFloat.loc_Exact) (H2 : l' = SpecFloat.loc_Exact) : x = start.","proofString":"now inversion_clear Hx."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H1 : l <> SpecFloat.loc_Exact) (H2 : l' = SpecFloat.loc_Inexact Lt) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Lt).","proofString":"now apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk0 : k <> 0%Z) : inbetween start (start + IZR nb_steps * step) x\n  (SpecFloat.loc_Inexact\n     match (2 * k ?= nb_steps)%Z with\n     | Eq =>\n         match l with\n         | SpecFloat.loc_Exact => Eq\n         | SpecFloat.loc_Inexact _ => Gt\n         end\n     | Lt => Lt\n     | Gt => Gt\n     end).","proofString":"destruct (Zcompare_spec (2 * k) nb_steps) as [Hk1|Hk1|Hk1].\napply inbetween_step_Lo with (1 := Hx).\nlia.\ndestruct (Zeven_ex nb_steps).\nrewrite He in H.\nlia.\nset (l' := match l with loc_Exact => Eq | _ => Gt end).\nassert ((l = loc_Exact /\\ l' = Eq) \\/ (l <> loc_Exact /\\ l' = Gt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nrewrite H1 in Hx.\nnow apply inbetween_step_Mi_Mi_even with (1 := Hx).\nnow apply inbetween_step_Hi_Mi_even with (1 := Hx).\napply inbetween_step_Hi with (1 := Hx).\nexact Hk1.\napply Hk."},{"statement":"(He : Z.even nb_steps = true) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk0 : k <> 0%Z) (Hk1 : (2 * k < nb_steps)%Z) : (0 < k)%Z.","proofString":"lia."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : inbetween start (start + IZR nb_steps * step) x (new_location_odd k l).","proofString":"unfold new_location_odd.\ndestruct (Zeq_bool_spec k 0) as [Hk0|Hk0].\nrewrite Hk0 in Hx.\nrewrite Rmult_0_l, Rplus_0_r, Rmult_1_l in Hx.\nset (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1).\ndestruct (Zcompare_spec (2 * k + 1) nb_steps) as [Hk1|Hk1|Hk1].\napply inbetween_step_Lo with (1 := Hx) (3 := Hk1).\nlia.\ndestruct l.\napply inbetween_step_Lo_Mi_Eq_odd with (1 := Hx) (2 := Hk1).\napply inbetween_step_any_Mi_odd with (1 := Hx) (2 := Hk1).\napply inbetween_step_Hi with (1 := Hx).\ndestruct (Zeven_ex nb_steps).\nrewrite Ho in H.\nlia.\napply Hk."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : inbetween start (start + IZR nb_steps * step) x\n  (if Zeq_bool k 0\n   then\n    match l with\n    | SpecFloat.loc_Exact => l\n    | SpecFloat.loc_Inexact _ => SpecFloat.loc_Inexact Lt\n    end\n   else\n    SpecFloat.loc_Inexact\n      match (2 * k + 1 ?= nb_steps)%Z with\n      | Eq =>\n          match l with\n          | SpecFloat.loc_Exact => Lt\n          | SpecFloat.loc_Inexact l0 => l0\n          end\n      | Lt => Lt\n      | Gt => Gt\n      end).","proofString":"destruct (Zeq_bool_spec k 0) as [Hk0|Hk0].\nrewrite Hk0 in Hx.\nrewrite Rmult_0_l, Rplus_0_r, Rmult_1_l in Hx.\nset (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1).\ndestruct (Zcompare_spec (2 * k + 1) nb_steps) as [Hk1|Hk1|Hk1].\napply inbetween_step_Lo with (1 := Hx) (3 := Hk1).\nlia.\ndestruct l.\napply inbetween_step_Lo_Mi_Eq_odd with (1 := Hx) (2 := Hk1).\napply inbetween_step_any_Mi_odd with (1 := Hx) (2 := Hk1).\napply inbetween_step_Hi with (1 := Hx).\ndestruct (Zeven_ex nb_steps).\nrewrite Ho in H.\nlia.\napply Hk."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk0 : k = 0%Z) : inbetween start (start + IZR nb_steps * step) x\n  match l with\n  | SpecFloat.loc_Exact => l\n  | SpecFloat.loc_Inexact _ => SpecFloat.loc_Inexact Lt\n  end.","proofString":"rewrite Hk0 in Hx.\nrewrite Rmult_0_l, Rplus_0_r, Rmult_1_l in Hx.\nset (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + 0 * step) (start + IZR (0 + 1) * step) x l) (Hk0 : k = 0%Z) : inbetween start (start + IZR nb_steps * step) x\n  match l with\n  | SpecFloat.loc_Exact => l\n  | SpecFloat.loc_Inexact _ => SpecFloat.loc_Inexact Lt\n  end.","proofString":"rewrite Rmult_0_l, Rplus_0_r, Rmult_1_l in Hx.\nset (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) : inbetween start (start + IZR nb_steps * step) x\n  match l with\n  | SpecFloat.loc_Exact => l\n  | SpecFloat.loc_Inexact _ => SpecFloat.loc_Inexact Lt\n  end.","proofString":"set (l' := match l with loc_Exact => l | _ => loc_Inexact Lt end).\nassert ((l = loc_Exact /\\ l' = loc_Exact) \\/ (l <> loc_Exact /\\ l' = loc_Inexact Lt)).\nunfold l' ; case l ; try (now left) ; right ; now split.\ndestruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H : l = SpecFloat.loc_Exact /\\ l' = SpecFloat.loc_Exact \\/\nl <> SpecFloat.loc_Exact /\\ l' = SpecFloat.loc_Inexact Lt) : inbetween start (start + IZR nb_steps * step) x l'.","proofString":"destruct H as [(H1,H2)|(H1,H2)] ; rewrite H2.\nconstructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx.\nnow apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H1 : l = SpecFloat.loc_Exact) (H2 : l' = SpecFloat.loc_Exact) : inbetween start (start + IZR nb_steps * step) x SpecFloat.loc_Exact.","proofString":"constructor.\nrewrite H1 in Hx.\nnow inversion_clear Hx."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H1 : l = SpecFloat.loc_Exact) (H2 : l' = SpecFloat.loc_Exact) : x = start.","proofString":"rewrite H1 in Hx.\nnow inversion_clear Hx."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x SpecFloat.loc_Exact) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H1 : l = SpecFloat.loc_Exact) (H2 : l' = SpecFloat.loc_Exact) : x = start.","proofString":"now inversion_clear Hx."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween start (start + step) x l) (Hk0 : k = 0%Z) (l' : SpecFloat.location) (H1 : l <> SpecFloat.loc_Exact) (H2 : l' = SpecFloat.loc_Inexact Lt) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Lt).","proofString":"now apply inbetween_step_Lo_not_Eq with (2 := H1)."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk0 : k <> 0%Z) : inbetween start (start + IZR nb_steps * step) x\n  (SpecFloat.loc_Inexact\n     match (2 * k + 1 ?= nb_steps)%Z with\n     | Eq =>\n         match l with\n         | SpecFloat.loc_Exact => Lt\n         | SpecFloat.loc_Inexact l0 => l0\n         end\n     | Lt => Lt\n     | Gt => Gt\n     end).","proofString":"destruct (Zcompare_spec (2 * k + 1) nb_steps) as [Hk1|Hk1|Hk1].\napply inbetween_step_Lo with (1 := Hx) (3 := Hk1).\nlia.\ndestruct l.\napply inbetween_step_Lo_Mi_Eq_odd with (1 := Hx) (2 := Hk1).\napply inbetween_step_any_Mi_odd with (1 := Hx) (2 := Hk1).\napply inbetween_step_Hi with (1 := Hx).\ndestruct (Zeven_ex nb_steps).\nrewrite Ho in H.\nlia.\napply Hk."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk0 : k <> 0%Z) (Hk1 : (2 * k + 1 < nb_steps)%Z) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Lt).","proofString":"apply inbetween_step_Lo with (1 := Hx) (3 := Hk1).\nlia."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk0 : k <> 0%Z) (Hk1 : (2 * k + 1 < nb_steps)%Z) : (0 < k)%Z.","proofString":"lia."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk0 : k <> 0%Z) (Hk1 : (2 * k + 1)%Z = nb_steps) : inbetween start (start + IZR nb_steps * step) x\n  (SpecFloat.loc_Inexact\n     match l with\n     | SpecFloat.loc_Exact => Lt\n     | SpecFloat.loc_Inexact l0 => l0\n     end).","proofString":"destruct l.\napply inbetween_step_Lo_Mi_Eq_odd with (1 := Hx) (2 := Hk1).\napply inbetween_step_any_Mi_odd with (1 := Hx) (2 := Hk1)."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x\n  SpecFloat.loc_Exact) (Hk0 : k <> 0%Z) (Hk1 : (2 * k + 1)%Z = nb_steps) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Lt).","proofString":"apply inbetween_step_Lo_Mi_Eq_odd with (1 := Hx) (2 := Hk1)."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (c : comparison) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x\n  (SpecFloat.loc_Inexact c)) (Hk0 : k <> 0%Z) (Hk1 : (2 * k + 1)%Z = nb_steps) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact c).","proofString":"apply inbetween_step_any_Mi_odd with (1 := Hx) (2 := Hk1)."},{"statement":"(Ho : Z.even nb_steps = false) (x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hk0 : k <> 0%Z) (Hk1 : (nb_steps < 2 * k + 1)%Z) : inbetween start (start + IZR nb_steps * step) x (SpecFloat.loc_Inexact Gt).","proofString":"apply inbetween_step_Hi with (1 := Hx).\ndestruct (Zeven_ex nb_steps).\nrewrite Ho in H.\nlia.\napply Hk."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : inbetween start (start + IZR nb_steps * step) x (new_location k l).","proofString":"unfold new_location.\ngeneralize (refl_equal nb_steps) (Z.le_lt_trans _ _ _ (proj1 Hk) (proj2 Hk)).\npattern nb_steps at 2 3 5 ; case nb_steps.\nnow intros _.\nintros [p|p|] Hp _.\napply new_location_odd_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp.\napply new_location_even_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp.\nnow rewrite Hp in Hnb_steps.\nnow intros p _."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : inbetween start (start + IZR nb_steps * step) x\n  ((if Z.even nb_steps then new_location_even else new_location_odd) k l).","proofString":"generalize (refl_equal nb_steps) (Z.le_lt_trans _ _ _ (proj1 Hk) (proj2 Hk)).\npattern nb_steps at 2 3 5 ; case nb_steps.\nnow intros _.\nintros [p|p|] Hp _.\napply new_location_odd_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp.\napply new_location_even_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp.\nnow rewrite Hp in Hnb_steps.\nnow intros p _."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : nb_steps = nb_steps ->\n(0 < nb_steps)%Z ->\ninbetween start (start + IZR nb_steps * step) x\n  ((if Z.even nb_steps then new_location_even else new_location_odd) k l).","proofString":"pattern nb_steps at 2 3 5 ; case nb_steps.\nnow intros _.\nintros [p|p|] Hp _.\napply new_location_odd_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp.\napply new_location_even_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp.\nnow rewrite Hp in Hnb_steps.\nnow intros p _."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : nb_steps = 0%Z ->\n(0 < 0)%Z ->\ninbetween start (start + IZR nb_steps * step) x\n  ((if Z.even 0 then new_location_even else new_location_odd) k l).","proofString":"now intros _."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : forall p : positive,\nnb_steps = Z.pos p ->\n(0 < Z.pos p)%Z ->\ninbetween start (start + IZR nb_steps * step) x\n  ((if Z.even (Z.pos p) then new_location_even else new_location_odd) k l).","proofString":"intros [p|p|] Hp _.\napply new_location_odd_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp.\napply new_location_even_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp.\nnow rewrite Hp in Hnb_steps."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (p : positive) (Hp : nb_steps = Z.pos p~1) : inbetween start (start + IZR nb_steps * step) x\n  ((if Z.even (Z.pos p~1) then new_location_even else new_location_odd) k l).","proofString":"apply new_location_odd_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (p : positive) (Hp : nb_steps = Z.pos p~1) : Z.even nb_steps = false.","proofString":"now rewrite Hp."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (p : positive) (Hp : nb_steps = Z.pos p~0) : inbetween start (start + IZR nb_steps * step) x\n  ((if Z.even (Z.pos p~0) then new_location_even else new_location_odd) k l).","proofString":"apply new_location_even_correct with (2 := Hk) (3 := Hx).\nnow rewrite Hp."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (p : positive) (Hp : nb_steps = Z.pos p~0) : Z.even nb_steps = true.","proofString":"now rewrite Hp."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) (Hp : nb_steps = 1%Z) : inbetween start (start + IZR nb_steps * step) x\n  ((if Z.even 1 then new_location_even else new_location_odd) k l).","proofString":"now rewrite Hp in Hnb_steps."},{"statement":"(x : R) (k : Z) (l : SpecFloat.location) (Hk : (0 <= k < nb_steps)%Z) (Hx : inbetween (start + IZR k * step) (start + IZR (k + 1) * step) x l) : forall p : positive,\nnb_steps = Z.neg p ->\n(0 < Z.neg p)%Z ->\ninbetween start (start + IZR nb_steps * step) x\n  ((if Z.even (Z.neg p) then new_location_even else new_location_odd) k l).","proofString":"now intros p _."},{"statement":"(x d u : R) (l : SpecFloat.location) (t : R) (Hx : u = x) : (u + t)%R = (x + t)%R.","proofString":"now rewrite Hx."},{"statement":"(x d u : R) (l : SpecFloat.location) (t : R) (l' : comparison) (Hx : (x < u < d)%R) (Hl : Rcompare u ((x + d) / 2) = l') : (x + t < u + t < d + t)%R.","proofString":"now split ; apply Rplus_lt_compat_r."},{"statement":"(x d u : R) (l : SpecFloat.location) (t : R) (l' : comparison) (Hx : (x < u < d)%R) (Hl : Rcompare u ((x + d) / 2) = l') : Rcompare (u + t) ((x + t + (d + t)) / 2) = l'.","proofString":"replace ((x + t + (d + t)) / 2)%R with ((x + d) / 2 + t)%R by field.\nnow rewrite Rcompare_plus_r."},{"statement":"(x d u : R) (l : SpecFloat.location) (t : R) (l' : comparison) (Hx : (x < u < d)%R) (Hl : Rcompare u ((x + d) / 2) = l') : Rcompare (u + t) ((x + d) / 2 + t) = l'.","proofString":"now rewrite Rcompare_plus_r."},{"statement":"(x d u : R) (l : SpecFloat.location) (t : R) (H : inbetween (x + t) (d + t) (u + t) l) : inbetween x d u l.","proofString":"generalize (inbetween_plus_compat _ _ _ _ (Ropp t) H).\nassert (K: forall y, (y + t + -t = y)%R) by (intros y ; ring).\nnow rewrite 3!K."},{"statement":"(x d u : R) (l : SpecFloat.location) (t : R) (H : inbetween (x + t) (d + t) (u + t) l) : inbetween (x + t + - t) (d + t + - t) (u + t + - t) l -> inbetween x d u l.","proofString":"assert (K: forall y, (y + t + -t = y)%R) by (intros y ; ring).\nnow rewrite 3!K."},{"statement":"(x d u : R) (l : SpecFloat.location) (t : R) (H : inbetween (x + t) (d + t) (u + t) l) (K : forall y : R, (y + t + - t)%R = y) : inbetween (x + t + - t) (d + t + - t) (u + t + - t) l -> inbetween x d u l.","proofString":"now rewrite 3!K."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (Hx : u = x) : (u * s)%R = (x * s)%R.","proofString":"now rewrite Hx."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (l' : comparison) (Hx : (x < u < d)%R) (Hl : Rcompare u ((x + d) / 2) = l') : (x * s < u * s < d * s)%R.","proofString":"now split ; apply Rmult_lt_compat_r."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (l' : comparison) (Hx : (x < u < d)%R) (Hl : Rcompare u ((x + d) / 2) = l') : Rcompare (u * s) ((x * s + d * s) / 2) = l'.","proofString":"replace ((x * s + d * s) / 2)%R with ((x + d) / 2 * s)%R by field.\nnow rewrite Rcompare_mult_r."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (l' : comparison) (Hx : (x < u < d)%R) (Hl : Rcompare u ((x + d) / 2) = l') : Rcompare (u * s) ((x + d) / 2 * s) = l'.","proofString":"now rewrite Rcompare_mult_r."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (H : inbetween (x * s) (d * s) (u * s) l) : inbetween x d u l.","proofString":"generalize (inbetween_mult_compat _ _ _ _ _ (Rinv_0_lt_compat s Hs) H).\nassert (K: forall y, (y * s * /s = y)%R).\nintros y.\nfield.\nnow apply Rgt_not_eq.\nnow rewrite 3!K."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (H : inbetween (x * s) (d * s) (u * s) l) : inbetween (x * s * / s) (d * s * / s) (u * s * / s) l -> inbetween x d u l.","proofString":"assert (K: forall y, (y * s * /s = y)%R).\nintros y.\nfield.\nnow apply Rgt_not_eq.\nnow rewrite 3!K."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (H : inbetween (x * s) (d * s) (u * s) l) : forall y : R, (y * s * / s)%R = y.","proofString":"intros y.\nfield.\nnow apply Rgt_not_eq."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (H : inbetween (x * s) (d * s) (u * s) l) (y : R) : (y * s * / s)%R = y.","proofString":"field.\nnow apply Rgt_not_eq."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (H : inbetween (x * s) (d * s) (u * s) l) (y : R) : s <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x d u : R) (l : SpecFloat.location) (s : R) (Hs : (0 < s)%R) (H : inbetween (x * s) (d * s) (u * s) l) (K : forall y : R, (y * s * / s)%R = y) : inbetween (x * s * / s) (d * s * / s) (u * s * / s) l -> inbetween x d u l.","proofString":"now rewrite 3!K."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (k : Z) (Hk : (0 < k)%Z) (Hx : inbetween_float m e x l) : inbetween_float (m / beta ^ k) (e + k) x\n  (new_location (beta ^ k) (m mod beta ^ k) l).","proofString":"unfold inbetween_float in *.\nassert (Hr: forall m, F2R (Float beta m (e + k)) = F2R (Float beta (m * Zpower beta k) e)).\nclear -Hk.\nintros m.\nrewrite (F2R_change_exp beta e).\napply (f_equal (fun r => F2R (Float beta (m * Zpower _ r) e))).\nring.\nlia.\nassert (Hp: (Zpower beta k > 0)%Z).\napply Z.lt_gt.\napply Zpower_gt_0.\nnow apply Zlt_le_weak.\nrewrite 2!Hr.\nrewrite Zmult_plus_distr_l, Zmult_1_l.\nunfold F2R at 2.\nsimpl.\nrewrite plus_IZR, Rmult_plus_distr_r.\napply new_location_correct; unfold F2R; simpl.\napply bpow_gt_0.\nnow apply Zpower_gt_1.\nnow apply Z_mod_lt.\nrewrite <- 2!Rmult_plus_distr_r, <- 2!plus_IZR.\nrewrite Zmult_comm, Zplus_assoc.\n(try now rewrite <- Z_div_mod_eq_full); now rewrite <- Z_div_mod_eq."},{"statement":"(e k : Z) (Hk : (0 < k)%Z) (m : Z) : (e + k - e)%Z = k.","proofString":"ring."},{"statement":"(e k : Z) (Hk : (0 < k)%Z) (m : Z) : (e <= e + k)%Z.","proofString":"lia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : inbetween_float m e x l) : inbetween_float (m / beta) (e + 1) x (new_location beta (m mod beta) l).","proofString":"replace (radix_val beta) with (Zpower beta 1).\nnow apply inbetween_float_new_location.\napply Zmult_1_r."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : inbetween_float m e x l) : inbetween_float (m / beta ^ 1) (e + 1) x\n  (new_location (beta ^ 1) (m mod beta ^ 1) l).","proofString":"now apply inbetween_float_new_location."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : inbetween_float m e x l) : (beta ^ 1)%Z = beta.","proofString":"apply Zmult_1_r."},{"statement":"(m e : Z) (l : SpecFloat.location) : exists x : R, inbetween_float m e x l.","proofString":"apply inbetween_ex.\napply F2R_lt.\napply Zlt_succ."},{"statement":"(m e : Z) (l : SpecFloat.location) : (m < m + 1)%Z.","proofString":"apply Zlt_succ."},{"statement":"(x : R) (e m : Z) (l : SpecFloat.location) (m' : Z) (l' : SpecFloat.location) (H : inbetween_float m e x l) (H' : inbetween_float m' e x l') : m = m' /\\ l = l'.","proofString":"refine ((fun Hm => conj Hm _) _).\nrewrite <- Hm in H'.\nclear -H H'.\napply inbetween_unique with (1 := H) (2 := H').\ndestruct (inbetween_float_bounds x m e l H) as (H1,H2).\ndestruct (inbetween_float_bounds x m' e l' H') as (H3,H4).\ncut (m < m' + 1 /\\ m' < m + 1)%Z.\nclear ; lia.\nnow split ; apply lt_F2R with beta e ; apply Rle_lt_trans with x."},{"statement":"(x : R) (e m : Z) (l : SpecFloat.location) (m' : Z) (l' : SpecFloat.location) (H : inbetween_float m e x l) (H' : inbetween_float m' e x l') (Hm : m = m') : l = l'.","proofString":"rewrite <- Hm in H'.\nclear -H H'.\napply inbetween_unique with (1 := H) (2 := H')."},{"statement":"(x : R) (e m : Z) (l : SpecFloat.location) (m' : Z) (l' : SpecFloat.location) (H : inbetween_float m e x l) (H' : inbetween_float m e x l') (Hm : m = m') : l = l'.","proofString":"clear -H H'.\napply inbetween_unique with (1 := H) (2 := H')."},{"statement":"(x : R) (e m : Z) (l l' : SpecFloat.location) (H : inbetween_float m e x l) (H' : inbetween_float m e x l') : l = l'.","proofString":"apply inbetween_unique with (1 := H) (2 := H')."},{"statement":"(x : R) (e m : Z) (l : SpecFloat.location) (m' : Z) (l' : SpecFloat.location) (H : inbetween_float m e x l) (H' : inbetween_float m' e x l') : m = m'.","proofString":"destruct (inbetween_float_bounds x m e l H) as (H1,H2).\ndestruct (inbetween_float_bounds x m' e l' H') as (H3,H4).\ncut (m < m' + 1 /\\ m' < m + 1)%Z.\nclear ; lia.\nnow split ; apply lt_F2R with beta e ; apply Rle_lt_trans with x."}]}