{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/x86/SelectLongproof.v","fileSamples":[{"statement":"(le : letenv) (n : int64) : eval_expr ge sp e m le (Eop (Olongconst n) Enil) (Vlong n).","proofString":"EvalOp."},{"statement":"(v : val) (a : expr) (n : int64) (le : letenv) (H : match is_longconst_match a with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) (H0 : eval_expr ge sp e m le a v) : v = Vlong n.","proofString":"eapply SplitLongproof.is_longconst_sound; eauto."},{"statement":"(v : val) (n : int64) (le : letenv) (H0 : eval_expr ge sp e m le (Eop (Olongconst n) Enil) v) (H : match is_longconst_match (Eop (Olongconst n) Enil) with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) : v = Vlong n.","proofString":"InvEval.\nauto."},{"statement":"(n : int64) (le : letenv) (H : match is_longconst_match (Eop (Olongconst n) Enil) with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) : Vlong n = Vlong n.","proofString":"auto."},{"statement":"(le : letenv) (x : val) (n : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n) Enil) x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.not n)) Enil) v /\\\n  Val.lessdef (Val.notl x) v.","proofString":"InvEval.\neconstructor; split.\napply eval_longconst.\nauto."},{"statement":"(le : letenv) (n : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.not n)) Enil) v /\\\n  Val.lessdef (Val.notl (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nauto."},{"statement":"(le : letenv) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (H : Val.andl v1 (Vlong n2) = Vundef) : eval_expr ge sp e m le (andlimm_base (Int64.and Int64.zero n2) t2)\n  (Vlong Int64.zero).","proofString":"apply eval_longconst."},{"statement":"(le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\ Val.lessdef (Val.andl x y) v.","proofString":"InvEval.\nrewrite Val.andl_commut.\napply eval_andlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\\n  Val.lessdef (Val.andl (Vlong n1) y) v.","proofString":"rewrite Val.andl_commut.\napply eval_andlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\\n  Val.lessdef (Val.andl y (Vlong n1)) v.","proofString":"apply eval_andlimm; auto."},{"statement":"(le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (H0 : eval_expr ge sp e m le (Eop (Olongconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n2 t1) v /\\ Val.lessdef (Val.andl x y) v.","proofString":"InvEval.\napply eval_andlimm; auto."},{"statement":"(le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (andlimm n2 t1) v /\\\n  Val.lessdef (Val.andl x (Vlong n2)) v.","proofString":"apply eval_andlimm; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then a\n     else\n      if Int64.eq n Int64.mone\n      then Eop (Olongconst Int64.mone) Enil\n      else\n       match orlimm_match a with\n       | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n       | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n       | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n       end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nexists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone.\neconstructor; split.\napply eval_longconst.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_mone; auto.\ndestruct (orlimm_match a); InvEval; subst.\neconstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto.\nTrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"exists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : Val.lessdef (Val.orl x (Vlong n)) x.","proofString":"subst.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.orl x (Vlong Int64.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.or i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.or_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.mone\n     then Eop (Olongconst Int64.mone) Enil\n     else\n      match orlimm_match a with\n      | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n      | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n      | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n      end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.mone.\neconstructor; split.\napply eval_longconst.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_mone; auto.\ndestruct (orlimm_match a); InvEval; subst.\neconstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto.\nTrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.mone) Enil) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_mone; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.mone <> Int64.zero) : Val.lessdef (Val.orl x (Vlong Int64.mone)) (Vlong Int64.mone).","proofString":"destruct x; simpl; auto.\nrewrite Int64.or_mone; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int64.mone <> Int64.zero) : Val.lessdef (Vlong (Int64.or i Int64.mone)) (Vlong Int64.mone).","proofString":"rewrite Int64.or_mone; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le\n    match orlimm_match a with\n    | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n    | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n    | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"destruct (orlimm_match a); InvEval; subst.\neconstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto.\nTrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.or n n2)) Enil) v /\\\n  Val.lessdef (Val.orl (Vlong n2) (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : Val.lessdef (Vlong (Int64.or n2 n)) (Vlong (Int64.or n n2)).","proofString":"rewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : eval_operation ge sp (Oorlimm (Int64.or n n2)) (v1 :: nil) m =\nSome (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)).","proofString":"simpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : Some (Val.orl v1 (Vlong (Int64.or n n2))) =\nSome (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)).","proofString":"rewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : Some (Val.orl v1 (Vlong (Int64.or n n2))) =\nSome (Val.orl v1 (Val.orl (Vlong n2) (Vlong n))).","proofString":"rewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm n) (e2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) : forall (v : val) (n1 n2 : int),\nInt.add n1 n2 = Int64.iwordsize' ->\nVal.lessdef (Val.orl (Val.shll v (Vint n1)) (Val.shrlu v (Vint n2)))\n  (Val.rorl v (Vint n2)).","proofString":"intros.\ndestruct v; simpl; auto.\ndestruct (Int.ltu n1 Int64.iwordsize') eqn:N1; auto.\ndestruct (Int.ltu n2 Int64.iwordsize') eqn:N2; auto.\nsimpl.\nrewrite <- Int64.or_ror'; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v0 : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v0 /\\\n  Val.lessdef (Val.orl x y) v0) (v : val) (n1 n2 : int) (H1 : Int.add n1 n2 = Int64.iwordsize') : Val.lessdef (Val.orl (Val.shll v (Vint n1)) (Val.shrlu v (Vint n2)))\n  (Val.rorl v (Vint n2)).","proofString":"destruct v; simpl; auto.\ndestruct (Int.ltu n1 Int64.iwordsize') eqn:N1; auto.\ndestruct (Int.ltu n2 Int64.iwordsize') eqn:N2; auto.\nsimpl.\nrewrite <- Int64.or_ror'; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (i : int64) (n1 n2 : int) (H1 : Int.add n1 n2 = Int64.iwordsize') : Val.lessdef\n  (Val.orl\n     (if Int.ltu n1 Int64.iwordsize' then Vlong (Int64.shl' i n1) else Vundef)\n     (if Int.ltu n2 Int64.iwordsize'\n      then Vlong (Int64.shru' i n2)\n      else Vundef)) (Vlong (Int64.ror i (Int64.repr (Int.unsigned n2)))).","proofString":"destruct (Int.ltu n1 Int64.iwordsize') eqn:N1; auto.\ndestruct (Int.ltu n2 Int64.iwordsize') eqn:N2; auto.\nsimpl.\nrewrite <- Int64.or_ror'; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (i : int64) (n1 n2 : int) (H1 : Int.add n1 n2 = Int64.iwordsize') (N1 : Int.ltu n1 Int64.iwordsize' = true) : Val.lessdef\n  (Val.orl (Vlong (Int64.shl' i n1))\n     (if Int.ltu n2 Int64.iwordsize'\n      then Vlong (Int64.shru' i n2)\n      else Vundef)) (Vlong (Int64.ror i (Int64.repr (Int.unsigned n2)))).","proofString":"destruct (Int.ltu n2 Int64.iwordsize') eqn:N2; auto.\nsimpl.\nrewrite <- Int64.or_ror'; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (i : int64) (n1 n2 : int) (H1 : Int.add n1 n2 = Int64.iwordsize') (N1 : Int.ltu n1 Int64.iwordsize' = true) (N2 : Int.ltu n2 Int64.iwordsize' = true) : Val.lessdef (Val.orl (Vlong (Int64.shl' i n1)) (Vlong (Int64.shru' i n2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned n2)))).","proofString":"simpl.\nrewrite <- Int64.or_ror'; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (i : int64) (n1 n2 : int) (H1 : Int.add n1 n2 = Int64.iwordsize') (N1 : Int.ltu n1 Int64.iwordsize' = true) (N2 : Int.ltu n2 Int64.iwordsize' = true) : Val.lessdef (Vlong (Int64.or (Int64.shl' i n1) (Int64.shru' i n2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned n2)))).","proofString":"rewrite <- Int64.or_ror'; auto."},{"statement":"(le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Oorl (Eop (Olongconst n1) Enil ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (ROR : forall (v : val) (n0 n2 : int),\nInt.add n0 n2 = Int64.iwordsize' ->\nVal.lessdef (Val.orl (Val.shll v (Vint n0)) (Val.shrlu v (Vint n2)))\n  (Val.rorl v (Vint n2))) : exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\ Val.lessdef (Val.orl x y) v.","proofString":"InvEval.\nrewrite Val.orl_commut.\napply eval_orlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Oorl (Eop (Olongconst n1) Enil ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Vlong n1) y) v) (ROR : forall (v : val) (n0 n2 : int),\nInt.add n0 n2 = Int64.iwordsize' ->\nVal.lessdef (Val.orl (Val.shll v (Vint n0)) (Val.shrlu v (Vint n2)))\n  (Val.rorl v (Vint n2))) : exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\\n  Val.lessdef (Val.orl (Vlong n1) y) v.","proofString":"rewrite Val.orl_commut.\napply eval_orlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Oorl (Eop (Olongconst n1) Enil ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Vlong n1) y) v) (ROR : forall (v : val) (n0 n2 : int),\nInt.add n0 n2 = Int64.iwordsize' ->\nVal.lessdef (Val.orl (Val.shll v (Vint n0)) (Val.shrlu v (Vint n2)))\n  (Val.rorl v (Vint n2))) : exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\\n  Val.lessdef (Val.orl y (Vlong n1)) v.","proofString":"apply eval_orlimm; auto."},{"statement":"(le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (H0 : eval_expr ge sp e m le (Eop (Olongconst n2) Enil) y) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Oorl (t1 ::: Eop (Olongconst n2) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v) (ROR : forall (v : val) (n1 n0 : int),\nInt.add n1 n0 = Int64.iwordsize' ->\nVal.lessdef (Val.orl (Val.shll v (Vint n1)) (Val.shrlu v (Vint n0)))\n  (Val.rorl v (Vint n0))) : exists v : val,\n  eval_expr ge sp e m le (orlimm n2 t1) v /\\ Val.lessdef (Val.orl x y) v.","proofString":"InvEval.\napply eval_orlimm; auto."},{"statement":"(le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Oorl (t1 ::: Eop (Olongconst n2) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Vlong n2)) v) (ROR : forall (v : val) (n1 n0 : int),\nInt.add n1 n0 = Int64.iwordsize' ->\nVal.lessdef (Val.orl (Val.shll v (Vint n1)) (Val.shrlu v (Vint n0)))\n  (Val.rorl v (Vint n0))) : exists v : val,\n  eval_expr ge sp e m le (orlimm n2 t1) v /\\\n  Val.lessdef (Val.orl x (Vlong n2)) v.","proofString":"apply eval_orlimm; auto."},{"statement":"(le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\ Val.lessdef (Val.xorl x y) v.","proofString":"InvEval.\nrewrite Val.xorl_commut.\napply eval_xorlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\\n  Val.lessdef (Val.xorl (Vlong n1) y) v.","proofString":"rewrite Val.xorl_commut.\napply eval_xorlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\\n  Val.lessdef (Val.xorl y (Vlong n1)) v.","proofString":"apply eval_xorlimm; auto."},{"statement":"(le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (H0 : eval_expr ge sp e m le (Eop (Olongconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n2 t1) v /\\ Val.lessdef (Val.xorl x y) v.","proofString":"InvEval.\napply eval_xorlimm; auto."},{"statement":"(le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n2 t1) v /\\\n  Val.lessdef (Val.xorl x (Vlong n2)) v.","proofString":"apply eval_xorlimm; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint n)) v.","proofString":"exists x; split; auto.\nsubst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : Val.lessdef (Val.shll x (Vint n)) x.","proofString":"subst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i).","proofString":"destruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shl' i Int.zero)) (Vlong i).","proofString":"change (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shl i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.shl_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shl' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shll (Vlong n1) (Vint n)) v.","proofString":"TrivialExists.\nsimpl; rewrite LT; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : eval_operation ge sp (Olongconst (Int64.shl' n1 n)) nil m =\nSome (Val.shll (Vlong n1) (Vint n)).","proofString":"simpl; rewrite LT; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrlu x (Vint n)) v.","proofString":"exists x; split; auto.\nsubst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : Val.lessdef (Val.shrlu x (Vint n)) x.","proofString":"subst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru' i Int.zero)\n   else Vundef) (Vlong i).","proofString":"destruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shru' i Int.zero)) (Vlong i).","proofString":"change (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shru i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.shru_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shru' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shrlu (Vlong n1) (Vint n)) v.","proofString":"TrivialExists.\nsimpl; rewrite LT; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : eval_operation ge sp (Olongconst (Int64.shru' n1 n)) nil m =\nSome (Val.shrlu (Vlong n1) (Vint n)).","proofString":"simpl; rewrite LT; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint n)) v.","proofString":"exists x; split; auto.\nsubst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : Val.lessdef (Val.shrl x (Vint n)) x.","proofString":"subst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i).","proofString":"destruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shr' i Int.zero)) (Vlong i).","proofString":"change (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shr i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.shr_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shr' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shrl (Vlong n1) (Vint n)) v.","proofString":"TrivialExists.\nsimpl; rewrite LT; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : eval_operation ge sp (Olongconst (Int64.shr' n1 n)) nil m =\nSome (Val.shrl (Vlong n1) (Vint n)).","proofString":"simpl; rewrite LT; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong n)) v.","proofString":"subst.\nexists x; split; auto.\ndestruct x; simpl; rewrite ?Int64.add_zero, ?Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong Int64.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; rewrite ?Int64.add_zero, ?Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.addl x (Vlong Int64.zero)) x.","proofString":"destruct x; simpl; rewrite ?Int64.add_zero, ?Ptrofs.add_zero; auto."},{"statement":"(n : int64) (le : letenv) (m0 : int64) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add n m0)) v /\\\n  Val.lessdef (Val.addl (Vlong m0) (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nrewrite Int64.add_commut; auto."},{"statement":"forall x y : Z, Int64.repr (x + y) = Int64.add (Int64.repr x) (Int64.repr y).","proofString":"intros; apply Int64.eqm_samerepr; auto with ints."},{"statement":"(A : forall x y : Z, Int64.repr (x + y) = Int64.add (Int64.repr x) (Int64.repr y)) : forall (id : ident) (ofs : ptrofs) (n : Z),\nArchi.ptr64 = true ->\nGenv.symbol_address ge id (Ptrofs.add ofs (Ptrofs.repr n)) =\nVal.addl (Genv.symbol_address ge id ofs) (Vlong (Int64.repr n)).","proofString":"intros.\nreplace (Ptrofs.repr n) with (Ptrofs.of_int64 (Int64.repr n)) by auto with ptrofs.\napply Genv.shift_symbol_address_64; auto."},{"statement":"(A : forall x y : Z, Int64.repr (x + y) = Int64.add (Int64.repr x) (Int64.repr y)) (id : ident) (ofs : ptrofs) (n : Z) (H : Archi.ptr64 = true) : Genv.symbol_address ge id (Ptrofs.add ofs (Ptrofs.repr n)) =\nVal.addl (Genv.symbol_address ge id ofs) (Vlong (Int64.repr n)).","proofString":"replace (Ptrofs.repr n) with (Ptrofs.of_int64 (Int64.repr n)) by auto with ptrofs.\napply Genv.shift_symbol_address_64; auto."},{"statement":"(A : forall x y : Z, Int64.repr (x + y) = Int64.add (Int64.repr x) (Int64.repr y)) (id : ident) (ofs : ptrofs) (n : Z) (H : Archi.ptr64 = true) : Genv.symbol_address ge id (Ptrofs.add ofs (Ptrofs.of_int64 (Int64.repr n))) =\nVal.addl (Genv.symbol_address ge id ofs) (Vlong (Int64.repr n)).","proofString":"apply Genv.shift_symbol_address_64; auto."},{"statement":"(A : forall x y0 : Z,\nInt64.repr (x + y0) = Int64.add (Int64.repr x) (Int64.repr y0)) (B : forall (id : ident) (ofs : ptrofs) (n : Z),\nArchi.ptr64 = true ->\nGenv.symbol_address ge id (Ptrofs.add ofs (Ptrofs.repr n)) =\nVal.addl (Genv.symbol_address ge id ofs) (Vlong (Int64.repr n))) (SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl (Vlong n1) y) v.","proofString":"rewrite Val.addl_commut.\napply eval_addlimm; auto."},{"statement":"(A : forall x y0 : Z,\nInt64.repr (x + y0) = Int64.add (Int64.repr x) (Int64.repr y0)) (B : forall (id : ident) (ofs : ptrofs) (n : Z),\nArchi.ptr64 = true ->\nGenv.symbol_address ge id (Ptrofs.add ofs (Ptrofs.repr n)) =\nVal.addl (Genv.symbol_address ge id ofs) (Vlong (Int64.repr n))) (SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl y (Vlong n1)) v.","proofString":"apply eval_addlimm; auto."},{"statement":"(A : forall x0 y : Z,\nInt64.repr (x0 + y) = Int64.add (Int64.repr x0) (Int64.repr y)) (B : forall (id : ident) (ofs : ptrofs) (n : Z),\nArchi.ptr64 = true ->\nGenv.symbol_address ge id (Ptrofs.add ofs (Ptrofs.repr n)) =\nVal.addl (Genv.symbol_address ge id ofs) (Vlong (Int64.repr n))) (SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (addlimm n2 t1) v /\\\n  Val.lessdef (Val.addl x (Vlong n2)) v.","proofString":"apply eval_addlimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.subl x (Vlong n2)) v.","proofString":"rewrite Val.subl_addl_opp.\napply eval_addlimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.addl x (Vlong (Int64.neg n2))) v.","proofString":"apply eval_addlimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 v0) (Vlong (Int64.sub n1 n2))) v.","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl (Val.addl v1 (Vlong n1)) y) v.","proofString":"rewrite Val.subl_addl_l.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 y) (Vlong n1)) v.","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (t2 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.neg n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl x v1) (Vlong (Int64.neg n2))) v.","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i : int) (B : Int64.one_bits' n = i :: nil) (D : n = Int64.int_of_one_bits' (i :: nil)) : exists v : val,\n  eval_expr ge sp e m le (shllimm a i) v /\\\n  Val.lessdef (Val.shll x (Vint i)) v.","proofString":"apply eval_shllimm; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i : int) (B : Int64.one_bits' n = i :: nil) (D : n = Int64.int_of_one_bits' (i :: nil)) : Val.shll x (Vint i) = Val.mull x (Vlong n).","proofString":"simpl in D.\nrewrite D, Int64.add_zero.\ndestruct x; simpl; auto.\nrewrite (Int64.one_bits'_range n) by (rewrite B; auto with coqlib).\nrewrite Int64.shl'_mul; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i : int) (B : Int64.one_bits' n = i :: nil) (D : n = Int64.add (Int64.shl' Int64.one i) Int64.zero) : Val.shll x (Vint i) = Val.mull x (Vlong n).","proofString":"rewrite D, Int64.add_zero.\ndestruct x; simpl; auto.\nrewrite (Int64.one_bits'_range n) by (rewrite B; auto with coqlib).\nrewrite Int64.shl'_mul; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i : int) (B : Int64.one_bits' n = i :: nil) (D : n = Int64.add (Int64.shl' Int64.one i) Int64.zero) : Val.shll x (Vint i) = Val.mull x (Vlong (Int64.shl' Int64.one i)).","proofString":"destruct x; simpl; auto.\nrewrite (Int64.one_bits'_range n) by (rewrite B; auto with coqlib).\nrewrite Int64.shl'_mul; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i : int) (B : Int64.one_bits' n = i :: nil) (D : n = Int64.add (Int64.shl' Int64.one i) Int64.zero) : (if Int.ltu i Int64.iwordsize' then Vlong (Int64.shl' i0 i) else Vundef) =\nVlong (Int64.mul i0 (Int64.shl' Int64.one i)).","proofString":"rewrite (Int64.one_bits'_range n) by (rewrite B; auto with coqlib).\nrewrite Int64.shl'_mul; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i : int) (B : Int64.one_bits' n = i :: nil) (D : n = Int64.add (Int64.shl' Int64.one i) Int64.zero) : Vlong (Int64.shl' i0 i) = Vlong (Int64.mul i0 (Int64.shl' Int64.one i)).","proofString":"rewrite Int64.shl'_mul; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i j : int) (B : Int64.one_bits' n = i :: j :: nil) (D : n = Int64.int_of_one_bits' (i :: j :: nil)) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) x) (v1 : val) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v3) (B3 : Val.lessdef (Val.addl v1 v2) v3) : Val.lessdef (Val.mull x (Vlong n)) v3.","proofString":"rewrite D.\nsimpl.\nrewrite Int64.add_zero.\ndestruct x; auto.\nsimpl in *.\nrewrite (Int64.one_bits'_range n) in B1 by (rewrite B; auto with coqlib).\nrewrite (Int64.one_bits'_range n) in B2 by (rewrite B; auto with coqlib).\ninv B1; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i j : int) (B : Int64.one_bits' n = i :: j :: nil) (D : n = Int64.int_of_one_bits' (i :: j :: nil)) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) x) (v1 : val) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v3) (B3 : Val.lessdef (Val.addl v1 v2) v3) : Val.lessdef (Val.mull x (Vlong (Int64.int_of_one_bits' (i :: j :: nil)))) v3.","proofString":"simpl.\nrewrite Int64.add_zero.\ndestruct x; auto.\nsimpl in *.\nrewrite (Int64.one_bits'_range n) in B1 by (rewrite B; auto with coqlib).\nrewrite (Int64.one_bits'_range n) in B2 by (rewrite B; auto with coqlib).\ninv B1; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i j : int) (B : Int64.one_bits' n = i :: j :: nil) (D : n = Int64.int_of_one_bits' (i :: j :: nil)) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) x) (v1 : val) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v3) (B3 : Val.lessdef (Val.addl v1 v2) v3) : Val.lessdef\n  (Val.mull x\n     (Vlong\n        (Int64.add (Int64.shl' Int64.one i)\n           (Int64.add (Int64.shl' Int64.one j) Int64.zero)))) v3.","proofString":"rewrite Int64.add_zero.\ndestruct x; auto.\nsimpl in *.\nrewrite (Int64.one_bits'_range n) in B1 by (rewrite B; auto with coqlib).\nrewrite (Int64.one_bits'_range n) in B2 by (rewrite B; auto with coqlib).\ninv B1; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i j : int) (B : Int64.one_bits' n = i :: j :: nil) (D : n = Int64.int_of_one_bits' (i :: j :: nil)) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) x) (v1 : val) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v3) (B3 : Val.lessdef (Val.addl v1 v2) v3) : Val.lessdef\n  (Val.mull x\n     (Vlong (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j))))\n  v3.","proofString":"destruct x; auto.\nsimpl in *.\nrewrite (Int64.one_bits'_range n) in B1 by (rewrite B; auto with coqlib).\nrewrite (Int64.one_bits'_range n) in B2 by (rewrite B; auto with coqlib).\ninv B1; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i j : int) (B : Int64.one_bits' n = i :: j :: nil) (D : n = Int64.int_of_one_bits' (i :: j :: nil)) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) (Vlong i0)) (v1 : val) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll (Vlong i0) (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll (Vlong i0) (Vint j)) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v3) (B3 : Val.lessdef (Val.addl v1 v2) v3) : Val.lessdef\n  (Val.mull (Vlong i0)\n     (Vlong (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j))))\n  v3.","proofString":"simpl in *.\nrewrite (Int64.one_bits'_range n) in B1 by (rewrite B; auto with coqlib).\nrewrite (Int64.one_bits'_range n) in B2 by (rewrite B; auto with coqlib).\ninv B1; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i j : int) (B : Int64.one_bits' n = i :: j :: nil) (D : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) (Vlong i0)) (v1 : val) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef\n  (if Int.ltu i Int64.iwordsize' then Vlong (Int64.shl' i0 i) else Vundef) v1) (v2 : val) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef\n  (if Int.ltu j Int64.iwordsize' then Vlong (Int64.shl' i0 j) else Vundef) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v3) (B3 : Val.lessdef (Val.addl v1 v2) v3) : Val.lessdef\n  (Vlong\n     (Int64.mul i0\n        (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j)))) v3.","proofString":"rewrite (Int64.one_bits'_range n) in B1 by (rewrite B; auto with coqlib).\nrewrite (Int64.one_bits'_range n) in B2 by (rewrite B; auto with coqlib).\ninv B1; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i j : int) (B : Int64.one_bits' n = i :: j :: nil) (D : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) (Vlong i0)) (v1 : val) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Vlong (Int64.shl' i0 i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef\n  (if Int.ltu j Int64.iwordsize' then Vlong (Int64.shl' i0 j) else Vundef) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v3) (B3 : Val.lessdef (Val.addl v1 v2) v3) : Val.lessdef\n  (Vlong\n     (Int64.mul i0\n        (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j)))) v3.","proofString":"rewrite (Int64.one_bits'_range n) in B2 by (rewrite B; auto with coqlib).\ninv B1; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i j : int) (B : Int64.one_bits' n = i :: j :: nil) (D : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) (Vlong i0)) (v1 : val) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Vlong (Int64.shl' i0 i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Vlong (Int64.shl' i0 j)) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v3) (B3 : Val.lessdef (Val.addl v1 v2) v3) : Val.lessdef\n  (Vlong\n     (Int64.mul i0\n        (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j)))) v3.","proofString":"inv B1; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i j : int) (B : Int64.one_bits'\n  (Int64.add (Int64.shl' Int64.one i)\n     (Int64.add (Int64.shl' Int64.one j) Int64.zero)) = \ni :: j :: nil) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) (Vlong i0)) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) (Vlong (Int64.shl' i0 i))) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) (Vlong (Int64.shl' i0 j))) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v3) (B3 : Val.lessdef (Val.addl (Vlong (Int64.shl' i0 i)) (Vlong (Int64.shl' i0 j))) v3) : Val.lessdef\n  (Vlong\n     (Int64.mul i0\n        (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j)))) v3.","proofString":"simpl in B3; inv B3.\nrewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i j : int) (B : Int64.one_bits'\n  (Int64.add (Int64.shl' Int64.one i)\n     (Int64.add (Int64.shl' Int64.one j) Int64.zero)) = \ni :: j :: nil) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) (Vlong i0)) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) (Vlong (Int64.shl' i0 i))) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) (Vlong (Int64.shl' i0 j))) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))\n  (Vlong (Int64.add (Int64.shl' i0 i) (Int64.shl' i0 j)))) : Val.lessdef\n  (Vlong\n     (Int64.mul i0\n        (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j))))\n  (Vlong (Int64.add (Int64.shl' i0 i) (Int64.shl' i0 j))).","proofString":"rewrite Int64.mul_add_distr_r.\nrewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i j : int) (B : Int64.one_bits'\n  (Int64.add (Int64.shl' Int64.one i)\n     (Int64.add (Int64.shl' Int64.one j) Int64.zero)) = \ni :: j :: nil) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) (Vlong i0)) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) (Vlong (Int64.shl' i0 i))) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) (Vlong (Int64.shl' i0 j))) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))\n  (Vlong (Int64.add (Int64.shl' i0 i) (Int64.shl' i0 j)))) : Val.lessdef\n  (Vlong\n     (Int64.add (Int64.mul i0 (Int64.shl' Int64.one i))\n        (Int64.mul i0 (Int64.shl' Int64.one j))))\n  (Vlong (Int64.add (Int64.shl' i0 i) (Int64.shl' i0 j))).","proofString":"rewrite <- ! Int64.shl'_mul.\nauto."},{"statement":"(le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (i j : int) (B : Int64.one_bits'\n  (Int64.add (Int64.shl' Int64.one i)\n     (Int64.add (Int64.shl' Int64.one j) Int64.zero)) = \ni :: j :: nil) (le' : list val) (A0 : eval_expr ge sp e m le' (Eletvar 0) (Vlong i0)) (A1 : eval_expr ge sp e m le' (shllimm (Eletvar 0) i) (Vlong (Int64.shl' i0 i))) (A2 : eval_expr ge sp e m le' (shllimm (Eletvar 0) j) (Vlong (Int64.shl' i0 j))) (A3 : eval_expr ge sp e m le'\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))\n  (Vlong (Int64.add (Int64.shl' i0 i) (Int64.shl' i0 j)))) : Val.lessdef (Vlong (Int64.add (Int64.shl' i0 i) (Int64.shl' i0 j)))\n  (Vlong (Int64.add (Int64.shl' i0 i) (Int64.shl' i0 j))).","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"exists (Vlong Int64.zero); split.\napply eval_longconst.\ndestruct x; simpl; auto.\nsubst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n = Int64.zero) : eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) (Vlong Int64.zero).","proofString":"apply eval_longconst."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n = Int64.zero) : Val.lessdef (Val.mull x (Vlong n)) (Vlong Int64.zero).","proofString":"destruct x; simpl; auto.\nsubst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = true) (H0 : n = Int64.zero) : Val.lessdef (Vlong (Int64.mul i n)) (Vlong Int64.zero).","proofString":"subst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nsubst n; rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : Val.lessdef (Val.mull x (Vlong n)) x.","proofString":"destruct x; simpl; auto.\nsubst n; rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : Val.lessdef (Vlong (Int64.mul i n)) (Vlong i).","proofString":"subst n; rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.mul n n2)) Enil) v /\\\n  Val.lessdef (Val.mull (Vlong n2) (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nrewrite Int64.mul_commut; auto."},{"statement":"(SL : Archi.splitlong = true) : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match mull_match e1 e2 with\n   | mull_case1 n1 t2 => mullimm n1 t2\n   | mull_case2 t1 n2 => mullimm n2 t1\n   | mull_default e0 e3 => Eop Omull (e0 ::: e3 ::: Enil)\n   end) Val.mull.","proofString":"red; intros; destruct (mull_match a b); InvEval.\nrewrite Val.mull_commut.\napply eval_mullimm; auto.\napply eval_mullimm; auto.\nTrivialExists."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\\n  Val.lessdef (Val.mull (Vlong n1) y) v.","proofString":"rewrite Val.mull_commut.\napply eval_mullimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\\n  Val.lessdef (Val.mull y (Vlong n1)) v.","proofString":"apply eval_mullimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (mullimm n2 t1) v /\\\n  Val.lessdef (Val.mull x (Vlong n2)) v.","proofString":"apply eval_mullimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (e1 : expr) (H : eval_expr ge sp e m le e1 x) (e2 : expr) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.mull x y) v.","proofString":"TrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) : unary_constructor_sound\n  (fun a : expr => Eop Omullhu (a ::: longconst n ::: Enil))\n  (fun v : val => Val.mullhu v (Vlong n)).","proofString":"red; intros.\nTrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Omullhu (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhu x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) : unary_constructor_sound\n  (fun a : expr => Eop Omullhs (a ::: longconst n ::: Enil))\n  (fun v : val => Val.mullhs v (Vlong n)).","proofString":"red; intros.\nTrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Omullhs (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhs x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero then a else Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\ndestruct x; simpl in H0; inv H0.\neconstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (SL : Archi.splitlong = false) (H1 : n = Int.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"subst n.\ndestruct x; simpl in H0; inv H0.\neconstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint Int.zero) = Some z) (SL : Archi.splitlong = false) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"destruct x; simpl in H0; inv H0.\neconstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = false) : exists v : val,\n  eval_expr ge sp e m le a v /\\\n  Val.lessdef\n    match\n      (if Int.ltu Int.zero (Int.repr 63)\n       then Some (Vlong (Int64.shrx' i Int.zero))\n       else None)\n    with\n    | Some v0 => v0\n    | None => Vlong (Int64.shrx' i Int.zero)\n    end v.","proofString":"econstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = false) : Val.lessdef\n  match\n    (if Int.ltu Int.zero (Int.repr 63)\n     then Some (Vlong (Int64.shrx' i Int.zero))\n     else None)\n  with\n  | Some v => v\n  | None => Vlong (Int64.shrx' i Int.zero)\n  end (Vlong i).","proofString":"change (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = false) : Val.lessdef\n  match (if true then Some (Vlong (Int64.shrx' i Int.zero)) else None) with\n  | Some v => v\n  | None => Vlong (Int64.shrx' i Int.zero)\n  end (Vlong i).","proofString":"simpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = false) : Val.lessdef (Vlong (Int64.shrx' i Int.zero)) (Vlong i).","proofString":"rewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (SL : Archi.splitlong = false) (H1 : n <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivl (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivlu (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longoffloat x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Olongoffloat (a ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatoflong (a ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longofsingle x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Olongofsingle (a ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Osingleoflong (a ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."}]}