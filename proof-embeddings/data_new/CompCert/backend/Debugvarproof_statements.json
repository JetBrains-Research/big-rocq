{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Debugvarproof.v","fileSamples":[{"statement":"(p tp : program) (H : transf_program p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p tp : program) (H : transf_program p = OK tp)","proofString":"eapply match_transform_partial_program; eauto."},{"statement":"(v : ident) (i : debuginfo) (s : list (ident * debuginfo)) (IHs : diff s s = nil) : match (v ?= v)%positive with\n| Eq => if eq_debuginfo i i then diff s s else (v, i) :: diff s s\n| Lt => (v, i) :: diff s ((v, i) :: s)\n| Gt =>\n    (fix diff2 (s2 : avail) : avail :=\n       match s2 with\n       | nil => (v, i) :: s\n       | (v2, i2) :: s2' =>\n           match (v ?= v2)%positive with\n           | Eq =>\n               if eq_debuginfo i i2 then diff s s2' else (v, i) :: diff s s2'\n           | Lt => (v, i) :: diff s s2\n           | Gt => diff2 s2'\n           end\n       end) s\nend = nil.","conclusion":"match (v ?= v)%positive with\n| Eq => if eq_debuginfo i i then diff s s else (v, i) :: diff s s\n| Lt => (v, i) :: diff s ((v, i) :: s)\n| Gt =>\n    (fix diff2 (s2 : avail) : avail :=\n       match s2 with\n       | nil => (v, i) :: s\n       | (v2, i2) :: s2' =>\n           match (v ?= v2)%positive with\n           | Eq =>\n               if eq_debuginfo i i2 then diff s s2' else (v, i) :: diff s s2'\n           | Lt => (v, i) :: diff s s2\n           | Gt => diff2 s2'\n           end\n       end) s\nend = nil","hypotheses":"(v : ident) (i : debuginfo) (s : list (ident * debuginfo)) (IHs : diff s s = nil)","proofString":"rewrite Pos.compare_refl.\nrewrite dec_eq_true.\nauto."},{"statement":"(v : ident) (i : debuginfo) (s : list (ident * debuginfo)) (IHs : diff s s = nil) : (if eq_debuginfo i i then diff s s else (v, i) :: diff s s) = nil.","conclusion":"(if eq_debuginfo i i then diff s s else (v, i) :: diff s s) = nil","hypotheses":"(v : ident) (i : debuginfo) (s : list (ident * debuginfo)) (IHs : diff s s = nil)","proofString":"rewrite dec_eq_true.\nauto."},{"statement":"(v : ident) (i : debuginfo) (s : list (ident * debuginfo)) (IHs : diff s s = nil) : diff s s = nil.","conclusion":"diff s s = nil","hypotheses":"(v : ident) (i : debuginfo) (s : list (ident * debuginfo)) (IHs : diff s s = nil)","proofString":"auto."},{"statement":"(a : avail) : (diff a a, diff a a) = (nil, nil).","conclusion":"(diff a a, diff a a) = (nil, nil)","hypotheses":"(a : avail)","proofString":"rewrite ! diff_same; auto."},{"statement":"(lm : labelmap) : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c).","conclusion":"forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)","hypotheses":"(lm : labelmap)","proofString":"fix REC 1.\ndestruct c; intros before; simpl.\nconstructor.\nassert (DEFAULT: forall before after,            match_code (i :: c)                       (i :: add_delta_ranges before after (transf_code lm after c))).\nintros.\nconstructor.\napply REC.\ndestruct i; auto.\ndestruct c; auto.\ndestruct i; auto.\nset (after := get_label l0 lm).\nset (c1 := Llabel l0 :: add_delta_ranges before after (transf_code lm after c)).\nreplace c1 with (add_delta_ranges before before c1).\nconstructor.\nconstructor.\napply REC.\nunfold add_delta_ranges.\nrewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)) : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c).","conclusion":"forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c)","hypotheses":"(lm : labelmap) (REC : forall (c : code) (before : option avail),\nmatch_code c (transf_code lm before c))","proofString":"destruct c; intros before; simpl.\nconstructor.\nassert (DEFAULT: forall before after,            match_code (i :: c)                       (i :: add_delta_ranges before after (transf_code lm after c))).\nintros.\nconstructor.\napply REC.\ndestruct i; auto.\ndestruct c; auto.\ndestruct i; auto.\nset (after := get_label l0 lm).\nset (c1 := Llabel l0 :: add_delta_ranges before after (transf_code lm after c)).\nreplace c1 with (add_delta_ranges before before c1).\nconstructor.\nconstructor.\napply REC.\nunfold add_delta_ranges.\nrewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c : code) (before0 : option avail),\nmatch_code c (transf_code lm before0 c)) (before : option avail) : match_code nil nil.","conclusion":"match_code nil nil","hypotheses":"(lm : labelmap) (REC : forall (c : code) (before0 : option avail),\nmatch_code c (transf_code lm before0 c)) (before : option avail)","proofString":"constructor."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (i : instruction) (c : list instruction) (before : option avail) : match_code (i :: c)\n  match i with\n  | Lgoto lbl1 =>\n      match c with\n      | Llabel lbl2 :: c' =>\n          Lgoto lbl1\n          :: Llabel lbl2\n             :: add_delta_ranges before (get_label lbl2 lm)\n                  (transf_code lm (get_label lbl2 lm) c')\n      | _ =>\n          i\n          :: add_delta_ranges before\n               (skip_debug_setvar lm (snd (transfer lm before i)) c)\n               (transf_code lm\n                  (skip_debug_setvar lm (snd (transfer lm before i)) c) c)\n      end\n  | _ =>\n      i\n      :: add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before i)) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before i)) c) c)\n  end.","conclusion":"match_code (i :: c)\n  match i with\n  | Lgoto lbl1 =>\n      match c with\n      | Llabel lbl2 :: c' =>\n          Lgoto lbl1\n          :: Llabel lbl2\n             :: add_delta_ranges before (get_label lbl2 lm)\n                  (transf_code lm (get_label lbl2 lm) c')\n      | _ =>\n          i\n          :: add_delta_ranges before\n               (skip_debug_setvar lm (snd (transfer lm before i)) c)\n               (transf_code lm\n                  (skip_debug_setvar lm (snd (transfer lm before i)) c) c)\n      end\n  | _ =>\n      i\n      :: add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before i)) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before i)) c) c)\n  end","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (i : instruction) (c : list instruction) (before : option avail)","proofString":"assert (DEFAULT: forall before after,            match_code (i :: c)                       (i :: add_delta_ranges before after (transf_code lm after c))).\nintros.\nconstructor.\napply REC.\ndestruct i; auto.\ndestruct c; auto.\ndestruct i; auto.\nset (after := get_label l0 lm).\nset (c1 := Llabel l0 :: add_delta_ranges before after (transf_code lm after c)).\nreplace c1 with (add_delta_ranges before before c1).\nconstructor.\nconstructor.\napply REC.\nunfold add_delta_ranges.\nrewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (i : instruction) (c : list instruction) (before : option avail) : forall before0 after : option avail,\nmatch_code (i :: c)\n  (i :: add_delta_ranges before0 after (transf_code lm after c)).","conclusion":"forall before0 after : option avail,\nmatch_code (i :: c)\n  (i :: add_delta_ranges before0 after (transf_code lm after c))","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (i : instruction) (c : list instruction) (before : option avail)","proofString":"intros.\nconstructor.\napply REC."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before1 : option avail),\nmatch_code c0 (transf_code lm before1 c0)) (i : instruction) (c : list instruction) (before before0 after : option avail) : match_code (i :: c)\n  (i :: add_delta_ranges before0 after (transf_code lm after c)).","conclusion":"match_code (i :: c)\n  (i :: add_delta_ranges before0 after (transf_code lm after c))","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before1 : option avail),\nmatch_code c0 (transf_code lm before1 c0)) (i : instruction) (c : list instruction) (before before0 after : option avail)","proofString":"constructor.\napply REC."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before1 : option avail),\nmatch_code c0 (transf_code lm before1 c0)) (i : instruction) (c : list instruction) (before before0 after : option avail) : match_code c (transf_code lm after c).","conclusion":"match_code c (transf_code lm after c)","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before1 : option avail),\nmatch_code c0 (transf_code lm before1 c0)) (i : instruction) (c : list instruction) (before before0 after : option avail)","proofString":"apply REC."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (i : instruction) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after : option avail,\nmatch_code (i :: c)\n  (i :: add_delta_ranges before0 after (transf_code lm after c))) : match_code (i :: c)\n  match i with\n  | Lgoto lbl1 =>\n      match c with\n      | Llabel lbl2 :: c' =>\n          Lgoto lbl1\n          :: Llabel lbl2\n             :: add_delta_ranges before (get_label lbl2 lm)\n                  (transf_code lm (get_label lbl2 lm) c')\n      | _ =>\n          i\n          :: add_delta_ranges before\n               (skip_debug_setvar lm (snd (transfer lm before i)) c)\n               (transf_code lm\n                  (skip_debug_setvar lm (snd (transfer lm before i)) c) c)\n      end\n  | _ =>\n      i\n      :: add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before i)) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before i)) c) c)\n  end.","conclusion":"match_code (i :: c)\n  match i with\n  | Lgoto lbl1 =>\n      match c with\n      | Llabel lbl2 :: c' =>\n          Lgoto lbl1\n          :: Llabel lbl2\n             :: add_delta_ranges before (get_label lbl2 lm)\n                  (transf_code lm (get_label lbl2 lm) c')\n      | _ =>\n          i\n          :: add_delta_ranges before\n               (skip_debug_setvar lm (snd (transfer lm before i)) c)\n               (transf_code lm\n                  (skip_debug_setvar lm (snd (transfer lm before i)) c) c)\n      end\n  | _ =>\n      i\n      :: add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before i)) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before i)) c) c)\n  end","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (i : instruction) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after : option avail,\nmatch_code (i :: c)\n  (i :: add_delta_ranges before0 after (transf_code lm after c)))","proofString":"destruct i; auto.\ndestruct c; auto.\ndestruct i; auto.\nset (after := get_label l0 lm).\nset (c1 := Llabel l0 :: add_delta_ranges before after (transf_code lm after c)).\nreplace c1 with (add_delta_ranges before before c1).\nconstructor.\nconstructor.\napply REC.\nunfold add_delta_ranges.\nrewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after : option avail,\nmatch_code (Lgoto l :: c)\n  (Lgoto l :: add_delta_ranges before0 after (transf_code lm after c))) : match_code (Lgoto l :: c)\n  match c with\n  | Llabel lbl2 :: c' =>\n      Lgoto l\n      :: Llabel lbl2\n         :: add_delta_ranges before (get_label lbl2 lm)\n              (transf_code lm (get_label lbl2 lm) c')\n  | _ =>\n      Lgoto l\n      :: add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l))) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before (Lgoto l))) c) c)\n  end.","conclusion":"match_code (Lgoto l :: c)\n  match c with\n  | Llabel lbl2 :: c' =>\n      Lgoto l\n      :: Llabel lbl2\n         :: add_delta_ranges before (get_label lbl2 lm)\n              (transf_code lm (get_label lbl2 lm) c')\n  | _ =>\n      Lgoto l\n      :: add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l))) c)\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before (Lgoto l))) c) c)\n  end","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after : option avail,\nmatch_code (Lgoto l :: c)\n  (Lgoto l :: add_delta_ranges before0 after (transf_code lm after c)))","proofString":"destruct c; auto.\ndestruct i; auto.\nset (after := get_label l0 lm).\nset (c1 := Llabel l0 :: add_delta_ranges before after (transf_code lm after c)).\nreplace c1 with (add_delta_ranges before before c1).\nconstructor.\nconstructor.\napply REC.\nunfold add_delta_ranges.\nrewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l : label) (i : instruction) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after : option avail,\nmatch_code (Lgoto l :: i :: c)\n  (Lgoto l :: add_delta_ranges before0 after (transf_code lm after (i :: c)))) : match_code (Lgoto l :: i :: c)\n  match i with\n  | Llabel lbl2 =>\n      Lgoto l\n      :: Llabel lbl2\n         :: add_delta_ranges before (get_label lbl2 lm)\n              (transf_code lm (get_label lbl2 lm) c)\n  | _ =>\n      Lgoto l\n      :: add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (i :: c))\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n                 (i :: c)) (i :: c))\n  end.","conclusion":"match_code (Lgoto l :: i :: c)\n  match i with\n  | Llabel lbl2 =>\n      Lgoto l\n      :: Llabel lbl2\n         :: add_delta_ranges before (get_label lbl2 lm)\n              (transf_code lm (get_label lbl2 lm) c)\n  | _ =>\n      Lgoto l\n      :: add_delta_ranges before\n           (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n              (i :: c))\n           (transf_code lm\n              (skip_debug_setvar lm (snd (transfer lm before (Lgoto l)))\n                 (i :: c)) (i :: c))\n  end","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l : label) (i : instruction) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after : option avail,\nmatch_code (Lgoto l :: i :: c)\n  (Lgoto l :: add_delta_ranges before0 after (transf_code lm after (i :: c))))","proofString":"destruct i; auto.\nset (after := get_label l0 lm).\nset (c1 := Llabel l0 :: add_delta_ranges before after (transf_code lm after c)).\nreplace c1 with (add_delta_ranges before before c1).\nconstructor.\nconstructor.\napply REC.\nunfold add_delta_ranges.\nrewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after (transf_code lm after (Llabel l0 :: c)))) : match_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: Llabel l0\n      :: add_delta_ranges before (get_label l0 lm)\n           (transf_code lm (get_label l0 lm) c)).","conclusion":"match_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: Llabel l0\n      :: add_delta_ranges before (get_label l0 lm)\n           (transf_code lm (get_label l0 lm) c))","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after (transf_code lm after (Llabel l0 :: c))))","proofString":"set (after := get_label l0 lm).\nset (c1 := Llabel l0 :: add_delta_ranges before after (transf_code lm after c)).\nreplace c1 with (add_delta_ranges before before c1).\nconstructor.\nconstructor.\napply REC.\nunfold add_delta_ranges.\nrewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail) : match_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: Llabel l0 :: add_delta_ranges before after (transf_code lm after c)).","conclusion":"match_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: Llabel l0 :: add_delta_ranges before after (transf_code lm after c))","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail)","proofString":"set (c1 := Llabel l0 :: add_delta_ranges before after (transf_code lm after c)).\nreplace c1 with (add_delta_ranges before before c1).\nconstructor.\nconstructor.\napply REC.\nunfold add_delta_ranges.\nrewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail) (c1 : list instruction) : match_code c (transf_code lm after c).","conclusion":"match_code c (transf_code lm after c)","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail) (c1 : list instruction)","proofString":"apply REC."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail) (c1 : list instruction) : add_delta_ranges before before c1 = c1.","conclusion":"add_delta_ranges before before c1 = c1","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail) (c1 : list instruction)","proofString":"unfold add_delta_ranges.\nrewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail) (c1 : list instruction) : (let (killed, born) := delta_state before before in\n fold_right add_end_range (fold_right add_start_range c1 born) killed) = c1.","conclusion":"(let (killed, born) := delta_state before before in\n fold_right add_end_range (fold_right add_start_range c1 born) killed) = c1","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail) (c1 : list instruction)","proofString":"rewrite delta_state_same.\nauto."},{"statement":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail) (c1 : list instruction) : fold_right add_end_range (fold_right add_start_range c1 nil) nil = c1.","conclusion":"fold_right add_end_range (fold_right add_start_range c1 nil) nil = c1","hypotheses":"(lm : labelmap) (REC : forall (c0 : code) (before0 : option avail),\nmatch_code c0 (transf_code lm before0 c0)) (l l0 : label) (c : list instruction) (before : option avail) (DEFAULT : forall before0 after0 : option avail,\nmatch_code (Lgoto l :: Llabel l0 :: c)\n  (Lgoto l\n   :: add_delta_ranges before0 after0\n        (transf_code lm after0 (Llabel l0 :: c)))) (after : option avail) (c1 : list instruction)","proofString":"auto."},{"statement":"(f tf : function) (H : match ana_function f with\n| Some lm =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_stacksize := fn_stacksize f;\n        fn_code := transf_code lm (Some top) (fn_code f)\n      |}\n| None => Error (msg \"Debugvar: analysis diverges\")\nend = OK tf) : match_function f tf.","conclusion":"match_function f tf","hypotheses":"(f tf : function) (H : match ana_function f with\n| Some lm =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_stacksize := fn_stacksize f;\n        fn_code := transf_code lm (Some top) (fn_code f)\n      |}\n| None => Error (msg \"Debugvar: analysis diverges\")\nend = OK tf)","proofString":"destruct (ana_function f) as [lm|]; inv H.\nconstructor.\napply transf_code_match."},{"statement":"(f : function) (lm : labelmap) : match_function f\n  {|\n    fn_sig := fn_sig f;\n    fn_stacksize := fn_stacksize f;\n    fn_code := transf_code lm (Some top) (fn_code f)\n  |}.","conclusion":"match_function f\n  {|\n    fn_sig := fn_sig f;\n    fn_stacksize := fn_stacksize f;\n    fn_code := transf_code lm (Some top) (fn_code f)\n  |}","hypotheses":"(f : function) (lm : labelmap)","proofString":"constructor.\napply transf_code_match."},{"statement":"(f : function) (lm : labelmap) : match_code (fn_code f) (transf_code lm (Some top) (fn_code f)).","conclusion":"match_code (fn_code f) (transf_code lm (Some top) (fn_code f))","hypotheses":"(f : function) (lm : labelmap)","proofString":"apply transf_code_match."},{"statement":"(lbl : label) (c : code) (before after : option avail) : find_label lbl (add_delta_ranges before after c) = find_label lbl c.","conclusion":"find_label lbl (add_delta_ranges before after c) = find_label lbl c","hypotheses":"(lbl : label) (c : code) (before after : option avail)","proofString":"unfold add_delta_ranges.\ndestruct (delta_state before after) as [killed born].\ninduction killed as [ | [v i] l]; simpl; auto.\ninduction born as [ | [v i] l]; simpl; auto."},{"statement":"(lbl : label) (c : code) (before after : option avail) : find_label lbl\n  (let (killed, born) := delta_state before after in\n   fold_right add_end_range (fold_right add_start_range c born) killed) =\nfind_label lbl c.","conclusion":"find_label lbl\n  (let (killed, born) := delta_state before after in\n   fold_right add_end_range (fold_right add_start_range c born) killed) =\nfind_label lbl c","hypotheses":"(lbl : label) (c : code) (before after : option avail)","proofString":"destruct (delta_state before after) as [killed born].\ninduction killed as [ | [v i] l]; simpl; auto.\ninduction born as [ | [v i] l]; simpl; auto."},{"statement":"(lbl : label) (c : code) (before after : option avail) (killed born : avail) : find_label lbl\n  (fold_right add_end_range (fold_right add_start_range c born) killed) =\nfind_label lbl c.","conclusion":"find_label lbl\n  (fold_right add_end_range (fold_right add_start_range c born) killed) =\nfind_label lbl c","hypotheses":"(lbl : label) (c : code) (before after : option avail) (killed born : avail)","proofString":"induction killed as [ | [v i] l]; simpl; auto.\ninduction born as [ | [v i] l]; simpl; auto."},{"statement":"(lbl : label) (c : code) (before after : option avail) (born : avail) : find_label lbl (fold_right add_start_range c born) = find_label lbl c.","conclusion":"find_label lbl (fold_right add_start_range c born) = find_label lbl c","hypotheses":"(lbl : label) (c : code) (before after : option avail) (born : avail)","proofString":"induction born as [ | [v i] l]; simpl; auto."},{"statement":"(lbl : label) (c' : code) (H : None = Some c') : exists (before after : option avail) (tc' : code),\n  None = Some (add_delta_ranges before after tc') /\\ match_code c' tc'.","conclusion":"exists (before after : option avail) (tc' : code),\n  None = Some (add_delta_ranges before after tc') /\\ match_code c' tc'","hypotheses":"(lbl : label) (c' : code) (H : None = Some c')","proofString":"discriminate."},{"statement":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c c'0 : code) (H : match_code c c'0) (IHmatch_code : find_label lbl c = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H0 : (if is_label lbl i then Some c else find_label lbl c) = Some c') : exists (before0 after0 : option avail) (tc' : code),\n  (if is_label lbl i\n   then Some (add_delta_ranges before after c'0)\n   else find_label lbl (add_delta_ranges before after c'0)) =\n  Some (add_delta_ranges before0 after0 tc') /\\ match_code c' tc'.","conclusion":"exists (before0 after0 : option avail) (tc' : code),\n  (if is_label lbl i\n   then Some (add_delta_ranges before after c'0)\n   else find_label lbl (add_delta_ranges before after c'0)) =\n  Some (add_delta_ranges before0 after0 tc') /\\ match_code c' tc'","hypotheses":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c c'0 : code) (H : match_code c c'0) (IHmatch_code : find_label lbl c = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H0 : (if is_label lbl i then Some c else find_label lbl c) = Some c')","proofString":"destruct (is_label lbl i).\ninv H0.\neconstructor; econstructor; econstructor; eauto.\nrewrite find_label_add_delta_ranges.\nauto."},{"statement":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c c'0 : code) (H : match_code c c'0) (IHmatch_code : find_label lbl c = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H0 : Some c = Some c') : exists (before0 after0 : option avail) (tc' : code),\n  Some (add_delta_ranges before after c'0) =\n  Some (add_delta_ranges before0 after0 tc') /\\ match_code c' tc'.","conclusion":"exists (before0 after0 : option avail) (tc' : code),\n  Some (add_delta_ranges before after c'0) =\n  Some (add_delta_ranges before0 after0 tc') /\\ match_code c' tc'","hypotheses":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c c'0 : code) (H : match_code c c'0) (IHmatch_code : find_label lbl c = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H0 : Some c = Some c')","proofString":"inv H0.\neconstructor; econstructor; econstructor; eauto."},{"statement":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c'0 : code) (IHmatch_code : find_label lbl c' = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H : match_code c' c'0) : exists (before0 after0 : option avail) (tc' : code),\n  Some (add_delta_ranges before after c'0) =\n  Some (add_delta_ranges before0 after0 tc') /\\ match_code c' tc'.","conclusion":"exists (before0 after0 : option avail) (tc' : code),\n  Some (add_delta_ranges before after c'0) =\n  Some (add_delta_ranges before0 after0 tc') /\\ match_code c' tc'","hypotheses":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c'0 : code) (IHmatch_code : find_label lbl c' = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H : match_code c' c'0)","proofString":"econstructor; econstructor; econstructor; eauto."},{"statement":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c c'0 : code) (H : match_code c c'0) (IHmatch_code : find_label lbl c = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H0 : find_label lbl c = Some c') : exists (before0 after0 : option avail) (tc' : code),\n  find_label lbl (add_delta_ranges before after c'0) =\n  Some (add_delta_ranges before0 after0 tc') /\\ match_code c' tc'.","conclusion":"exists (before0 after0 : option avail) (tc' : code),\n  find_label lbl (add_delta_ranges before after c'0) =\n  Some (add_delta_ranges before0 after0 tc') /\\ match_code c' tc'","hypotheses":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c c'0 : code) (H : match_code c c'0) (IHmatch_code : find_label lbl c = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H0 : find_label lbl c = Some c')","proofString":"rewrite find_label_add_delta_ranges.\nauto."},{"statement":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c c'0 : code) (H : match_code c c'0) (IHmatch_code : find_label lbl c = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H0 : find_label lbl c = Some c') : exists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc'.","conclusion":"exists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc'","hypotheses":"(lbl : label) (c' : code) (i : instruction) (before after : option avail) (c c'0 : code) (H : match_code c c'0) (IHmatch_code : find_label lbl c = Some c' ->\nexists (before0 after0 : option avail) (tc' : code),\n  find_label lbl c'0 = Some (add_delta_ranges before0 after0 tc') /\\\n  match_code c' tc') (H0 : find_label lbl c = Some c')","proofString":"auto."},{"statement":"(f tf : function) (lbl : label) (c : code) (H : match_function f tf) (H0 : find_label lbl (fn_code f) = Some c) : exists (before after : option avail) (tc : code),\n  find_label lbl (fn_code tf) = Some (add_delta_ranges before after tc) /\\\n  match_code c tc.","conclusion":"exists (before after : option avail) (tc : code),\n  find_label lbl (fn_code tf) = Some (add_delta_ranges before after tc) /\\\n  match_code c tc","hypotheses":"(f tf : function) (lbl : label) (c : code) (H : match_function f tf) (H0 : find_label lbl (fn_code f) = Some c)","proofString":"inv H.\neapply find_label_match_rec; eauto."},{"statement":"(f : function) (lbl : label) (c : code) (H0 : find_label lbl (fn_code f) = Some c) (c0 : code) (H1 : match_code (fn_code f) c0) : exists (before after : option avail) (tc : code),\n  find_label lbl\n    (fn_code\n       {|\n         fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c0\n       |}) = Some (add_delta_ranges before after tc) /\\ \n  match_code c tc.","conclusion":"exists (before after : option avail) (tc : code),\n  find_label lbl\n    (fn_code\n       {|\n         fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c0\n       |}) = Some (add_delta_ranges before after tc) /\\ \n  match_code c tc","hypotheses":"(f : function) (lbl : label) (c : code) (H0 : find_label lbl (fn_code f) = Some c) (c0 : code) (H1 : match_code (fn_code f) c0)","proofString":"eapply find_label_match_rec; eauto."},{"statement":"(v : ident) (i : debuginfo) : (v, i) = (v, i) \\/ False.","conclusion":"(v, i) = (v, i) \\/ False","hypotheses":"(v : ident) (i : debuginfo)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : list (ident * debuginfo)) (IHs : In (v, i) (set_state v i s)) : In (v, i)\n  match (v ?= v')%positive with\n  | Eq => (v, i) :: s\n  | Lt => (v, i) :: (v', i') :: s\n  | Gt => (v', i') :: set_state v i s\n  end.","conclusion":"In (v, i)\n  match (v ?= v')%positive with\n  | Eq => (v, i) :: s\n  | Lt => (v, i) :: (v', i') :: s\n  | Gt => (v', i') :: set_state v i s\n  end","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : list (ident * debuginfo)) (IHs : In (v, i) (set_state v i s))","proofString":"destruct (Pos.compare v v'); simpl; auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (H : v' <> v) (H0 : False) : (v, i) = (v', i') \\/ False.","conclusion":"(v, i) = (v', i') \\/ False","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (H : v' <> v) (H0 : False)","proofString":"contradiction."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) : In (v', i')\n  match (v ?= v1)%positive with\n  | Eq => (v, i) :: s\n  | Lt => (v, i) :: (v1, i1) :: s\n  | Gt => (v1, i1) :: set_state v i s\n  end.","conclusion":"In (v', i')\n  match (v ?= v1)%positive with\n  | Eq => (v, i) :: s\n  | Lt => (v, i) :: (v1, i1) :: s\n  | Gt => (v1, i1) :: set_state v i s\n  end","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s)","proofString":"destruct (Pos.compare_spec v v1); simpl.\nsubst v1.\ndestruct H0.\ncongruence.\nauto.\nauto.\ndestruct H0; auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : v = v1) : (v, i) = (v', i') \\/ In (v', i') s.","conclusion":"(v, i) = (v', i') \\/ In (v', i') s","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : v = v1)","proofString":"subst v1.\ndestruct H0.\ncongruence.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v, i1) = (v', i') \\/ In (v', i') s) : (v, i) = (v', i') \\/ In (v', i') s.","conclusion":"(v, i) = (v', i') \\/ In (v', i') s","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v, i1) = (v', i') \\/ In (v', i') s)","proofString":"destruct H0.\ncongruence.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v, i1) = (v', i')) : (v, i) = (v', i') \\/ In (v', i') s.","conclusion":"(v, i) = (v', i') \\/ In (v', i') s","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v, i1) = (v', i'))","proofString":"congruence."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : In (v', i') s) : (v, i) = (v', i') \\/ In (v', i') s.","conclusion":"(v, i) = (v', i') \\/ In (v', i') s","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : In (v', i') s)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : (v < v1)%positive) : (v, i) = (v', i') \\/ (v1, i1) = (v', i') \\/ In (v', i') s.","conclusion":"(v, i) = (v', i') \\/ (v1, i1) = (v', i') \\/ In (v', i') s","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : (v < v1)%positive)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : (v1 < v)%positive) : (v1, i1) = (v', i') \\/ In (v', i') (set_state v i s).","conclusion":"(v1, i1) = (v', i') \\/ In (v', i') (set_state v i s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (set_state v i s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : (v1 < v)%positive)","proofString":"destruct H0; auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (H : (v, i) = (v', i') \\/ False) : v' = v /\\ i' = i \\/ v' <> v /\\ False.","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ False","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (H : (v, i) = (v', i') \\/ False)","proofString":"intuition congruence."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i')\n  match (v ?= v0)%positive with\n  | Eq => (v, i) :: s\n  | Lt => (v, i) :: (v0, i0) :: s\n  | Gt => (v0, i0) :: set_state v i s\n  end) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i')\n  match (v ?= v0)%positive with\n  | Eq => (v, i) :: s\n  | Lt => (v, i) :: (v0, i0) :: s\n  | Gt => (v0, i0) :: set_state v i s\n  end)","proofString":"destruct (Pos.compare_spec v v0); simpl in H1.\nsubst v0.\ndestruct H1.\ninv H1; auto.\nright; split.\napply not_eq_sym.\napply Plt_ne.\neapply H; eauto.\nauto.\ndestruct H1.\ninv H1; auto.\ndestruct H1.\ninv H1.\nright; split; auto.\napply not_eq_sym.\napply Plt_ne.\nauto.\nright; split; auto.\napply not_eq_sym.\napply Plt_ne.\napply Plt_trans with v0; eauto.\ndestruct H1.\ninv H1.\nright; split; auto.\napply Plt_ne.\nauto.\ndestruct IHwf_avail as [A | [A B]]; auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i') \\/ In (v', i') s) (H2 : v = v0) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i') \\/ In (v', i') s) (H2 : v = v0)","proofString":"subst v0.\ndestruct H1.\ninv H1; auto.\nright; split.\napply not_eq_sym.\napply Plt_ne.\neapply H; eauto.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i') \\/ In (v', i') s) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i') \\/ In (v', i') s)","proofString":"destruct H1.\ninv H1; auto.\nright; split.\napply not_eq_sym.\napply Plt_ne.\neapply H; eauto.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i')) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i'))","proofString":"inv H1; auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s)","proofString":"right; split.\napply not_eq_sym.\napply Plt_ne.\neapply H; eauto.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) : v' <> v.","conclusion":"v' <> v","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s)","proofString":"apply not_eq_sym.\napply Plt_ne.\neapply H; eauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) : v <> v'.","conclusion":"v <> v'","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s)","proofString":"apply Plt_ne.\neapply H; eauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s)","proofString":"eapply H; eauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) : (v, i0) = (v', i') \\/ In (v', i') s.","conclusion":"(v, i0) = (v', i') \\/ In (v', i') s","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i') \\/ (v0, i0) = (v', i') \\/ In (v', i') s) (H2 : (v < v0)%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i') \\/ (v0, i0) = (v', i') \\/ In (v', i') s) (H2 : (v < v0)%positive)","proofString":"destruct H1.\ninv H1; auto.\ndestruct H1.\ninv H1.\nright; split; auto.\napply not_eq_sym.\napply Plt_ne.\nauto.\nright; split; auto.\napply not_eq_sym.\napply Plt_ne.\napply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i')) (H2 : (v < v0)%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v, i) = (v', i')) (H2 : (v < v0)%positive)","proofString":"inv H1; auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v0, i0) = (v', i') \\/ In (v', i') s) (H2 : (v < v0)%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v0, i0) = (v', i') \\/ In (v', i') s) (H2 : (v < v0)%positive)","proofString":"destruct H1.\ninv H1.\nright; split; auto.\napply not_eq_sym.\napply Plt_ne.\nauto.\nright; split; auto.\napply not_eq_sym.\napply Plt_ne.\napply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v0, i0) = (v', i')) (H2 : (v < v0)%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v0, i0) = (v', i')) (H2 : (v < v0)%positive)","proofString":"inv H1.\nright; split; auto.\napply not_eq_sym.\napply Plt_ne.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v', i') = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v', i') = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive)","proofString":"right; split; auto.\napply not_eq_sym.\napply Plt_ne.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive) : v' <> v.","conclusion":"v' <> v","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive)","proofString":"apply not_eq_sym.\napply Plt_ne.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive) : v <> v'.","conclusion":"v <> v'","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive)","proofString":"apply Plt_ne.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive)","proofString":"right; split; auto.\napply not_eq_sym.\napply Plt_ne.\napply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive) : v' <> v.","conclusion":"v' <> v","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive)","proofString":"apply not_eq_sym.\napply Plt_ne.\napply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive) : v <> v'.","conclusion":"v <> v'","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive)","proofString":"apply Plt_ne.\napply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive)","proofString":"apply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v0, i0) = (v', i') \\/ In (v', i') (set_state v i s)) (H2 : (v0 < v)%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v0, i0) = (v', i') \\/ In (v', i') (set_state v i s)) (H2 : (v0 < v)%positive)","proofString":"destruct H1.\ninv H1.\nright; split; auto.\napply Plt_ne.\nauto.\ndestruct IHwf_avail as [A | [A B]]; auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v0, i0) = (v', i')) (H2 : (v0 < v)%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : (v0, i0) = (v', i')) (H2 : (v0 < v)%positive)","proofString":"inv H1.\nright; split; auto.\napply Plt_ne.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v', i') = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v', i') = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive)","proofString":"right; split; auto.\napply Plt_ne.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive) : v' <> v.","conclusion":"v' <> v","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive)","proofString":"apply Plt_ne.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive) : Plt v' v.","conclusion":"Plt v' v","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') (set_state v i s)) (H2 : (v0 < v)%positive) : v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s).","conclusion":"v' = v /\\ i' = i \\/ v' <> v /\\ ((v0, i0) = (v', i') \\/ In (v', i') s)","hypotheses":"(v : ident) (i : debuginfo) (v' : ident) (i' : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (set_state v i s) -> v' = v /\\ i' = i \\/ v' <> v /\\ In (v', i') s) (H1 : In (v', i') (set_state v i s)) (H2 : (v0 < v)%positive)","proofString":"destruct IHwf_avail as [A | [A B]]; auto."},{"statement":"(v : ident) (i : debuginfo) : wf_avail ((v, i) :: nil).","conclusion":"wf_avail ((v, i) :: nil)","hypotheses":"(v : ident) (i : debuginfo)","proofString":"constructor.\nred; simpl; tauto.\nconstructor."},{"statement":"(v : ident) (i : debuginfo) : avail_above v nil.","conclusion":"avail_above v nil","hypotheses":"(v : ident) (i : debuginfo)","proofString":"red; simpl; tauto."},{"statement":"(v : ident) (i : debuginfo) : wf_avail nil.","conclusion":"wf_avail nil","hypotheses":"(v : ident) (i : debuginfo)","proofString":"constructor."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) : wf_avail\n  match (v ?= v0)%positive with\n  | Eq => (v, i) :: s\n  | Lt => (v, i) :: (v0, i0) :: s\n  | Gt => (v0, i0) :: set_state v i s\n  end.","conclusion":"wf_avail\n  match (v ?= v0)%positive with\n  | Eq => (v, i) :: s\n  | Lt => (v, i) :: (v0, i0) :: s\n  | Gt => (v0, i0) :: set_state v i s\n  end","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s))","proofString":"destruct (Pos.compare_spec v v0).\nsubst v0.\nconstructor; auto.\nconstructor.\nred; simpl; intros.\ndestruct H2.\ninv H2.\nauto.\napply Plt_trans with v0; eauto.\nconstructor; auto.\nconstructor.\nred; intros.\nexploit set_state_3.\neexact H0.\neauto.\nintros [[A B] | [A B]]; subst; eauto.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : v = v0) : wf_avail ((v, i) :: s).","conclusion":"wf_avail ((v, i) :: s)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : v = v0)","proofString":"subst v0.\nconstructor; auto."},{"statement":"(v : ident) (i i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) : wf_avail ((v, i) :: s).","conclusion":"wf_avail ((v, i) :: s)","hypotheses":"(v : ident) (i i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s))","proofString":"constructor; auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive) : wf_avail ((v, i) :: (v0, i0) :: s).","conclusion":"wf_avail ((v, i) :: (v0, i0) :: s)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive)","proofString":"constructor.\nred; simpl; intros.\ndestruct H2.\ninv H2.\nauto.\napply Plt_trans with v0; eauto.\nconstructor; auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive) : avail_above v ((v0, i0) :: s).","conclusion":"avail_above v ((v0, i0) :: s)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive)","proofString":"red; simpl; intros.\ndestruct H2.\ninv H2.\nauto.\napply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive) (v' : ident) (i' : debuginfo) (H2 : (v0, i0) = (v', i') \\/ In (v', i') s) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive) (v' : ident) (i' : debuginfo) (H2 : (v0, i0) = (v', i') \\/ In (v', i') s)","proofString":"destruct H2.\ninv H2.\nauto.\napply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive) (v' : ident) (i' : debuginfo) (H2 : (v0, i0) = (v', i')) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive) (v' : ident) (i' : debuginfo) (H2 : (v0, i0) = (v', i'))","proofString":"inv H2.\nauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (v' : ident) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v')%positive) (i' : debuginfo) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (v' : ident) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v')%positive) (i' : debuginfo)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive) (v' : ident) (i' : debuginfo) (H2 : In (v', i') s) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive) (v' : ident) (i' : debuginfo) (H2 : In (v', i') s)","proofString":"apply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive) : wf_avail ((v0, i0) :: s).","conclusion":"wf_avail ((v0, i0) :: s)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v < v0)%positive)","proofString":"constructor; auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v0 < v)%positive) : wf_avail ((v0, i0) :: set_state v i s).","conclusion":"wf_avail ((v0, i0) :: set_state v i s)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v0 < v)%positive)","proofString":"constructor.\nred; intros.\nexploit set_state_3.\neexact H0.\neauto.\nintros [[A B] | [A B]]; subst; eauto.\nauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v0 < v)%positive) : avail_above v0 (set_state v i s).","conclusion":"avail_above v0 (set_state v i s)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v0 < v)%positive)","proofString":"red; intros.\nexploit set_state_3.\neexact H0.\neauto.\nintros [[A B] | [A B]]; subst; eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v0 < v)%positive) (v' : ident) (i' : debuginfo) (H2 : In (v', i') (set_state v i s)) : Plt v0 v'.","conclusion":"Plt v0 v'","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v0 < v)%positive) (v' : ident) (i' : debuginfo) (H2 : In (v', i') (set_state v i s))","proofString":"exploit set_state_3.\neexact H0.\neauto.\nintros [[A B] | [A B]]; subst; eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v0 < v)%positive) : wf_avail (set_state v i s).","conclusion":"wf_avail (set_state v i s)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (set_state v i s)) (H1 : (v0 < v)%positive)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (H : False) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (H : False)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i)\n  match (v ?= v0)%positive with\n  | Eq => s\n  | Lt => (v0, i0) :: s\n  | Gt => (v0, i0) :: remove_state v s\n  end) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i)\n  match (v ?= v0)%positive with\n  | Eq => s\n  | Lt => (v0, i0) :: s\n  | Gt => (v0, i0) :: remove_state v s\n  end)","proofString":"destruct (Pos.compare_spec v v0); simpl in *.\nsubst v0.\nelim (Plt_strict v); eauto.\ndestruct H1.\ninv H1.\nelim (Plt_strict v); eauto.\nelim (Plt_strict v).\napply Plt_trans with v0; eauto.\ndestruct H1.\ninv H1.\nelim (Plt_strict v); eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) s) (H2 : v = v0) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) s) (H2 : v = v0)","proofString":"subst v0.\nelim (Plt_strict v); eauto."},{"statement":"(v : ident) (i i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) s) : False.","conclusion":"False","hypotheses":"(v : ident) (i i0 : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) s)","proofString":"elim (Plt_strict v); eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : (v0, i0) = (v, i) \\/ In (v, i) s) (H2 : (v < v0)%positive) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : (v0, i0) = (v, i) \\/ In (v, i) s) (H2 : (v < v0)%positive)","proofString":"destruct H1.\ninv H1.\nelim (Plt_strict v); eauto.\nelim (Plt_strict v).\napply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : (v0, i0) = (v, i)) (H2 : (v < v0)%positive) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : (v0, i0) = (v, i)) (H2 : (v < v0)%positive)","proofString":"inv H1.\nelim (Plt_strict v); eauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H2 : (v < v)%positive) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H2 : (v < v)%positive)","proofString":"elim (Plt_strict v); eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) s) (H2 : (v < v0)%positive) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) s) (H2 : (v < v0)%positive)","proofString":"elim (Plt_strict v).\napply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) s) (H2 : (v < v0)%positive) : Plt v v.","conclusion":"Plt v v","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) s) (H2 : (v < v0)%positive)","proofString":"apply Plt_trans with v0; eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : (v0, i0) = (v, i) \\/ In (v, i) (remove_state v s)) (H2 : (v0 < v)%positive) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : (v0, i0) = (v, i) \\/ In (v, i) (remove_state v s)) (H2 : (v0 < v)%positive)","proofString":"destruct H1.\ninv H1.\nelim (Plt_strict v); eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : (v0, i0) = (v, i)) (H2 : (v0 < v)%positive) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : (v0, i0) = (v, i)) (H2 : (v0 < v)%positive)","proofString":"inv H1.\nelim (Plt_strict v); eauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H2 : (v < v)%positive) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H2 : (v < v)%positive)","proofString":"elim (Plt_strict v); eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) (remove_state v s)) (H2 : (v0 < v)%positive) : False.","conclusion":"False","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : ~ In (v, i) (remove_state v s)) (H1 : In (v, i) (remove_state v s)) (H2 : (v0 < v)%positive)","proofString":"tauto."},{"statement":"(v v' : ident) (i' : debuginfo) (H : v' <> v) (H0 : False) : False.","conclusion":"False","hypotheses":"(v v' : ident) (i' : debuginfo) (H : v' <> v) (H0 : False)","proofString":"auto."},{"statement":"(v v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) : In (v', i')\n  match (v ?= v1)%positive with\n  | Eq => s\n  | Lt => (v1, i1) :: s\n  | Gt => (v1, i1) :: remove_state v s\n  end.","conclusion":"In (v', i')\n  match (v ?= v1)%positive with\n  | Eq => s\n  | Lt => (v1, i1) :: s\n  | Gt => (v1, i1) :: remove_state v s\n  end","hypotheses":"(v v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s)","proofString":"destruct (Pos.compare_spec v v1); simpl.\nsubst v1.\ndestruct H0.\ncongruence.\nauto.\nauto.\ndestruct H0; auto."},{"statement":"(v v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : v = v1) : In (v', i') s.","conclusion":"In (v', i') s","hypotheses":"(v v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : v = v1)","proofString":"subst v1.\ndestruct H0.\ncongruence.\nauto."},{"statement":"(v v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v, i1) = (v', i') \\/ In (v', i') s) : In (v', i') s.","conclusion":"In (v', i') s","hypotheses":"(v v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v, i1) = (v', i') \\/ In (v', i') s)","proofString":"destruct H0.\ncongruence.\nauto."},{"statement":"(v v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v, i1) = (v', i')) : In (v', i') s.","conclusion":"In (v', i') s","hypotheses":"(v v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v, i1) = (v', i'))","proofString":"congruence."},{"statement":"(v v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : In (v', i') s) : In (v', i') s.","conclusion":"In (v', i') s","hypotheses":"(v v' : ident) (i' i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : In (v', i') s)","proofString":"auto."},{"statement":"(v v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : (v < v1)%positive) : (v1, i1) = (v', i') \\/ In (v', i') s.","conclusion":"(v1, i1) = (v', i') \\/ In (v', i') s","hypotheses":"(v v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : (v < v1)%positive)","proofString":"auto."},{"statement":"(v v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : (v1 < v)%positive) : (v1, i1) = (v', i') \\/ In (v', i') (remove_state v s).","conclusion":"(v1, i1) = (v', i') \\/ In (v', i') (remove_state v s)","hypotheses":"(v v' : ident) (i' : debuginfo) (v1 : ident) (i1 : debuginfo) (s : list (ident * debuginfo)) (IHs : v' <> v -> In (v', i') s -> In (v', i') (remove_state v s)) (H : v' <> v) (H0 : (v1, i1) = (v', i') \\/ In (v', i') s) (H1 : (v1 < v)%positive)","proofString":"destruct H0; auto."},{"statement":"(v v' : ident) (i' : debuginfo) (H : False) : v' <> v /\\ False.","conclusion":"v' <> v /\\ False","hypotheses":"(v v' : ident) (i' : debuginfo) (H : False)","proofString":"contradiction."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i')\n  match (v ?= v0)%positive with\n  | Eq => s\n  | Lt => (v0, i) :: s\n  | Gt => (v0, i) :: remove_state v s\n  end) : v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i')\n  match (v ?= v0)%positive with\n  | Eq => s\n  | Lt => (v0, i) :: s\n  | Gt => (v0, i) :: remove_state v s\n  end)","proofString":"destruct (Pos.compare_spec v v0); simpl in H1.\nsubst v0.\nsplit; auto.\napply not_eq_sym; apply Plt_ne; eauto.\ndestruct H1.\ninv H1.\nsplit; auto.\napply not_eq_sym; apply Plt_ne; eauto.\nsplit; auto.\napply not_eq_sym; apply Plt_ne.\napply Plt_trans with v0; eauto.\ndestruct H1.\ninv H1.\nsplit; auto.\napply Plt_ne; auto.\ndestruct IHwf_avail as [A B] ; auto."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : v = v0) : v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : v = v0)","proofString":"subst v0.\nsplit; auto.\napply not_eq_sym; apply Plt_ne; eauto."},{"statement":"(v v' : ident) (i' i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) : v' <> v /\\ ((v, i) = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v, i) = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s)","proofString":"split; auto.\napply not_eq_sym; apply Plt_ne; eauto."},{"statement":"(v v' : ident) (i' i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) : v' <> v.","conclusion":"v' <> v","hypotheses":"(v v' : ident) (i' i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s)","proofString":"apply not_eq_sym; apply Plt_ne; eauto."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : (v0, i) = (v', i') \\/ In (v', i') s) (H2 : (v < v0)%positive) : v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : (v0, i) = (v', i') \\/ In (v', i') s) (H2 : (v < v0)%positive)","proofString":"destruct H1.\ninv H1.\nsplit; auto.\napply not_eq_sym; apply Plt_ne; eauto.\nsplit; auto.\napply not_eq_sym; apply Plt_ne.\napply Plt_trans with v0; eauto."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : (v0, i) = (v', i')) (H2 : (v < v0)%positive) : v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : (v0, i) = (v', i')) (H2 : (v < v0)%positive)","proofString":"inv H1.\nsplit; auto.\napply not_eq_sym; apply Plt_ne; eauto."},{"statement":"(v v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive) : v' <> v /\\ ((v', i') = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v', i') = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive)","proofString":"split; auto.\napply not_eq_sym; apply Plt_ne; eauto."},{"statement":"(v v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive) : v' <> v.","conclusion":"v' <> v","hypotheses":"(v v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H2 : (v < v')%positive)","proofString":"apply not_eq_sym; apply Plt_ne; eauto."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive) : v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive)","proofString":"split; auto.\napply not_eq_sym; apply Plt_ne.\napply Plt_trans with v0; eauto."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive) : v' <> v.","conclusion":"v' <> v","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive)","proofString":"apply not_eq_sym; apply Plt_ne.\napply Plt_trans with v0; eauto."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') s) (H2 : (v < v0)%positive)","proofString":"apply Plt_trans with v0; eauto."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : (v0, i) = (v', i') \\/ In (v', i') (remove_state v s)) (H2 : (v0 < v)%positive) : v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : (v0, i) = (v', i') \\/ In (v', i') (remove_state v s)) (H2 : (v0 < v)%positive)","proofString":"destruct H1.\ninv H1.\nsplit; auto.\napply Plt_ne; auto.\ndestruct IHwf_avail as [A B] ; auto."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : (v0, i) = (v', i')) (H2 : (v0 < v)%positive) : v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : (v0, i) = (v', i')) (H2 : (v0 < v)%positive)","proofString":"inv H1.\nsplit; auto.\napply Plt_ne; auto."},{"statement":"(v v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive) : v' <> v /\\ ((v', i') = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v', i') = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive)","proofString":"split; auto.\napply Plt_ne; auto."},{"statement":"(v v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive) : v' <> v.","conclusion":"v' <> v","hypotheses":"(v v' : ident) (i' : debuginfo) (s : avail) (H : avail_above v' s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H2 : (v' < v)%positive)","proofString":"apply Plt_ne; auto."},{"statement":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') (remove_state v s)) (H2 : (v0 < v)%positive) : v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s).","conclusion":"v' <> v /\\ ((v0, i) = (v', i') \\/ In (v', i') s)","hypotheses":"(v v' : ident) (i' : debuginfo) (v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s) (H1 : In (v', i') (remove_state v s)) (H2 : (v0 < v)%positive)","proofString":"destruct IHwf_avail as [A B] ; auto."},{"statement":"(v : ident) : wf_avail nil.","conclusion":"wf_avail nil","hypotheses":"(v : ident)","proofString":"constructor."},{"statement":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) : wf_avail\n  match (v ?= v0)%positive with\n  | Eq => s\n  | Lt => (v0, i) :: s\n  | Gt => (v0, i) :: remove_state v s\n  end.","conclusion":"wf_avail\n  match (v ?= v0)%positive with\n  | Eq => s\n  | Lt => (v0, i) :: s\n  | Gt => (v0, i) :: remove_state v s\n  end","hypotheses":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s))","proofString":"destruct (Pos.compare_spec v v0).\nauto.\nconstructor; auto.\nconstructor; auto.\nred; intros.\nexploit remove_state_3.\neexact H0.\neauto.\nintros [A B].\neauto."},{"statement":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : v = v0) : wf_avail s.","conclusion":"wf_avail s","hypotheses":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : v = v0)","proofString":"auto."},{"statement":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v < v0)%positive) : wf_avail ((v0, i) :: s).","conclusion":"wf_avail ((v0, i) :: s)","hypotheses":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v < v0)%positive)","proofString":"constructor; auto."},{"statement":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v0 < v)%positive) : wf_avail ((v0, i) :: remove_state v s).","conclusion":"wf_avail ((v0, i) :: remove_state v s)","hypotheses":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v0 < v)%positive)","proofString":"constructor; auto.\nred; intros.\nexploit remove_state_3.\neexact H0.\neauto.\nintros [A B].\neauto."},{"statement":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v0 < v)%positive) : avail_above v0 (remove_state v s).","conclusion":"avail_above v0 (remove_state v s)","hypotheses":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v0 < v)%positive)","proofString":"red; intros.\nexploit remove_state_3.\neexact H0.\neauto.\nintros [A B].\neauto."},{"statement":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v0 < v)%positive) (v' : ident) (i' : debuginfo) (H2 : In (v', i') (remove_state v s)) : Plt v0 v'.","conclusion":"Plt v0 v'","hypotheses":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v0 < v)%positive) (v' : ident) (i' : debuginfo) (H2 : In (v', i') (remove_state v s))","proofString":"exploit remove_state_3.\neexact H0.\neauto.\nintros [A B].\neauto."},{"statement":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v0 < v)%positive) (v' : ident) (i' : debuginfo) (H2 : In (v', i') (remove_state v s)) (A : v' <> v) (B : In (v', i') s) : Plt v0 v'.","conclusion":"Plt v0 v'","hypotheses":"(v v0 : ident) (i : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : wf_avail (remove_state v s)) (H1 : (v0 < v)%positive) (v' : ident) (i' : debuginfo) (H2 : In (v', i') (remove_state v s)) (A : v' <> v) (B : In (v', i') s)","proofString":"eauto."},{"statement":"(pred : ident * debuginfo -> bool) : wf_avail nil.","conclusion":"wf_avail nil","hypotheses":"(pred : ident * debuginfo -> bool)","proofString":"constructor."},{"statement":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) : wf_avail (if pred (v, i) then (v, i) :: filter pred s else filter pred s).","conclusion":"wf_avail (if pred (v, i) then (v, i) :: filter pred s else filter pred s)","hypotheses":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s))","proofString":"destruct (pred (v, i)) eqn:P; auto.\nconstructor; auto.\nred; intros.\napply filter_In in H1.\ndestruct H1.\neauto."},{"statement":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true) : wf_avail ((v, i) :: filter pred s).","conclusion":"wf_avail ((v, i) :: filter pred s)","hypotheses":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true)","proofString":"constructor; auto.\nred; intros.\napply filter_In in H1.\ndestruct H1.\neauto."},{"statement":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true) : avail_above v (filter pred s).","conclusion":"avail_above v (filter pred s)","hypotheses":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true)","proofString":"red; intros.\napply filter_In in H1.\ndestruct H1.\neauto."},{"statement":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true) (v' : ident) (i' : debuginfo) (H1 : In (v', i') (filter pred s)) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true) (v' : ident) (i' : debuginfo) (H1 : In (v', i') (filter pred s))","proofString":"apply filter_In in H1.\ndestruct H1.\neauto."},{"statement":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true) (v' : ident) (i' : debuginfo) (H1 : In (v', i') s /\\ pred (v', i') = true) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true) (v' : ident) (i' : debuginfo) (H1 : In (v', i') s /\\ pred (v', i') = true)","proofString":"destruct H1.\neauto."},{"statement":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true) (v' : ident) (i' : debuginfo) (H1 : In (v', i') s) (H2 : pred (v', i') = true) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(pred : ident * debuginfo -> bool) (v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : wf_avail (filter pred s)) (P : pred (v, i) = true) (v' : ident) (i' : debuginfo) (H1 : In (v', i') s) (H2 : pred (v', i') = true)","proofString":"eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (I1 : (v0, i0) = (v, i) \\/ In (v, i) s) (I2 : (v1, i1) = (v, i) \\/ In (v, i) s0) : In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (I1 : (v0, i0) = (v, i) \\/ In (v, i) s) (I2 : (v1, i1) = (v, i) \\/ In (v, i) s0)","proofString":"destruct I1, I2.\ninv H3; inv H4.\nrewrite Pos.compare_refl.\nrewrite dec_eq_true; auto with coqlib.\ninv H3.\nassert (L: Plt v1 v) by eauto.\napply Pos.compare_gt_iff in L.\nrewrite L.\nauto.\ninv H4.\nassert (L: Plt v0 v) by eauto.\napply Pos.compare_lt_iff in L.\nrewrite L.\napply IHwf_avail.\nconstructor; auto.\nauto.\nauto with coqlib.\ndestruct (Pos.compare v0 v1).\ndestruct (eq_debuginfo i0 i1); auto with coqlib.\napply IHwf_avail; auto with coqlib.\nconstructor; auto.\neauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v0, i0) = (v, i)) (H4 : (v1, i1) = (v, i)) : In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v0, i0) = (v, i)) (H4 : (v1, i1) = (v, i))","proofString":"inv H3; inv H4.\nrewrite Pos.compare_refl.\nrewrite dec_eq_true; auto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) : In (v, i)\n  match (v ?= v)%positive with\n  | Eq => if eq_debuginfo i i then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v, i) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v ?= v)%positive with\n  | Eq => if eq_debuginfo i i then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v, i) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0))","proofString":"rewrite Pos.compare_refl.\nrewrite dec_eq_true; auto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) : In (v, i) (if eq_debuginfo i i then (v, i) :: join s s0 else join s s0).","conclusion":"In (v, i) (if eq_debuginfo i i then (v, i) :: join s s0 else join s s0)","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0))","proofString":"rewrite dec_eq_true; auto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v0, i0) = (v, i)) (H4 : In (v, i) s0) : In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v0, i0) = (v, i)) (H4 : In (v, i) s0)","proofString":"inv H3.\nassert (L: Plt v1 v) by eauto.\napply Pos.compare_gt_iff in L.\nrewrite L.\nauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H4 : In (v, i) s0) : In (v, i)\n  match (v ?= v1)%positive with\n  | Eq => if eq_debuginfo i i1 then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v ?= v1)%positive with\n  | Eq => if eq_debuginfo i i1 then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H4 : In (v, i) s0)","proofString":"assert (L: Plt v1 v) by eauto.\napply Pos.compare_gt_iff in L.\nrewrite L.\nauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H4 : In (v, i) s0) (L : Plt v1 v) : In (v, i)\n  match (v ?= v1)%positive with\n  | Eq => if eq_debuginfo i i1 then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v ?= v1)%positive with\n  | Eq => if eq_debuginfo i i1 then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H4 : In (v, i) s0) (L : Plt v1 v)","proofString":"apply Pos.compare_gt_iff in L.\nrewrite L.\nauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H4 : In (v, i) s0) (L : (v ?= v1)%positive = Gt) : In (v, i)\n  match (v ?= v1)%positive with\n  | Eq => if eq_debuginfo i i1 then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v ?= v1)%positive with\n  | Eq => if eq_debuginfo i i1 then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H4 : In (v, i) s0) (L : (v ?= v1)%positive = Gt)","proofString":"rewrite L.\nauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H4 : In (v, i) s0) (L : (v ?= v1)%positive = Gt) : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0).","conclusion":"In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v, i) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H4 : In (v, i) s0) (L : (v ?= v1)%positive = Gt)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : (v1, i1) = (v, i)) : In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : (v1, i1) = (v, i))","proofString":"inv H4.\nassert (L: Plt v0 v) by eauto.\napply Pos.compare_lt_iff in L.\nrewrite L.\napply IHwf_avail.\nconstructor; auto.\nauto.\nauto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) : In (v, i)\n  match (v0 ?= v)%positive with\n  | Eq => if eq_debuginfo i0 i then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v, i) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v0 ?= v)%positive with\n  | Eq => if eq_debuginfo i0 i then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v, i) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s)","proofString":"assert (L: Plt v0 v) by eauto.\napply Pos.compare_lt_iff in L.\nrewrite L.\napply IHwf_avail.\nconstructor; auto.\nauto.\nauto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : Plt v0 v) : In (v, i)\n  match (v0 ?= v)%positive with\n  | Eq => if eq_debuginfo i0 i then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v, i) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v0 ?= v)%positive with\n  | Eq => if eq_debuginfo i0 i then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v, i) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : Plt v0 v)","proofString":"apply Pos.compare_lt_iff in L.\nrewrite L.\napply IHwf_avail.\nconstructor; auto.\nauto.\nauto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt) : In (v, i)\n  match (v0 ?= v)%positive with\n  | Eq => if eq_debuginfo i0 i then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v, i) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v0 ?= v)%positive with\n  | Eq => if eq_debuginfo i0 i then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v, i) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt)","proofString":"rewrite L.\napply IHwf_avail.\nconstructor; auto.\nauto.\nauto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt) : In (v, i) (join s ((v, i) :: s0)).","conclusion":"In (v, i) (join s ((v, i) :: s0))","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt)","proofString":"apply IHwf_avail.\nconstructor; auto.\nauto.\nauto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt) : wf_avail ((v, i) :: s0).","conclusion":"wf_avail ((v, i) :: s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt)","proofString":"constructor; auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt) : In (v, i) s.","conclusion":"In (v, i) s","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt)","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt) : In (v, i) ((v, i) :: s0).","conclusion":"In (v, i) ((v, i) :: s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (L : (v0 ?= v)%positive = Lt)","proofString":"auto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0) : In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0)","proofString":"destruct (Pos.compare v0 v1).\ndestruct (eq_debuginfo i0 i1); auto with coqlib.\napply IHwf_avail; auto with coqlib.\nconstructor; auto.\neauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0) : In (v, i) (if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0).","conclusion":"In (v, i) (if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0)","proofString":"destruct (eq_debuginfo i0 i1); auto with coqlib."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0) : In (v, i) (join s ((v1, i1) :: s0)).","conclusion":"In (v, i) (join s ((v1, i1) :: s0))","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0)","proofString":"apply IHwf_avail; auto with coqlib.\nconstructor; auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0) : wf_avail ((v1, i1) :: s0).","conclusion":"wf_avail ((v1, i1) :: s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0)","proofString":"constructor; auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0) : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0).","conclusion":"In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) s -> In (v, i) s2 -> In (v, i) (join s s2)) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : (v0, i0) = (v, i) \\/ In (v, i) s ->\nIn (v, i) s0 ->\nIn (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : In (v, i) s) (H4 : In (v, i) s0)","proofString":"eauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i)\n  match (v0 ?= v1)%positive with\n  | Eq => if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0\n  | Lt => join s ((v1, i1) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v0 ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i0 i2\n                 then (v0, i0) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end)","proofString":"destruct (Pos.compare_spec v0 v1).\nsubst v1.\ndestruct (eq_debuginfo i0 i1).\nsubst i1.\ndestruct I.\nauto.\nexploit IHwf_avail; eauto.\ntauto.\nexploit IHwf_avail; eauto.\ntauto.\nexploit (IHwf_avail ((v1, i1) :: s0)); eauto.\nconstructor; auto.\nsimpl.\ntauto.\nexploit IHwf_avail0; eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0)) (H3 : v0 = v1) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0)) (H3 : v0 = v1)","proofString":"subst v1.\ndestruct (eq_debuginfo i0 i1).\nsubst i1.\ndestruct I.\nauto.\nexploit IHwf_avail; eauto.\ntauto.\nexploit IHwf_avail; eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0)) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (if eq_debuginfo i0 i1 then (v0, i0) :: join s s0 else join s s0))","proofString":"destruct (eq_debuginfo i0 i1).\nsubst i1.\ndestruct I.\nauto.\nexploit IHwf_avail; eauto.\ntauto.\nexploit IHwf_avail; eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (e : i0 = i1) (I : In (v, i) ((v0, i0) :: join s s0)) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (e : i0 = i1) (I : In (v, i) ((v0, i0) :: join s s0))","proofString":"subst i1.\ndestruct I.\nauto.\nexploit IHwf_avail; eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) ((v0, i0) :: join s s0)) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i0) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i0) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) ((v0, i0) :: join s s0))","proofString":"destruct I.\nauto.\nexploit IHwf_avail; eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (H3 : (v0, i0) = (v, i)) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i0) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i0) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (H3 : (v0, i0) = (v, i))","proofString":"auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (H3 : In (v, i) (join s s0)) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i0) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i0) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (H3 : In (v, i) (join s s0))","proofString":"exploit IHwf_avail; eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (H3 : In (v, i) (join s s0)) : In (v, i) s /\\ In (v, i) s0 ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i0) = (v, i) \\/ In (v, i) s0).","conclusion":"In (v, i) s /\\ In (v, i) s0 ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i0) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (H3 : In (v, i) (join s s0))","proofString":"tauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (n : i0 <> i1) (I : In (v, i) (join s s0)) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (n : i0 <> i1) (I : In (v, i) (join s s0))","proofString":"exploit IHwf_avail; eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (n : i0 <> i1) (I : In (v, i) (join s s0)) : In (v, i) s /\\ In (v, i) s0 ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"In (v, i) s /\\ In (v, i) s0 ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v0, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (n : i0 <> i1) (I : In (v, i) (join s s0))","proofString":"tauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (join s ((v1, i1) :: s0))) (H3 : (v0 < v1)%positive) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (join s ((v1, i1) :: s0))) (H3 : (v0 < v1)%positive)","proofString":"exploit (IHwf_avail ((v1, i1) :: s0)); eauto.\nconstructor; auto.\nsimpl.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (join s ((v1, i1) :: s0))) (H3 : (v0 < v1)%positive) : wf_avail ((v1, i1) :: s0).","conclusion":"wf_avail ((v1, i1) :: s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (join s ((v1, i1) :: s0))) (H3 : (v0 < v1)%positive)","proofString":"constructor; auto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (join s ((v1, i1) :: s0))) (H3 : (v0 < v1)%positive) : In (v, i) s /\\ In (v, i) ((v1, i1) :: s0) ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"In (v, i) s /\\ In (v, i) ((v1, i1) :: s0) ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (join s ((v1, i1) :: s0))) (H3 : (v0 < v1)%positive)","proofString":"simpl.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (join s ((v1, i1) :: s0))) (H3 : (v0 < v1)%positive) : In (v, i) s /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0) ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"In (v, i) s /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0) ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i) (join s ((v1, i1) :: s0))) (H3 : (v0 < v1)%positive)","proofString":"tauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v1 < v0)%positive) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v1 < v0)%positive)","proofString":"exploit IHwf_avail0; eauto.\ntauto."},{"statement":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v1 < v0)%positive) : ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0 ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0).","conclusion":"((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0 ->\n((v0, i0) = (v, i) \\/ In (v, i) s) /\\ ((v1, i1) = (v, i) \\/ In (v, i) s0)","hypotheses":"(v : ident) (i : debuginfo) (v0 : ident) (i0 : debuginfo) (s : avail) (H : avail_above v0 s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail,\nwf_avail s2 -> In (v, i) (join s s2) -> In (v, i) s /\\ In (v, i) s2) (v1 : ident) (i1 : debuginfo) (s0 : avail) (H1 : avail_above v1 s0) (H2 : wf_avail s0) (IHwf_avail0 : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0) -> ((v0, i0) = (v, i) \\/ In (v, i) s) /\\ In (v, i) s0) (I : In (v, i)\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v0 ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i0 i2\n              then (v0, i0) :: join s s2'\n              else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v1 < v0)%positive)","proofString":"tauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) : wf_avail\n  match (v ?= v0)%positive with\n  | Eq => if eq_debuginfo i i0 then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v0, i0) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end.","conclusion":"wf_avail\n  match (v ?= v0)%positive with\n  | Eq => if eq_debuginfo i i0 then (v, i) :: join s s0 else join s s0\n  | Lt => join s ((v0, i0) :: s0)\n  | Gt =>\n      (fix join2 (s2 : avail) : avail :=\n         match s2 with\n         | nil => nil\n         | (v2, i2) :: s2' =>\n             match (v ?= v2)%positive with\n             | Eq =>\n                 if eq_debuginfo i i2\n                 then (v, i) :: join s s2'\n                 else join s s2'\n             | Lt => join s s2\n             | Gt => join2 s2'\n             end\n         end) s0\n  end","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0))","proofString":"destruct (Pos.compare_spec v v0).\nsubst v0.\ndestruct (eq_debuginfo i i0); auto.\nconstructor; auto.\nred; intros.\napply join_2 in H3; auto.\ndestruct H3.\neauto.\napply IHwf_avail.\nconstructor; auto.\napply IHwf_avail0."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : v = v0) : wf_avail (if eq_debuginfo i i0 then (v, i) :: join s s0 else join s s0).","conclusion":"wf_avail (if eq_debuginfo i i0 then (v, i) :: join s s0 else join s s0)","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : v = v0)","proofString":"subst v0.\ndestruct (eq_debuginfo i i0); auto.\nconstructor; auto.\nred; intros.\napply join_2 in H3; auto.\ndestruct H3.\neauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) : wf_avail (if eq_debuginfo i i0 then (v, i) :: join s s0 else join s s0).","conclusion":"wf_avail (if eq_debuginfo i i0 then (v, i) :: join s s0 else join s s0)","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0))","proofString":"destruct (eq_debuginfo i i0); auto.\nconstructor; auto.\nred; intros.\napply join_2 in H3; auto.\ndestruct H3.\neauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0) : wf_avail ((v, i) :: join s s0).","conclusion":"wf_avail ((v, i) :: join s s0)","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0)","proofString":"constructor; auto.\nred; intros.\napply join_2 in H3; auto.\ndestruct H3.\neauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0) : avail_above v (join s s0).","conclusion":"avail_above v (join s s0)","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0)","proofString":"red; intros.\napply join_2 in H3; auto.\ndestruct H3.\neauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0) (v' : ident) (i' : debuginfo) (H3 : In (v', i') (join s s0)) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0) (v' : ident) (i' : debuginfo) (H3 : In (v', i') (join s s0))","proofString":"apply join_2 in H3; auto.\ndestruct H3.\neauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0) (v' : ident) (i' : debuginfo) (H3 : In (v', i') s /\\ In (v', i') s0) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0) (v' : ident) (i' : debuginfo) (H3 : In (v', i') s /\\ In (v', i') s0)","proofString":"destruct H3.\neauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0) (v' : ident) (i' : debuginfo) (H3 : In (v', i') s) (H4 : In (v', i') s0) : Plt v v'.","conclusion":"Plt v v'","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (e : i = i0) (v' : ident) (i' : debuginfo) (H3 : In (v', i') s) (H4 : In (v', i') s0)","proofString":"eauto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v < v0)%positive) : wf_avail (join s ((v0, i0) :: s0)).","conclusion":"wf_avail (join s ((v0, i0) :: s0))","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v < v0)%positive)","proofString":"apply IHwf_avail.\nconstructor; auto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v < v0)%positive) : wf_avail ((v0, i0) :: s0).","conclusion":"wf_avail ((v0, i0) :: s0)","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v < v0)%positive)","proofString":"constructor; auto."},{"statement":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v0 < v)%positive) : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0).","conclusion":"wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)","hypotheses":"(v : ident) (i : debuginfo) (s : avail) (H : avail_above v s) (H0 : wf_avail s) (IHwf_avail : forall s2 : avail, wf_avail s2 -> wf_avail (join s s2)) (v0 : ident) (i0 : debuginfo) (s0 : avail) (H1 : avail_above v0 s0) (H2 : wf_avail s0) (IHwf_avail0 : wf_avail\n  ((fix join2 (s2 : avail) : avail :=\n      match s2 with\n      | nil => nil\n      | (v2, i2) :: s2' =>\n          match (v ?= v2)%positive with\n          | Eq =>\n              if eq_debuginfo i i2 then (v, i) :: join s s2' else join s s2'\n          | Lt => join s s2\n          | Gt => join2 s2'\n          end\n      end) s0)) (H3 : (v0 < v)%positive)","proofString":"apply IHwf_avail0."},{"statement":"(f tf : fundef) (H : match f with\n| Internal f0 =>\n    bind (transf_function f0) (fun f' : function => OK (Internal f'))\n| External ef => OK (External ef)\nend = OK tf) : funsig tf = funsig f.","conclusion":"funsig tf = funsig f","hypotheses":"(f tf : fundef) (H : match f with\n| Internal f0 =>\n    bind (transf_function f0) (fun f' : function => OK (Internal f'))\n| External ef => OK (External ef)\nend = OK tf)","proofString":"destruct f.\nmonadInv H.\nexploit transf_function_match; eauto.\nintros M; inv M; auto.\ninv H.\nreflexivity."},{"statement":"(f : function) (tf : fundef) (H : bind (transf_function f) (fun f' : function => OK (Internal f')) = OK tf) : funsig tf = funsig (Internal f).","conclusion":"funsig tf = funsig (Internal f)","hypotheses":"(f : function) (tf : fundef) (H : bind (transf_function f) (fun f' : function => OK (Internal f')) = OK tf)","proofString":"monadInv H.\nexploit transf_function_match; eauto.\nintros M; inv M; auto."},{"statement":"(f x : function) (EQ : transf_function f = OK x) : funsig (Internal x) = funsig (Internal f).","conclusion":"funsig (Internal x) = funsig (Internal f)","hypotheses":"(f x : function) (EQ : transf_function f = OK x)","proofString":"exploit transf_function_match; eauto.\nintros M; inv M; auto."},{"statement":"(f x : function) (EQ : transf_function f = OK x) : match_function f x -> funsig (Internal x) = funsig (Internal f).","conclusion":"match_function f x -> funsig (Internal x) = funsig (Internal f)","hypotheses":"(f x : function) (EQ : transf_function f = OK x)","proofString":"intros M; inv M; auto."},{"statement":"(e : external_function) (tf : fundef) (H : OK (External e) = OK tf) : funsig tf = funsig (External e).","conclusion":"funsig tf = funsig (External e)","hypotheses":"(e : external_function) (tf : fundef) (H : OK (External e) = OK tf)","proofString":"inv H.\nreflexivity."},{"statement":"(e : external_function) : funsig (External e) = funsig (External e).","conclusion":"funsig (External e) = funsig (External e)","hypotheses":"(e : external_function)","proofString":"reflexivity."},{"statement":"(m : mreg) (ls : locset) (f : fundef) (H : Genv.find_funct ge (ls (R m)) = Some f) : exists tf : fundef,\n  Genv.find_funct tge (ls (R m)) = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef,\n  Genv.find_funct tge (ls (R m)) = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(m : mreg) (ls : locset) (f : fundef) (H : Genv.find_funct ge (ls (R m)) = Some f)","proofString":"apply functions_translated; auto."},{"statement":"(i : ident) (ls : locset) (f : fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) : exists tf : fundef,\n  match Genv.find_symbol tge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef,\n  match Genv.find_symbol tge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(i : ident) (ls : locset) (f : fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f)","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge i).\napply function_ptr_translated; auto.\ncongruence."},{"statement":"(i : ident) (ls : locset) (f : fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) : exists tf : fundef,\n  match Genv.find_symbol ge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef,\n  match Genv.find_symbol ge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(i : ident) (ls : locset) (f : fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f)","proofString":"destruct (Genv.find_symbol ge i).\napply function_ptr_translated; auto.\ncongruence."},{"statement":"(i : ident) (ls : locset) (f : fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some f) : exists tf : fundef,\n  Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef,\n  Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(i : ident) (ls : locset) (f : fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some f)","proofString":"apply function_ptr_translated; auto."},{"statement":"(i : ident) (ls : locset) (f : fundef) (H : None = Some f) : exists tf : fundef, None = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef, None = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(i : ident) (ls : locset) (f : fundef) (H : None = Some f)","proofString":"congruence."},{"statement":"(rs : locset) (sp : val) (m : mem) (a1 a2 : builtin_arg loc) (IHa1 : safe_builtin_arg a1 -> exists v : val, eval_builtin_arg tge rs sp m a1 v) (IHa2 : safe_builtin_arg a2 -> exists v : val, eval_builtin_arg tge rs sp m a2 v) (H : safe_builtin_arg a1 /\\ safe_builtin_arg a2) : exists v : val, eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v.","conclusion":"exists v : val, eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v","hypotheses":"(rs : locset) (sp : val) (m : mem) (a1 a2 : builtin_arg loc) (IHa1 : safe_builtin_arg a1 -> exists v : val, eval_builtin_arg tge rs sp m a1 v) (IHa2 : safe_builtin_arg a2 -> exists v : val, eval_builtin_arg tge rs sp m a2 v) (H : safe_builtin_arg a1 /\\ safe_builtin_arg a2)","proofString":"destruct H as [S1 S2].\ndestruct (IHa1 S1) as [v1 E1].\ndestruct (IHa2 S2) as [v2 E2].\nexists (Val.longofwords v1 v2); auto with barg."},{"statement":"(rs : locset) (sp : val) (m : mem) (a1 a2 : builtin_arg loc) (IHa1 : safe_builtin_arg a1 -> exists v : val, eval_builtin_arg tge rs sp m a1 v) (IHa2 : safe_builtin_arg a2 -> exists v : val, eval_builtin_arg tge rs sp m a2 v) (S1 : safe_builtin_arg a1) (S2 : safe_builtin_arg a2) : exists v : val, eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v.","conclusion":"exists v : val, eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v","hypotheses":"(rs : locset) (sp : val) (m : mem) (a1 a2 : builtin_arg loc) (IHa1 : safe_builtin_arg a1 -> exists v : val, eval_builtin_arg tge rs sp m a1 v) (IHa2 : safe_builtin_arg a2 -> exists v : val, eval_builtin_arg tge rs sp m a2 v) (S1 : safe_builtin_arg a1) (S2 : safe_builtin_arg a2)","proofString":"destruct (IHa1 S1) as [v1 E1].\ndestruct (IHa2 S2) as [v2 E2].\nexists (Val.longofwords v1 v2); auto with barg."},{"statement":"(rs : locset) (sp : val) (m : mem) (a1 a2 : builtin_arg loc) (IHa1 : safe_builtin_arg a1 -> exists v : val, eval_builtin_arg tge rs sp m a1 v) (IHa2 : safe_builtin_arg a2 -> exists v : val, eval_builtin_arg tge rs sp m a2 v) (S1 : safe_builtin_arg a1) (S2 : safe_builtin_arg a2) (v1 : val) (E1 : eval_builtin_arg tge rs sp m a1 v1) : exists v : val, eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v.","conclusion":"exists v : val, eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v","hypotheses":"(rs : locset) (sp : val) (m : mem) (a1 a2 : builtin_arg loc) (IHa1 : safe_builtin_arg a1 -> exists v : val, eval_builtin_arg tge rs sp m a1 v) (IHa2 : safe_builtin_arg a2 -> exists v : val, eval_builtin_arg tge rs sp m a2 v) (S1 : safe_builtin_arg a1) (S2 : safe_builtin_arg a2) (v1 : val) (E1 : eval_builtin_arg tge rs sp m a1 v1)","proofString":"destruct (IHa2 S2) as [v2 E2].\nexists (Val.longofwords v1 v2); auto with barg."},{"statement":"(rs : locset) (sp : val) (m : mem) (a1 a2 : builtin_arg loc) (IHa1 : safe_builtin_arg a1 -> exists v : val, eval_builtin_arg tge rs sp m a1 v) (IHa2 : safe_builtin_arg a2 -> exists v : val, eval_builtin_arg tge rs sp m a2 v) (S1 : safe_builtin_arg a1) (S2 : safe_builtin_arg a2) (v1 : val) (E1 : eval_builtin_arg tge rs sp m a1 v1) (v2 : val) (E2 : eval_builtin_arg tge rs sp m a2 v2) : exists v : val, eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v.","conclusion":"exists v : val, eval_builtin_arg tge rs sp m (BA_splitlong a1 a2) v","hypotheses":"(rs : locset) (sp : val) (m : mem) (a1 a2 : builtin_arg loc) (IHa1 : safe_builtin_arg a1 -> exists v : val, eval_builtin_arg tge rs sp m a1 v) (IHa2 : safe_builtin_arg a2 -> exists v : val, eval_builtin_arg tge rs sp m a2 v) (S1 : safe_builtin_arg a1) (S2 : safe_builtin_arg a2) (v1 : val) (E1 : eval_builtin_arg tge rs sp m a1 v1) (v2 : val) (E2 : eval_builtin_arg tge rs sp m a2 v2)","proofString":"exists (Val.longofwords v1 v2); auto with barg."},{"statement":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) : star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n  (State s f sp c rs m).","conclusion":"star step tge (State s f sp (add_delta_ranges before after c) rs m) E0\n  (State s f sp c rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail)","proofString":"unfold add_delta_ranges.\ndestruct (delta_state before after) as [killed born].\ninduction killed as [ | [v i] l]; simpl.\ninduction born as [ | [v i] l]; simpl.\napply star_refl.\ndestruct i as [a SAFE]; simpl.\nexploit can_eval_safe_arg; eauto.\nintros [v1 E1].\neapply star_step; eauto.\neconstructor.\nconstructor.\neexact E1.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq.\neapply star_step; eauto.\neconstructor.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq."},{"statement":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) : star step tge\n  (State s f sp\n     (let (killed, born) := delta_state before after in\n      fold_right add_end_range (fold_right add_start_range c born) killed) rs\n     m) E0 (State s f sp c rs m).","conclusion":"star step tge\n  (State s f sp\n     (let (killed, born) := delta_state before after in\n      fold_right add_end_range (fold_right add_start_range c born) killed) rs\n     m) E0 (State s f sp c rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail)","proofString":"destruct (delta_state before after) as [killed born].\ninduction killed as [ | [v i] l]; simpl.\ninduction born as [ | [v i] l]; simpl.\napply star_refl.\ndestruct i as [a SAFE]; simpl.\nexploit can_eval_safe_arg; eauto.\nintros [v1 E1].\neapply star_step; eauto.\neconstructor.\nconstructor.\neexact E1.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq.\neapply star_step; eauto.\neconstructor.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq."},{"statement":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (killed born : avail) : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born) killed) rs\n     m) E0 (State s f sp c rs m).","conclusion":"star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born) killed) rs\n     m) E0 (State s f sp c rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (killed born : avail)","proofString":"induction killed as [ | [v i] l]; simpl.\ninduction born as [ | [v i] l]; simpl.\napply star_refl.\ndestruct i as [a SAFE]; simpl.\nexploit can_eval_safe_arg; eauto.\nintros [v1 E1].\neapply star_step; eauto.\neconstructor.\nconstructor.\neexact E1.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq.\neapply star_step; eauto.\neconstructor.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq."},{"statement":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (born : avail) : star step tge (State s f sp (fold_right add_start_range c born) rs m) E0\n  (State s f sp c rs m).","conclusion":"star step tge (State s f sp (fold_right add_start_range c born) rs m) E0\n  (State s f sp c rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (born : avail)","proofString":"induction born as [ | [v i] l]; simpl.\napply star_refl.\ndestruct i as [a SAFE]; simpl.\nexploit can_eval_safe_arg; eauto.\nintros [v1 E1].\neapply star_step; eauto.\neconstructor.\nconstructor.\neexact E1.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq."},{"statement":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) : star step tge (State s f sp c rs m) E0 (State s f sp c rs m).","conclusion":"star step tge (State s f sp c rs m) E0 (State s f sp c rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail)","proofString":"apply star_refl."},{"statement":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (v : ident) (i : debuginfo) (l : list (ident * debuginfo)) (IHl : star step tge (State s f sp (fold_right add_start_range c l) rs m) E0\n  (State s f sp c rs m)) : star step tge\n  (State s f sp\n     (Lbuiltin (EF_debug 3 v nil) (proj1_sig i :: nil) BR_none\n      :: fold_right add_start_range c l) rs m) E0 \n  (State s f sp c rs m).","conclusion":"star step tge\n  (State s f sp\n     (Lbuiltin (EF_debug 3 v nil) (proj1_sig i :: nil) BR_none\n      :: fold_right add_start_range c l) rs m) E0 \n  (State s f sp c rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (v : ident) (i : debuginfo) (l : list (ident * debuginfo)) (IHl : star step tge (State s f sp (fold_right add_start_range c l) rs m) E0\n  (State s f sp c rs m))","proofString":"destruct i as [a SAFE]; simpl.\nexploit can_eval_safe_arg; eauto.\nintros [v1 E1].\neapply star_step; eauto.\neconstructor.\nconstructor.\neexact E1.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq."},{"statement":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (v : ident) (a : builtin_arg loc) (SAFE : safe_builtin_arg a) (l : list (ident * debuginfo)) (IHl : star step tge (State s f sp (fold_right add_start_range c l) rs m) E0\n  (State s f sp c rs m)) : star step tge\n  (State s f sp\n     (Lbuiltin (EF_debug 3 v nil) (a :: nil) BR_none\n      :: fold_right add_start_range c l) rs m) E0 \n  (State s f sp c rs m).","conclusion":"star step tge\n  (State s f sp\n     (Lbuiltin (EF_debug 3 v nil) (a :: nil) BR_none\n      :: fold_right add_start_range c l) rs m) E0 \n  (State s f sp c rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (v : ident) (a : builtin_arg loc) (SAFE : safe_builtin_arg a) (l : list (ident * debuginfo)) (IHl : star step tge (State s f sp (fold_right add_start_range c l) rs m) E0\n  (State s f sp c rs m))","proofString":"exploit can_eval_safe_arg; eauto.\nintros [v1 E1].\neapply star_step; eauto.\neconstructor.\nconstructor.\neexact E1.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq."},{"statement":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (v : ident) (i : debuginfo) (l : list (ident * debuginfo)) (born : avail) (IHl : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born) l) rs m)\n  E0 (State s f sp c rs m)) : star step tge\n  (State s f sp\n     (Lbuiltin (EF_debug 4 v nil) nil BR_none\n      :: fold_right add_end_range (fold_right add_start_range c born) l) rs m)\n  E0 (State s f sp c rs m).","conclusion":"star step tge\n  (State s f sp\n     (Lbuiltin (EF_debug 4 v nil) nil BR_none\n      :: fold_right add_end_range (fold_right add_start_range c born) l) rs m)\n  E0 (State s f sp c rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (c : code) (rs : locset) (m : mem) (before after : option avail) (v : ident) (i : debuginfo) (l : list (ident * debuginfo)) (born : avail) (IHl : star step tge\n  (State s f sp\n     (fold_right add_end_range (fold_right add_start_range c born) l) rs m)\n  E0 (State s f sp c rs m))","proofString":"eapply star_step; eauto.\neconstructor.\nconstructor.\nsimpl; constructor.\nsimpl; auto.\ntraceEq."},{"statement":"Locmap.init Vundef = Locmap.init Vundef.","conclusion":"Locmap.init Vundef = Locmap.init Vundef","hypotheses":"","proofString":"auto."},{"statement":"(a1 : stackframe) (al : list stackframe) (b1 : stackframe) (bl : list stackframe) (H : match_stackframes a1 b1) (H0 : list_forall2 match_stackframes al bl) (IHlist_forall2 : parent_locset bl = parent_locset al) : match b1 with\n| Stackframe _ _ ls _ => ls\nend = match a1 with\n      | Stackframe _ _ ls _ => ls\n      end.","conclusion":"match b1 with\n| Stackframe _ _ ls _ => ls\nend = match a1 with\n      | Stackframe _ _ ls _ => ls\n      end","hypotheses":"(a1 : stackframe) (al : list stackframe) (b1 : stackframe) (bl : list stackframe) (H : match_stackframes a1 b1) (H0 : list_forall2 match_stackframes al bl) (IHlist_forall2 : parent_locset bl = parent_locset al)","proofString":"inv H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (rs : loc -> val) (m : mem) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H2 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lgetstack sl ofs ty dst :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lgetstack sl ofs ty dst :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (rs : loc -> val) (m : mem) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H2 : match_code b c')","proofString":"econstructor; split.\neapply plus_left.\nconstructor; auto.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (rs : loc -> val) (m : mem) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H2 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lsetstack src sl ofs ty :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.set (S sl ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lsetstack src sl ofs ty :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.set (S sl ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (rs : loc -> val) (m : mem) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H2 : match_code b c')","proofString":"econstructor; split.\neapply plus_left.\nconstructor; auto.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (LTL.reglist rs args) m = Some v) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lop op args res :: add_delta_ranges before after c') rs\n       m) E0 ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lop op args res :: add_delta_ranges before after c') rs\n       m) E0 ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (LTL.reglist rs args) m = Some v) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"econstructor; split.\neapply plus_left.\neconstructor; eauto.\ninstantiate (1 := v).\nrewrite <- H; apply eval_operation_preserved; exact symbols_preserved.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (LTL.reglist rs args) m = Some v) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : eval_operation tge sp op (LTL.reglist rs args) m = Some v.","conclusion":"eval_operation tge sp op (LTL.reglist rs args) m = Some v","hypotheses":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (LTL.reglist rs args) m = Some v) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"rewrite <- H; apply eval_operation_preserved; exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lload chunk addr args dst :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lload chunk addr args dst :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"econstructor; split.\neapply plus_left.\neapply exec_Lload with (a := a).\nrewrite <- H; apply eval_addressing_preserved; exact symbols_preserved.\neauto.\neauto.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : eval_addressing tge sp addr (LTL.reglist rs args) = Some a.","conclusion":"eval_addressing tge sp addr (LTL.reglist rs args) = Some a","hypotheses":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"rewrite <- H; apply eval_addressing_preserved; exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list instruction) (rs : LTL.locset) (m m' : mem) (a : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lstore chunk addr args src :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states\n    (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs) m')\n    ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lstore chunk addr args src :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states\n    (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs) m')\n    ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list instruction) (rs : LTL.locset) (m m' : mem) (a : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"econstructor; split.\neapply plus_left.\neapply exec_Lstore with (a := a).\nrewrite <- H; apply eval_addressing_preserved; exact symbols_preserved.\neauto.\neauto.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list instruction) (rs : LTL.locset) (m m' : mem) (a : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : eval_addressing tge sp addr (LTL.reglist rs args) = Some a.","conclusion":"eval_addressing tge sp addr (LTL.reglist rs args) = Some a","hypotheses":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list instruction) (rs : LTL.locset) (m m' : mem) (a : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"rewrite <- H; apply eval_addressing_preserved; exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lcall (funsig f') ros :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (Callstate (Stackframe f sp rs b :: s) f' rs m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lcall (funsig f') ros :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (Callstate (Stackframe f sp rs b :: s) f' rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"exploit find_function_translated; eauto.\nintros (tf' & A & B).\neconstructor; split.\napply plus_one.\neconstructor.\neexact A.\nsymmetry; apply sig_preserved; auto.\ntraceEq.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : (exists tf0 : fundef,\n   find_function tge ros rs = Some tf0 /\\ transf_fundef f' = OK tf0) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lcall (funsig f') ros :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (Callstate (Stackframe f sp rs b :: s) f' rs m) ts2.","conclusion":"(exists tf0 : fundef,\n   find_function tge ros rs = Some tf0 /\\ transf_fundef f' = OK tf0) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lcall (funsig f') ros :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (Callstate (Stackframe f sp rs b :: s) f' rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"intros (tf' & A & B).\neconstructor; split.\napply plus_one.\neconstructor.\neexact A.\nsymmetry; apply sig_preserved; auto.\ntraceEq.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (tf' : fundef) (A : find_function tge ros rs = Some tf') (B : transf_fundef f' = OK tf') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lcall (funsig f') ros :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (Callstate (Stackframe f sp rs b :: s) f' rs m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lcall (funsig f') ros :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (Callstate (Stackframe f sp rs b :: s) f' rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (tf' : fundef) (A : find_function tge ros rs = Some tf') (B : transf_fundef f' = OK tf')","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neexact A.\nsymmetry; apply sig_preserved; auto.\ntraceEq.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (tf' : fundef) (A : find_function tge ros rs = Some tf') (B : transf_fundef f' = OK tf') : match_states (Callstate (Stackframe f sp rs b :: s) f' rs m)\n  (Callstate (Stackframe tf sp rs (add_delta_ranges before after c') :: ts)\n     tf' rs m).","conclusion":"match_states (Callstate (Stackframe f sp rs b :: s) f' rs m)\n  (Callstate (Stackframe tf sp rs (add_delta_ranges before after c') :: ts)\n     tf' rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (tf' : fundef) (A : find_function tge ros rs = Some tf') (B : transf_fundef f' = OK tf')","proofString":"constructor; auto.\nconstructor; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (tf' : fundef) (A : find_function tge ros rs = Some tf') (B : transf_fundef f' = OK tf') : list_forall2 match_stackframes (Stackframe f sp rs b :: s)\n  (Stackframe tf sp rs (add_delta_ranges before after c') :: ts).","conclusion":"list_forall2 match_stackframes (Stackframe f sp rs b :: s)\n  (Stackframe tf sp rs (add_delta_ranges before after c') :: ts)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (tf' : fundef) (A : find_function tge ros rs = Some tf') (B : transf_fundef f' = OK tf')","proofString":"constructor; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (tf' : fundef) (A : find_function tge ros rs = Some tf') (B : transf_fundef f' = OK tf') : match_stackframes (Stackframe f sp rs b)\n  (Stackframe tf sp rs (add_delta_ranges before after c')).","conclusion":"match_stackframes (Stackframe f sp rs b)\n  (Stackframe tf sp rs (add_delta_ranges before after c'))","hypotheses":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (tf' : fundef) (A : find_function tge ros rs = Some tf') (B : transf_fundef f' = OK tf')","proofString":"constructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2","hypotheses":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"exploit find_function_translated; eauto.\nintros (tf' & A & B).\nexploit parent_locset_match; eauto.\nintros PLS.\neconstructor; split.\napply plus_one.\neconstructor.\neauto.\nrewrite PLS.\neexact A.\nsymmetry; apply sig_preserved; auto.\ninv TRF; eauto.\ntraceEq.\nrewrite PLS.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : (exists tf0 : fundef,\n   find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf0 /\\\n   transf_fundef f' = OK tf0) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2.","conclusion":"(exists tf0 : fundef,\n   find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf0 /\\\n   transf_fundef f' = OK tf0) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2","hypotheses":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"intros (tf' & A & B).\nexploit parent_locset_match; eauto.\nintros PLS.\neconstructor; split.\napply plus_one.\neconstructor.\neauto.\nrewrite PLS.\neexact A.\nsymmetry; apply sig_preserved; auto.\ninv TRF; eauto.\ntraceEq.\nrewrite PLS.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf') : exists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2","hypotheses":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf')","proofString":"exploit parent_locset_match; eauto.\nintros PLS.\neconstructor; split.\napply plus_one.\neconstructor.\neauto.\nrewrite PLS.\neexact A.\nsymmetry; apply sig_preserved; auto.\ninv TRF; eauto.\ntraceEq.\nrewrite PLS.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf') : parent_locset ts = parent_locset s ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2.","conclusion":"parent_locset ts = parent_locset s ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2","hypotheses":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf')","proofString":"intros PLS.\neconstructor; split.\napply plus_one.\neconstructor.\neauto.\nrewrite PLS.\neexact A.\nsymmetry; apply sig_preserved; auto.\ninv TRF; eauto.\ntraceEq.\nrewrite PLS.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf') (PLS : parent_locset ts = parent_locset s) : exists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Ltailcall (funsig f') ros :: add_delta_ranges before after c') rs m)\n    E0 ts2 /\\\n  match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') ts2","hypotheses":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf') (PLS : parent_locset ts = parent_locset s)","proofString":"econstructor; split.\napply plus_one.\neconstructor.\neauto.\nrewrite PLS.\neexact A.\nsymmetry; apply sig_preserved; auto.\ninv TRF; eauto.\ntraceEq.\nrewrite PLS.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf') (PLS : parent_locset ts = parent_locset s) : match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n  (Callstate ts tf' (LTL.return_regs (parent_locset ts) rs) m').","conclusion":"match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n  (Callstate ts tf' (LTL.return_regs (parent_locset ts) rs) m')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf') (PLS : parent_locset ts = parent_locset s)","proofString":"rewrite PLS.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf') (PLS : parent_locset ts = parent_locset s) : match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n  (Callstate ts tf' (LTL.return_regs (parent_locset s) rs) m').","conclusion":"match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n  (Callstate ts tf' (LTL.return_regs (parent_locset s) rs) m')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (tf' : fundef) (A : find_function tge ros (LTL.return_regs (parent_locset s) rs) = Some tf') (B : transf_fundef f' = OK tf') (PLS : parent_locset ts = parent_locset s)","proofString":"constructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lbuiltin ef args res :: add_delta_ranges before after c') rs m) t ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp\n       (Lbuiltin ef args res :: add_delta_ranges before after c') rs m) t ts2 /\\\n  match_states\n    (State s f sp b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"econstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","conclusion":"forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id","hypotheses":"(s : list stackframe) (f : function) (sp : val) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list stackframe) (f : function) (sp : val) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"apply senv_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H2 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Llabel lbl :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (State s f sp b rs m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Llabel lbl :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (State s f sp b rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H2 : match_code b c')","proofString":"econstructor; split.\neapply plus_left.\nconstructor; auto.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (b' : code) (H : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lgoto lbl :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (State s f sp b' rs m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lgoto lbl :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (State s f sp b' rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (b' : code) (H : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"exploit find_label_match; eauto.\nintros (before' & after' & tc' & A & B).\neconstructor; split.\neapply plus_left.\nconstructor; eauto.\napply eval_add_delta_ranges; eauto.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (b' : code) (H : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : (exists (before0 after0 : option avail) (tc : code),\n   find_label lbl (fn_code tf) = Some (add_delta_ranges before0 after0 tc) /\\\n   match_code b' tc) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lgoto lbl :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (State s f sp b' rs m) ts2.","conclusion":"(exists (before0 after0 : option avail) (tc : code),\n   find_label lbl (fn_code tf) = Some (add_delta_ranges before0 after0 tc) /\\\n   match_code b' tc) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lgoto lbl :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (State s f sp b' rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (b' : code) (H : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"intros (before' & after' & tc' & A & B).\neconstructor; split.\neapply plus_left.\nconstructor; eauto.\napply eval_add_delta_ranges; eauto.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (b' : code) (H : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (before' after' : option avail) (tc' : code) (A : find_label lbl (fn_code tf) = Some (add_delta_ranges before' after' tc')) (B : match_code b' tc') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lgoto lbl :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (State s f sp b' rs m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lgoto lbl :: add_delta_ranges before after c') rs m) E0\n    ts2 /\\ match_states (State s f sp b' rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (b' : code) (H : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') (before' after' : option avail) (tc' : code) (A : find_label lbl (fn_code tf) = Some (add_delta_ranges before' after' tc')) (B : match_code b' tc')","proofString":"econstructor; split.\neapply plus_left.\nconstructor; eauto.\napply eval_add_delta_ranges; eauto.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lcond cond args lbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states\n    (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lcond cond args lbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states\n    (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"exploit find_label_match; eauto.\nintros (before' & after' & tc' & A & B).\neconstructor; split.\neapply plus_left.\neapply exec_Lcond_true; eauto.\napply eval_add_delta_ranges; eauto.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') : (exists (before0 after0 : option avail) (tc : code),\n   find_label lbl (fn_code tf) = Some (add_delta_ranges before0 after0 tc) /\\\n   match_code b' tc) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lcond cond args lbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states\n    (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m) ts2.","conclusion":"(exists (before0 after0 : option avail) (tc : code),\n   find_label lbl (fn_code tf) = Some (add_delta_ranges before0 after0 tc) /\\\n   match_code b' tc) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lcond cond args lbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states\n    (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c')","proofString":"intros (before' & after' & tc' & A & B).\neconstructor; split.\neapply plus_left.\neapply exec_Lcond_true; eauto.\napply eval_add_delta_ranges; eauto.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (before' after' : option avail) (tc' : code) (A : find_label lbl (fn_code tf) = Some (add_delta_ranges before' after' tc')) (B : match_code b' tc') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lcond cond args lbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states\n    (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lcond cond args lbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states\n    (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H4 : match_code b c') (before' after' : option avail) (tc' : code) (A : find_label lbl (fn_code tf) = Some (add_delta_ranges before' after' tc')) (B : match_code b' tc')","proofString":"econstructor; split.\neapply plus_left.\neapply exec_Lcond_true; eauto.\napply eval_add_delta_ranges; eauto.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (LTL.reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lcond cond args lbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states\n    (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Lcond cond args lbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states\n    (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (LTL.reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"econstructor; split.\neapply plus_left.\neapply exec_Lcond_false; auto.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H5 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Ljumptable arg tbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n    ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Ljumptable arg tbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n    ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H5 : match_code b c')","proofString":"exploit find_label_match; eauto.\nintros (before' & after' & tc' & A & B).\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\napply eval_add_delta_ranges.\nreflexivity.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H5 : match_code b c') : (exists (before0 after0 : option avail) (tc : code),\n   find_label lbl (fn_code tf) = Some (add_delta_ranges before0 after0 tc) /\\\n   match_code b' tc) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf sp (Ljumptable arg tbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n    ts2.","conclusion":"(exists (before0 after0 : option avail) (tc : code),\n   find_label lbl (fn_code tf) = Some (add_delta_ranges before0 after0 tc) /\\\n   match_code b' tc) ->\nexists ts2 : state,\n  plus step tge\n    (State ts tf sp (Ljumptable arg tbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n    ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H5 : match_code b c')","proofString":"intros (before' & after' & tc' & A & B).\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\napply eval_add_delta_ranges.\nreflexivity.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H5 : match_code b c') (before' after' : option avail) (tc' : code) (A : find_label lbl (fn_code tf) = Some (add_delta_ranges before' after' tc')) (B : match_code b' tc') : exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Ljumptable arg tbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n    ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf sp (Ljumptable arg tbl :: add_delta_ranges before after c')\n       rs m) E0 ts2 /\\\n  match_states (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n    ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H5 : match_code b c') (before' after' : option avail) (tc' : code) (A : find_label lbl (fn_code tf) = Some (add_delta_ranges before' after' tc')) (B : match_code b' tc')","proofString":"econstructor; split.\neapply plus_left.\neconstructor; eauto.\napply eval_add_delta_ranges.\nreflexivity.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H5 : match_code b c') (before' after' : option avail) (tc' : code) (A : find_label lbl (fn_code tf) = Some (add_delta_ranges before' after' tc')) (B : match_code b' tc') : match_states (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp tc' (LTL.undef_regs destroyed_by_jumptable rs) m).","conclusion":"match_states (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp tc' (LTL.undef_regs destroyed_by_jumptable rs) m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H5 : match_code b c') (before' after' : option avail) (tc' : code) (A : find_label lbl (fn_code tf) = Some (add_delta_ranges before' after' tc')) (B : match_code b' tc')","proofString":"constructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (b : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : exists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Lreturn :: add_delta_ranges before after c') rs m) E0 ts2 /\\\n  match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (State ts tf (Vptr stk Ptrofs.zero)\n       (Lreturn :: add_delta_ranges before after c') rs m) E0 ts2 /\\\n  match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m') ts2","hypotheses":"(s : list stackframe) (f : function) (stk : block) (b : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"econstructor; split.\napply plus_one.\nconstructor.\ninv TRF; eauto.\ntraceEq.\nrewrite (parent_locset_match _ _ STACKS).\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (b : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m')\n  (Returnstate ts (LTL.return_regs (parent_locset ts) rs) m').","conclusion":"match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m')\n  (Returnstate ts (LTL.return_regs (parent_locset ts) rs) m')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (b : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"rewrite (parent_locset_match _ _ STACKS).\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (b : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c') : match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m')\n  (Returnstate ts (LTL.return_regs (parent_locset s) rs) m').","conclusion":"match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m')\n  (Returnstate ts (LTL.return_regs (parent_locset s) rs) m')","hypotheses":"(s : list stackframe) (f : function) (stk : block) (b : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (TRF : match_function f tf) (before after : option avail) (c' : code) (H3 : match_code b c')","proofString":"constructor; auto."},{"statement":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (tf : fundef) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (H7 : transf_fundef (Internal f) = OK tf) : exists ts2 : state,\n  plus step tge (Callstate ts tf rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2.","conclusion":"exists ts2 : state,\n  plus step tge (Callstate ts tf rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2","hypotheses":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (tf : fundef) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (H7 : transf_fundef (Internal f) = OK tf)","proofString":"monadInv H7.\nrename x into tf.\nassert (MF: match_function f tf) by (apply transf_function_match; auto).\ninversion MF; subst.\neconstructor; split.\napply plus_one.\nconstructor.\nsimpl; eauto.\nreflexivity.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (x : function) (EQ : transf_function f = OK x) : exists ts2 : state,\n  plus step tge (Callstate ts (Internal x) rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2.","conclusion":"exists ts2 : state,\n  plus step tge (Callstate ts (Internal x) rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2","hypotheses":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (x : function) (EQ : transf_function f = OK x)","proofString":"rename x into tf.\nassert (MF: match_function f tf) by (apply transf_function_match; auto).\ninversion MF; subst.\neconstructor; split.\napply plus_one.\nconstructor.\nsimpl; eauto.\nreflexivity.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (tf : function) (EQ : transf_function f = OK tf) : exists ts2 : state,\n  plus step tge (Callstate ts (Internal tf) rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2.","conclusion":"exists ts2 : state,\n  plus step tge (Callstate ts (Internal tf) rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2","hypotheses":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (tf : function) (EQ : transf_function f = OK tf)","proofString":"assert (MF: match_function f tf) by (apply transf_function_match; auto).\ninversion MF; subst.\neconstructor; split.\napply plus_one.\nconstructor.\nsimpl; eauto.\nreflexivity.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (tf : function) (EQ : transf_function f = OK tf) (MF : match_function f tf) : exists ts2 : state,\n  plus step tge (Callstate ts (Internal tf) rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2.","conclusion":"exists ts2 : state,\n  plus step tge (Callstate ts (Internal tf) rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2","hypotheses":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (tf : function) (EQ : transf_function f = OK tf) (MF : match_function f tf)","proofString":"inversion MF; subst.\neconstructor; split.\napply plus_one.\nconstructor.\nsimpl; eauto.\nreflexivity.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (c : code) (MF : match_function f\n  {| fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c |}) (EQ : transf_function f =\nOK {| fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c |}) (H0 : match_code (fn_code f) c) : exists ts2 : state,\n  plus step tge\n    (Callstate ts\n       (Internal\n          {|\n            fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n          |}) rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (Callstate ts\n       (Internal\n          {|\n            fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c\n          |}) rs m) E0 ts2 /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n    ts2","hypotheses":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (c : code) (MF : match_function f\n  {| fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c |}) (EQ : transf_function f =\nOK {| fn_sig := fn_sig f; fn_stacksize := fn_stacksize f; fn_code := c |}) (H0 : match_code (fn_code f) c)","proofString":"econstructor; split.\napply plus_one.\nconstructor.\nsimpl; eauto.\nreflexivity.\nconstructor; auto."},{"statement":"(s : list stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t res m') (tf : fundef) (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) (H8 : transf_fundef (External ef) = OK tf) : exists ts2 : state,\n  plus step tge (Callstate ts tf rs1 m) t ts2 /\\\n  match_states\n    (Returnstate s\n       (Locmap.setpair (loc_result (ef_sig ef)) res\n          (LTL.undef_caller_save_regs rs1)) m') ts2.","conclusion":"exists ts2 : state,\n  plus step tge (Callstate ts tf rs1 m) t ts2 /\\\n  match_states\n    (Returnstate s\n       (Locmap.setpair (loc_result (ef_sig ef)) res\n          (LTL.undef_caller_save_regs rs1)) m') ts2","hypotheses":"(s : list stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t res m') (tf : fundef) (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) (H8 : transf_fundef (External ef) = OK tf)","proofString":"monadInv H8.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nconstructor; auto."},{"statement":"(s : list stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) : exists ts2 : state,\n  plus step tge (Callstate ts (External ef) rs1 m) t ts2 /\\\n  match_states\n    (Returnstate s\n       (Locmap.setpair (loc_result (ef_sig ef)) res\n          (LTL.undef_caller_save_regs rs1)) m') ts2.","conclusion":"exists ts2 : state,\n  plus step tge (Callstate ts (External ef) rs1 m) t ts2 /\\\n  match_states\n    (Returnstate s\n       (Locmap.setpair (loc_result (ef_sig ef)) res\n          (LTL.undef_caller_save_regs rs1)) m') ts2","hypotheses":"(s : list stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts)","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nconstructor; auto."},{"statement":"(s : list stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts)","proofString":"apply senv_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs0 : locset) (c : code) (rs : locset) (m : mem) (ts : list stackframe) (H3 : list_forall2 match_stackframes (Stackframe f sp rs0 c :: s) ts) : exists ts2 : state,\n  plus step tge (Returnstate ts rs m) E0 ts2 /\\\n  match_states (State s f sp c rs m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge (Returnstate ts rs m) E0 ts2 /\\\n  match_states (State s f sp c rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (rs0 : locset) (c : code) (rs : locset) (m : mem) (ts : list stackframe) (H3 : list_forall2 match_stackframes (Stackframe f sp rs0 c :: s) ts)","proofString":"inv H3.\ninv H1.\neconstructor; split.\neapply plus_left.\neconstructor.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs0 : locset) (c : code) (rs : locset) (m : mem) (b1 : stackframe) (bl : list stackframe) (H1 : match_stackframes (Stackframe f sp rs0 c) b1) (H4 : list_forall2 match_stackframes s bl) : exists ts2 : state,\n  plus step tge (Returnstate (b1 :: bl) rs m) E0 ts2 /\\\n  match_states (State s f sp c rs m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge (Returnstate (b1 :: bl) rs m) E0 ts2 /\\\n  match_states (State s f sp c rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (rs0 : locset) (c : code) (rs : locset) (m : mem) (b1 : stackframe) (bl : list stackframe) (H1 : match_stackframes (Stackframe f sp rs0 c) b1) (H4 : list_forall2 match_stackframes s bl)","proofString":"inv H1.\neconstructor; split.\neapply plus_left.\neconstructor.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs0 : locset) (c : code) (rs : locset) (m : mem) (bl : list stackframe) (H4 : list_forall2 match_stackframes s bl) (tf : function) (tc : code) (before after : option avail) (H6 : match_function f tf) (H7 : match_code c tc) : exists ts2 : state,\n  plus step tge\n    (Returnstate\n       (Stackframe tf sp rs0 (add_delta_ranges before after tc) :: bl) rs m)\n    E0 ts2 /\\ match_states (State s f sp c rs m) ts2.","conclusion":"exists ts2 : state,\n  plus step tge\n    (Returnstate\n       (Stackframe tf sp rs0 (add_delta_ranges before after tc) :: bl) rs m)\n    E0 ts2 /\\ match_states (State s f sp c rs m) ts2","hypotheses":"(s : list stackframe) (f : function) (sp : val) (rs0 : locset) (c : code) (rs : locset) (m : mem) (bl : list stackframe) (H4 : list_forall2 match_stackframes s bl) (tf : function) (tc : code) (before after : option avail) (H6 : match_function f tf) (H7 : match_code c tc)","proofString":"econstructor; split.\neapply plus_left.\neconstructor.\napply eval_add_delta_ranges.\ntraceEq.\nconstructor; auto."},{"statement":"(st1 : state) (H : initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","conclusion":"exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2","hypotheses":"(st1 : state) (H : initial_state prog st1)","proofString":"inversion H.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists (Callstate nil tf (Locmap.init Vundef) m0); split.\neconstructor; eauto.\neapply (Genv.init_mem_transf_partial TRANSF); eauto.\nrewrite (match_program_main TRANSF), symbols_preserved.\nauto.\nrewrite <- H3.\napply sig_preserved.\nauto.\nconstructor.\nconstructor.\nauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : Genv.init_mem tprog = Some m0.","conclusion":"Genv.init_mem tprog = Some m0","hypotheses":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"eapply (Genv.init_mem_transf_partial TRANSF); eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : funsig tf = signature_main.","conclusion":"funsig tf = signature_main","hypotheses":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"rewrite <- H3.\napply sig_preserved.\nauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : funsig tf = funsig f.","conclusion":"funsig tf = funsig f","hypotheses":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"apply sig_preserved.\nauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : transf_fundef f = OK tf.","conclusion":"transf_fundef f = OK tf","hypotheses":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"auto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : match_states (Callstate nil f (Locmap.init Vundef) m0)\n  (Callstate nil tf (Locmap.init Vundef) m0).","conclusion":"match_states (Callstate nil f (Locmap.init Vundef) m0)\n  (Callstate nil tf (Locmap.init Vundef) m0)","hypotheses":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"constructor.\nconstructor.\nauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : list_forall2 match_stackframes nil nil.","conclusion":"list_forall2 match_stackframes nil nil","hypotheses":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"constructor."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : transf_fundef f = OK tf.","conclusion":"transf_fundef f = OK tf","hypotheses":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"auto."},{"statement":"(st1 st2 : state) (r : int) (H : match_states st1 st2) (H0 : final_state st1 r) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st1 st2 : state) (r : int) (H : match_states st1 st2) (H0 : final_state st1 r)","proofString":"inv H0.\ninv H.\ninv H5.\neconstructor; eauto."},{"statement":"(st2 : state) (r : int) (rs : Locmap.t) (m : mem) (H : match_states (Returnstate nil rs m) st2) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st2 : state) (r : int) (rs : Locmap.t) (m : mem) (H : match_states (Returnstate nil rs m) st2) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r)","proofString":"inv H.\ninv H5.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (ts : list stackframe) (H5 : list_forall2 match_stackframes nil ts) : final_state (Returnstate ts rs m) r.","conclusion":"final_state (Returnstate ts rs m) r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (ts : list stackframe) (H5 : list_forall2 match_stackframes nil ts)","proofString":"inv H5.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) : final_state (Returnstate nil rs m) r.","conclusion":"final_state (Returnstate nil rs m) r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r)","proofString":"econstructor; eauto."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id","hypotheses":"","proofString":"apply senv_preserved."}]}