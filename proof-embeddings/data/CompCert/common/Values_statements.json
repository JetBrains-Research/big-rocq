{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Values.v","fileSamples":[{"statement":"(x y : val) (i i0 : int) : {i = i0} + {i <> i0}.","proofString":"apply Int.eq_dec."},{"statement":"(x y : val) (i i0 : int64) : {i = i0} + {i <> i0}.","proofString":"apply Int64.eq_dec."},{"statement":"(x y : val) (f f0 : float) : {f = f0} + {f <> f0}.","proofString":"apply Float.eq_dec."},{"statement":"(x y : val) (f f0 : float32) : {f = f0} + {f <> f0}.","proofString":"apply Float32.eq_dec."},{"statement":"(x y : val) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (a : b = b0) : {i = i0} + {i <> i0}.","proofString":"apply Ptrofs.eq_dec."},{"statement":"(x y : val) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) : {b = b0} + {b <> b0}.","proofString":"apply eq_block."},{"statement":"(b : block) (ofs : ptrofs) : has_type (Vptr b ofs) Tptr.","proofString":"unfold Tptr, has_type; destruct Archi.ptr64; reflexivity."},{"statement":"(ty1 ty2 : typ) (v : val) (H : subtype ty1 ty2 = true) (H0 : has_type v ty1) : has_type v ty2.","proofString":"destruct ty1; destruct ty2; simpl in H;  (contradiction || discriminate || assumption || idtac);  unfold has_type in *; destruct v; auto; contradiction."},{"statement":"(H : subtype_list nil nil = true) (H0 : has_type_list nil nil) : has_type_list nil nil.","proofString":"red; auto."},{"statement":"(a : typ) (tyl1 : list typ) (IHtyl1 : forall (tyl0 : list typ) (vl0 : list val),\nsubtype_list tyl1 tyl0 = true ->\nhas_type_list vl0 tyl1 -> has_type_list vl0 tyl0) (t : typ) (tyl2 : list typ) (v : val) (vl : list val) (H : subtype_list (a :: tyl1) (t :: tyl2) = true) (H0 : has_type_list (v :: vl) (a :: tyl1)) : has_type_list (v :: vl) (t :: tyl2).","proofString":"simpl in *.\nInvBooleans.\ndestruct H0.\nsplit; auto.\neapply has_subtype; eauto."},{"statement":"(a : typ) (tyl1 : list typ) (IHtyl1 : forall (tyl0 : list typ) (vl0 : list val),\nsubtype_list tyl1 tyl0 = true ->\nhas_type_list vl0 tyl1 -> has_type_list vl0 tyl0) (t : typ) (tyl2 : list typ) (v : val) (vl : list val) (H : subtype a t && subtype_list tyl1 tyl2 = true) (H0 : has_type v a /\\ has_type_list vl tyl1) : has_type v t /\\ has_type_list vl tyl2.","proofString":"InvBooleans.\ndestruct H0.\nsplit; auto.\neapply has_subtype; eauto."},{"statement":"(a : typ) (tyl1 : list typ) (IHtyl1 : forall (tyl0 : list typ) (vl0 : list val),\nsubtype_list tyl1 tyl0 = true ->\nhas_type_list vl0 tyl1 -> has_type_list vl0 tyl0) (t : typ) (tyl2 : list typ) (v : val) (vl : list val) (H0 : has_type v a /\\ has_type_list vl tyl1) (H1 : subtype a t = true) (H2 : subtype_list tyl1 tyl2 = true) : has_type v t /\\ has_type_list vl tyl2.","proofString":"destruct H0.\nsplit; auto.\neapply has_subtype; eauto."},{"statement":"(a : typ) (tyl1 : list typ) (IHtyl1 : forall (tyl0 : list typ) (vl0 : list val),\nsubtype_list tyl1 tyl0 = true ->\nhas_type_list vl0 tyl1 -> has_type_list vl0 tyl0) (t : typ) (tyl2 : list typ) (v : val) (vl : list val) (H : has_type v a) (H0 : has_type_list vl tyl1) (H1 : subtype a t = true) (H2 : subtype_list tyl1 tyl2 = true) : has_type v t /\\ has_type_list vl tyl2.","proofString":"split; auto.\neapply has_subtype; eauto."},{"statement":"(a : typ) (tyl1 : list typ) (IHtyl1 : forall (tyl0 : list typ) (vl0 : list val),\nsubtype_list tyl1 tyl0 = true ->\nhas_type_list vl0 tyl1 -> has_type_list vl0 tyl0) (t : typ) (tyl2 : list typ) (v : val) (vl : list val) (H : has_type v a) (H0 : has_type_list vl tyl1) (H1 : subtype a t = true) (H2 : subtype_list tyl1 tyl2 = true) : has_type v t.","proofString":"eapply has_subtype; eauto."},{"statement":"(t : typ) : {True} + {~ True}.","proofString":"auto."},{"statement":"(i : int) (t : typ) : {match t with\n | Tfloat | Tlong | Tsingle => False\n | _ => True\n end} + {~ match t with\n           | Tfloat | Tlong | Tsingle => False\n           | _ => True\n           end}.","proofString":"destruct t; auto."},{"statement":"(i : int64) (t : typ) : {match t with\n | Tlong | Tany64 => True\n | _ => False\n end} + {~ match t with\n           | Tlong | Tany64 => True\n           | _ => False\n           end}.","proofString":"destruct t; auto."},{"statement":"(f : float) (t : typ) : {match t with\n | Tfloat | Tany64 => True\n | _ => False\n end} + {~ match t with\n           | Tfloat | Tany64 => True\n           | _ => False\n           end}.","proofString":"destruct t; auto."},{"statement":"(f : float32) (t : typ) : {match t with\n | Tint | Tfloat | Tlong => False\n | _ => True\n end} + {~ match t with\n           | Tint | Tfloat | Tlong => False\n           | _ => True\n           end}.","proofString":"destruct t; auto."},{"statement":"(b : block) (i : ptrofs) (t : typ) : {match t with\n | Tlong => Archi.ptr64 = true\n | Tfloat | Tsingle => False\n | Tany64 => True\n | _ => Archi.ptr64 = false\n end} +\n{~\n match t with\n | Tlong => Archi.ptr64 = true\n | Tfloat | Tsingle => False\n | Tany64 => True\n | _ => Archi.ptr64 = false\n end}.","proofString":"destruct t.\napply bool_dec.\nauto.\napply bool_dec.\nauto.\napply bool_dec.\nauto."},{"statement":"(b : block) (i : ptrofs) : {Archi.ptr64 = false} + {Archi.ptr64 <> false}.","proofString":"apply bool_dec."},{"statement":"(b : block) (i : ptrofs) : {False} + {~ False}.","proofString":"auto."},{"statement":"(b : block) (i : ptrofs) : {Archi.ptr64 = true} + {Archi.ptr64 <> true}.","proofString":"apply bool_dec."},{"statement":"(b : block) (i : ptrofs) : {False} + {~ False}.","proofString":"auto."},{"statement":"(b : block) (i : ptrofs) : {Archi.ptr64 = false} + {Archi.ptr64 <> false}.","proofString":"apply bool_dec."},{"statement":"(b : block) (i : ptrofs) : {True} + {~ True}.","proofString":"auto."},{"statement":"(v : val) (t : xtype) (H : has_rettype v t) : has_type v (proj_xtype t).","proofString":"destruct t, v; simpl in *; auto; try contradiction.\nunfold Tptr; rewrite H; auto.\nunfold Tptr; rewrite H; auto.\nunfold Tptr; destruct Archi.ptr64; auto."},{"statement":"(i : int) (H : Archi.ptr64 = false) : match Tptr with\n| Tfloat | Tlong | Tsingle => False\n| _ => True\nend.","proofString":"unfold Tptr; rewrite H; auto."},{"statement":"(i : int64) (H : Archi.ptr64 = true) : match Tptr with\n| Tlong | Tany64 => True\n| _ => False\nend.","proofString":"unfold Tptr; rewrite H; auto."},{"statement":"(b : block) (i : ptrofs) (H : True) : match Tptr with\n| Tlong => Archi.ptr64 = true\n| Tfloat | Tsingle => False\n| Tany64 => True\n| _ => Archi.ptr64 = false\nend.","proofString":"unfold Tptr; destruct Archi.ptr64; auto."},{"statement":"(v : val) (t : typ) (H : has_type v t) : has_rettype v (inj_type t).","proofString":"destruct v, t; simpl in *; auto."},{"statement":"(i m : int64) : Vlong (Int64.rolm i (Int64.repr (Int.unsigned Int.zero)) m) =\nVlong (Int64.and i m).","proofString":"decEq.\napply Int64.rolm_zero."},{"statement":"(i m : int64) : Int64.rolm i (Int64.repr (Int.unsigned Int.zero)) m = Int64.and i m.","proofString":"apply Int64.rolm_zero."},{"statement":"(ty : typ) : True.","proofString":"auto."},{"statement":"(i : int) (ty : typ) : has_type match ty with\n         | Tfloat | Tlong | Tsingle => Vundef\n         | _ => Vint i\n         end ty.","proofString":"destruct ty; exact I."},{"statement":"(i : int64) (ty : typ) : has_type match ty with\n         | Tlong | Tany64 => Vlong i\n         | _ => Vundef\n         end ty.","proofString":"destruct ty; exact I."},{"statement":"(f : float) (ty : typ) : has_type match ty with\n         | Tfloat | Tany64 => Vfloat f\n         | _ => Vundef\n         end ty.","proofString":"destruct ty; exact I."},{"statement":"(f : float32) (ty : typ) : has_type match ty with\n         | Tint | Tfloat | Tlong => Vundef\n         | _ => Vsingle f\n         end ty.","proofString":"destruct ty; exact I."},{"statement":"(b : block) (i : ptrofs) (ty : typ) : has_type\n  match ty with\n  | Tlong => if Archi.ptr64 then Vptr b i else Vundef\n  | Tfloat | Tsingle => Vundef\n  | Tany64 => Vptr b i\n  | _ => if Archi.ptr64 then Vundef else Vptr b i\n  end ty.","proofString":"unfold has_type; destruct ty, Archi.ptr64; auto."},{"statement":"(v : val) (ty : typ) (H : match v with\n| Vundef => True\n| Vint _ => match ty with\n            | Tfloat | Tlong | Tsingle => False\n            | _ => True\n            end\n| Vlong _ => match ty with\n             | Tlong | Tany64 => True\n             | _ => False\n             end\n| Vfloat _ => match ty with\n              | Tfloat | Tany64 => True\n              | _ => False\n              end\n| Vsingle _ => match ty with\n               | Tint | Tfloat | Tlong => False\n               | _ => True\n               end\n| Vptr _ _ =>\n    match ty with\n    | Tlong => Archi.ptr64 = true\n    | Tfloat | Tsingle => False\n    | Tany64 => True\n    | _ => Archi.ptr64 = false\n    end\nend) : match v with\n| Vundef => Vundef\n| Vint _ => match ty with\n            | Tfloat | Tlong | Tsingle => Vundef\n            | _ => v\n            end\n| Vlong _ => match ty with\n             | Tlong | Tany64 => v\n             | _ => Vundef\n             end\n| Vfloat _ => match ty with\n              | Tfloat | Tany64 => v\n              | _ => Vundef\n              end\n| Vsingle _ => match ty with\n               | Tint | Tfloat | Tlong => Vundef\n               | _ => v\n               end\n| Vptr _ _ =>\n    match ty with\n    | Tlong => if Archi.ptr64 then v else Vundef\n    | Tfloat | Tsingle => Vundef\n    | Tany64 => v\n    | _ => if Archi.ptr64 then Vundef else v\n    end\nend = v.","proofString":"destruct v.\nauto.\ndestruct ty; intuition auto.\ndestruct ty; intuition auto.\ndestruct ty; intuition auto.\ndestruct ty; intuition auto.\ndestruct ty, Archi.ptr64; intuition congruence."},{"statement":"(ty : typ) (H : True) : Vundef = Vundef.","proofString":"auto."},{"statement":"(i : int) (ty : typ) (H : match ty with\n| Tfloat | Tlong | Tsingle => False\n| _ => True\nend) : match ty with\n| Tfloat | Tlong | Tsingle => Vundef\n| _ => Vint i\nend = Vint i.","proofString":"destruct ty; intuition auto."},{"statement":"(i : int64) (ty : typ) (H : match ty with\n| Tlong | Tany64 => True\n| _ => False\nend) : match ty with\n| Tlong | Tany64 => Vlong i\n| _ => Vundef\nend = Vlong i.","proofString":"destruct ty; intuition auto."},{"statement":"(f : float) (ty : typ) (H : match ty with\n| Tfloat | Tany64 => True\n| _ => False\nend) : match ty with\n| Tfloat | Tany64 => Vfloat f\n| _ => Vundef\nend = Vfloat f.","proofString":"destruct ty; intuition auto."},{"statement":"(f : float32) (ty : typ) (H : match ty with\n| Tint | Tfloat | Tlong => False\n| _ => True\nend) : match ty with\n| Tint | Tfloat | Tlong => Vundef\n| _ => Vsingle f\nend = Vsingle f.","proofString":"destruct ty; intuition auto."},{"statement":"(b : block) (i : ptrofs) (ty : typ) (H : match ty with\n| Tlong => Archi.ptr64 = true\n| Tfloat | Tsingle => False\n| Tany64 => True\n| _ => Archi.ptr64 = false\nend) : match ty with\n| Tlong => if Archi.ptr64 then Vptr b i else Vundef\n| Tfloat | Tsingle => Vundef\n| Tany64 => Vptr b i\n| _ => if Archi.ptr64 then Vundef else Vptr b i\nend = Vptr b i.","proofString":"destruct ty, Archi.ptr64; intuition congruence."},{"statement":"(v : val) : norm_bool v = Vundef \\/ norm_bool v = Vfalse \\/ norm_bool v = Vtrue.","proofString":"unfold norm_bool, is_bool.\ndestruct (eq v Vtrue); auto.\ndestruct (eq v Vfalse); auto."},{"statement":"(v : val) : (if eq v Vtrue || eq v Vfalse then v else Vundef) = Vundef \\/\n(if eq v Vtrue || eq v Vfalse then v else Vundef) = Vfalse \\/\n(if eq v Vtrue || eq v Vfalse then v else Vundef) = Vtrue.","proofString":"destruct (eq v Vtrue); auto.\ndestruct (eq v Vfalse); auto."},{"statement":"(chunk : memory_chunk) (v : val) : has_rettype (load_result chunk v) (xtype_of_chunk chunk).","proofString":"unfold has_rettype; destruct chunk; destruct v; simpl; auto.\ndestruct (norm_bool_cases (Vint (Int.zero_ext 8 i))) as [A | [A | A]]; rewrite A; simpl; auto.\nrewrite Int.sign_ext_idem by lia; auto.\nrewrite Int.zero_ext_idem by lia; auto.\nrewrite Int.sign_ext_idem by lia; auto.\nrewrite Int.zero_ext_idem by lia; auto.\ndestruct Archi.ptr64 eqn:SF; simpl; auto.\ndestruct Archi.ptr64 eqn:SF; simpl; auto.\ndestruct Archi.ptr64 eqn:SF; simpl; auto."},{"statement":"(i : int) : match norm_bool (Vint (Int.zero_ext 8 i)) with\n| Vundef => True\n| Vint n => n = Int.zero \\/ n = Int.one\n| _ => False\nend.","proofString":"destruct (norm_bool_cases (Vint (Int.zero_ext 8 i))) as [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(i : int) : Int.sign_ext 8 i = Int.sign_ext 8 (Int.sign_ext 8 i).","proofString":"rewrite Int.sign_ext_idem by lia; auto."},{"statement":"(i : int) : Int.zero_ext 8 i = Int.zero_ext 8 (Int.zero_ext 8 i).","proofString":"rewrite Int.zero_ext_idem by lia; auto."},{"statement":"(i : int) : Int.sign_ext 16 i = Int.sign_ext 16 (Int.sign_ext 16 i).","proofString":"rewrite Int.sign_ext_idem by lia; auto."},{"statement":"(i : int) : Int.zero_ext 16 i = Int.zero_ext 16 (Int.zero_ext 16 i).","proofString":"rewrite Int.zero_ext_idem by lia; auto."},{"statement":"(b : block) (i : ptrofs) : match (if Archi.ptr64 then Vundef else Vptr b i) with\n| Vundef | Vint _ => True\n| Vptr _ _ => Archi.ptr64 = false\n| _ => False\nend.","proofString":"destruct Archi.ptr64 eqn:SF; simpl; auto."},{"statement":"(b : block) (i : ptrofs) : match (if Archi.ptr64 then Vptr b i else Vundef) with\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend.","proofString":"destruct Archi.ptr64 eqn:SF; simpl; auto."},{"statement":"(b : block) (i : ptrofs) : match (if Archi.ptr64 then Vundef else Vptr b i) with\n| Vlong _ | Vfloat _ => False\n| Vptr _ _ => Archi.ptr64 = false\n| _ => True\nend.","proofString":"destruct Archi.ptr64 eqn:SF; simpl; auto."},{"statement":"(chunk : memory_chunk) (v : val) : has_type (load_result chunk v) (type_of_chunk chunk).","proofString":"rewrite <-proj_xtype_of_chunk.\napply has_proj_xtype.\napply load_result_xtype."},{"statement":"(chunk : memory_chunk) (v : val) : has_type (load_result chunk v) (proj_xtype (xtype_of_chunk chunk)).","proofString":"apply has_proj_xtype.\napply load_result_xtype."},{"statement":"(chunk : memory_chunk) (v : val) : has_rettype (load_result chunk v) (xtype_of_chunk chunk).","proofString":"apply load_result_xtype."},{"statement":"(v : val) (ty : typ) (H : match v with\n| Vundef => True\n| Vint _ => match ty with\n            | Tfloat | Tlong | Tsingle => False\n            | _ => True\n            end\n| Vlong _ => match ty with\n             | Tlong | Tany64 => True\n             | _ => False\n             end\n| Vfloat _ => match ty with\n              | Tfloat | Tany64 => True\n              | _ => False\n              end\n| Vsingle _ => match ty with\n               | Tint | Tfloat | Tlong => False\n               | _ => True\n               end\n| Vptr _ _ =>\n    match ty with\n    | Tlong => Archi.ptr64 = true\n    | Tfloat | Tsingle => False\n    | Tany64 => True\n    | _ => Archi.ptr64 = false\n    end\nend) : match chunk_of_type ty with\n| Mbool =>\n    match v with\n    | Vint n => norm_bool (Vint (Int.zero_ext 8 n))\n    | _ => Vundef\n    end\n| Mint8signed =>\n    match v with\n    | Vint n => Vint (Int.sign_ext 8 n)\n    | _ => Vundef\n    end\n| Mint8unsigned =>\n    match v with\n    | Vint n => Vint (Int.zero_ext 8 n)\n    | _ => Vundef\n    end\n| Mint16signed =>\n    match v with\n    | Vint n => Vint (Int.sign_ext 16 n)\n    | _ => Vundef\n    end\n| Mint16unsigned =>\n    match v with\n    | Vint n => Vint (Int.zero_ext 16 n)\n    | _ => Vundef\n    end\n| Mint32 =>\n    match v with\n    | Vint n => Vint n\n    | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n    | _ => Vundef\n    end\n| Mint64 =>\n    match v with\n    | Vlong n => Vlong n\n    | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n    | _ => Vundef\n    end\n| Mfloat32 => match v with\n              | Vsingle f => Vsingle f\n              | _ => Vundef\n              end\n| Mfloat64 => match v with\n              | Vfloat f => Vfloat f\n              | _ => Vundef\n              end\n| Many32 =>\n    match v with\n    | Vint _ | Vsingle _ => v\n    | Vptr _ _ => if Archi.ptr64 then Vundef else v\n    | _ => Vundef\n    end\n| Many64 => v\nend = v.","proofString":"destruct v; destruct ty; destruct Archi.ptr64; try contradiction; try discriminate; auto."},{"statement":"(i : int) : Vint (Int.zero_ext 8 i) = Vint (Int.and i (Int.repr 255)).","proofString":"decEq.\nchange 255 with (two_p 8 - 1).\napply Int.zero_ext_and.\nlia."},{"statement":"(i : int) : Int.zero_ext 8 i = Int.and i (Int.repr 255).","proofString":"change 255 with (two_p 8 - 1).\napply Int.zero_ext_and.\nlia."},{"statement":"(i : int) : Int.zero_ext 8 i = Int.and i (Int.repr (two_p 8 - 1)).","proofString":"apply Int.zero_ext_and.\nlia."},{"statement":"(i : int) : 0 <= 8.","proofString":"lia."},{"statement":"(i : int) : Vint (Int.zero_ext 16 i) = Vint (Int.and i (Int.repr 65535)).","proofString":"decEq.\nchange 65535 with (two_p 16 - 1).\napply Int.zero_ext_and.\nlia."},{"statement":"(i : int) : Int.zero_ext 16 i = Int.and i (Int.repr 65535).","proofString":"change 65535 with (two_p 16 - 1).\napply Int.zero_ext_and.\nlia."},{"statement":"(i : int) : Int.zero_ext 16 i = Int.and i (Int.repr (two_p 16 - 1)).","proofString":"apply Int.zero_ext_and.\nlia."},{"statement":"(i : int) : 0 <= 16.","proofString":"lia."},{"statement":"(b1 b2 : bool) (H : bool_of_val (of_bool b1) b2) : b1 = b2.","proofString":"destruct b1; simpl in H; inv H; auto."},{"statement":"(ob : option bool) (b : bool) (H : bool_of_val (of_optbool ob) b) : ob = Some b.","proofString":"destruct ob; simpl in H.\ndestruct b0; simpl in H; inv H; auto.\ninv H."},{"statement":"(b0 b : bool) (H : bool_of_val (if b0 then Vtrue else Vfalse) b) : Some b0 = Some b.","proofString":"destruct b0; simpl in H; inv H; auto."},{"statement":"(b : bool) (H : bool_of_val Vundef b) : None = Some b.","proofString":"inv H."},{"statement":"(v : val) : (if is_bool (if is_bool v then v else Vundef)\n then if is_bool v then v else Vundef\n else Vundef) = (if is_bool v then v else Vundef).","proofString":"destruct (is_bool v) eqn:E; auto.\nrewrite E; auto."},{"statement":"(v : val) (E : is_bool v = true) : (if is_bool v then v else Vundef) = v.","proofString":"rewrite E; auto."},{"statement":"(b : bool) : of_optbool (option_map negb (Some b)) = notbool (of_optbool (Some b)).","proofString":"destruct b; auto."},{"statement":"(i : int) : notbool (notbool (of_bool (Int.eq i Int.zero))) = of_bool (Int.eq i Int.zero).","proofString":"case (Int.eq i Int.zero); reflexivity."},{"statement":"(b : bool) : notbool (notbool (of_optbool (Some b))) = of_optbool (Some b).","proofString":"destruct b; auto."},{"statement":"(i i0 : int) : Vint (Int.add i i0) = Vint (Int.add i0 i).","proofString":"decEq.\napply Int.add_commut."},{"statement":"(i i0 : int) : Int.add i i0 = Int.add i0 i.","proofString":"apply Int.add_commut."},{"statement":"(i i0 i1 : int) (SF : Archi.ptr64 = true) : Vint (Int.add (Int.add i i0) i1) = Vint (Int.add i (Int.add i0 i1)).","proofString":"rewrite Int.add_assoc; auto."},{"statement":"(i i0 i1 : int) (SF : Archi.ptr64 = false) : Vint (Int.add (Int.add i i0) i1) = Vint (Int.add i (Int.add i0 i1)).","proofString":"rewrite Int.add_assoc; auto."},{"statement":"(i i0 : int) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.add i1 (Ptrofs.of_int (Int.add i i0))) =\nVptr b (Ptrofs.add (Ptrofs.add i1 (Ptrofs.of_int i0)) (Ptrofs.of_int i)).","proofString":"rewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(i i0 : int) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.add i1 (Ptrofs.of_int (Int.add i i0))) =\nVptr b (Ptrofs.add i1 (Ptrofs.add (Ptrofs.of_int i0) (Ptrofs.of_int i))).","proofString":"f_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(i i0 : int) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = false) : Ptrofs.add i1 (Ptrofs.of_int (Int.add i i0)) =\nPtrofs.add i1 (Ptrofs.add (Ptrofs.of_int i0) (Ptrofs.of_int i)).","proofString":"f_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(i i0 : int) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = false) : Ptrofs.of_int (Int.add i i0) =\nPtrofs.add (Ptrofs.of_int i0) (Ptrofs.of_int i).","proofString":"rewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(i i0 : int) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = false) : Ptrofs.of_int (Int.add i i0) =\nPtrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i0).","proofString":"auto with ptrofs."},{"statement":"(i : int) (b : block) (i0 : ptrofs) (i1 : int) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.add (Ptrofs.add i0 (Ptrofs.of_int i)) (Ptrofs.of_int i1)) =\nVptr b (Ptrofs.add (Ptrofs.add i0 (Ptrofs.of_int i1)) (Ptrofs.of_int i)).","proofString":"rewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\napply Ptrofs.add_commut."},{"statement":"(i : int) (b : block) (i0 : ptrofs) (i1 : int) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.add i0 (Ptrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i1))) =\nVptr b (Ptrofs.add i0 (Ptrofs.add (Ptrofs.of_int i1) (Ptrofs.of_int i))).","proofString":"f_equal.\nf_equal.\napply Ptrofs.add_commut."},{"statement":"(i : int) (b : block) (i0 : ptrofs) (i1 : int) (SF : Archi.ptr64 = false) : Ptrofs.add i0 (Ptrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i1)) =\nPtrofs.add i0 (Ptrofs.add (Ptrofs.of_int i1) (Ptrofs.of_int i)).","proofString":"f_equal.\napply Ptrofs.add_commut."},{"statement":"(i : int) (b : block) (i0 : ptrofs) (i1 : int) (SF : Archi.ptr64 = false) : Ptrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i1) =\nPtrofs.add (Ptrofs.of_int i1) (Ptrofs.of_int i).","proofString":"apply Ptrofs.add_commut."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.add (Ptrofs.add i (Ptrofs.of_int i0)) (Ptrofs.of_int i1)) =\nVptr b (Ptrofs.add i (Ptrofs.of_int (Int.add i0 i1))).","proofString":"rewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int i0) (Ptrofs.of_int i1))) =\nVptr b (Ptrofs.add i (Ptrofs.of_int (Int.add i0 i1))).","proofString":"f_equal.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int) (SF : Archi.ptr64 = false) : Ptrofs.add i (Ptrofs.add (Ptrofs.of_int i0) (Ptrofs.of_int i1)) =\nPtrofs.add i (Ptrofs.of_int (Int.add i0 i1)).","proofString":"f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int) (SF : Archi.ptr64 = false) : Ptrofs.add (Ptrofs.of_int i0) (Ptrofs.of_int i1) =\nPtrofs.of_int (Int.add i0 i1).","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int) (SF : Archi.ptr64 = false) : Ptrofs.of_int (Int.add i0 i1) =\nPtrofs.add (Ptrofs.of_int i0) (Ptrofs.of_int i1).","proofString":"auto with ptrofs."},{"statement":"(x y z : val) : add x (add y z) = add y (add x z).","proofString":"rewrite (add_commut y z).\nrewrite <- add_assoc.\napply add_commut."},{"statement":"(x y z : val) : add x (add z y) = add y (add x z).","proofString":"rewrite <- add_assoc.\napply add_commut."},{"statement":"(x y z : val) : add (add x z) y = add y (add x z).","proofString":"apply add_commut."},{"statement":"(x y z t : val) : add (add x y) (add z t) = add (add x z) (add y t).","proofString":"rewrite add_permut.\nrewrite add_assoc.\nrewrite add_permut.\nsymmetry.\napply add_assoc."},{"statement":"(x y z t : val) : add z (add (add x y) t) = add (add x z) (add y t).","proofString":"rewrite add_assoc.\nrewrite add_permut.\nsymmetry.\napply add_assoc."},{"statement":"(x y z t : val) : add z (add x (add y t)) = add (add x z) (add y t).","proofString":"rewrite add_permut.\nsymmetry.\napply add_assoc."},{"statement":"(x y z t : val) : add x (add z (add y t)) = add (add x z) (add y t).","proofString":"symmetry.\napply add_assoc."},{"statement":"(x y z t : val) : add (add x z) (add y t) = add x (add z (add y t)).","proofString":"apply add_assoc."},{"statement":"(i y : int) (SF : Archi.ptr64 = true) : Vint (Int.sub i y) = Vint (Int.add i (Int.neg y)).","proofString":"rewrite Int.sub_add_opp; auto."},{"statement":"(i y : int) (SF : Archi.ptr64 = false) : Vint (Int.sub i y) = Vint (Int.add i (Int.neg y)).","proofString":"rewrite Int.sub_add_opp; auto."},{"statement":"(b : block) (i : ptrofs) (y : int) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.sub i (Ptrofs.of_int y)) =\nVptr b (Ptrofs.add i (Ptrofs.of_int (Int.neg y))).","proofString":"rewrite Ptrofs.sub_add_opp.\nf_equal.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (y : int) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.add i (Ptrofs.neg (Ptrofs.of_int y))) =\nVptr b (Ptrofs.add i (Ptrofs.of_int (Int.neg y))).","proofString":"f_equal.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (y : int) (SF : Archi.ptr64 = false) : Ptrofs.add i (Ptrofs.neg (Ptrofs.of_int y)) =\nPtrofs.add i (Ptrofs.of_int (Int.neg y)).","proofString":"f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (y : int) (SF : Archi.ptr64 = false) : Ptrofs.neg (Ptrofs.of_int y) = Ptrofs.of_int (Int.neg y).","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (y : int) (SF : Archi.ptr64 = false) : Ptrofs.of_int (Int.neg y) = Ptrofs.neg (Ptrofs.of_int y).","proofString":"auto with ptrofs."},{"statement":"(x : val) (y : int) : sub x (Vint (Int.neg y)) = add x (Vint y).","proofString":"rewrite sub_add_opp.\nrewrite Int.neg_involutive.\nauto."},{"statement":"(x : val) (y : int) : add x (Vint (Int.neg (Int.neg y))) = add x (Vint y).","proofString":"rewrite Int.neg_involutive.\nauto."},{"statement":"(x : val) (y : int) : add x (Vint y) = add x (Vint y).","proofString":"auto."},{"statement":"(i0 i1 i : int) (SF : Archi.ptr64 = true) : Vint (Int.sub (Int.add i0 i) i1) = Vint (Int.add (Int.sub i0 i1) i).","proofString":"rewrite Int.sub_add_l; auto."},{"statement":"(i0 i1 i : int) (SF : Archi.ptr64 = false) : Vint (Int.sub (Int.add i0 i) i1) = Vint (Int.add (Int.sub i0 i1) i).","proofString":"rewrite Int.sub_add_l; auto."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.sub (Ptrofs.add i0 (Ptrofs.of_int i)) (Ptrofs.of_int i1)) =\nVptr b (Ptrofs.add (Ptrofs.sub i0 (Ptrofs.of_int i1)) (Ptrofs.of_int i)).","proofString":"rewrite Ptrofs.sub_add_l; auto."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int) (SF : Archi.ptr64 = false) : (if eq_block b b0\n then Vint (Ptrofs.to_int (Ptrofs.sub (Ptrofs.add i0 (Ptrofs.of_int i)) i1))\n else Vundef) =\nmatch\n  (if eq_block b b0 then Vint (Ptrofs.to_int (Ptrofs.sub i0 i1)) else Vundef)\nwith\n| Vint n1 => Vint (Int.add n1 i)\n| Vptr b1 ofs1 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int i))\n| _ => Vundef\nend.","proofString":"destruct (eq_block b b0); auto.\nf_equal.\nrewrite Ptrofs.sub_add_l.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int) (SF : Archi.ptr64 = false) (e : b = b0) : Vint (Ptrofs.to_int (Ptrofs.sub (Ptrofs.add i0 (Ptrofs.of_int i)) i1)) =\nVint (Int.add (Ptrofs.to_int (Ptrofs.sub i0 i1)) i).","proofString":"f_equal.\nrewrite Ptrofs.sub_add_l.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int) (SF : Archi.ptr64 = false) (e : b = b0) : Ptrofs.to_int (Ptrofs.sub (Ptrofs.add i0 (Ptrofs.of_int i)) i1) =\nInt.add (Ptrofs.to_int (Ptrofs.sub i0 i1)) i.","proofString":"rewrite Ptrofs.sub_add_l.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int) (SF : Archi.ptr64 = false) (e : b = b0) : Ptrofs.to_int (Ptrofs.add (Ptrofs.sub i0 i1) (Ptrofs.of_int i)) =\nInt.add (Ptrofs.to_int (Ptrofs.sub i0 i1)) i.","proofString":"auto with ptrofs."},{"statement":"(i0 i1 i : int) (SF : Archi.ptr64 = true) : Vint (Int.sub i0 (Int.add i1 i)) = Vint (Int.add (Int.sub i0 i1) (Int.neg i)).","proofString":"rewrite Int.add_commut.\nrewrite Int.sub_add_r.\nauto."},{"statement":"(i0 i1 i : int) (SF : Archi.ptr64 = true) : Vint (Int.sub i0 (Int.add i i1)) = Vint (Int.add (Int.sub i0 i1) (Int.neg i)).","proofString":"rewrite Int.sub_add_r.\nauto."},{"statement":"(i0 i1 i : int) (SF : Archi.ptr64 = true) : Vint (Int.add (Int.sub i0 i1) (Int.neg i)) =\nVint (Int.add (Int.sub i0 i1) (Int.neg i)).","proofString":"auto."},{"statement":"(i0 i1 i : int) (SF : Archi.ptr64 = false) : Vint (Int.sub i0 (Int.add i1 i)) = Vint (Int.add (Int.sub i0 i1) (Int.neg i)).","proofString":"rewrite Int.add_commut.\nrewrite Int.sub_add_r.\nauto."},{"statement":"(i0 i1 i : int) (SF : Archi.ptr64 = false) : Vint (Int.sub i0 (Int.add i i1)) = Vint (Int.add (Int.sub i0 i1) (Int.neg i)).","proofString":"rewrite Int.sub_add_r.\nauto."},{"statement":"(i0 i1 i : int) (SF : Archi.ptr64 = false) : Vint (Int.add (Int.sub i0 i1) (Int.neg i)) =\nVint (Int.add (Int.sub i0 i1) (Int.neg i)).","proofString":"auto."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Vptr b (Ptrofs.sub i0 (Ptrofs.of_int (Int.add i1 i))) =\nVptr b\n  (Ptrofs.add (Ptrofs.sub i0 (Ptrofs.of_int i1)) (Ptrofs.of_int (Int.neg i))).","proofString":"f_equal.\nreplace (Ptrofs.of_int (Int.add i1 i)) with (Ptrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i1)).\nrewrite Ptrofs.sub_add_r.\nf_equal.\nsymmetry.\nauto with ptrofs.\nsymmetry.\nrewrite Int.add_commut.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Ptrofs.sub i0 (Ptrofs.of_int (Int.add i1 i)) =\nPtrofs.add (Ptrofs.sub i0 (Ptrofs.of_int i1)) (Ptrofs.of_int (Int.neg i)).","proofString":"replace (Ptrofs.of_int (Int.add i1 i)) with (Ptrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i1)).\nrewrite Ptrofs.sub_add_r.\nf_equal.\nsymmetry.\nauto with ptrofs.\nsymmetry.\nrewrite Int.add_commut.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Ptrofs.sub i0 (Ptrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i1)) =\nPtrofs.add (Ptrofs.sub i0 (Ptrofs.of_int i1)) (Ptrofs.of_int (Int.neg i)).","proofString":"rewrite Ptrofs.sub_add_r.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Ptrofs.add (Ptrofs.sub i0 (Ptrofs.of_int i1)) (Ptrofs.neg (Ptrofs.of_int i)) =\nPtrofs.add (Ptrofs.sub i0 (Ptrofs.of_int i1)) (Ptrofs.of_int (Int.neg i)).","proofString":"f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Ptrofs.neg (Ptrofs.of_int i) = Ptrofs.of_int (Int.neg i).","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Ptrofs.of_int (Int.neg i) = Ptrofs.neg (Ptrofs.of_int i).","proofString":"auto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Ptrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i1) =\nPtrofs.of_int (Int.add i1 i).","proofString":"symmetry.\nrewrite Int.add_commut.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Ptrofs.of_int (Int.add i1 i) =\nPtrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i1).","proofString":"rewrite Int.add_commut.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int) (SF : Archi.ptr64 = false) : Ptrofs.of_int (Int.add i i1) =\nPtrofs.add (Ptrofs.of_int i) (Ptrofs.of_int i1).","proofString":"auto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int) (SF : Archi.ptr64 = false) : (if eq_block b b0\n then Vint (Ptrofs.to_int (Ptrofs.sub i0 (Ptrofs.add i1 (Ptrofs.of_int i))))\n else Vundef) =\nmatch\n  (if eq_block b b0 then Vint (Ptrofs.to_int (Ptrofs.sub i0 i1)) else Vundef)\nwith\n| Vint n1 => Vint (Int.add n1 (Int.neg i))\n| Vptr b1 ofs1 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int (Int.neg i)))\n| _ => Vundef\nend.","proofString":"destruct (eq_block b b0); auto.\nf_equal.\nrewrite Ptrofs.add_commut.\nrewrite Ptrofs.sub_add_r.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int) (SF : Archi.ptr64 = false) (e : b = b0) : Vint (Ptrofs.to_int (Ptrofs.sub i0 (Ptrofs.add i1 (Ptrofs.of_int i)))) =\nVint (Int.add (Ptrofs.to_int (Ptrofs.sub i0 i1)) (Int.neg i)).","proofString":"f_equal.\nrewrite Ptrofs.add_commut.\nrewrite Ptrofs.sub_add_r.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int) (SF : Archi.ptr64 = false) (e : b = b0) : Ptrofs.to_int (Ptrofs.sub i0 (Ptrofs.add i1 (Ptrofs.of_int i))) =\nInt.add (Ptrofs.to_int (Ptrofs.sub i0 i1)) (Int.neg i).","proofString":"rewrite Ptrofs.add_commut.\nrewrite Ptrofs.sub_add_r.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int) (SF : Archi.ptr64 = false) (e : b = b0) : Ptrofs.to_int (Ptrofs.sub i0 (Ptrofs.add (Ptrofs.of_int i) i1)) =\nInt.add (Ptrofs.to_int (Ptrofs.sub i0 i1)) (Int.neg i).","proofString":"rewrite Ptrofs.sub_add_r.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int) (SF : Archi.ptr64 = false) (e : b = b0) : Ptrofs.to_int (Ptrofs.add (Ptrofs.sub i0 i1) (Ptrofs.neg (Ptrofs.of_int i))) =\nInt.add (Ptrofs.to_int (Ptrofs.sub i0 i1)) (Int.neg i).","proofString":"auto with ptrofs."},{"statement":"(i i0 : int) : Vint (Int.mul i i0) = Vint (Int.mul i0 i).","proofString":"decEq.\napply Int.mul_commut."},{"statement":"(i i0 : int) : Int.mul i i0 = Int.mul i0 i.","proofString":"apply Int.mul_commut."},{"statement":"(i i0 i1 : int) : Vint (Int.mul (Int.mul i i0) i1) = Vint (Int.mul i (Int.mul i0 i1)).","proofString":"decEq.\napply Int.mul_assoc."},{"statement":"(i i0 i1 : int) : Int.mul (Int.mul i i0) i1 = Int.mul i (Int.mul i0 i1).","proofString":"apply Int.mul_assoc."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Vint (Int.mul i n) =\n(if Int.ltu logn Int.iwordsize then Vint (Int.shl i logn) else Vundef).","proofString":"change 32 with Int.zwordsize.\nrewrite (Int.is_power2_range _ _ H).\ndecEq.\napply Int.mul_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Vint (Int.mul i n) =\n(if Int.ltu logn Int.iwordsize then Vint (Int.shl i logn) else Vundef).","proofString":"rewrite (Int.is_power2_range _ _ H).\ndecEq.\napply Int.mul_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Vint (Int.mul i n) = Vint (Int.shl i logn).","proofString":"decEq.\napply Int.mul_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Int.mul i n = Int.shl i logn.","proofString":"apply Int.mul_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Int.is_power2 n = Some logn.","proofString":"auto."},{"statement":"(x y z : val) (H : mods x y = Some z) : exists v : val, divs x y = Some v /\\ z = sub x (mul v y).","proofString":"destruct x; destruct y; simpl in *; try discriminate.\ndestruct (Int.eq i0 Int.zero        || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H.\nexists (Vint (Int.divs i i0)); split; auto.\nsimpl.\nrewrite Int.mods_divs.\nauto."},{"statement":"(i i0 : int) (z : val) (H : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some z) : exists v : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.divs i i0))) = Some v /\\\n  z =\n  match mul v (Vint i0) with\n  | Vint n2 => Vint (Int.sub i n2)\n  | _ => Vundef\n  end.","proofString":"destruct (Int.eq i0 Int.zero        || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H.\nexists (Vint (Int.divs i i0)); split; auto.\nsimpl.\nrewrite Int.mods_divs.\nauto."},{"statement":"(i i0 : int) : exists v : val,\n  Some (Vint (Int.divs i i0)) = Some v /\\\n  Vint (Int.mods i i0) =\n  match mul v (Vint i0) with\n  | Vint n2 => Vint (Int.sub i n2)\n  | _ => Vundef\n  end.","proofString":"exists (Vint (Int.divs i i0)); split; auto.\nsimpl.\nrewrite Int.mods_divs.\nauto."},{"statement":"(i i0 : int) : Vint (Int.mods i i0) =\nmatch mul (Vint (Int.divs i i0)) (Vint i0) with\n| Vint n2 => Vint (Int.sub i n2)\n| _ => Vundef\nend.","proofString":"simpl.\nrewrite Int.mods_divs.\nauto."},{"statement":"(i i0 : int) : Vint (Int.mods i i0) = Vint (Int.sub i (Int.mul (Int.divs i i0) i0)).","proofString":"rewrite Int.mods_divs.\nauto."},{"statement":"(i i0 : int) : Vint (Int.sub i (Int.mul (Int.divs i i0) i0)) =\nVint (Int.sub i (Int.mul (Int.divs i i0) i0)).","proofString":"auto."},{"statement":"(x y z : val) (H : modu x y = Some z) : exists v : val, divu x y = Some v /\\ z = sub x (mul v y).","proofString":"destruct x; destruct y; simpl in *; try discriminate.\ndestruct (Int.eq i0 Int.zero) eqn:?; inv H.\nexists (Vint (Int.divu i i0)); split; auto.\nsimpl.\nrewrite Int.modu_divu.\nauto.\ngeneralize (Int.eq_spec i0 Int.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int) (z : val) (H : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some z) : exists v : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v /\\\n  z =\n  match mul v (Vint i0) with\n  | Vint n2 => Vint (Int.sub i n2)\n  | _ => Vundef\n  end.","proofString":"destruct (Int.eq i0 Int.zero) eqn:?; inv H.\nexists (Vint (Int.divu i i0)); split; auto.\nsimpl.\nrewrite Int.modu_divu.\nauto.\ngeneralize (Int.eq_spec i0 Int.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int) (Heqb : Int.eq i0 Int.zero = false) : exists v : val,\n  Some (Vint (Int.divu i i0)) = Some v /\\\n  Vint (Int.modu i i0) =\n  match mul v (Vint i0) with\n  | Vint n2 => Vint (Int.sub i n2)\n  | _ => Vundef\n  end.","proofString":"exists (Vint (Int.divu i i0)); split; auto.\nsimpl.\nrewrite Int.modu_divu.\nauto.\ngeneralize (Int.eq_spec i0 Int.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int) (Heqb : Int.eq i0 Int.zero = false) : Vint (Int.modu i i0) =\nmatch mul (Vint (Int.divu i i0)) (Vint i0) with\n| Vint n2 => Vint (Int.sub i n2)\n| _ => Vundef\nend.","proofString":"simpl.\nrewrite Int.modu_divu.\nauto.\ngeneralize (Int.eq_spec i0 Int.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int) (Heqb : Int.eq i0 Int.zero = false) : Vint (Int.modu i i0) = Vint (Int.sub i (Int.mul (Int.divu i i0) i0)).","proofString":"rewrite Int.modu_divu.\nauto.\ngeneralize (Int.eq_spec i0 Int.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int) (Heqb : Int.eq i0 Int.zero = false) : Vint (Int.sub i (Int.mul (Int.divu i i0) i0)) =\nVint (Int.sub i (Int.mul (Int.divu i i0) i0)).","proofString":"auto."},{"statement":"(i i0 : int) (Heqb : Int.eq i0 Int.zero = false) : i0 <> Int.zero.","proofString":"generalize (Int.eq_spec i0 Int.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int) (Heqb : Int.eq i0 Int.zero = false) : (if Int.eq i0 Int.zero then i0 = Int.zero else i0 <> Int.zero) ->\ni0 <> Int.zero.","proofString":"rewrite Heqb; auto."},{"statement":"(x y z : val) (H : modls x y = Some z) : exists v : val, divls x y = Some v /\\ z = subl x (mull v y).","proofString":"destruct x; destruct y; simpl in *; try discriminate.\ndestruct (Int64.eq i0 Int64.zero        || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H.\nexists (Vlong (Int64.divs i i0)); split; auto.\nsimpl.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(i i0 : int64) (z : val) (H : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some z) : exists v : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.divs i i0))) = Some v /\\\n  z =\n  match mull v (Vlong i0) with\n  | Vlong n2 => Vlong (Int64.sub i n2)\n  | _ => Vundef\n  end.","proofString":"destruct (Int64.eq i0 Int64.zero        || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H.\nexists (Vlong (Int64.divs i i0)); split; auto.\nsimpl.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(i i0 : int64) : exists v : val,\n  Some (Vlong (Int64.divs i i0)) = Some v /\\\n  Vlong (Int64.mods i i0) =\n  match mull v (Vlong i0) with\n  | Vlong n2 => Vlong (Int64.sub i n2)\n  | _ => Vundef\n  end.","proofString":"exists (Vlong (Int64.divs i i0)); split; auto.\nsimpl.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(i i0 : int64) : Vlong (Int64.mods i i0) =\nmatch mull (Vlong (Int64.divs i i0)) (Vlong i0) with\n| Vlong n2 => Vlong (Int64.sub i n2)\n| _ => Vundef\nend.","proofString":"simpl.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(i i0 : int64) : Vlong (Int64.mods i i0) =\nVlong (Int64.sub i (Int64.mul (Int64.divs i i0) i0)).","proofString":"rewrite Int64.mods_divs.\nauto."},{"statement":"(i i0 : int64) : Vlong (Int64.sub i (Int64.mul (Int64.divs i i0) i0)) =\nVlong (Int64.sub i (Int64.mul (Int64.divs i i0) i0)).","proofString":"auto."},{"statement":"(x y z : val) (H : modlu x y = Some z) : exists v : val, divlu x y = Some v /\\ z = subl x (mull v y).","proofString":"destruct x; destruct y; simpl in *; try discriminate.\ndestruct (Int64.eq i0 Int64.zero) eqn:?; inv H.\nexists (Vlong (Int64.divu i i0)); split; auto.\nsimpl.\nrewrite Int64.modu_divu.\nauto.\ngeneralize (Int64.eq_spec i0 Int64.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int64) (z : val) (H : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome z) : exists v : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\n  Some v /\\\n  z =\n  match mull v (Vlong i0) with\n  | Vlong n2 => Vlong (Int64.sub i n2)\n  | _ => Vundef\n  end.","proofString":"destruct (Int64.eq i0 Int64.zero) eqn:?; inv H.\nexists (Vlong (Int64.divu i i0)); split; auto.\nsimpl.\nrewrite Int64.modu_divu.\nauto.\ngeneralize (Int64.eq_spec i0 Int64.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int64) (Heqb : Int64.eq i0 Int64.zero = false) : exists v : val,\n  Some (Vlong (Int64.divu i i0)) = Some v /\\\n  Vlong (Int64.modu i i0) =\n  match mull v (Vlong i0) with\n  | Vlong n2 => Vlong (Int64.sub i n2)\n  | _ => Vundef\n  end.","proofString":"exists (Vlong (Int64.divu i i0)); split; auto.\nsimpl.\nrewrite Int64.modu_divu.\nauto.\ngeneralize (Int64.eq_spec i0 Int64.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int64) (Heqb : Int64.eq i0 Int64.zero = false) : Vlong (Int64.modu i i0) =\nmatch mull (Vlong (Int64.divu i i0)) (Vlong i0) with\n| Vlong n2 => Vlong (Int64.sub i n2)\n| _ => Vundef\nend.","proofString":"simpl.\nrewrite Int64.modu_divu.\nauto.\ngeneralize (Int64.eq_spec i0 Int64.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int64) (Heqb : Int64.eq i0 Int64.zero = false) : Vlong (Int64.modu i i0) =\nVlong (Int64.sub i (Int64.mul (Int64.divu i i0) i0)).","proofString":"rewrite Int64.modu_divu.\nauto.\ngeneralize (Int64.eq_spec i0 Int64.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int64) (Heqb : Int64.eq i0 Int64.zero = false) : Vlong (Int64.sub i (Int64.mul (Int64.divu i i0) i0)) =\nVlong (Int64.sub i (Int64.mul (Int64.divu i i0) i0)).","proofString":"auto."},{"statement":"(i i0 : int64) (Heqb : Int64.eq i0 Int64.zero = false) : i0 <> Int64.zero.","proofString":"generalize (Int64.eq_spec i0 Int64.zero).\nrewrite Heqb; auto."},{"statement":"(i i0 : int64) (Heqb : Int64.eq i0 Int64.zero = false) : (if Int64.eq i0 Int64.zero then i0 = Int64.zero else i0 <> Int64.zero) ->\ni0 <> Int64.zero.","proofString":"rewrite Heqb; auto."},{"statement":"(i n logn : int) (y : val) (H : Int.is_power2 n = Some logn) (H0 : Int.ltu logn (Int.repr 31) = true) (H3 : (if\n  Int.eq n Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq n Int.mone\n then None\n else Some (Vint (Int.divs i n))) = Some y) : shrx (Vint i) (Vint logn) =\n(if\n  Int.eq n Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq n Int.mone\n then None\n else Some (Vint (Int.divs i n))).","proofString":"destruct (Int.eq n Int.zero         || Int.eq i (Int.repr Int.min_signed) && Int.eq n Int.mone); inv H3.\nsimpl.\nrewrite H0.\ndecEq.\ndecEq.\nsymmetry.\napply Int.divs_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) (H0 : Int.ltu logn (Int.repr 31) = true) : shrx (Vint i) (Vint logn) = Some (Vint (Int.divs i n)).","proofString":"simpl.\nrewrite H0.\ndecEq.\ndecEq.\nsymmetry.\napply Int.divs_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) (H0 : Int.ltu logn (Int.repr 31) = true) : (if Int.ltu logn (Int.repr 31) then Some (Vint (Int.shrx i logn)) else None) =\nSome (Vint (Int.divs i n)).","proofString":"rewrite H0.\ndecEq.\ndecEq.\nsymmetry.\napply Int.divs_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) (H0 : Int.ltu logn (Int.repr 31) = true) : Some (Vint (Int.shrx i logn)) = Some (Vint (Int.divs i n)).","proofString":"decEq.\ndecEq.\nsymmetry.\napply Int.divs_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) (H0 : Int.ltu logn (Int.repr 31) = true) : Vint (Int.shrx i logn) = Vint (Int.divs i n).","proofString":"decEq.\nsymmetry.\napply Int.divs_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) (H0 : Int.ltu logn (Int.repr 31) = true) : Int.shrx i logn = Int.divs i n.","proofString":"symmetry.\napply Int.divs_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) (H0 : Int.ltu logn (Int.repr 31) = true) : Int.divs i n = Int.shrx i logn.","proofString":"apply Int.divs_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) (H0 : Int.ltu logn (Int.repr 31) = true) : Int.is_power2 n = Some logn.","proofString":"auto."},{"statement":"(s : int) : divs (Vint s) (Vint Int.one) = Some (Vint s).","proofString":"unfold divs.\nrewrite Int.eq_false; try discriminate.\nsimpl.\nrewrite (Int.eq_false Int.one Int.mone); try discriminate.\nrewrite andb_false_intro2; auto.\nf_equal.\nf_equal.\nrewrite Int.divs_one; auto.\nreplace Int.zwordsize with 32; auto.\nlia."},{"statement":"(s : int) : (if\n  Int.eq Int.one Int.zero\n  || Int.eq s (Int.repr Int.min_signed) && Int.eq Int.one Int.mone\n then None\n else Some (Vint (Int.divs s Int.one))) = Some (Vint s).","proofString":"rewrite Int.eq_false; try discriminate.\nsimpl.\nrewrite (Int.eq_false Int.one Int.mone); try discriminate.\nrewrite andb_false_intro2; auto.\nf_equal.\nf_equal.\nrewrite Int.divs_one; auto.\nreplace Int.zwordsize with 32; auto.\nlia."},{"statement":"(s : int) : (if false || Int.eq s (Int.repr Int.min_signed) && Int.eq Int.one Int.mone\n then None\n else Some (Vint (Int.divs s Int.one))) = Some (Vint s).","proofString":"simpl.\nrewrite (Int.eq_false Int.one Int.mone); try discriminate.\nrewrite andb_false_intro2; auto.\nf_equal.\nf_equal.\nrewrite Int.divs_one; auto.\nreplace Int.zwordsize with 32; auto.\nlia."},{"statement":"(s : int) : (if Int.eq s (Int.repr Int.min_signed) && Int.eq Int.one Int.mone\n then None\n else Some (Vint (Int.divs s Int.one))) = Some (Vint s).","proofString":"rewrite (Int.eq_false Int.one Int.mone); try discriminate.\nrewrite andb_false_intro2; auto.\nf_equal.\nf_equal.\nrewrite Int.divs_one; auto.\nreplace Int.zwordsize with 32; auto.\nlia."},{"statement":"(s : int) : (if Int.eq s (Int.repr Int.min_signed) && false\n then None\n else Some (Vint (Int.divs s Int.one))) = Some (Vint s).","proofString":"rewrite andb_false_intro2; auto.\nf_equal.\nf_equal.\nrewrite Int.divs_one; auto.\nreplace Int.zwordsize with 32; auto.\nlia."},{"statement":"(s : int) : Some (Vint (Int.divs s Int.one)) = Some (Vint s).","proofString":"f_equal.\nf_equal.\nrewrite Int.divs_one; auto.\nreplace Int.zwordsize with 32; auto.\nlia."},{"statement":"(s : int) : Vint (Int.divs s Int.one) = Vint s.","proofString":"f_equal.\nrewrite Int.divs_one; auto.\nreplace Int.zwordsize with 32; auto.\nlia."},{"statement":"(s : int) : Int.divs s Int.one = s.","proofString":"rewrite Int.divs_one; auto.\nreplace Int.zwordsize with 32; auto.\nlia."},{"statement":"(s : int) : Int.zwordsize > 1.","proofString":"replace Int.zwordsize with 32; auto.\nlia."},{"statement":"(s : int) : 32 > 1.","proofString":"lia."},{"statement":"(i n logn : int) (y : val) (H : Int.is_power2 n = Some logn) (H2 : (if Int.eq n Int.zero then None else Some (Vint (Int.divu i n))) = Some y) : shru (Vint i) (Vint logn) = y.","proofString":"destruct (Int.eq n Int.zero); inv H2.\nsimpl.\nrewrite (Int.is_power2_range _ _ H).\ndecEq.\nsymmetry.\napply Int.divu_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : shru (Vint i) (Vint logn) = Vint (Int.divu i n).","proofString":"simpl.\nrewrite (Int.is_power2_range _ _ H).\ndecEq.\nsymmetry.\napply Int.divu_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : (if Int.ltu logn Int.iwordsize then Vint (Int.shru i logn) else Vundef) =\nVint (Int.divu i n).","proofString":"rewrite (Int.is_power2_range _ _ H).\ndecEq.\nsymmetry.\napply Int.divu_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Vint (Int.shru i logn) = Vint (Int.divu i n).","proofString":"decEq.\nsymmetry.\napply Int.divu_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Int.shru i logn = Int.divu i n.","proofString":"symmetry.\napply Int.divu_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Int.divu i n = Int.shru i logn.","proofString":"apply Int.divu_pow2.\nauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Int.is_power2 n = Some logn.","proofString":"auto."},{"statement":"(s : int) : divu (Vint s) (Vint Int.one) = Some (Vint s).","proofString":"simpl.\nrewrite Int.eq_false; try discriminate.\nf_equal.\nf_equal.\napply Int.divu_one."},{"statement":"(s : int) : (if Int.eq Int.one Int.zero then None else Some (Vint (Int.divu s Int.one))) =\nSome (Vint s).","proofString":"rewrite Int.eq_false; try discriminate.\nf_equal.\nf_equal.\napply Int.divu_one."},{"statement":"(s : int) : Some (Vint (Int.divu s Int.one)) = Some (Vint s).","proofString":"f_equal.\nf_equal.\napply Int.divu_one."},{"statement":"(s : int) : Vint (Int.divu s Int.one) = Vint s.","proofString":"f_equal.\napply Int.divu_one."},{"statement":"(s : int) : Int.divu s Int.one = s.","proofString":"apply Int.divu_one."},{"statement":"(i n logn : int) (y : val) (H : Int.is_power2 n = Some logn) (H2 : (if Int.eq n Int.zero then None else Some (Vint (Int.modu i n))) = Some y) : and (Vint i) (Vint (Int.sub n Int.one)) = y.","proofString":"destruct (Int.eq n Int.zero); inv H2.\nsimpl.\ndecEq.\nsymmetry.\neapply Int.modu_and; eauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : and (Vint i) (Vint (Int.sub n Int.one)) = Vint (Int.modu i n).","proofString":"simpl.\ndecEq.\nsymmetry.\neapply Int.modu_and; eauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Vint (Int.and i (Int.sub n Int.one)) = Vint (Int.modu i n).","proofString":"decEq.\nsymmetry.\neapply Int.modu_and; eauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Int.and i (Int.sub n Int.one) = Int.modu i n.","proofString":"symmetry.\neapply Int.modu_and; eauto."},{"statement":"(i n logn : int) (H : Int.is_power2 n = Some logn) : Int.modu i n = Int.and i (Int.sub n Int.one).","proofString":"eapply Int.modu_and; eauto."},{"statement":"(i i0 : int) : Vint (Int.and i i0) = Vint (Int.and i0 i).","proofString":"decEq.\napply Int.and_commut."},{"statement":"(i i0 : int) : Int.and i i0 = Int.and i0 i.","proofString":"apply Int.and_commut."},{"statement":"(i i0 i1 : int) : Vint (Int.and (Int.and i i0) i1) = Vint (Int.and i (Int.and i0 i1)).","proofString":"decEq.\napply Int.and_assoc."},{"statement":"(i i0 i1 : int) : Int.and (Int.and i i0) i1 = Int.and i (Int.and i0 i1).","proofString":"apply Int.and_assoc."},{"statement":"(i i0 : int) : Vint (Int.or i i0) = Vint (Int.or i0 i).","proofString":"decEq.\napply Int.or_commut."},{"statement":"(i i0 : int) : Int.or i i0 = Int.or i0 i.","proofString":"apply Int.or_commut."},{"statement":"(i i0 i1 : int) : Vint (Int.or (Int.or i i0) i1) = Vint (Int.or i (Int.or i0 i1)).","proofString":"decEq.\napply Int.or_assoc."},{"statement":"(i i0 i1 : int) : Int.or (Int.or i i0) i1 = Int.or i (Int.or i0 i1).","proofString":"apply Int.or_assoc."},{"statement":"(i i0 : int) : Vint (Int.xor i i0) = Vint (Int.xor i0 i).","proofString":"decEq.\napply Int.xor_commut."},{"statement":"(i i0 : int) : Int.xor i i0 = Int.xor i0 i.","proofString":"apply Int.xor_commut."},{"statement":"(i i0 i1 : int) : Vint (Int.xor (Int.xor i i0) i1) = Vint (Int.xor i (Int.xor i0 i1)).","proofString":"decEq.\napply Int.xor_assoc."},{"statement":"(i i0 i1 : int) : Int.xor (Int.xor i i0) i1 = Int.xor i (Int.xor i0 i1).","proofString":"apply Int.xor_assoc."},{"statement":"(i i0 : int) : match\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl Int.one i0) else Vundef)\nwith\n| Vint n2 => Vint (Int.mul i n2)\n| _ => Vundef\nend = (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef).","proofString":"case (Int.ltu i0 Int.iwordsize); auto.\ndecEq.\nsymmetry.\napply Int.shl_mul."},{"statement":"(i i0 : int) : Vint (Int.mul i (Int.shl Int.one i0)) = Vint (Int.shl i i0).","proofString":"decEq.\nsymmetry.\napply Int.shl_mul."},{"statement":"(i i0 : int) : Int.mul i (Int.shl Int.one i0) = Int.shl i i0.","proofString":"symmetry.\napply Int.shl_mul."},{"statement":"(i i0 : int) : Int.shl i i0 = Int.mul i (Int.shl Int.one i0).","proofString":"apply Int.shl_mul."},{"statement":"(i n : int) (H : Int.ltu n Int.iwordsize = true) : (if Int.ltu n Int.iwordsize then Vint (Int.shl i n) else Vundef) =\nVint (Int.rolm i n (Int.shl Int.mone n)).","proofString":"rewrite H.\ndecEq.\napply Int.shl_rolm.\nexact H."},{"statement":"(i n : int) (H : Int.ltu n Int.iwordsize = true) : Vint (Int.shl i n) = Vint (Int.rolm i n (Int.shl Int.mone n)).","proofString":"decEq.\napply Int.shl_rolm.\nexact H."},{"statement":"(i n : int) (H : Int.ltu n Int.iwordsize = true) : Int.shl i n = Int.rolm i n (Int.shl Int.mone n).","proofString":"apply Int.shl_rolm.\nexact H."},{"statement":"(i n : int) (H : Int.ltu n Int.iwordsize = true) : Int.ltu n Int.iwordsize = true.","proofString":"exact H."},{"statement":"(x : val) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : shll x (Vint n) =\nrolml x n (Int64.shl Int64.mone (Int64.repr (Int.unsigned n))).","proofString":"destruct x; auto.\nsimpl.\nrewrite H.\nrewrite <- Int64.shl_rolm.\nunfold Int64.shl.\nrewrite Int64.int_unsigned_repr.\nconstructor.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\napply H."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : shll (Vlong i) (Vint n) =\nrolml (Vlong i) n (Int64.shl Int64.mone (Int64.repr (Int.unsigned n))).","proofString":"simpl.\nrewrite H.\nrewrite <- Int64.shl_rolm.\nunfold Int64.shl.\nrewrite Int64.int_unsigned_repr.\nconstructor.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\napply H."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' i n) else Vundef) =\nVlong\n  (Int64.rolm i (Int64.repr (Int.unsigned n))\n     (Int64.shl Int64.mone (Int64.repr (Int.unsigned n)))).","proofString":"rewrite H.\nrewrite <- Int64.shl_rolm.\nunfold Int64.shl.\nrewrite Int64.int_unsigned_repr.\nconstructor.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\napply H."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.shl' i n) =\nVlong\n  (Int64.rolm i (Int64.repr (Int.unsigned n))\n     (Int64.shl Int64.mone (Int64.repr (Int.unsigned n)))).","proofString":"rewrite <- Int64.shl_rolm.\nunfold Int64.shl.\nrewrite Int64.int_unsigned_repr.\nconstructor.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\napply H."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.shl' i n) = Vlong (Int64.shl i (Int64.repr (Int.unsigned n))).","proofString":"unfold Int64.shl.\nrewrite Int64.int_unsigned_repr.\nconstructor."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.shl' i n) =\nVlong\n  (Int64.repr\n     (Z.shiftl (Int64.unsigned i)\n        (Int64.unsigned (Int64.repr (Int.unsigned n))))).","proofString":"rewrite Int64.int_unsigned_repr.\nconstructor."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.shl' i n) =\nVlong (Int64.repr (Z.shiftl (Int64.unsigned i) (Int.unsigned n))).","proofString":"constructor."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Int64.ltu (Int64.repr (Int.unsigned n)) Int64.iwordsize = true.","proofString":"unfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\napply H."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : (if\n  zlt (Int64.unsigned (Int64.repr (Int.unsigned n)))\n    (Int64.unsigned Int64.iwordsize)\n then true\n else false) = true.","proofString":"rewrite Int64.int_unsigned_repr.\napply H."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : (if zlt (Int.unsigned n) (Int64.unsigned Int64.iwordsize)\n then true\n else false) = true.","proofString":"apply H."},{"statement":"(i n : int) (H : Int.ltu n Int.iwordsize = true) : (if Int.ltu n Int.iwordsize then Vint (Int.shru i n) else Vundef) =\nVint (Int.rolm i (Int.sub Int.iwordsize n) (Int.shru Int.mone n)).","proofString":"rewrite H.\ndecEq.\napply Int.shru_rolm.\nexact H."},{"statement":"(i n : int) (H : Int.ltu n Int.iwordsize = true) : Vint (Int.shru i n) =\nVint (Int.rolm i (Int.sub Int.iwordsize n) (Int.shru Int.mone n)).","proofString":"decEq.\napply Int.shru_rolm.\nexact H."},{"statement":"(i n : int) (H : Int.ltu n Int.iwordsize = true) : Int.shru i n = Int.rolm i (Int.sub Int.iwordsize n) (Int.shru Int.mone n).","proofString":"apply Int.shru_rolm.\nexact H."},{"statement":"(i n : int) (H : Int.ltu n Int.iwordsize = true) : Int.ltu n Int.iwordsize = true.","proofString":"exact H."},{"statement":"(x : val) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : shrlu x (Vint n) =\nrolml x (Int.sub Int64.iwordsize' n)\n  (Int64.shru Int64.mone (Int64.repr (Int.unsigned n))).","proofString":"destruct x; auto.\nsimpl.\nrewrite H.\nrewrite Int64.int_sub_ltu by apply H.\nrewrite Int64.repr_unsigned.\nrewrite <- Int64.shru_rolm.\nunfold Int64.shru'.\nunfold Int64.shru.\nrewrite Int64.unsigned_repr.\nreflexivity.\napply Int64.int_unsigned_range.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\nauto."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : shrlu (Vlong i) (Vint n) =\nrolml (Vlong i) (Int.sub Int64.iwordsize' n)\n  (Int64.shru Int64.mone (Int64.repr (Int.unsigned n))).","proofString":"simpl.\nrewrite H.\nrewrite Int64.int_sub_ltu by apply H.\nrewrite Int64.repr_unsigned.\nrewrite <- Int64.shru_rolm.\nunfold Int64.shru'.\nunfold Int64.shru.\nrewrite Int64.unsigned_repr.\nreflexivity.\napply Int64.int_unsigned_range.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\nauto."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' i n) else Vundef) =\nVlong\n  (Int64.rolm i (Int64.repr (Int.unsigned (Int.sub Int64.iwordsize' n)))\n     (Int64.shru Int64.mone (Int64.repr (Int.unsigned n)))).","proofString":"rewrite H.\nrewrite Int64.int_sub_ltu by apply H.\nrewrite Int64.repr_unsigned.\nrewrite <- Int64.shru_rolm.\nunfold Int64.shru'.\nunfold Int64.shru.\nrewrite Int64.unsigned_repr.\nreflexivity.\napply Int64.int_unsigned_range.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\nauto."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.shru' i n) =\nVlong\n  (Int64.rolm i (Int64.repr (Int.unsigned (Int.sub Int64.iwordsize' n)))\n     (Int64.shru Int64.mone (Int64.repr (Int.unsigned n)))).","proofString":"rewrite Int64.int_sub_ltu by apply H.\nrewrite Int64.repr_unsigned.\nrewrite <- Int64.shru_rolm.\nunfold Int64.shru'.\nunfold Int64.shru.\nrewrite Int64.unsigned_repr.\nreflexivity.\napply Int64.int_unsigned_range.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\nauto."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.shru' i n) =\nVlong\n  (Int64.rolm i\n     (Int64.repr\n        (Int64.unsigned\n           (Int64.sub (Int64.repr (Int.unsigned Int64.iwordsize'))\n              (Int64.repr (Int.unsigned n)))))\n     (Int64.shru Int64.mone (Int64.repr (Int.unsigned n)))).","proofString":"rewrite Int64.repr_unsigned.\nrewrite <- Int64.shru_rolm.\nunfold Int64.shru'.\nunfold Int64.shru.\nrewrite Int64.unsigned_repr.\nreflexivity.\napply Int64.int_unsigned_range.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\nauto."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.shru' i n) =\nVlong\n  (Int64.rolm i\n     (Int64.sub (Int64.repr (Int.unsigned Int64.iwordsize'))\n        (Int64.repr (Int.unsigned n)))\n     (Int64.shru Int64.mone (Int64.repr (Int.unsigned n)))).","proofString":"rewrite <- Int64.shru_rolm.\nunfold Int64.shru'.\nunfold Int64.shru.\nrewrite Int64.unsigned_repr.\nreflexivity.\napply Int64.int_unsigned_range.\nunfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\nauto."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.shru' i n) = Vlong (Int64.shru i (Int64.repr (Int.unsigned n))).","proofString":"unfold Int64.shru'.\nunfold Int64.shru.\nrewrite Int64.unsigned_repr.\nreflexivity.\napply Int64.int_unsigned_range."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.repr (Z.shiftr (Int64.unsigned i) (Int.unsigned n))) =\nVlong (Int64.shru i (Int64.repr (Int.unsigned n))).","proofString":"unfold Int64.shru.\nrewrite Int64.unsigned_repr.\nreflexivity.\napply Int64.int_unsigned_range."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.repr (Z.shiftr (Int64.unsigned i) (Int.unsigned n))) =\nVlong\n  (Int64.repr\n     (Z.shiftr (Int64.unsigned i)\n        (Int64.unsigned (Int64.repr (Int.unsigned n))))).","proofString":"rewrite Int64.unsigned_repr.\nreflexivity.\napply Int64.int_unsigned_range."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Vlong (Int64.repr (Z.shiftr (Int64.unsigned i) (Int.unsigned n))) =\nVlong (Int64.repr (Z.shiftr (Int64.unsigned i) (Int.unsigned n))).","proofString":"reflexivity."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : 0 <= Int.unsigned n <= Int64.max_unsigned.","proofString":"apply Int64.int_unsigned_range."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : Int64.ltu (Int64.repr (Int.unsigned n)) Int64.iwordsize = true.","proofString":"unfold Int64.ltu.\nrewrite Int64.int_unsigned_repr.\nauto."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : (if\n  zlt (Int64.unsigned (Int64.repr (Int.unsigned n)))\n    (Int64.unsigned Int64.iwordsize)\n then true\n else false) = true.","proofString":"rewrite Int64.int_unsigned_repr.\nauto."},{"statement":"(i : int64) (n : int) (H : Int.ltu n Int64.iwordsize' = true) : (if zlt (Int.unsigned n) (Int64.unsigned Int64.iwordsize)\n then true\n else false) = true.","proofString":"auto."},{"statement":"(x y z : val) (H : shrx x y = Some z) : add (shr x y) (shr_carry x y) = z.","proofString":"destruct x; destruct y; simpl in H; inv H.\ndestruct (Int.ltu i0 (Int.repr 31)) eqn:?; inv H1.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 31)) with 31.\nintros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (z : val) (H1 : (if Int.ltu i0 (Int.repr 31) then Some (Vint (Int.shrx i i0)) else None) =\nSome z) : add (shr (Vint i) (Vint i0)) (shr_carry (Vint i) (Vint i0)) = z.","proofString":"destruct (Int.ltu i0 (Int.repr 31)) eqn:?; inv H1.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 31)) with 31.\nintros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) : add (shr (Vint i) (Vint i0)) (shr_carry (Vint i) (Vint i0)) =\nVint (Int.shrx i i0).","proofString":"exploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 31)) with 31.\nintros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) : 0 <= Int.unsigned i0 < Int.unsigned (Int.repr 31) ->\nadd (shr (Vint i) (Vint i0)) (shr_carry (Vint i) (Vint i0)) =\nVint (Int.shrx i i0).","proofString":"change (Int.unsigned (Int.repr 31)) with 31.\nintros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) : 0 <= Int.unsigned i0 < 31 ->\nadd (shr (Vint i) (Vint i0)) (shr_carry (Vint i) (Vint i0)) =\nVint (Int.shrx i i0).","proofString":"intros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : add (shr (Vint i) (Vint i0)) (shr_carry (Vint i) (Vint i0)) =\nVint (Int.shrx i i0).","proofString":"assert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : Int.ltu i0 Int.iwordsize = true.","proofString":"unfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : (if zlt (Int.unsigned i0) (Int.unsigned Int.iwordsize) then true else false) =\ntrue.","proofString":"apply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : Int.unsigned i0 < Int.unsigned Int.iwordsize.","proofString":"change (Int.unsigned Int.iwordsize) with 32.\nlia."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : Int.unsigned i0 < 32.","proofString":"lia."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) (H0 : Int.ltu i0 Int.iwordsize = true) : add (shr (Vint i) (Vint i0)) (shr_carry (Vint i) (Vint i0)) =\nVint (Int.shrx i i0).","proofString":"simpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) (H0 : Int.ltu i0 Int.iwordsize = true) : add (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr_carry i i0) else Vundef) =\nVint (Int.shrx i i0).","proofString":"rewrite H0.\nsimpl.\ndecEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) (H0 : Int.ltu i0 Int.iwordsize = true) : add (Vint (Int.shr i i0)) (Vint (Int.shr_carry i i0)) = Vint (Int.shrx i i0).","proofString":"simpl.\ndecEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) (H0 : Int.ltu i0 Int.iwordsize = true) : Vint (Int.add (Int.shr i i0) (Int.shr_carry i i0)) = Vint (Int.shrx i i0).","proofString":"decEq.\nrewrite Int.shrx_carry; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) (H0 : Int.ltu i0 Int.iwordsize = true) : Int.add (Int.shr i i0) (Int.shr_carry i i0) = Int.shrx i i0.","proofString":"rewrite Int.shrx_carry; auto."},{"statement":"(x y z : val) (H : shrx x y = Some z) : exists p q : int,\n  x = Vint p /\\\n  y = Vint q /\\\n  z =\n  shr\n    (if Int.lt p Int.zero\n     then add x (Vint (Int.sub (Int.shl Int.one q) Int.one))\n     else x) (Vint q).","proofString":"destruct x; destruct y; simpl in H; inv H.\ndestruct (Int.ltu i0 (Int.repr 31)) eqn:?; inv H1.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 31)) with 31.\nintros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nexists i; exists i0; intuition.\nrewrite Int.shrx_shr; auto.\ndestruct (Int.lt i Int.zero); simpl; rewrite H0; auto."},{"statement":"(i i0 : int) (z : val) (H1 : (if Int.ltu i0 (Int.repr 31) then Some (Vint (Int.shrx i i0)) else None) =\nSome z) : exists p q : int,\n  Vint i = Vint p /\\\n  Vint i0 = Vint q /\\\n  z =\n  shr\n    (if Int.lt p Int.zero\n     then add (Vint i) (Vint (Int.sub (Int.shl Int.one q) Int.one))\n     else Vint i) (Vint q).","proofString":"destruct (Int.ltu i0 (Int.repr 31)) eqn:?; inv H1.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 31)) with 31.\nintros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nexists i; exists i0; intuition.\nrewrite Int.shrx_shr; auto.\ndestruct (Int.lt i Int.zero); simpl; rewrite H0; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) : exists p q : int,\n  Vint i = Vint p /\\\n  Vint i0 = Vint q /\\\n  Vint (Int.shrx i i0) =\n  shr\n    (if Int.lt p Int.zero\n     then add (Vint i) (Vint (Int.sub (Int.shl Int.one q) Int.one))\n     else Vint i) (Vint q).","proofString":"exploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 31)) with 31.\nintros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nexists i; exists i0; intuition.\nrewrite Int.shrx_shr; auto.\ndestruct (Int.lt i Int.zero); simpl; rewrite H0; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) : 0 <= Int.unsigned i0 < Int.unsigned (Int.repr 31) ->\nexists p q : int,\n  Vint i = Vint p /\\\n  Vint i0 = Vint q /\\\n  Vint (Int.shrx i i0) =\n  shr\n    (if Int.lt p Int.zero\n     then add (Vint i) (Vint (Int.sub (Int.shl Int.one q) Int.one))\n     else Vint i) (Vint q).","proofString":"change (Int.unsigned (Int.repr 31)) with 31.\nintros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nexists i; exists i0; intuition.\nrewrite Int.shrx_shr; auto.\ndestruct (Int.lt i Int.zero); simpl; rewrite H0; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) : 0 <= Int.unsigned i0 < 31 ->\nexists p q : int,\n  Vint i = Vint p /\\\n  Vint i0 = Vint q /\\\n  Vint (Int.shrx i i0) =\n  shr\n    (if Int.lt p Int.zero\n     then add (Vint i) (Vint (Int.sub (Int.shl Int.one q) Int.one))\n     else Vint i) (Vint q).","proofString":"intros.\nassert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nexists i; exists i0; intuition.\nrewrite Int.shrx_shr; auto.\ndestruct (Int.lt i Int.zero); simpl; rewrite H0; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : exists p q : int,\n  Vint i = Vint p /\\\n  Vint i0 = Vint q /\\\n  Vint (Int.shrx i i0) =\n  shr\n    (if Int.lt p Int.zero\n     then add (Vint i) (Vint (Int.sub (Int.shl Int.one q) Int.one))\n     else Vint i) (Vint q).","proofString":"assert (Int.ltu i0 Int.iwordsize = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia.\nexists i; exists i0; intuition.\nrewrite Int.shrx_shr; auto.\ndestruct (Int.lt i Int.zero); simpl; rewrite H0; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : Int.ltu i0 Int.iwordsize = true.","proofString":"unfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : (if zlt (Int.unsigned i0) (Int.unsigned Int.iwordsize) then true else false) =\ntrue.","proofString":"apply zlt_true.\nchange (Int.unsigned Int.iwordsize) with 32.\nlia."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : Int.unsigned i0 < Int.unsigned Int.iwordsize.","proofString":"change (Int.unsigned Int.iwordsize) with 32.\nlia."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) : Int.unsigned i0 < 32.","proofString":"lia."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H : 0 <= Int.unsigned i0 < 31) (H0 : Int.ltu i0 Int.iwordsize = true) : exists p q : int,\n  Vint i = Vint p /\\\n  Vint i0 = Vint q /\\\n  Vint (Int.shrx i i0) =\n  shr\n    (if Int.lt p Int.zero\n     then add (Vint i) (Vint (Int.sub (Int.shl Int.one q) Int.one))\n     else Vint i) (Vint q).","proofString":"exists i; exists i0; intuition.\nrewrite Int.shrx_shr; auto.\ndestruct (Int.lt i Int.zero); simpl; rewrite H0; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H0 : Int.ltu i0 Int.iwordsize = true) (H1 : 0 <= Int.unsigned i0) (H2 : Int.unsigned i0 < 31) : Vint (Int.shrx i i0) =\nshr\n  (if Int.lt i Int.zero\n   then add (Vint i) (Vint (Int.sub (Int.shl Int.one i0) Int.one))\n   else Vint i) (Vint i0).","proofString":"rewrite Int.shrx_shr; auto.\ndestruct (Int.lt i Int.zero); simpl; rewrite H0; auto."},{"statement":"(i i0 : int) (Heqb : Int.ltu i0 (Int.repr 31) = true) (H0 : Int.ltu i0 Int.iwordsize = true) (H1 : 0 <= Int.unsigned i0) (H2 : Int.unsigned i0 < 31) : Vint\n  (Int.shr\n     (if Int.lt i Int.zero\n      then Int.add i (Int.sub (Int.shl Int.one i0) Int.one)\n      else i) i0) =\nshr\n  (if Int.lt i Int.zero\n   then add (Vint i) (Vint (Int.sub (Int.shl Int.one i0) Int.one))\n   else Vint i) (Vint i0).","proofString":"destruct (Int.lt i Int.zero); simpl; rewrite H0; auto."},{"statement":"(n : int) (x z : val) (H : shrx x (Vint n) = Some z) : z =\n(if Int.eq n Int.zero\n then x\n else\n  shr\n    (add x\n       (shru (shr x (Vint (Int.repr 31))) (Vint (Int.sub (Int.repr 32) n))))\n    (Vint n)).","proofString":"destruct x; simpl in H; try discriminate.\ndestruct (Int.ltu n (Int.repr 31)) eqn:LT; inv H.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 31)) with 31; intros LT'.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nunfold Int.shrx.\nrewrite Int.shl_zero.\nunfold Int.divs.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto.\nsimpl.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (z : val) (H : (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\nSome z) : z =\n(if Int.eq n Int.zero\n then Vint i\n else\n  shr\n    (add (Vint i)\n       (shru (shr (Vint i) (Vint (Int.repr 31)))\n          (Vint (Int.sub (Int.repr 32) n)))) (Vint n)).","proofString":"destruct (Int.ltu n (Int.repr 31)) eqn:LT; inv H.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 31)) with 31; intros LT'.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nunfold Int.shrx.\nrewrite Int.shl_zero.\nunfold Int.divs.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto.\nsimpl.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) : Vint (Int.shrx i n) =\n(if Int.eq n Int.zero\n then Vint i\n else\n  shr\n    (add (Vint i)\n       (shru (shr (Vint i) (Vint (Int.repr 31)))\n          (Vint (Int.sub (Int.repr 32) n)))) (Vint n)).","proofString":"exploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 31)) with 31; intros LT'.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nunfold Int.shrx.\nrewrite Int.shl_zero.\nunfold Int.divs.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto.\nsimpl.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) : 0 <= Int.unsigned n < Int.unsigned (Int.repr 31) ->\nVint (Int.shrx i n) =\n(if Int.eq n Int.zero\n then Vint i\n else\n  shr\n    (add (Vint i)\n       (shru (shr (Vint i) (Vint (Int.repr 31)))\n          (Vint (Int.sub (Int.repr 32) n)))) (Vint n)).","proofString":"change (Int.unsigned (Int.repr 31)) with 31; intros LT'.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nunfold Int.shrx.\nrewrite Int.shl_zero.\nunfold Int.divs.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto.\nsimpl.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) : Vint (Int.shrx i n) =\n(if Int.eq n Int.zero\n then Vint i\n else\n  shr\n    (add (Vint i)\n       (shru (shr (Vint i) (Vint (Int.repr 31)))\n          (Vint (Int.sub (Int.repr 32) n)))) (Vint n)).","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nunfold Int.shrx.\nrewrite Int.shl_zero.\nunfold Int.divs.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto.\nsimpl.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n = Int.zero) : Vint (Int.shrx i n) = Vint i.","proofString":"subst n.\nunfold Int.shrx.\nrewrite Int.shl_zero.\nunfold Int.divs.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(i : int) (LT' : 0 <= Int.unsigned Int.zero < 31) (LT : Int.ltu Int.zero (Int.repr 31) = true) : Vint (Int.shrx i Int.zero) = Vint i.","proofString":"unfold Int.shrx.\nrewrite Int.shl_zero.\nunfold Int.divs.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(i : int) (LT' : 0 <= Int.unsigned Int.zero < 31) (LT : Int.ltu Int.zero (Int.repr 31) = true) : Vint (Int.divs i (Int.shl Int.one Int.zero)) = Vint i.","proofString":"rewrite Int.shl_zero.\nunfold Int.divs.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(i : int) (LT' : 0 <= Int.unsigned Int.zero < 31) (LT : Int.ltu Int.zero (Int.repr 31) = true) : Vint (Int.divs i Int.one) = Vint i.","proofString":"unfold Int.divs.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(i : int) (LT' : 0 <= Int.unsigned Int.zero < 31) (LT : Int.ltu Int.zero (Int.repr 31) = true) : Vint (Int.repr (Int.signed i  Int.signed Int.one)) = Vint i.","proofString":"change (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(i : int) (LT' : 0 <= Int.unsigned Int.zero < 31) (LT : Int.ltu Int.zero (Int.repr 31) = true) : Vint (Int.repr (Int.signed i  1)) = Vint i.","proofString":"rewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(i : int) (LT' : 0 <= Int.unsigned Int.zero < 31) (LT : Int.ltu Int.zero (Int.repr 31) = true) : Vint (Int.repr (Int.signed i)) = Vint i.","proofString":"rewrite Int.repr_signed; auto."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Vint (Int.shrx i n) =\nshr\n  (add (Vint i)\n     (shru (shr (Vint i) (Vint (Int.repr 31)))\n        (Vint (Int.sub (Int.repr 32) n)))) (Vint n).","proofString":"simpl.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Vint (Int.shrx i n) =\nshr\n  match\n    shru\n      (if Int.ltu (Int.repr 31) Int.iwordsize\n       then Vint (Int.shr i (Int.repr 31))\n       else Vundef) (Vint (Int.sub (Int.repr 32) n))\n  with\n  | Vint n2 => Vint (Int.add i n2)\n  | Vptr b2 ofs2 =>\n      if Archi.ptr64\n      then Vundef\n      else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int i))\n  | _ => Vundef\n  end (Vint n).","proofString":"change (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Vint (Int.shrx i n) =\nshr\n  match\n    shru (if true then Vint (Int.shr i (Int.repr 31)) else Vundef)\n      (Vint (Int.sub (Int.repr 32) n))\n  with\n  | Vint n2 => Vint (Int.add i n2)\n  | Vptr b2 ofs2 =>\n      if Archi.ptr64\n      then Vundef\n      else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int i))\n  | _ => Vundef\n  end (Vint n).","proofString":"simpl.\nreplace (Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Vint (Int.shrx i n) =\nshr\n  match\n    (if Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize\n     then Vint (Int.shru (Int.shr i (Int.repr 31)) (Int.sub (Int.repr 32) n))\n     else Vundef)\n  with\n  | Vint n2 => Vint (Int.add i n2)\n  | Vptr b2 ofs2 =>\n      if Archi.ptr64\n      then Vundef\n      else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int i))\n  | _ => Vundef\n  end (Vint n).","proofString":"replace (Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize) with true.\nsimpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Vint (Int.shrx i n) =\nshr\n  (Vint\n     (Int.add i\n        (Int.shru (Int.shr i (Int.repr 31)) (Int.sub (Int.repr 32) n))))\n  (Vint n).","proofString":"simpl.\nreplace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Vint (Int.shrx i n) =\n(if Int.ltu n Int.iwordsize\n then\n  Vint\n    (Int.shr\n       (Int.add i\n          (Int.shru (Int.shr i (Int.repr 31)) (Int.sub (Int.repr 32) n))) n)\n else Vundef).","proofString":"replace (Int.ltu n Int.iwordsize) with true.\nf_equal; apply Int.shrx_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Vint (Int.shrx i n) =\nVint\n  (Int.shr\n     (Int.add i\n        (Int.shru (Int.shr i (Int.repr 31)) (Int.sub (Int.repr 32) n))) n).","proofString":"f_equal; apply Int.shrx_shr_2; assumption."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : true = Int.ltu n Int.iwordsize.","proofString":"symmetry; apply zlt_true.\nchange (Int.unsigned n < 32); lia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Int.unsigned n < Int.unsigned Int.iwordsize.","proofString":"change (Int.unsigned n < 32); lia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : true = Int.ltu (Int.sub (Int.repr 32) n) Int.iwordsize.","proofString":"symmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Int.unsigned (Int.sub (Int.repr 32) n) < Int.unsigned Int.iwordsize.","proofString":"unfold Int.sub.\nchange (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Int.unsigned (Int.repr (Int.unsigned (Int.repr 32) - Int.unsigned n)) <\nInt.unsigned Int.iwordsize.","proofString":"change (Int.unsigned (Int.repr 32)) with 32.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Int.unsigned (Int.repr (32 - Int.unsigned n)) < Int.unsigned Int.iwordsize.","proofString":"assert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) : Int.unsigned n <> 0.","proofString":"red; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) (H0 : Int.unsigned n = 0) : n = Int.zero.","proofString":"rewrite <- (Int.repr_unsigned n), H0.\nauto."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) (H0 : Int.unsigned n = 0) : Int.repr 0 = Int.zero.","proofString":"auto."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) (H0 : Int.unsigned n <> 0) : Int.unsigned (Int.repr (32 - Int.unsigned n)) < Int.unsigned Int.iwordsize.","proofString":"rewrite Int.unsigned_repr.\nchange (Int.unsigned Int.iwordsize) with 32; lia.\nassert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) (H0 : Int.unsigned n <> 0) : 32 - Int.unsigned n < Int.unsigned Int.iwordsize.","proofString":"change (Int.unsigned Int.iwordsize) with 32; lia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) (H0 : Int.unsigned n <> 0) : 0 <= 32 - Int.unsigned n <= Int.max_unsigned.","proofString":"assert (32 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n i : int) (LT : Int.ltu n (Int.repr 31) = true) (LT' : 0 <= Int.unsigned n < 31) (H : n <> Int.zero) (H0 : Int.unsigned n <> 0) (H1 : 32 < Int.max_unsigned) : 0 <= 32 - Int.unsigned n <= Int.max_unsigned.","proofString":"lia."},{"statement":"(i n m1 m2 : int) : Vint (Int.or (Int.rolm i n m1) (Int.rolm i n m2)) =\nVint (Int.rolm i n (Int.or m1 m2)).","proofString":"decEq.\napply Int.or_rolm."},{"statement":"(i n m1 m2 : int) : Int.or (Int.rolm i n m1) (Int.rolm i n m2) = Int.rolm i n (Int.or m1 m2).","proofString":"apply Int.or_rolm."},{"statement":"(i n1 m1 n2 m2 : int) : Vint (Int.rolm (Int.rolm i n1 m1) n2 m2) =\nVint\n  (Int.rolm i (Int.modu (Int.add n1 n2) Int.iwordsize)\n     (Int.and (Int.rol m1 n2) m2)).","proofString":"decEq.\napply Int.rolm_rolm.\napply int_wordsize_divides_modulus."},{"statement":"(i n1 m1 n2 m2 : int) : Int.rolm (Int.rolm i n1 m1) n2 m2 =\nInt.rolm i (Int.modu (Int.add n1 n2) Int.iwordsize)\n  (Int.and (Int.rol m1 n2) m2).","proofString":"apply Int.rolm_rolm.\napply int_wordsize_divides_modulus."},{"statement":"(i n1 m1 n2 m2 : int) : (Int.zwordsize | Int.modulus).","proofString":"apply int_wordsize_divides_modulus."},{"statement":"(i m : int) : Vint (Int.rolm i Int.zero m) = Vint (Int.and i m).","proofString":"decEq.\napply Int.rolm_zero."},{"statement":"(i m : int) : Int.rolm i Int.zero m = Int.and i m.","proofString":"apply Int.rolm_zero."},{"statement":"(i i0 : int64) : Vlong (Int64.add i i0) = Vlong (Int64.add i0 i).","proofString":"decEq.\napply Int64.add_commut."},{"statement":"(i i0 : int64) : Int64.add i i0 = Int64.add i0 i.","proofString":"apply Int64.add_commut."},{"statement":"(i i0 i1 : int64) (SF : Archi.ptr64 = true) : Vlong (Int64.add (Int64.add i i0) i1) = Vlong (Int64.add i (Int64.add i0 i1)).","proofString":"rewrite Int64.add_assoc; auto."},{"statement":"(i i0 : int64) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.add i1 (Ptrofs.of_int64 (Int64.add i i0))) =\nVptr b (Ptrofs.add (Ptrofs.add i1 (Ptrofs.of_int64 i0)) (Ptrofs.of_int64 i)).","proofString":"rewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(i i0 : int64) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.add i1 (Ptrofs.of_int64 (Int64.add i i0))) =\nVptr b (Ptrofs.add i1 (Ptrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 i))).","proofString":"f_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(i i0 : int64) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = true) : Ptrofs.add i1 (Ptrofs.of_int64 (Int64.add i i0)) =\nPtrofs.add i1 (Ptrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 i)).","proofString":"f_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(i i0 : int64) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.add i i0) =\nPtrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 i).","proofString":"rewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(i i0 : int64) (b : block) (i1 : ptrofs) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.add i i0) =\nPtrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i0).","proofString":"auto with ptrofs."},{"statement":"(i : int64) (b : block) (i0 : ptrofs) (i1 : int64) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.add (Ptrofs.add i0 (Ptrofs.of_int64 i)) (Ptrofs.of_int64 i1)) =\nVptr b (Ptrofs.add (Ptrofs.add i0 (Ptrofs.of_int64 i1)) (Ptrofs.of_int64 i)).","proofString":"rewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\napply Ptrofs.add_commut."},{"statement":"(i : int64) (b : block) (i0 : ptrofs) (i1 : int64) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.add i0 (Ptrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i1))) =\nVptr b (Ptrofs.add i0 (Ptrofs.add (Ptrofs.of_int64 i1) (Ptrofs.of_int64 i))).","proofString":"f_equal.\nf_equal.\napply Ptrofs.add_commut."},{"statement":"(i : int64) (b : block) (i0 : ptrofs) (i1 : int64) (SF : Archi.ptr64 = true) : Ptrofs.add i0 (Ptrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i1)) =\nPtrofs.add i0 (Ptrofs.add (Ptrofs.of_int64 i1) (Ptrofs.of_int64 i)).","proofString":"f_equal.\napply Ptrofs.add_commut."},{"statement":"(i : int64) (b : block) (i0 : ptrofs) (i1 : int64) (SF : Archi.ptr64 = true) : Ptrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i1) =\nPtrofs.add (Ptrofs.of_int64 i1) (Ptrofs.of_int64 i).","proofString":"apply Ptrofs.add_commut."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int64) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.add (Ptrofs.add i (Ptrofs.of_int64 i0)) (Ptrofs.of_int64 i1)) =\nVptr b (Ptrofs.add i (Ptrofs.of_int64 (Int64.add i0 i1))).","proofString":"rewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int64) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 i1))) =\nVptr b (Ptrofs.add i (Ptrofs.of_int64 (Int64.add i0 i1))).","proofString":"f_equal.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int64) (SF : Archi.ptr64 = true) : Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 i1)) =\nPtrofs.add i (Ptrofs.of_int64 (Int64.add i0 i1)).","proofString":"f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int64) (SF : Archi.ptr64 = true) : Ptrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 i1) =\nPtrofs.of_int64 (Int64.add i0 i1).","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (i0 i1 : int64) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.add i0 i1) =\nPtrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 i1).","proofString":"auto with ptrofs."},{"statement":"(i i0 i1 : int64) (SF : Archi.ptr64 = false) : Vlong (Int64.add (Int64.add i i0) i1) = Vlong (Int64.add i (Int64.add i0 i1)).","proofString":"rewrite Int64.add_assoc; auto."},{"statement":"(x y z : val) : addl x (addl y z) = addl y (addl x z).","proofString":"rewrite (addl_commut y z).\nrewrite <- addl_assoc.\napply addl_commut."},{"statement":"(x y z : val) : addl x (addl z y) = addl y (addl x z).","proofString":"rewrite <- addl_assoc.\napply addl_commut."},{"statement":"(x y z : val) : addl (addl x z) y = addl y (addl x z).","proofString":"apply addl_commut."},{"statement":"(x y z t : val) : addl (addl x y) (addl z t) = addl (addl x z) (addl y t).","proofString":"rewrite addl_permut.\nrewrite addl_assoc.\nrewrite addl_permut.\nsymmetry.\napply addl_assoc."},{"statement":"(x y z t : val) : addl z (addl (addl x y) t) = addl (addl x z) (addl y t).","proofString":"rewrite addl_assoc.\nrewrite addl_permut.\nsymmetry.\napply addl_assoc."},{"statement":"(x y z t : val) : addl z (addl x (addl y t)) = addl (addl x z) (addl y t).","proofString":"rewrite addl_permut.\nsymmetry.\napply addl_assoc."},{"statement":"(x y z t : val) : addl x (addl z (addl y t)) = addl (addl x z) (addl y t).","proofString":"symmetry.\napply addl_assoc."},{"statement":"(x y z t : val) : addl (addl x z) (addl y t) = addl x (addl z (addl y t)).","proofString":"apply addl_assoc."},{"statement":"(i y : int64) (SF : Archi.ptr64 = true) : Vlong (Int64.sub i y) = Vlong (Int64.add i (Int64.neg y)).","proofString":"rewrite Int64.sub_add_opp; auto."},{"statement":"(b : block) (i : ptrofs) (y : int64) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.sub i (Ptrofs.of_int64 y)) =\nVptr b (Ptrofs.add i (Ptrofs.of_int64 (Int64.neg y))).","proofString":"rewrite Ptrofs.sub_add_opp.\nf_equal.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (y : int64) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.add i (Ptrofs.neg (Ptrofs.of_int64 y))) =\nVptr b (Ptrofs.add i (Ptrofs.of_int64 (Int64.neg y))).","proofString":"f_equal.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (y : int64) (SF : Archi.ptr64 = true) : Ptrofs.add i (Ptrofs.neg (Ptrofs.of_int64 y)) =\nPtrofs.add i (Ptrofs.of_int64 (Int64.neg y)).","proofString":"f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (y : int64) (SF : Archi.ptr64 = true) : Ptrofs.neg (Ptrofs.of_int64 y) = Ptrofs.of_int64 (Int64.neg y).","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(b : block) (i : ptrofs) (y : int64) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.neg y) = Ptrofs.neg (Ptrofs.of_int64 y).","proofString":"auto with ptrofs."},{"statement":"(i y : int64) (SF : Archi.ptr64 = false) : Vlong (Int64.sub i y) = Vlong (Int64.add i (Int64.neg y)).","proofString":"rewrite Int64.sub_add_opp; auto."},{"statement":"(x : val) (y : int64) : subl x (Vlong (Int64.neg y)) = addl x (Vlong y).","proofString":"rewrite subl_addl_opp.\nrewrite Int64.neg_involutive.\nauto."},{"statement":"(x : val) (y : int64) : addl x (Vlong (Int64.neg (Int64.neg y))) = addl x (Vlong y).","proofString":"rewrite Int64.neg_involutive.\nauto."},{"statement":"(x : val) (y : int64) : addl x (Vlong y) = addl x (Vlong y).","proofString":"auto."},{"statement":"(i0 i1 i : int64) (SF : Archi.ptr64 = true) : Vlong (Int64.sub (Int64.add i0 i) i1) = Vlong (Int64.add (Int64.sub i0 i1) i).","proofString":"rewrite Int64.sub_add_l; auto."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.sub (Ptrofs.add i0 (Ptrofs.of_int64 i)) (Ptrofs.of_int64 i1)) =\nVptr b (Ptrofs.add (Ptrofs.sub i0 (Ptrofs.of_int64 i1)) (Ptrofs.of_int64 i)).","proofString":"rewrite Ptrofs.sub_add_l; auto."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) : (if negb true\n then Vundef\n else\n  if eq_block b b0\n  then\n   Vlong\n     (Ptrofs.to_int64 (Ptrofs.sub (Ptrofs.add i0 (Ptrofs.of_int64 i)) i1))\n  else Vundef) =\nmatch\n  (if negb true\n   then Vundef\n   else\n    if eq_block b b0\n    then Vlong (Ptrofs.to_int64 (Ptrofs.sub i0 i1))\n    else Vundef)\nwith\n| Vlong n1 => Vlong (Int64.add n1 i)\n| Vptr b1 ofs1 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 i))\n| _ => Vundef\nend.","proofString":"destruct (eq_block b b0); auto.\nsimpl.\nf_equal.\nrewrite Ptrofs.sub_add_l.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) (e : b = b0) : (if negb true\n then Vundef\n else\n  Vlong (Ptrofs.to_int64 (Ptrofs.sub (Ptrofs.add i0 (Ptrofs.of_int64 i)) i1))) =\nmatch\n  (if negb true then Vundef else Vlong (Ptrofs.to_int64 (Ptrofs.sub i0 i1)))\nwith\n| Vlong n1 => Vlong (Int64.add n1 i)\n| Vptr b1 ofs1 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 i))\n| _ => Vundef\nend.","proofString":"simpl.\nf_equal.\nrewrite Ptrofs.sub_add_l.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) (e : b = b0) : Vlong (Ptrofs.to_int64 (Ptrofs.sub (Ptrofs.add i0 (Ptrofs.of_int64 i)) i1)) =\nVlong (Int64.add (Ptrofs.to_int64 (Ptrofs.sub i0 i1)) i).","proofString":"f_equal.\nrewrite Ptrofs.sub_add_l.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) (e : b = b0) : Ptrofs.to_int64 (Ptrofs.sub (Ptrofs.add i0 (Ptrofs.of_int64 i)) i1) =\nInt64.add (Ptrofs.to_int64 (Ptrofs.sub i0 i1)) i.","proofString":"rewrite Ptrofs.sub_add_l.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) (e : b = b0) : Ptrofs.to_int64 (Ptrofs.add (Ptrofs.sub i0 i1) (Ptrofs.of_int64 i)) =\nInt64.add (Ptrofs.to_int64 (Ptrofs.sub i0 i1)) i.","proofString":"auto with ptrofs."},{"statement":"(i0 i1 i : int64) (SF : Archi.ptr64 = false) : Vlong (Int64.sub (Int64.add i0 i) i1) = Vlong (Int64.add (Int64.sub i0 i1) i).","proofString":"rewrite Int64.sub_add_l; auto."},{"statement":"(i0 i1 i : int64) (SF : Archi.ptr64 = true) : Vlong (Int64.sub i0 (Int64.add i1 i)) =\nVlong (Int64.add (Int64.sub i0 i1) (Int64.neg i)).","proofString":"rewrite Int64.add_commut.\nrewrite Int64.sub_add_r.\nauto."},{"statement":"(i0 i1 i : int64) (SF : Archi.ptr64 = true) : Vlong (Int64.sub i0 (Int64.add i i1)) =\nVlong (Int64.add (Int64.sub i0 i1) (Int64.neg i)).","proofString":"rewrite Int64.sub_add_r.\nauto."},{"statement":"(i0 i1 i : int64) (SF : Archi.ptr64 = true) : Vlong (Int64.add (Int64.sub i0 i1) (Int64.neg i)) =\nVlong (Int64.add (Int64.sub i0 i1) (Int64.neg i)).","proofString":"auto."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Vptr b (Ptrofs.sub i0 (Ptrofs.of_int64 (Int64.add i1 i))) =\nVptr b\n  (Ptrofs.add (Ptrofs.sub i0 (Ptrofs.of_int64 i1))\n     (Ptrofs.of_int64 (Int64.neg i))).","proofString":"f_equal.\nreplace (Ptrofs.of_int64 (Int64.add i1 i)) with (Ptrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i1)).\nrewrite Ptrofs.sub_add_r.\nf_equal.\nsymmetry.\nauto with ptrofs.\nsymmetry.\nrewrite Int64.add_commut.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Ptrofs.sub i0 (Ptrofs.of_int64 (Int64.add i1 i)) =\nPtrofs.add (Ptrofs.sub i0 (Ptrofs.of_int64 i1))\n  (Ptrofs.of_int64 (Int64.neg i)).","proofString":"replace (Ptrofs.of_int64 (Int64.add i1 i)) with (Ptrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i1)).\nrewrite Ptrofs.sub_add_r.\nf_equal.\nsymmetry.\nauto with ptrofs.\nsymmetry.\nrewrite Int64.add_commut.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Ptrofs.sub i0 (Ptrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i1)) =\nPtrofs.add (Ptrofs.sub i0 (Ptrofs.of_int64 i1))\n  (Ptrofs.of_int64 (Int64.neg i)).","proofString":"rewrite Ptrofs.sub_add_r.\nf_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Ptrofs.add (Ptrofs.sub i0 (Ptrofs.of_int64 i1))\n  (Ptrofs.neg (Ptrofs.of_int64 i)) =\nPtrofs.add (Ptrofs.sub i0 (Ptrofs.of_int64 i1))\n  (Ptrofs.of_int64 (Int64.neg i)).","proofString":"f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Ptrofs.neg (Ptrofs.of_int64 i) = Ptrofs.of_int64 (Int64.neg i).","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.neg i) = Ptrofs.neg (Ptrofs.of_int64 i).","proofString":"auto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Ptrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i1) =\nPtrofs.of_int64 (Int64.add i1 i).","proofString":"symmetry.\nrewrite Int64.add_commut.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.add i1 i) =\nPtrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i1).","proofString":"rewrite Int64.add_commut.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (i1 i : int64) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.add i i1) =\nPtrofs.add (Ptrofs.of_int64 i) (Ptrofs.of_int64 i1).","proofString":"auto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) : (if negb true\n then Vundef\n else\n  if eq_block b b0\n  then\n   Vlong\n     (Ptrofs.to_int64 (Ptrofs.sub i0 (Ptrofs.add i1 (Ptrofs.of_int64 i))))\n  else Vundef) =\nmatch\n  (if negb true\n   then Vundef\n   else\n    if eq_block b b0\n    then Vlong (Ptrofs.to_int64 (Ptrofs.sub i0 i1))\n    else Vundef)\nwith\n| Vlong n1 => Vlong (Int64.add n1 (Int64.neg i))\n| Vptr b1 ofs1 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 (Int64.neg i)))\n| _ => Vundef\nend.","proofString":"destruct (eq_block b b0); auto.\nsimpl; f_equal.\nrewrite Ptrofs.add_commut.\nrewrite Ptrofs.sub_add_r.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) (e : b = b0) : (if negb true\n then Vundef\n else\n  Vlong (Ptrofs.to_int64 (Ptrofs.sub i0 (Ptrofs.add i1 (Ptrofs.of_int64 i))))) =\nmatch\n  (if negb true then Vundef else Vlong (Ptrofs.to_int64 (Ptrofs.sub i0 i1)))\nwith\n| Vlong n1 => Vlong (Int64.add n1 (Int64.neg i))\n| Vptr b1 ofs1 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 (Int64.neg i)))\n| _ => Vundef\nend.","proofString":"simpl; f_equal.\nrewrite Ptrofs.add_commut.\nrewrite Ptrofs.sub_add_r.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) (e : b = b0) : Ptrofs.to_int64 (Ptrofs.sub i0 (Ptrofs.add i1 (Ptrofs.of_int64 i))) =\nInt64.add (Ptrofs.to_int64 (Ptrofs.sub i0 i1)) (Int64.neg i).","proofString":"rewrite Ptrofs.add_commut.\nrewrite Ptrofs.sub_add_r.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) (e : b = b0) : Ptrofs.to_int64 (Ptrofs.sub i0 (Ptrofs.add (Ptrofs.of_int64 i) i1)) =\nInt64.add (Ptrofs.to_int64 (Ptrofs.sub i0 i1)) (Int64.neg i).","proofString":"rewrite Ptrofs.sub_add_r.\nauto with ptrofs."},{"statement":"(b : block) (i0 : ptrofs) (b0 : block) (i1 : ptrofs) (i : int64) (SF : Archi.ptr64 = true) (e : b = b0) : Ptrofs.to_int64\n  (Ptrofs.add (Ptrofs.sub i0 i1) (Ptrofs.neg (Ptrofs.of_int64 i))) =\nInt64.add (Ptrofs.to_int64 (Ptrofs.sub i0 i1)) (Int64.neg i).","proofString":"auto with ptrofs."},{"statement":"(i0 i1 i : int64) (SF : Archi.ptr64 = false) : Vlong (Int64.sub i0 (Int64.add i1 i)) =\nVlong (Int64.add (Int64.sub i0 i1) (Int64.neg i)).","proofString":"rewrite Int64.add_commut.\nrewrite Int64.sub_add_r.\nauto."},{"statement":"(i0 i1 i : int64) (SF : Archi.ptr64 = false) : Vlong (Int64.sub i0 (Int64.add i i1)) =\nVlong (Int64.add (Int64.sub i0 i1) (Int64.neg i)).","proofString":"rewrite Int64.sub_add_r.\nauto."},{"statement":"(i0 i1 i : int64) (SF : Archi.ptr64 = false) : Vlong (Int64.add (Int64.sub i0 i1) (Int64.neg i)) =\nVlong (Int64.add (Int64.sub i0 i1) (Int64.neg i)).","proofString":"auto."},{"statement":"(i i0 : int64) : Vlong (Int64.mul i i0) = Vlong (Int64.mul i0 i).","proofString":"decEq.\napply Int64.mul_commut."},{"statement":"(i i0 : int64) : Int64.mul i i0 = Int64.mul i0 i.","proofString":"apply Int64.mul_commut."},{"statement":"(i i0 i1 : int64) : Vlong (Int64.mul (Int64.mul i i0) i1) = Vlong (Int64.mul i (Int64.mul i0 i1)).","proofString":"decEq.\napply Int64.mul_assoc."},{"statement":"(i i0 i1 : int64) : Int64.mul (Int64.mul i i0) i1 = Int64.mul i (Int64.mul i0 i1).","proofString":"apply Int64.mul_assoc."},{"statement":"(i i0 : int64) : Vlong (Int64.and i i0) = Vlong (Int64.and i0 i).","proofString":"decEq.\napply Int64.and_commut."},{"statement":"(i i0 : int64) : Int64.and i i0 = Int64.and i0 i.","proofString":"apply Int64.and_commut."},{"statement":"(i i0 i1 : int64) : Vlong (Int64.and (Int64.and i i0) i1) = Vlong (Int64.and i (Int64.and i0 i1)).","proofString":"decEq.\napply Int64.and_assoc."},{"statement":"(i i0 i1 : int64) : Int64.and (Int64.and i i0) i1 = Int64.and i (Int64.and i0 i1).","proofString":"apply Int64.and_assoc."},{"statement":"(i i0 : int64) : Vlong (Int64.or i i0) = Vlong (Int64.or i0 i).","proofString":"decEq.\napply Int64.or_commut."},{"statement":"(i i0 : int64) : Int64.or i i0 = Int64.or i0 i.","proofString":"apply Int64.or_commut."},{"statement":"(i i0 i1 : int64) : Vlong (Int64.or (Int64.or i i0) i1) = Vlong (Int64.or i (Int64.or i0 i1)).","proofString":"decEq.\napply Int64.or_assoc."},{"statement":"(i i0 i1 : int64) : Int64.or (Int64.or i i0) i1 = Int64.or i (Int64.or i0 i1).","proofString":"apply Int64.or_assoc."},{"statement":"(i i0 : int64) : Vlong (Int64.xor i i0) = Vlong (Int64.xor i0 i).","proofString":"decEq.\napply Int64.xor_commut."},{"statement":"(i i0 : int64) : Int64.xor i i0 = Int64.xor i0 i.","proofString":"apply Int64.xor_commut."},{"statement":"(i i0 i1 : int64) : Vlong (Int64.xor (Int64.xor i i0) i1) = Vlong (Int64.xor i (Int64.xor i0 i1)).","proofString":"decEq.\napply Int64.xor_assoc."},{"statement":"(i i0 i1 : int64) : Int64.xor (Int64.xor i i0) i1 = Int64.xor i (Int64.xor i0 i1).","proofString":"apply Int64.xor_assoc."},{"statement":"(i n : int64) (logn : int) (y : val) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) (H3 : (if\n  Int64.eq n Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n Int64.mone\n then None\n else Some (Vlong (Int64.divs i n))) = Some y) : shrxl (Vlong i) (Vint logn) =\n(if\n  Int64.eq n Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n Int64.mone\n then None\n else Some (Vlong (Int64.divs i n))).","proofString":"destruct (Int64.eq n Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n Int64.mone); inv H3.\nsimpl.\nrewrite H0.\ndecEq.\ndecEq.\ngeneralize (Int64.is_power2'_correct _ _ H); intro.\nunfold Int64.shrx'.\nrewrite Int64.shl'_mul_two_p.\nrewrite <- H1.\nrewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) : shrxl (Vlong i) (Vint logn) = Some (Vlong (Int64.divs i n)).","proofString":"simpl.\nrewrite H0.\ndecEq.\ndecEq.\ngeneralize (Int64.is_power2'_correct _ _ H); intro.\nunfold Int64.shrx'.\nrewrite Int64.shl'_mul_two_p.\nrewrite <- H1.\nrewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) : (if Int.ltu logn (Int.repr 63)\n then Some (Vlong (Int64.shrx' i logn))\n else None) = Some (Vlong (Int64.divs i n)).","proofString":"rewrite H0.\ndecEq.\ndecEq.\ngeneralize (Int64.is_power2'_correct _ _ H); intro.\nunfold Int64.shrx'.\nrewrite Int64.shl'_mul_two_p.\nrewrite <- H1.\nrewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) : Some (Vlong (Int64.shrx' i logn)) = Some (Vlong (Int64.divs i n)).","proofString":"decEq.\ndecEq.\ngeneralize (Int64.is_power2'_correct _ _ H); intro.\nunfold Int64.shrx'.\nrewrite Int64.shl'_mul_two_p.\nrewrite <- H1.\nrewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) : Vlong (Int64.shrx' i logn) = Vlong (Int64.divs i n).","proofString":"decEq.\ngeneralize (Int64.is_power2'_correct _ _ H); intro.\nunfold Int64.shrx'.\nrewrite Int64.shl'_mul_two_p.\nrewrite <- H1.\nrewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) : Int64.shrx' i logn = Int64.divs i n.","proofString":"generalize (Int64.is_power2'_correct _ _ H); intro.\nunfold Int64.shrx'.\nrewrite Int64.shl'_mul_two_p.\nrewrite <- H1.\nrewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) (H1 : Int64.unsigned n = two_p (Int.unsigned logn)) : Int64.shrx' i logn = Int64.divs i n.","proofString":"unfold Int64.shrx'.\nrewrite Int64.shl'_mul_two_p.\nrewrite <- H1.\nrewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) (H1 : Int64.unsigned n = two_p (Int.unsigned logn)) : Int64.divs i (Int64.shl' Int64.one logn) = Int64.divs i n.","proofString":"rewrite Int64.shl'_mul_two_p.\nrewrite <- H1.\nrewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) (H1 : Int64.unsigned n = two_p (Int.unsigned logn)) : Int64.divs i (Int64.mul Int64.one (Int64.repr (two_p (Int.unsigned logn)))) =\nInt64.divs i n.","proofString":"rewrite <- H1.\nrewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) (H1 : Int64.unsigned n = two_p (Int.unsigned logn)) : Int64.divs i (Int64.mul Int64.one (Int64.repr (Int64.unsigned n))) =\nInt64.divs i n.","proofString":"rewrite Int64.mul_commut.\nrewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) (H1 : Int64.unsigned n = two_p (Int.unsigned logn)) : Int64.divs i (Int64.mul (Int64.repr (Int64.unsigned n)) Int64.one) =\nInt64.divs i n.","proofString":"rewrite Int64.mul_one.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) (H1 : Int64.unsigned n = two_p (Int.unsigned logn)) : Int64.divs i (Int64.repr (Int64.unsigned n)) = Int64.divs i n.","proofString":"rewrite Int64.repr_unsigned.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) (H0 : Int.ltu logn (Int.repr 63) = true) (H1 : Int64.unsigned n = two_p (Int.unsigned logn)) : Int64.divs i n = Int64.divs i n.","proofString":"auto."},{"statement":"(n : int64) : divls (Vlong n) (Vlong Int64.one) = Some (Vlong n).","proofString":"unfold divls.\nrewrite Int64.eq_false; try discriminate.\nrewrite (Int64.eq_false Int64.one Int64.mone); try discriminate.\nrewrite andb_false_intro2; auto.\nsimpl.\nf_equal.\nf_equal.\napply Int64.divs_one.\nreplace Int64.zwordsize with 64; auto.\nlia."},{"statement":"(n : int64) : (if\n  Int64.eq Int64.one Int64.zero\n  || Int64.eq n (Int64.repr Int64.min_signed) &&\n     Int64.eq Int64.one Int64.mone\n then None\n else Some (Vlong (Int64.divs n Int64.one))) = Some (Vlong n).","proofString":"rewrite Int64.eq_false; try discriminate.\nrewrite (Int64.eq_false Int64.one Int64.mone); try discriminate.\nrewrite andb_false_intro2; auto.\nsimpl.\nf_equal.\nf_equal.\napply Int64.divs_one.\nreplace Int64.zwordsize with 64; auto.\nlia."},{"statement":"(n : int64) : (if\n  false\n  || Int64.eq n (Int64.repr Int64.min_signed) &&\n     Int64.eq Int64.one Int64.mone\n then None\n else Some (Vlong (Int64.divs n Int64.one))) = Some (Vlong n).","proofString":"rewrite (Int64.eq_false Int64.one Int64.mone); try discriminate.\nrewrite andb_false_intro2; auto.\nsimpl.\nf_equal.\nf_equal.\napply Int64.divs_one.\nreplace Int64.zwordsize with 64; auto.\nlia."},{"statement":"(n : int64) : (if false || Int64.eq n (Int64.repr Int64.min_signed) && false\n then None\n else Some (Vlong (Int64.divs n Int64.one))) = Some (Vlong n).","proofString":"rewrite andb_false_intro2; auto.\nsimpl.\nf_equal.\nf_equal.\napply Int64.divs_one.\nreplace Int64.zwordsize with 64; auto.\nlia."},{"statement":"(n : int64) : (if false || false then None else Some (Vlong (Int64.divs n Int64.one))) =\nSome (Vlong n).","proofString":"simpl.\nf_equal.\nf_equal.\napply Int64.divs_one.\nreplace Int64.zwordsize with 64; auto.\nlia."},{"statement":"(n : int64) : Some (Vlong (Int64.divs n Int64.one)) = Some (Vlong n).","proofString":"f_equal.\nf_equal.\napply Int64.divs_one.\nreplace Int64.zwordsize with 64; auto.\nlia."},{"statement":"(n : int64) : Vlong (Int64.divs n Int64.one) = Vlong n.","proofString":"f_equal.\napply Int64.divs_one.\nreplace Int64.zwordsize with 64; auto.\nlia."},{"statement":"(n : int64) : Int64.divs n Int64.one = n.","proofString":"apply Int64.divs_one.\nreplace Int64.zwordsize with 64; auto.\nlia."},{"statement":"(n : int64) : Int64.zwordsize > 1.","proofString":"replace Int64.zwordsize with 64; auto.\nlia."},{"statement":"(n : int64) : 64 > 1.","proofString":"lia."},{"statement":"(i n : int64) (logn : int) (y : val) (H : Int64.is_power2' n = Some logn) (H2 : (if Int64.eq n Int64.zero then None else Some (Vlong (Int64.divu i n))) =\nSome y) : shrlu (Vlong i) (Vint logn) = y.","proofString":"destruct (Int64.eq n Int64.zero); inv H2.\nsimpl.\nrewrite (Int64.is_power2'_range _ _ H).\ndecEq.\nsymmetry.\napply Int64.divu_pow2'.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) : shrlu (Vlong i) (Vint logn) = Vlong (Int64.divu i n).","proofString":"simpl.\nrewrite (Int64.is_power2'_range _ _ H).\ndecEq.\nsymmetry.\napply Int64.divu_pow2'.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) : (if Int.ltu logn Int64.iwordsize' then Vlong (Int64.shru' i logn) else Vundef) =\nVlong (Int64.divu i n).","proofString":"rewrite (Int64.is_power2'_range _ _ H).\ndecEq.\nsymmetry.\napply Int64.divu_pow2'.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) : Vlong (Int64.shru' i logn) = Vlong (Int64.divu i n).","proofString":"decEq.\nsymmetry.\napply Int64.divu_pow2'.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) : Int64.shru' i logn = Int64.divu i n.","proofString":"symmetry.\napply Int64.divu_pow2'.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) : Int64.divu i n = Int64.shru' i logn.","proofString":"apply Int64.divu_pow2'.\nauto."},{"statement":"(i n : int64) (logn : int) (H : Int64.is_power2' n = Some logn) : Int64.is_power2' n = Some logn.","proofString":"auto."},{"statement":"(n : int64) : divlu (Vlong n) (Vlong Int64.one) = Some (Vlong n).","proofString":"unfold divlu.\nrewrite Int64.eq_false; try discriminate.\nsimpl.\nf_equal.\nf_equal.\napply Int64.divu_one."},{"statement":"(n : int64) : (if Int64.eq Int64.one Int64.zero\n then None\n else Some (Vlong (Int64.divu n Int64.one))) = Some (Vlong n).","proofString":"rewrite Int64.eq_false; try discriminate.\nsimpl.\nf_equal.\nf_equal.\napply Int64.divu_one."},{"statement":"(n : int64) : Some (Vlong (Int64.divu n Int64.one)) = Some (Vlong n).","proofString":"simpl.\nf_equal.\nf_equal.\napply Int64.divu_one."},{"statement":"(n : int64) : Some (Vlong (Int64.divu n Int64.one)) = Some (Vlong n).","proofString":"f_equal.\nf_equal.\napply Int64.divu_one."},{"statement":"(n : int64) : Vlong (Int64.divu n Int64.one) = Vlong n.","proofString":"f_equal.\napply Int64.divu_one."},{"statement":"(n : int64) : Int64.divu n Int64.one = n.","proofString":"apply Int64.divu_one."},{"statement":"(i n logn : int64) (y : val) (H : Int64.is_power2 n = Some logn) (H2 : (if Int64.eq n Int64.zero then None else Some (Vlong (Int64.modu i n))) =\nSome y) : andl (Vlong i) (Vlong (Int64.sub n Int64.one)) = y.","proofString":"destruct (Int64.eq n Int64.zero); inv H2.\nsimpl.\ndecEq.\nsymmetry.\neapply Int64.modu_and; eauto."},{"statement":"(i n logn : int64) (H : Int64.is_power2 n = Some logn) : andl (Vlong i) (Vlong (Int64.sub n Int64.one)) = Vlong (Int64.modu i n).","proofString":"simpl.\ndecEq.\nsymmetry.\neapply Int64.modu_and; eauto."},{"statement":"(i n logn : int64) (H : Int64.is_power2 n = Some logn) : Vlong (Int64.and i (Int64.sub n Int64.one)) = Vlong (Int64.modu i n).","proofString":"decEq.\nsymmetry.\neapply Int64.modu_and; eauto."},{"statement":"(i n logn : int64) (H : Int64.is_power2 n = Some logn) : Int64.and i (Int64.sub n Int64.one) = Int64.modu i n.","proofString":"symmetry.\neapply Int64.modu_and; eauto."},{"statement":"(i n logn : int64) (H : Int64.is_power2 n = Some logn) : Int64.modu i n = Int64.and i (Int64.sub n Int64.one).","proofString":"eapply Int64.modu_and; eauto."},{"statement":"(x y z : val) (H : shrxl x y = Some z) : addl (shrl x y) (shrl_carry x y) = z.","proofString":"destruct x; destruct y; simpl in H; inv H.\ndestruct (Int.ltu i0 (Int.repr 63)) eqn:?; inv H1.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 63)) with 63.\nintros.\nassert (Int.ltu i0 Int64.iwordsize' = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int64.iwordsize') with 64.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (z : val) (H1 : (if Int.ltu i0 (Int.repr 63) then Some (Vlong (Int64.shrx' i i0)) else None) =\nSome z) : addl (shrl (Vlong i) (Vint i0)) (shrl_carry (Vlong i) (Vint i0)) = z.","proofString":"destruct (Int.ltu i0 (Int.repr 63)) eqn:?; inv H1.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 63)) with 63.\nintros.\nassert (Int.ltu i0 Int64.iwordsize' = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int64.iwordsize') with 64.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) : addl (shrl (Vlong i) (Vint i0)) (shrl_carry (Vlong i) (Vint i0)) =\nVlong (Int64.shrx' i i0).","proofString":"exploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 63)) with 63.\nintros.\nassert (Int.ltu i0 Int64.iwordsize' = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int64.iwordsize') with 64.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) : 0 <= Int.unsigned i0 < Int.unsigned (Int.repr 63) ->\naddl (shrl (Vlong i) (Vint i0)) (shrl_carry (Vlong i) (Vint i0)) =\nVlong (Int64.shrx' i i0).","proofString":"change (Int.unsigned (Int.repr 63)) with 63.\nintros.\nassert (Int.ltu i0 Int64.iwordsize' = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int64.iwordsize') with 64.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) : 0 <= Int.unsigned i0 < 63 ->\naddl (shrl (Vlong i) (Vint i0)) (shrl_carry (Vlong i) (Vint i0)) =\nVlong (Int64.shrx' i i0).","proofString":"intros.\nassert (Int.ltu i0 Int64.iwordsize' = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int64.iwordsize') with 64.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) : addl (shrl (Vlong i) (Vint i0)) (shrl_carry (Vlong i) (Vint i0)) =\nVlong (Int64.shrx' i i0).","proofString":"assert (Int.ltu i0 Int64.iwordsize' = true).\nunfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int64.iwordsize') with 64.\nlia.\nsimpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) : Int.ltu i0 Int64.iwordsize' = true.","proofString":"unfold Int.ltu.\napply zlt_true.\nchange (Int.unsigned Int64.iwordsize') with 64.\nlia."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) : (if zlt (Int.unsigned i0) (Int.unsigned Int64.iwordsize')\n then true\n else false) = true.","proofString":"apply zlt_true.\nchange (Int.unsigned Int64.iwordsize') with 64.\nlia."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) : Int.unsigned i0 < Int.unsigned Int64.iwordsize'.","proofString":"change (Int.unsigned Int64.iwordsize') with 64.\nlia."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) : Int.unsigned i0 < 64.","proofString":"lia."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) (H0 : Int.ltu i0 Int64.iwordsize' = true) : addl (shrl (Vlong i) (Vint i0)) (shrl_carry (Vlong i) (Vint i0)) =\nVlong (Int64.shrx' i i0).","proofString":"simpl.\nrewrite H0.\nsimpl.\ndecEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) (H0 : Int.ltu i0 Int64.iwordsize' = true) : addl\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize'\n   then Vlong (Int64.shr_carry' i i0)\n   else Vundef) = Vlong (Int64.shrx' i i0).","proofString":"rewrite H0.\nsimpl.\ndecEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) (H0 : Int.ltu i0 Int64.iwordsize' = true) : addl (Vlong (Int64.shr' i i0)) (Vlong (Int64.shr_carry' i i0)) =\nVlong (Int64.shrx' i i0).","proofString":"simpl.\ndecEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) (H0 : Int.ltu i0 Int64.iwordsize' = true) : Vlong (Int64.add (Int64.shr' i i0) (Int64.shr_carry' i i0)) =\nVlong (Int64.shrx' i i0).","proofString":"decEq.\nrewrite Int64.shrx'_carry; auto."},{"statement":"(i : int64) (i0 : int) (Heqb : Int.ltu i0 (Int.repr 63) = true) (H : 0 <= Int.unsigned i0 < 63) (H0 : Int.ltu i0 Int64.iwordsize' = true) : Int64.add (Int64.shr' i i0) (Int64.shr_carry' i i0) = Int64.shrx' i i0.","proofString":"rewrite Int64.shrx'_carry; auto."},{"statement":"(n : int) (x z : val) (H : shrxl x (Vint n) = Some z) : z =\n(if Int.eq n Int.zero\n then x\n else\n  shrl\n    (addl x\n       (shrlu (shrl x (Vint (Int.repr 63))) (Vint (Int.sub (Int.repr 64) n))))\n    (Vint n)).","proofString":"destruct x; simpl in H; try discriminate.\ndestruct (Int.ltu n (Int.repr 63)) eqn:LT; inv H.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 63)) with 63; intros LT'.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nrewrite Int64.shrx'_zero.\nauto.\nsimpl.\nchange (Int.ltu (Int.repr 63) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (z : val) (H : (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\nSome z) : z =\n(if Int.eq n Int.zero\n then Vlong i\n else\n  shrl\n    (addl (Vlong i)\n       (shrlu (shrl (Vlong i) (Vint (Int.repr 63)))\n          (Vint (Int.sub (Int.repr 64) n)))) (Vint n)).","proofString":"destruct (Int.ltu n (Int.repr 63)) eqn:LT; inv H.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 63)) with 63; intros LT'.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nrewrite Int64.shrx'_zero.\nauto.\nsimpl.\nchange (Int.ltu (Int.repr 63) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) : Vlong (Int64.shrx' i n) =\n(if Int.eq n Int.zero\n then Vlong i\n else\n  shrl\n    (addl (Vlong i)\n       (shrlu (shrl (Vlong i) (Vint (Int.repr 63)))\n          (Vint (Int.sub (Int.repr 64) n)))) (Vint n)).","proofString":"exploit Int.ltu_inv; eauto.\nchange (Int.unsigned (Int.repr 63)) with 63; intros LT'.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nrewrite Int64.shrx'_zero.\nauto.\nsimpl.\nchange (Int.ltu (Int.repr 63) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) : 0 <= Int.unsigned n < Int.unsigned (Int.repr 63) ->\nVlong (Int64.shrx' i n) =\n(if Int.eq n Int.zero\n then Vlong i\n else\n  shrl\n    (addl (Vlong i)\n       (shrlu (shrl (Vlong i) (Vint (Int.repr 63)))\n          (Vint (Int.sub (Int.repr 64) n)))) (Vint n)).","proofString":"change (Int.unsigned (Int.repr 63)) with 63; intros LT'.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nrewrite Int64.shrx'_zero.\nauto.\nsimpl.\nchange (Int.ltu (Int.repr 63) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) : Vlong (Int64.shrx' i n) =\n(if Int.eq n Int.zero\n then Vlong i\n else\n  shrl\n    (addl (Vlong i)\n       (shrlu (shrl (Vlong i) (Vint (Int.repr 63)))\n          (Vint (Int.sub (Int.repr 64) n)))) (Vint n)).","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nrewrite Int64.shrx'_zero.\nauto.\nsimpl.\nchange (Int.ltu (Int.repr 63) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n = Int.zero) : Vlong (Int64.shrx' i n) = Vlong i.","proofString":"subst n.\nrewrite Int64.shrx'_zero.\nauto."},{"statement":"(i : int64) (LT' : 0 <= Int.unsigned Int.zero < 63) (LT : Int.ltu Int.zero (Int.repr 63) = true) : Vlong (Int64.shrx' i Int.zero) = Vlong i.","proofString":"rewrite Int64.shrx'_zero.\nauto."},{"statement":"(i : int64) (LT' : 0 <= Int.unsigned Int.zero < 63) (LT : Int.ltu Int.zero (Int.repr 63) = true) : Vlong i = Vlong i.","proofString":"auto."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Vlong (Int64.shrx' i n) =\nshrl\n  (addl (Vlong i)\n     (shrlu (shrl (Vlong i) (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n).","proofString":"simpl.\nchange (Int.ltu (Int.repr 63) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Vlong (Int64.shrx' i n) =\nshrl\n  match\n    shrlu\n      (if Int.ltu (Int.repr 63) Int64.iwordsize'\n       then Vlong (Int64.shr' i (Int.repr 63))\n       else Vundef) (Vint (Int.sub (Int.repr 64) n))\n  with\n  | Vlong n2 => Vlong (Int64.add i n2)\n  | Vptr b2 ofs2 =>\n      if Archi.ptr64\n      then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 i))\n      else Vundef\n  | _ => Vundef\n  end (Vint n).","proofString":"change (Int.ltu (Int.repr 63) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Vlong (Int64.shrx' i n) =\nshrl\n  match\n    shrlu (if true then Vlong (Int64.shr' i (Int.repr 63)) else Vundef)\n      (Vint (Int.sub (Int.repr 64) n))\n  with\n  | Vlong n2 => Vlong (Int64.add i n2)\n  | Vptr b2 ofs2 =>\n      if Archi.ptr64\n      then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 i))\n      else Vundef\n  | _ => Vundef\n  end (Vint n).","proofString":"simpl.\nreplace (Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Vlong (Int64.shrx' i n) =\nshrl\n  match\n    (if Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize'\n     then\n      Vlong\n        (Int64.shru' (Int64.shr' i (Int.repr 63)) (Int.sub (Int.repr 64) n))\n     else Vundef)\n  with\n  | Vlong n2 => Vlong (Int64.add i n2)\n  | Vptr b2 ofs2 =>\n      if Archi.ptr64\n      then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 i))\n      else Vundef\n  | _ => Vundef\n  end (Vint n).","proofString":"replace (Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize') with true.\nsimpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia.\nsymmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Vlong (Int64.shrx' i n) =\nshrl\n  (Vlong\n     (Int64.add i\n        (Int64.shru' (Int64.shr' i (Int.repr 63)) (Int.sub (Int.repr 64) n))))\n  (Vint n).","proofString":"simpl.\nreplace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Vlong (Int64.shrx' i n) =\n(if Int.ltu n Int64.iwordsize'\n then\n  Vlong\n    (Int64.shr'\n       (Int64.add i\n          (Int64.shru' (Int64.shr' i (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n       n)\n else Vundef).","proofString":"replace (Int.ltu n Int64.iwordsize') with true.\nf_equal; apply Int64.shrx'_shr_2; assumption.\nsymmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Vlong (Int64.shrx' i n) =\nVlong\n  (Int64.shr'\n     (Int64.add i\n        (Int64.shru' (Int64.shr' i (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n     n).","proofString":"f_equal; apply Int64.shrx'_shr_2; assumption."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : true = Int.ltu n Int64.iwordsize'.","proofString":"symmetry; apply zlt_true.\nchange (Int.unsigned n < 64); lia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Int.unsigned n < Int.unsigned Int64.iwordsize'.","proofString":"change (Int.unsigned n < 64); lia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : true = Int.ltu (Int.sub (Int.repr 64) n) Int64.iwordsize'.","proofString":"symmetry; apply zlt_true.\nunfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Int.unsigned (Int.sub (Int.repr 64) n) < Int.unsigned Int64.iwordsize'.","proofString":"unfold Int.sub.\nchange (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Int.unsigned (Int.repr (Int.unsigned (Int.repr 64) - Int.unsigned n)) <\nInt.unsigned Int64.iwordsize'.","proofString":"change (Int.unsigned (Int.repr 64)) with 64.\nassert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Int.unsigned (Int.repr (64 - Int.unsigned n)) < Int.unsigned Int64.iwordsize'.","proofString":"assert (Int.unsigned n <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto.\nrewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) : Int.unsigned n <> 0.","proofString":"red; intros; elim H.\nrewrite <- (Int.repr_unsigned n), H0.\nauto."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) (H0 : Int.unsigned n = 0) : n = Int.zero.","proofString":"rewrite <- (Int.repr_unsigned n), H0.\nauto."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) (H0 : Int.unsigned n = 0) : Int.repr 0 = Int.zero.","proofString":"auto."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) (H0 : Int.unsigned n <> 0) : Int.unsigned (Int.repr (64 - Int.unsigned n)) < Int.unsigned Int64.iwordsize'.","proofString":"rewrite Int.unsigned_repr.\nchange (Int.unsigned Int64.iwordsize') with 64; lia.\nassert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) (H0 : Int.unsigned n <> 0) : 64 - Int.unsigned n < Int.unsigned Int64.iwordsize'.","proofString":"change (Int.unsigned Int64.iwordsize') with 64; lia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) (H0 : Int.unsigned n <> 0) : 0 <= 64 - Int.unsigned n <= Int.max_unsigned.","proofString":"assert (64 < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(n : int) (i : int64) (LT : Int.ltu n (Int.repr 63) = true) (LT' : 0 <= Int.unsigned n < 63) (H : n <> Int.zero) (H0 : Int.unsigned n <> 0) (H1 : 64 < Int.max_unsigned) : 0 <= 64 - Int.unsigned n <= Int.max_unsigned.","proofString":"lia."},{"statement":"(c : comparison) (i i0 : int) : Some (Int.cmp (negate_comparison c) i i0) = Some (negb (Int.cmp c i i0)).","proofString":"rewrite Int.negate_cmp.\nauto."},{"statement":"(c : comparison) (i i0 : int) : Some (negb (Int.cmp c i i0)) = Some (negb (Int.cmp c i i0)).","proofString":"auto."},{"statement":"forall c : comparison,\ncmp_different_blocks (negate_comparison c) =\noption_map negb (cmp_different_blocks c).","proofString":"destruct c; auto."},{"statement":"(H : forall c : comparison,\ncmp_different_blocks (negate_comparison c) =\noption_map negb (cmp_different_blocks c)) : forall (valid_ptr : block -> Z -> bool) (c : comparison) (x y : val),\ncmpu_bool valid_ptr (negate_comparison c) x y =\noption_map negb (cmpu_bool valid_ptr c x y).","proofString":"unfold cmpu_bool; intros; destruct Archi.ptr64 eqn:SF, x, y; auto.\nrewrite Int.negate_cmpu.\nauto.\nrewrite Int.negate_cmpu.\nauto.\ndestruct (Int.eq i Int.zero && (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))); auto.\ndestruct (Int.eq i0 Int.zero && (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))); auto.\ndestruct (eq_block b b0).\ndestruct ((valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&            (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))).\nrewrite Ptrofs.negate_cmpu.\nauto.\nauto.\ndestruct (valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int) (SF : Archi.ptr64 = true) : Some (Int.cmpu (negate_comparison c) i i0) =\noption_map negb (Some (Int.cmpu c i i0)).","proofString":"rewrite Int.negate_cmpu.\nauto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int) (SF : Archi.ptr64 = true) : Some (negb (Int.cmpu c i i0)) = option_map negb (Some (Int.cmpu c i i0)).","proofString":"auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int) (SF : Archi.ptr64 = false) : Some (Int.cmpu (negate_comparison c) i i0) =\noption_map negb (Some (Int.cmpu c i i0)).","proofString":"rewrite Int.negate_cmpu.\nauto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int) (SF : Archi.ptr64 = false) : Some (negb (Int.cmpu c i i0)) = option_map negb (Some (Int.cmpu c i i0)).","proofString":"auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i : int) (b : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) : (if\n  Int.eq i Int.zero &&\n  (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))\n then cmp_different_blocks (negate_comparison c)\n else None) =\noption_map negb\n  (if\n    Int.eq i Int.zero &&\n    (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))\n   then cmp_different_blocks c\n   else None).","proofString":"destruct (Int.eq i Int.zero && (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (i0 : int) (SF : Archi.ptr64 = false) : (if\n  Int.eq i0 Int.zero &&\n  (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n then cmp_different_blocks (negate_comparison c)\n else None) =\noption_map negb\n  (if\n    Int.eq i0 Int.zero &&\n    (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n   then cmp_different_blocks c\n   else None).","proofString":"destruct (Int.eq i0 Int.zero && (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) : (if eq_block b b0\n then\n  if\n   (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu (negate_comparison c) i i0)\n  else None\n else\n  if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n  then cmp_different_blocks (negate_comparison c)\n  else None) =\noption_map negb\n  (if eq_block b b0\n   then\n    if\n     (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n     (valid_ptr b0 (Ptrofs.unsigned i0)\n      || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n    then Some (Ptrofs.cmpu c i i0)\n    else None\n   else\n    if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n    then cmp_different_blocks c\n    else None).","proofString":"destruct (eq_block b b0).\ndestruct ((valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&            (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))).\nrewrite Ptrofs.negate_cmpu.\nauto.\nauto.\ndestruct (valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) (e : b = b0) : (if\n  (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n  (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n then Some (Ptrofs.cmpu (negate_comparison c) i i0)\n else None) =\noption_map negb\n  (if\n    (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n    (valid_ptr b0 (Ptrofs.unsigned i0)\n     || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n   then Some (Ptrofs.cmpu c i i0)\n   else None).","proofString":"destruct ((valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&            (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))).\nrewrite Ptrofs.negate_cmpu.\nauto.\nauto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) (e : b = b0) : Some (Ptrofs.cmpu (negate_comparison c) i i0) =\noption_map negb (Some (Ptrofs.cmpu c i i0)).","proofString":"rewrite Ptrofs.negate_cmpu.\nauto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) (e : b = b0) : Some (negb (Ptrofs.cmpu c i i0)) =\noption_map negb (Some (Ptrofs.cmpu c i i0)).","proofString":"auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) (e : b = b0) : None = option_map negb None.","proofString":"auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) (n : b <> b0) : (if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n then cmp_different_blocks (negate_comparison c)\n else None) =\noption_map negb\n  (if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n   then cmp_different_blocks c\n   else None).","proofString":"destruct (valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)); auto."},{"statement":"(c : comparison) (i i0 : int64) : Some (Int64.cmp (negate_comparison c) i i0) = Some (negb (Int64.cmp c i i0)).","proofString":"rewrite Int64.negate_cmp.\nauto."},{"statement":"(c : comparison) (i i0 : int64) : Some (negb (Int64.cmp c i i0)) = Some (negb (Int64.cmp c i i0)).","proofString":"auto."},{"statement":"forall c : comparison,\ncmp_different_blocks (negate_comparison c) =\noption_map negb (cmp_different_blocks c).","proofString":"destruct c; auto."},{"statement":"(H : forall c : comparison,\ncmp_different_blocks (negate_comparison c) =\noption_map negb (cmp_different_blocks c)) : forall (valid_ptr : block -> Z -> bool) (c : comparison) (x y : val),\ncmplu_bool valid_ptr (negate_comparison c) x y =\noption_map negb (cmplu_bool valid_ptr c x y).","proofString":"unfold cmplu_bool; intros; destruct Archi.ptr64 eqn:SF, x, y; auto.\nrewrite Int64.negate_cmpu.\nauto.\nsimpl.\ndestruct (Int64.eq i Int64.zero && (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))); auto.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero && (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))); auto.\nsimpl.\ndestruct (eq_block b b0).\ndestruct ((valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&            (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))).\nrewrite Ptrofs.negate_cmpu.\nauto.\nauto.\ndestruct (valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)); auto.\nrewrite Int64.negate_cmpu.\nauto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int64) (SF : Archi.ptr64 = true) : Some (Int64.cmpu (negate_comparison c) i i0) =\noption_map negb (Some (Int64.cmpu c i i0)).","proofString":"rewrite Int64.negate_cmpu.\nauto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int64) (SF : Archi.ptr64 = true) : Some (negb (Int64.cmpu c i i0)) = option_map negb (Some (Int64.cmpu c i i0)).","proofString":"auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i : int64) (b : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) : (if negb true\n then None\n else\n  if\n   Int64.eq i Int64.zero &&\n   (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))\n  then cmp_different_blocks (negate_comparison c)\n  else None) =\noption_map negb\n  (if negb true\n   then None\n   else\n    if\n     Int64.eq i Int64.zero &&\n     (valid_ptr b (Ptrofs.unsigned i0)\n      || valid_ptr b (Ptrofs.unsigned i0 - 1))\n    then cmp_different_blocks c\n    else None).","proofString":"simpl.\ndestruct (Int64.eq i Int64.zero && (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i : int64) (b : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) : (if\n  Int64.eq i Int64.zero &&\n  (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))\n then cmp_different_blocks (negate_comparison c)\n else None) =\noption_map negb\n  (if\n    Int64.eq i Int64.zero &&\n    (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))\n   then cmp_different_blocks c\n   else None).","proofString":"destruct (Int64.eq i Int64.zero && (valid_ptr b (Ptrofs.unsigned i0) || valid_ptr b (Ptrofs.unsigned i0 - 1))); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (i0 : int64) (SF : Archi.ptr64 = true) : (if negb true\n then None\n else\n  if\n   Int64.eq i0 Int64.zero &&\n   (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n  then cmp_different_blocks (negate_comparison c)\n  else None) =\noption_map negb\n  (if negb true\n   then None\n   else\n    if\n     Int64.eq i0 Int64.zero &&\n     (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n    then cmp_different_blocks c\n    else None).","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero && (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (i0 : int64) (SF : Archi.ptr64 = true) : (if\n  Int64.eq i0 Int64.zero &&\n  (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n then cmp_different_blocks (negate_comparison c)\n else None) =\noption_map negb\n  (if\n    Int64.eq i0 Int64.zero &&\n    (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n   then cmp_different_blocks c\n   else None).","proofString":"destruct (Int64.eq i0 Int64.zero && (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) : (if negb true\n then None\n else\n  if eq_block b b0\n  then\n   if\n    (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n    (valid_ptr b0 (Ptrofs.unsigned i0)\n     || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n   then Some (Ptrofs.cmpu (negate_comparison c) i i0)\n   else None\n  else\n   if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n   then cmp_different_blocks (negate_comparison c)\n   else None) =\noption_map negb\n  (if negb true\n   then None\n   else\n    if eq_block b b0\n    then\n     if\n      (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n      (valid_ptr b0 (Ptrofs.unsigned i0)\n       || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n     then Some (Ptrofs.cmpu c i i0)\n     else None\n    else\n     if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n     then cmp_different_blocks c\n     else None).","proofString":"simpl.\ndestruct (eq_block b b0).\ndestruct ((valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&            (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))).\nrewrite Ptrofs.negate_cmpu.\nauto.\nauto.\ndestruct (valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) : (if eq_block b b0\n then\n  if\n   (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu (negate_comparison c) i i0)\n  else None\n else\n  if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n  then cmp_different_blocks (negate_comparison c)\n  else None) =\noption_map negb\n  (if eq_block b b0\n   then\n    if\n     (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n     (valid_ptr b0 (Ptrofs.unsigned i0)\n      || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n    then Some (Ptrofs.cmpu c i i0)\n    else None\n   else\n    if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n    then cmp_different_blocks c\n    else None).","proofString":"destruct (eq_block b b0).\ndestruct ((valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&            (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))).\nrewrite Ptrofs.negate_cmpu.\nauto.\nauto.\ndestruct (valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) (e : b = b0) : (if\n  (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n  (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n then Some (Ptrofs.cmpu (negate_comparison c) i i0)\n else None) =\noption_map negb\n  (if\n    (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n    (valid_ptr b0 (Ptrofs.unsigned i0)\n     || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n   then Some (Ptrofs.cmpu c i i0)\n   else None).","proofString":"destruct ((valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&            (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))).\nrewrite Ptrofs.negate_cmpu.\nauto.\nauto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) (e : b = b0) : Some (Ptrofs.cmpu (negate_comparison c) i i0) =\noption_map negb (Some (Ptrofs.cmpu c i i0)).","proofString":"rewrite Ptrofs.negate_cmpu.\nauto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) (e : b = b0) : Some (negb (Ptrofs.cmpu c i i0)) =\noption_map negb (Some (Ptrofs.cmpu c i i0)).","proofString":"auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) (e : b = b0) : None = option_map negb None.","proofString":"auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) (n : b <> b0) : (if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n then cmp_different_blocks (negate_comparison c)\n else None) =\noption_map negb\n  (if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n   then cmp_different_blocks c\n   else None).","proofString":"destruct (valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)); auto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int64) (SF : Archi.ptr64 = false) : Some (Int64.cmpu (negate_comparison c) i i0) =\noption_map negb (Some (Int64.cmpu c i i0)).","proofString":"rewrite Int64.negate_cmpu.\nauto."},{"statement":"(H : forall c0 : comparison,\ncmp_different_blocks (negate_comparison c0) =\noption_map negb (cmp_different_blocks c0)) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int64) (SF : Archi.ptr64 = false) : Some (negb (Int64.cmpu c i i0)) = option_map negb (Some (Int64.cmpu c i i0)).","proofString":"auto."},{"statement":"(b : bool) : of_optbool (option_map negb (Some b)) = notbool (of_optbool (Some b)).","proofString":"destruct b; auto."},{"statement":"(c : comparison) (x y : val) : cmp (negate_comparison c) x y = notbool (cmp c x y).","proofString":"unfold cmp.\nrewrite negate_cmp_bool.\napply not_of_optbool."},{"statement":"(c : comparison) (x y : val) : of_optbool (cmp_bool (negate_comparison c) x y) =\nnotbool (of_optbool (cmp_bool c x y)).","proofString":"rewrite negate_cmp_bool.\napply not_of_optbool."},{"statement":"(c : comparison) (x y : val) : of_optbool (option_map negb (cmp_bool c x y)) =\nnotbool (of_optbool (cmp_bool c x y)).","proofString":"apply not_of_optbool."},{"statement":"(valid_ptr : block -> Z -> bool) (c : comparison) (x y : val) : cmpu valid_ptr (negate_comparison c) x y = notbool (cmpu valid_ptr c x y).","proofString":"unfold cmpu.\nrewrite negate_cmpu_bool.\napply not_of_optbool."},{"statement":"(valid_ptr : block -> Z -> bool) (c : comparison) (x y : val) : of_optbool (cmpu_bool valid_ptr (negate_comparison c) x y) =\nnotbool (of_optbool (cmpu_bool valid_ptr c x y)).","proofString":"rewrite negate_cmpu_bool.\napply not_of_optbool."},{"statement":"(valid_ptr : block -> Z -> bool) (c : comparison) (x y : val) : of_optbool (option_map negb (cmpu_bool valid_ptr c x y)) =\nnotbool (of_optbool (cmpu_bool valid_ptr c x y)).","proofString":"apply not_of_optbool."},{"statement":"(c : comparison) (i i0 : int) : Some (Int.cmp (swap_comparison c) i i0) = Some (Int.cmp c i0 i).","proofString":"rewrite Int.swap_cmp.\nauto."},{"statement":"(c : comparison) (i i0 : int) : Some (Int.cmp c i0 i) = Some (Int.cmp c i0 i).","proofString":"auto."},{"statement":"forall c : comparison,\ncmp_different_blocks (swap_comparison c) = cmp_different_blocks c.","proofString":"destruct c; auto."},{"statement":"(E : forall c : comparison,\ncmp_different_blocks (swap_comparison c) = cmp_different_blocks c) : forall (valid_ptr : block -> Z -> bool) (c : comparison) (x y : val),\ncmpu_bool valid_ptr (swap_comparison c) x y = cmpu_bool valid_ptr c y x.","proofString":"intros; unfold cmpu_bool.\nrewrite ! E.\ndestruct Archi.ptr64 eqn:SF, x, y; auto.\nrewrite Int.swap_cmpu.\nauto.\nrewrite Int.swap_cmpu.\nauto.\ndestruct (eq_block b b0); subst.\nrewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto.\nrewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (x y : val) : match x with\n| Vint n1 =>\n    match y with\n    | Vint n2 => Some (Int.cmpu (swap_comparison c) n1 n2)\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks (swap_comparison c)\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match y with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks (swap_comparison c)\n         else None\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu (swap_comparison c) ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks (swap_comparison c)\n          else None\n    | _ => None\n    end\n| _ => None\nend =\nmatch y with\n| Vint n1 =>\n    match x with\n    | Vint n2 => Some (Int.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match x with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend.","proofString":"rewrite ! E.\ndestruct Archi.ptr64 eqn:SF, x, y; auto.\nrewrite Int.swap_cmpu.\nauto.\nrewrite Int.swap_cmpu.\nauto.\ndestruct (eq_block b b0); subst.\nrewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto.\nrewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (x y : val) : match x with\n| Vint n1 =>\n    match y with\n    | Vint n2 => Some (Int.cmpu (swap_comparison c) n1 n2)\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match y with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu (swap_comparison c) ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend =\nmatch y with\n| Vint n1 =>\n    match x with\n    | Vint n2 => Some (Int.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match x with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend.","proofString":"destruct Archi.ptr64 eqn:SF, x, y; auto.\nrewrite Int.swap_cmpu.\nauto.\nrewrite Int.swap_cmpu.\nauto.\ndestruct (eq_block b b0); subst.\nrewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto.\nrewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int) (SF : Archi.ptr64 = true) : Some (Int.cmpu (swap_comparison c) i i0) = Some (Int.cmpu c i0 i).","proofString":"rewrite Int.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int) (SF : Archi.ptr64 = true) : Some (Int.cmpu c i0 i) = Some (Int.cmpu c i0 i).","proofString":"auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int) (SF : Archi.ptr64 = false) : Some (Int.cmpu (swap_comparison c) i i0) = Some (Int.cmpu c i0 i).","proofString":"rewrite Int.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int) (SF : Archi.ptr64 = false) : Some (Int.cmpu c i0 i) = Some (Int.cmpu c i0 i).","proofString":"auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) : (if eq_block b b0\n then\n  if\n   (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu (swap_comparison c) i i0)\n  else None\n else\n  if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n  then cmp_different_blocks c\n  else None) =\n(if eq_block b0 b\n then\n  if\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) &&\n   (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n  then Some (Ptrofs.cmpu c i0 i)\n  else None\n else\n  if valid_ptr b0 (Ptrofs.unsigned i0) && valid_ptr b (Ptrofs.unsigned i)\n  then cmp_different_blocks c\n  else None).","proofString":"destruct (eq_block b b0); subst.\nrewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto.\nrewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) : (if\n  (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) &&\n  (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n then Some (Ptrofs.cmpu (swap_comparison c) i i0)\n else None) =\n(if eq_block b0 b0\n then\n  if\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) &&\n   (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1))\n  then Some (Ptrofs.cmpu c i0 i)\n  else None\n else\n  if valid_ptr b0 (Ptrofs.unsigned i0) && valid_ptr b0 (Ptrofs.unsigned i)\n  then cmp_different_blocks c\n  else None).","proofString":"rewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) : (if\n  (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) &&\n  (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n then Some (Ptrofs.cmpu (swap_comparison c) i i0)\n else None) =\n(if\n  (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) &&\n  (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1))\n then Some (Ptrofs.cmpu c i0 i)\n else None).","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) : Some (Ptrofs.cmpu (swap_comparison c) i i0) = Some (Ptrofs.cmpu c i0 i).","proofString":"rewrite Ptrofs.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) : Some (Ptrofs.cmpu c i0 i) = Some (Ptrofs.cmpu c i0 i).","proofString":"auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) (n : b <> b0) : (if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n then cmp_different_blocks c\n else None) =\n(if eq_block b0 b\n then\n  if\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) &&\n   (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n  then Some (Ptrofs.cmpu c i0 i)\n  else None\n else\n  if valid_ptr b0 (Ptrofs.unsigned i0) && valid_ptr b (Ptrofs.unsigned i)\n  then cmp_different_blocks c\n  else None).","proofString":"rewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = false) (n : b <> b0) : (if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n then cmp_different_blocks c\n else None) =\n(if valid_ptr b0 (Ptrofs.unsigned i0) && valid_ptr b (Ptrofs.unsigned i)\n then cmp_different_blocks c\n else None).","proofString":"destruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto."},{"statement":"(c : comparison) (i i0 : int64) : Some (Int64.cmp (swap_comparison c) i i0) = Some (Int64.cmp c i0 i).","proofString":"rewrite Int64.swap_cmp.\nauto."},{"statement":"(c : comparison) (i i0 : int64) : Some (Int64.cmp c i0 i) = Some (Int64.cmp c i0 i).","proofString":"auto."},{"statement":"forall c : comparison,\ncmp_different_blocks (swap_comparison c) = cmp_different_blocks c.","proofString":"destruct c; auto."},{"statement":"(E : forall c : comparison,\ncmp_different_blocks (swap_comparison c) = cmp_different_blocks c) : forall (valid_ptr : block -> Z -> bool) (c : comparison) (x y : val),\ncmplu_bool valid_ptr (swap_comparison c) x y = cmplu_bool valid_ptr c y x.","proofString":"intros; unfold cmplu_bool.\nrewrite ! E.\ndestruct Archi.ptr64 eqn:SF, x, y; auto.\nrewrite Int64.swap_cmpu.\nauto.\ndestruct (eq_block b b0); subst.\nrewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto.\nrewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto.\nrewrite Int64.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (x y : val) : match x with\n| Vlong n1 =>\n    match y with\n    | Vlong n2 => Some (Int64.cmpu (swap_comparison c) n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks (swap_comparison c)\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match y with\n    | Vlong n2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks (swap_comparison c)\n         else None\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu (swap_comparison c) ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks (swap_comparison c)\n          else None\n    | _ => None\n    end\n| _ => None\nend =\nmatch y with\n| Vlong n1 =>\n    match x with\n    | Vlong n2 => Some (Int64.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match x with\n    | Vlong n2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend.","proofString":"rewrite ! E.\ndestruct Archi.ptr64 eqn:SF, x, y; auto.\nrewrite Int64.swap_cmpu.\nauto.\ndestruct (eq_block b b0); subst.\nrewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto.\nrewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto.\nrewrite Int64.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (x y : val) : match x with\n| Vlong n1 =>\n    match y with\n    | Vlong n2 => Some (Int64.cmpu (swap_comparison c) n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match y with\n    | Vlong n2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu (swap_comparison c) ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend =\nmatch y with\n| Vlong n1 =>\n    match x with\n    | Vlong n2 => Some (Int64.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match x with\n    | Vlong n2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend.","proofString":"destruct Archi.ptr64 eqn:SF, x, y; auto.\nrewrite Int64.swap_cmpu.\nauto.\ndestruct (eq_block b b0); subst.\nrewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto.\nrewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto.\nrewrite Int64.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int64) (SF : Archi.ptr64 = true) : Some (Int64.cmpu (swap_comparison c) i i0) = Some (Int64.cmpu c i0 i).","proofString":"rewrite Int64.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int64) (SF : Archi.ptr64 = true) : Some (Int64.cmpu c i0 i) = Some (Int64.cmpu c i0 i).","proofString":"auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) : (if negb true\n then None\n else\n  if eq_block b b0\n  then\n   if\n    (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1)) &&\n    (valid_ptr b0 (Ptrofs.unsigned i0)\n     || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n   then Some (Ptrofs.cmpu (swap_comparison c) i i0)\n   else None\n  else\n   if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n   then cmp_different_blocks c\n   else None) =\n(if negb true\n then None\n else\n  if eq_block b0 b\n  then\n   if\n    (valid_ptr b0 (Ptrofs.unsigned i0)\n     || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) &&\n    (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n   then Some (Ptrofs.cmpu c i0 i)\n   else None\n  else\n   if valid_ptr b0 (Ptrofs.unsigned i0) && valid_ptr b (Ptrofs.unsigned i)\n   then cmp_different_blocks c\n   else None).","proofString":"destruct (eq_block b b0); subst.\nrewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto.\nrewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) : (if negb true\n then None\n else\n  if\n   (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu (swap_comparison c) i i0)\n  else None) =\n(if negb true\n then None\n else\n  if eq_block b0 b0\n  then\n   if\n    (valid_ptr b0 (Ptrofs.unsigned i0)\n     || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) &&\n    (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1))\n   then Some (Ptrofs.cmpu c i0 i)\n   else None\n  else\n   if valid_ptr b0 (Ptrofs.unsigned i0) && valid_ptr b0 (Ptrofs.unsigned i)\n   then cmp_different_blocks c\n   else None).","proofString":"rewrite dec_eq_true.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) : (if negb true\n then None\n else\n  if\n   (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu (swap_comparison c) i i0)\n  else None) =\n(if negb true\n then None\n else\n  if\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) &&\n   (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1))\n  then Some (Ptrofs.cmpu c i0 i)\n  else None).","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1));  destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1));  simpl; auto.\nrewrite Ptrofs.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) : Some (Ptrofs.cmpu (swap_comparison c) i i0) = Some (Ptrofs.cmpu c i0 i).","proofString":"rewrite Ptrofs.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) : Some (Ptrofs.cmpu c i0 i) = Some (Ptrofs.cmpu c i0 i).","proofString":"auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) (n : b <> b0) : (if negb true\n then None\n else\n  if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n  then cmp_different_blocks c\n  else None) =\n(if negb true\n then None\n else\n  if eq_block b0 b\n  then\n   if\n    (valid_ptr b0 (Ptrofs.unsigned i0)\n     || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) &&\n    (valid_ptr b (Ptrofs.unsigned i) || valid_ptr b (Ptrofs.unsigned i - 1))\n   then Some (Ptrofs.cmpu c i0 i)\n   else None\n  else\n   if valid_ptr b0 (Ptrofs.unsigned i0) && valid_ptr b (Ptrofs.unsigned i)\n   then cmp_different_blocks c\n   else None).","proofString":"rewrite dec_eq_false by auto.\ndestruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (SF : Archi.ptr64 = true) (n : b <> b0) : (if negb true\n then None\n else\n  if valid_ptr b (Ptrofs.unsigned i) && valid_ptr b0 (Ptrofs.unsigned i0)\n  then cmp_different_blocks c\n  else None) =\n(if negb true\n then None\n else\n  if valid_ptr b0 (Ptrofs.unsigned i0) && valid_ptr b (Ptrofs.unsigned i)\n  then cmp_different_blocks c\n  else None).","proofString":"destruct (valid_ptr b (Ptrofs.unsigned i));    destruct (valid_ptr b0 (Ptrofs.unsigned i0)); simpl; auto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int64) (SF : Archi.ptr64 = false) : Some (Int64.cmpu (swap_comparison c) i i0) = Some (Int64.cmpu c i0 i).","proofString":"rewrite Int64.swap_cmpu.\nauto."},{"statement":"(E : forall c0 : comparison,\ncmp_different_blocks (swap_comparison c0) = cmp_different_blocks c0) (valid_ptr : block -> Z -> bool) (c : comparison) (i i0 : int64) (SF : Archi.ptr64 = false) : Some (Int64.cmpu c i0 i) = Some (Int64.cmpu c i0 i).","proofString":"auto."},{"statement":"(f f0 : float) : notbool (cmpf Cne (Vfloat f) (Vfloat f0)) = cmpf Ceq (Vfloat f) (Vfloat f0).","proofString":"unfold cmpf, cmpf_bool.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : notbool (of_optbool (Some (Float.cmp Cne f f0))) =\nof_optbool (Some (Float.cmp Ceq f f0)).","proofString":"rewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : notbool (of_optbool (Some (negb (Float.cmp Ceq f f0)))) =\nof_optbool (Some (Float.cmp Ceq f f0)).","proofString":"destruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : notbool (cmpf Ceq (Vfloat f) (Vfloat f0)) = cmpf Cne (Vfloat f) (Vfloat f0).","proofString":"unfold cmpf, cmpf_bool.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : notbool (of_optbool (Some (Float.cmp Ceq f f0))) =\nof_optbool (Some (Float.cmp Cne f f0)).","proofString":"rewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : notbool (of_optbool (Some (Float.cmp Ceq f f0))) =\nof_optbool (Some (negb (Float.cmp Ceq f f0))).","proofString":"destruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : cmpf Cle (Vfloat f) (Vfloat f0) =\nor (cmpf Clt (Vfloat f) (Vfloat f0)) (cmpf Ceq (Vfloat f) (Vfloat f0)).","proofString":"unfold cmpf, cmpf_bool.\nrewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt f f0); destruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : of_optbool (Some (Float.cmp Cle f f0)) =\nor (of_optbool (Some (Float.cmp Clt f f0)))\n  (of_optbool (Some (Float.cmp Ceq f f0))).","proofString":"rewrite Float.cmp_le_lt_eq.\ndestruct (Float.cmp Clt f f0); destruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : of_optbool (Some (Float.cmp Clt f f0 || Float.cmp Ceq f f0)) =\nor (of_optbool (Some (Float.cmp Clt f f0)))\n  (of_optbool (Some (Float.cmp Ceq f f0))).","proofString":"destruct (Float.cmp Clt f f0); destruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : cmpf Cge (Vfloat f) (Vfloat f0) =\nor (cmpf Cgt (Vfloat f) (Vfloat f0)) (cmpf Ceq (Vfloat f) (Vfloat f0)).","proofString":"unfold cmpf, cmpf_bool.\nrewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Cgt f f0); destruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : of_optbool (Some (Float.cmp Cge f f0)) =\nor (of_optbool (Some (Float.cmp Cgt f f0)))\n  (of_optbool (Some (Float.cmp Ceq f f0))).","proofString":"rewrite Float.cmp_ge_gt_eq.\ndestruct (Float.cmp Cgt f f0); destruct (Float.cmp Ceq f f0); auto."},{"statement":"(f f0 : float) : of_optbool (Some (Float.cmp Cgt f f0 || Float.cmp Ceq f f0)) =\nor (of_optbool (Some (Float.cmp Cgt f f0)))\n  (of_optbool (Some (Float.cmp Ceq f f0))).","proofString":"destruct (Float.cmp Cgt f f0); destruct (Float.cmp Ceq f f0); auto."},{"statement":"(ob : option bool) : cmp Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.","proofString":"destruct ob; simpl; auto.\ndestruct b; auto."},{"statement":"(b : bool) : cmp Cne (if b then Vtrue else Vfalse) (Vint Int.zero) =\n(if b then Vtrue else Vfalse).","proofString":"destruct b; auto."},{"statement":"(ob : option bool) : cmp Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.","proofString":"destruct ob; simpl; auto.\ndestruct b; auto."},{"statement":"(b : bool) : cmp Ceq (if b then Vtrue else Vfalse) (Vint Int.one) =\n(if b then Vtrue else Vfalse).","proofString":"destruct b; auto."},{"statement":"(ob : option bool) : cmp Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).","proofString":"destruct ob; simpl; auto.\ndestruct b; auto."},{"statement":"(b : bool) : cmp Ceq (if b then Vtrue else Vfalse) (Vint Int.zero) =\n(if negb b then Vtrue else Vfalse).","proofString":"destruct b; auto."},{"statement":"(ob : option bool) : cmp Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).","proofString":"destruct ob; simpl; auto.\ndestruct b; auto."},{"statement":"(b : bool) : cmp Cne (if b then Vtrue else Vfalse) (Vint Int.one) =\n(if negb b then Vtrue else Vfalse).","proofString":"destruct b; auto."},{"statement":"(valid_ptr : block -> Z -> bool) (ob : option bool) : cmpu valid_ptr Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.","proofString":"destruct ob; simpl; auto.\ndestruct b; auto."},{"statement":"(valid_ptr : block -> Z -> bool) (b : bool) : cmpu valid_ptr Cne (if b then Vtrue else Vfalse) (Vint Int.zero) =\n(if b then Vtrue else Vfalse).","proofString":"destruct b; auto."},{"statement":"(valid_ptr : block -> Z -> bool) (ob : option bool) : cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.","proofString":"destruct ob; simpl; auto.\ndestruct b; auto."},{"statement":"(valid_ptr : block -> Z -> bool) (b : bool) : cmpu valid_ptr Ceq (if b then Vtrue else Vfalse) (Vint Int.one) =\n(if b then Vtrue else Vfalse).","proofString":"destruct b; auto."},{"statement":"(valid_ptr : block -> Z -> bool) (ob : option bool) : cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.zero) =\nof_optbool (option_map negb ob).","proofString":"destruct ob; simpl; auto.\ndestruct b; auto."},{"statement":"(valid_ptr : block -> Z -> bool) (b : bool) : cmpu valid_ptr Ceq (if b then Vtrue else Vfalse) (Vint Int.zero) =\n(if negb b then Vtrue else Vfalse).","proofString":"destruct b; auto."},{"statement":"(valid_ptr : block -> Z -> bool) (ob : option bool) : cmpu valid_ptr Cne (of_optbool ob) (Vint Int.one) =\nof_optbool (option_map negb ob).","proofString":"destruct ob; simpl; auto.\ndestruct b; auto."},{"statement":"(valid_ptr : block -> Z -> bool) (b : bool) : cmpu valid_ptr Cne (if b then Vtrue else Vfalse) (Vint Int.one) =\n(if negb b then Vtrue else Vfalse).","proofString":"destruct b; auto."},{"statement":"(n : Z) (v : val) (H : 0 <= n) : zero_ext n v = and v (Vint (Int.repr (two_p n - 1))).","proofString":"destruct v; simpl; auto.\ndecEq.\napply Int.zero_ext_and; auto."},{"statement":"(n : Z) (i : int) (H : 0 <= n) : Vint (Int.zero_ext n i) = Vint (Int.and i (Int.repr (two_p n - 1))).","proofString":"decEq.\napply Int.zero_ext_and; auto."},{"statement":"(n : Z) (i : int) (H : 0 <= n) : Int.zero_ext n i = Int.and i (Int.repr (two_p n - 1)).","proofString":"apply Int.zero_ext_and; auto."},{"statement":"(n : Z) (v : val) (H : 0 <= n) : zero_ext_l n v = andl v (Vlong (Int64.repr (two_p n - 1))).","proofString":"destruct v; simpl; auto.\ndecEq.\napply Int64.zero_ext_and; auto."},{"statement":"(n : Z) (i : int64) (H : 0 <= n) : Vlong (Int64.zero_ext n i) = Vlong (Int64.and i (Int64.repr (two_p n - 1))).","proofString":"decEq.\napply Int64.zero_ext_and; auto."},{"statement":"(n : Z) (i : int64) (H : 0 <= n) : Int64.zero_ext n i = Int64.and i (Int64.repr (two_p n - 1)).","proofString":"apply Int64.zero_ext_and; auto."},{"statement":"(v : val) : rolm v Int.one Int.one = cmp Clt v (Vint Int.zero).","proofString":"unfold cmp, cmp_bool; destruct v; simpl; auto.\ntransitivity (Vint (Int.shru i (Int.repr (Int.zwordsize - 1)))).\ndecEq.\nsymmetry.\nrewrite Int.shru_rolm.\nauto.\nauto.\nrewrite Int.shru_lt_zero.\ndestruct (Int.lt i Int.zero); auto."},{"statement":"(i : int) : Vint (Int.rolm i Int.one Int.one) =\n(if Int.lt i Int.zero then Vtrue else Vfalse).","proofString":"transitivity (Vint (Int.shru i (Int.repr (Int.zwordsize - 1)))).\ndecEq.\nsymmetry.\nrewrite Int.shru_rolm.\nauto.\nauto.\nrewrite Int.shru_lt_zero.\ndestruct (Int.lt i Int.zero); auto."},{"statement":"(i : int) : Vint (Int.rolm i Int.one Int.one) =\nVint (Int.shru i (Int.repr (Int.zwordsize - 1))).","proofString":"decEq.\nsymmetry.\nrewrite Int.shru_rolm.\nauto.\nauto."},{"statement":"(i : int) : Int.rolm i Int.one Int.one = Int.shru i (Int.repr (Int.zwordsize - 1)).","proofString":"symmetry.\nrewrite Int.shru_rolm.\nauto.\nauto."},{"statement":"(i : int) : Int.shru i (Int.repr (Int.zwordsize - 1)) = Int.rolm i Int.one Int.one.","proofString":"rewrite Int.shru_rolm.\nauto.\nauto."},{"statement":"(i : int) : Int.rolm i (Int.sub Int.iwordsize (Int.repr (Int.zwordsize - 1)))\n  (Int.shru Int.mone (Int.repr (Int.zwordsize - 1))) =\nInt.rolm i Int.one Int.one.","proofString":"auto."},{"statement":"(i : int) : Int.ltu (Int.repr (Int.zwordsize - 1)) Int.iwordsize = true.","proofString":"auto."},{"statement":"(i : int) : Vint (Int.shru i (Int.repr (Int.zwordsize - 1))) =\n(if Int.lt i Int.zero then Vtrue else Vfalse).","proofString":"rewrite Int.shru_lt_zero.\ndestruct (Int.lt i Int.zero); auto."},{"statement":"(i : int) : Vint (if Int.lt i Int.zero then Int.one else Int.zero) =\n(if Int.lt i Int.zero then Vtrue else Vfalse).","proofString":"destruct (Int.lt i Int.zero); auto."},{"statement":"(v : val) : xor (rolm v Int.one Int.one) (Vint Int.one) = cmp Cge v (Vint Int.zero).","proofString":"rewrite rolm_lt_zero.\ndestruct v; simpl; auto.\nunfold cmp; simpl.\ndestruct (Int.lt i Int.zero); auto."},{"statement":"(v : val) : xor (cmp Clt v (Vint Int.zero)) (Vint Int.one) = cmp Cge v (Vint Int.zero).","proofString":"destruct v; simpl; auto.\nunfold cmp; simpl.\ndestruct (Int.lt i Int.zero); auto."},{"statement":"(i : int) : xor (cmp Clt (Vint i) (Vint Int.zero)) (Vint Int.one) =\ncmp Cge (Vint i) (Vint Int.zero).","proofString":"unfold cmp; simpl.\ndestruct (Int.lt i Int.zero); auto."},{"statement":"(i : int) : xor (if Int.lt i Int.zero then Vtrue else Vfalse) (Vint Int.one) =\n(if negb (Int.lt i Int.zero) then Vtrue else Vfalse).","proofString":"destruct (Int.lt i Int.zero); auto."},{"statement":"(v1 v2 : val) (H : v1 = v2) : lessdef v1 v2.","proofString":"subst v2.\nconstructor."},{"statement":"(v1 : val) : lessdef v1 v1.","proofString":"constructor."},{"statement":"(v1 v2 v3 : val) (H : lessdef v1 v2) (H0 : lessdef v2 v3) : lessdef v1 v3.","proofString":"inv H.\nauto.\nconstructor."},{"statement":"(v2 v3 : val) (H0 : lessdef v2 v3) : lessdef v2 v3.","proofString":"auto."},{"statement":"(v2 v3 : val) (H0 : lessdef v2 v3) : lessdef Vundef v3.","proofString":"constructor."},{"statement":"(v1 v2 : val) (vl1 vl2 : list val) (H : lessdef v1 v2) (H0 : lessdef_list vl1 vl2) (IHlessdef_list : vl1 = vl2 \\/ In Vundef vl1) : v1 :: vl1 = v2 :: vl2 \\/ v1 = Vundef \\/ In Vundef vl1.","proofString":"inv H.\ndestruct IHlessdef_list.\nleft; congruence.\ntauto.\ntauto."},{"statement":"(v2 : val) (vl1 vl2 : list val) (H0 : lessdef_list vl1 vl2) (IHlessdef_list : vl1 = vl2 \\/ In Vundef vl1) : v2 :: vl1 = v2 :: vl2 \\/ v2 = Vundef \\/ In Vundef vl1.","proofString":"destruct IHlessdef_list.\nleft; congruence.\ntauto."},{"statement":"(v2 : val) (vl1 vl2 : list val) (H0 : lessdef_list vl1 vl2) (H : vl1 = vl2) : v2 :: vl1 = v2 :: vl2 \\/ v2 = Vundef \\/ In Vundef vl1.","proofString":"left; congruence."},{"statement":"(v2 : val) (vl1 vl2 : list val) (H0 : lessdef_list vl1 vl2) (H : In Vundef vl1) : v2 :: vl1 = v2 :: vl2 \\/ v2 = Vundef \\/ In Vundef vl1.","proofString":"tauto."},{"statement":"(v2 : val) (vl1 vl2 : list val) (H0 : lessdef_list vl1 vl2) (IHlessdef_list : vl1 = vl2 \\/ In Vundef vl1) : Vundef :: vl1 = v2 :: vl2 \\/ Vundef = Vundef \\/ In Vundef vl1.","proofString":"tauto."},{"statement":"(chunk : memory_chunk) (v1 v2 : val) (H : lessdef v1 v2) : lessdef (load_result chunk v1) (load_result chunk v2).","proofString":"inv H.\nauto.\ndestruct chunk; simpl; auto."},{"statement":"(chunk : memory_chunk) (v2 : val) : lessdef (load_result chunk v2) (load_result chunk v2).","proofString":"auto."},{"statement":"(chunk : memory_chunk) (v2 : val) : lessdef (load_result chunk Vundef) (load_result chunk v2).","proofString":"destruct chunk; simpl; auto."},{"statement":"(v : val) : lessdef (if is_bool v then v else Vundef) v.","proofString":"destruct is_bool; auto."},{"statement":"(v1 v1' v2 v2' : val) (H : lessdef v1 v1') (H0 : lessdef v2 v2') : lessdef (add v1 v2) (add v1' v2').","proofString":"inv H.\ninv H0.\nauto.\ndestruct v1'; simpl; auto.\nsimpl; auto."},{"statement":"(v1' v2 v2' : val) (H0 : lessdef v2 v2') : lessdef (add v1' v2) (add v1' v2').","proofString":"inv H0.\nauto.\ndestruct v1'; simpl; auto."},{"statement":"(v1' v2' : val) : lessdef (add v1' v2') (add v1' v2').","proofString":"auto."},{"statement":"(v1' v2' : val) : lessdef (add v1' Vundef) (add v1' v2').","proofString":"destruct v1'; simpl; auto."},{"statement":"(v1' v2 v2' : val) (H0 : lessdef v2 v2') : lessdef (add Vundef v2) (add v1' v2').","proofString":"simpl; auto."},{"statement":"(v1 v1' v2 v2' : val) (H : lessdef v1 v1') (H0 : lessdef v2 v2') : lessdef (addl v1 v2) (addl v1' v2').","proofString":"inv H.\ninv H0.\nauto.\ndestruct v1'; simpl; auto.\nsimpl; auto."},{"statement":"(v1' v2 v2' : val) (H0 : lessdef v2 v2') : lessdef (addl v1' v2) (addl v1' v2').","proofString":"inv H0.\nauto.\ndestruct v1'; simpl; auto."},{"statement":"(v1' v2' : val) : lessdef (addl v1' v2') (addl v1' v2').","proofString":"auto."},{"statement":"(v1' v2' : val) : lessdef (addl v1' Vundef) (addl v1' v2').","proofString":"destruct v1'; simpl; auto."},{"statement":"(v1' v2 v2' : val) (H0 : lessdef v2 v2') : lessdef (addl Vundef v2) (addl v1' v2').","proofString":"simpl; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmpu_bool valid_ptr c v1 v2 = Some b) : cmpu_bool valid_ptr' c v1' v2' = Some b.","proofString":"assert (X: forall b ofs,             valid_ptr b ofs || valid_ptr b (ofs - 1) = true ->             valid_ptr' b ofs || valid_ptr' b (ofs - 1) = true).\nintros.\napply orb_true_intro.\ndestruct (orb_prop _ _ H3).\nrewrite (H b0 ofs); auto.\nrewrite (H b0 (ofs - 1)); auto.\ninv H0; [ | discriminate].\ninv H1; [ | destruct v1'; discriminate ].\nunfold cmpu_bool in *.\nremember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int.eq i Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int.eq i0 Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmpu_bool valid_ptr c v1 v2 = Some b) : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true.","proofString":"intros.\napply orb_true_intro.\ndestruct (orb_prop _ _ H3).\nrewrite (H b0 ofs); auto.\nrewrite (H b0 (ofs - 1)); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b1 : block) (ofs0 : Z),\nvalid_ptr b1 ofs0 = true -> valid_ptr' b1 ofs0 = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmpu_bool valid_ptr c v1 v2 = Some b) (b0 : block) (ofs : Z) (H3 : valid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true) : valid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true.","proofString":"apply orb_true_intro.\ndestruct (orb_prop _ _ H3).\nrewrite (H b0 ofs); auto.\nrewrite (H b0 (ofs - 1)); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b1 : block) (ofs0 : Z),\nvalid_ptr b1 ofs0 = true -> valid_ptr' b1 ofs0 = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmpu_bool valid_ptr c v1 v2 = Some b) (b0 : block) (ofs : Z) (H3 : valid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true) : valid_ptr' b0 ofs = true \\/ valid_ptr' b0 (ofs - 1) = true.","proofString":"destruct (orb_prop _ _ H3).\nrewrite (H b0 ofs); auto.\nrewrite (H b0 (ofs - 1)); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b1 : block) (ofs0 : Z),\nvalid_ptr b1 ofs0 = true -> valid_ptr' b1 ofs0 = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmpu_bool valid_ptr c v1 v2 = Some b) (b0 : block) (ofs : Z) (H3 : valid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true) (H4 : valid_ptr b0 ofs = true) : valid_ptr' b0 ofs = true \\/ valid_ptr' b0 (ofs - 1) = true.","proofString":"rewrite (H b0 ofs); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b1 : block) (ofs0 : Z),\nvalid_ptr b1 ofs0 = true -> valid_ptr' b1 ofs0 = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmpu_bool valid_ptr c v1 v2 = Some b) (b0 : block) (ofs : Z) (H3 : valid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true) (H4 : valid_ptr b0 (ofs - 1) = true) : valid_ptr' b0 ofs = true \\/ valid_ptr' b0 (ofs - 1) = true.","proofString":"rewrite (H b0 (ofs - 1)); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmpu_bool valid_ptr c v1 v2 = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : cmpu_bool valid_ptr' c v1' v2' = Some b.","proofString":"inv H0; [ | discriminate].\ninv H1; [ | destruct v1'; discriminate ].\nunfold cmpu_bool in *.\nremember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int.eq i Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int.eq i0 Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1' v2 v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H1 : lessdef v2 v2') (H2 : cmpu_bool valid_ptr c v1' v2 = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : cmpu_bool valid_ptr' c v1' v2' = Some b.","proofString":"inv H1; [ | destruct v1'; discriminate ].\nunfold cmpu_bool in *.\nremember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int.eq i Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int.eq i0 Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1' v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H2 : cmpu_bool valid_ptr c v1' v2' = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : cmpu_bool valid_ptr' c v1' v2' = Some b.","proofString":"unfold cmpu_bool in *.\nremember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int.eq i Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int.eq i0 Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1' v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H2 : match v1' with\n| Vint n1 =>\n    match v2' with\n    | Vint n2 => Some (Int.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2' with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : match v1' with\n| Vint n1 =>\n    match v2' with\n    | Vint n2 => Some (Int.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (valid_ptr' b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr' b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2' with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (valid_ptr' b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr' b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr' b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr' b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr' b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr' b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr' b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr' b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"remember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int.eq i Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int.eq i0 Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1' v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (H2 : match v1' with\n| Vint n1 =>\n    match v2' with\n    | Vint n2 => Some (Int.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2' with\n    | Vint n2 =>\n        if ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : match v1' with\n| Vint n1 =>\n    match v2' with\n    | Vint n2 => Some (Int.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (valid_ptr' b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr' b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2' with\n    | Vint n2 =>\n        if ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (valid_ptr' b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr' b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr' b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr' b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr' b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr' b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr' b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr' b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int.eq i Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int.eq i0 Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : int) (b0 : block) (i0 : ptrofs) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : false = Archi.ptr64) (H2 : (if\n  Int.eq i Int.zero &&\n  (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n then cmp_different_blocks c\n else None) = Some b) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) : (if\n  Int.eq i Int.zero &&\n  (valid_ptr' b0 (Ptrofs.unsigned i0)\n   || valid_ptr' b0 (Ptrofs.unsigned i0 - 1))\n then cmp_different_blocks c\n else None) = Some b.","proofString":"destruct (Int.eq i Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : int) (b0 : block) (i0 : ptrofs) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : false = Archi.ptr64) (H2 : (if\n  true &&\n  (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n then cmp_different_blocks c\n else None) = Some b) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) : (if\n  true &&\n  (valid_ptr' b0 (Ptrofs.unsigned i0)\n   || valid_ptr' b0 (Ptrofs.unsigned i0 - 1))\n then cmp_different_blocks c\n else None) = Some b.","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : int) (b0 : block) (i0 : ptrofs) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : false = Archi.ptr64) (A : valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1) =\ntrue) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) (H1 : cmp_different_blocks c = Some b) : (if\n  true &&\n  (valid_ptr' b0 (Ptrofs.unsigned i0)\n   || valid_ptr' b0 (Ptrofs.unsigned i0 - 1))\n then cmp_different_blocks c\n else None) = cmp_different_blocks c.","proofString":"rewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (i0 : int) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : false = Archi.ptr64) (H2 : (if\n  Int.eq i0 Int.zero &&\n  (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1))\n then cmp_different_blocks c\n else None) = Some b) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) : (if\n  Int.eq i0 Int.zero &&\n  (valid_ptr' b0 (Ptrofs.unsigned i) || valid_ptr' b0 (Ptrofs.unsigned i - 1))\n then cmp_different_blocks c\n else None) = Some b.","proofString":"destruct (Int.eq i0 Int.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (i0 : int) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : false = Archi.ptr64) (H2 : (if\n  true &&\n  (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1))\n then cmp_different_blocks c\n else None) = Some b) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) : (if\n  true &&\n  (valid_ptr' b0 (Ptrofs.unsigned i) || valid_ptr' b0 (Ptrofs.unsigned i - 1))\n then cmp_different_blocks c\n else None) = Some b.","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (i0 : int) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : false = Archi.ptr64) (A : valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1) =\ntrue) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) (H1 : cmp_different_blocks c = Some b) : (if\n  true &&\n  (valid_ptr' b0 (Ptrofs.unsigned i) || valid_ptr' b0 (Ptrofs.unsigned i - 1))\n then cmp_different_blocks c\n else None) = cmp_different_blocks c.","proofString":"rewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : false = Archi.ptr64) (H2 : (if eq_block b0 b1\n then\n  if\n   (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr b1 (Ptrofs.unsigned i0)\n    || valid_ptr b1 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu c i i0)\n  else None\n else\n  if valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)\n  then cmp_different_blocks c\n  else None) = Some b) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) : (if eq_block b0 b1\n then\n  if\n   (valid_ptr' b0 (Ptrofs.unsigned i)\n    || valid_ptr' b0 (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr' b1 (Ptrofs.unsigned i0)\n    || valid_ptr' b1 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu c i i0)\n  else None\n else\n  if valid_ptr' b0 (Ptrofs.unsigned i) && valid_ptr' b1 (Ptrofs.unsigned i0)\n  then cmp_different_blocks c\n  else None) = Some b.","proofString":"destruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : false = Archi.ptr64) (e : b0 = b1) (H2 : (if\n  (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) &&\n  (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1))\n then Some (Ptrofs.cmpu c i i0)\n else None) = Some b) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) : (if\n  (valid_ptr' b0 (Ptrofs.unsigned i) || valid_ptr' b0 (Ptrofs.unsigned i - 1)) &&\n  (valid_ptr' b1 (Ptrofs.unsigned i0)\n   || valid_ptr' b1 (Ptrofs.unsigned i0 - 1))\n then Some (Ptrofs.cmpu c i i0)\n else None) = Some b.","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (Heqptr64 : false = Archi.ptr64) (A : valid_ptr b1 (Ptrofs.unsigned i) || valid_ptr b1 (Ptrofs.unsigned i - 1) =\ntrue) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) (H1 : (if\n  valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)\n then Some (Ptrofs.cmpu c i i0)\n else None) = Some b) : (if\n  (valid_ptr' b1 (Ptrofs.unsigned i) || valid_ptr' b1 (Ptrofs.unsigned i - 1)) &&\n  (valid_ptr' b1 (Ptrofs.unsigned i0)\n   || valid_ptr' b1 (Ptrofs.unsigned i0 - 1))\n then Some (Ptrofs.cmpu c i i0)\n else None) =\n(if\n  valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)\n then Some (Ptrofs.cmpu c i i0)\n else None).","proofString":"destruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : ptrofs) (b1 : block) (i0 : ptrofs) (H : forall (b : block) (ofs : Z),\nvalid_ptr b ofs = true -> valid_ptr' b ofs = true) (Heqptr64 : false = Archi.ptr64) (A : valid_ptr b1 (Ptrofs.unsigned i) || valid_ptr b1 (Ptrofs.unsigned i - 1) =\ntrue) (X : forall (b : block) (ofs : Z),\nvalid_ptr b ofs || valid_ptr b (ofs - 1) = true ->\nvalid_ptr' b ofs || valid_ptr' b (ofs - 1) = true) (B : valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1) =\ntrue) : (if\n  (valid_ptr' b1 (Ptrofs.unsigned i) || valid_ptr' b1 (Ptrofs.unsigned i - 1)) &&\n  (valid_ptr' b1 (Ptrofs.unsigned i0)\n   || valid_ptr' b1 (Ptrofs.unsigned i0 - 1))\n then Some (Ptrofs.cmpu c i i0)\n else None) = Some (Ptrofs.cmpu c i i0).","proofString":"rewrite ! X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : false = Archi.ptr64) (n : b0 <> b1) (H2 : (if valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)\n then cmp_different_blocks c\n else None) = Some b) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) : (if valid_ptr' b0 (Ptrofs.unsigned i) && valid_ptr' b1 (Ptrofs.unsigned i0)\n then cmp_different_blocks c\n else None) = Some b.","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : false = Archi.ptr64) (n : b0 <> b1) (A : valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0) = true) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) (H1 : cmp_different_blocks c = Some b) : (if valid_ptr' b0 (Ptrofs.unsigned i) && valid_ptr' b1 (Ptrofs.unsigned i0)\n then cmp_different_blocks c\n else None) = cmp_different_blocks c.","proofString":"InvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : false = Archi.ptr64) (n : b0 <> b1) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) (H1 : cmp_different_blocks c = Some b) (H0 : valid_ptr b0 (Ptrofs.unsigned i) = true) (H2 : valid_ptr b1 (Ptrofs.unsigned i0) = true) : (if valid_ptr' b0 (Ptrofs.unsigned i) && valid_ptr' b1 (Ptrofs.unsigned i0)\n then cmp_different_blocks c\n else None) = cmp_different_blocks c.","proofString":"rewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmplu_bool valid_ptr c v1 v2 = Some b) : cmplu_bool valid_ptr' c v1' v2' = Some b.","proofString":"assert (X: forall b ofs,             valid_ptr b ofs || valid_ptr b (ofs - 1) = true ->             valid_ptr' b ofs || valid_ptr' b (ofs - 1) = true).\nintros.\napply orb_true_intro.\ndestruct (orb_prop _ _ H3).\nrewrite (H b0 ofs); auto.\nrewrite (H b0 (ofs - 1)); auto.\ninv H0; [ | discriminate].\ninv H1; [ | destruct v1'; discriminate ].\nunfold cmplu_bool in *.\nremember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int64.eq i Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int64.eq i0 Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmplu_bool valid_ptr c v1 v2 = Some b) : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true.","proofString":"intros.\napply orb_true_intro.\ndestruct (orb_prop _ _ H3).\nrewrite (H b0 ofs); auto.\nrewrite (H b0 (ofs - 1)); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b1 : block) (ofs0 : Z),\nvalid_ptr b1 ofs0 = true -> valid_ptr' b1 ofs0 = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmplu_bool valid_ptr c v1 v2 = Some b) (b0 : block) (ofs : Z) (H3 : valid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true) : valid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true.","proofString":"apply orb_true_intro.\ndestruct (orb_prop _ _ H3).\nrewrite (H b0 ofs); auto.\nrewrite (H b0 (ofs - 1)); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b1 : block) (ofs0 : Z),\nvalid_ptr b1 ofs0 = true -> valid_ptr' b1 ofs0 = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmplu_bool valid_ptr c v1 v2 = Some b) (b0 : block) (ofs : Z) (H3 : valid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true) : valid_ptr' b0 ofs = true \\/ valid_ptr' b0 (ofs - 1) = true.","proofString":"destruct (orb_prop _ _ H3).\nrewrite (H b0 ofs); auto.\nrewrite (H b0 (ofs - 1)); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b1 : block) (ofs0 : Z),\nvalid_ptr b1 ofs0 = true -> valid_ptr' b1 ofs0 = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmplu_bool valid_ptr c v1 v2 = Some b) (b0 : block) (ofs : Z) (H3 : valid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true) (H4 : valid_ptr b0 ofs = true) : valid_ptr' b0 ofs = true \\/ valid_ptr' b0 (ofs - 1) = true.","proofString":"rewrite (H b0 ofs); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b1 : block) (ofs0 : Z),\nvalid_ptr b1 ofs0 = true -> valid_ptr' b1 ofs0 = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmplu_bool valid_ptr c v1 v2 = Some b) (b0 : block) (ofs : Z) (H3 : valid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true) (H4 : valid_ptr b0 (ofs - 1) = true) : valid_ptr' b0 ofs = true \\/ valid_ptr' b0 (ofs - 1) = true.","proofString":"rewrite (H b0 (ofs - 1)); auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1 v1' v2 v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') (H2 : cmplu_bool valid_ptr c v1 v2 = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : cmplu_bool valid_ptr' c v1' v2' = Some b.","proofString":"inv H0; [ | discriminate].\ninv H1; [ | destruct v1'; discriminate ].\nunfold cmplu_bool in *.\nremember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int64.eq i Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int64.eq i0 Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1' v2 v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H1 : lessdef v2 v2') (H2 : cmplu_bool valid_ptr c v1' v2 = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : cmplu_bool valid_ptr' c v1' v2' = Some b.","proofString":"inv H1; [ | destruct v1'; discriminate ].\nunfold cmplu_bool in *.\nremember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int64.eq i Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int64.eq i0 Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1' v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H2 : cmplu_bool valid_ptr c v1' v2' = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : cmplu_bool valid_ptr' c v1' v2' = Some b.","proofString":"unfold cmplu_bool in *.\nremember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int64.eq i Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int64.eq i0 Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1' v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (H2 : match v1' with\n| Vlong n1 =>\n    match v2' with\n    | Vlong n2 => Some (Int64.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2' with\n    | Vlong n2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : match v1' with\n| Vlong n1 =>\n    match v2' with\n    | Vlong n2 => Some (Int64.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (valid_ptr' b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr' b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2' with\n    | Vlong n2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (valid_ptr' b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr' b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr' b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr' b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr' b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr' b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr' b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr' b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"remember Archi.ptr64 as ptr64.\ndestruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int64.eq i Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int64.eq i0 Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (v1' v2' : val) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (H2 : match v1' with\n| Vlong n1 =>\n    match v2' with\n    | Vlong n2 => Some (Int64.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (valid_ptr b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2' with\n    | Vlong n2 =>\n        if negb ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (valid_ptr b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if negb ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some b) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) : match v1' with\n| Vlong n1 =>\n    match v2' with\n    | Vlong n2 => Some (Int64.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (valid_ptr' b2 (Ptrofs.unsigned ofs2)\n           || valid_ptr' b2 (Ptrofs.unsigned ofs2 - 1))\n         then cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match v2' with\n    | Vlong n2 =>\n        if negb ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (valid_ptr' b1 (Ptrofs.unsigned ofs1)\n           || valid_ptr' b1 (Ptrofs.unsigned ofs1 - 1))\n         then cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if negb ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (valid_ptr' b1 (Ptrofs.unsigned ofs1)\n            || valid_ptr' b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (valid_ptr' b2 (Ptrofs.unsigned ofs2)\n            || valid_ptr' b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           valid_ptr' b1 (Ptrofs.unsigned ofs1) &&\n           valid_ptr' b2 (Ptrofs.unsigned ofs2)\n          then cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct v1'; auto; destruct v2'; auto; destruct ptr64; auto.\ndestruct (Int64.eq i Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (Int64.eq i0 Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto.\ndestruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : int64) (b0 : block) (i0 : ptrofs) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : true = Archi.ptr64) (H2 : (if negb true\n then None\n else\n  if\n   Int64.eq i Int64.zero &&\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n  then cmp_different_blocks c\n  else None) = Some b) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) : (if negb true\n then None\n else\n  if\n   Int64.eq i Int64.zero &&\n   (valid_ptr' b0 (Ptrofs.unsigned i0)\n    || valid_ptr' b0 (Ptrofs.unsigned i0 - 1))\n  then cmp_different_blocks c\n  else None) = Some b.","proofString":"destruct (Int64.eq i Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : int64) (b0 : block) (i0 : ptrofs) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : true = Archi.ptr64) (H2 : (if negb true\n then None\n else\n  if\n   true &&\n   (valid_ptr b0 (Ptrofs.unsigned i0)\n    || valid_ptr b0 (Ptrofs.unsigned i0 - 1))\n  then cmp_different_blocks c\n  else None) = Some b) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) : (if negb true\n then None\n else\n  if\n   true &&\n   (valid_ptr' b0 (Ptrofs.unsigned i0)\n    || valid_ptr' b0 (Ptrofs.unsigned i0 - 1))\n  then cmp_different_blocks c\n  else None) = Some b.","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1)) eqn:A; inv H2.\nrewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : int64) (b0 : block) (i0 : ptrofs) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : true = Archi.ptr64) (A : valid_ptr b0 (Ptrofs.unsigned i0) || valid_ptr b0 (Ptrofs.unsigned i0 - 1) =\ntrue) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) (H1 : cmp_different_blocks c = Some b) : (if negb true\n then None\n else\n  if\n   true &&\n   (valid_ptr' b0 (Ptrofs.unsigned i0)\n    || valid_ptr' b0 (Ptrofs.unsigned i0 - 1))\n  then cmp_different_blocks c\n  else None) = cmp_different_blocks c.","proofString":"rewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (i0 : int64) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : true = Archi.ptr64) (H2 : (if negb true\n then None\n else\n  if\n   Int64.eq i0 Int64.zero &&\n   (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1))\n  then cmp_different_blocks c\n  else None) = Some b) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) : (if negb true\n then None\n else\n  if\n   Int64.eq i0 Int64.zero &&\n   (valid_ptr' b0 (Ptrofs.unsigned i)\n    || valid_ptr' b0 (Ptrofs.unsigned i - 1))\n  then cmp_different_blocks c\n  else None) = Some b.","proofString":"destruct (Int64.eq i0 Int64.zero); auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (i0 : int64) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : true = Archi.ptr64) (H2 : (if negb true\n then None\n else\n  if\n   true &&\n   (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1))\n  then cmp_different_blocks c\n  else None) = Some b) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) : (if negb true\n then None\n else\n  if\n   true &&\n   (valid_ptr' b0 (Ptrofs.unsigned i)\n    || valid_ptr' b0 (Ptrofs.unsigned i - 1))\n  then cmp_different_blocks c\n  else None) = Some b.","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\nrewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (i0 : int64) (b : bool) (H : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs = true -> valid_ptr' b1 ofs = true) (Heqptr64 : true = Archi.ptr64) (A : valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1) =\ntrue) (X : forall (b1 : block) (ofs : Z),\nvalid_ptr b1 ofs || valid_ptr b1 (ofs - 1) = true ->\nvalid_ptr' b1 ofs || valid_ptr' b1 (ofs - 1) = true) (H1 : cmp_different_blocks c = Some b) : (if negb true\n then None\n else\n  if\n   true &&\n   (valid_ptr' b0 (Ptrofs.unsigned i)\n    || valid_ptr' b0 (Ptrofs.unsigned i - 1))\n  then cmp_different_blocks c\n  else None) = cmp_different_blocks c.","proofString":"rewrite X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : true = Archi.ptr64) (H2 : (if negb true\n then None\n else\n  if eq_block b0 b1\n  then\n   if\n    (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) &&\n    (valid_ptr b1 (Ptrofs.unsigned i0)\n     || valid_ptr b1 (Ptrofs.unsigned i0 - 1))\n   then Some (Ptrofs.cmpu c i i0)\n   else None\n  else\n   if valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)\n   then cmp_different_blocks c\n   else None) = Some b) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) : (if negb true\n then None\n else\n  if eq_block b0 b1\n  then\n   if\n    (valid_ptr' b0 (Ptrofs.unsigned i)\n     || valid_ptr' b0 (Ptrofs.unsigned i - 1)) &&\n    (valid_ptr' b1 (Ptrofs.unsigned i0)\n     || valid_ptr' b1 (Ptrofs.unsigned i0 - 1))\n   then Some (Ptrofs.cmpu c i i0)\n   else None\n  else\n   if valid_ptr' b0 (Ptrofs.unsigned i) && valid_ptr' b1 (Ptrofs.unsigned i0)\n   then cmp_different_blocks c\n   else None) = Some b.","proofString":"destruct (eq_block b0 b1).\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto.\ndestruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : true = Archi.ptr64) (e : b0 = b1) (H2 : (if negb true\n then None\n else\n  if\n   (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr b1 (Ptrofs.unsigned i0)\n    || valid_ptr b1 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu c i i0)\n  else None) = Some b) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) : (if negb true\n then None\n else\n  if\n   (valid_ptr' b0 (Ptrofs.unsigned i)\n    || valid_ptr' b0 (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr' b1 (Ptrofs.unsigned i0)\n    || valid_ptr' b1 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu c i i0)\n  else None) = Some b.","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i) || valid_ptr b0 (Ptrofs.unsigned i - 1)) eqn:A; inv H2.\ndestruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs = true -> valid_ptr' b0 ofs = true) (Heqptr64 : true = Archi.ptr64) (A : valid_ptr b1 (Ptrofs.unsigned i) || valid_ptr b1 (Ptrofs.unsigned i - 1) =\ntrue) (X : forall (b0 : block) (ofs : Z),\nvalid_ptr b0 ofs || valid_ptr b0 (ofs - 1) = true ->\nvalid_ptr' b0 ofs || valid_ptr' b0 (ofs - 1) = true) (H1 : (if\n  valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)\n then Some (Ptrofs.cmpu c i i0)\n else None) = Some b) : (if negb true\n then None\n else\n  if\n   (valid_ptr' b1 (Ptrofs.unsigned i)\n    || valid_ptr' b1 (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr' b1 (Ptrofs.unsigned i0)\n    || valid_ptr' b1 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu c i i0)\n  else None) =\n(if\n  valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)\n then Some (Ptrofs.cmpu c i i0)\n else None).","proofString":"destruct (valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1)) eqn:B; inv H1.\nrewrite ! X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (i : ptrofs) (b1 : block) (i0 : ptrofs) (H : forall (b : block) (ofs : Z),\nvalid_ptr b ofs = true -> valid_ptr' b ofs = true) (Heqptr64 : true = Archi.ptr64) (A : valid_ptr b1 (Ptrofs.unsigned i) || valid_ptr b1 (Ptrofs.unsigned i - 1) =\ntrue) (X : forall (b : block) (ofs : Z),\nvalid_ptr b ofs || valid_ptr b (ofs - 1) = true ->\nvalid_ptr' b ofs || valid_ptr' b (ofs - 1) = true) (B : valid_ptr b1 (Ptrofs.unsigned i0) || valid_ptr b1 (Ptrofs.unsigned i0 - 1) =\ntrue) : (if negb true\n then None\n else\n  if\n   (valid_ptr' b1 (Ptrofs.unsigned i)\n    || valid_ptr' b1 (Ptrofs.unsigned i - 1)) &&\n   (valid_ptr' b1 (Ptrofs.unsigned i0)\n    || valid_ptr' b1 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu c i i0)\n  else None) = Some (Ptrofs.cmpu c i i0).","proofString":"rewrite ! X; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : true = Archi.ptr64) (n : b0 <> b1) (H2 : (if negb true\n then None\n else\n  if valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)\n  then cmp_different_blocks c\n  else None) = Some b) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) : (if negb true\n then None\n else\n  if valid_ptr' b0 (Ptrofs.unsigned i) && valid_ptr' b1 (Ptrofs.unsigned i0)\n  then cmp_different_blocks c\n  else None) = Some b.","proofString":"destruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.\nInvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : true = Archi.ptr64) (n : b0 <> b1) (A : valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0) = true) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) (H1 : cmp_different_blocks c = Some b) : (if negb true\n then None\n else\n  if valid_ptr' b0 (Ptrofs.unsigned i) && valid_ptr' b1 (Ptrofs.unsigned i0)\n  then cmp_different_blocks c\n  else None) = cmp_different_blocks c.","proofString":"InvBooleans.\nrewrite ! H; auto."},{"statement":"(valid_ptr valid_ptr' : block -> Z -> bool) (c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (H : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs = true -> valid_ptr' b2 ofs = true) (Heqptr64 : true = Archi.ptr64) (n : b0 <> b1) (X : forall (b2 : block) (ofs : Z),\nvalid_ptr b2 ofs || valid_ptr b2 (ofs - 1) = true ->\nvalid_ptr' b2 ofs || valid_ptr' b2 (ofs - 1) = true) (H1 : cmp_different_blocks c = Some b) (H0 : valid_ptr b0 (Ptrofs.unsigned i) = true) (H2 : valid_ptr b1 (Ptrofs.unsigned i0) = true) : (if negb true\n then None\n else\n  if valid_ptr' b0 (Ptrofs.unsigned i) && valid_ptr' b1 (Ptrofs.unsigned i0)\n  then cmp_different_blocks c\n  else None) = cmp_different_blocks c.","proofString":"rewrite ! H; auto."},{"statement":"(ob ob' : option bool) (H : forall b : bool, ob = Some b -> ob' = Some b) : lessdef (of_optbool ob) (of_optbool ob').","proofString":"destruct ob; simpl; auto.\nrewrite (H b); auto."},{"statement":"(b : bool) (ob' : option bool) (H : forall b0 : bool, Some b = Some b0 -> ob' = Some b0) : lessdef (if b then Vtrue else Vfalse) (of_optbool ob').","proofString":"rewrite (H b); auto."},{"statement":"(v1 v2 v1' v2' : val) (H : lessdef v1 v1') (H0 : lessdef v2 v2') : lessdef (longofwords v1 v2) (longofwords v1' v2').","proofString":"unfold longofwords.\ninv H; auto.\ninv H0; auto.\ndestruct v1'; auto."},{"statement":"(v1 v2 v1' v2' : val) (H : lessdef v1 v1') (H0 : lessdef v2 v2') : lessdef\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"inv H; auto.\ninv H0; auto.\ndestruct v1'; auto."},{"statement":"(v2 v1' v2' : val) (H0 : lessdef v2 v2') : lessdef\n  match v1' with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"inv H0; auto.\ndestruct v1'; auto."},{"statement":"(v1' v2' : val) : lessdef match v1' with\n        | Vundef | _ => Vundef\n        end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"destruct v1'; auto."},{"statement":"(v v' : val) (H : lessdef v v') : lessdef (loword v) (loword v').","proofString":"inv H; auto."},{"statement":"(v v' : val) (H : lessdef v v') : lessdef (hiword v) (hiword v').","proofString":"inv H; auto."},{"statement":"(v : val) : lessdef (offset_ptr v Ptrofs.zero) v.","proofString":"destruct v; simpl; auto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(b : block) (i : ptrofs) : lessdef (Vptr b (Ptrofs.add i Ptrofs.zero)) (Vptr b i).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(v : val) (d1 d2 : ptrofs) : offset_ptr (offset_ptr v d1) d2 = offset_ptr v (Ptrofs.add d1 d2).","proofString":"destruct v; simpl; auto.\nf_equal.\napply Ptrofs.add_assoc."},{"statement":"(b : block) (i d1 d2 : ptrofs) : Vptr b (Ptrofs.add (Ptrofs.add i d1) d2) =\nVptr b (Ptrofs.add i (Ptrofs.add d1 d2)).","proofString":"f_equal.\napply Ptrofs.add_assoc."},{"statement":"(b : block) (i d1 d2 : ptrofs) : Ptrofs.add (Ptrofs.add i d1) d2 = Ptrofs.add i (Ptrofs.add d1 d2).","proofString":"apply Ptrofs.add_assoc."},{"statement":"(v : val) (ty : typ) : lessdef (normalize v ty) v.","proofString":"destruct v; simpl.\nauto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty, Archi.ptr64; auto."},{"statement":"(ty : typ) : lessdef Vundef Vundef.","proofString":"auto."},{"statement":"(i : int) (ty : typ) : lessdef match ty with\n        | Tfloat | Tlong | Tsingle => Vundef\n        | _ => Vint i\n        end (Vint i).","proofString":"destruct ty; auto."},{"statement":"(i : int64) (ty : typ) : lessdef match ty with\n        | Tlong | Tany64 => Vlong i\n        | _ => Vundef\n        end (Vlong i).","proofString":"destruct ty; auto."},{"statement":"(f : float) (ty : typ) : lessdef match ty with\n        | Tfloat | Tany64 => Vfloat f\n        | _ => Vundef\n        end (Vfloat f).","proofString":"destruct ty; auto."},{"statement":"(f : float32) (ty : typ) : lessdef match ty with\n        | Tint | Tfloat | Tlong => Vundef\n        | _ => Vsingle f\n        end (Vsingle f).","proofString":"destruct ty; auto."},{"statement":"(b : block) (i : ptrofs) (ty : typ) : lessdef\n  match ty with\n  | Tlong => if Archi.ptr64 then Vptr b i else Vundef\n  | Tfloat | Tsingle => Vundef\n  | Tany64 => Vptr b i\n  | _ => if Archi.ptr64 then Vundef else Vptr b i\n  end (Vptr b i).","proofString":"destruct ty, Archi.ptr64; auto."},{"statement":"(v v' : val) (ty : typ) (H : lessdef v v') : lessdef (normalize v ty) (normalize v' ty).","proofString":"inv H; auto."},{"statement":"(ob ob' : option bool) (v1 v1' v2 v2' : val) (ty : typ) (H : ob = None \\/ ob = ob') (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') : lessdef\n  match ob with\n  | Some b => normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob' with\n  | Some b => normalize (if b then v1' else v2') ty\n  | None => Vundef\n  end.","proofString":"destruct H.\nsubst ob; auto.\nsubst ob'; destruct ob as [b|]; auto.\napply normalize_lessdef.\ndestruct b; auto."},{"statement":"(ob ob' : option bool) (v1 v1' v2 v2' : val) (ty : typ) (H : ob = None) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') : lessdef\n  match ob with\n  | Some b => normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob' with\n  | Some b => normalize (if b then v1' else v2') ty\n  | None => Vundef\n  end.","proofString":"subst ob; auto."},{"statement":"(ob ob' : option bool) (v1 v1' v2 v2' : val) (ty : typ) (H : ob = ob') (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') : lessdef\n  match ob with\n  | Some b => normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob' with\n  | Some b => normalize (if b then v1' else v2') ty\n  | None => Vundef\n  end.","proofString":"subst ob'; destruct ob as [b|]; auto.\napply normalize_lessdef.\ndestruct b; auto."},{"statement":"(b : bool) (v1 v1' v2 v2' : val) (ty : typ) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') : lessdef (normalize (if b then v1 else v2) ty)\n  (normalize (if b then v1' else v2') ty).","proofString":"apply normalize_lessdef.\ndestruct b; auto."},{"statement":"(b : bool) (v1 v1' v2 v2' : val) (ty : typ) (H0 : lessdef v1 v1') (H1 : lessdef v2 v2') : lessdef (if b then v1 else v2) (if b then v1' else v2').","proofString":"destruct b; auto."},{"statement":"(v : val) (r : xtype) (v' : val) (H : has_argtype v r) (H0 : lessdef v v') : has_argtype v' r.","proofString":"inv H0; auto.\ndestruct r; elim H || exact I."},{"statement":"(r : xtype) (v' : val) (H : has_argtype Vundef r) : has_argtype v' r.","proofString":"destruct r; elim H || exact I."},{"statement":"(vl : list val) (rl : list xtype) (vl' : list val) (H : list_forall2 has_argtype vl rl) (H0 : lessdef_list vl vl') : list_forall2 has_argtype vl' rl.","proofString":"revert vl vl' H0 rl H.\ninduction 1; intros.\ninv H.\nconstructor.\ninv H1.\nconstructor; eauto using has_argtype_lessdef."},{"statement":"forall vl vl' : list val,\nlessdef_list vl vl' ->\nforall rl : list xtype,\nlist_forall2 has_argtype vl rl -> list_forall2 has_argtype vl' rl.","proofString":"induction 1; intros.\ninv H.\nconstructor.\ninv H1.\nconstructor; eauto using has_argtype_lessdef."},{"statement":"(rl : list xtype) (H : list_forall2 has_argtype nil rl) : list_forall2 has_argtype nil rl.","proofString":"inv H.\nconstructor."},{"statement":"list_forall2 has_argtype nil nil.","proofString":"constructor."},{"statement":"(v1 v2 : val) (vl1 vl2 : list val) (H : lessdef v1 v2) (H0 : lessdef_list vl1 vl2) (IHlessdef_list : forall rl0 : list xtype,\nlist_forall2 has_argtype vl1 rl0 -> list_forall2 has_argtype vl2 rl0) (rl : list xtype) (H1 : list_forall2 has_argtype (v1 :: vl1) rl) : list_forall2 has_argtype (v2 :: vl2) rl.","proofString":"inv H1.\nconstructor; eauto using has_argtype_lessdef."},{"statement":"(v1 v2 : val) (vl1 vl2 : list val) (H : lessdef v1 v2) (H0 : lessdef_list vl1 vl2) (IHlessdef_list : forall rl : list xtype,\nlist_forall2 has_argtype vl1 rl -> list_forall2 has_argtype vl2 rl) (b1 : xtype) (bl : list xtype) (H4 : has_argtype v1 b1) (H6 : list_forall2 has_argtype vl1 bl) : list_forall2 has_argtype (v2 :: vl2) (b1 :: bl).","proofString":"constructor; eauto using has_argtype_lessdef."},{"statement":"(mi : meminj) (i : ptrofs) : inject mi\n  (if Archi.ptr64 then Vlong (Ptrofs.to_int64 i) else Vint (Ptrofs.to_int i))\n  (if Archi.ptr64 then Vlong (Ptrofs.to_int64 i) else Vint (Ptrofs.to_int i)).","proofString":"destruct Archi.ptr64; auto."},{"statement":"(chunk : memory_chunk) (v1 v2 : val) (H : inject f v1 v2) : inject f (load_result chunk v1) (load_result chunk v2).","proofString":"unfold Val.load_result.\ninv H; destruct chunk; try constructor; try (destruct Archi.ptr64; econstructor; now eauto).\nunfold norm_bool.\ndestruct is_bool; auto."},{"statement":"(chunk : memory_chunk) (v1 v2 : val) (H : inject f v1 v2) : inject f\n  match chunk with\n  | Mbool =>\n      match v1 with\n      | Vint n => norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v1 with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v1 with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v1 with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v1 with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v1 with\n      | Vint n => Vint n\n      | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v1 with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v1 with\n                | Vsingle f0 => Vsingle f0\n                | _ => Vundef\n                end\n  | Mfloat64 => match v1 with\n                | Vfloat f0 => Vfloat f0\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v1 with\n      | Vint _ | Vsingle _ => v1\n      | Vptr _ _ => if Archi.ptr64 then Vundef else v1\n      | _ => Vundef\n      end\n  | Many64 => v1\n  end\n  match chunk with\n  | Mbool =>\n      match v2 with\n      | Vint n => norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v2 with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v2 with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v2 with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v2 with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v2 with\n      | Vint n => Vint n\n      | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v2 with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v2 with\n                | Vsingle f0 => Vsingle f0\n                | _ => Vundef\n                end\n  | Mfloat64 => match v2 with\n                | Vfloat f0 => Vfloat f0\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v2 with\n      | Vint _ | Vsingle _ => v2\n      | Vptr _ _ => if Archi.ptr64 then Vundef else v2\n      | _ => Vundef\n      end\n  | Many64 => v2\n  end.","proofString":"inv H; destruct chunk; try constructor; try (destruct Archi.ptr64; econstructor; now eauto).\nunfold norm_bool.\ndestruct is_bool; auto."},{"statement":"(i : int) : inject f (norm_bool (Vint (Int.zero_ext 8 i)))\n  (norm_bool (Vint (Int.zero_ext 8 i))).","proofString":"unfold norm_bool.\ndestruct is_bool; auto."},{"statement":"(i : int) : inject f\n  (if is_bool (Vint (Int.zero_ext 8 i))\n   then Vint (Int.zero_ext 8 i)\n   else Vundef)\n  (if is_bool (Vint (Int.zero_ext 8 i))\n   then Vint (Int.zero_ext 8 i)\n   else Vundef).","proofString":"destruct is_bool; auto."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f (add v1 v2) (add v1' v2').","proofString":"unfold Val.add.\ndestruct Archi.ptr64 eqn:SF.\ninv H; inv H0; constructor.\ninv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2' with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"destruct Archi.ptr64 eqn:SF.\ninv H; inv H0; constructor.\ninv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') (SF : Archi.ptr64 = true) : inject f\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2' with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end.","proofString":"inv H; inv H0; constructor."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') (SF : Archi.ptr64 = false) : inject f\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2' with\n      | Vint n2 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"inv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = false) (i : int) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : inject f (Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int i)))\n  (Vptr b2\n     (Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int i))).","proofString":"econstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = false) (i : int) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int i) =\nPtrofs.add (Ptrofs.add ofs1 (Ptrofs.of_int i)) (Ptrofs.repr delta).","proofString":"rewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = false) (i : int) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : Ptrofs.add ofs1 (Ptrofs.add (Ptrofs.repr delta) (Ptrofs.of_int i)) =\nPtrofs.add ofs1 (Ptrofs.add (Ptrofs.of_int i) (Ptrofs.repr delta)).","proofString":"decEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = false) (i : int) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : Ptrofs.add (Ptrofs.repr delta) (Ptrofs.of_int i) =\nPtrofs.add (Ptrofs.of_int i) (Ptrofs.repr delta).","proofString":"apply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = false) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int) : inject f (Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int i)))\n  (Vptr b2\n     (Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int i))).","proofString":"econstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = false) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int) : Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int i) =\nPtrofs.add (Ptrofs.add ofs1 (Ptrofs.of_int i)) (Ptrofs.repr delta).","proofString":"rewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = false) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int) : Ptrofs.add ofs1 (Ptrofs.add (Ptrofs.repr delta) (Ptrofs.of_int i)) =\nPtrofs.add ofs1 (Ptrofs.add (Ptrofs.of_int i) (Ptrofs.repr delta)).","proofString":"decEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = false) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int) : Ptrofs.add (Ptrofs.repr delta) (Ptrofs.of_int i) =\nPtrofs.add (Ptrofs.of_int i) (Ptrofs.repr delta).","proofString":"apply Ptrofs.add_commut."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f (sub v1 v2) (sub v1' v2').","proofString":"unfold Val.sub.\ndestruct Archi.ptr64 eqn:SF.\ninv H; inv H0; constructor.\ninv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite Ptrofs.sub_add_l.\nauto.\ndestruct (eq_block b1 b0); auto.\nsubst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2' with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"destruct Archi.ptr64 eqn:SF.\ninv H; inv H0; constructor.\ninv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite Ptrofs.sub_add_l.\nauto.\ndestruct (eq_block b1 b0); auto.\nsubst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') (SF : Archi.ptr64 = true) : inject f\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2' with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end.","proofString":"inv H; inv H0; constructor."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') (SF : Archi.ptr64 = false) : inject f\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 => Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if eq_block b1 b2\n          then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2' with\n      | Vint n2 => Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if eq_block b1 b2\n          then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"inv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite Ptrofs.sub_add_l.\nauto.\ndestruct (eq_block b1 b0); auto.\nsubst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = false) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int) : inject f (Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int i)))\n  (Vptr b2\n     (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int i))).","proofString":"econstructor; eauto.\nrewrite Ptrofs.sub_add_l.\nauto."},{"statement":"(SF : Archi.ptr64 = false) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int) : Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int i) =\nPtrofs.add (Ptrofs.sub ofs1 (Ptrofs.of_int i)) (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.sub_add_l.\nauto."},{"statement":"(SF : Archi.ptr64 = false) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int) : Ptrofs.add (Ptrofs.sub ofs1 (Ptrofs.of_int i)) (Ptrofs.repr delta) =\nPtrofs.add (Ptrofs.sub ofs1 (Ptrofs.of_int i)) (Ptrofs.repr delta).","proofString":"auto."},{"statement":"(SF : Archi.ptr64 = false) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (b0 : block) (ofs0 : ptrofs) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) : inject f\n  (if eq_block b1 b0\n   then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs0))\n   else Vundef)\n  (if eq_block b2 b3\n   then\n    Vint\n      (Ptrofs.to_int\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"destruct (eq_block b1 b0); auto.\nsubst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = false) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (b0 : block) (ofs0 : ptrofs) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) (e : b1 = b0) : inject f (Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs0)))\n  (if eq_block b2 b3\n   then\n    Vint\n      (Ptrofs.to_int\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"subst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = false) (ofs1 : ptrofs) (b2 : block) (delta : Z) (b0 : block) (H1 : f b0 = Some (b2, delta)) (ofs0 : ptrofs) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) : inject f (Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs0)))\n  (if eq_block b2 b3\n   then\n    Vint\n      (Ptrofs.to_int\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"rewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = false) (ofs1 : ptrofs) (b2 : block) (delta : Z) (b0 : block) (H1 : f b0 = Some (b2, delta)) (ofs0 : ptrofs) (b3 : block) (delta0 : Z) (H : Some (b2, delta) = Some (b3, delta0)) : inject f (Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs0)))\n  (if eq_block b2 b3\n   then\n    Vint\n      (Ptrofs.to_int\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"inv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = false) (ofs1 : ptrofs) (b0 b3 : block) (delta0 : Z) (H1 : f b0 = Some (b3, delta0)) (ofs0 : ptrofs) : inject f (Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs0)))\n  (if eq_block b3 b3\n   then\n    Vint\n      (Ptrofs.to_int\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta0))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"rewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = false) (ofs1 : ptrofs) (b0 b3 : block) (delta0 : Z) (H1 : f b0 = Some (b3, delta0)) (ofs0 : ptrofs) : inject f (Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs0)))\n  (Vint\n     (Ptrofs.to_int\n        (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta0))\n           (Ptrofs.add ofs0 (Ptrofs.repr delta0))))).","proofString":"rewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = false) (ofs1 : ptrofs) (b0 b3 : block) (delta0 : Z) (H1 : f b0 = Some (b3, delta0)) (ofs0 : ptrofs) : inject f (Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs0)))\n  (Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs0))).","proofString":"auto."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f (addl v1 v2) (addl v1' v2').","proofString":"unfold Val.addl.\ndestruct Archi.ptr64 eqn:SF.\ninv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\ninv H; inv H0; constructor."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n          else Vundef\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vlong n1 =>\n      match v2' with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n          else Vundef\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2' with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"destruct Archi.ptr64 eqn:SF.\ninv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\ninv H; inv H0; constructor."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') (SF : Archi.ptr64 = true) : inject f\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vlong n2 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vlong n1 =>\n      match v2' with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2' with\n      | Vlong n2 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"inv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut.\neconstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = true) (i : int64) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : inject f (Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 i)))\n  (Vptr b2\n     (Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int64 i))).","proofString":"econstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = true) (i : int64) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int64 i) =\nPtrofs.add (Ptrofs.add ofs1 (Ptrofs.of_int64 i)) (Ptrofs.repr delta).","proofString":"rewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = true) (i : int64) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : Ptrofs.add ofs1 (Ptrofs.add (Ptrofs.repr delta) (Ptrofs.of_int64 i)) =\nPtrofs.add ofs1 (Ptrofs.add (Ptrofs.of_int64 i) (Ptrofs.repr delta)).","proofString":"decEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = true) (i : int64) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : Ptrofs.add (Ptrofs.repr delta) (Ptrofs.of_int64 i) =\nPtrofs.add (Ptrofs.of_int64 i) (Ptrofs.repr delta).","proofString":"apply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = true) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int64) : inject f (Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 i)))\n  (Vptr b2\n     (Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int64 i))).","proofString":"econstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = true) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int64) : Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int64 i) =\nPtrofs.add (Ptrofs.add ofs1 (Ptrofs.of_int64 i)) (Ptrofs.repr delta).","proofString":"rewrite ! Ptrofs.add_assoc.\ndecEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = true) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int64) : Ptrofs.add ofs1 (Ptrofs.add (Ptrofs.repr delta) (Ptrofs.of_int64 i)) =\nPtrofs.add ofs1 (Ptrofs.add (Ptrofs.of_int64 i) (Ptrofs.repr delta)).","proofString":"decEq.\napply Ptrofs.add_commut."},{"statement":"(SF : Archi.ptr64 = true) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int64) : Ptrofs.add (Ptrofs.repr delta) (Ptrofs.of_int64 i) =\nPtrofs.add (Ptrofs.of_int64 i) (Ptrofs.repr delta).","proofString":"apply Ptrofs.add_commut."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') (SF : Archi.ptr64 = false) : inject f\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vlong n1 =>\n      match v2' with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2' with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end.","proofString":"inv H; inv H0; constructor."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f (subl v1 v2) (subl v1' v2').","proofString":"unfold Val.subl.\ndestruct Archi.ptr64 eqn:SF.\ninv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite Ptrofs.sub_add_l.\nauto.\ndestruct (eq_block b1 b0); auto.\nsubst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto.\ninv H; inv H0; constructor."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | Vptr b2 ofs2 =>\n          if negb Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vlong n1 =>\n      match v2' with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2' with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | Vptr b2 ofs2 =>\n          if negb Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"destruct Archi.ptr64 eqn:SF.\ninv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite Ptrofs.sub_add_l.\nauto.\ndestruct (eq_block b1 b0); auto.\nsubst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto.\ninv H; inv H0; constructor."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') (SF : Archi.ptr64 = true) : inject f\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vlong n2 => Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2))\n      | Vptr b2 ofs2 =>\n          if negb true\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vlong n1 =>\n      match v2' with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2' with\n      | Vlong n2 => Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2))\n      | Vptr b2 ofs2 =>\n          if negb true\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"inv H; inv H0; simpl; auto.\neconstructor; eauto.\nrewrite Ptrofs.sub_add_l.\nauto.\ndestruct (eq_block b1 b0); auto.\nsubst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = true) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int64) : inject f (Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 i)))\n  (Vptr b2\n     (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int64 i))).","proofString":"econstructor; eauto.\nrewrite Ptrofs.sub_add_l.\nauto."},{"statement":"(SF : Archi.ptr64 = true) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int64) : Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.of_int64 i) =\nPtrofs.add (Ptrofs.sub ofs1 (Ptrofs.of_int64 i)) (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.sub_add_l.\nauto."},{"statement":"(SF : Archi.ptr64 = true) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (i : int64) : Ptrofs.add (Ptrofs.sub ofs1 (Ptrofs.of_int64 i)) (Ptrofs.repr delta) =\nPtrofs.add (Ptrofs.sub ofs1 (Ptrofs.of_int64 i)) (Ptrofs.repr delta).","proofString":"auto."},{"statement":"(SF : Archi.ptr64 = true) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (b0 : block) (ofs0 : ptrofs) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) : inject f\n  (if eq_block b1 b0\n   then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs0))\n   else Vundef)\n  (if eq_block b2 b3\n   then\n    Vlong\n      (Ptrofs.to_int64\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"destruct (eq_block b1 b0); auto.\nsubst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = true) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (b0 : block) (ofs0 : ptrofs) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) (e : b1 = b0) : inject f (Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs0)))\n  (if eq_block b2 b3\n   then\n    Vlong\n      (Ptrofs.to_int64\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"subst.\nrewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = true) (ofs1 : ptrofs) (b2 : block) (delta : Z) (b0 : block) (H1 : f b0 = Some (b2, delta)) (ofs0 : ptrofs) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) : inject f (Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs0)))\n  (if eq_block b2 b3\n   then\n    Vlong\n      (Ptrofs.to_int64\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"rewrite H1 in H.\ninv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = true) (ofs1 : ptrofs) (b2 : block) (delta : Z) (b0 : block) (H1 : f b0 = Some (b2, delta)) (ofs0 : ptrofs) (b3 : block) (delta0 : Z) (H : Some (b2, delta) = Some (b3, delta0)) : inject f (Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs0)))\n  (if eq_block b2 b3\n   then\n    Vlong\n      (Ptrofs.to_int64\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"inv H.\nrewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = true) (ofs1 : ptrofs) (b0 b3 : block) (delta0 : Z) (H1 : f b0 = Some (b3, delta0)) (ofs0 : ptrofs) : inject f (Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs0)))\n  (if eq_block b3 b3\n   then\n    Vlong\n      (Ptrofs.to_int64\n         (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta0))\n            (Ptrofs.add ofs0 (Ptrofs.repr delta0))))\n   else Vundef).","proofString":"rewrite dec_eq_true.\nrewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = true) (ofs1 : ptrofs) (b0 b3 : block) (delta0 : Z) (H1 : f b0 = Some (b3, delta0)) (ofs0 : ptrofs) : inject f (Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs0)))\n  (Vlong\n     (Ptrofs.to_int64\n        (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.repr delta0))\n           (Ptrofs.add ofs0 (Ptrofs.repr delta0))))).","proofString":"rewrite Ptrofs.sub_shifted.\nauto."},{"statement":"(SF : Archi.ptr64 = true) (ofs1 : ptrofs) (b0 b3 : block) (delta0 : Z) (H1 : f b0 = Some (b3, delta0)) (ofs0 : ptrofs) : inject f (Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs0)))\n  (Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs0))).","proofString":"auto."},{"statement":"(v1 v1' v2 v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') (SF : Archi.ptr64 = false) : inject f\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vptr b2 ofs2 =>\n          if negb false\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vlong n1 =>\n      match v2' with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2' with\n      | Vptr b2 ofs2 =>\n          if negb false\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"inv H; inv H0; constructor."},{"statement":"(v v' : val) (ofs : ptrofs) (H : inject f v v') : inject f (offset_ptr v ofs) (offset_ptr v' ofs).","proofString":"inv H; simpl; econstructor; eauto.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\napply Ptrofs.add_commut."},{"statement":"(ofs : ptrofs) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) ofs =\nPtrofs.add (Ptrofs.add ofs1 ofs) (Ptrofs.repr delta).","proofString":"rewrite ! Ptrofs.add_assoc.\nf_equal.\napply Ptrofs.add_commut."},{"statement":"(ofs : ptrofs) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : Ptrofs.add ofs1 (Ptrofs.add (Ptrofs.repr delta) ofs) =\nPtrofs.add ofs1 (Ptrofs.add ofs (Ptrofs.repr delta)).","proofString":"f_equal.\napply Ptrofs.add_commut."},{"statement":"(ofs : ptrofs) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : Ptrofs.add (Ptrofs.repr delta) ofs = Ptrofs.add ofs (Ptrofs.repr delta).","proofString":"apply Ptrofs.add_commut."},{"statement":"(c : comparison) (v1 v2 v1' v2' : val) (b : bool) (H : inject f v1 v1') (H0 : inject f v2 v2') (H1 : cmp_bool c v1 v2 = Some b) : cmp_bool c v1' v2' = Some b.","proofString":"inv H; simpl in H1; try discriminate; inv H0; simpl in H1; try discriminate; simpl; auto."},{"statement":"(v1 v2 v1' v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f (longofwords v1 v2) (longofwords v1' v2').","proofString":"unfold Val.longofwords.\ninv H; auto.\ninv H0; auto."},{"statement":"(v1 v2 v1' v2' : val) (H : inject f v1 v1') (H0 : inject f v2 v2') : inject f\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match v1' with\n  | Vint n1 =>\n      match v2' with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"inv H; auto.\ninv H0; auto."},{"statement":"(v2 v2' : val) (H0 : inject f v2 v2') (i : int) : inject f\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\n  match v2' with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end.","proofString":"inv H0; auto."},{"statement":"(v v' : val) (H : inject f v v') : inject f (loword v) (loword v').","proofString":"unfold Val.loword; inv H; auto."},{"statement":"(v v' : val) (H : inject f v v') : inject f (hiword v) (hiword v').","proofString":"unfold Val.hiword; inv H; auto."},{"statement":"(v v' : val) (ty : typ) (H : inject f v v') : inject f (normalize v ty) (normalize v' ty).","proofString":"inv H.\ndestruct ty; constructor.\ndestruct ty; constructor.\ndestruct ty; constructor.\ndestruct ty; constructor.\nsimpl.\ndestruct ty.\ndestruct Archi.ptr64; econstructor; eauto.\nauto.\ndestruct Archi.ptr64; econstructor; eauto.\nauto.\ndestruct Archi.ptr64; econstructor; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(ty : typ) (i : int) : inject f (normalize (Vint i) ty) (normalize (Vint i) ty).","proofString":"destruct ty; constructor."},{"statement":"(ty : typ) (i : int64) : inject f (normalize (Vlong i) ty) (normalize (Vlong i) ty).","proofString":"destruct ty; constructor."},{"statement":"(ty : typ) (f0 : float) : inject f (normalize (Vfloat f0) ty) (normalize (Vfloat f0) ty).","proofString":"destruct ty; constructor."},{"statement":"(ty : typ) (f0 : float32) : inject f (normalize (Vsingle f0) ty) (normalize (Vsingle f0) ty).","proofString":"destruct ty; constructor."},{"statement":"(ty : typ) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : inject f (normalize (Vptr b1 ofs1) ty)\n  (normalize (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) ty).","proofString":"simpl.\ndestruct ty.\ndestruct Archi.ptr64; econstructor; eauto.\nauto.\ndestruct Archi.ptr64; econstructor; eauto.\nauto.\ndestruct Archi.ptr64; econstructor; eauto.\neconstructor; eauto."},{"statement":"(ty : typ) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : inject f\n  match ty with\n  | Tlong => if Archi.ptr64 then Vptr b1 ofs1 else Vundef\n  | Tfloat | Tsingle => Vundef\n  | Tany64 => Vptr b1 ofs1\n  | _ => if Archi.ptr64 then Vundef else Vptr b1 ofs1\n  end\n  match ty with\n  | Tlong =>\n      if Archi.ptr64\n      then Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))\n      else Vundef\n  | Tfloat | Tsingle => Vundef\n  | Tany64 => Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))\n  | _ =>\n      if Archi.ptr64\n      then Vundef\n      else Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))\n  end.","proofString":"destruct ty.\ndestruct Archi.ptr64; econstructor; eauto.\nauto.\ndestruct Archi.ptr64; econstructor; eauto.\nauto.\ndestruct Archi.ptr64; econstructor; eauto.\neconstructor; eauto."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : inject f (if Archi.ptr64 then Vundef else Vptr b1 ofs1)\n  (if Archi.ptr64\n   then Vundef\n   else Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"destruct Archi.ptr64; econstructor; eauto."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : inject f Vundef Vundef.","proofString":"auto."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : inject f (if Archi.ptr64 then Vptr b1 ofs1 else Vundef)\n  (if Archi.ptr64\n   then Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))\n   else Vundef).","proofString":"destruct Archi.ptr64; econstructor; eauto."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : inject f Vundef Vundef.","proofString":"auto."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : inject f (if Archi.ptr64 then Vundef else Vptr b1 ofs1)\n  (if Archi.ptr64\n   then Vundef\n   else Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"destruct Archi.ptr64; econstructor; eauto."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : f b1 = Some (b2, delta)) : inject f (Vptr b1 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"econstructor; eauto."},{"statement":"(v' : val) (ty : typ) : inject f (normalize Vundef ty) (normalize v' ty).","proofString":"constructor."},{"statement":"(ob ob' : option bool) (v1 v1' v2 v2' : val) (ty : typ) (H : ob = None \\/ ob = ob') (H0 : inject f v1 v1') (H1 : inject f v2 v2') : inject f\n  match ob with\n  | Some b => normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob' with\n  | Some b => normalize (if b then v1' else v2') ty\n  | None => Vundef\n  end.","proofString":"destruct H.\nsubst ob; auto.\nsubst ob'; destruct ob as [b|]; auto.\napply normalize_inject.\ndestruct b; auto."},{"statement":"(ob ob' : option bool) (v1 v1' v2 v2' : val) (ty : typ) (H : ob = None) (H0 : inject f v1 v1') (H1 : inject f v2 v2') : inject f\n  match ob with\n  | Some b => normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob' with\n  | Some b => normalize (if b then v1' else v2') ty\n  | None => Vundef\n  end.","proofString":"subst ob; auto."},{"statement":"(ob ob' : option bool) (v1 v1' v2 v2' : val) (ty : typ) (H : ob = ob') (H0 : inject f v1 v1') (H1 : inject f v2 v2') : inject f\n  match ob with\n  | Some b => normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob' with\n  | Some b => normalize (if b then v1' else v2') ty\n  | None => Vundef\n  end.","proofString":"subst ob'; destruct ob as [b|]; auto.\napply normalize_inject.\ndestruct b; auto."},{"statement":"(b : bool) (v1 v1' v2 v2' : val) (ty : typ) (H0 : inject f v1 v1') (H1 : inject f v2 v2') : inject f (normalize (if b then v1 else v2) ty)\n  (normalize (if b then v1' else v2') ty).","proofString":"apply normalize_inject.\ndestruct b; auto."},{"statement":"(b : bool) (v1 v1' v2 v2' : val) (ty : typ) (H0 : inject f v1 v1') (H1 : inject f v2 v2') : inject f (if b then v1 else v2) (if b then v1' else v2').","proofString":"destruct b; auto."},{"statement":"(v : val) (r : xtype) (v' : val) (H : has_argtype v r) (H0 : inject f v v') : has_argtype v' r.","proofString":"inv H0; destruct r; try contradiction; auto."},{"statement":"(vl : list val) (rl : list xtype) (vl' : list val) (H : list_forall2 has_argtype vl rl) (H0 : inject_list f vl vl') : list_forall2 has_argtype vl' rl.","proofString":"revert vl vl' H0 rl H.\ninduction 1; intros.\ninv H.\nconstructor.\ninv H1.\nconstructor; eauto using has_argtype_inject."},{"statement":"forall vl vl' : list val,\ninject_list f vl vl' ->\nforall rl : list xtype,\nlist_forall2 has_argtype vl rl -> list_forall2 has_argtype vl' rl.","proofString":"induction 1; intros.\ninv H.\nconstructor.\ninv H1.\nconstructor; eauto using has_argtype_inject."},{"statement":"(rl : list xtype) (H : list_forall2 has_argtype nil rl) : list_forall2 has_argtype nil rl.","proofString":"inv H.\nconstructor."},{"statement":"list_forall2 has_argtype nil nil.","proofString":"constructor."},{"statement":"(v v' : val) (vl vl' : list val) (H : inject f v v') (H0 : inject_list f vl vl') (IHinject_list : forall rl0 : list xtype,\nlist_forall2 has_argtype vl rl0 -> list_forall2 has_argtype vl' rl0) (rl : list xtype) (H1 : list_forall2 has_argtype (v :: vl) rl) : list_forall2 has_argtype (v' :: vl') rl.","proofString":"inv H1.\nconstructor; eauto using has_argtype_inject."},{"statement":"(v v' : val) (vl vl' : list val) (H : inject f v v') (H0 : inject_list f vl vl') (IHinject_list : forall rl : list xtype,\nlist_forall2 has_argtype vl rl -> list_forall2 has_argtype vl' rl) (b1 : xtype) (bl : list xtype) (H4 : has_argtype v b1) (H6 : list_forall2 has_argtype vl bl) : list_forall2 has_argtype (v' :: vl') (b1 :: bl).","proofString":"constructor; eauto using has_argtype_inject."},{"statement":"forall (f : meminj) (b b' : block) (delta : Z),\nf b = Some (b', delta) -> f b = Some (b', delta).","proofString":"auto."},{"statement":"(f1 f2 f3 : meminj) (H : forall (b0 b'0 : block) (delta0 : Z),\nf1 b0 = Some (b'0, delta0) -> f2 b0 = Some (b'0, delta0)) (H0 : forall (b0 b'0 : block) (delta0 : Z),\nf2 b0 = Some (b'0, delta0) -> f3 b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (H1 : f1 b = Some (b', delta)) : f3 b = Some (b', delta).","proofString":"eauto."},{"statement":"(f1 f2 : meminj) (v v' : val) (H : inject_incr f1 f2) (H0 : Val.inject f1 v v') : Val.inject f2 v v'.","proofString":"inv H0; eauto."},{"statement":"(f1 f2 : meminj) (H : inject_incr f1 f2) : Val.inject_list f2 nil nil.","proofString":"auto."},{"statement":"(f1 f2 : meminj) (a : val) (vl : list val) (IHvl : forall vl' : list val,\ninject_incr f1 f2 -> Val.inject_list f1 vl vl' -> Val.inject_list f2 vl vl') (H : inject_incr f1 f2) (v' : val) (vl'0 : list val) (H3 : Val.inject f1 a v') (H5 : Val.inject_list f1 vl vl'0) : Val.inject_list f2 (a :: vl) (v' :: vl'0).","proofString":"constructor.\neapply val_inject_incr; eauto.\nauto."},{"statement":"(f1 f2 : meminj) (a : val) (vl : list val) (IHvl : forall vl' : list val,\ninject_incr f1 f2 -> Val.inject_list f1 vl vl' -> Val.inject_list f2 vl vl') (H : inject_incr f1 f2) (v' : val) (vl'0 : list val) (H3 : Val.inject f1 a v') (H5 : Val.inject_list f1 vl vl'0) : Val.inject f2 a v'.","proofString":"eapply val_inject_incr; eauto."},{"statement":"(f1 f2 : meminj) (a : val) (vl : list val) (IHvl : forall vl' : list val,\ninject_incr f1 f2 -> Val.inject_list f1 vl vl' -> Val.inject_list f2 vl vl') (H : inject_incr f1 f2) (v' : val) (vl'0 : list val) (H3 : Val.inject f1 a v') (H5 : Val.inject_list f1 vl vl'0) : Val.inject_list f2 vl vl'0.","proofString":"auto."},{"statement":"(v1 v2 : val) (H : Val.lessdef v1 v2) : Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"inv H; auto.\ndestruct v2; econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(v2 : val) : Val.inject (fun b : block => Some (b, 0)) v2 v2.","proofString":"destruct v2; econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(b : block) (i : ptrofs) : i = Ptrofs.add i (Ptrofs.repr 0).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(v1 v2 : val) (H : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","proofString":"inv H; auto.\ninv H0.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) : Val.lessdef (Vptr b1 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"inv H0.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(ofs1 : ptrofs) (b2 : block) : Val.lessdef (Vptr b2 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr 0))).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(vl1 vl2 : list val) : Val.lessdef_list vl1 vl2 ->\nVal.inject_list (fun b : block => Some (b, 0)) vl1 vl2.","proofString":"induction 1; constructor; auto.\napply val_inject_lessdef; auto."},{"statement":"(v1 v2 : val) (vl1 vl2 : list val) (H : Val.lessdef v1 v2) (H0 : Val.lessdef_list vl1 vl2) (IHlessdef_list : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) : Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"apply val_inject_lessdef; auto."},{"statement":"(vl1 vl2 : list val) : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2 ->\nVal.lessdef_list vl1 vl2.","proofString":"induction 1; constructor; auto.\napply val_inject_lessdef; auto."},{"statement":"(v v' : val) (vl vl' : list val) (H : Val.inject (fun b : block => Some (b, 0)) v v') (H0 : Val.inject_list (fun b : block => Some (b, 0)) vl vl') (IHinject_list : Val.lessdef_list vl vl') : Val.lessdef v v'.","proofString":"apply val_inject_lessdef; auto."},{"statement":"(v1 v2 : val) (H : Val.inject inject_id v1 v2) : Val.lessdef v1 v2.","proofString":"inv H; auto.\nunfold inject_id in H0.\ninv H0.\nrewrite Ptrofs.add_zero.\nconstructor."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : inject_id b1 = Some (b2, delta)) : Val.lessdef (Vptr b1 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"unfold inject_id in H0.\ninv H0.\nrewrite Ptrofs.add_zero.\nconstructor."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) : Val.lessdef (Vptr b1 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))).","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\nconstructor."},{"statement":"(ofs1 : ptrofs) (b2 : block) : Val.lessdef (Vptr b2 ofs1) (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr 0))).","proofString":"rewrite Ptrofs.add_zero.\nconstructor."},{"statement":"(ofs1 : ptrofs) (b2 : block) : Val.lessdef (Vptr b2 ofs1) (Vptr b2 ofs1).","proofString":"constructor."},{"statement":"(v1 v2 : val) (H : Val.lessdef v1 v2) : Val.inject inject_id v1 v2.","proofString":"inv H.\ndestruct v2; econstructor.\nunfold inject_id; reflexivity.\nrewrite Ptrofs.add_zero; auto.\nconstructor."},{"statement":"(v2 : val) : Val.inject inject_id v2 v2.","proofString":"destruct v2; econstructor.\nunfold inject_id; reflexivity.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(v2 : val) : Val.inject inject_id Vundef v2.","proofString":"constructor."},{"statement":"(f f' : meminj) (v1 v2 v3 : val) (H : Val.inject f v1 v2) (H0 : Val.inject f' v2 v3) : Val.inject (compose_meminj f f') v1 v3.","proofString":"inv H; auto; inv H0; auto.\neconstructor.\nunfold compose_meminj; rewrite H1; rewrite H3; eauto.\nrewrite Ptrofs.add_assoc.\ndecEq.\nunfold Ptrofs.add.\napply Ptrofs.eqm_samerepr.\nauto with ints."},{"statement":"(f f' : meminj) (ofs1 : ptrofs) (b2 : block) (delta : Z) (b1 : block) (H1 : f b1 = Some (b2, delta)) (b3 : block) (delta0 : Z) (H3 : f' b2 = Some (b3, delta0)) : Val.inject (compose_meminj f f') (Vptr b1 ofs1)\n  (Vptr b3\n     (Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta)) (Ptrofs.repr delta0))).","proofString":"econstructor.\nunfold compose_meminj; rewrite H1; rewrite H3; eauto.\nrewrite Ptrofs.add_assoc.\ndecEq.\nunfold Ptrofs.add.\napply Ptrofs.eqm_samerepr.\nauto with ints."},{"statement":"(f f' : meminj) (ofs1 : ptrofs) (b2 : block) (delta : Z) (b1 : block) (H1 : f b1 = Some (b2, delta)) (b3 : block) (delta0 : Z) (H3 : f' b2 = Some (b3, delta0)) : Ptrofs.add ofs1 (Ptrofs.add (Ptrofs.repr delta) (Ptrofs.repr delta0)) =\nPtrofs.add ofs1 (Ptrofs.repr (delta + delta0)).","proofString":"decEq.\nunfold Ptrofs.add.\napply Ptrofs.eqm_samerepr.\nauto with ints."},{"statement":"(f f' : meminj) (ofs1 : ptrofs) (b2 : block) (delta : Z) (b1 : block) (H1 : f b1 = Some (b2, delta)) (b3 : block) (delta0 : Z) (H3 : f' b2 = Some (b3, delta0)) : Ptrofs.add (Ptrofs.repr delta) (Ptrofs.repr delta0) =\nPtrofs.repr (delta + delta0).","proofString":"unfold Ptrofs.add.\napply Ptrofs.eqm_samerepr.\nauto with ints."},{"statement":"(f f' : meminj) (ofs1 : ptrofs) (b2 : block) (delta : Z) (b1 : block) (H1 : f b1 = Some (b2, delta)) (b3 : block) (delta0 : Z) (H3 : f' b2 = Some (b3, delta0)) : Ptrofs.repr\n  (Ptrofs.unsigned (Ptrofs.repr delta) + Ptrofs.unsigned (Ptrofs.repr delta0)) =\nPtrofs.repr (delta + delta0).","proofString":"apply Ptrofs.eqm_samerepr.\nauto with ints."},{"statement":"(f f' : meminj) (ofs1 : ptrofs) (b2 : block) (delta : Z) (b1 : block) (H1 : f b1 = Some (b2, delta)) (b3 : block) (delta0 : Z) (H3 : f' b2 = Some (b3, delta0)) : Ptrofs.eqm\n  (Ptrofs.unsigned (Ptrofs.repr delta) + Ptrofs.unsigned (Ptrofs.repr delta0))\n  (delta + delta0).","proofString":"auto with ints."}]}