{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Ctypes.v","fileSamples":[{"statement":"(a1 a2 : attr) (attr_volatile0 : bool) (attr_alignas0 : option N) (attr_volatile1 : bool) (attr_alignas1 : option N) (a : attr_volatile0 = attr_volatile1) : {attr_alignas0 = attr_alignas1} + {attr_alignas0 <> attr_alignas1}.","proofString":"decide equality.\napply N.eq_dec."},{"statement":"(a1 a2 : attr) (attr_volatile0 : bool) (attr_alignas0 : option N) (attr_volatile1 : bool) (attr_alignas1 : option N) (a : attr_volatile0 = attr_volatile1) (a0 n : N) : {a0 = n} + {a0 <> n}.","proofString":"apply N.eq_dec."},{"statement":"(a1 a2 : attr) (attr_volatile0 : bool) (attr_alignas0 : option N) (attr_volatile1 : bool) (attr_alignas1 : option N) : {attr_volatile0 = attr_volatile1} + {attr_volatile0 <> attr_volatile1}.","proofString":"apply bool_dec."},{"statement":"(REC : forall ty1 ty2 : type, {ty1 = ty2} + {ty1 <> ty2}) : forall ty1 ty2 : type, {ty1 = ty2} + {ty1 <> ty2}.","proofString":"decide equality; auto using ident_eq, zeq, bool_dec, ident_eq, intsize_eq, signedness_eq, floatsize_eq, attr_eq, list_eq_dec, calling_convention_eq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (a3 : m = m0) : {a = a0} + {a <> a0}.","proofString":"decide equality.\ndecide equality.\napply N.eq_dec.\napply bool_dec."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (a3 : m = m0) (attr_volatile0 : bool) (attr_alignas0 : option N) (attr_volatile1 : bool) (attr_alignas1 : option N) (a4 : attr_volatile0 = attr_volatile1) : {attr_alignas0 = attr_alignas1} + {attr_alignas0 <> attr_alignas1}.","proofString":"decide equality.\napply N.eq_dec."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (a3 : m = m0) (attr_volatile0 : bool) (attr_alignas0 : option N) (attr_volatile1 : bool) (attr_alignas1 : option N) (a4 : attr_volatile0 = attr_volatile1) (a5 n : N) : {a5 = n} + {a5 <> n}.","proofString":"apply N.eq_dec."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (a3 : m = m0) (attr_volatile0 : bool) (attr_alignas0 : option N) (attr_volatile1 : bool) (attr_alignas1 : option N) : {attr_volatile0 = attr_volatile1} + {attr_volatile0 <> attr_volatile1}.","proofString":"apply bool_dec."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) : {m = m0} + {m <> m0}.","proofString":"apply list_eq_dec.\ndecide equality.\napply type_eq.\napply ident_eq.\napply bool_dec.\napply zeq.\napply attr_eq.\napply signedness_eq.\napply intsize_eq.\napply ident_eq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) : forall x0 y0 : member, {x0 = y0} + {x0 <> y0}.","proofString":"decide equality.\napply type_eq.\napply ident_eq.\napply bool_dec.\napply zeq.\napply attr_eq.\napply signedness_eq.\napply intsize_eq.\napply ident_eq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (x0 y0 : member) (id1 : ident) (t : type) (id2 : ident) (t0 : type) (a3 : id1 = id2) : {t = t0} + {t <> t0}.","proofString":"apply type_eq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (x0 y0 : member) (id1 : ident) (t : type) (id2 : ident) (t0 : type) : {id1 = id2} + {id1 <> id2}.","proofString":"apply ident_eq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (x0 y0 : member) (id1 : ident) (sz : intsize) (sg : signedness) (a3 : attr) (width : Z) (padding : bool) (id2 : ident) (sz0 : intsize) (sg0 : signedness) (a4 : attr) (width0 : Z) (padding0 : bool) (a5 : id1 = id2) (a6 : sz = sz0) (a7 : sg = sg0) (a8 : a3 = a4) (a9 : width = width0) : {padding = padding0} + {padding <> padding0}.","proofString":"apply bool_dec."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (x0 y0 : member) (id1 : ident) (sz : intsize) (sg : signedness) (a3 : attr) (width : Z) (padding : bool) (id2 : ident) (sz0 : intsize) (sg0 : signedness) (a4 : attr) (width0 : Z) (padding0 : bool) (a5 : id1 = id2) (a6 : sz = sz0) (a7 : sg = sg0) (a8 : a3 = a4) : {width = width0} + {width <> width0}.","proofString":"apply zeq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (x0 y0 : member) (id1 : ident) (sz : intsize) (sg : signedness) (a3 : attr) (width : Z) (padding : bool) (id2 : ident) (sz0 : intsize) (sg0 : signedness) (a4 : attr) (width0 : Z) (padding0 : bool) (a5 : id1 = id2) (a6 : sz = sz0) (a7 : sg = sg0) : {a3 = a4} + {a3 <> a4}.","proofString":"apply attr_eq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (x0 y0 : member) (id1 : ident) (sz : intsize) (sg : signedness) (a3 : attr) (width : Z) (padding : bool) (id2 : ident) (sz0 : intsize) (sg0 : signedness) (a4 : attr) (width0 : Z) (padding0 : bool) (a5 : id1 = id2) (a6 : sz = sz0) : {sg = sg0} + {sg <> sg0}.","proofString":"apply signedness_eq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (x0 y0 : member) (id1 : ident) (sz : intsize) (sg : signedness) (a3 : attr) (width : Z) (padding : bool) (id2 : ident) (sz0 : intsize) (sg0 : signedness) (a4 : attr) (width0 : Z) (padding0 : bool) (a5 : id1 = id2) : {sz = sz0} + {sz <> sz0}.","proofString":"apply intsize_eq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) (a2 : su = su0) (x0 y0 : member) (id1 : ident) (sz : intsize) (sg : signedness) (a3 : attr) (width : Z) (padding : bool) (id2 : ident) (sz0 : intsize) (sg0 : signedness) (a4 : attr) (width0 : Z) (padding0 : bool) : {id1 = id2} + {id1 <> id2}.","proofString":"apply ident_eq."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (a1 : id = id0) : {su = su0} + {su <> su0}.","proofString":"decide equality."},{"statement":"(x y : composite_definition) (id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) : {id = id0} + {id <> id0}.","proofString":"apply ident_eq."},{"statement":"(al : Z) (a : attr) (H : exists n : nat, al = two_power_nat n) : exists n : nat, align_attr a al = two_power_nat n.","proofString":"unfold align_attr.\ndestruct (attr_alignas a).\nexists (N.to_nat n).\nrewrite two_power_nat_two_p.\nrewrite N_nat_Z.\nauto.\nauto."},{"statement":"(al : Z) (a : attr) (H : exists n : nat, al = two_power_nat n) : exists n : nat,\n  match attr_alignas a with\n  | Some l => two_p (Z.of_N l)\n  | None => al\n  end = two_power_nat n.","proofString":"destruct (attr_alignas a).\nexists (N.to_nat n).\nrewrite two_power_nat_two_p.\nrewrite N_nat_Z.\nauto.\nauto."},{"statement":"(al : Z) (a : attr) (H : exists n0 : nat, al = two_power_nat n0) (n : N) : exists n0 : nat, two_p (Z.of_N n) = two_power_nat n0.","proofString":"exists (N.to_nat n).\nrewrite two_power_nat_two_p.\nrewrite N_nat_Z.\nauto."},{"statement":"(al : Z) (a : attr) (H : exists n0 : nat, al = two_power_nat n0) (n : N) : two_p (Z.of_N n) = two_power_nat (N.to_nat n).","proofString":"rewrite two_power_nat_two_p.\nrewrite N_nat_Z.\nauto."},{"statement":"(al : Z) (a : attr) (H : exists n0 : nat, al = two_power_nat n0) (n : N) : two_p (Z.of_N n) = two_p (Z.of_nat (N.to_nat n)).","proofString":"rewrite N_nat_Z.\nauto."},{"statement":"(al : Z) (a : attr) (H : exists n0 : nat, al = two_power_nat n0) (n : N) : two_p (Z.of_N n) = two_p (Z.of_N n).","proofString":"auto."},{"statement":"(al : Z) (a : attr) (H : exists n : nat, al = two_power_nat n) : exists n : nat, al = two_power_nat n.","proofString":"auto."},{"statement":"(env : composite_env) : exists n : nat, 1 = two_power_nat n.","proofString":"exists 0%nat; auto."},{"statement":"(env : composite_env) (i : intsize) (s : signedness) (a : attr) : exists n : nat,\n  match i with\n  | I16 => 2\n  | I32 => 4\n  | _ => 1\n  end = two_power_nat n.","proofString":"destruct i.\nexists 0%nat; auto.\nexists 1%nat; auto.\nexists 2%nat; auto.\nexists 0%nat; auto."},{"statement":"(env : composite_env) (s : signedness) (a : attr) : exists n : nat, 1 = two_power_nat n.","proofString":"exists 0%nat; auto."},{"statement":"(env : composite_env) (s : signedness) (a : attr) : exists n : nat, 2 = two_power_nat n.","proofString":"exists 1%nat; auto."},{"statement":"(env : composite_env) (s : signedness) (a : attr) : exists n : nat, 4 = two_power_nat n.","proofString":"exists 2%nat; auto."},{"statement":"(env : composite_env) (s : signedness) (a : attr) : exists n : nat, 1 = two_power_nat n.","proofString":"exists 0%nat; auto."},{"statement":"(env : composite_env) (s : signedness) (a : attr) : exists n : nat, Archi.align_int64 = two_power_nat n.","proofString":"unfold Archi.align_int64.\ndestruct Archi.ptr64; ((exists 2%nat; reflexivity) || (exists 3%nat; reflexivity))."},{"statement":"(env : composite_env) (s : signedness) (a : attr) : exists n : nat, 8 = two_power_nat n.","proofString":"destruct Archi.ptr64; ((exists 2%nat; reflexivity) || (exists 3%nat; reflexivity))."},{"statement":"(env : composite_env) (f : floatsize) (a : attr) : exists n : nat,\n  match f with\n  | F32 => 4\n  | F64 => Archi.align_float64\n  end = two_power_nat n.","proofString":"destruct f.\nexists 2%nat; auto.\nunfold Archi.align_float64.\ndestruct Archi.ptr64; ((exists 2%nat; reflexivity) || (exists 3%nat; reflexivity))."},{"statement":"(env : composite_env) (a : attr) : exists n : nat, 4 = two_power_nat n.","proofString":"exists 2%nat; auto."},{"statement":"(env : composite_env) (a : attr) : exists n : nat, Archi.align_float64 = two_power_nat n.","proofString":"unfold Archi.align_float64.\ndestruct Archi.ptr64; ((exists 2%nat; reflexivity) || (exists 3%nat; reflexivity))."},{"statement":"(env : composite_env) (a : attr) : exists n : nat, 8 = two_power_nat n.","proofString":"destruct Archi.ptr64; ((exists 2%nat; reflexivity) || (exists 3%nat; reflexivity))."},{"statement":"(env : composite_env) (t : type) (a : attr) (IHt : exists n : nat, alignof env t = two_power_nat n) : exists n : nat, (if Archi.ptr64 then 8 else 4) = two_power_nat n.","proofString":"exists (if Archi.ptr64 then 3%nat else 2%nat); destruct Archi.ptr64; auto."},{"statement":"(env : composite_env) (t : type) (z : Z) (a : attr) (IHt : exists n : nat, alignof env t = two_power_nat n) : exists n : nat,\n  (fix alignof (env0 : composite_env) (t0 : type) {struct t0} : Z :=\n     align_attr (attr_of_type t0)\n       match t0 with\n       | Tint I16 _ _ => 2\n       | Tlong _ _ => Archi.align_int64\n       | Tint I32 _ _ | Tfloat F32 _ => 4\n       | Tfloat F64 _ => Archi.align_float64\n       | Tpointer _ _ => if Archi.ptr64 then 8 else 4\n       | Tarray t' _ _ => alignof env0 t'\n       | Tstruct id _ | Tunion id _ =>\n           match env0 ! id with\n           | Some co => co_alignof co\n           | None => 1\n           end\n       | _ => 1\n       end) env t = two_power_nat n.","proofString":"apply IHt."},{"statement":"(env : composite_env) (l : list type) (t : type) (c : calling_convention) (IHt : exists n : nat, alignof env t = two_power_nat n) : exists n : nat, 1 = two_power_nat n.","proofString":"exists 0%nat; auto."},{"statement":"(env : composite_env) (i : ident) (a : attr) : exists n : nat,\n  match env ! i with\n  | Some co => co_alignof co\n  | None => 1\n  end = two_power_nat n.","proofString":"destruct (env!i).\napply co_alignof_two_p.\nexists 0%nat; auto."},{"statement":"(env : composite_env) (i : ident) (a : attr) (c : composite) : exists n : nat, co_alignof c = two_power_nat n.","proofString":"apply co_alignof_two_p."},{"statement":"(env : composite_env) (i : ident) (a : attr) : exists n : nat, 1 = two_power_nat n.","proofString":"exists 0%nat; auto."},{"statement":"(env : composite_env) (i : ident) (a : attr) : exists n : nat,\n  match env ! i with\n  | Some co => co_alignof co\n  | None => 1\n  end = two_power_nat n.","proofString":"destruct (env!i).\napply co_alignof_two_p.\nexists 0%nat; auto."},{"statement":"(env : composite_env) (i : ident) (a : attr) (c : composite) : exists n : nat, co_alignof c = two_power_nat n.","proofString":"apply co_alignof_two_p."},{"statement":"(env : composite_env) (i : ident) (a : attr) : exists n : nat, 1 = two_power_nat n.","proofString":"exists 0%nat; auto."},{"statement":"(env : composite_env) (t : type) : alignof env t > 0.","proofString":"destruct (alignof_two_p env t) as [n EQ].\nrewrite EQ.\napply two_power_nat_pos."},{"statement":"(env : composite_env) (t : type) (n : nat) (EQ : alignof env t = two_power_nat n) : alignof env t > 0.","proofString":"rewrite EQ.\napply two_power_nat_pos."},{"statement":"(env : composite_env) (t : type) (n : nat) (EQ : alignof env t = two_power_nat n) : two_power_nat n > 0.","proofString":"apply two_power_nat_pos."},{"statement":"(env : composite_env) : 1 >= 0.","proofString":"lia."},{"statement":"(env : composite_env) (i : intsize) (s : signedness) (a : attr) : match i with\n| I16 => 2\n| I32 => 4\n| _ => 1\nend >= 0.","proofString":"destruct i; lia."},{"statement":"(env : composite_env) (s : signedness) (a : attr) : 8 >= 0.","proofString":"lia."},{"statement":"(env : composite_env) (f : floatsize) (a : attr) : match f with\n| F32 => 4\n| F64 => 8\nend >= 0.","proofString":"destruct f; lia."},{"statement":"(env : composite_env) (t : type) (a : attr) (IHt : sizeof env t >= 0) : (if Archi.ptr64 then 8 else 4) >= 0.","proofString":"destruct Archi.ptr64; lia."},{"statement":"(env : composite_env) (t : type) (z : Z) (a : attr) (IHt : sizeof env t >= 0) : sizeof env t * Z.max 0 z >= 0.","proofString":"change 0 with (0 * Z.max 0 z) at 2.\napply Zmult_ge_compat_r.\nauto.\nlia."},{"statement":"(env : composite_env) (t : type) (z : Z) (a : attr) (IHt : sizeof env t >= 0) : sizeof env t * Z.max 0 z >= 0 * Z.max 0 z.","proofString":"apply Zmult_ge_compat_r.\nauto.\nlia."},{"statement":"(env : composite_env) (t : type) (z : Z) (a : attr) (IHt : sizeof env t >= 0) : sizeof env t >= 0.","proofString":"auto."},{"statement":"(env : composite_env) (t : type) (z : Z) (a : attr) (IHt : sizeof env t >= 0) : Z.max 0 z >= 0.","proofString":"lia."},{"statement":"(env : composite_env) (l : list type) (t : type) (c : calling_convention) (IHt : sizeof env t >= 0) : 1 >= 0.","proofString":"lia."},{"statement":"(env : composite_env) (i : ident) (a : attr) : match env ! i with\n| Some co => co_sizeof co\n| None => 0\nend >= 0.","proofString":"destruct (env!i).\napply co_sizeof_pos.\nlia."},{"statement":"(env : composite_env) (i : ident) (a : attr) (c : composite) : co_sizeof c >= 0.","proofString":"apply co_sizeof_pos."},{"statement":"(env : composite_env) (i : ident) (a : attr) : 0 >= 0.","proofString":"lia."},{"statement":"(env : composite_env) (i : ident) (a : attr) : match env ! i with\n| Some co => co_sizeof co\n| None => 0\nend >= 0.","proofString":"destruct (env!i).\napply co_sizeof_pos.\nlia."},{"statement":"(env : composite_env) (i : ident) (a : attr) (c : composite) : co_sizeof c >= 0.","proofString":"apply co_sizeof_pos."},{"statement":"(env : composite_env) (i : ident) (a : attr) : 0 >= 0.","proofString":"lia."},{"statement":"(env : composite_env) (A : attr_alignas (attr_of_type Tvoid) = None) (B : True) : (1 | 1).","proofString":"apply Z.divide_refl."},{"statement":"(env : composite_env) (i : intsize) (s : signedness) (a : attr) (A : attr_alignas (attr_of_type (Tint i s a)) = None) (B : True) : (match i with\n | I16 => 2\n | I32 => 4\n | _ => 1\n end | match i with\n       | I16 => 2\n       | I32 => 4\n       | _ => 1\n       end).","proofString":"destruct i; apply Z.divide_refl."},{"statement":"(env : composite_env) (s : signedness) (a : attr) (A : attr_alignas (attr_of_type (Tlong s a)) = None) (B : True) : (Archi.align_int64 | 8).","proofString":"exists (8 / Archi.align_int64).\nunfold Archi.align_int64; destruct Archi.ptr64; reflexivity."},{"statement":"(env : composite_env) (s : signedness) (a : attr) (A : attr_alignas (attr_of_type (Tlong s a)) = None) (B : True) : 8 = 8 / Archi.align_int64 * Archi.align_int64.","proofString":"unfold Archi.align_int64; destruct Archi.ptr64; reflexivity."},{"statement":"(env : composite_env) (f : floatsize) (a : attr) (A : attr_alignas (attr_of_type (Tfloat f a)) = None) (B : True) : (match f with\n | F32 => 4\n | F64 => Archi.align_float64\n end | match f with\n       | F32 => 4\n       | F64 => 8\n       end).","proofString":"destruct f.\napply Z.divide_refl.\nexists (8 / Archi.align_float64).\nunfold Archi.align_float64; destruct Archi.ptr64; reflexivity."},{"statement":"(env : composite_env) (a : attr) (A : attr_alignas (attr_of_type (Tfloat F32 a)) = None) (B : True) : (4 | 4).","proofString":"apply Z.divide_refl."},{"statement":"(env : composite_env) (a : attr) (A : attr_alignas (attr_of_type (Tfloat F64 a)) = None) (B : True) : (Archi.align_float64 | 8).","proofString":"exists (8 / Archi.align_float64).\nunfold Archi.align_float64; destruct Archi.ptr64; reflexivity."},{"statement":"(env : composite_env) (a : attr) (A : attr_alignas (attr_of_type (Tfloat F64 a)) = None) (B : True) : 8 = 8 / Archi.align_float64 * Archi.align_float64.","proofString":"unfold Archi.align_float64; destruct Archi.ptr64; reflexivity."},{"statement":"(env : composite_env) (t : type) (a : attr) (IHt : naturally_aligned t -> (alignof env t | sizeof env t)) (A : attr_alignas (attr_of_type (Tpointer t a)) = None) (B : True) : (if Archi.ptr64 then 8 else 4 | if Archi.ptr64 then 8 else 4).","proofString":"apply Z.divide_refl."},{"statement":"(env : composite_env) (t : type) (z : Z) (a : attr) (IHt : naturally_aligned t -> (alignof env t | sizeof env t)) (A : attr_alignas (attr_of_type (Tarray t z a)) = None) (B : naturally_aligned t) : ((fix alignof (env0 : composite_env) (t0 : type) {struct t0} : Z :=\n    match attr_alignas (attr_of_type t0) with\n    | Some l => two_p (Z.of_N l)\n    | None =>\n        match t0 with\n        | Tint I16 _ _ => 2\n        | Tlong _ _ => Archi.align_int64\n        | Tint I32 _ _ | Tfloat F32 _ => 4\n        | Tfloat F64 _ => Archi.align_float64\n        | Tpointer _ _ => if Archi.ptr64 then 8 else 4\n        | Tarray t' _ _ => alignof env0 t'\n        | Tstruct id _ | Tunion id _ =>\n            match env0 ! id with\n            | Some co => co_alignof co\n            | None => 1\n            end\n        | _ => 1\n        end\n    end) env t | sizeof env t * Z.max 0 z).","proofString":"apply Z.divide_mul_l; auto."},{"statement":"(env : composite_env) (l : list type) (t : type) (c : calling_convention) (IHt : naturally_aligned t -> (alignof env t | sizeof env t)) (A : attr_alignas (attr_of_type (Tfunction l t c)) = None) (B : True) : (1 | 1).","proofString":"apply Z.divide_refl."},{"statement":"(env : composite_env) (i : ident) (a : attr) (A : attr_alignas (attr_of_type (Tstruct i a)) = None) (B : True) : (match env ! i with\n | Some co => co_alignof co\n | None => 1\n end | match env ! i with\n       | Some co => co_sizeof co\n       | None => 0\n       end).","proofString":"destruct (env!i).\napply co_sizeof_alignof.\napply Z.divide_0_r."},{"statement":"(env : composite_env) (i : ident) (a : attr) (A : attr_alignas (attr_of_type (Tstruct i a)) = None) (B : True) (c : composite) : (co_alignof c | co_sizeof c).","proofString":"apply co_sizeof_alignof."},{"statement":"(env : composite_env) (i : ident) (a : attr) (A : attr_alignas (attr_of_type (Tstruct i a)) = None) (B : True) : (1 | 0).","proofString":"apply Z.divide_0_r."},{"statement":"(env : composite_env) (i : ident) (a : attr) (A : attr_alignas (attr_of_type (Tunion i a)) = None) (B : True) : (match env ! i with\n | Some co => co_alignof co\n | None => 1\n end | match env ! i with\n       | Some co => co_sizeof co\n       | None => 0\n       end).","proofString":"destruct (env!i).\napply co_sizeof_alignof.\napply Z.divide_0_r."},{"statement":"(env : composite_env) (i : ident) (a : attr) (A : attr_alignas (attr_of_type (Tunion i a)) = None) (B : True) (c : composite) : (co_alignof c | co_sizeof c).","proofString":"apply co_sizeof_alignof."},{"statement":"(env : composite_env) (i : ident) (a : attr) (A : attr_alignas (attr_of_type (Tunion i a)) = None) (B : True) : (1 | 0).","proofString":"apply Z.divide_0_r."},{"statement":"(pos : Z) (m : member) : pos <= next_field pos m.","proofString":"unfold next_field.\ndestruct m.\nset (al := bitalignof t).\nassert (A: al > 0).\nunfold al, bitalignof.\ngeneralize (alignof_pos env t).\nlia.\nassert (pos <= align pos al) by (apply align_le; auto).\nassert (bitsizeof t >= 0).\nunfold bitsizeof.\ngeneralize (sizeof_pos env t).\nlia.\nlia.\nset (s := bitalignof_intsize sz).\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\ndestruct (zle width 0).\napply align_le; auto.\ngeneralize (floor_interval pos s A).\nset (start := floor pos s).\nintros B.\ndestruct (zle (pos + width) (start + s)); lia."},{"statement":"(pos : Z) (m : member) : pos <=\nmatch m with\n| Member_plain _ t => align pos (bitalignof t) + bitsizeof t\n| Member_bitfield _ sz _ _ w _ =>\n    if zle w 0\n    then align pos (bitalignof_intsize sz)\n    else\n     if\n      zle (pos + w)\n        (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n     then pos + w\n     else floor pos (bitalignof_intsize sz) + bitalignof_intsize sz + w\nend.","proofString":"destruct m.\nset (al := bitalignof t).\nassert (A: al > 0).\nunfold al, bitalignof.\ngeneralize (alignof_pos env t).\nlia.\nassert (pos <= align pos al) by (apply align_le; auto).\nassert (bitsizeof t >= 0).\nunfold bitsizeof.\ngeneralize (sizeof_pos env t).\nlia.\nlia.\nset (s := bitalignof_intsize sz).\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\ndestruct (zle width 0).\napply align_le; auto.\ngeneralize (floor_interval pos s A).\nset (start := floor pos s).\nintros B.\ndestruct (zle (pos + width) (start + s)); lia."},{"statement":"(pos : Z) (id : ident) (t : type) : pos <= align pos (bitalignof t) + bitsizeof t.","proofString":"set (al := bitalignof t).\nassert (A: al > 0).\nunfold al, bitalignof.\ngeneralize (alignof_pos env t).\nlia.\nassert (pos <= align pos al) by (apply align_le; auto).\nassert (bitsizeof t >= 0).\nunfold bitsizeof.\ngeneralize (sizeof_pos env t).\nlia.\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) : alignof env t * 8 > 0.","proofString":"generalize (alignof_pos env t).\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) : alignof env t > 0 -> alignof env t * 8 > 0.","proofString":"lia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (A : al > 0) : pos <= align pos al + bitsizeof t.","proofString":"assert (pos <= align pos al) by (apply align_le; auto).\nassert (bitsizeof t >= 0).\nunfold bitsizeof.\ngeneralize (sizeof_pos env t).\nlia.\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (A : al > 0) (H : pos <= align pos al) : pos <= align pos al + bitsizeof t.","proofString":"assert (bitsizeof t >= 0).\nunfold bitsizeof.\ngeneralize (sizeof_pos env t).\nlia.\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (A : al > 0) (H : pos <= align pos al) : bitsizeof t >= 0.","proofString":"unfold bitsizeof.\ngeneralize (sizeof_pos env t).\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (A : al > 0) (H : pos <= align pos al) : sizeof env t * 8 >= 0.","proofString":"generalize (sizeof_pos env t).\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (A : al > 0) (H : pos <= align pos al) : sizeof env t >= 0 -> sizeof env t * 8 >= 0.","proofString":"lia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (A : al > 0) (H : pos <= align pos al) (H0 : bitsizeof t >= 0) : pos <= align pos al + bitsizeof t.","proofString":"lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) : pos <=\n(if zle width 0\n then align pos (bitalignof_intsize sz)\n else\n  if\n   zle (pos + width)\n     (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n  then pos + width\n  else floor pos (bitalignof_intsize sz) + bitalignof_intsize sz + width).","proofString":"set (s := bitalignof_intsize sz).\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\ndestruct (zle width 0).\napply align_le; auto.\ngeneralize (floor_interval pos s A).\nset (start := floor pos s).\nintros B.\ndestruct (zle (pos + width) (start + s)); lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (s : Z) (A : s > 0) : pos <=\n(if zle width 0\n then align pos s\n else\n  if zle (pos + width) (floor pos s + s)\n  then pos + width\n  else floor pos s + s + width).","proofString":"destruct (zle width 0).\napply align_le; auto.\ngeneralize (floor_interval pos s A).\nset (start := floor pos s).\nintros B.\ndestruct (zle (pos + width) (start + s)); lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (s : Z) (A : s > 0) (l : width <= 0) : pos <= align pos s.","proofString":"apply align_le; auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (s : Z) (A : s > 0) (g : width > 0) : pos <=\n(if zle (pos + width) (floor pos s + s)\n then pos + width\n else floor pos s + s + width).","proofString":"generalize (floor_interval pos s A).\nset (start := floor pos s).\nintros B.\ndestruct (zle (pos + width) (start + s)); lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (s : Z) (A : s > 0) (g : width > 0) : floor pos s <= pos < floor pos s + s ->\npos <=\n(if zle (pos + width) (floor pos s + s)\n then pos + width\n else floor pos s + s + width).","proofString":"set (start := floor pos s).\nintros B.\ndestruct (zle (pos + width) (start + s)); lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (s : Z) (A : s > 0) (g : width > 0) (start : Z) : start <= pos < start + s ->\npos <=\n(if zle (pos + width) (start + s) then pos + width else start + s + width).","proofString":"intros B.\ndestruct (zle (pos + width) (start + s)); lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (s : Z) (A : s > 0) (g : width > 0) (start : Z) (B : start <= pos < start + s) : pos <=\n(if zle (pos + width) (start + s) then pos + width else start + s + width).","proofString":"destruct (zle (pos + width) (start + s)); lia."},{"statement":"(pos : Z) (m : member) (ofs : Z) (bf : bitfield) (L : layout_field pos m = OK (ofs, bf)) : pos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width (type_member m) bf <= next_field pos m.","proofString":"unfold layout_start, layout_width.\ndestruct m; simpl in L.\ninv L.\nsimpl.\nset (al := bitalignof t).\nset (q := align pos al).\nassert (A: al > 0).\nunfold al, bitalignof.\ngeneralize (alignof_pos env t).\nlia.\nassert (B: pos <= q) by (apply align_le; auto).\nassert (C: (al | q)) by (apply align_divides; auto).\nassert (D: (8 | q)).\napply Z.divide_transitive with al; auto.\napply Z.divide_factor_r.\nassert (E: q / 8 * 8 = q).\ndestruct D as (n & E).\nrewrite E.\nrewrite Z.div_mul by lia.\nauto.\nrewrite E.\nlia.\nunfold next_field.\ndestruct (zle width 0); try discriminate.\ndestruct (zlt (bitsize_intsize sz) width); try discriminate.\nset (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\ngeneralize (floor_interval pos s A).\nset (p := floor pos s) in *.\nintros B.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: (8 | p)) by (apply Z.divide_transitive with s; auto).\nassert (F: (8 | p + s)) by (apply Z.divide_add_r; auto).\nassert (G: p / 8 * 8 = p).\ndestruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\nassert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (m : member) (ofs : Z) (bf : bitfield) (L : layout_field pos m = OK (ofs, bf)) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member m)\n| Bits _ _ _ w => w\nend <= next_field pos m.","proofString":"destruct m; simpl in L.\ninv L.\nsimpl.\nset (al := bitalignof t).\nset (q := align pos al).\nassert (A: al > 0).\nunfold al, bitalignof.\ngeneralize (alignof_pos env t).\nlia.\nassert (B: pos <= q) by (apply align_le; auto).\nassert (C: (al | q)) by (apply align_divides; auto).\nassert (D: (8 | q)).\napply Z.divide_transitive with al; auto.\napply Z.divide_factor_r.\nassert (E: q / 8 * 8 = q).\ndestruct D as (n & E).\nrewrite E.\nrewrite Z.div_mul by lia.\nauto.\nrewrite E.\nlia.\nunfold next_field.\ndestruct (zle width 0); try discriminate.\ndestruct (zlt (bitsize_intsize sz) width); try discriminate.\nset (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\ngeneralize (floor_interval pos s A).\nset (p := floor pos s) in *.\nintros B.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: (8 | p)) by (apply Z.divide_transitive with s; auto).\nassert (F: (8 | p + s)) by (apply Z.divide_add_r; auto).\nassert (G: p / 8 * 8 = p).\ndestruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\nassert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (id : ident) (t : type) (ofs : Z) (bf : bitfield) (L : OK (align pos (bitalignof t) / 8, Full) = OK (ofs, bf)) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_plain id t))\n| Bits _ _ _ w => w\nend <= next_field pos (Member_plain id t).","proofString":"inv L.\nsimpl.\nset (al := bitalignof t).\nset (q := align pos al).\nassert (A: al > 0).\nunfold al, bitalignof.\ngeneralize (alignof_pos env t).\nlia.\nassert (B: pos <= q) by (apply align_le; auto).\nassert (C: (al | q)) by (apply align_divides; auto).\nassert (D: (8 | q)).\napply Z.divide_transitive with al; auto.\napply Z.divide_factor_r.\nassert (E: q / 8 * 8 = q).\ndestruct D as (n & E).\nrewrite E.\nrewrite Z.div_mul by lia.\nauto.\nrewrite E.\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) : pos <= align pos (bitalignof t) / 8 * 8 + 0 /\\\nalign pos (bitalignof t) / 8 * 8 + 0 +\nbitsizeof (type_member (Member_plain id t)) <=\nnext_field pos (Member_plain id t).","proofString":"simpl.\nset (al := bitalignof t).\nset (q := align pos al).\nassert (A: al > 0).\nunfold al, bitalignof.\ngeneralize (alignof_pos env t).\nlia.\nassert (B: pos <= q) by (apply align_le; auto).\nassert (C: (al | q)) by (apply align_divides; auto).\nassert (D: (8 | q)).\napply Z.divide_transitive with al; auto.\napply Z.divide_factor_r.\nassert (E: q / 8 * 8 = q).\ndestruct D as (n & E).\nrewrite E.\nrewrite Z.div_mul by lia.\nauto.\nrewrite E.\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) : pos <= align pos (bitalignof t) / 8 * 8 + 0 /\\\nalign pos (bitalignof t) / 8 * 8 + 0 + bitsizeof t <=\nalign pos (bitalignof t) + bitsizeof t.","proofString":"set (al := bitalignof t).\nset (q := align pos al).\nassert (A: al > 0).\nunfold al, bitalignof.\ngeneralize (alignof_pos env t).\nlia.\nassert (B: pos <= q) by (apply align_le; auto).\nassert (C: (al | q)) by (apply align_divides; auto).\nassert (D: (8 | q)).\napply Z.divide_transitive with al; auto.\napply Z.divide_factor_r.\nassert (E: q / 8 * 8 = q).\ndestruct D as (n & E).\nrewrite E.\nrewrite Z.div_mul by lia.\nauto.\nrewrite E.\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (q : Z) : alignof env t * 8 > 0.","proofString":"generalize (alignof_pos env t).\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (q : Z) : alignof env t > 0 -> alignof env t * 8 > 0.","proofString":"lia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (q : Z) (A : al > 0) (B : pos <= q) (C : (al | q)) (D : (8 | q)) : pos <= q / 8 * 8 + 0 /\\ q / 8 * 8 + 0 + bitsizeof t <= q + bitsizeof t.","proofString":"assert (E: q / 8 * 8 = q).\ndestruct D as (n & E).\nrewrite E.\nrewrite Z.div_mul by lia.\nauto.\nrewrite E.\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (q : Z) (A : al > 0) (B : pos <= q) (C : (al | q)) (D : (8 | q)) : q / 8 * 8 = q.","proofString":"destruct D as (n & E).\nrewrite E.\nrewrite Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (q : Z) (A : al > 0) (B : pos <= q) (C : (al | q)) (n : Z) (E : q = n * 8) : q / 8 * 8 = q.","proofString":"rewrite E.\nrewrite Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (q : Z) (A : al > 0) (B : pos <= q) (C : (al | q)) (n : Z) (E : q = n * 8) : n * 8 / 8 * 8 = n * 8.","proofString":"rewrite Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (q : Z) (A : al > 0) (B : pos <= q) (C : (al | q)) (n : Z) (E : q = n * 8) : n * 8 = n * 8.","proofString":"auto."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (q : Z) (A : al > 0) (B : pos <= q) (C : (al | q)) (D : (8 | q)) (E : q / 8 * 8 = q) : pos <= q / 8 * 8 + 0 /\\ q / 8 * 8 + 0 + bitsizeof t <= q + bitsizeof t.","proofString":"rewrite E.\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (al : Z) (q : Z) (A : al > 0) (B : pos <= q) (C : (al | q)) (D : (8 | q)) (E : q / 8 * 8 = q) : pos <= q + 0 /\\ q + 0 + bitsizeof t <= q + bitsizeof t.","proofString":"lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (L : (if zle width 0\n then Error (msg \"accessing zero-width bitfield\")\n else\n  if zlt (bitsize_intsize sz) width\n  then Error (msg \"bitfield too wide\")\n  else\n   if\n    zle (pos + width)\n      (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n   then\n    OK\n      (floor pos (bitalignof_intsize sz) / 8,\n       Bits sz sg (pos - floor pos (bitalignof_intsize sz)) width)\n   else\n    OK\n      ((floor pos (bitalignof_intsize sz) + bitalignof_intsize sz) / 8,\n       Bits sz sg 0 width)) = OK (ofs, bf)) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_bitfield id sz sg a width padding))\n| Bits _ _ _ w => w\nend <= next_field pos (Member_bitfield id sz sg a width padding).","proofString":"unfold next_field.\ndestruct (zle width 0); try discriminate.\ndestruct (zlt (bitsize_intsize sz) width); try discriminate.\nset (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\ngeneralize (floor_interval pos s A).\nset (p := floor pos s) in *.\nintros B.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: (8 | p)) by (apply Z.divide_transitive with s; auto).\nassert (F: (8 | p + s)) by (apply Z.divide_add_r; auto).\nassert (G: p / 8 * 8 = p).\ndestruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\nassert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (L : (if zle width 0\n then Error (msg \"accessing zero-width bitfield\")\n else\n  if zlt (bitsize_intsize sz) width\n  then Error (msg \"bitfield too wide\")\n  else\n   if\n    zle (pos + width)\n      (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n   then\n    OK\n      (floor pos (bitalignof_intsize sz) / 8,\n       Bits sz sg (pos - floor pos (bitalignof_intsize sz)) width)\n   else\n    OK\n      ((floor pos (bitalignof_intsize sz) + bitalignof_intsize sz) / 8,\n       Bits sz sg 0 width)) = OK (ofs, bf)) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_bitfield id sz sg a width padding))\n| Bits _ _ _ w => w\nend <=\n(if zle width 0\n then align pos (bitalignof_intsize sz)\n else\n  if\n   zle (pos + width)\n     (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n  then pos + width\n  else floor pos (bitalignof_intsize sz) + bitalignof_intsize sz + width).","proofString":"destruct (zle width 0); try discriminate.\ndestruct (zlt (bitsize_intsize sz) width); try discriminate.\nset (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\ngeneralize (floor_interval pos s A).\nset (p := floor pos s) in *.\nintros B.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: (8 | p)) by (apply Z.divide_transitive with s; auto).\nassert (F: (8 | p + s)) by (apply Z.divide_add_r; auto).\nassert (G: p / 8 * 8 = p).\ndestruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\nassert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (L : (if zlt (bitsize_intsize sz) width\n then Error (msg \"bitfield too wide\")\n else\n  if\n   zle (pos + width)\n     (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n  then\n   OK\n     (floor pos (bitalignof_intsize sz) / 8,\n      Bits sz sg (pos - floor pos (bitalignof_intsize sz)) width)\n  else\n   OK\n     ((floor pos (bitalignof_intsize sz) + bitalignof_intsize sz) / 8,\n      Bits sz sg 0 width)) = OK (ofs, bf)) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_bitfield id sz sg a width padding))\n| Bits _ _ _ w => w\nend <=\n(if\n  zle (pos + width)\n    (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n then pos + width\n else floor pos (bitalignof_intsize sz) + bitalignof_intsize sz + width).","proofString":"destruct (zlt (bitsize_intsize sz) width); try discriminate.\nset (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\ngeneralize (floor_interval pos s A).\nset (p := floor pos s) in *.\nintros B.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: (8 | p)) by (apply Z.divide_transitive with s; auto).\nassert (F: (8 | p + s)) by (apply Z.divide_add_r; auto).\nassert (G: p / 8 * 8 = p).\ndestruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\nassert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (L : (if\n  zle (pos + width)\n    (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n then\n  OK\n    (floor pos (bitalignof_intsize sz) / 8,\n     Bits sz sg (pos - floor pos (bitalignof_intsize sz)) width)\n else\n  OK\n    ((floor pos (bitalignof_intsize sz) + bitalignof_intsize sz) / 8,\n     Bits sz sg 0 width)) = OK (ofs, bf)) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_bitfield id sz sg a width padding))\n| Bits _ _ _ w => w\nend <=\n(if\n  zle (pos + width)\n    (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n then pos + width\n else floor pos (bitalignof_intsize sz) + bitalignof_intsize sz + width).","proofString":"set (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\ngeneralize (floor_interval pos s A).\nset (p := floor pos s) in *.\nintros B.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: (8 | p)) by (apply Z.divide_transitive with s; auto).\nassert (F: (8 | p + s)) by (apply Z.divide_add_r; auto).\nassert (G: p / 8 * 8 = p).\ndestruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\nassert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) : bitalignof_intsize sz = bitalignof_intsize sz / 8 * 8.","proofString":"destruct sz; reflexivity."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_bitfield id sz sg a width padding))\n| Bits _ _ _ w => w\nend <= (if zle (pos + width) (p + s) then pos + width else p + s + width).","proofString":"assert (E: (8 | p)) by (apply Z.divide_transitive with s; auto).\nassert (F: (8 | p + s)) by (apply Z.divide_add_r; auto).\nassert (G: p / 8 * 8 = p).\ndestruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\nassert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (E : (8 | p)) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_bitfield id sz sg a width padding))\n| Bits _ _ _ w => w\nend <= (if zle (pos + width) (p + s) then pos + width else p + s + width).","proofString":"assert (F: (8 | p + s)) by (apply Z.divide_add_r; auto).\nassert (G: p / 8 * 8 = p).\ndestruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\nassert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (E : (8 | p)) (F : (8 | p + s)) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_bitfield id sz sg a width padding))\n| Bits _ _ _ w => w\nend <= (if zle (pos + width) (p + s) then pos + width else p + s + width).","proofString":"assert (G: p / 8 * 8 = p).\ndestruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\nassert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (E : (8 | p)) (F : (8 | p + s)) : p / 8 * 8 = p.","proofString":"destruct E as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (n : Z) (EQ : p = n * 8) (F : (8 | p + s)) : p / 8 * 8 = p.","proofString":"rewrite EQ.\nrewrite Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (n : Z) (EQ : p = n * 8) (F : (8 | p + s)) : n * 8 / 8 * 8 = n * 8.","proofString":"rewrite Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (n : Z) (EQ : p = n * 8) (F : (8 | p + s)) : n * 8 = n * 8.","proofString":"auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (E : (8 | p)) (F : (8 | p + s)) (G : p / 8 * 8 = p) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_bitfield id sz sg a width padding))\n| Bits _ _ _ w => w\nend <= (if zle (pos + width) (p + s) then pos + width else p + s + width).","proofString":"assert (H: (p + s) / 8 * 8 = p + s).\ndestruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto.\ndestruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (E : (8 | p)) (F : (8 | p + s)) (G : p / 8 * 8 = p) : (p + s) / 8 * 8 = p + s.","proofString":"destruct F as (n & EQ).\nrewrite EQ.\nrewrite Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (E : (8 | p)) (n : Z) (EQ : p + s = n * 8) (G : p / 8 * 8 = p) : (p + s) / 8 * 8 = p + s.","proofString":"rewrite EQ.\nrewrite Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (E : (8 | p)) (n : Z) (EQ : p + s = n * 8) (G : p / 8 * 8 = p) : n * 8 / 8 * 8 = n * 8.","proofString":"rewrite Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (E : (8 | p)) (n : Z) (EQ : p + s = n * 8) (G : p / 8 * 8 = p) : n * 8 = n * 8.","proofString":"auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (B : p <= pos < p + s) (C : (s | p)) (D : (8 | s)) (E : (8 | p)) (F : (8 | p + s)) (G : p / 8 * 8 = p) (H : (p + s) / 8 * 8 = p + s) : pos <= ofs * 8 + match bf with\n                 | Full => 0\n                 | Bits _ _ pos0 _ => pos0\n                 end /\\\nofs * 8 + match bf with\n          | Full => 0\n          | Bits _ _ pos0 _ => pos0\n          end +\nmatch bf with\n| Full => bitsizeof (type_member (Member_bitfield id sz sg a width padding))\n| Bits _ _ _ w => w\nend <= (if zle (pos + width) (p + s) then pos + width else p + s + width).","proofString":"destruct (zle (pos + width) (p + s)); inv L; lia."},{"statement":"(pos : Z) (m : member) (ofs : Z) (bf : bitfield) (L : layout_field pos m = OK (ofs, bf)) : (layout_alignment (type_member m) bf | ofs).","proofString":"destruct m; simpl in L.\ninv L; simpl.\nset (q := align pos (bitalignof t)).\nassert (A: (bitalignof t | q)).\napply align_divides.\nunfold bitalignof.\ngeneralize (alignof_pos env t).\nlia.\ndestruct A as [n E].\nexists n.\nrewrite E.\nunfold bitalignof.\nrewrite Z.mul_assoc, Z.div_mul by lia.\nauto.\ndestruct (zle width 0); try discriminate.\ndestruct (zlt (bitsize_intsize sz) width); try discriminate.\nset (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\nset (p := floor pos s) in *.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: forall n, (s | n) -> (s / 8 | n / 8)).\nintros.\ndestruct H as [n1 E1], D as [n2 E2].\nrewrite E1, E2.\nrewrite Z.mul_assoc, ! Z.div_mul by lia.\nexists n1; auto.\ndestruct (zle (pos + width) (p + s)); inv L; simpl; fold s.\napply E.\nauto.\napply E.\napply Z.divide_add_r; auto using Z.divide_refl."},{"statement":"(pos : Z) (id : ident) (t : type) (ofs : Z) (bf : bitfield) (L : OK (align pos (bitalignof t) / 8, Full) = OK (ofs, bf)) : (layout_alignment (type_member (Member_plain id t)) bf | ofs).","proofString":"inv L; simpl.\nset (q := align pos (bitalignof t)).\nassert (A: (bitalignof t | q)).\napply align_divides.\nunfold bitalignof.\ngeneralize (alignof_pos env t).\nlia.\ndestruct A as [n E].\nexists n.\nrewrite E.\nunfold bitalignof.\nrewrite Z.mul_assoc, Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) : (alignof env t | align pos (bitalignof t) / 8).","proofString":"set (q := align pos (bitalignof t)).\nassert (A: (bitalignof t | q)).\napply align_divides.\nunfold bitalignof.\ngeneralize (alignof_pos env t).\nlia.\ndestruct A as [n E].\nexists n.\nrewrite E.\nunfold bitalignof.\nrewrite Z.mul_assoc, Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (q : Z) : bitalignof t > 0.","proofString":"unfold bitalignof.\ngeneralize (alignof_pos env t).\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (q : Z) : alignof env t * 8 > 0.","proofString":"generalize (alignof_pos env t).\nlia."},{"statement":"(pos : Z) (id : ident) (t : type) (q : Z) : alignof env t > 0 -> alignof env t * 8 > 0.","proofString":"lia."},{"statement":"(pos : Z) (id : ident) (t : type) (q : Z) (A : (bitalignof t | q)) : (alignof env t | q / 8).","proofString":"destruct A as [n E].\nexists n.\nrewrite E.\nunfold bitalignof.\nrewrite Z.mul_assoc, Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (q : Z) (n : Z) (E : q = n * bitalignof t) : (alignof env t | q / 8).","proofString":"exists n.\nrewrite E.\nunfold bitalignof.\nrewrite Z.mul_assoc, Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (q : Z) (n : Z) (E : q = n * bitalignof t) : q / 8 = n * alignof env t.","proofString":"rewrite E.\nunfold bitalignof.\nrewrite Z.mul_assoc, Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (q : Z) (n : Z) (E : q = n * bitalignof t) : n * bitalignof t / 8 = n * alignof env t.","proofString":"unfold bitalignof.\nrewrite Z.mul_assoc, Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (q : Z) (n : Z) (E : q = n * bitalignof t) : n * (alignof env t * 8) / 8 = n * alignof env t.","proofString":"rewrite Z.mul_assoc, Z.div_mul by lia.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (q : Z) (n : Z) (E : q = n * bitalignof t) : n * alignof env t = n * alignof env t.","proofString":"auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (L : (if zle width 0\n then Error (msg \"accessing zero-width bitfield\")\n else\n  if zlt (bitsize_intsize sz) width\n  then Error (msg \"bitfield too wide\")\n  else\n   if\n    zle (pos + width)\n      (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n   then\n    OK\n      (floor pos (bitalignof_intsize sz) / 8,\n       Bits sz sg (pos - floor pos (bitalignof_intsize sz)) width)\n   else\n    OK\n      ((floor pos (bitalignof_intsize sz) + bitalignof_intsize sz) / 8,\n       Bits sz sg 0 width)) = OK (ofs, bf)) : (layout_alignment (type_member (Member_bitfield id sz sg a width padding)) bf\n| ofs).","proofString":"destruct (zle width 0); try discriminate.\ndestruct (zlt (bitsize_intsize sz) width); try discriminate.\nset (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\nset (p := floor pos s) in *.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: forall n, (s | n) -> (s / 8 | n / 8)).\nintros.\ndestruct H as [n1 E1], D as [n2 E2].\nrewrite E1, E2.\nrewrite Z.mul_assoc, ! Z.div_mul by lia.\nexists n1; auto.\ndestruct (zle (pos + width) (p + s)); inv L; simpl; fold s.\napply E.\nauto.\napply E.\napply Z.divide_add_r; auto using Z.divide_refl."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (L : (if zlt (bitsize_intsize sz) width\n then Error (msg \"bitfield too wide\")\n else\n  if\n   zle (pos + width)\n     (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n  then\n   OK\n     (floor pos (bitalignof_intsize sz) / 8,\n      Bits sz sg (pos - floor pos (bitalignof_intsize sz)) width)\n  else\n   OK\n     ((floor pos (bitalignof_intsize sz) + bitalignof_intsize sz) / 8,\n      Bits sz sg 0 width)) = OK (ofs, bf)) : (layout_alignment (type_member (Member_bitfield id sz sg a width padding)) bf\n| ofs).","proofString":"destruct (zlt (bitsize_intsize sz) width); try discriminate.\nset (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\nset (p := floor pos s) in *.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: forall n, (s | n) -> (s / 8 | n / 8)).\nintros.\ndestruct H as [n1 E1], D as [n2 E2].\nrewrite E1, E2.\nrewrite Z.mul_assoc, ! Z.div_mul by lia.\nexists n1; auto.\ndestruct (zle (pos + width) (p + s)); inv L; simpl; fold s.\napply E.\nauto.\napply E.\napply Z.divide_add_r; auto using Z.divide_refl."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (L : (if\n  zle (pos + width)\n    (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n then\n  OK\n    (floor pos (bitalignof_intsize sz) / 8,\n     Bits sz sg (pos - floor pos (bitalignof_intsize sz)) width)\n else\n  OK\n    ((floor pos (bitalignof_intsize sz) + bitalignof_intsize sz) / 8,\n     Bits sz sg 0 width)) = OK (ofs, bf)) : (layout_alignment (type_member (Member_bitfield id sz sg a width padding)) bf\n| ofs).","proofString":"set (s := bitalignof_intsize sz) in *.\nassert (A: s > 0) by (apply bitalignof_intsize_pos).\nset (p := floor pos s) in *.\nassert (C: (s | p)) by (apply floor_divides; auto).\nassert (D: (8 | s)).\nexists (s / 8).\nunfold s.\ndestruct sz; reflexivity.\nassert (E: forall n, (s | n) -> (s / 8 | n / 8)).\nintros.\ndestruct H as [n1 E1], D as [n2 E2].\nrewrite E1, E2.\nrewrite Z.mul_assoc, ! Z.div_mul by lia.\nexists n1; auto.\ndestruct (zle (pos + width) (p + s)); inv L; simpl; fold s.\napply E.\nauto.\napply E.\napply Z.divide_add_r; auto using Z.divide_refl."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (C : (s | p)) : bitalignof_intsize sz = bitalignof_intsize sz / 8 * 8.","proofString":"destruct sz; reflexivity."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (C : (s | p)) (D : (8 | s)) : forall n : Z, (s | n) -> (s / 8 | n / 8).","proofString":"intros.\ndestruct H as [n1 E1], D as [n2 E2].\nrewrite E1, E2.\nrewrite Z.mul_assoc, ! Z.div_mul by lia.\nexists n1; auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (C : (s | p)) (D : (8 | s)) (n : Z) (H : (s | n)) : (s / 8 | n / 8).","proofString":"destruct H as [n1 E1], D as [n2 E2].\nrewrite E1, E2.\nrewrite Z.mul_assoc, ! Z.div_mul by lia.\nexists n1; auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (C : (s | p)) (n2 : Z) (E2 : s = n2 * 8) (n n1 : Z) (E1 : n = n1 * s) : (s / 8 | n / 8).","proofString":"rewrite E1, E2.\nrewrite Z.mul_assoc, ! Z.div_mul by lia.\nexists n1; auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (C : (s | p)) (n2 : Z) (E2 : s = n2 * 8) (n n1 : Z) (E1 : n = n1 * s) : (n2 * 8 / 8 | n1 * (n2 * 8) / 8).","proofString":"rewrite Z.mul_assoc, ! Z.div_mul by lia.\nexists n1; auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ofs : Z) (bf : bitfield) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (L : (if zle (pos + width) (p + s)\n then OK (p / 8, Bits sz sg (pos - p) width)\n else OK ((p + s) / 8, Bits sz sg 0 width)) = OK (ofs, bf)) (A : s > 0) (C : (s | p)) (n2 : Z) (E2 : s = n2 * 8) (n n1 : Z) (E1 : n = n1 * s) : (n2 | n1 * n2).","proofString":"exists n1; auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (l : pos + width <= p + s) (A : s > 0) (C : (s | p)) (D : (8 | s)) (E : forall n : Z, (s | n) -> (s / 8 | n / 8)) : (s / 8 | p / 8).","proofString":"apply E.\nauto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (l : pos + width <= p + s) (A : s > 0) (C : (s | p)) (D : (8 | s)) (E : forall n : Z, (s | n) -> (s / 8 | n / 8)) : (s | p).","proofString":"auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (g1 : pos + width > p + s) (A : s > 0) (C : (s | p)) (D : (8 | s)) (E : forall n : Z, (s | n) -> (s / 8 | n / 8)) : (s / 8 | (p + s) / 8).","proofString":"apply E.\napply Z.divide_add_r; auto using Z.divide_refl."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (g : width > 0) (g0 : bitsize_intsize sz >= width) (s : Z) (p : Z) (g1 : pos + width > p + s) (A : s > 0) (C : (s | p)) (D : (8 | s)) (E : forall n : Z, (s | n) -> (s / 8 | n / 8)) : (s | p + s).","proofString":"apply Z.divide_add_r; auto using Z.divide_refl."},{"statement":"(env : composite_env) : exists n : nat, 1 = two_power_nat n.","proofString":"exists 0%nat; auto."},{"statement":"(env : composite_env) (a : member) (m : list member) (IHm : exists n : nat, alignof_composite env m = two_power_nat n) : exists n : nat,\n  (if member_is_padding a\n   then alignof_composite env m\n   else Z.max (alignof env (type_member a)) (alignof_composite env m)) =\n  two_power_nat n.","proofString":"destruct (member_is_padding a); auto.\napply Z.max_case; auto.\napply alignof_two_p."},{"statement":"(env : composite_env) (a : member) (m : list member) (IHm : exists n : nat, alignof_composite env m = two_power_nat n) : exists n : nat,\n  Z.max (alignof env (type_member a)) (alignof_composite env m) =\n  two_power_nat n.","proofString":"apply Z.max_case; auto.\napply alignof_two_p."},{"statement":"(env : composite_env) (a : member) (m : list member) (IHm : exists n : nat, alignof_composite env m = two_power_nat n) : exists n : nat, alignof env (type_member a) = two_power_nat n.","proofString":"apply alignof_two_p."},{"statement":"(env : composite_env) (m : members) (a : attr) : align_attr a (alignof_composite env m) > 0.","proofString":"exploit align_attr_two_p.\napply (alignof_composite_two_p env m).\ninstantiate (1 := a).\nintros [n EQ].\nrewrite EQ; apply two_power_nat_pos."},{"statement":"(env : composite_env) (m : members) (a : attr) : (exists n : nat, align_attr a (alignof_composite env m) = two_power_nat n) ->\nalign_attr a (alignof_composite env m) > 0.","proofString":"intros [n EQ].\nrewrite EQ; apply two_power_nat_pos."},{"statement":"(env : composite_env) (m : members) (a : attr) (n : nat) (EQ : align_attr a (alignof_composite env m) = two_power_nat n) : align_attr a (alignof_composite env m) > 0.","proofString":"rewrite EQ; apply two_power_nat_pos."},{"statement":"(env : composite_env) (cur : Z) : cur <= cur.","proofString":"lia."},{"statement":"(env : composite_env) (a : member) (m : list member) (IHm : forall cur0 : Z, cur0 <= bitsizeof_struct env cur0 m) (cur : Z) : cur <= bitsizeof_struct env (next_field env cur a) m.","proofString":"apply Z.le_trans with (next_field env cur a).\napply next_field_incr.\napply IHm."},{"statement":"(env : composite_env) (a : member) (m : list member) (IHm : forall cur0 : Z, cur0 <= bitsizeof_struct env cur0 m) (cur : Z) : cur <= next_field env cur a.","proofString":"apply next_field_incr."},{"statement":"(env : composite_env) (a : member) (m : list member) (IHm : forall cur0 : Z, cur0 <= bitsizeof_struct env cur0 m) (cur : Z) : next_field env cur a <= bitsizeof_struct env (next_field env cur a) m.","proofString":"apply IHm."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (pos : Z) (H : Error (MSG \"Unknown field \" :: CTX id :: nil) = OK (ofs, bf)) (H0 : Error (MSG \"Unknown field \" :: CTX id :: nil) = OK ty) : pos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= pos.","proofString":"discriminate."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (ms : list member) (IHms : forall pos0 : Z,\nfield_offset_rec env id ms pos0 = OK (ofs, bf) ->\nfield_type id ms = OK ty ->\npos0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= bitsizeof_struct env pos0 ms) (pos : Z) (H : (if ident_eq id (name_member m)\n then layout_field env pos m\n else field_offset_rec env id ms (next_field env pos m)) = \nOK (ofs, bf)) (H0 : (if ident_eq id (name_member m) then OK (type_member m) else field_type id ms) =\nOK ty) : pos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"destruct (ident_eq id (name_member m)).\ninv H0.\nexploit layout_field_range; eauto.\ngeneralize (bitsizeof_struct_incr env ms (next_field env pos m)).\nlia.\nexploit IHms; eauto.\ngeneralize (next_field_incr env pos m).\nlia."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (ms : list member) (IHms : forall pos0 : Z,\nfield_offset_rec env id ms pos0 = OK (ofs, bf) ->\nfield_type id ms = OK ty ->\npos0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= bitsizeof_struct env pos0 ms) (pos : Z) (e : id = name_member m) (H : layout_field env pos m = OK (ofs, bf)) (H0 : OK (type_member m) = OK ty) : pos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"inv H0.\nexploit layout_field_range; eauto.\ngeneralize (bitsizeof_struct_incr env ms (next_field env pos m)).\nlia."},{"statement":"(env : composite_env) (ofs : Z) (bf : bitfield) (m : member) (ms : list member) (IHms : forall pos0 : Z,\nfield_offset_rec env (name_member m) ms pos0 = OK (ofs, bf) ->\nfield_type (name_member m) ms = OK (type_member m) ->\npos0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nbitsizeof_struct env pos0 ms) (pos : Z) (H : layout_field env pos m = OK (ofs, bf)) : pos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"exploit layout_field_range; eauto.\ngeneralize (bitsizeof_struct_incr env ms (next_field env pos m)).\nlia."},{"statement":"(env : composite_env) (ofs : Z) (bf : bitfield) (m : member) (ms : list member) (IHms : forall pos0 : Z,\nfield_offset_rec env (name_member m) ms pos0 = OK (ofs, bf) ->\nfield_type (name_member m) ms = OK (type_member m) ->\npos0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nbitsizeof_struct env pos0 ms) (pos : Z) (H : layout_field env pos m = OK (ofs, bf)) : pos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nnext_field env pos m ->\npos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"generalize (bitsizeof_struct_incr env ms (next_field env pos m)).\nlia."},{"statement":"(env : composite_env) (ofs : Z) (bf : bitfield) (m : member) (ms : list member) (IHms : forall pos0 : Z,\nfield_offset_rec env (name_member m) ms pos0 = OK (ofs, bf) ->\nfield_type (name_member m) ms = OK (type_member m) ->\npos0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nbitsizeof_struct env pos0 ms) (pos : Z) (H : layout_field env pos m = OK (ofs, bf)) : next_field env pos m <= bitsizeof_struct env (next_field env pos m) ms ->\npos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nnext_field env pos m ->\npos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"lia."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (ms : list member) (IHms : forall pos0 : Z,\nfield_offset_rec env id ms pos0 = OK (ofs, bf) ->\nfield_type id ms = OK ty ->\npos0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= bitsizeof_struct env pos0 ms) (pos : Z) (n : id <> name_member m) (H : field_offset_rec env id ms (next_field env pos m) = OK (ofs, bf)) (H0 : field_type id ms = OK ty) : pos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"exploit IHms; eauto.\ngeneralize (next_field_incr env pos m).\nlia."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (ms : list member) (IHms : forall pos0 : Z,\nfield_offset_rec env id ms pos0 = OK (ofs, bf) ->\nfield_type id ms = OK ty ->\npos0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= bitsizeof_struct env pos0 ms) (pos : Z) (n : id <> name_member m) (H : field_offset_rec env id ms (next_field env pos m) = OK (ofs, bf)) (H0 : field_type id ms = OK ty) : next_field env pos m <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nbitsizeof_struct env (next_field env pos m) ms ->\npos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"generalize (next_field_incr env pos m).\nlia."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (ms : list member) (IHms : forall pos0 : Z,\nfield_offset_rec env id ms pos0 = OK (ofs, bf) ->\nfield_type id ms = OK ty ->\npos0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= bitsizeof_struct env pos0 ms) (pos : Z) (n : id <> name_member m) (H : field_offset_rec env id ms (next_field env pos m) = OK (ofs, bf)) (H0 : field_type id ms = OK ty) : pos <= next_field env pos m ->\nnext_field env pos m <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nbitsizeof_struct env (next_field env pos m) ms ->\npos <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"lia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (H : field_offset env id ms = OK (ofs, bf)) (H0 : field_type id ms = OK ty) : 0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= bitsizeof_struct env 0 ms.","proofString":"eapply field_offset_rec_in_range; eauto."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) : 0 <= ofs /\\ ofs + sizeof env ty <= sizeof_struct env ms.","proofString":"exploit field_offset_in_range_gen; eauto.\nunfold layout_start, layout_width, bitsizeof, sizeof_struct.\nintros [A B].\nassert (C: forall x y, x * 8 <= y -> x <= bytes_of_bits y).\nunfold bytes_of_bits; intros.\nassert (P: 8 > 0) by lia.\ngeneralize (Z_div_mod_eq (y + 7) 8 P) (Z_mod_lt (y + 7) 8 P).\nlia.\nsplit.\nlia.\napply C.\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) : 0 <= layout_start ofs Full /\\\nlayout_start ofs Full + layout_width env ty Full <= bitsizeof_struct env 0 ms ->\n0 <= ofs /\\ ofs + sizeof env ty <= sizeof_struct env ms.","proofString":"unfold layout_start, layout_width, bitsizeof, sizeof_struct.\nintros [A B].\nassert (C: forall x y, x * 8 <= y -> x <= bytes_of_bits y).\nunfold bytes_of_bits; intros.\nassert (P: 8 > 0) by lia.\ngeneralize (Z_div_mod_eq (y + 7) 8 P) (Z_mod_lt (y + 7) 8 P).\nlia.\nsplit.\nlia.\napply C.\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) : 0 <= ofs * 8 + 0 /\\\nofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms ->\n0 <= ofs /\\ ofs + sizeof env ty <= bytes_of_bits (bitsizeof_struct env 0 ms).","proofString":"intros [A B].\nassert (C: forall x y, x * 8 <= y -> x <= bytes_of_bits y).\nunfold bytes_of_bits; intros.\nassert (P: 8 > 0) by lia.\ngeneralize (Z_div_mod_eq (y + 7) 8 P) (Z_mod_lt (y + 7) 8 P).\nlia.\nsplit.\nlia.\napply C.\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) (A : 0 <= ofs * 8 + 0) (B : ofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms) : 0 <= ofs /\\ ofs + sizeof env ty <= bytes_of_bits (bitsizeof_struct env 0 ms).","proofString":"assert (C: forall x y, x * 8 <= y -> x <= bytes_of_bits y).\nunfold bytes_of_bits; intros.\nassert (P: 8 > 0) by lia.\ngeneralize (Z_div_mod_eq (y + 7) 8 P) (Z_mod_lt (y + 7) 8 P).\nlia.\nsplit.\nlia.\napply C.\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) (A : 0 <= ofs * 8 + 0) (B : ofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms) : forall x y : Z, x * 8 <= y -> x <= bytes_of_bits y.","proofString":"unfold bytes_of_bits; intros.\nassert (P: 8 > 0) by lia.\ngeneralize (Z_div_mod_eq (y + 7) 8 P) (Z_mod_lt (y + 7) 8 P).\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) (A : 0 <= ofs * 8 + 0) (B : ofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms) (x y : Z) (H1 : x * 8 <= y) : x <= (y + 7) / 8.","proofString":"assert (P: 8 > 0) by lia.\ngeneralize (Z_div_mod_eq (y + 7) 8 P) (Z_mod_lt (y + 7) 8 P).\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) (A : 0 <= ofs * 8 + 0) (B : ofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms) (x y : Z) (H1 : x * 8 <= y) (P : 8 > 0) : x <= (y + 7) / 8.","proofString":"generalize (Z_div_mod_eq (y + 7) 8 P) (Z_mod_lt (y + 7) 8 P).\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) (A : 0 <= ofs * 8 + 0) (B : ofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms) (x y : Z) (H1 : x * 8 <= y) (P : 8 > 0) : y + 7 = 8 * ((y + 7) / 8) + (y + 7) mod 8 ->\n0 <= (y + 7) mod 8 < 8 -> x <= (y + 7) / 8.","proofString":"lia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) (A : 0 <= ofs * 8 + 0) (B : ofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms) (C : forall x y : Z, x * 8 <= y -> x <= bytes_of_bits y) : 0 <= ofs /\\ ofs + sizeof env ty <= bytes_of_bits (bitsizeof_struct env 0 ms).","proofString":"split.\nlia.\napply C.\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) (A : 0 <= ofs * 8 + 0) (B : ofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms) (C : forall x y : Z, x * 8 <= y -> x <= bytes_of_bits y) : 0 <= ofs.","proofString":"lia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) (A : 0 <= ofs * 8 + 0) (B : ofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms) (C : forall x y : Z, x * 8 <= y -> x <= bytes_of_bits y) : ofs + sizeof env ty <= bytes_of_bits (bitsizeof_struct env 0 ms).","proofString":"apply C.\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) (A : 0 <= ofs * 8 + 0) (B : ofs * 8 + 0 + sizeof env ty * 8 <= bitsizeof_struct env 0 ms) (C : forall x y : Z, x * 8 <= y -> x <= bytes_of_bits y) : (ofs + sizeof env ty) * 8 <= bitsizeof_struct env 0 ms.","proofString":"lia."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (fld : members) : field_offset env id1 fld = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset env id2 fld = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nid1 <> id2 ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"unfold field_offset.\ngeneralize 0 as pos.\ninduction fld as [|m fld]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id1 (name_member m)); destruct (ident_eq id2 (name_member m)).\ncongruence.\ninv H0.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia.\ninv H2.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia.\neapply IHfld; eauto."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (fld : members) : field_offset_rec env id1 fld 0 = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env id2 fld 0 = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nid1 <> id2 ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"generalize 0 as pos.\ninduction fld as [|m fld]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id1 (name_member m)); destruct (ident_eq id2 (name_member m)).\ncongruence.\ninv H0.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia.\ninv H2.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia.\neapply IHfld; eauto."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (fld : members) : forall pos : Z,\nfield_offset_rec env id1 fld pos = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env id2 fld pos = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nid1 <> id2 ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"induction fld as [|m fld]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id1 (name_member m)); destruct (ident_eq id2 (name_member m)).\ncongruence.\ninv H0.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia.\ninv H2.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia.\neapply IHfld; eauto."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (pos : Z) (H : Error (MSG \"Unknown field \" :: CTX id1 :: nil) = OK (ofs1, bf1)) (H0 : Error (MSG \"Unknown field \" :: CTX id1 :: nil) = OK ty1) (H1 : Error (MSG \"Unknown field \" :: CTX id2 :: nil) = OK (ofs2, bf2)) (H2 : Error (MSG \"Unknown field \" :: CTX id2 :: nil) = OK ty2) (H3 : id1 <> id2) : layout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"discriminate."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id1 fld pos0 = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env id2 fld pos0 = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nid1 <> id2 ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1) (pos : Z) (H : (if ident_eq id1 (name_member m)\n then layout_field env pos m\n else field_offset_rec env id1 fld (next_field env pos m)) = \nOK (ofs1, bf1)) (H0 : (if ident_eq id1 (name_member m)\n then OK (type_member m)\n else field_type id1 fld) = OK ty1) (H1 : (if ident_eq id2 (name_member m)\n then layout_field env pos m\n else field_offset_rec env id2 fld (next_field env pos m)) = \nOK (ofs2, bf2)) (H2 : (if ident_eq id2 (name_member m)\n then OK (type_member m)\n else field_type id2 fld) = OK ty2) (H3 : id1 <> id2) : layout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"destruct (ident_eq id1 (name_member m)); destruct (ident_eq id2 (name_member m)).\ncongruence.\ninv H0.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia.\ninv H2.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia.\neapply IHfld; eauto."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id1 fld pos0 = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env id2 fld pos0 = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nid1 <> id2 ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1) (pos : Z) (e : id1 = name_member m) (H : layout_field env pos m = OK (ofs1, bf1)) (H0 : OK (type_member m) = OK ty1) (e0 : id2 = name_member m) (H1 : layout_field env pos m = OK (ofs2, bf2)) (H2 : OK (type_member m) = OK ty2) (H3 : id1 <> id2) : layout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"congruence."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id1 fld pos0 = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env id2 fld pos0 = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nid1 <> id2 ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1) (pos : Z) (e : id1 = name_member m) (H : layout_field env pos m = OK (ofs1, bf1)) (H0 : OK (type_member m) = OK ty1) (n : id2 <> name_member m) (H1 : field_offset_rec env id2 fld (next_field env pos m) = OK (ofs2, bf2)) (H2 : field_type id2 fld = OK ty2) (H3 : id1 <> id2) : layout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"inv H0.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia."},{"statement":"(env : composite_env) (ofs1 : Z) (bf1 : bitfield) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env (name_member m) fld pos0 = OK (ofs1, bf1) ->\nfield_type (name_member m) fld = OK (type_member m) ->\nfield_offset_rec env id2 fld pos0 = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nname_member m <> id2 ->\nlayout_start ofs1 bf1 + layout_width env (type_member m) bf1 <=\nlayout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1) (pos : Z) (H : layout_field env pos m = OK (ofs1, bf1)) (n : id2 <> name_member m) (H1 : field_offset_rec env id2 fld (next_field env pos m) = OK (ofs2, bf2)) (H2 : field_type id2 fld = OK ty2) (H3 : name_member m <> id2) : layout_start ofs1 bf1 + layout_width env (type_member m) bf1 <=\nlayout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"exploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia."},{"statement":"(env : composite_env) (ofs1 : Z) (bf1 : bitfield) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env (name_member m) fld pos0 = OK (ofs1, bf1) ->\nfield_type (name_member m) fld = OK (type_member m) ->\nfield_offset_rec env id2 fld pos0 = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nname_member m <> id2 ->\nlayout_start ofs1 bf1 + layout_width env (type_member m) bf1 <=\nlayout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1) (pos : Z) (H : layout_field env pos m = OK (ofs1, bf1)) (n : id2 <> name_member m) (H1 : field_offset_rec env id2 fld (next_field env pos m) = OK (ofs2, bf2)) (H2 : field_type id2 fld = OK ty2) (H3 : name_member m <> id2) : next_field env pos m <= layout_start ofs2 bf2 /\\\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <=\nbitsizeof_struct env (next_field env pos m) fld ->\nlayout_start ofs1 bf1 + layout_width env (type_member m) bf1 <=\nlayout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"exploit layout_field_range; eauto.\nlia."},{"statement":"(env : composite_env) (ofs1 : Z) (bf1 : bitfield) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env (name_member m) fld pos0 = OK (ofs1, bf1) ->\nfield_type (name_member m) fld = OK (type_member m) ->\nfield_offset_rec env id2 fld pos0 = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nname_member m <> id2 ->\nlayout_start ofs1 bf1 + layout_width env (type_member m) bf1 <=\nlayout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1) (pos : Z) (H : layout_field env pos m = OK (ofs1, bf1)) (n : id2 <> name_member m) (H1 : field_offset_rec env id2 fld (next_field env pos m) = OK (ofs2, bf2)) (H2 : field_type id2 fld = OK ty2) (H3 : name_member m <> id2) : pos <= layout_start ofs1 bf1 /\\\nlayout_start ofs1 bf1 + layout_width env (type_member m) bf1 <=\nnext_field env pos m ->\nnext_field env pos m <= layout_start ofs2 bf2 /\\\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <=\nbitsizeof_struct env (next_field env pos m) fld ->\nlayout_start ofs1 bf1 + layout_width env (type_member m) bf1 <=\nlayout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"lia."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id1 fld pos0 = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env id2 fld pos0 = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nid1 <> id2 ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1) (pos : Z) (n : id1 <> name_member m) (H : field_offset_rec env id1 fld (next_field env pos m) = OK (ofs1, bf1)) (H0 : field_type id1 fld = OK ty1) (e : id2 = name_member m) (H1 : layout_field env pos m = OK (ofs2, bf2)) (H2 : OK (type_member m) = OK ty2) (H3 : id1 <> id2) : layout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"inv H2.\nexploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (ofs2 : Z) (bf2 : bitfield) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id1 fld pos0 = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env (name_member m) fld pos0 = OK (ofs2, bf2) ->\nfield_type (name_member m) fld = OK (type_member m) ->\nid1 <> name_member m ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env (type_member m) bf2 <=\nlayout_start ofs1 bf1) (pos : Z) (n : id1 <> name_member m) (H : field_offset_rec env id1 fld (next_field env pos m) = OK (ofs1, bf1)) (H0 : field_type id1 fld = OK ty1) (H1 : layout_field env pos m = OK (ofs2, bf2)) (H3 : id1 <> name_member m) : layout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env (type_member m) bf2 <=\nlayout_start ofs1 bf1.","proofString":"exploit field_offset_rec_in_range; eauto.\nexploit layout_field_range; eauto.\nlia."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (ofs2 : Z) (bf2 : bitfield) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id1 fld pos0 = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env (name_member m) fld pos0 = OK (ofs2, bf2) ->\nfield_type (name_member m) fld = OK (type_member m) ->\nid1 <> name_member m ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env (type_member m) bf2 <=\nlayout_start ofs1 bf1) (pos : Z) (n : id1 <> name_member m) (H : field_offset_rec env id1 fld (next_field env pos m) = OK (ofs1, bf1)) (H0 : field_type id1 fld = OK ty1) (H1 : layout_field env pos m = OK (ofs2, bf2)) (H3 : id1 <> name_member m) : next_field env pos m <= layout_start ofs1 bf1 /\\\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <=\nbitsizeof_struct env (next_field env pos m) fld ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env (type_member m) bf2 <=\nlayout_start ofs1 bf1.","proofString":"exploit layout_field_range; eauto.\nlia."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (ofs2 : Z) (bf2 : bitfield) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id1 fld pos0 = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env (name_member m) fld pos0 = OK (ofs2, bf2) ->\nfield_type (name_member m) fld = OK (type_member m) ->\nid1 <> name_member m ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env (type_member m) bf2 <=\nlayout_start ofs1 bf1) (pos : Z) (n : id1 <> name_member m) (H : field_offset_rec env id1 fld (next_field env pos m) = OK (ofs1, bf1)) (H0 : field_type id1 fld = OK ty1) (H1 : layout_field env pos m = OK (ofs2, bf2)) (H3 : id1 <> name_member m) : pos <= layout_start ofs2 bf2 /\\\nlayout_start ofs2 bf2 + layout_width env (type_member m) bf2 <=\nnext_field env pos m ->\nnext_field env pos m <= layout_start ofs1 bf1 /\\\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <=\nbitsizeof_struct env (next_field env pos m) fld ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env (type_member m) bf2 <=\nlayout_start ofs1 bf1.","proofString":"lia."},{"statement":"(env : composite_env) (id1 : ident) (ofs1 : Z) (bf1 : bitfield) (ty1 : type) (id2 : ident) (ofs2 : Z) (bf2 : bitfield) (ty2 : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id1 fld pos0 = OK (ofs1, bf1) ->\nfield_type id1 fld = OK ty1 ->\nfield_offset_rec env id2 fld pos0 = OK (ofs2, bf2) ->\nfield_type id2 fld = OK ty2 ->\nid1 <> id2 ->\nlayout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1) (pos : Z) (n : id1 <> name_member m) (H : field_offset_rec env id1 fld (next_field env pos m) = OK (ofs1, bf1)) (H0 : field_type id1 fld = OK ty1) (n0 : id2 <> name_member m) (H1 : field_offset_rec env id2 fld (next_field env pos m) = OK (ofs2, bf2)) (H2 : field_type id2 fld = OK ty2) (H3 : id1 <> id2) : layout_start ofs1 bf1 + layout_width env ty1 bf1 <= layout_start ofs2 bf2 \\/\nlayout_start ofs2 bf2 + layout_width env ty2 bf2 <= layout_start ofs1 bf1.","proofString":"eapply IHfld; eauto."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (fld2 : list member) (fld1 : members) : field_offset env id fld1 = OK (ofs, bf) ->\nfield_offset env id (fld1 ++ fld2) = OK (ofs, bf).","proofString":"unfold field_offset.\ngeneralize 0 as pos.\ninduction fld1 as [|m fld1]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id (name_member m)); auto."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (fld2 : list member) (fld1 : members) : field_offset_rec env id fld1 0 = OK (ofs, bf) ->\nfield_offset_rec env id (fld1 ++ fld2) 0 = OK (ofs, bf).","proofString":"generalize 0 as pos.\ninduction fld1 as [|m fld1]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id (name_member m)); auto."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (fld2 : list member) (fld1 : members) : forall pos : Z,\nfield_offset_rec env id fld1 pos = OK (ofs, bf) ->\nfield_offset_rec env id (fld1 ++ fld2) pos = OK (ofs, bf).","proofString":"induction fld1 as [|m fld1]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id (name_member m)); auto."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (fld2 : list member) (pos : Z) (H : Error (MSG \"Unknown field \" :: CTX id :: nil) = OK (ofs, bf)) : field_offset_rec env id fld2 pos = OK (ofs, bf).","proofString":"discriminate."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (fld2 : list member) (m : member) (fld1 : list member) (IHfld1 : forall pos0 : Z,\nfield_offset_rec env id fld1 pos0 = OK (ofs, bf) ->\nfield_offset_rec env id (fld1 ++ fld2) pos0 = OK (ofs, bf)) (pos : Z) (H : (if ident_eq id (name_member m)\n then layout_field env pos m\n else field_offset_rec env id fld1 (next_field env pos m)) = \nOK (ofs, bf)) : (if ident_eq id (name_member m)\n then layout_field env pos m\n else field_offset_rec env id (fld1 ++ fld2) (next_field env pos m)) =\nOK (ofs, bf).","proofString":"destruct (ident_eq id (name_member m)); auto."},{"statement":"(env : composite_env) (id : ident) (fld : members) (ofs : Z) (bf : bitfield) (ty : type) : field_offset env id fld = OK (ofs, bf) ->\nfield_type id fld = OK ty -> (layout_alignment env ty bf | ofs).","proofString":"unfold field_offset.\ngeneralize 0 as pos.\nrevert fld.\ninduction fld as [|m fld]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id (name_member m)).\ninv H0.\neapply layout_field_alignment; eauto.\neauto."},{"statement":"(env : composite_env) (id : ident) (fld : members) (ofs : Z) (bf : bitfield) (ty : type) : field_offset_rec env id fld 0 = OK (ofs, bf) ->\nfield_type id fld = OK ty -> (layout_alignment env ty bf | ofs).","proofString":"generalize 0 as pos.\nrevert fld.\ninduction fld as [|m fld]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id (name_member m)).\ninv H0.\neapply layout_field_alignment; eauto.\neauto."},{"statement":"(env : composite_env) (id : ident) (fld : members) (ofs : Z) (bf : bitfield) (ty : type) : forall pos : Z,\nfield_offset_rec env id fld pos = OK (ofs, bf) ->\nfield_type id fld = OK ty -> (layout_alignment env ty bf | ofs).","proofString":"revert fld.\ninduction fld as [|m fld]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id (name_member m)).\ninv H0.\neapply layout_field_alignment; eauto.\neauto."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) : forall (fld : members) (pos : Z),\nfield_offset_rec env id fld pos = OK (ofs, bf) ->\nfield_type id fld = OK ty -> (layout_alignment env ty bf | ofs).","proofString":"induction fld as [|m fld]; simpl; intros.\ndiscriminate.\ndestruct (ident_eq id (name_member m)).\ninv H0.\neapply layout_field_alignment; eauto.\neauto."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (pos : Z) (H : Error (MSG \"Unknown field \" :: CTX id :: nil) = OK (ofs, bf)) (H0 : Error (MSG \"Unknown field \" :: CTX id :: nil) = OK ty) : (layout_alignment env ty bf | ofs).","proofString":"discriminate."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id fld pos0 = OK (ofs, bf) ->\nfield_type id fld = OK ty -> (layout_alignment env ty bf | ofs)) (pos : Z) (H : (if ident_eq id (name_member m)\n then layout_field env pos m\n else field_offset_rec env id fld (next_field env pos m)) = \nOK (ofs, bf)) (H0 : (if ident_eq id (name_member m)\n then OK (type_member m)\n else field_type id fld) = OK ty) : (layout_alignment env ty bf | ofs).","proofString":"destruct (ident_eq id (name_member m)).\ninv H0.\neapply layout_field_alignment; eauto.\neauto."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id fld pos0 = OK (ofs, bf) ->\nfield_type id fld = OK ty -> (layout_alignment env ty bf | ofs)) (pos : Z) (e : id = name_member m) (H : layout_field env pos m = OK (ofs, bf)) (H0 : OK (type_member m) = OK ty) : (layout_alignment env ty bf | ofs).","proofString":"inv H0.\neapply layout_field_alignment; eauto."},{"statement":"(env : composite_env) (ofs : Z) (bf : bitfield) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env (name_member m) fld pos0 = OK (ofs, bf) ->\nfield_type (name_member m) fld = OK (type_member m) ->\n(layout_alignment env (type_member m) bf | ofs)) (pos : Z) (H : layout_field env pos m = OK (ofs, bf)) : (layout_alignment env (type_member m) bf | ofs).","proofString":"eapply layout_field_alignment; eauto."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (fld : list member) (IHfld : forall pos0 : Z,\nfield_offset_rec env id fld pos0 = OK (ofs, bf) ->\nfield_type id fld = OK ty -> (layout_alignment env ty bf | ofs)) (pos : Z) (n : id <> name_member m) (H : field_offset_rec env id fld (next_field env pos m) = OK (ofs, bf)) (H0 : field_type id fld = OK ty) : (layout_alignment env ty bf | ofs).","proofString":"eauto."},{"statement":"(env : composite_env) (id : ident) (fld : members) (ofs : Z) (ty : type) (H : field_offset env id fld = OK (ofs, Full)) (H0 : field_type id fld = OK ty) : (alignof env ty | ofs).","proofString":"exploit field_offset_aligned_gen; eauto."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (H : Error (MSG \"Unknown field \" :: CTX id :: nil) = OK (ofs, bf)) (H0 : Error (MSG \"Unknown field \" :: CTX id :: nil) = OK ty) : ofs = 0 /\\\n0 <= layout_start ofs bf /\\ layout_start ofs bf + layout_width env ty bf <= 0.","proofString":"discriminate."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (ms : list member) (IHms : union_field_offset env id ms = OK (ofs, bf) ->\nfield_type id ms = OK ty ->\nofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= sizeof_union env ms * 8) (H : (if ident_eq id (name_member m)\n then layout_field env 0 m\n else union_field_offset env id ms) = OK (ofs, bf)) (H0 : (if ident_eq id (name_member m) then OK (type_member m) else field_type id ms) =\nOK ty) : ofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nZ.max (sizeof env (type_member m)) (sizeof_union env ms) * 8.","proofString":"destruct (ident_eq id (name_member m)).\ninv H0.\nset (ty := type_member m) in *.\ndestruct m; simpl in H.\ninv H.\nunfold layout_start, layout_width.\nrewrite align_same.\nchange (0 / 8) with 0.\nunfold bitsizeof.\nlia.\nunfold bitalignof.\ngeneralize (alignof_pos env t).\nlia.\napply Z.divide_0_r.\ndestruct (zle width 0); try discriminate.\ndestruct (zlt (bitsize_intsize sz) width); try discriminate.\nassert (A: bitsize_intsize sz <= bitalignof_intsize sz <= sizeof env ty * 8).\nunfold ty, type_member; destruct sz; simpl; lia.\nrewrite zle_true in H by lia.\ninv H.\nunfold layout_start, layout_width.\nunfold floor; rewrite Z.div_0_l by lia.\nlia.\nexploit IHms; eauto.\nlia."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (ms : list member) (IHms : union_field_offset env id ms = OK (ofs, bf) ->\nfield_type id ms = OK ty ->\nofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= sizeof_union env ms * 8) (e : id = name_member m) (H : layout_field env 0 m = OK (ofs, bf)) (H0 : OK (type_member m) = OK ty) : ofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nZ.max (sizeof env (type_member m)) (sizeof_union env ms) * 8.","proofString":"inv H0.\nset (ty := type_member m) in *.\ndestruct m; simpl in H.\ninv H.\nunfold layout_start, layout_width.\nrewrite align_same.\nchange (0 / 8) with 0.\nunfold bitsizeof.\nlia.\nunfold bitalignof.\ngeneralize (alignof_pos env t).\nlia.\napply Z.divide_0_r.\ndestruct (zle width 0); try discriminate.\ndestruct (zlt (bitsize_intsize sz) width); try discriminate.\nassert (A: bitsize_intsize sz <= bitalignof_intsize sz <= sizeof env ty * 8).\nunfold ty, type_member; destruct sz; simpl; lia.\nrewrite zle_true in H by lia.\ninv H.\nunfold layout_start, layout_width.\nunfold floor; rewrite Z.div_0_l by lia.\nlia."},{"statement":"(env : composite_env) (ofs : Z) (bf : bitfield) (m : member) (ms : list member) (IHms : union_field_offset env (name_member m) ms = OK (ofs, bf) ->\nfield_type (name_member m) ms = OK (type_member m) ->\nofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nsizeof_union env ms * 8) (H : layout_field env 0 m = OK (ofs, bf)) : ofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env (type_member m) bf <=\nZ.max (sizeof env (type_member m)) (sizeof_union env ms) * 8.","proofString":"set (ty := type_member m) in *.\ndestruct m; simpl in H.\ninv H.\nunfold layout_start, layout_width.\nrewrite align_same.\nchange (0 / 8) with 0.\nunfold bitsizeof.\nlia.\nunfold bitalignof.\ngeneralize (alignof_pos env t).\nlia.\napply Z.divide_0_r.\ndestruct (zle width 0); try discriminate.\ndestruct (zlt (bitsize_intsize sz) width); try discriminate.\nassert (A: bitsize_intsize sz <= bitalignof_intsize sz <= sizeof env ty * 8).\nunfold ty, type_member; destruct sz; simpl; lia.\nrewrite zle_true in H by lia.\ninv H.\nunfold layout_start, layout_width.\nunfold floor; rewrite Z.div_0_l by lia.\nlia."},{"statement":"(env : composite_env) (ofs : Z) (bf : bitfield) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms = OK (ofs, bf) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= sizeof_union env ms * 8) (H : OK (align 0 (bitalignof env t) / 8, Full) = OK (ofs, bf)) : ofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"inv H.\nunfold layout_start, layout_width.\nrewrite align_same.\nchange (0 / 8) with 0.\nunfold bitsizeof.\nlia.\nunfold bitalignof.\ngeneralize (alignof_pos env t).\nlia.\napply Z.divide_0_r."},{"statement":"(env : composite_env) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms =\nOK (align 0 (bitalignof env t) / 8, Full) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nalign 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nsizeof_union env ms * 8) : align 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"unfold layout_start, layout_width.\nrewrite align_same.\nchange (0 / 8) with 0.\nunfold bitsizeof.\nlia.\nunfold bitalignof.\ngeneralize (alignof_pos env t).\nlia.\napply Z.divide_0_r."},{"statement":"(env : composite_env) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms =\nOK (align 0 (bitalignof env t) / 8, Full) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nalign 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nsizeof_union env ms * 8) : align 0 (bitalignof env t) / 8 = 0 /\\\n0 <= align 0 (bitalignof env t) / 8 * 8 + 0 /\\\nalign 0 (bitalignof env t) / 8 * 8 + 0 + bitsizeof env ty <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"rewrite align_same.\nchange (0 / 8) with 0.\nunfold bitsizeof.\nlia.\nunfold bitalignof.\ngeneralize (alignof_pos env t).\nlia.\napply Z.divide_0_r."},{"statement":"(env : composite_env) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms =\nOK (align 0 (bitalignof env t) / 8, Full) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nalign 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nsizeof_union env ms * 8) : 0 / 8 = 0 /\\\n0 <= 0 / 8 * 8 + 0 /\\\n0 / 8 * 8 + 0 + bitsizeof env ty <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"change (0 / 8) with 0.\nunfold bitsizeof.\nlia."},{"statement":"(env : composite_env) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms =\nOK (align 0 (bitalignof env t) / 8, Full) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nalign 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nsizeof_union env ms * 8) : 0 = 0 /\\\n0 <= 0 * 8 + 0 /\\\n0 * 8 + 0 + bitsizeof env ty <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"unfold bitsizeof.\nlia."},{"statement":"(env : composite_env) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms =\nOK (align 0 (bitalignof env t) / 8, Full) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nalign 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nsizeof_union env ms * 8) : 0 = 0 /\\\n0 <= 0 * 8 + 0 /\\\n0 * 8 + 0 + sizeof env ty * 8 <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"lia."},{"statement":"(env : composite_env) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms =\nOK (align 0 (bitalignof env t) / 8, Full) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nalign 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nsizeof_union env ms * 8) : bitalignof env t > 0.","proofString":"unfold bitalignof.\ngeneralize (alignof_pos env t).\nlia."},{"statement":"(env : composite_env) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms =\nOK (align 0 (bitalignof env t) / 8, Full) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nalign 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nsizeof_union env ms * 8) : alignof env t * 8 > 0.","proofString":"generalize (alignof_pos env t).\nlia."},{"statement":"(env : composite_env) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms =\nOK (align 0 (bitalignof env t) / 8, Full) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nalign 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nsizeof_union env ms * 8) : alignof env t > 0 -> alignof env t * 8 > 0.","proofString":"lia."},{"statement":"(env : composite_env) (id : ident) (t : type) (ms : list member) (ty : type) (IHms : union_field_offset env (name_member (Member_plain id t)) ms =\nOK (align 0 (bitalignof env t) / 8, Full) ->\nfield_type (name_member (Member_plain id t)) ms = OK ty ->\nalign 0 (bitalignof env t) / 8 = 0 /\\\n0 <= layout_start (align 0 (bitalignof env t) / 8) Full /\\\nlayout_start (align 0 (bitalignof env t) / 8) Full + layout_width env ty Full <=\nsizeof_union env ms * 8) : (bitalignof env t | 0).","proofString":"apply Z.divide_0_r."},{"statement":"(env : composite_env) (ofs : Z) (bf : bitfield) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ms : list member) (ty : type) (IHms : union_field_offset env\n  (name_member (Member_bitfield id sz sg a width padding)) ms = \nOK (ofs, bf) ->\nfield_type (name_member (Member_bitfield id sz sg a width padding)) ms =\nOK ty ->\nofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= sizeof_union env ms * 8) (g : width > 0) (g0 : bitsize_intsize sz >= width) (H : (if zle width (bitalignof_intsize sz)\n then OK (floor 0 (bitalignof_intsize sz) / 8, Bits sz sg 0 width)\n else OK (bitalignof_intsize sz / 8, Bits sz sg 0 width)) = \nOK (ofs, bf)) (A : bitsize_intsize sz <= bitalignof_intsize sz <= sizeof env ty * 8) : ofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"rewrite zle_true in H by lia.\ninv H.\nunfold layout_start, layout_width.\nunfold floor; rewrite Z.div_0_l by lia.\nlia."},{"statement":"(env : composite_env) (ofs : Z) (bf : bitfield) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ms : list member) (ty : type) (IHms : union_field_offset env\n  (name_member (Member_bitfield id sz sg a width padding)) ms = \nOK (ofs, bf) ->\nfield_type (name_member (Member_bitfield id sz sg a width padding)) ms =\nOK ty ->\nofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= sizeof_union env ms * 8) (g : width > 0) (g0 : bitsize_intsize sz >= width) (H : OK (floor 0 (bitalignof_intsize sz) / 8, Bits sz sg 0 width) = OK (ofs, bf)) (A : bitsize_intsize sz <= bitalignof_intsize sz <= sizeof env ty * 8) : ofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"inv H.\nunfold layout_start, layout_width.\nunfold floor; rewrite Z.div_0_l by lia.\nlia."},{"statement":"(env : composite_env) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ms : list member) (ty : type) (IHms : union_field_offset env\n  (name_member (Member_bitfield id sz sg a width padding)) ms =\nOK (floor 0 (bitalignof_intsize sz) / 8, Bits sz sg 0 width) ->\nfield_type (name_member (Member_bitfield id sz sg a width padding)) ms =\nOK ty ->\nfloor 0 (bitalignof_intsize sz) / 8 = 0 /\\\n0 <= layout_start (floor 0 (bitalignof_intsize sz) / 8) (Bits sz sg 0 width) /\\\nlayout_start (floor 0 (bitalignof_intsize sz) / 8) (Bits sz sg 0 width) +\nlayout_width env ty (Bits sz sg 0 width) <= sizeof_union env ms * 8) (g : width > 0) (g0 : bitsize_intsize sz >= width) (A : bitsize_intsize sz <= bitalignof_intsize sz <= sizeof env ty * 8) : floor 0 (bitalignof_intsize sz) / 8 = 0 /\\\n0 <= layout_start (floor 0 (bitalignof_intsize sz) / 8) (Bits sz sg 0 width) /\\\nlayout_start (floor 0 (bitalignof_intsize sz) / 8) (Bits sz sg 0 width) +\nlayout_width env ty (Bits sz sg 0 width) <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"unfold layout_start, layout_width.\nunfold floor; rewrite Z.div_0_l by lia.\nlia."},{"statement":"(env : composite_env) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ms : list member) (ty : type) (IHms : union_field_offset env\n  (name_member (Member_bitfield id sz sg a width padding)) ms =\nOK (floor 0 (bitalignof_intsize sz) / 8, Bits sz sg 0 width) ->\nfield_type (name_member (Member_bitfield id sz sg a width padding)) ms =\nOK ty ->\nfloor 0 (bitalignof_intsize sz) / 8 = 0 /\\\n0 <= layout_start (floor 0 (bitalignof_intsize sz) / 8) (Bits sz sg 0 width) /\\\nlayout_start (floor 0 (bitalignof_intsize sz) / 8) (Bits sz sg 0 width) +\nlayout_width env ty (Bits sz sg 0 width) <= sizeof_union env ms * 8) (g : width > 0) (g0 : bitsize_intsize sz >= width) (A : bitsize_intsize sz <= bitalignof_intsize sz <= sizeof env ty * 8) : floor 0 (bitalignof_intsize sz) / 8 = 0 /\\\n0 <= floor 0 (bitalignof_intsize sz) / 8 * 8 + 0 /\\\nfloor 0 (bitalignof_intsize sz) / 8 * 8 + 0 + width <=\nZ.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"unfold floor; rewrite Z.div_0_l by lia.\nlia."},{"statement":"(env : composite_env) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ms : list member) (ty : type) (IHms : union_field_offset env\n  (name_member (Member_bitfield id sz sg a width padding)) ms =\nOK (floor 0 (bitalignof_intsize sz) / 8, Bits sz sg 0 width) ->\nfield_type (name_member (Member_bitfield id sz sg a width padding)) ms =\nOK ty ->\nfloor 0 (bitalignof_intsize sz) / 8 = 0 /\\\n0 <= layout_start (floor 0 (bitalignof_intsize sz) / 8) (Bits sz sg 0 width) /\\\nlayout_start (floor 0 (bitalignof_intsize sz) / 8) (Bits sz sg 0 width) +\nlayout_width env ty (Bits sz sg 0 width) <= sizeof_union env ms * 8) (g : width > 0) (g0 : bitsize_intsize sz >= width) (A : bitsize_intsize sz <= bitalignof_intsize sz <= sizeof env ty * 8) : 0 = 0 /\\\n0 <= 0 * 8 + 0 /\\\n0 * 8 + 0 + width <= Z.max (sizeof env ty) (sizeof_union env ms) * 8.","proofString":"lia."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (ms : list member) (IHms : union_field_offset env id ms = OK (ofs, bf) ->\nfield_type id ms = OK ty ->\nofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= sizeof_union env ms * 8) (n : id <> name_member m) (H : union_field_offset env id ms = OK (ofs, bf)) (H0 : field_type id ms = OK ty) : ofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nZ.max (sizeof env (type_member m)) (sizeof_union env ms) * 8.","proofString":"exploit IHms; eauto.\nlia."},{"statement":"(env : composite_env) (id : ident) (ofs : Z) (bf : bitfield) (ty : type) (m : member) (ms : list member) (IHms : union_field_offset env id ms = OK (ofs, bf) ->\nfield_type id ms = OK ty ->\nofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= sizeof_union env ms * 8) (n : id <> name_member m) (H : union_field_offset env id ms = OK (ofs, bf)) (H0 : field_type id ms = OK ty) : ofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <= sizeof_union env ms * 8 ->\nofs = 0 /\\\n0 <= layout_start ofs bf /\\\nlayout_start ofs bf + layout_width env ty bf <=\nZ.max (sizeof env (type_member m)) (sizeof_union env ms) * 8.","proofString":"lia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : union_field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) : ofs = 0 /\\ sizeof env ty <= sizeof_union env ms.","proofString":"exploit union_field_offset_in_range_gen; eauto.\nunfold layout_start, layout_width, bitsizeof.\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : union_field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) : ofs = 0 /\\\n0 <= layout_start ofs Full /\\\nlayout_start ofs Full + layout_width env ty Full <= sizeof_union env ms * 8 ->\nofs = 0 /\\ sizeof env ty <= sizeof_union env ms.","proofString":"unfold layout_start, layout_width, bitsizeof.\nlia."},{"statement":"(env : composite_env) (ms : members) (id : ident) (ofs : Z) (ty : type) (H : union_field_offset env id ms = OK (ofs, Full)) (H0 : field_type id ms = OK ty) : ofs = 0 /\\\n0 <= ofs * 8 + 0 /\\\nofs * 8 + 0 + sizeof env ty * 8 <= sizeof_union env ms * 8 ->\nofs = 0 /\\ sizeof env ty <= sizeof_union env ms.","proofString":"lia."},{"statement":"forall co : composite,\nlet a := Z.min 8 (co_alignof co) in a = 1 \\/ a = 2 \\/ a = 4 \\/ a = 8.","proofString":"intros.\ndestruct (co_alignof_two_p co) as [n EQ].\nunfold a; rewrite EQ.\ndestruct n; auto.\ndestruct n; auto.\ndestruct n; auto.\nright; right; right.\napply Z.min_l.\nrewrite two_power_nat_two_p.\nrewrite ! Nat2Z.inj_succ.\nchange 8 with (two_p 3).\napply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat n) : Z.min 8 (two_power_nat n) = 1 \\/\nZ.min 8 (two_power_nat n) = 2 \\/\nZ.min 8 (two_power_nat n) = 4 \\/ Z.min 8 (two_power_nat n) = 8.","proofString":"destruct n; auto.\ndestruct n; auto.\ndestruct n; auto.\nright; right; right.\napply Z.min_l.\nrewrite two_power_nat_two_p.\nrewrite ! Nat2Z.inj_succ.\nchange 8 with (two_p 3).\napply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat (S n)) : Z.min 8 (two_power_nat (S n)) = 1 \\/\nZ.min 8 (two_power_nat (S n)) = 2 \\/\nZ.min 8 (two_power_nat (S n)) = 4 \\/ Z.min 8 (two_power_nat (S n)) = 8.","proofString":"destruct n; auto.\ndestruct n; auto.\nright; right; right.\napply Z.min_l.\nrewrite two_power_nat_two_p.\nrewrite ! Nat2Z.inj_succ.\nchange 8 with (two_p 3).\napply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat (S (S n))) : Z.min 8 (two_power_nat (S (S n))) = 1 \\/\nZ.min 8 (two_power_nat (S (S n))) = 2 \\/\nZ.min 8 (two_power_nat (S (S n))) = 4 \\/\nZ.min 8 (two_power_nat (S (S n))) = 8.","proofString":"destruct n; auto.\nright; right; right.\napply Z.min_l.\nrewrite two_power_nat_two_p.\nrewrite ! Nat2Z.inj_succ.\nchange 8 with (two_p 3).\napply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat (S (S (S n)))) : Z.min 8 (two_power_nat (S (S (S n)))) = 1 \\/\nZ.min 8 (two_power_nat (S (S (S n)))) = 2 \\/\nZ.min 8 (two_power_nat (S (S (S n)))) = 4 \\/\nZ.min 8 (two_power_nat (S (S (S n)))) = 8.","proofString":"right; right; right.\napply Z.min_l.\nrewrite two_power_nat_two_p.\nrewrite ! Nat2Z.inj_succ.\nchange 8 with (two_p 3).\napply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat (S (S (S n)))) : Z.min 8 (two_power_nat (S (S (S n)))) = 8.","proofString":"apply Z.min_l.\nrewrite two_power_nat_two_p.\nrewrite ! Nat2Z.inj_succ.\nchange 8 with (two_p 3).\napply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat (S (S (S n)))) : 8 <= two_power_nat (S (S (S n))).","proofString":"rewrite two_power_nat_two_p.\nrewrite ! Nat2Z.inj_succ.\nchange 8 with (two_p 3).\napply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat (S (S (S n)))) : 8 <= two_p (Z.of_nat (S (S (S n)))).","proofString":"rewrite ! Nat2Z.inj_succ.\nchange 8 with (two_p 3).\napply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat (S (S (S n)))) : 8 <= two_p (Z.succ (Z.succ (Z.succ (Z.of_nat n)))).","proofString":"change 8 with (two_p 3).\napply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat (S (S (S n)))) : two_p 3 <= two_p (Z.succ (Z.succ (Z.succ (Z.of_nat n)))).","proofString":"apply two_p_monotone.\nlia."},{"statement":"(co : composite) (a : Z) (n : nat) (EQ : co_alignof co = two_power_nat (S (S (S n)))) : 0 <= 3 <= Z.succ (Z.succ (Z.succ (Z.of_nat n))).","proofString":"lia."},{"statement":"(X : forall co : composite,\nlet a := Z.min 8 (co_alignof co) in a = 1 \\/ a = 2 \\/ a = 4 \\/ a = 8) : forall (env : composite_env) (ty : type),\nlet a := alignof_blockcopy env ty in a = 1 \\/ a = 2 \\/ a = 4 \\/ a = 8.","proofString":"induction ty; simpl.\nauto.\ndestruct i; auto.\nauto.\ndestruct f; auto.\ndestruct Archi.ptr64; auto.\napply IHty.\nauto.\ndestruct (env!i); auto.\ndestruct (env!i); auto."},{"statement":"(X : forall co : composite,\nlet a := Z.min 8 (co_alignof co) in a = 1 \\/ a = 2 \\/ a = 4 \\/ a = 8) (env : composite_env) : 1 = 1 \\/ 1 = 2 \\/ 1 = 4 \\/ 1 = 8.","proofString":"auto."},{"statement":"(X : forall co : composite,\nlet a0 := Z.min 8 (co_alignof co) in a0 = 1 \\/ a0 = 2 \\/ a0 = 4 \\/ a0 = 8) (env : composite_env) (i : intsize) (s : signedness) (a : attr) : match i with\n| I16 => 2\n| I32 => 4\n| _ => 1\nend = 1 \\/\nmatch i with\n| I16 => 2\n| I32 => 4\n| _ => 1\nend = 2 \\/\nmatch i with\n| I16 => 2\n| I32 => 4\n| _ => 1\nend = 4 \\/ match i with\n           | I16 => 2\n           | I32 => 4\n           | _ => 1\n           end = 8.","proofString":"destruct i; auto."},{"statement":"(X : forall co : composite,\nlet a0 := Z.min 8 (co_alignof co) in a0 = 1 \\/ a0 = 2 \\/ a0 = 4 \\/ a0 = 8) (env : composite_env) (s : signedness) (a : attr) : 8 = 1 \\/ 8 = 2 \\/ 8 = 4 \\/ 8 = 8.","proofString":"auto."},{"statement":"(X : forall co : composite,\nlet a0 := Z.min 8 (co_alignof co) in a0 = 1 \\/ a0 = 2 \\/ a0 = 4 \\/ a0 = 8) (env : composite_env) (f : floatsize) (a : attr) : match f with\n| F32 => 4\n| F64 => 8\nend = 1 \\/\nmatch f with\n| F32 => 4\n| F64 => 8\nend = 2 \\/\nmatch f with\n| F32 => 4\n| F64 => 8\nend = 4 \\/ match f with\n           | F32 => 4\n           | F64 => 8\n           end = 8.","proofString":"destruct f; auto."},{"statement":"(X : forall co : composite,\nlet a0 := Z.min 8 (co_alignof co) in a0 = 1 \\/ a0 = 2 \\/ a0 = 4 \\/ a0 = 8) (env : composite_env) (ty : type) (a : attr) (IHty : let a0 := alignof_blockcopy env ty in a0 = 1 \\/ a0 = 2 \\/ a0 = 4 \\/ a0 = 8) : (if Archi.ptr64 then 8 else 4) = 1 \\/\n(if Archi.ptr64 then 8 else 4) = 2 \\/\n(if Archi.ptr64 then 8 else 4) = 4 \\/ (if Archi.ptr64 then 8 else 4) = 8.","proofString":"destruct Archi.ptr64; auto."},{"statement":"(X : forall co : composite,\nlet a0 := Z.min 8 (co_alignof co) in a0 = 1 \\/ a0 = 2 \\/ a0 = 4 \\/ a0 = 8) (env : composite_env) (ty : type) (z : Z) (a : attr) (IHty : let a0 := alignof_blockcopy env ty in a0 = 1 \\/ a0 = 2 \\/ a0 = 4 \\/ a0 = 8) : alignof_blockcopy env ty = 1 \\/\nalignof_blockcopy env ty = 2 \\/\nalignof_blockcopy env ty = 4 \\/ alignof_blockcopy env ty = 8.","proofString":"apply IHty."},{"statement":"(X : forall co : composite,\nlet a := Z.min 8 (co_alignof co) in a = 1 \\/ a = 2 \\/ a = 4 \\/ a = 8) (env : composite_env) (l : list type) (ty : type) (c : calling_convention) (IHty : let a := alignof_blockcopy env ty in a = 1 \\/ a = 2 \\/ a = 4 \\/ a = 8) : 1 = 1 \\/ 1 = 2 \\/ 1 = 4 \\/ 1 = 8.","proofString":"auto."},{"statement":"(X : forall co : composite,\nlet a0 := Z.min 8 (co_alignof co) in a0 = 1 \\/ a0 = 2 \\/ a0 = 4 \\/ a0 = 8) (env : composite_env) (i : ident) (a : attr) : match env ! i with\n| Some co => Z.min 8 (co_alignof co)\n| None => 1\nend = 1 \\/\nmatch env ! i with\n| Some co => Z.min 8 (co_alignof co)\n| None => 1\nend = 2 \\/\nmatch env ! i with\n| Some co => Z.min 8 (co_alignof co)\n| None => 1\nend = 4 \\/\nmatch env ! i with\n| Some co => Z.min 8 (co_alignof co)\n| None => 1\nend = 8.","proofString":"destruct (env!i); auto."},{"statement":"(X : forall co : composite,\nlet a0 := Z.min 8 (co_alignof co) in a0 = 1 \\/ a0 = 2 \\/ a0 = 4 \\/ a0 = 8) (env : composite_env) (i : ident) (a : attr) : match env ! i with\n| Some co => Z.min 8 (co_alignof co)\n| None => 1\nend = 1 \\/\nmatch env ! i with\n| Some co => Z.min 8 (co_alignof co)\n| None => 1\nend = 2 \\/\nmatch env ! i with\n| Some co => Z.min 8 (co_alignof co)\n| None => 1\nend = 4 \\/\nmatch env ! i with\n| Some co => Z.min 8 (co_alignof co)\n| None => 1\nend = 8.","proofString":"destruct (env!i); auto."},{"statement":"(env : composite_env) (ty : type) : alignof_blockcopy env ty > 0.","proofString":"generalize (alignof_blockcopy_1248 env ty).\nsimpl.\nintuition lia."},{"statement":"(env : composite_env) (ty : type) : (let a := alignof_blockcopy env ty in a = 1 \\/ a = 2 \\/ a = 4 \\/ a = 8) ->\nalignof_blockcopy env ty > 0.","proofString":"simpl.\nintuition lia."},{"statement":"(env : composite_env) (ty : type) : alignof_blockcopy env ty = 1 \\/\nalignof_blockcopy env ty = 2 \\/\nalignof_blockcopy env ty = 4 \\/ alignof_blockcopy env ty = 8 ->\nalignof_blockcopy env ty > 0.","proofString":"intuition lia."},{"statement":"(env : composite_env) (su : struct_or_union) (m : members) : 0 <= sizeof_composite env su m.","proofString":"destruct su; simpl.\nunfold sizeof_struct, bytes_of_bits.\nassert (0 <= bitsizeof_struct env 0 m) by apply bitsizeof_struct_incr.\nchange 0 with (0 / 8) at 1.\napply Z.div_le_mono; lia.\napply sizeof_union_pos."},{"statement":"(env : composite_env) (m : members) : 0 <= sizeof_struct env m.","proofString":"unfold sizeof_struct, bytes_of_bits.\nassert (0 <= bitsizeof_struct env 0 m) by apply bitsizeof_struct_incr.\nchange 0 with (0 / 8) at 1.\napply Z.div_le_mono; lia."},{"statement":"(env : composite_env) (m : members) : 0 <= (bitsizeof_struct env 0 m + 7) / 8.","proofString":"assert (0 <= bitsizeof_struct env 0 m) by apply bitsizeof_struct_incr.\nchange 0 with (0 / 8) at 1.\napply Z.div_le_mono; lia."},{"statement":"(env : composite_env) (m : members) (H : 0 <= bitsizeof_struct env 0 m) : 0 <= (bitsizeof_struct env 0 m + 7) / 8.","proofString":"change 0 with (0 / 8) at 1.\napply Z.div_le_mono; lia."},{"statement":"(env : composite_env) (m : members) (H : 0 <= bitsizeof_struct env 0 m) : 0 / 8 <= (bitsizeof_struct env 0 m + 7) / 8.","proofString":"apply Z.div_le_mono; lia."},{"statement":"(env : composite_env) (m : members) : 0 <= sizeof_union env m.","proofString":"apply sizeof_union_pos."},{"statement":"(env : composite_env) (m m1 : member) (ms : list member) (IHms : In m ms ->\ncomplete_members env ms = true -> complete_type env (type_member m) = true) (H0 : complete_type env (type_member m1) && complete_members env ms = true) (H1 : m1 = m) : complete_type env (type_member m) = true.","proofString":"InvBooleans; inv H1; auto."},{"statement":"(env : composite_env) (m m1 : member) (ms : list member) (H0 : complete_type env (type_member m1) && complete_members env ms = true) (H1 : In m ms) (H : complete_members env ms = true -> complete_type env (type_member m) = true) : complete_type env (type_member m) = true.","proofString":"InvBooleans; eauto."},{"statement":"(i : ident) (a : attr) (H : match env ! i with\n| Some _ => true\n| None => false\nend = true) : match env' ! i with\n| Some co => co_alignof co\n| None => 1\nend = match env ! i with\n      | Some co => co_alignof co\n      | None => 1\n      end.","proofString":"destruct (env!i) as [co|] eqn:E; try discriminate.\nerewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : match env' ! i with\n| Some co0 => co_alignof co0\n| None => 1\nend = co_alignof co.","proofString":"erewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : co_alignof co = co_alignof co.","proofString":"auto."},{"statement":"(i : ident) (a : attr) (H : match env ! i with\n| Some _ => true\n| None => false\nend = true) : match env' ! i with\n| Some co => co_alignof co\n| None => 1\nend = match env ! i with\n      | Some co => co_alignof co\n      | None => 1\n      end.","proofString":"destruct (env!i) as [co|] eqn:E; try discriminate.\nerewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : match env' ! i with\n| Some co0 => co_alignof co0\n| None => 1\nend = co_alignof co.","proofString":"erewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : co_alignof co = co_alignof co.","proofString":"auto."},{"statement":"(t : type) (z : Z) (a : attr) (IHt : complete_type env t = true -> sizeof env' t = sizeof env t) (H : complete_type env t = true) : sizeof env' t * Z.max 0 z = sizeof env t * Z.max 0 z.","proofString":"rewrite IHt by auto.\nauto."},{"statement":"(t : type) (z : Z) (a : attr) (IHt : complete_type env t = true -> sizeof env' t = sizeof env t) (H : complete_type env t = true) : sizeof env t * Z.max 0 z = sizeof env t * Z.max 0 z.","proofString":"auto."},{"statement":"(i : ident) (a : attr) (H : match env ! i with\n| Some _ => true\n| None => false\nend = true) : match env' ! i with\n| Some co => co_sizeof co\n| None => 0\nend = match env ! i with\n      | Some co => co_sizeof co\n      | None => 0\n      end.","proofString":"destruct (env!i) as [co|] eqn:E; try discriminate.\nerewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : match env' ! i with\n| Some co0 => co_sizeof co0\n| None => 0\nend = co_sizeof co.","proofString":"erewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : co_sizeof co = co_sizeof co.","proofString":"auto."},{"statement":"(i : ident) (a : attr) (H : match env ! i with\n| Some _ => true\n| None => false\nend = true) : match env' ! i with\n| Some co => co_sizeof co\n| None => 0\nend = match env ! i with\n      | Some co => co_sizeof co\n      | None => 0\n      end.","proofString":"destruct (env!i) as [co|] eqn:E; try discriminate.\nerewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : match env' ! i with\n| Some co0 => co_sizeof co0\n| None => 0\nend = co_sizeof co.","proofString":"erewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : co_sizeof co = co_sizeof co.","proofString":"auto."},{"statement":"(i : ident) (a : attr) (H : match env ! i with\n| Some _ => true\n| None => false\nend = true) : match env' ! i with\n| Some _ => true\n| None => false\nend = true.","proofString":"destruct (env!i) as [co|] eqn:E; try discriminate.\nerewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : match env' ! i with\n| Some _ => true\n| None => false\nend = true.","proofString":"erewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : true = true.","proofString":"auto."},{"statement":"(i : ident) (a : attr) (H : match env ! i with\n| Some _ => true\n| None => false\nend = true) : match env' ! i with\n| Some _ => true\n| None => false\nend = true.","proofString":"destruct (env!i) as [co|] eqn:E; try discriminate.\nerewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : match env' ! i with\n| Some _ => true\n| None => false\nend = true.","proofString":"erewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : true = true.","proofString":"auto."},{"statement":"(i : ident) (a : attr) (H : match env ! i with\n| Some _ => true\n| None => false\nend = true) : match env' ! i with\n| Some co => S (co_rank co)\n| None => 0%nat\nend = match env ! i with\n      | Some co => S (co_rank co)\n      | None => 0%nat\n      end.","proofString":"destruct (env!i) as [co|] eqn:E; try discriminate.\nerewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : match env' ! i with\n| Some co0 => S (co_rank co0)\n| None => 0%nat\nend = S (co_rank co).","proofString":"erewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : S (co_rank co) = S (co_rank co).","proofString":"auto."},{"statement":"(i : ident) (a : attr) (H : match env ! i with\n| Some _ => true\n| None => false\nend = true) : match env' ! i with\n| Some co => S (co_rank co)\n| None => 0%nat\nend = match env ! i with\n      | Some co => S (co_rank co)\n      | None => 0%nat\n      end.","proofString":"destruct (env!i) as [co|] eqn:E; try discriminate.\nerewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : match env' ! i with\n| Some co0 => S (co_rank co0)\n| None => 0%nat\nend = S (co_rank co).","proofString":"erewrite extends by eauto.\nauto."},{"statement":"(i : ident) (a : attr) (co : composite) (E : env ! i = Some co) (H : true = true) : S (co_rank co) = S (co_rank co).","proofString":"auto."},{"statement":"(H : true = true) : 1 = 1.","proofString":"auto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true ->\nalignof_composite env' ms = alignof_composite env ms) (H : complete_type env (type_member m) && complete_members env ms = true) : (if member_is_padding m\n then alignof_composite env' ms\n else Z.max (alignof env' (type_member m)) (alignof_composite env' ms)) =\n(if member_is_padding m\n then alignof_composite env ms\n else Z.max (alignof env (type_member m)) (alignof_composite env ms)).","proofString":"InvBooleans.\nrewrite alignof_stable by auto.\nrewrite IHms by auto.\nauto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true ->\nalignof_composite env' ms = alignof_composite env ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : (if member_is_padding m\n then alignof_composite env' ms\n else Z.max (alignof env' (type_member m)) (alignof_composite env' ms)) =\n(if member_is_padding m\n then alignof_composite env ms\n else Z.max (alignof env (type_member m)) (alignof_composite env ms)).","proofString":"rewrite alignof_stable by auto.\nrewrite IHms by auto.\nauto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true ->\nalignof_composite env' ms = alignof_composite env ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : (if member_is_padding m\n then alignof_composite env' ms\n else Z.max (alignof env (type_member m)) (alignof_composite env' ms)) =\n(if member_is_padding m\n then alignof_composite env ms\n else Z.max (alignof env (type_member m)) (alignof_composite env ms)).","proofString":"rewrite IHms by auto.\nauto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true ->\nalignof_composite env' ms = alignof_composite env ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : (if member_is_padding m\n then alignof_composite env ms\n else Z.max (alignof env (type_member m)) (alignof_composite env ms)) =\n(if member_is_padding m\n then alignof_composite env ms\n else Z.max (alignof env (type_member m)) (alignof_composite env ms)).","proofString":"auto."},{"statement":"(pos : Z) (id : ident) (t : type) (H : complete_type env t = true) : align pos (bitalignof env' t) + bitsizeof env' t =\nalign pos (bitalignof env t) + bitsizeof env t.","proofString":"unfold bitalignof, bitsizeof.\nrewrite alignof_stable, sizeof_stable by auto.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (H : complete_type env t = true) : align pos (alignof env' t * 8) + sizeof env' t * 8 =\nalign pos (alignof env t * 8) + sizeof env t * 8.","proofString":"rewrite alignof_stable, sizeof_stable by auto.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (H : complete_type env t = true) : align pos (alignof env t * 8) + sizeof env t * 8 =\nalign pos (alignof env t * 8) + sizeof env t * 8.","proofString":"auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (H : true = true) : (if zle width 0\n then align pos (bitalignof_intsize sz)\n else\n  if\n   zle (pos + width)\n     (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n  then pos + width\n  else floor pos (bitalignof_intsize sz) + bitalignof_intsize sz + width) =\n(if zle width 0\n then align pos (bitalignof_intsize sz)\n else\n  if\n   zle (pos + width)\n     (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n  then pos + width\n  else floor pos (bitalignof_intsize sz) + bitalignof_intsize sz + width).","proofString":"auto."},{"statement":"(pos : Z) (H : true = true) : pos = pos.","proofString":"auto."},{"statement":"(m : member) (ms : list member) (IHms : forall pos0 : Z,\ncomplete_members env ms = true ->\nbitsizeof_struct env' pos0 ms = bitsizeof_struct env pos0 ms) (pos : Z) (H : complete_type env (type_member m) && complete_members env ms = true) : bitsizeof_struct env' (next_field env' pos m) ms =\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"InvBooleans.\nrewrite next_field_stable by auto.\napply IHms; auto."},{"statement":"(m : member) (ms : list member) (IHms : forall pos0 : Z,\ncomplete_members env ms = true ->\nbitsizeof_struct env' pos0 ms = bitsizeof_struct env pos0 ms) (pos : Z) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : bitsizeof_struct env' (next_field env' pos m) ms =\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"rewrite next_field_stable by auto.\napply IHms; auto."},{"statement":"(m : member) (ms : list member) (IHms : forall pos0 : Z,\ncomplete_members env ms = true ->\nbitsizeof_struct env' pos0 ms = bitsizeof_struct env pos0 ms) (pos : Z) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : bitsizeof_struct env' (next_field env pos m) ms =\nbitsizeof_struct env (next_field env pos m) ms.","proofString":"apply IHms; auto."},{"statement":"(H : true = true) : 0 = 0.","proofString":"auto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> sizeof_union env' ms = sizeof_union env ms) (H : complete_type env (type_member m) && complete_members env ms = true) : Z.max (sizeof env' (type_member m)) (sizeof_union env' ms) =\nZ.max (sizeof env (type_member m)) (sizeof_union env ms).","proofString":"InvBooleans.\nrewrite sizeof_stable by auto.\nrewrite IHms by auto.\nauto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> sizeof_union env' ms = sizeof_union env ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : Z.max (sizeof env' (type_member m)) (sizeof_union env' ms) =\nZ.max (sizeof env (type_member m)) (sizeof_union env ms).","proofString":"rewrite sizeof_stable by auto.\nrewrite IHms by auto.\nauto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> sizeof_union env' ms = sizeof_union env ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : Z.max (sizeof env (type_member m)) (sizeof_union env' ms) =\nZ.max (sizeof env (type_member m)) (sizeof_union env ms).","proofString":"rewrite IHms by auto.\nauto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> sizeof_union env' ms = sizeof_union env ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : Z.max (sizeof env (type_member m)) (sizeof_union env ms) =\nZ.max (sizeof env (type_member m)) (sizeof_union env ms).","proofString":"auto."},{"statement":"(su : struct_or_union) (ms : members) (H : complete_members env ms = true) : sizeof_composite env' su ms = sizeof_composite env su ms.","proofString":"destruct su; simpl.\nunfold sizeof_struct.\nf_equal.\napply bitsizeof_struct_stable; auto.\napply sizeof_union_stable; auto."},{"statement":"(ms : members) (H : complete_members env ms = true) : sizeof_struct env' ms = sizeof_struct env ms.","proofString":"unfold sizeof_struct.\nf_equal.\napply bitsizeof_struct_stable; auto."},{"statement":"(ms : members) (H : complete_members env ms = true) : bytes_of_bits (bitsizeof_struct env' 0 ms) =\nbytes_of_bits (bitsizeof_struct env 0 ms).","proofString":"f_equal.\napply bitsizeof_struct_stable; auto."},{"statement":"(ms : members) (H : complete_members env ms = true) : bitsizeof_struct env' 0 ms = bitsizeof_struct env 0 ms.","proofString":"apply bitsizeof_struct_stable; auto."},{"statement":"(ms : members) (H : complete_members env ms = true) : sizeof_union env' ms = sizeof_union env ms.","proofString":"apply sizeof_union_stable; auto."},{"statement":"(H : true = true) : true = true.","proofString":"auto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> complete_members env' ms = true) (H : complete_type env (type_member m) && complete_members env ms = true) : complete_type env' (type_member m) && complete_members env' ms = true.","proofString":"InvBooleans.\nrewrite complete_type_stable by auto.\nrewrite IHms by auto.\nauto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> complete_members env' ms = true) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : complete_type env' (type_member m) && complete_members env' ms = true.","proofString":"rewrite complete_type_stable by auto.\nrewrite IHms by auto.\nauto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> complete_members env' ms = true) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : true && complete_members env' ms = true.","proofString":"rewrite IHms by auto.\nauto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> complete_members env' ms = true) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : true && true = true.","proofString":"auto."},{"statement":"(H : true = true) : 0%nat = 0%nat.","proofString":"auto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> rank_members env' ms = rank_members env ms) (H : complete_type env (type_member m) && complete_members env ms = true) : match m with\n| Member_plain _ t => Init.Nat.max (rank_type env' t) (rank_members env' ms)\n| Member_bitfield _ _ _ _ _ _ => rank_members env' ms\nend =\nmatch m with\n| Member_plain _ t => Init.Nat.max (rank_type env t) (rank_members env ms)\n| Member_bitfield _ _ _ _ _ _ => rank_members env ms\nend.","proofString":"InvBooleans.\ndestruct m; auto.\nf_equal; auto.\napply rank_type_stable; auto."},{"statement":"(m : member) (ms : list member) (IHms : complete_members env ms = true -> rank_members env' ms = rank_members env ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : match m with\n| Member_plain _ t => Init.Nat.max (rank_type env' t) (rank_members env' ms)\n| Member_bitfield _ _ _ _ _ _ => rank_members env' ms\nend =\nmatch m with\n| Member_plain _ t => Init.Nat.max (rank_type env t) (rank_members env ms)\n| Member_bitfield _ _ _ _ _ _ => rank_members env ms\nend.","proofString":"destruct m; auto.\nf_equal; auto.\napply rank_type_stable; auto."},{"statement":"(id : ident) (t : type) (ms : list member) (IHms : complete_members env ms = true -> rank_members env' ms = rank_members env ms) (H0 : complete_type env (type_member (Member_plain id t)) = true) (H1 : complete_members env ms = true) : Init.Nat.max (rank_type env' t) (rank_members env' ms) =\nInit.Nat.max (rank_type env t) (rank_members env ms).","proofString":"f_equal; auto.\napply rank_type_stable; auto."},{"statement":"(id : ident) (t : type) (ms : list member) (IHms : complete_members env ms = true -> rank_members env' ms = rank_members env ms) (H0 : complete_type env (type_member (Member_plain id t)) = true) (H1 : complete_members env ms = true) : rank_type env' t = rank_type env t.","proofString":"apply rank_type_stable; auto."},{"statement":"(pos : Z) (id : ident) (t : type) (H : complete_type env t = true) : OK (align pos (bitalignof env' t) / 8, Full) =\nOK (align pos (bitalignof env t) / 8, Full).","proofString":"unfold bitalignof.\nrewrite alignof_stable by auto.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (H : complete_type env t = true) : OK (align pos (alignof env' t * 8) / 8, Full) =\nOK (align pos (alignof env t * 8) / 8, Full).","proofString":"rewrite alignof_stable by auto.\nauto."},{"statement":"(pos : Z) (id : ident) (t : type) (H : complete_type env t = true) : OK (align pos (alignof env t * 8) / 8, Full) =\nOK (align pos (alignof env t * 8) / 8, Full).","proofString":"auto."},{"statement":"(pos : Z) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (H : true = true) : (if zle width 0\n then Error (msg \"accessing zero-width bitfield\")\n else\n  if zlt (bitsize_intsize sz) width\n  then Error (msg \"bitfield too wide\")\n  else\n   if\n    zle (pos + width)\n      (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n   then\n    OK\n      (floor pos (bitalignof_intsize sz) / 8,\n       Bits sz sg (pos - floor pos (bitalignof_intsize sz)) width)\n   else\n    OK\n      ((floor pos (bitalignof_intsize sz) + bitalignof_intsize sz) / 8,\n       Bits sz sg 0 width)) =\n(if zle width 0\n then Error (msg \"accessing zero-width bitfield\")\n else\n  if zlt (bitsize_intsize sz) width\n  then Error (msg \"bitfield too wide\")\n  else\n   if\n    zle (pos + width)\n      (floor pos (bitalignof_intsize sz) + bitalignof_intsize sz)\n   then\n    OK\n      (floor pos (bitalignof_intsize sz) / 8,\n       Bits sz sg (pos - floor pos (bitalignof_intsize sz)) width)\n   else\n    OK\n      ((floor pos (bitalignof_intsize sz) + bitalignof_intsize sz) / 8,\n       Bits sz sg 0 width)).","proofString":"auto."},{"statement":"(f : ident) (ms : members) : complete_members env ms = true ->\nfield_offset env' f ms = field_offset env f ms.","proofString":"unfold field_offset.\ngeneralize 0.\ninduction ms as [|m ms]; simpl; intros.\nauto.\nInvBooleans.\ndestruct (ident_eq f (name_member m)).\napply layout_field_stable; auto.\nrewrite next_field_stable by auto.\napply IHms; auto."},{"statement":"(f : ident) (ms : members) : complete_members env ms = true ->\nfield_offset_rec env' f ms 0 = field_offset_rec env f ms 0.","proofString":"generalize 0.\ninduction ms as [|m ms]; simpl; intros.\nauto.\nInvBooleans.\ndestruct (ident_eq f (name_member m)).\napply layout_field_stable; auto.\nrewrite next_field_stable by auto.\napply IHms; auto."},{"statement":"(f : ident) (ms : members) : forall z : Z,\ncomplete_members env ms = true ->\nfield_offset_rec env' f ms z = field_offset_rec env f ms z.","proofString":"induction ms as [|m ms]; simpl; intros.\nauto.\nInvBooleans.\ndestruct (ident_eq f (name_member m)).\napply layout_field_stable; auto.\nrewrite next_field_stable by auto.\napply IHms; auto."},{"statement":"(f : ident) (m : member) (ms : list member) (IHms : forall z0 : Z,\ncomplete_members env ms = true ->\nfield_offset_rec env' f ms z0 = field_offset_rec env f ms z0) (z : Z) (H : complete_type env (type_member m) && complete_members env ms = true) : (if ident_eq f (name_member m)\n then layout_field env' z m\n else field_offset_rec env' f ms (next_field env' z m)) =\n(if ident_eq f (name_member m)\n then layout_field env z m\n else field_offset_rec env f ms (next_field env z m)).","proofString":"InvBooleans.\ndestruct (ident_eq f (name_member m)).\napply layout_field_stable; auto.\nrewrite next_field_stable by auto.\napply IHms; auto."},{"statement":"(f : ident) (m : member) (ms : list member) (IHms : forall z0 : Z,\ncomplete_members env ms = true ->\nfield_offset_rec env' f ms z0 = field_offset_rec env f ms z0) (z : Z) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : (if ident_eq f (name_member m)\n then layout_field env' z m\n else field_offset_rec env' f ms (next_field env' z m)) =\n(if ident_eq f (name_member m)\n then layout_field env z m\n else field_offset_rec env f ms (next_field env z m)).","proofString":"destruct (ident_eq f (name_member m)).\napply layout_field_stable; auto.\nrewrite next_field_stable by auto.\napply IHms; auto."},{"statement":"(f : ident) (m : member) (ms : list member) (IHms : forall z0 : Z,\ncomplete_members env ms = true ->\nfield_offset_rec env' f ms z0 = field_offset_rec env f ms z0) (z : Z) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) (e : f = name_member m) : layout_field env' z m = layout_field env z m.","proofString":"apply layout_field_stable; auto."},{"statement":"(f : ident) (m : member) (ms : list member) (IHms : forall z0 : Z,\ncomplete_members env ms = true ->\nfield_offset_rec env' f ms z0 = field_offset_rec env f ms z0) (z : Z) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) (n : f <> name_member m) : field_offset_rec env' f ms (next_field env' z m) =\nfield_offset_rec env f ms (next_field env z m).","proofString":"rewrite next_field_stable by auto.\napply IHms; auto."},{"statement":"(f : ident) (m : member) (ms : list member) (IHms : forall z0 : Z,\ncomplete_members env ms = true ->\nfield_offset_rec env' f ms z0 = field_offset_rec env f ms z0) (z : Z) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) (n : f <> name_member m) : field_offset_rec env' f ms (next_field env z m) =\nfield_offset_rec env f ms (next_field env z m).","proofString":"apply IHms; auto."},{"statement":"(f : ident) (m : member) (ms : list member) (IHms : complete_members env ms = true ->\nunion_field_offset env' f ms = union_field_offset env f ms) (H : complete_type env (type_member m) && complete_members env ms = true) : (if ident_eq f (name_member m)\n then layout_field env' 0 m\n else union_field_offset env' f ms) =\n(if ident_eq f (name_member m)\n then layout_field env 0 m\n else union_field_offset env f ms).","proofString":"InvBooleans.\ndestruct (ident_eq f (name_member m)).\napply layout_field_stable; auto.\napply IHms; auto."},{"statement":"(f : ident) (m : member) (ms : list member) (IHms : complete_members env ms = true ->\nunion_field_offset env' f ms = union_field_offset env f ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) : (if ident_eq f (name_member m)\n then layout_field env' 0 m\n else union_field_offset env' f ms) =\n(if ident_eq f (name_member m)\n then layout_field env 0 m\n else union_field_offset env f ms).","proofString":"destruct (ident_eq f (name_member m)).\napply layout_field_stable; auto.\napply IHms; auto."},{"statement":"(f : ident) (m : member) (ms : list member) (IHms : complete_members env ms = true ->\nunion_field_offset env' f ms = union_field_offset env f ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) (e : f = name_member m) : layout_field env' 0 m = layout_field env 0 m.","proofString":"apply layout_field_stable; auto."},{"statement":"(f : ident) (m : member) (ms : list member) (IHms : complete_members env ms = true ->\nunion_field_offset env' f ms = union_field_offset env f ms) (H0 : complete_type env (type_member m) = true) (H1 : complete_members env ms = true) (n : f <> name_member m) : union_field_offset env' f ms = union_field_offset env f ms.","proofString":"apply IHms; auto."},{"statement":"(id : positive) (co : composite) (env1 env2 : composite_env) (H : OK env1 = OK env2) (H0 : env1 ! id = Some co) : env2 ! id = Some co.","proofString":"inv H; auto."},{"statement":"(id : positive) (co : composite) (a : composite_definition) (defs : list composite_definition) (IHdefs : forall env0 env3 : composite_env,\nadd_composite_definitions env0 defs = OK env3 ->\nenv0 ! id = Some co -> env3 ! id = Some co) (env1 env2 : composite_env) (H : match a with\n| Composite id0 su m a0 =>\n    do co0 <- composite_of_def env1 id0 su m a0;\n    add_composite_definitions (PTree.set id0 co0 env1) defs\nend = OK env2) (H0 : env1 ! id = Some co) : env2 ! id = Some co.","proofString":"destruct a; monadInv H.\neapply IHdefs; eauto.\nrewrite PTree.gso; auto.\nred; intros; subst id0.\nunfold composite_of_def in EQ.\nrewrite H0 in EQ; discriminate."},{"statement":"(id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env0 env3 : composite_env,\nadd_composite_definitions env0 defs = OK env3 ->\nenv0 ! id = Some co -> env3 ! id = Some co) (env1 env2 : composite_env) (H0 : env1 ! id = Some co) (x : composite) (EQ : composite_of_def env1 id0 su m a = OK x) (EQ0 : add_composite_definitions (PTree.set id0 x env1) defs = OK env2) : env2 ! id = Some co.","proofString":"eapply IHdefs; eauto.\nrewrite PTree.gso; auto.\nred; intros; subst id0.\nunfold composite_of_def in EQ.\nrewrite H0 in EQ; discriminate."},{"statement":"(id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env0 env3 : composite_env,\nadd_composite_definitions env0 defs = OK env3 ->\nenv0 ! id = Some co -> env3 ! id = Some co) (env1 env2 : composite_env) (H0 : env1 ! id = Some co) (x : composite) (EQ : composite_of_def env1 id0 su m a = OK x) (EQ0 : add_composite_definitions (PTree.set id0 x env1) defs = OK env2) : (PTree.set id0 x env1) ! id = Some co.","proofString":"rewrite PTree.gso; auto.\nred; intros; subst id0.\nunfold composite_of_def in EQ.\nrewrite H0 in EQ; discriminate."},{"statement":"(id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env0 env3 : composite_env,\nadd_composite_definitions env0 defs = OK env3 ->\nenv0 ! id = Some co -> env3 ! id = Some co) (env1 env2 : composite_env) (H0 : env1 ! id = Some co) (x : composite) (EQ : composite_of_def env1 id0 su m a = OK x) (EQ0 : add_composite_definitions (PTree.set id0 x env1) defs = OK env2) : id <> id0.","proofString":"red; intros; subst id0.\nunfold composite_of_def in EQ.\nrewrite H0 in EQ; discriminate."},{"statement":"(id : positive) (co : composite) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env0 env3 : composite_env,\nadd_composite_definitions env0 defs = OK env3 ->\nenv0 ! id = Some co -> env3 ! id = Some co) (env1 env2 : composite_env) (H0 : env1 ! id = Some co) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env1) defs = OK env2) (EQ : composite_of_def env1 id su m a = OK x) : False.","proofString":"unfold composite_of_def in EQ.\nrewrite H0 in EQ; discriminate."},{"statement":"(id : positive) (co : composite) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env0 env3 : composite_env,\nadd_composite_definitions env0 defs = OK env3 ->\nenv0 ! id = Some co -> env3 ! id = Some co) (env1 env2 : composite_env) (H0 : env1 ! id = Some co) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env1) defs = OK env2) (EQ : match env1 ! id with\n| Some _ =>\n    Error (MSG \"Multiple definitions of struct or union \" :: CTX id :: nil)\n| None =>\n    if complete_members env1 m\n    then\n     OK\n       {|\n         co_su := su;\n         co_members := m;\n         co_attr := a;\n         co_sizeof :=\n           align (sizeof_composite env1 su m)\n             (align_attr a (alignof_composite env1 m));\n         co_alignof := align_attr a (alignof_composite env1 m);\n         co_rank := rank_members env1 m;\n         co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n         co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n         co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n       |}\n    else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)\nend = OK x) : False.","proofString":"rewrite H0 in EQ; discriminate."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (H : composite_consistent env co) : composite_consistent env' co.","proofString":"destruct H as [A B C D].\nconstructor.\neapply complete_members_stable; eauto.\nsymmetry; rewrite B.\nf_equal.\napply alignof_composite_stable; auto.\nsymmetry; rewrite C.\nf_equal.\napply sizeof_composite_stable; auto.\nsymmetry; rewrite D.\napply rank_members_stable; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : composite_consistent env' co.","proofString":"constructor.\neapply complete_members_stable; eauto.\nsymmetry; rewrite B.\nf_equal.\napply alignof_composite_stable; auto.\nsymmetry; rewrite C.\nf_equal.\napply sizeof_composite_stable; auto.\nsymmetry; rewrite D.\napply rank_members_stable; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : complete_members env' (co_members co) = true.","proofString":"eapply complete_members_stable; eauto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env' (co_members co)).","proofString":"symmetry; rewrite B.\nf_equal.\napply alignof_composite_stable; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : align_attr (co_attr co) (alignof_composite env' (co_members co)) =\nalign_attr (co_attr co) (alignof_composite env (co_members co)).","proofString":"f_equal.\napply alignof_composite_stable; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : alignof_composite env' (co_members co) =\nalignof_composite env (co_members co).","proofString":"apply alignof_composite_stable; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : co_sizeof co =\nalign (sizeof_composite env' (co_su co) (co_members co)) (co_alignof co).","proofString":"symmetry; rewrite C.\nf_equal.\napply sizeof_composite_stable; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : align (sizeof_composite env' (co_su co) (co_members co)) (co_alignof co) =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co).","proofString":"f_equal.\napply sizeof_composite_stable; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : sizeof_composite env' (co_su co) (co_members co) =\nsizeof_composite env (co_su co) (co_members co).","proofString":"apply sizeof_composite_stable; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : co_rank co = rank_members env' (co_members co).","proofString":"symmetry; rewrite D.\napply rank_members_stable; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id : positive) (co0 : composite),\nenv ! id = Some co0 -> env' ! id = Some co0) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) : rank_members env' (co_members co) = rank_members env (co_members co).","proofString":"apply rank_members_stable; auto."},{"statement":"(env : composite_env) (id : ident) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : match env ! id with\n| Some _ =>\n    Error (MSG \"Multiple definitions of struct or union \" :: CTX id :: nil)\n| None =>\n    if complete_members env m\n    then\n     OK\n       {|\n         co_su := su;\n         co_members := m;\n         co_attr := a;\n         co_sizeof :=\n           align (sizeof_composite env su m)\n             (align_attr a (alignof_composite env m));\n         co_alignof := align_attr a (alignof_composite env m);\n         co_rank := rank_members env m;\n         co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n         co_alignof_two_p := composite_of_def_obligation_2 env m a;\n         co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n       |}\n    else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)\nend = OK co) : composite_consistent env co.","proofString":"destruct (env!id); try discriminate.\ndestruct (complete_members env m) eqn:C; inv H.\nconstructor; auto."},{"statement":"(env : composite_env) (id : ident) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : (if complete_members env m\n then\n  OK\n    {|\n      co_su := su;\n      co_members := m;\n      co_attr := a;\n      co_sizeof :=\n        align (sizeof_composite env su m)\n          (align_attr a (alignof_composite env m));\n      co_alignof := align_attr a (alignof_composite env m);\n      co_rank := rank_members env m;\n      co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n      co_alignof_two_p := composite_of_def_obligation_2 env m a;\n      co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n    |}\n else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)) = \nOK co) : composite_consistent env co.","proofString":"destruct (complete_members env m) eqn:C; inv H.\nconstructor; auto."},{"statement":"(env : composite_env) (id : ident) (su : struct_or_union) (m : members) (a : attr) (C : complete_members env m = true) : composite_consistent env\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |}.","proofString":"constructor; auto."},{"statement":"(forall (defs : list composite_definition) (env0 env : composite_env),\n add_composite_definitions env0 defs = OK env ->\n composite_env_consistent env0 -> composite_env_consistent env) ->\nforall (defs : list composite_definition) (env : composite_env),\nbuild_composite_env defs = OK env -> composite_env_consistent env.","proofString":"intros.\neapply H; eauto.\nred; intros.\nrewrite PTree.gempty in H1; discriminate."},{"statement":"(H : forall (defs0 : list composite_definition) (env0 env1 : composite_env),\nadd_composite_definitions env0 defs0 = OK env1 ->\ncomposite_env_consistent env0 -> composite_env_consistent env1) (defs : list composite_definition) (env : composite_env) (H0 : build_composite_env defs = OK env) : composite_env_consistent env.","proofString":"eapply H; eauto.\nred; intros.\nrewrite PTree.gempty in H1; discriminate."},{"statement":"(H : forall (defs0 : list composite_definition) (env0 env1 : composite_env),\nadd_composite_definitions env0 defs0 = OK env1 ->\ncomposite_env_consistent env0 -> composite_env_consistent env1) (defs : list composite_definition) (env : composite_env) (H0 : build_composite_env defs = OK env) : composite_env_consistent (PTree.empty composite).","proofString":"red; intros.\nrewrite PTree.gempty in H1; discriminate."},{"statement":"(H : forall (defs0 : list composite_definition) (env0 env1 : composite_env),\nadd_composite_definitions env0 defs0 = OK env1 ->\ncomposite_env_consistent env0 -> composite_env_consistent env1) (defs : list composite_definition) (env : composite_env) (H0 : build_composite_env defs = OK env) (id : positive) (co : composite) (H1 : (PTree.empty composite) ! id = Some co) : composite_consistent (PTree.empty composite) co.","proofString":"rewrite PTree.gempty in H1; discriminate."},{"statement":"forall (defs : list composite_definition) (env0 env : composite_env),\nadd_composite_definitions env0 defs = OK env ->\ncomposite_env_consistent env0 -> composite_env_consistent env.","proofString":"induction defs as [|d1 defs]; simpl; intros.\ninv H; auto.\ndestruct d1; monadInv H.\neapply IHdefs; eauto.\nset (env1 := PTree.set id x env0) in *.\nassert (env0!id = None).\nunfold composite_of_def in EQ.\ndestruct (env0!id).\ndiscriminate.\nauto.\nassert (forall id1 co1, env0!id1 = Some co1 -> env1!id1 = Some co1).\nintros.\nunfold env1.\nrewrite PTree.gso; auto.\ncongruence.\nred; intros.\napply composite_consistent_stable with env0; auto.\nunfold env1 in H2; rewrite PTree.gsspec in H2; destruct (peq id0 id).\nsubst id0.\ninversion H2; clear H2.\nsubst co.\neapply composite_of_def_consistent; eauto.\neapply H0; eauto."},{"statement":"(env0 env : composite_env) (H : OK env0 = OK env) (H0 : composite_env_consistent env0) : composite_env_consistent env.","proofString":"inv H; auto."},{"statement":"(d1 : composite_definition) (defs : list composite_definition) (IHdefs : forall env1 env2 : composite_env,\nadd_composite_definitions env1 defs = OK env2 ->\ncomposite_env_consistent env1 -> composite_env_consistent env2) (env0 env : composite_env) (H : match d1 with\n| Composite id su m a =>\n    do co <- composite_of_def env0 id su m a;\n    add_composite_definitions (PTree.set id co env0) defs\nend = OK env) (H0 : composite_env_consistent env0) : composite_env_consistent env.","proofString":"destruct d1; monadInv H.\neapply IHdefs; eauto.\nset (env1 := PTree.set id x env0) in *.\nassert (env0!id = None).\nunfold composite_of_def in EQ.\ndestruct (env0!id).\ndiscriminate.\nauto.\nassert (forall id1 co1, env0!id1 = Some co1 -> env1!id1 = Some co1).\nintros.\nunfold env1.\nrewrite PTree.gso; auto.\ncongruence.\nred; intros.\napply composite_consistent_stable with env0; auto.\nunfold env1 in H2; rewrite PTree.gsspec in H2; destruct (peq id0 id).\nsubst id0.\ninversion H2; clear H2.\nsubst co.\neapply composite_of_def_consistent; eauto.\neapply H0; eauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env1 env2 : composite_env,\nadd_composite_definitions env1 defs = OK env2 ->\ncomposite_env_consistent env1 -> composite_env_consistent env2) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) : composite_env_consistent env.","proofString":"eapply IHdefs; eauto.\nset (env1 := PTree.set id x env0) in *.\nassert (env0!id = None).\nunfold composite_of_def in EQ.\ndestruct (env0!id).\ndiscriminate.\nauto.\nassert (forall id1 co1, env0!id1 = Some co1 -> env1!id1 = Some co1).\nintros.\nunfold env1.\nrewrite PTree.gso; auto.\ncongruence.\nred; intros.\napply composite_consistent_stable with env0; auto.\nunfold env1 in H2; rewrite PTree.gsspec in H2; destruct (peq id0 id).\nsubst id0.\ninversion H2; clear H2.\nsubst co.\neapply composite_of_def_consistent; eauto.\neapply H0; eauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env1 env2 : composite_env,\nadd_composite_definitions env1 defs = OK env2 ->\ncomposite_env_consistent env1 -> composite_env_consistent env2) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) : composite_env_consistent (PTree.set id x env0).","proofString":"set (env1 := PTree.set id x env0) in *.\nassert (env0!id = None).\nunfold composite_of_def in EQ.\ndestruct (env0!id).\ndiscriminate.\nauto.\nassert (forall id1 co1, env0!id1 = Some co1 -> env1!id1 = Some co1).\nintros.\nunfold env1.\nrewrite PTree.gso; auto.\ncongruence.\nred; intros.\napply composite_consistent_stable with env0; auto.\nunfold env1 in H2; rewrite PTree.gsspec in H2; destruct (peq id0 id).\nsubst id0.\ninversion H2; clear H2.\nsubst co.\neapply composite_of_def_consistent; eauto.\neapply H0; eauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) : env0 ! id = None.","proofString":"unfold composite_of_def in EQ.\ndestruct (env0!id).\ndiscriminate.\nauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : match env0 ! id with\n| Some _ =>\n    Error (MSG \"Multiple definitions of struct or union \" :: CTX id :: nil)\n| None =>\n    if complete_members env0 m\n    then\n     OK\n       {|\n         co_su := su;\n         co_members := m;\n         co_attr := a;\n         co_sizeof :=\n           align (sizeof_composite env0 su m)\n             (align_attr a (alignof_composite env0 m));\n         co_alignof := align_attr a (alignof_composite env0 m);\n         co_rank := rank_members env0 m;\n         co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n         co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n         co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n       |}\n    else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)\nend = OK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) : env0 ! id = None.","proofString":"destruct (env0!id).\ndiscriminate.\nauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x c : composite) (EQ : Error (MSG \"Multiple definitions of struct or union \" :: CTX id :: nil) =\nOK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) : Some c = None.","proofString":"discriminate."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) (H : env0 ! id = None) (id1 : positive) (co1 : composite) (H1 : env0 ! id1 = Some co1) : (PTree.set id x env0) ! id1 = Some co1.","proofString":"rewrite PTree.gso; auto.\ncongruence."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) (H : env0 ! id = None) (id1 : positive) (co1 : composite) (H1 : env0 ! id1 = Some co1) : id1 <> id.","proofString":"congruence."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) (H : env0 ! id = None) (H1 : forall (id1 : positive) (co1 : composite),\nenv0 ! id1 = Some co1 -> env1 ! id1 = Some co1) (id0 : positive) (co : composite) (e : id0 = id) (H2 : Some x = Some co) : composite_consistent env0 co.","proofString":"subst id0.\ninversion H2; clear H2.\nsubst co.\neapply composite_of_def_consistent; eauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) (H : env0 ! id = None) (H1 : forall (id1 : positive) (co1 : composite),\nenv0 ! id1 = Some co1 -> env1 ! id1 = Some co1) (co : composite) (H2 : Some x = Some co) : composite_consistent env0 co.","proofString":"inversion H2; clear H2.\nsubst co.\neapply composite_of_def_consistent; eauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) (H : env0 ! id = None) (H1 : forall (id1 : positive) (co1 : composite),\nenv0 ! id1 = Some co1 -> env1 ! id1 = Some co1) (co : composite) (H4 : x = co) : composite_consistent env0 co.","proofString":"subst co.\neapply composite_of_def_consistent; eauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) (H : env0 ! id = None) (H1 : forall (id1 : positive) (co1 : composite),\nenv0 ! id1 = Some co1 -> env1 ! id1 = Some co1) : composite_consistent env0 x.","proofString":"eapply composite_of_def_consistent; eauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall env2 env3 : composite_env,\nadd_composite_definitions env2 defs = OK env3 ->\ncomposite_env_consistent env2 -> composite_env_consistent env3) (env0 env : composite_env) (H0 : composite_env_consistent env0) (x : composite) (EQ : composite_of_def env0 id su m a = OK x) (env1 : PTree.tree composite) (EQ0 : add_composite_definitions env1 defs = OK env) (H : env0 ! id = None) (H1 : forall (id1 : positive) (co1 : composite),\nenv0 ! id1 = Some co1 -> env1 ! id1 = Some co1) (id0 : positive) (co : composite) (n : id0 <> id) (H2 : env0 ! id0 = Some co) : composite_consistent env0 co.","proofString":"eapply H0; eauto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) : forall env : composite_env,\nbuild_composite_env defs = OK env ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"unfold build_composite_env.\ngeneralize (PTree.empty composite) as env0.\nrevert defs.\ninduction defs as [|d1 defs]; simpl; intros.\ncontradiction.\ndestruct d1; monadInv H.\ndestruct H0; [idtac|eapply IHdefs;eauto].\ninv H.\nunfold composite_of_def in EQ.\ndestruct (env0!id) eqn:E; try discriminate.\ndestruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) : forall env : composite_env,\nadd_composite_definitions (PTree.empty composite) defs = OK env ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"generalize (PTree.empty composite) as env0.\nrevert defs.\ninduction defs as [|d1 defs]; simpl; intros.\ncontradiction.\ndestruct d1; monadInv H.\ndestruct H0; [idtac|eapply IHdefs;eauto].\ninv H.\nunfold composite_of_def in EQ.\ndestruct (env0!id) eqn:E; try discriminate.\ndestruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) : forall (env0 : PTree.t composite) (env : composite_env),\nadd_composite_definitions env0 defs = OK env ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"revert defs.\ninduction defs as [|d1 defs]; simpl; intros.\ncontradiction.\ndestruct d1; monadInv H.\ndestruct H0; [idtac|eapply IHdefs;eauto].\ninv H.\nunfold composite_of_def in EQ.\ndestruct (env0!id) eqn:E; try discriminate.\ndestruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) : forall (defs : list composite_definition) (env0 : PTree.t composite)\n  (env : composite_env),\nadd_composite_definitions env0 defs = OK env ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"induction defs as [|d1 defs]; simpl; intros.\ncontradiction.\ndestruct d1; monadInv H.\ndestruct H0; [idtac|eapply IHdefs;eauto].\ninv H.\nunfold composite_of_def in EQ.\ndestruct (env0!id) eqn:E; try discriminate.\ndestruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (env0 : PTree.t composite) (env : composite_env) (H : OK env0 = OK env) (H0 : False) : exists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"contradiction."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (d1 : composite_definition) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (H : match d1 with\n| Composite id0 su0 m0 a0 =>\n    do co <- composite_of_def env0 id0 su0 m0 a0;\n    add_composite_definitions (PTree.set id0 co env0) defs\nend = OK env) (H0 : d1 = Composite id su m a \\/ In (Composite id su m a) defs) : exists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"destruct d1; monadInv H.\ndestruct H0; [idtac|eapply IHdefs;eauto].\ninv H.\nunfold composite_of_def in EQ.\ndestruct (env0!id) eqn:E; try discriminate.\ndestruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (H0 : Composite id0 su0 m0 a0 = Composite id su m a \\/\nIn (Composite id su m a) defs) (x : composite) (EQ : composite_of_def env0 id0 su0 m0 a0 = OK x) (EQ0 : add_composite_definitions (PTree.set id0 x env0) defs = OK env) : exists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"destruct H0; [idtac|eapply IHdefs;eauto].\ninv H.\nunfold composite_of_def in EQ.\ndestruct (env0!id) eqn:E; try discriminate.\ndestruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (id0 : ident) (su0 : struct_or_union) (m0 : members) (a0 : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (H : Composite id0 su0 m0 a0 = Composite id su m a) (x : composite) (EQ : composite_of_def env0 id0 su0 m0 a0 = OK x) (EQ0 : add_composite_definitions (PTree.set id0 x env0) defs = OK env) : exists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"inv H.\nunfold composite_of_def in EQ.\ndestruct (env0!id) eqn:E; try discriminate.\ndestruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) (EQ : composite_of_def env0 id su m a = OK x) : exists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"unfold composite_of_def in EQ.\ndestruct (env0!id) eqn:E; try discriminate.\ndestruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) (EQ : match env0 ! id with\n| Some _ =>\n    Error (MSG \"Multiple definitions of struct or union \" :: CTX id :: nil)\n| None =>\n    if complete_members env0 m\n    then\n     OK\n       {|\n         co_su := su;\n         co_members := m;\n         co_attr := a;\n         co_sizeof :=\n           align (sizeof_composite env0 su m)\n             (align_attr a (alignof_composite env0 m));\n         co_alignof := align_attr a (alignof_composite env0 m);\n         co_rank := rank_members env0 m;\n         co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n         co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n         co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n       |}\n    else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)\nend = OK x) : exists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"destruct (env0!id) eqn:E; try discriminate.\ndestruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) (E : env0 ! id = None) (EQ : (if complete_members env0 m\n then\n  OK\n    {|\n      co_su := su;\n      co_members := m;\n      co_attr := a;\n      co_sizeof :=\n        align (sizeof_composite env0 su m)\n          (align_attr a (alignof_composite env0 m));\n      co_alignof := align_attr a (alignof_composite env0 m);\n      co_rank := rank_members env0 m;\n      co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n      co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n      co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n    |}\n else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)) = \nOK x) : exists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"destruct (complete_members env0 m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) (E : env0 ! id = None) (C : complete_members env0 m = true) (EQ : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env0 su m)\n        (align_attr a (alignof_composite env0 m));\n    co_alignof := align_attr a (alignof_composite env0 m);\n    co_rank := rank_members env0 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n  |} = OK x) : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env0 su m)\n      (align_attr a (alignof_composite env0 m));\n  co_alignof := align_attr a (alignof_composite env0 m);\n  co_rank := rank_members env0 m;\n  co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n|} = x ->\nexists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"clear EQ; intros EQ.\nexists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) (E : env0 ! id = None) (C : complete_members env0 m = true) (EQ : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env0 su m)\n      (align_attr a (alignof_composite env0 m));\n  co_alignof := align_attr a (alignof_composite env0 m);\n  co_rank := rank_members env0 m;\n  co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n|} = x) : exists co : composite,\n  env ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su.","proofString":"exists x.\nsplit.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) (E : env0 ! id = None) (C : complete_members env0 m = true) (EQ : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env0 su m)\n      (align_attr a (alignof_composite env0 m));\n  co_alignof := align_attr a (alignof_composite env0 m);\n  co_rank := rank_members env0 m;\n  co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n|} = x) : env ! id = Some x /\\ co_members x = m /\\ co_attr x = a /\\ co_su x = su.","proofString":"split.\neapply add_composite_definitions_incr; eauto.\napply PTree.gss.\nsubst x; auto."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) (E : env0 ! id = None) (C : complete_members env0 m = true) (EQ : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env0 su m)\n      (align_attr a (alignof_composite env0 m));\n  co_alignof := align_attr a (alignof_composite env0 m);\n  co_rank := rank_members env0 m;\n  co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n|} = x) : env ! id = Some x.","proofString":"eapply add_composite_definitions_incr; eauto.\napply PTree.gss."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) (E : env0 ! id = None) (C : complete_members env0 m = true) (EQ : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env0 su m)\n      (align_attr a (alignof_composite env0 m));\n  co_alignof := align_attr a (alignof_composite env0 m);\n  co_rank := rank_members env0 m;\n  co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n|} = x) : (PTree.set id x env0) ! id = Some x.","proofString":"apply PTree.gss."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (defs : list composite_definition) (IHdefs : forall (env1 : PTree.t composite) (env2 : composite_env),\nadd_composite_definitions env1 defs = OK env2 ->\nIn (Composite id su m a) defs ->\nexists co : composite,\n  env2 ! id = Some co /\\ co_members co = m /\\ co_attr co = a /\\ co_su co = su) (env0 : PTree.t composite) (env : composite_env) (x : composite) (EQ0 : add_composite_definitions (PTree.set id x env0) defs = OK env) (E : env0 ! id = None) (C : complete_members env0 m = true) (EQ : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env0 su m)\n      (align_attr a (alignof_composite env0 m));\n  co_alignof := align_attr a (alignof_composite env0 m);\n  co_rank := rank_members env0 m;\n  co_sizeof_pos := composite_of_def_obligation_1 env0 su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env0 m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env0 su m a\n|} = x) : co_members x = m /\\ co_attr x = a /\\ co_su x = su.","proofString":"subst x; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) : build_composite_env defs0 = OK env0 ->\nenv0 ! id = Some co ->\nIn (Composite id (co_su co) (co_members co) (co_attr co)) defs0.","proofString":"assert (REC: forall l env env',    add_composite_definitions env l = OK env' ->    env'!id = Some co ->    env!id = Some co \\/ In (Composite id (co_su co) (co_members co) (co_attr co)) l).\ninduction l; simpl; intros.\ninv H; auto.\ndestruct a; monadInv H.\nexploit IHl; eauto.\nunfold composite_of_def in EQ.\ndestruct (env!id0) eqn:E; try discriminate.\ndestruct (complete_members env m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nrewrite PTree.gsspec.\nintros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto.\nintros.\nexploit REC; eauto.\nrewrite PTree.gempty.\nintuition congruence."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) : forall (l : list composite_definition) (env env' : composite_env),\nadd_composite_definitions env l = OK env' ->\nenv' ! id = Some co ->\nenv ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"induction l; simpl; intros.\ninv H; auto.\ndestruct a; monadInv H.\nexploit IHl; eauto.\nunfold composite_of_def in EQ.\ndestruct (env!id0) eqn:E; try discriminate.\ndestruct (complete_members env m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nrewrite PTree.gsspec.\nintros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (env env' : composite_env) (H : OK env = OK env') (H0 : env' ! id = Some co) : env ! id = Some co \\/ False.","proofString":"inv H; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (a : composite_definition) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H : match a with\n| Composite id0 su m a0 =>\n    do co0 <- composite_of_def env id0 su m a0;\n    add_composite_definitions (PTree.set id0 co0 env) l\nend = OK env') (H0 : env' ! id = Some co) : env ! id = Some co \\/\na = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"destruct a; monadInv H.\nexploit IHl; eauto.\nunfold composite_of_def in EQ.\ndestruct (env!id0) eqn:E; try discriminate.\ndestruct (complete_members env m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nrewrite PTree.gsspec.\nintros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H0 : env' ! id = Some co) (x : composite) (EQ : composite_of_def env id0 su m a = OK x) (EQ0 : add_composite_definitions (PTree.set id0 x env) l = OK env') : env ! id = Some co \\/\nComposite id0 su m a = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"exploit IHl; eauto.\nunfold composite_of_def in EQ.\ndestruct (env!id0) eqn:E; try discriminate.\ndestruct (complete_members env m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nrewrite PTree.gsspec.\nintros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H0 : env' ! id = Some co) (x : composite) (EQ : composite_of_def env id0 su m a = OK x) (EQ0 : add_composite_definitions (PTree.set id0 x env) l = OK env') : (PTree.set id0 x env) ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l ->\nenv ! id = Some co \\/\nComposite id0 su m a = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"unfold composite_of_def in EQ.\ndestruct (env!id0) eqn:E; try discriminate.\ndestruct (complete_members env m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nrewrite PTree.gsspec.\nintros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H0 : env' ! id = Some co) (x : composite) (EQ : match env ! id0 with\n| Some _ =>\n    Error (MSG \"Multiple definitions of struct or union \" :: CTX id0 :: nil)\n| None =>\n    if complete_members env m\n    then\n     OK\n       {|\n         co_su := su;\n         co_members := m;\n         co_attr := a;\n         co_sizeof :=\n           align (sizeof_composite env su m)\n             (align_attr a (alignof_composite env m));\n         co_alignof := align_attr a (alignof_composite env m);\n         co_rank := rank_members env m;\n         co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n         co_alignof_two_p := composite_of_def_obligation_2 env m a;\n         co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n       |}\n    else Error (MSG \"Incomplete struct or union \" :: CTX id0 :: nil)\nend = OK x) (EQ0 : add_composite_definitions (PTree.set id0 x env) l = OK env') : (PTree.set id0 x env) ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l ->\nenv ! id = Some co \\/\nComposite id0 su m a = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"destruct (env!id0) eqn:E; try discriminate.\ndestruct (complete_members env m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nrewrite PTree.gsspec.\nintros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H0 : env' ! id = Some co) (x : composite) (E : env ! id0 = None) (EQ : (if complete_members env m\n then\n  OK\n    {|\n      co_su := su;\n      co_members := m;\n      co_attr := a;\n      co_sizeof :=\n        align (sizeof_composite env su m)\n          (align_attr a (alignof_composite env m));\n      co_alignof := align_attr a (alignof_composite env m);\n      co_rank := rank_members env m;\n      co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n      co_alignof_two_p := composite_of_def_obligation_2 env m a;\n      co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n    |}\n else Error (MSG \"Incomplete struct or union \" :: CTX id0 :: nil)) = \nOK x) (EQ0 : add_composite_definitions (PTree.set id0 x env) l = OK env') : (PTree.set id0 x env) ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l ->\nenv ! id = Some co \\/\nComposite id0 su m a = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"destruct (complete_members env m) eqn:C; simplify_eq EQ.\nclear EQ; intros EQ.\nrewrite PTree.gsspec.\nintros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H0 : env' ! id = Some co) (x : composite) (E : env ! id0 = None) (C : complete_members env m = true) (EQ : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |} = OK x) (EQ0 : add_composite_definitions (PTree.set id0 x env) l = OK env') : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env su m)\n      (align_attr a (alignof_composite env m));\n  co_alignof := align_attr a (alignof_composite env m);\n  co_rank := rank_members env m;\n  co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n|} = x ->\n(PTree.set id0 x env) ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l ->\nenv ! id = Some co \\/\nComposite id0 su m a = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"clear EQ; intros EQ.\nrewrite PTree.gsspec.\nintros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H0 : env' ! id = Some co) (x : composite) (E : env ! id0 = None) (C : complete_members env m = true) (EQ0 : add_composite_definitions (PTree.set id0 x env) l = OK env') (EQ : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env su m)\n      (align_attr a (alignof_composite env m));\n  co_alignof := align_attr a (alignof_composite env m);\n  co_rank := rank_members env m;\n  co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n|} = x) : (PTree.set id0 x env) ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l ->\nenv ! id = Some co \\/\nComposite id0 su m a = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"rewrite PTree.gsspec.\nintros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H0 : env' ! id = Some co) (x : composite) (E : env ! id0 = None) (C : complete_members env m = true) (EQ0 : add_composite_definitions (PTree.set id0 x env) l = OK env') (EQ : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env su m)\n      (align_attr a (alignof_composite env m));\n  co_alignof := align_attr a (alignof_composite env m);\n  co_rank := rank_members env m;\n  co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n|} = x) : (if peq id id0 then Some x else env ! id) = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l ->\nenv ! id = Some co \\/\nComposite id0 su m a = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"intros [A|A]; auto.\ndestruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H0 : env' ! id = Some co) (x : composite) (E : env ! id0 = None) (C : complete_members env m = true) (EQ0 : add_composite_definitions (PTree.set id0 x env) l = OK env') (EQ : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env su m)\n      (align_attr a (alignof_composite env m));\n  co_alignof := align_attr a (alignof_composite env m);\n  co_rank := rank_members env m;\n  co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n|} = x) (A : (if peq id id0 then Some x else env ! id) = Some co) : env ! id = Some co \\/\nComposite id0 su m a = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"destruct (peq id id0); auto.\ninv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id = Some co ->\nenv1 ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (env env' : composite_env) (H0 : env' ! id = Some co) (x : composite) (E : env ! id0 = None) (C : complete_members env m = true) (EQ0 : add_composite_definitions (PTree.set id0 x env) l = OK env') (EQ : {|\n  co_su := su;\n  co_members := m;\n  co_attr := a;\n  co_sizeof :=\n    align (sizeof_composite env su m)\n      (align_attr a (alignof_composite env m));\n  co_alignof := align_attr a (alignof_composite env m);\n  co_rank := rank_members env m;\n  co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n  co_alignof_two_p := composite_of_def_obligation_2 env m a;\n  co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n|} = x) (e : id = id0) (A : Some x = Some co) : env ! id = Some co \\/\nComposite id0 su m a = Composite id (co_su co) (co_members co) (co_attr co) \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l.","proofString":"inv A.\nrewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id0 : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (env : composite_env) (IHl : forall env1 env'0 : composite_env,\nadd_composite_definitions env1 l = OK env'0 ->\nenv'0 ! id0 =\nSome\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |} ->\nenv1 ! id0 =\nSome\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |} \\/\nIn\n  (Composite id0\n     (co_su\n        {|\n          co_su := su;\n          co_members := m;\n          co_attr := a;\n          co_sizeof :=\n            align (sizeof_composite env su m)\n              (align_attr a (alignof_composite env m));\n          co_alignof := align_attr a (alignof_composite env m);\n          co_rank := rank_members env m;\n          co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n          co_alignof_two_p := composite_of_def_obligation_2 env m a;\n          co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n        |})\n     (co_members\n        {|\n          co_su := su;\n          co_members := m;\n          co_attr := a;\n          co_sizeof :=\n            align (sizeof_composite env su m)\n              (align_attr a (alignof_composite env m));\n          co_alignof := align_attr a (alignof_composite env m);\n          co_rank := rank_members env m;\n          co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n          co_alignof_two_p := composite_of_def_obligation_2 env m a;\n          co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n        |})\n     (co_attr\n        {|\n          co_su := su;\n          co_members := m;\n          co_attr := a;\n          co_sizeof :=\n            align (sizeof_composite env su m)\n              (align_attr a (alignof_composite env m));\n          co_alignof := align_attr a (alignof_composite env m);\n          co_rank := rank_members env m;\n          co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n          co_alignof_two_p := composite_of_def_obligation_2 env m a;\n          co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n        |})) l) (env' : composite_env) (H0 : env' ! id0 =\nSome\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |}) (E : env ! id0 = None) (C : complete_members env m = true) (EQ0 : add_composite_definitions\n  (PTree.set id0\n     {|\n       co_su := su;\n       co_members := m;\n       co_attr := a;\n       co_sizeof :=\n         align (sizeof_composite env su m)\n           (align_attr a (alignof_composite env m));\n       co_alignof := align_attr a (alignof_composite env m);\n       co_rank := rank_members env m;\n       co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n       co_alignof_two_p := composite_of_def_obligation_2 env m a;\n       co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n     |} env) l = OK env') : env ! id0 =\nSome\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |} \\/\nComposite id0 su m a =\nComposite id0\n  (co_su\n     {|\n       co_su := su;\n       co_members := m;\n       co_attr := a;\n       co_sizeof :=\n         align (sizeof_composite env su m)\n           (align_attr a (alignof_composite env m));\n       co_alignof := align_attr a (alignof_composite env m);\n       co_rank := rank_members env m;\n       co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n       co_alignof_two_p := composite_of_def_obligation_2 env m a;\n       co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n     |})\n  (co_members\n     {|\n       co_su := su;\n       co_members := m;\n       co_attr := a;\n       co_sizeof :=\n         align (sizeof_composite env su m)\n           (align_attr a (alignof_composite env m));\n       co_alignof := align_attr a (alignof_composite env m);\n       co_rank := rank_members env m;\n       co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n       co_alignof_two_p := composite_of_def_obligation_2 env m a;\n       co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n     |})\n  (co_attr\n     {|\n       co_su := su;\n       co_members := m;\n       co_attr := a;\n       co_sizeof :=\n         align (sizeof_composite env su m)\n           (align_attr a (alignof_composite env m));\n       co_alignof := align_attr a (alignof_composite env m);\n       co_rank := rank_members env m;\n       co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n       co_alignof_two_p := composite_of_def_obligation_2 env m a;\n       co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n     |}) \\/\nIn\n  (Composite id0\n     (co_su\n        {|\n          co_su := su;\n          co_members := m;\n          co_attr := a;\n          co_sizeof :=\n            align (sizeof_composite env su m)\n              (align_attr a (alignof_composite env m));\n          co_alignof := align_attr a (alignof_composite env m);\n          co_rank := rank_members env m;\n          co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n          co_alignof_two_p := composite_of_def_obligation_2 env m a;\n          co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n        |})\n     (co_members\n        {|\n          co_su := su;\n          co_members := m;\n          co_attr := a;\n          co_sizeof :=\n            align (sizeof_composite env su m)\n              (align_attr a (alignof_composite env m));\n          co_alignof := align_attr a (alignof_composite env m);\n          co_rank := rank_members env m;\n          co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n          co_alignof_two_p := composite_of_def_obligation_2 env m a;\n          co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n        |})\n     (co_attr\n        {|\n          co_su := su;\n          co_members := m;\n          co_attr := a;\n          co_sizeof :=\n            align (sizeof_composite env su m)\n              (align_attr a (alignof_composite env m));\n          co_alignof := align_attr a (alignof_composite env m);\n          co_rank := rank_members env m;\n          co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n          co_alignof_two_p := composite_of_def_obligation_2 env m a;\n          co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n        |})) l.","proofString":"rewrite <- H0; auto."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (REC : forall (l : list composite_definition) (env env' : composite_env),\nadd_composite_definitions env l = OK env' ->\nenv' ! id = Some co ->\nenv ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) : build_composite_env defs0 = OK env0 ->\nenv0 ! id = Some co ->\nIn (Composite id (co_su co) (co_members co) (co_attr co)) defs0.","proofString":"intros.\nexploit REC; eauto.\nrewrite PTree.gempty.\nintuition congruence."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (REC : forall (l : list composite_definition) (env env' : composite_env),\nadd_composite_definitions env l = OK env' ->\nenv' ! id = Some co ->\nenv ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (H : build_composite_env defs0 = OK env0) (H0 : env0 ! id = Some co) : In (Composite id (co_su co) (co_members co) (co_attr co)) defs0.","proofString":"exploit REC; eauto.\nrewrite PTree.gempty.\nintuition congruence."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (REC : forall (l : list composite_definition) (env env' : composite_env),\nadd_composite_definitions env l = OK env' ->\nenv' ! id = Some co ->\nenv ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (H : build_composite_env defs0 = OK env0) (H0 : env0 ! id = Some co) : (PTree.empty composite) ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) defs0 ->\nIn (Composite id (co_su co) (co_members co) (co_attr co)) defs0.","proofString":"rewrite PTree.gempty.\nintuition congruence."},{"statement":"(env0 : composite_env) (defs0 : list composite_definition) (id : positive) (co : composite) (REC : forall (l : list composite_definition) (env env' : composite_env),\nadd_composite_definitions env l = OK env' ->\nenv' ! id = Some co ->\nenv ! id = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) l) (H : build_composite_env defs0 = OK env0) (H0 : env0 ! id = Some co) : None = Some co \\/\nIn (Composite id (co_su co) (co_members co) (co_attr co)) defs0 ->\nIn (Composite id (co_su co) (co_members co) (co_attr co)) defs0.","proofString":"intuition congruence."},{"statement":"(ce : composite_env) (m : member) (H : False) : (rank_type ce (type_member m) <= 0)%nat.","proofString":"tauto."},{"statement":"(ce : composite_env) (m a : member) (ms : list member) (IHms : In m ms -> (rank_type ce (type_member m) <= rank_members ce ms)%nat) (H : a = m \\/ In m ms) : (rank_type ce (type_member m) <=\n match a with\n | Member_plain _ t => Init.Nat.max (rank_type ce t) (rank_members ce ms)\n | Member_bitfield _ _ _ _ _ _ => rank_members ce ms\n end)%nat.","proofString":"destruct a; destruct H; subst; simpl.\nlia.\napply IHms in H.\nlia.\nlia.\napply IHms; auto."},{"statement":"(ce : composite_env) (id : ident) (t : type) (ms : list member) (IHms : In (Member_plain id t) ms ->\n(rank_type ce (type_member (Member_plain id t)) <= rank_members ce ms)%nat) : (rank_type ce t <= Init.Nat.max (rank_type ce t) (rank_members ce ms))%nat.","proofString":"lia."},{"statement":"(ce : composite_env) (m : member) (id : ident) (t : type) (ms : list member) (IHms : In m ms -> (rank_type ce (type_member m) <= rank_members ce ms)%nat) (H : In m ms) : (rank_type ce (type_member m) <=\n Init.Nat.max (rank_type ce t) (rank_members ce ms))%nat.","proofString":"apply IHms in H.\nlia."},{"statement":"(ce : composite_env) (m : member) (id : ident) (t : type) (ms : list member) (IHms : In m ms -> (rank_type ce (type_member m) <= rank_members ce ms)%nat) (H : (rank_type ce (type_member m) <= rank_members ce ms)%nat) : (rank_type ce (type_member m) <=\n Init.Nat.max (rank_type ce t) (rank_members ce ms))%nat.","proofString":"lia."},{"statement":"(ce : composite_env) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ms : list member) (IHms : In (Member_bitfield id sz sg a width padding) ms ->\n(rank_type ce (type_member (Member_bitfield id sz sg a width padding)) <=\n rank_members ce ms)%nat) : (0 <= rank_members ce ms)%nat.","proofString":"lia."},{"statement":"(ce : composite_env) (m : member) (id : ident) (sz : intsize) (sg : signedness) (a : attr) (width : Z) (padding : bool) (ms : list member) (IHms : In m ms -> (rank_type ce (type_member m) <= rank_members ce ms)%nat) (H : In m ms) : (rank_type ce (type_member m) <= rank_members ce ms)%nat.","proofString":"apply IHms; auto."},{"statement":"(ce : composite_env) (id : positive) (a : attr) (co : composite) (m : member) (H : composite_env_consistent ce) (H0 : ce ! id = Some co) (H1 : In m (co_members co)) : (rank_type ce (type_member m) <\n match ce ! id with\n | Some co0 => S (co_rank co0)\n | None => 0\n end)%nat.","proofString":"rewrite H0.\nerewrite co_consistent_rank by eauto.\nexploit (rank_type_members ce); eauto.\nlia."},{"statement":"(ce : composite_env) (id : positive) (a : attr) (co : composite) (m : member) (H : composite_env_consistent ce) (H0 : ce ! id = Some co) (H1 : In m (co_members co)) : (rank_type ce (type_member m) < S (co_rank co))%nat.","proofString":"erewrite co_consistent_rank by eauto.\nexploit (rank_type_members ce); eauto.\nlia."},{"statement":"(ce : composite_env) (id : positive) (a : attr) (co : composite) (m : member) (H : composite_env_consistent ce) (H0 : ce ! id = Some co) (H1 : In m (co_members co)) : (rank_type ce (type_member m) < S (rank_members ce (co_members co)))%nat.","proofString":"exploit (rank_type_members ce); eauto.\nlia."},{"statement":"(ce : composite_env) (id : positive) (a : attr) (co : composite) (m : member) (H : composite_env_consistent ce) (H0 : ce ! id = Some co) (H1 : In m (co_members co)) : (rank_type ce (type_member m) <= rank_members ce (co_members co))%nat ->\n(rank_type ce (type_member m) < S (rank_members ce (co_members co)))%nat.","proofString":"lia."},{"statement":"(ce : composite_env) (id : positive) (a : attr) (co : composite) (m : member) (H : composite_env_consistent ce) (H0 : ce ! id = Some co) (H1 : In m (co_members co)) : (rank_type ce (type_member m) <\n match ce ! id with\n | Some co0 => S (co_rank co0)\n | None => 0\n end)%nat.","proofString":"rewrite H0.\nerewrite co_consistent_rank by eauto.\nexploit (rank_type_members ce); eauto.\nlia."},{"statement":"(ce : composite_env) (id : positive) (a : attr) (co : composite) (m : member) (H : composite_env_consistent ce) (H0 : ce ! id = Some co) (H1 : In m (co_members co)) : (rank_type ce (type_member m) < S (co_rank co))%nat.","proofString":"erewrite co_consistent_rank by eauto.\nexploit (rank_type_members ce); eauto.\nlia."},{"statement":"(ce : composite_env) (id : positive) (a : attr) (co : composite) (m : member) (H : composite_env_consistent ce) (H0 : ce ! id = Some co) (H1 : In m (co_members co)) : (rank_type ce (type_member m) < S (rank_members ce (co_members co)))%nat.","proofString":"exploit (rank_type_members ce); eauto.\nlia."},{"statement":"(ce : composite_env) (id : positive) (a : attr) (co : composite) (m : member) (H : composite_env_consistent ce) (H0 : ce ! id = Some co) (H1 : In m (co_members co)) : (rank_type ce (type_member m) <= rank_members ce (co_members co))%nat ->\n(rank_type ce (type_member m) < S (rank_members ce (co_members co)))%nat.","proofString":"lia."},{"statement":"(l1 l2 l : list composite_definition) (H : (if forallb (check_compat_composite l2) l1\n then Some (l1 ++ filter_redefs l1 l2)\n else None) = Some l) : (forall cd1 cd2 : composite_definition,\n In cd1 l1 ->\n In cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) /\\\nl = l1 ++ filter_redefs l1 l2 /\\\n(forall x : composite_definition, In x l <-> In x l1 \\/ In x l2).","proofString":"destruct (forallb (check_compat_composite l2) l1) eqn:C; inv H.\nassert (A:     forall cd1 cd2, In cd1 l1 -> In cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1).\nrewrite forallb_forall in C.\nintros.\napply C in H.\nunfold check_compat_composite in H.\nrewrite forallb_forall in H.\napply H in H0.\nrewrite H1, dec_eq_true in H0.\nsymmetry; eapply proj_sumbool_true; eauto.\nsplit.\nauto.\nsplit.\nauto.\nunfold filter_redefs; intros.\nrewrite in_app_iff.\nrewrite filter_In.\nintuition auto.\ndestruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.\nexploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) : (forall cd1 cd2 : composite_definition,\n In cd1 l1 ->\n In cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) /\\\nl1 ++ filter_redefs l1 l2 = l1 ++ filter_redefs l1 l2 /\\\n(forall x : composite_definition,\n In x (l1 ++ filter_redefs l1 l2) <-> In x l1 \\/ In x l2).","proofString":"assert (A:     forall cd1 cd2, In cd1 l1 -> In cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1).\nrewrite forallb_forall in C.\nintros.\napply C in H.\nunfold check_compat_composite in H.\nrewrite forallb_forall in H.\napply H in H0.\nrewrite H1, dec_eq_true in H0.\nsymmetry; eapply proj_sumbool_true; eauto.\nsplit.\nauto.\nsplit.\nauto.\nunfold filter_redefs; intros.\nrewrite in_app_iff.\nrewrite filter_In.\nintuition auto.\ndestruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.\nexploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1.","proofString":"rewrite forallb_forall in C.\nintros.\napply C in H.\nunfold check_compat_composite in H.\nrewrite forallb_forall in H.\napply H in H0.\nrewrite H1, dec_eq_true in H0.\nsymmetry; eapply proj_sumbool_true; eauto."},{"statement":"(l1 l2 : list composite_definition) (C : forall x : composite_definition,\nIn x l1 -> check_compat_composite l2 x = true) : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1.","proofString":"intros.\napply C in H.\nunfold check_compat_composite in H.\nrewrite forallb_forall in H.\napply H in H0.\nrewrite H1, dec_eq_true in H0.\nsymmetry; eapply proj_sumbool_true; eauto."},{"statement":"(l1 l2 : list composite_definition) (C : forall x : composite_definition,\nIn x l1 -> check_compat_composite l2 x = true) (cd1 cd2 : composite_definition) (H : In cd1 l1) (H0 : In cd2 l2) (H1 : name_composite_def cd2 = name_composite_def cd1) : cd2 = cd1.","proofString":"apply C in H.\nunfold check_compat_composite in H.\nrewrite forallb_forall in H.\napply H in H0.\nrewrite H1, dec_eq_true in H0.\nsymmetry; eapply proj_sumbool_true; eauto."},{"statement":"(l1 l2 : list composite_definition) (C : forall x : composite_definition,\nIn x l1 -> check_compat_composite l2 x = true) (cd1 cd2 : composite_definition) (H : check_compat_composite l2 cd1 = true) (H0 : In cd2 l2) (H1 : name_composite_def cd2 = name_composite_def cd1) : cd2 = cd1.","proofString":"unfold check_compat_composite in H.\nrewrite forallb_forall in H.\napply H in H0.\nrewrite H1, dec_eq_true in H0.\nsymmetry; eapply proj_sumbool_true; eauto."},{"statement":"(l1 l2 : list composite_definition) (C : forall x : composite_definition,\nIn x l1 -> check_compat_composite l2 x = true) (cd1 cd2 : composite_definition) (H : forallb\n  (fun cd' : composite_definition =>\n   if ident_eq (name_composite_def cd') (name_composite_def cd1)\n   then composite_def_eq cd1 cd'\n   else true) l2 = true) (H0 : In cd2 l2) (H1 : name_composite_def cd2 = name_composite_def cd1) : cd2 = cd1.","proofString":"rewrite forallb_forall in H.\napply H in H0.\nrewrite H1, dec_eq_true in H0.\nsymmetry; eapply proj_sumbool_true; eauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : (forall cd1 cd2 : composite_definition,\n In cd1 l1 ->\n In cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) /\\\nl1 ++ filter_redefs l1 l2 = l1 ++ filter_redefs l1 l2 /\\\n(forall x : composite_definition,\n In x (l1 ++ filter_redefs l1 l2) <-> In x l1 \\/ In x l2).","proofString":"split.\nauto.\nsplit.\nauto.\nunfold filter_redefs; intros.\nrewrite in_app_iff.\nrewrite filter_In.\nintuition auto.\ndestruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.\nexploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1.","proofString":"auto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : l1 ++ filter_redefs l1 l2 = l1 ++ filter_redefs l1 l2 /\\\n(forall x : composite_definition,\n In x (l1 ++ filter_redefs l1 l2) <-> In x l1 \\/ In x l2).","proofString":"split.\nauto.\nunfold filter_redefs; intros.\nrewrite in_app_iff.\nrewrite filter_In.\nintuition auto.\ndestruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.\nexploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : l1 ++ filter_redefs l1 l2 = l1 ++ filter_redefs l1 l2.","proofString":"auto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : forall x : composite_definition,\nIn x (l1 ++ filter_redefs l1 l2) <-> In x l1 \\/ In x l2.","proofString":"unfold filter_redefs; intros.\nrewrite in_app_iff.\nrewrite filter_In.\nintuition auto.\ndestruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.\nexploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (x : composite_definition) : In x\n  (l1 ++\n   filter\n     (fun cd : composite_definition =>\n      negb\n        (in_dec ident_eq (name_composite_def cd) (map name_composite_def l1)))\n     l2) <-> In x l1 \\/ In x l2.","proofString":"rewrite in_app_iff.\nrewrite filter_In.\nintuition auto.\ndestruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.\nexploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (x : composite_definition) : In x l1 \\/\nIn x\n  (filter\n     (fun cd : composite_definition =>\n      negb\n        (in_dec ident_eq (name_composite_def cd) (map name_composite_def l1)))\n     l2) <-> In x l1 \\/ In x l2.","proofString":"rewrite filter_In.\nintuition auto.\ndestruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.\nexploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (x : composite_definition) : In x l1 \\/\nIn x l2 /\\\nnegb (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)) =\ntrue <-> In x l1 \\/ In x l2.","proofString":"intuition auto.\ndestruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.\nexploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (x : composite_definition) (H0 : In x l2) : In x l1 \\/\nIn x l2 /\\\nnegb (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)) =\ntrue.","proofString":"destruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.\nexploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (x : composite_definition) (H0 : In x l2) (i : In (name_composite_def x) (map name_composite_def l1)) : In x l1 \\/ In x l2 /\\ false = true.","proofString":"exploit list_in_map_inv; eauto.\nintros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (x : composite_definition) (H0 : In x l2) (i : In (name_composite_def x) (map name_composite_def l1)) : (exists x0 : composite_definition,\n   name_composite_def x = name_composite_def x0 /\\ In x0 l1) ->\nIn x l1 \\/ In x l2 /\\ false = true.","proofString":"intros (y & P & Q).\nassert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (x : composite_definition) (H0 : In x l2) (i : In (name_composite_def x) (map name_composite_def l1)) (y : composite_definition) (P : name_composite_def x = name_composite_def y) (Q : In y l1) : In x l1 \\/ In x l2 /\\ false = true.","proofString":"assert (x = y) by eauto.\nsubst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (x : composite_definition) (H0 : In x l2) (i : In (name_composite_def x) (map name_composite_def l1)) (y : composite_definition) (P : name_composite_def x = name_composite_def y) (Q : In y l1) (H : x = y) : In x l1 \\/ In x l2 /\\ false = true.","proofString":"subst y.\nauto."},{"statement":"(l1 l2 : list composite_definition) (C : forallb (check_compat_composite l2) l1 = true) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (x : composite_definition) (H0 : In x l2) (i : In (name_composite_def x) (map name_composite_def l1)) (Q : In x l1) (P : name_composite_def x = name_composite_def x) : In x l1 \\/ In x l2 /\\ false = true.","proofString":"auto."},{"statement":"(l2 : list composite_definition) (env env'' : composite_env) : add_composite_definitions env l2 = OK env'' <->\n(exists env' : composite_env,\n   OK env = OK env' /\\ add_composite_definitions env' l2 = OK env'').","proofString":"split; intros.\nexists env; auto.\ndestruct H as (env' & A & B).\ncongruence."},{"statement":"(l2 : list composite_definition) (env env'' : composite_env) (H : add_composite_definitions env l2 = OK env'') : exists env' : composite_env,\n  OK env = OK env' /\\ add_composite_definitions env' l2 = OK env''.","proofString":"exists env; auto."},{"statement":"(l2 : list composite_definition) (env env'' : composite_env) (H : exists env' : composite_env,\n  OK env = OK env' /\\ add_composite_definitions env' l2 = OK env'') : add_composite_definitions env l2 = OK env''.","proofString":"destruct H as (env' & A & B).\ncongruence."},{"statement":"(l2 : list composite_definition) (env env'' env' : composite_env) (A : OK env = OK env') (B : add_composite_definitions env' l2 = OK env'') : add_composite_definitions env l2 = OK env''.","proofString":"congruence."},{"statement":"(a : composite_definition) (l1 : list composite_definition) (IHl1 : forall (l0 : list composite_definition) (env0 env''0 : composite_env),\nadd_composite_definitions env0 (l1 ++ l0) = OK env''0 <->\n(exists env' : composite_env,\n   add_composite_definitions env0 l1 = OK env' /\\\n   add_composite_definitions env' l0 = OK env''0)) (l2 : list composite_definition) (env env'' : composite_env) : match a with\n| Composite id su m a0 =>\n    do co <- composite_of_def env id su m a0;\n    add_composite_definitions (PTree.set id co env) (l1 ++ l2)\nend = OK env'' <->\n(exists env' : composite_env,\n   match a with\n   | Composite id su m a0 =>\n       do co <- composite_of_def env id su m a0;\n       add_composite_definitions (PTree.set id co env) l1\n   end = OK env' /\\ add_composite_definitions env' l2 = OK env'').","proofString":"destruct a; simpl.\ndestruct (composite_of_def env id su m a); simpl.\napply IHl1.\nsplit; intros.\ndiscriminate.\ndestruct H as (env' & A & B); discriminate."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (l1 : list composite_definition) (IHl1 : forall (l0 : list composite_definition) (env0 env''0 : composite_env),\nadd_composite_definitions env0 (l1 ++ l0) = OK env''0 <->\n(exists env' : composite_env,\n   add_composite_definitions env0 l1 = OK env' /\\\n   add_composite_definitions env' l0 = OK env''0)) (l2 : list composite_definition) (env env'' : composite_env) : (do co <- composite_of_def env id su m a;\n add_composite_definitions (PTree.set id co env) (l1 ++ l2)) = \nOK env'' <->\n(exists env' : composite_env,\n   (do co <- composite_of_def env id su m a;\n    add_composite_definitions (PTree.set id co env) l1) = \n   OK env' /\\ add_composite_definitions env' l2 = OK env'').","proofString":"destruct (composite_of_def env id su m a); simpl.\napply IHl1.\nsplit; intros.\ndiscriminate.\ndestruct H as (env' & A & B); discriminate."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (l1 : list composite_definition) (IHl1 : forall (l0 : list composite_definition) (env0 env''0 : composite_env),\nadd_composite_definitions env0 (l1 ++ l0) = OK env''0 <->\n(exists env' : composite_env,\n   add_composite_definitions env0 l1 = OK env' /\\\n   add_composite_definitions env' l0 = OK env''0)) (l2 : list composite_definition) (env env'' : composite_env) (c : composite) : add_composite_definitions (PTree.set id c env) (l1 ++ l2) = OK env'' <->\n(exists env' : composite_env,\n   add_composite_definitions (PTree.set id c env) l1 = OK env' /\\\n   add_composite_definitions env' l2 = OK env'').","proofString":"apply IHl1."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (l1 : list composite_definition) (IHl1 : forall (l0 : list composite_definition) (env0 env''0 : composite_env),\nadd_composite_definitions env0 (l1 ++ l0) = OK env''0 <->\n(exists env' : composite_env,\n   add_composite_definitions env0 l1 = OK env' /\\\n   add_composite_definitions env' l0 = OK env''0)) (l2 : list composite_definition) (env env'' : composite_env) (e : errmsg) : Error e = OK env'' <->\n(exists env' : composite_env,\n   Error e = OK env' /\\ add_composite_definitions env' l2 = OK env'').","proofString":"split; intros.\ndiscriminate.\ndestruct H as (env' & A & B); discriminate."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (l1 : list composite_definition) (IHl1 : forall (l0 : list composite_definition) (env0 env''0 : composite_env),\nadd_composite_definitions env0 (l1 ++ l0) = OK env''0 <->\n(exists env' : composite_env,\n   add_composite_definitions env0 l1 = OK env' /\\\n   add_composite_definitions env' l0 = OK env''0)) (l2 : list composite_definition) (env env'' : composite_env) (e : errmsg) (H : Error e = OK env'') : exists env' : composite_env,\n  Error e = OK env' /\\ add_composite_definitions env' l2 = OK env''.","proofString":"discriminate."},{"statement":"(id : ident) (su : struct_or_union) (m : members) (a : attr) (l1 : list composite_definition) (IHl1 : forall (l0 : list composite_definition) (env0 env''0 : composite_env),\nadd_composite_definitions env0 (l1 ++ l0) = OK env''0 <->\n(exists env' : composite_env,\n   add_composite_definitions env0 l1 = OK env' /\\\n   add_composite_definitions env' l0 = OK env''0)) (l2 : list composite_definition) (env env'' : composite_env) (e : errmsg) (H : exists env' : composite_env,\n  Error e = OK env' /\\ add_composite_definitions env' l2 = OK env'') : Error e = OK env''.","proofString":"destruct H as (env' & A & B); discriminate."},{"statement":"(su1 : struct_or_union) (m1 : members) (a1 : attr) (sz1 al1 : Z) (r1 : nat) (pos1 : sz1 >= 0) (al2p1 : exists n : nat, al1 = two_power_nat n) (szal1 : (al1 | sz1)) (su2 : struct_or_union) (m2 : members) (a2 : attr) (sz2 al2 : Z) (r2 : nat) (pos2 : sz2 >= 0) (al2p2 : exists n : nat, al2 = two_power_nat n) (szal2 : (al2 | sz2)) (H : su1 = su2) (H0 : m1 = m2) (H1 : a1 = a2) (H2 : sz1 = sz2) (H3 : al1 = al2) (H4 : r1 = r2) : {|\n  co_su := su1;\n  co_members := m1;\n  co_attr := a1;\n  co_sizeof := sz1;\n  co_alignof := al1;\n  co_rank := r1;\n  co_sizeof_pos := pos1;\n  co_alignof_two_p := al2p1;\n  co_sizeof_alignof := szal1\n|} =\n{|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos2;\n  co_alignof_two_p := al2p2;\n  co_sizeof_alignof := szal2\n|}.","proofString":"subst.\nassert (pos1 = pos2) by apply proof_irr.\nassert (al2p1 = al2p2) by apply proof_irr.\nassert (szal1 = szal2) by apply proof_irr.\nsubst.\nreflexivity."},{"statement":"(sz2 : Z) (pos1 : sz2 >= 0) (al2 : Z) (szal1 : (al2 | sz2)) (al2p1 : exists n : nat, al2 = two_power_nat n) (su2 : struct_or_union) (m2 : members) (a2 : attr) (r2 : nat) (pos2 : sz2 >= 0) (al2p2 : exists n : nat, al2 = two_power_nat n) (szal2 : (al2 | sz2)) : {|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos1;\n  co_alignof_two_p := al2p1;\n  co_sizeof_alignof := szal1\n|} =\n{|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos2;\n  co_alignof_two_p := al2p2;\n  co_sizeof_alignof := szal2\n|}.","proofString":"assert (pos1 = pos2) by apply proof_irr.\nassert (al2p1 = al2p2) by apply proof_irr.\nassert (szal1 = szal2) by apply proof_irr.\nsubst.\nreflexivity."},{"statement":"(sz2 : Z) (pos1 : sz2 >= 0) (al2 : Z) (szal1 : (al2 | sz2)) (al2p1 : exists n : nat, al2 = two_power_nat n) (su2 : struct_or_union) (m2 : members) (a2 : attr) (r2 : nat) (pos2 : sz2 >= 0) (al2p2 : exists n : nat, al2 = two_power_nat n) (szal2 : (al2 | sz2)) (H : pos1 = pos2) : {|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos1;\n  co_alignof_two_p := al2p1;\n  co_sizeof_alignof := szal1\n|} =\n{|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos2;\n  co_alignof_two_p := al2p2;\n  co_sizeof_alignof := szal2\n|}.","proofString":"assert (al2p1 = al2p2) by apply proof_irr.\nassert (szal1 = szal2) by apply proof_irr.\nsubst.\nreflexivity."},{"statement":"(sz2 : Z) (pos1 : sz2 >= 0) (al2 : Z) (szal1 : (al2 | sz2)) (al2p1 : exists n : nat, al2 = two_power_nat n) (su2 : struct_or_union) (m2 : members) (a2 : attr) (r2 : nat) (pos2 : sz2 >= 0) (al2p2 : exists n : nat, al2 = two_power_nat n) (szal2 : (al2 | sz2)) (H : pos1 = pos2) (H0 : al2p1 = al2p2) : {|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos1;\n  co_alignof_two_p := al2p1;\n  co_sizeof_alignof := szal1\n|} =\n{|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos2;\n  co_alignof_two_p := al2p2;\n  co_sizeof_alignof := szal2\n|}.","proofString":"assert (szal1 = szal2) by apply proof_irr.\nsubst.\nreflexivity."},{"statement":"(sz2 : Z) (pos1 : sz2 >= 0) (al2 : Z) (szal1 : (al2 | sz2)) (al2p1 : exists n : nat, al2 = two_power_nat n) (su2 : struct_or_union) (m2 : members) (a2 : attr) (r2 : nat) (pos2 : sz2 >= 0) (al2p2 : exists n : nat, al2 = two_power_nat n) (szal2 : (al2 | sz2)) (H : pos1 = pos2) (H0 : al2p1 = al2p2) (H1 : szal1 = szal2) : {|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos1;\n  co_alignof_two_p := al2p1;\n  co_sizeof_alignof := szal1\n|} =\n{|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos2;\n  co_alignof_two_p := al2p2;\n  co_sizeof_alignof := szal2\n|}.","proofString":"subst.\nreflexivity."},{"statement":"(sz2 al2 : Z) (su2 : struct_or_union) (m2 : members) (a2 : attr) (r2 : nat) (pos2 : sz2 >= 0) (al2p2 : exists n : nat, al2 = two_power_nat n) (szal2 : (al2 | sz2)) : {|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos2;\n  co_alignof_two_p := al2p2;\n  co_sizeof_alignof := szal2\n|} =\n{|\n  co_su := su2;\n  co_members := m2;\n  co_attr := a2;\n  co_sizeof := sz2;\n  co_alignof := al2;\n  co_rank := r2;\n  co_sizeof_pos := pos2;\n  co_alignof_two_p := al2p2;\n  co_sizeof_alignof := szal2\n|}.","proofString":"reflexivity."},{"statement":"(env : composite_env) (id : positive) (co : composite) (H : composite_consistent env co) (H0 : env ! id = None) : composite_of_def env id (co_su co) (co_members co) (co_attr co) = OK co.","proofString":"destruct H as [A B C D].\nunfold composite_of_def.\nrewrite H0, A.\ndestruct co; simpl in *.\nf_equal.\napply composite_eq; auto.\nrewrite C, B; auto."},{"statement":"(env : composite_env) (id : positive) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) (H0 : env ! id = None) : composite_of_def env id (co_su co) (co_members co) (co_attr co) = OK co.","proofString":"unfold composite_of_def.\nrewrite H0, A.\ndestruct co; simpl in *.\nf_equal.\napply composite_eq; auto.\nrewrite C, B; auto."},{"statement":"(env : composite_env) (id : positive) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) (H0 : env ! id = None) : match env ! id with\n| Some _ =>\n    Error (MSG \"Multiple definitions of struct or union \" :: CTX id :: nil)\n| None =>\n    if complete_members env (co_members co)\n    then\n     OK\n       {|\n         co_su := co_su co;\n         co_members := co_members co;\n         co_attr := co_attr co;\n         co_sizeof :=\n           align (sizeof_composite env (co_su co) (co_members co))\n             (align_attr (co_attr co) (alignof_composite env (co_members co)));\n         co_alignof :=\n           align_attr (co_attr co) (alignof_composite env (co_members co));\n         co_rank := rank_members env (co_members co);\n         co_sizeof_pos :=\n           composite_of_def_obligation_1 env (co_su co) \n             (co_members co) (co_attr co);\n         co_alignof_two_p :=\n           composite_of_def_obligation_2 env (co_members co) (co_attr co);\n         co_sizeof_alignof :=\n           composite_of_def_obligation_3 env (co_su co) \n             (co_members co) (co_attr co)\n       |}\n    else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)\nend = OK co.","proofString":"rewrite H0, A.\ndestruct co; simpl in *.\nf_equal.\napply composite_eq; auto.\nrewrite C, B; auto."},{"statement":"(env : composite_env) (id : positive) (co : composite) (A : complete_members env (co_members co) = true) (B : co_alignof co =\nalign_attr (co_attr co) (alignof_composite env (co_members co))) (C : co_sizeof co =\nalign (sizeof_composite env (co_su co) (co_members co)) (co_alignof co)) (D : co_rank co = rank_members env (co_members co)) (H0 : env ! id = None) : OK\n  {|\n    co_su := co_su co;\n    co_members := co_members co;\n    co_attr := co_attr co;\n    co_sizeof :=\n      align (sizeof_composite env (co_su co) (co_members co))\n        (align_attr (co_attr co) (alignof_composite env (co_members co)));\n    co_alignof :=\n      align_attr (co_attr co) (alignof_composite env (co_members co));\n    co_rank := rank_members env (co_members co);\n    co_sizeof_pos :=\n      composite_of_def_obligation_1 env (co_su co) \n        (co_members co) (co_attr co);\n    co_alignof_two_p :=\n      composite_of_def_obligation_2 env (co_members co) (co_attr co);\n    co_sizeof_alignof :=\n      composite_of_def_obligation_3 env (co_su co) \n        (co_members co) (co_attr co)\n  |} = OK co.","proofString":"destruct co; simpl in *.\nf_equal.\napply composite_eq; auto.\nrewrite C, B; auto."},{"statement":"(env : composite_env) (id : positive) (co_su0 : struct_or_union) (co_members0 : members) (co_attr0 : attr) (co_sizeof0 co_alignof0 : Z) (co_rank0 : nat) (co_sizeof_pos0 : co_sizeof0 >= 0) (co_alignof_two_p0 : exists n : nat, co_alignof0 = two_power_nat n) (co_sizeof_alignof0 : (co_alignof0 | co_sizeof0)) (A : complete_members env co_members0 = true) (B : co_alignof0 = align_attr co_attr0 (alignof_composite env co_members0)) (C : co_sizeof0 = align (sizeof_composite env co_su0 co_members0) co_alignof0) (D : co_rank0 = rank_members env co_members0) (H0 : env ! id = None) : OK\n  {|\n    co_su := co_su0;\n    co_members := co_members0;\n    co_attr := co_attr0;\n    co_sizeof :=\n      align (sizeof_composite env co_su0 co_members0)\n        (align_attr co_attr0 (alignof_composite env co_members0));\n    co_alignof := align_attr co_attr0 (alignof_composite env co_members0);\n    co_rank := rank_members env co_members0;\n    co_sizeof_pos :=\n      composite_of_def_obligation_1 env co_su0 co_members0 co_attr0;\n    co_alignof_two_p :=\n      composite_of_def_obligation_2 env co_members0 co_attr0;\n    co_sizeof_alignof :=\n      composite_of_def_obligation_3 env co_su0 co_members0 co_attr0\n  |} =\nOK\n  {|\n    co_su := co_su0;\n    co_members := co_members0;\n    co_attr := co_attr0;\n    co_sizeof := co_sizeof0;\n    co_alignof := co_alignof0;\n    co_rank := co_rank0;\n    co_sizeof_pos := co_sizeof_pos0;\n    co_alignof_two_p := co_alignof_two_p0;\n    co_sizeof_alignof := co_sizeof_alignof0\n  |}.","proofString":"f_equal.\napply composite_eq; auto.\nrewrite C, B; auto."},{"statement":"(env : composite_env) (id : positive) (co_su0 : struct_or_union) (co_members0 : members) (co_attr0 : attr) (co_sizeof0 co_alignof0 : Z) (co_rank0 : nat) (co_sizeof_pos0 : co_sizeof0 >= 0) (co_alignof_two_p0 : exists n : nat, co_alignof0 = two_power_nat n) (co_sizeof_alignof0 : (co_alignof0 | co_sizeof0)) (A : complete_members env co_members0 = true) (B : co_alignof0 = align_attr co_attr0 (alignof_composite env co_members0)) (C : co_sizeof0 = align (sizeof_composite env co_su0 co_members0) co_alignof0) (D : co_rank0 = rank_members env co_members0) (H0 : env ! id = None) : {|\n  co_su := co_su0;\n  co_members := co_members0;\n  co_attr := co_attr0;\n  co_sizeof :=\n    align (sizeof_composite env co_su0 co_members0)\n      (align_attr co_attr0 (alignof_composite env co_members0));\n  co_alignof := align_attr co_attr0 (alignof_composite env co_members0);\n  co_rank := rank_members env co_members0;\n  co_sizeof_pos :=\n    composite_of_def_obligation_1 env co_su0 co_members0 co_attr0;\n  co_alignof_two_p := composite_of_def_obligation_2 env co_members0 co_attr0;\n  co_sizeof_alignof :=\n    composite_of_def_obligation_3 env co_su0 co_members0 co_attr0\n|} =\n{|\n  co_su := co_su0;\n  co_members := co_members0;\n  co_attr := co_attr0;\n  co_sizeof := co_sizeof0;\n  co_alignof := co_alignof0;\n  co_rank := co_rank0;\n  co_sizeof_pos := co_sizeof_pos0;\n  co_alignof_two_p := co_alignof_two_p0;\n  co_sizeof_alignof := co_sizeof_alignof0\n|}.","proofString":"apply composite_eq; auto.\nrewrite C, B; auto."},{"statement":"(env : composite_env) (id : positive) (co_su0 : struct_or_union) (co_members0 : members) (co_attr0 : attr) (co_sizeof0 co_alignof0 : Z) (co_rank0 : nat) (co_sizeof_pos0 : co_sizeof0 >= 0) (co_alignof_two_p0 : exists n : nat, co_alignof0 = two_power_nat n) (co_sizeof_alignof0 : (co_alignof0 | co_sizeof0)) (A : complete_members env co_members0 = true) (B : co_alignof0 = align_attr co_attr0 (alignof_composite env co_members0)) (C : co_sizeof0 = align (sizeof_composite env co_su0 co_members0) co_alignof0) (D : co_rank0 = rank_members env co_members0) (H0 : env ! id = None) : align (sizeof_composite env co_su0 co_members0)\n  (align_attr co_attr0 (alignof_composite env co_members0)) = co_sizeof0.","proofString":"rewrite C, B; auto."},{"statement":"(env : composite_env) (co1 co2 : composite) (H : composite_consistent env co1) (H0 : composite_consistent env co2) (H1 : co_su co1 = co_su co2) (H2 : co_members co1 = co_members co2) (H3 : co_attr co1 = co_attr co2) : co1 = co2.","proofString":"destruct H, H0.\ndestruct co1, co2; simpl in *.\napply composite_eq; congruence."},{"statement":"(env : composite_env) (co1 co2 : composite) (co_consistent_complete0 : complete_members env (co_members co1) = true) (co_consistent_alignof0 : co_alignof co1 =\nalign_attr (co_attr co1) (alignof_composite env (co_members co1))) (co_consistent_sizeof0 : co_sizeof co1 =\nalign (sizeof_composite env (co_su co1) (co_members co1)) (co_alignof co1)) (co_consistent_rank0 : co_rank co1 = rank_members env (co_members co1)) (co_consistent_complete1 : complete_members env (co_members co2) = true) (co_consistent_alignof1 : co_alignof co2 =\nalign_attr (co_attr co2) (alignof_composite env (co_members co2))) (co_consistent_sizeof1 : co_sizeof co2 =\nalign (sizeof_composite env (co_su co2) (co_members co2)) (co_alignof co2)) (co_consistent_rank1 : co_rank co2 = rank_members env (co_members co2)) (H1 : co_su co1 = co_su co2) (H2 : co_members co1 = co_members co2) (H3 : co_attr co1 = co_attr co2) : co1 = co2.","proofString":"destruct co1, co2; simpl in *.\napply composite_eq; congruence."},{"statement":"(env : composite_env) (co_su0 : struct_or_union) (co_members0 : members) (co_attr0 : attr) (co_sizeof0 co_alignof0 : Z) (co_rank0 : nat) (co_sizeof_pos0 : co_sizeof0 >= 0) (co_alignof_two_p0 : exists n : nat, co_alignof0 = two_power_nat n) (co_sizeof_alignof0 : (co_alignof0 | co_sizeof0)) (co_su1 : struct_or_union) (co_members1 : members) (co_attr1 : attr) (co_sizeof1 co_alignof1 : Z) (co_rank1 : nat) (co_sizeof_pos1 : co_sizeof1 >= 0) (co_alignof_two_p1 : exists n : nat, co_alignof1 = two_power_nat n) (co_sizeof_alignof1 : (co_alignof1 | co_sizeof1)) (co_consistent_complete0 : complete_members env co_members0 = true) (co_consistent_alignof0 : co_alignof0 = align_attr co_attr0 (alignof_composite env co_members0)) (co_consistent_sizeof0 : co_sizeof0 = align (sizeof_composite env co_su0 co_members0) co_alignof0) (co_consistent_rank0 : co_rank0 = rank_members env co_members0) (co_consistent_complete1 : complete_members env co_members1 = true) (co_consistent_alignof1 : co_alignof1 = align_attr co_attr1 (alignof_composite env co_members1)) (co_consistent_sizeof1 : co_sizeof1 = align (sizeof_composite env co_su1 co_members1) co_alignof1) (co_consistent_rank1 : co_rank1 = rank_members env co_members1) (H1 : co_su0 = co_su1) (H2 : co_members0 = co_members1) (H3 : co_attr0 = co_attr1) : {|\n  co_su := co_su0;\n  co_members := co_members0;\n  co_attr := co_attr0;\n  co_sizeof := co_sizeof0;\n  co_alignof := co_alignof0;\n  co_rank := co_rank0;\n  co_sizeof_pos := co_sizeof_pos0;\n  co_alignof_two_p := co_alignof_two_p0;\n  co_sizeof_alignof := co_sizeof_alignof0\n|} =\n{|\n  co_su := co_su1;\n  co_members := co_members1;\n  co_attr := co_attr1;\n  co_sizeof := co_sizeof1;\n  co_alignof := co_alignof1;\n  co_rank := co_rank1;\n  co_sizeof_pos := co_sizeof_pos1;\n  co_alignof_two_p := co_alignof_two_p1;\n  co_sizeof_alignof := co_sizeof_alignof1\n|}.","proofString":"apply composite_eq; congruence."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id0 : positive) (co0 : composite),\nenv ! id0 = Some co0 -> env' ! id0 = Some co0) (id : positive) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : env' ! id = None) (H0 : composite_of_def env id su m a = OK co) : composite_of_def env' id su m a = OK co.","proofString":"unfold composite_of_def in H0.\ndestruct (env!id) eqn:E; try discriminate.\ndestruct (complete_members env m) eqn:CM; try discriminate.\ntransitivity (composite_of_def env' id (co_su co) (co_members co) (co_attr co)).\ninv H0; auto.\napply composite_of_def_eq; auto.\napply composite_consistent_stable with env; auto.\ninv H0; constructor; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id0 : positive) (co0 : composite),\nenv ! id0 = Some co0 -> env' ! id0 = Some co0) (id : positive) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : env' ! id = None) (H0 : match env ! id with\n| Some _ =>\n    Error (MSG \"Multiple definitions of struct or union \" :: CTX id :: nil)\n| None =>\n    if complete_members env m\n    then\n     OK\n       {|\n         co_su := su;\n         co_members := m;\n         co_attr := a;\n         co_sizeof :=\n           align (sizeof_composite env su m)\n             (align_attr a (alignof_composite env m));\n         co_alignof := align_attr a (alignof_composite env m);\n         co_rank := rank_members env m;\n         co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n         co_alignof_two_p := composite_of_def_obligation_2 env m a;\n         co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n       |}\n    else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)\nend = OK co) : composite_of_def env' id su m a = OK co.","proofString":"destruct (env!id) eqn:E; try discriminate.\ndestruct (complete_members env m) eqn:CM; try discriminate.\ntransitivity (composite_of_def env' id (co_su co) (co_members co) (co_attr co)).\ninv H0; auto.\napply composite_of_def_eq; auto.\napply composite_consistent_stable with env; auto.\ninv H0; constructor; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id0 : positive) (co0 : composite),\nenv ! id0 = Some co0 -> env' ! id0 = Some co0) (id : positive) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : env' ! id = None) (E : env ! id = None) (H0 : (if complete_members env m\n then\n  OK\n    {|\n      co_su := su;\n      co_members := m;\n      co_attr := a;\n      co_sizeof :=\n        align (sizeof_composite env su m)\n          (align_attr a (alignof_composite env m));\n      co_alignof := align_attr a (alignof_composite env m);\n      co_rank := rank_members env m;\n      co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n      co_alignof_two_p := composite_of_def_obligation_2 env m a;\n      co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n    |}\n else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)) = \nOK co) : composite_of_def env' id su m a = OK co.","proofString":"destruct (complete_members env m) eqn:CM; try discriminate.\ntransitivity (composite_of_def env' id (co_su co) (co_members co) (co_attr co)).\ninv H0; auto.\napply composite_of_def_eq; auto.\napply composite_consistent_stable with env; auto.\ninv H0; constructor; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id0 : positive) (co0 : composite),\nenv ! id0 = Some co0 -> env' ! id0 = Some co0) (id : positive) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : env' ! id = None) (E : env ! id = None) (CM : complete_members env m = true) (H0 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |} = OK co) : composite_of_def env' id su m a = OK co.","proofString":"transitivity (composite_of_def env' id (co_su co) (co_members co) (co_attr co)).\ninv H0; auto.\napply composite_of_def_eq; auto.\napply composite_consistent_stable with env; auto.\ninv H0; constructor; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id0 : positive) (co0 : composite),\nenv ! id0 = Some co0 -> env' ! id0 = Some co0) (id : positive) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : env' ! id = None) (E : env ! id = None) (CM : complete_members env m = true) (H0 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |} = OK co) : composite_of_def env' id su m a =\ncomposite_of_def env' id (co_su co) (co_members co) (co_attr co).","proofString":"inv H0; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id0 : positive) (co0 : composite),\nenv ! id0 = Some co0 -> env' ! id0 = Some co0) (id : positive) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : env' ! id = None) (E : env ! id = None) (CM : complete_members env m = true) (H0 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |} = OK co) : composite_of_def env' id (co_su co) (co_members co) (co_attr co) = OK co.","proofString":"apply composite_of_def_eq; auto.\napply composite_consistent_stable with env; auto.\ninv H0; constructor; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id0 : positive) (co0 : composite),\nenv ! id0 = Some co0 -> env' ! id0 = Some co0) (id : positive) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : env' ! id = None) (E : env ! id = None) (CM : complete_members env m = true) (H0 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |} = OK co) : composite_consistent env' co.","proofString":"apply composite_consistent_stable with env; auto.\ninv H0; constructor; auto."},{"statement":"(env env' : composite_env) (EXTENDS : forall (id0 : positive) (co0 : composite),\nenv ! id0 = Some co0 -> env' ! id0 = Some co0) (id : positive) (su : struct_or_union) (m : members) (a : attr) (co : composite) (H : env' ! id = None) (E : env ! id = None) (CM : complete_members env m = true) (H0 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env su m)\n        (align_attr a (alignof_composite env m));\n    co_alignof := align_attr a (alignof_composite env m);\n    co_rank := rank_members env m;\n    co_sizeof_pos := composite_of_def_obligation_1 env su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env su m a\n  |} = OK co) : composite_consistent env co.","proofString":"inv H0; constructor; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (env1 env1' : composite_env) (env2 : PTree.tree composite) (ACD : OK env1 = OK env1') (AGREE1 : forall (id : positive) (co : composite),\nenv1 ! id = Some co -> env2 ! id = Some co) (AGREE0 : forall (id : positive) (co : composite),\nenv0 ! id = Some co -> env2 ! id = Some co) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nFalse -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : {env2' : composite_env\n| OK env2 = OK env2' /\\\n  (forall (id : positive) (co : composite),\n   env1' ! id = Some co -> env2' ! id = Some co) /\\\n  (forall (id : positive) (co : composite),\n   env0 ! id = Some co -> env2' ! id = Some co)}.","proofString":"inv ACD.\nexists env2; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (env1' : composite_env) (env2 : PTree.tree composite) (AGREE1 : forall (id : positive) (co : composite),\nenv1' ! id = Some co -> env2 ! id = Some co) (AGREE0 : forall (id : positive) (co : composite),\nenv0 ! id = Some co -> env2 ! id = Some co) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1' ! id)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nFalse -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : {env2' : composite_env\n| OK env2 = OK env2' /\\\n  (forall (id : positive) (co : composite),\n   env1' ! id = Some co -> env2' ! id = Some co) /\\\n  (forall (id : positive) (co : composite),\n   env0 ! id = Some co -> env2' ! id = Some co)}.","proofString":"exists env2; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (a : composite_definition) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co : composite),\n env3 ! id = Some co -> env4 ! id = Some co) ->\n(forall (id : positive) (co : composite),\n env0 ! id = Some co -> env4 ! id = Some co) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co : composite),\n   env1'0 ! id = Some co -> env2' ! id = Some co) /\\\n  (forall (id : positive) (co : composite),\n   env0 ! id = Some co -> env2' ! id = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (ACD : match a with\n| Composite id su m a0 =>\n    do co <- composite_of_def env1 id su m a0;\n    add_composite_definitions (PTree.set id co env1) l\nend = OK env1') (AGREE1 : forall (id : positive) (co : composite),\nenv1 ! id = Some co -> env2 ! id = Some co) (AGREE0 : forall (id : positive) (co : composite),\nenv0 ! id = Some co -> env2 ! id = Some co) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\na = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : {env2' : composite_env\n| add_composite_definitions env2\n    (if\n      negb\n        (in_dec ident_eq (name_composite_def a) (map name_composite_def l0))\n     then a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co : composite),\n   env1' ! id = Some co -> env2' ! id = Some co) /\\\n  (forall (id : positive) (co : composite),\n   env0 ! id = Some co -> env2' ! id = Some co)}.","proofString":"destruct a.\ndestruct (composite_of_def env1 id su m a) as [x|e] eqn:EQ; try discriminate.\nsimpl in ACD.\ngeneralize EQ.\nunfold composite_of_def at 1.\ndestruct (env1!id) eqn:E1; try congruence.\ndestruct (complete_members env1 m) eqn:CM1; try congruence.\nintros EQ1.\nsimpl.\ndestruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (ACD : (do co <- composite_of_def env1 id su m a;\n add_composite_definitions (PTree.set id co env1) l) = \nOK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : {env2' : composite_env\n| add_composite_definitions env2\n    (if\n      negb\n        (in_dec ident_eq (name_composite_def (Composite id su m a))\n           (map name_composite_def l0))\n     then Composite id su m a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"destruct (composite_of_def env1 id su m a) as [x|e] eqn:EQ; try discriminate.\nsimpl in ACD.\ngeneralize EQ.\nunfold composite_of_def at 1.\ndestruct (env1!id) eqn:E1; try congruence.\ndestruct (complete_members env1 m) eqn:CM1; try congruence.\nintros EQ1.\nsimpl.\ndestruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : (do co <- OK x; add_composite_definitions (PTree.set id co env1) l) =\nOK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : {env2' : composite_env\n| add_composite_definitions env2\n    (if\n      negb\n        (in_dec ident_eq (name_composite_def (Composite id su m a))\n           (map name_composite_def l0))\n     then Composite id su m a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"simpl in ACD.\ngeneralize EQ.\nunfold composite_of_def at 1.\ndestruct (env1!id) eqn:E1; try congruence.\ndestruct (complete_members env1 m) eqn:CM1; try congruence.\nintros EQ1.\nsimpl.\ndestruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : {env2' : composite_env\n| add_composite_definitions env2\n    (if\n      negb\n        (in_dec ident_eq (name_composite_def (Composite id su m a))\n           (map name_composite_def l0))\n     then Composite id su m a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"generalize EQ.\nunfold composite_of_def at 1.\ndestruct (env1!id) eqn:E1; try congruence.\ndestruct (complete_members env1 m) eqn:CM1; try congruence.\nintros EQ1.\nsimpl.\ndestruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : composite_of_def env1 id su m a = OK x ->\n{env2' : composite_env\n| add_composite_definitions env2\n    (if\n      negb\n        (in_dec ident_eq (name_composite_def (Composite id su m a))\n           (map name_composite_def l0))\n     then Composite id su m a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"unfold composite_of_def at 1.\ndestruct (env1!id) eqn:E1; try congruence.\ndestruct (complete_members env1 m) eqn:CM1; try congruence.\nintros EQ1.\nsimpl.\ndestruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) : match env1 ! id with\n| Some _ =>\n    Error (MSG \"Multiple definitions of struct or union \" :: CTX id :: nil)\n| None =>\n    if complete_members env1 m\n    then\n     OK\n       {|\n         co_su := su;\n         co_members := m;\n         co_attr := a;\n         co_sizeof :=\n           align (sizeof_composite env1 su m)\n             (align_attr a (alignof_composite env1 m));\n         co_alignof := align_attr a (alignof_composite env1 m);\n         co_rank := rank_members env1 m;\n         co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n         co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n         co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n       |}\n    else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)\nend = OK x ->\n{env2' : composite_env\n| add_composite_definitions env2\n    (if\n      negb\n        (in_dec ident_eq (name_composite_def (Composite id su m a))\n           (map name_composite_def l0))\n     then Composite id su m a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"destruct (env1!id) eqn:E1; try congruence.\ndestruct (complete_members env1 m) eqn:CM1; try congruence.\nintros EQ1.\nsimpl.\ndestruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) : (if complete_members env1 m\n then\n  OK\n    {|\n      co_su := su;\n      co_members := m;\n      co_attr := a;\n      co_sizeof :=\n        align (sizeof_composite env1 su m)\n          (align_attr a (alignof_composite env1 m));\n      co_alignof := align_attr a (alignof_composite env1 m);\n      co_rank := rank_members env1 m;\n      co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n      co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n      co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n    |}\n else Error (MSG \"Incomplete struct or union \" :: CTX id :: nil)) = \nOK x ->\n{env2' : composite_env\n| add_composite_definitions env2\n    (if\n      negb\n        (in_dec ident_eq (name_composite_def (Composite id su m a))\n           (map name_composite_def l0))\n     then Composite id su m a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"destruct (complete_members env1 m) eqn:CM1; try congruence.\nintros EQ1.\nsimpl.\ndestruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x ->\n{env2' : composite_env\n| add_composite_definitions env2\n    (if\n      negb\n        (in_dec ident_eq (name_composite_def (Composite id su m a))\n           (map name_composite_def l0))\n     then Composite id su m a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"intros EQ1.\nsimpl.\ndestruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) : {env2' : composite_env\n| add_composite_definitions env2\n    (if\n      negb\n        (in_dec ident_eq (name_composite_def (Composite id su m a))\n           (map name_composite_def l0))\n     then Composite id su m a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"simpl.\ndestruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) : {env2' : composite_env\n| add_composite_definitions env2\n    (if negb (in_dec ident_eq id (map name_composite_def l0))\n     then Composite id su m a :: filter_redefs l0 l\n     else filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"destruct (in_dec ident_eq id (map name_composite_def l0)); simpl.\neapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction.\nassert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) : {env2' : composite_env\n| add_composite_definitions env2 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"eapply IHl; eauto.\nintros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto.\nintros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) : forall (id0 : positive) (co : composite),\n(PTree.set id x env1) ! id0 = Some co -> env2 ! id0 = Some co.","proofString":"intros.\nrewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co0 : composite),\n env3 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall (id1 : positive) (co0 : composite),\n env0 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co0 : composite),\n   env1'0 ! id1 = Some co0 -> env2' ! id1 = Some co0) /\\\n  (forall (id1 : positive) (co0 : composite),\n   env0 ! id1 = Some co0 -> env2' ! id1 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co0 : composite),\nenv1 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE0 : forall (id1 : positive) (co0 : composite),\nenv0 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) (id0 : positive) (co : composite) (H0 : (PTree.set id x env1) ! id0 = Some co) : env2 ! id0 = Some co.","proofString":"rewrite PTree.gsspec in H0.\ndestruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co0 : composite),\n env3 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall (id1 : positive) (co0 : composite),\n env0 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co0 : composite),\n   env1'0 ! id1 = Some co0 -> env2' ! id1 = Some co0) /\\\n  (forall (id1 : positive) (co0 : composite),\n   env0 ! id1 = Some co0 -> env2' ! id1 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co0 : composite),\nenv1 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE0 : forall (id1 : positive) (co0 : composite),\nenv0 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) (id0 : positive) (co : composite) (H0 : (if peq id0 id then Some x else env1 ! id0) = Some co) : env2 ! id0 = Some co.","proofString":"destruct (peq id0 id); auto.\ninv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co0 : composite),\n env3 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall (id1 : positive) (co0 : composite),\n env0 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co0 : composite),\n   env1'0 ! id1 = Some co0 -> env2' ! id1 = Some co0) /\\\n  (forall (id1 : positive) (co0 : composite),\n   env0 ! id1 = Some co0 -> env2' ! id1 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co0 : composite),\nenv1 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE0 : forall (id1 : positive) (co0 : composite),\nenv0 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) (id0 : positive) (co : composite) (e : id0 = id) (H0 : Some x = Some co) : env2 ! id0 = Some co.","proofString":"inv H0.\nexploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (ACD : add_composite_definitions (PTree.set id co env1) l = OK env1') (EQ : composite_of_def env1 id su m a = OK co) (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK co) (i : In id (map name_composite_def l0)) : env2 ! id = Some co.","proofString":"exploit list_in_map_inv; eauto.\nintros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (ACD : add_composite_definitions (PTree.set id co env1) l = OK env1') (EQ : composite_of_def env1 id su m a = OK co) (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK co) (i : In id (map name_composite_def l0)) : (exists x : composite_definition, id = name_composite_def x /\\ In x l0) ->\nenv2 ! id = Some co.","proofString":"intros ([id' su' m' a'] & P & Q).\nassert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (ACD : add_composite_definitions (PTree.set id co env1) l = OK env1') (EQ : composite_of_def env1 id su m a = OK co) (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK co) (i : In id (map name_composite_def l0)) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (P : id = name_composite_def (Composite id' su' m' a')) (Q : In (Composite id' su' m' a') l0) : env2 ! id = Some co.","proofString":"assert (X: Composite id su m a = Composite id' su' m' a').\neapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto.\ninv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (ACD : add_composite_definitions (PTree.set id co env1) l = OK env1') (EQ : composite_of_def env1 id su m a = OK co) (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK co) (i : In id (map name_composite_def l0)) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (P : id = name_composite_def (Composite id' su' m' a')) (Q : In (Composite id' su' m' a') l0) : Composite id su m a = Composite id' su' m' a'.","proofString":"eapply UNIQUE.\nauto.\nauto.\nrewrite <- P; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (ACD : add_composite_definitions (PTree.set id co env1) l = OK env1') (EQ : composite_of_def env1 id su m a = OK co) (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK co) (i : In id (map name_composite_def l0)) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (P : id = name_composite_def (Composite id' su' m' a')) (Q : In (Composite id' su' m' a') l0) : In (Composite id' su' m' a') l0.","proofString":"auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (ACD : add_composite_definitions (PTree.set id co env1) l = OK env1') (EQ : composite_of_def env1 id su m a = OK co) (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK co) (i : In id (map name_composite_def l0)) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (P : id = name_composite_def (Composite id' su' m' a')) (Q : In (Composite id' su' m' a') l0) : Composite id su m a = Composite id su m a \\/ In (Composite id su m a) l.","proofString":"auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (ACD : add_composite_definitions (PTree.set id co env1) l = OK env1') (EQ : composite_of_def env1 id su m a = OK co) (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK co) (i : In id (map name_composite_def l0)) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (P : id = name_composite_def (Composite id' su' m' a')) (Q : In (Composite id' su' m' a') l0) : name_composite_def (Composite id su m a) =\nname_composite_def (Composite id' su' m' a').","proofString":"rewrite <- P; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (ACD : add_composite_definitions (PTree.set id co env1) l = OK env1') (EQ : composite_of_def env1 id su m a = OK co) (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK co) (i : In id (map name_composite_def l0)) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (P : id = name_composite_def (Composite id' su' m' a')) (Q : In (Composite id' su' m' a') l0) (X : Composite id su m a = Composite id' su' m' a') : env2 ! id = Some co.","proofString":"inv X.\nexploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') : env2 ! id' = Some co.","proofString":"exploit build_composite_env_charact; eauto.\nintros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') : (exists co0 : composite,\n   env0 ! id' = Some co0 /\\\n   co_members co0 = m' /\\ co_attr co0 = a' /\\ co_su co0 = su') ->\nenv2 ! id' = Some co.","proofString":"intros (co' & U & V & W & X).\nassert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') : env2 ! id' = Some co.","proofString":"assert (co' = co).\napply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\nsubst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') : co' = co.","proofString":"apply composite_consistent_unique with env2.\napply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto.\napply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto.\ninversion EQ1; auto.\ninversion EQ1; auto.\ninversion EQ1; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') : composite_consistent env2 co'.","proofString":"apply composite_consistent_stable with env0; auto.\neapply build_composite_env_consistent; eauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') : composite_consistent env0 co'.","proofString":"eapply build_composite_env_consistent; eauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') : composite_consistent env2 co.","proofString":"apply composite_consistent_stable with env1; auto.\ninversion EQ1; constructor; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') : composite_consistent env1 co.","proofString":"inversion EQ1; constructor; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') : co_su co' = co_su co.","proofString":"inversion EQ1; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') : co_members co' = co_members co.","proofString":"inversion EQ1; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') : co_attr co' = co_attr co.","proofString":"inversion EQ1; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (co' : composite) (U : env0 ! id' = Some co') (V : co_members co' = m') (W : co_attr co' = a') (X : co_su co' = su') (H0 : co' = co) : env2 ! id' = Some co.","proofString":"subst co'.\napply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id : positive) (co0 : composite),\n env3 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall (id : positive) (co0 : composite),\n env0 ! id = Some co0 -> env4 ! id = Some co0) ->\n(forall id : positive,\n env4 ! id =\n (if in_dec ident_eq id (map name_composite_def l0)\n  then env0 ! id\n  else env3 ! id)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id : positive) (co0 : composite),\n   env1'0 ! id = Some co0 -> env2' ! id = Some co0) /\\\n  (forall (id : positive) (co0 : composite),\n   env0 ! id = Some co0 -> env2' ! id = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (co : composite) (id' : ident) (su' : struct_or_union) (m' : members) (a' : attr) (EQ : composite_of_def env1 (name_composite_def (Composite id' su' m' a')) su' m'\n  a' = OK co) (ACD : add_composite_definitions\n  (PTree.set (name_composite_def (Composite id' su' m' a')) co env1) l =\nOK env1') (AGREE1 : forall (id : positive) (co0 : composite),\nenv1 ! id = Some co0 -> env2 ! id = Some co0) (AGREE0 : forall (id : positive) (co0 : composite),\nenv0 ! id = Some co0 -> env2 ! id = Some co0) (AGREE2 : forall id : positive,\nenv2 ! id =\n(if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id)) (E1 : env1 ! (name_composite_def (Composite id' su' m' a')) = None) (EQ1 : OK\n  {|\n    co_su := su';\n    co_members := m';\n    co_attr := a';\n    co_sizeof :=\n      align (sizeof_composite env1 su' m')\n        (align_attr a' (alignof_composite env1 m'));\n    co_alignof := align_attr a' (alignof_composite env1 m');\n    co_rank := rank_members env1 m';\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su' m' a';\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m' a';\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su' m' a'\n  |} = OK co) (CM1 : complete_members env1 m' = true) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite (name_composite_def (Composite id' su' m' a')) su' m' a' = cd2 \\/\nIn cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (i : In (name_composite_def (Composite id' su' m' a')) (map name_composite_def l0)) (Q : In (Composite id' su' m' a') l0) (H1 : name_composite_def (Composite id' su' m' a') = id') (X : co_su co = su') (W : co_attr co = a') (V : co_members co = m') (U : env0 ! id' = Some co) : env2 ! id' = Some co.","proofString":"apply AGREE0; auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else (PTree.set id x env1) ! id0).","proofString":"intros.\nrewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co : composite),\n env3 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall (id1 : positive) (co : composite),\n env0 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co : composite),\n   env1'0 ! id1 = Some co -> env2' ! id1 = Some co) /\\\n  (forall (id1 : positive) (co : composite),\n   env0 ! id1 = Some co -> env2' ! id1 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co : composite),\nenv1 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE0 : forall (id1 : positive) (co : composite),\nenv0 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) (id0 : positive) : env2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else (PTree.set id x env1) ! id0).","proofString":"rewrite AGREE2.\ndestruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co : composite),\n env3 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall (id1 : positive) (co : composite),\n env0 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co : composite),\n   env1'0 ! id1 = Some co -> env2' ! id1 = Some co) /\\\n  (forall (id1 : positive) (co : composite),\n   env0 ! id1 = Some co -> env2' ! id1 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co : composite),\nenv1 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE0 : forall (id1 : positive) (co : composite),\nenv0 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) (id0 : positive) : (if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0) =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else (PTree.set id x env1) ! id0).","proofString":"destruct (in_dec ident_eq id0 (map name_composite_def l0)); auto.\nrewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co : composite),\n env3 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall (id1 : positive) (co : composite),\n env0 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co : composite),\n   env1'0 ! id1 = Some co -> env2' ! id1 = Some co) /\\\n  (forall (id1 : positive) (co : composite),\n   env0 ! id1 = Some co -> env2' ! id1 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co : composite),\nenv1 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE0 : forall (id1 : positive) (co : composite),\nenv0 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) (id0 : positive) (n : ~ In id0 (map name_composite_def l0)) : env1 ! id0 = (PTree.set id x env1) ! id0.","proofString":"rewrite PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\ncontradiction."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co : composite),\n env3 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall (id1 : positive) (co : composite),\n env0 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co : composite),\n   env1'0 ! id1 = Some co -> env2' ! id1 = Some co) /\\\n  (forall (id1 : positive) (co : composite),\n   env0 ! id1 = Some co -> env2' ! id1 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co : composite),\nenv1 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE0 : forall (id1 : positive) (co : composite),\nenv0 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) (id0 : positive) (n : ~ In id0 (map name_composite_def l0)) : env1 ! id0 = (if peq id0 id then Some x else env1 ! id0).","proofString":"destruct (peq id0 id); auto.\nsubst id0.\ncontradiction."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co : composite),\n env3 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall (id1 : positive) (co : composite),\n env0 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co : composite),\n   env1'0 ! id1 = Some co -> env2' ! id1 = Some co) /\\\n  (forall (id1 : positive) (co : composite),\n   env0 ! id1 = Some co -> env2' ! id1 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co : composite),\nenv1 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE0 : forall (id1 : positive) (co : composite),\nenv0 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) (id0 : positive) (n : ~ In id0 (map name_composite_def l0)) (e : id0 = id) : env1 ! id0 = Some x.","proofString":"subst id0.\ncontradiction."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (i : In id (map name_composite_def l0)) (n : ~ In id (map name_composite_def l0)) : env1 ! id = Some x.","proofString":"contradiction."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) : {env2' : composite_env\n| (do co <- composite_of_def env2 id su m a;\n   add_composite_definitions (PTree.set id co env2) (filter_redefs l0 l)) =\n  OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"assert (E2: env2!id = None).\nrewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto.\nassert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) : env2 ! id = None.","proofString":"rewrite AGREE2.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) : (if in_dec ident_eq id (map name_composite_def l0)\n then env0 ! id\n else env1 ! id) = None.","proofString":"rewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) : env1 ! id = None.","proofString":"auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) : {env2' : composite_env\n| (do co <- composite_of_def env2 id su m a;\n   add_composite_definitions (PTree.set id co env2) (filter_redefs l0 l)) =\n  OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"assert (E3: composite_of_def env2 id su m a = OK x).\neapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto.\nrewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) : composite_of_def env2 id su m a = OK x.","proofString":"eapply composite_of_def_stable.\neexact AGREE1.\neauto.\neauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) : env2 ! id = None.","proofString":"eauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) : {env2' : composite_env\n| (do co <- composite_of_def env2 id su m a;\n   add_composite_definitions (PTree.set id co env2) (filter_redefs l0 l)) =\n  OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"rewrite E3.\nsimpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) : {env2' : composite_env\n| (do co <- OK x;\n   add_composite_definitions (PTree.set id co env2) (filter_redefs l0 l)) =\n  OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"simpl.\neapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) : {env2' : composite_env\n| add_composite_definitions (PTree.set id x env2) (filter_redefs l0 l) =\n  OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1' ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}.","proofString":"eapply IHl; eauto.\nintros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nintros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence.\nintros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) : forall (id0 : positive) (co : composite),\n(PTree.set id x env1) ! id0 = Some co ->\n(PTree.set id x env2) ! id0 = Some co.","proofString":"intros until co; rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co0 : composite),\n env3 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall (id1 : positive) (co0 : composite),\n env0 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co0 : composite),\n   env1'0 ! id1 = Some co0 -> env2' ! id1 = Some co0) /\\\n  (forall (id1 : positive) (co0 : composite),\n   env0 ! id1 = Some co0 -> env2' ! id1 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co0 : composite),\nenv1 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE0 : forall (id1 : positive) (co0 : composite),\nenv0 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) (id0 : positive) (co : composite) : (if peq id0 id then Some x else env1 ! id0) = Some co ->\n(if peq id0 id then Some x else env2 ! id0) = Some co.","proofString":"destruct (peq id0 id); auto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> (PTree.set id x env2) ! id0 = Some co.","proofString":"intros until co; rewrite ! PTree.gsspec.\nintros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co0 : composite),\n env3 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall (id1 : positive) (co0 : composite),\n env0 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co0 : composite),\n   env1'0 ! id1 = Some co0 -> env2' ! id1 = Some co0) /\\\n  (forall (id1 : positive) (co0 : composite),\n   env0 ! id1 = Some co0 -> env2' ! id1 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co0 : composite),\nenv1 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE0 : forall (id1 : positive) (co0 : composite),\nenv0 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) (id0 : positive) (co : composite) : env0 ! id0 = Some co -> (if peq id0 id then Some x else env2 ! id0) = Some co.","proofString":"intros.\ndestruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co0 : composite),\n env3 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall (id1 : positive) (co0 : composite),\n env0 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co0 : composite),\n   env1'0 ! id1 = Some co0 -> env2' ! id1 = Some co0) /\\\n  (forall (id1 : positive) (co0 : composite),\n   env0 ! id1 = Some co0 -> env2' ! id1 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co0 : composite),\nenv1 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE0 : forall (id1 : positive) (co0 : composite),\nenv0 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) (id0 : positive) (co : composite) (H0 : env0 ! id0 = Some co) : (if peq id0 id then Some x else env2 ! id0) = Some co.","proofString":"destruct (peq id0 id); auto.\nsubst id0.\napply AGREE0 in H0.\ncongruence."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co0 : composite),\n env3 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall (id1 : positive) (co0 : composite),\n env0 ! id1 = Some co0 -> env4 ! id1 = Some co0) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co0 : composite),\n   env1'0 ! id1 = Some co0 -> env2' ! id1 = Some co0) /\\\n  (forall (id1 : positive) (co0 : composite),\n   env0 ! id1 = Some co0 -> env2' ! id1 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co0 : composite),\nenv1 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE0 : forall (id1 : positive) (co0 : composite),\nenv0 ! id1 = Some co0 -> env2 ! id1 = Some co0) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) (id0 : positive) (co : composite) (H0 : env0 ! id0 = Some co) (e : id0 = id) : Some x = Some co.","proofString":"subst id0.\napply AGREE0 in H0.\ncongruence."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) (co : composite) (H0 : env0 ! id = Some co) : Some x = Some co.","proofString":"apply AGREE0 in H0.\ncongruence."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co0 : composite),\n env3 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall (id0 : positive) (co0 : composite),\n env0 ! id0 = Some co0 -> env4 ! id0 = Some co0) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co0 : composite),\n   env1'0 ! id0 = Some co0 -> env2' ! id0 = Some co0) /\\\n  (forall (id0 : positive) (co0 : composite),\n   env0 ! id0 = Some co0 -> env2' ! id0 = Some co0)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co0 : composite),\nenv1 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE0 : forall (id0 : positive) (co0 : composite),\nenv0 ! id0 = Some co0 -> env2 ! id0 = Some co0) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) (co : composite) (H0 : env2 ! id = Some co) : Some x = Some co.","proofString":"congruence."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) : forall id0 : positive,\n(PTree.set id x env2) ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else (PTree.set id x env1) ! id0).","proofString":"intros.\nrewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co : composite),\n env3 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall (id1 : positive) (co : composite),\n env0 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co : composite),\n   env1'0 ! id1 = Some co -> env2' ! id1 = Some co) /\\\n  (forall (id1 : positive) (co : composite),\n   env0 ! id1 = Some co -> env2' ! id1 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co : composite),\nenv1 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE0 : forall (id1 : positive) (co : composite),\nenv0 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) (id0 : positive) : (PTree.set id x env2) ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else (PTree.set id x env1) ! id0).","proofString":"rewrite ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co : composite),\n env3 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall (id1 : positive) (co : composite),\n env0 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co : composite),\n   env1'0 ! id1 = Some co -> env2' ! id1 = Some co) /\\\n  (forall (id1 : positive) (co : composite),\n   env0 ! id1 = Some co -> env2' ! id1 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co : composite),\nenv1 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE0 : forall (id1 : positive) (co : composite),\nenv0 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) (id0 : positive) : (if peq id0 id then Some x else env2 ! id0) =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else if peq id0 id then Some x else env1 ! id0).","proofString":"destruct (peq id0 id); auto.\nsubst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id1 : positive) (co : composite),\n env3 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall (id1 : positive) (co : composite),\n env0 ! id1 = Some co -> env4 ! id1 = Some co) ->\n(forall id1 : positive,\n env4 ! id1 =\n (if in_dec ident_eq id1 (map name_composite_def l0)\n  then env0 ! id1\n  else env3 ! id1)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id1 : positive) (co : composite),\n   env1'0 ! id1 = Some co -> env2' ! id1 = Some co) /\\\n  (forall (id1 : positive) (co : composite),\n   env0 ! id1 = Some co -> env2' ! id1 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id1 : positive) (co : composite),\nenv1 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE0 : forall (id1 : positive) (co : composite),\nenv0 ! id1 = Some co -> env2 ! id1 = Some co) (AGREE2 : forall id1 : positive,\nenv2 ! id1 =\n(if in_dec ident_eq id1 (map name_composite_def l0)\n then env0 ! id1\n else env1 ! id1)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) (id0 : positive) (e : id0 = id) : Some x =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else Some x).","proofString":"subst id0.\nrewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) : Some x =\n(if in_dec ident_eq id (map name_composite_def l0) then env0 ! id else Some x).","proofString":"rewrite pred_dec_false by auto.\nauto."},{"statement":"(l0 : list composite_definition) (env0 : composite_env) (H : build_composite_env l0 = OK env0) (id : ident) (su : struct_or_union) (m : members) (a : attr) (l : list composite_definition) (IHl : forall (env3 env1'0 : composite_env) (env4 : PTree.tree composite),\nadd_composite_definitions env3 l = OK env1'0 ->\n(forall (id0 : positive) (co : composite),\n env3 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall (id0 : positive) (co : composite),\n env0 ! id0 = Some co -> env4 ! id0 = Some co) ->\n(forall id0 : positive,\n env4 ! id0 =\n (if in_dec ident_eq id0 (map name_composite_def l0)\n  then env0 ! id0\n  else env3 ! id0)) ->\n(forall cd1 cd2 : composite_definition,\n In cd1 l0 ->\n In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) ->\n{env2' : composite_env\n| add_composite_definitions env4 (filter_redefs l0 l) = OK env2' /\\\n  (forall (id0 : positive) (co : composite),\n   env1'0 ! id0 = Some co -> env2' ! id0 = Some co) /\\\n  (forall (id0 : positive) (co : composite),\n   env0 ! id0 = Some co -> env2' ! id0 = Some co)}) (env1 env1' : composite_env) (env2 : PTree.tree composite) (x : composite) (EQ : composite_of_def env1 id su m a = OK x) (ACD : add_composite_definitions (PTree.set id x env1) l = OK env1') (AGREE1 : forall (id0 : positive) (co : composite),\nenv1 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE0 : forall (id0 : positive) (co : composite),\nenv0 ! id0 = Some co -> env2 ! id0 = Some co) (AGREE2 : forall id0 : positive,\nenv2 ! id0 =\n(if in_dec ident_eq id0 (map name_composite_def l0)\n then env0 ! id0\n else env1 ! id0)) (UNIQUE : forall cd1 cd2 : composite_definition,\nIn cd1 l0 ->\nComposite id su m a = cd2 \\/ In cd2 l ->\nname_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (E1 : env1 ! id = None) (CM1 : complete_members env1 m = true) (EQ1 : OK\n  {|\n    co_su := su;\n    co_members := m;\n    co_attr := a;\n    co_sizeof :=\n      align (sizeof_composite env1 su m)\n        (align_attr a (alignof_composite env1 m));\n    co_alignof := align_attr a (alignof_composite env1 m);\n    co_rank := rank_members env1 m;\n    co_sizeof_pos := composite_of_def_obligation_1 env1 su m a;\n    co_alignof_two_p := composite_of_def_obligation_2 env1 m a;\n    co_sizeof_alignof := composite_of_def_obligation_3 env1 su m a\n  |} = OK x) (n : ~ In id (map name_composite_def l0)) (E2 : env2 ! id = None) (E3 : composite_of_def env2 id su m a = OK x) : Some x = Some x.","proofString":"auto."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) : {env : composite_env\n| build_composite_env l = OK env /\\\n  (forall (id : positive) (co : composite),\n   env1 ! id = Some co -> env ! id = Some co) /\\\n  (forall (id : positive) (co : composite),\n   env2 ! id = Some co -> env ! id = Some co)}.","proofString":"edestruct link_composite_def_inv as (A & B & C); eauto.\nedestruct link_add_composite_definitions as (env & P & Q & R).\neexact H.\neexact H0.\ninstantiate (1 := env1).\nintros.\nrewrite PTree.gempty in H2; discriminate.\nauto.\nintros.\ndestruct (in_dec ident_eq id (map name_composite_def l1)); auto.\nrewrite PTree.gempty.\ndestruct (env1!id) eqn:E1; auto.\nexploit build_composite_env_domain.\neexact H.\neauto.\nintros.\napply (in_map name_composite_def) in H2.\nelim n; auto.\nauto.\nexists env; split; auto.\nsubst l.\napply add_composite_definitions_append.\nexists env1; auto."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) : {env : composite_env\n| build_composite_env l = OK env /\\\n  (forall (id : positive) (co : composite),\n   env1 ! id = Some co -> env ! id = Some co) /\\\n  (forall (id : positive) (co : composite),\n   env2 ! id = Some co -> env ! id = Some co)}.","proofString":"edestruct link_add_composite_definitions as (env & P & Q & R).\neexact H.\neexact H0.\ninstantiate (1 := env1).\nintros.\nrewrite PTree.gempty in H2; discriminate.\nauto.\nintros.\ndestruct (in_dec ident_eq id (map name_composite_def l1)); auto.\nrewrite PTree.gempty.\ndestruct (env1!id) eqn:E1; auto.\nexploit build_composite_env_domain.\neexact H.\neauto.\nintros.\napply (in_map name_composite_def) in H2.\nelim n; auto.\nauto.\nexists env; split; auto.\nsubst l.\napply add_composite_definitions_append.\nexists env1; auto."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) : forall (id : positive) (co : composite),\n(PTree.empty composite) ! id = Some co -> env1 ! id = Some co.","proofString":"intros.\nrewrite PTree.gempty in H2; discriminate."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) (id : positive) (co : composite) (H2 : (PTree.empty composite) ! id = Some co) : env1 ! id = Some co.","proofString":"rewrite PTree.gempty in H2; discriminate."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) (id : positive) : env1 ! id =\n(if in_dec ident_eq id (map name_composite_def l1)\n then env1 ! id\n else (PTree.empty composite) ! id).","proofString":"destruct (in_dec ident_eq id (map name_composite_def l1)); auto.\nrewrite PTree.gempty.\ndestruct (env1!id) eqn:E1; auto.\nexploit build_composite_env_domain.\neexact H.\neauto.\nintros.\napply (in_map name_composite_def) in H2.\nelim n; auto."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) (id : positive) (n : ~ In id (map name_composite_def l1)) : env1 ! id = (PTree.empty composite) ! id.","proofString":"rewrite PTree.gempty.\ndestruct (env1!id) eqn:E1; auto.\nexploit build_composite_env_domain.\neexact H.\neauto.\nintros.\napply (in_map name_composite_def) in H2.\nelim n; auto."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) (id : positive) (n : ~ In id (map name_composite_def l1)) : env1 ! id = None.","proofString":"destruct (env1!id) eqn:E1; auto.\nexploit build_composite_env_domain.\neexact H.\neauto.\nintros.\napply (in_map name_composite_def) in H2.\nelim n; auto."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) (id : positive) (n : ~ In id (map name_composite_def l1)) (c : composite) (E1 : env1 ! id = Some c) : Some c = None.","proofString":"exploit build_composite_env_domain.\neexact H.\neauto.\nintros.\napply (in_map name_composite_def) in H2.\nelim n; auto."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) (id : positive) (n : ~ In id (map name_composite_def l1)) (c : composite) (E1 : env1 ! id = Some c) (H2 : In (Composite id (co_su c) (co_members c) (co_attr c)) l1) : Some c = None.","proofString":"apply (in_map name_composite_def) in H2.\nelim n; auto."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) (id : positive) (n : ~ In id (map name_composite_def l1)) (c : composite) (E1 : env1 ! id = Some c) (H2 : In (name_composite_def (Composite id (co_su c) (co_members c) (co_attr c)))\n  (map name_composite_def l1)) : Some c = None.","proofString":"elim n; auto."},{"statement":"(l1 l2 l : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some l) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (B : l = l1 ++ filter_redefs l1 l2) (C : forall x : composite_definition, In x l <-> In x l1 \\/ In x l2) (env : composite_env) (P : add_composite_definitions env1 (filter_redefs l1 l2) = OK env) (Q : forall (id : positive) (co : composite),\nenv2 ! id = Some co -> env ! id = Some co) (R : forall (id : positive) (co : composite),\nenv1 ! id = Some co -> env ! id = Some co) : build_composite_env l = OK env.","proofString":"subst l.\napply add_composite_definitions_append.\nexists env1; auto."},{"statement":"(l1 l2 : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some (l1 ++ filter_redefs l1 l2)) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (C : forall x : composite_definition,\nIn x (l1 ++ filter_redefs l1 l2) <-> In x l1 \\/ In x l2) (env : composite_env) (P : add_composite_definitions env1 (filter_redefs l1 l2) = OK env) (Q : forall (id : positive) (co : composite),\nenv2 ! id = Some co -> env ! id = Some co) (R : forall (id : positive) (co : composite),\nenv1 ! id = Some co -> env ! id = Some co) : build_composite_env (l1 ++ filter_redefs l1 l2) = OK env.","proofString":"apply add_composite_definitions_append.\nexists env1; auto."},{"statement":"(l1 l2 : list composite_definition) (env1 env2 : composite_env) (H : build_composite_env l1 = OK env1) (H0 : build_composite_env l2 = OK env2) (H1 : link l1 l2 = Some (l1 ++ filter_redefs l1 l2)) (A : forall cd1 cd2 : composite_definition,\nIn cd1 l1 ->\nIn cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1) (C : forall x : composite_definition,\nIn x (l1 ++ filter_redefs l1 l2) <-> In x l1 \\/ In x l2) (env : composite_env) (P : add_composite_definitions env1 (filter_redefs l1 l2) = OK env) (Q : forall (id : positive) (co : composite),\nenv2 ! id = Some co -> env ! id = Some co) (R : forall (id : positive) (co : composite),\nenv1 ! id = Some co -> env ! id = Some co) : exists env' : composite_env,\n  add_composite_definitions (PTree.empty composite) l1 = OK env' /\\\n  add_composite_definitions env' (filter_redefs l1 l2) = OK env.","proofString":"exists env1; auto."},{"statement":"(F : Type) (f1 f2 f : fundef F) (H : link_fundef f1 f2 = Some f) : f = f1 \\/ f = f2.","proofString":"unfold link_fundef in H.\ndestruct f1, f2; try discriminate.\ndestruct e; inv H.\nauto.\ndestruct e; inv H.\nauto.\ndestruct andb; inv H; auto."},{"statement":"(F : Type) (f1 f2 f : fundef F) (H : match f1 with\n| Internal f0 =>\n    match f2 with\n    | External (EF_external _ _) _ _ _ => Some (Internal f0)\n    | _ => None\n    end\n| External ef targs tres cc =>\n    match f2 with\n    | Internal f0 =>\n        match ef with\n        | EF_external _ _ => Some (Internal f0)\n        | _ => None\n        end\n    | External ef2 targs2 tres2 cc2 =>\n        if\n         external_function_eq ef ef2 && typelist_eq targs targs2 &&\n         type_eq tres tres2 && calling_convention_eq cc cc2\n        then Some (External ef targs tres cc)\n        else None\n    end\nend = Some f) : f = f1 \\/ f = f2.","proofString":"destruct f1, f2; try discriminate.\ndestruct e; inv H.\nauto.\ndestruct e; inv H.\nauto.\ndestruct andb; inv H; auto."},{"statement":"(F : Type) (f0 : F) (e : external_function) (l : list type) (t : type) (c : calling_convention) (f : fundef F) (H : match e with\n| EF_external _ _ => Some (Internal f0)\n| _ => None\nend = Some f) : f = Internal f0 \\/ f = External e l t c.","proofString":"destruct e; inv H.\nauto."},{"statement":"(F : Type) (f0 : F) (name : string) (sg : signature) (l : list type) (t : type) (c : calling_convention) : Internal f0 = Internal f0 \\/\nInternal f0 = External (EF_external name sg) l t c.","proofString":"auto."},{"statement":"(F : Type) (e : external_function) (l : list type) (t : type) (c : calling_convention) (f0 : F) (f : fundef F) (H : match e with\n| EF_external _ _ => Some (Internal f0)\n| _ => None\nend = Some f) : f = External e l t c \\/ f = Internal f0.","proofString":"destruct e; inv H.\nauto."},{"statement":"(F : Type) (name : string) (sg : signature) (l : list type) (t : type) (c : calling_convention) (f0 : F) : Internal f0 = External (EF_external name sg) l t c \\/\nInternal f0 = Internal f0.","proofString":"auto."},{"statement":"(F : Type) (e : external_function) (l : list type) (t : type) (c : calling_convention) (e0 : external_function) (l0 : list type) (t0 : type) (c0 : calling_convention) (f : fundef F) (H : (if\n  external_function_eq e e0 && typelist_eq l l0 && type_eq t t0 &&\n  calling_convention_eq c c0\n then Some (External e l t c)\n else None) = Some f) : f = External e l t c \\/ f = External e0 l0 t0 c0.","proofString":"destruct andb; inv H; auto."},{"statement":"(A : Type) (a : A) : {x : A | Some a = Some x} + {Some a = None}.","proofString":"left; exists a; auto."}]}