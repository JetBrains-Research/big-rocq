[{"statement":"Lemma s_psc_in_psc : ⦗F∩₁Sc⦘ ⨾ s_hb ⨾ eco ⨾ s_hb ⨾ ⦗F∩₁Sc⦘ ⊆ psc.","proof":"unfold imm.psc.\nby rewrite s_hb_in_hb.\n"},{"statement":"Lemma s_ppo_in_ppo : s_ppo ⊆ ppo.","proof":"unfold imm_s_ppo.ppo, imm_ppo.ppo.\nassert (rmw ∪ (rmw_dep ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb) ⊆          (rmw ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb ∪ rmw_dep)⁺) as AA.\n2: {\nrewrite !unionA.\nrewrite AA.\nrewrite <- !unionA.\nrewrite ct_of_union_ct_r.\nby rewrite <- !unionA.\n}\nunionL.\n2: {\nrewrite crE, seq_union_r, seq_id_r.\nunionL.\n{\nrewrite <- ct_step.\nbasic_solver.\n}\nrewrite <- ct_unit.\nrewrite <- ct_step.\nrewrite (dom_r (wf_rmw_depD WF)) at 1.\nbasic_solver 10.\n}\nall: rewrite <- ct_step; unionR left; basic_solver 10.\n"},{"statement":"Lemma s_ar_int_in_ar_int : ⦗R⦘ ⨾ s_ar_int⁺ ⨾ ⦗W⦘ ⊆ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘.","proof":"unfold imm_s_ppo.ar_int, imm_ppo.ar_int.\nby rewrite s_ppo_in_ppo.\n"},{"statement":"Lemma acyc_ext_implies_s_acyc_ext_helper (AC : imm.acyc_ext G) :\n  imm_s.acyc_ext G (⦗F∩₁Sc⦘ ⨾ s_hb ⨾ eco ⨾ s_hb ⨾ ⦗F∩₁Sc⦘).","proof":"unfold imm_s.acyc_ext, imm.acyc_ext in *.\nunfold imm_s.ar.\napply s_acyc_ext_psc_helper; auto.\nunfold imm_s.psc.\nrewrite s_psc_in_psc.\nrewrite s_ar_int_in_ar_int.\narewrite (sb^? ⨾ psc ⨾ sb^? ⊆ ar⁺).\n{\nrewrite imm.wf_pscD.\nrewrite !seqA.\narewrite (sb^? ⨾ ⦗F ∩₁ Sc⦘ ⊆ bob^?).\n{\nunfold imm_bob.bob, imm_bob.fwbob.\nmode_solver 10.\n}\narewrite (⦗F ∩₁ Sc⦘ ⨾ sb^?⊆ bob^?).\n{\nunfold imm_bob.bob, imm_bob.fwbob.\nmode_solver 10.\n}\narewrite (bob ⊆ ar).\n{\nunfold imm.ar, imm_ppo.ar_int.\nbasic_solver 10.\n}\narewrite (psc ⊆ ar).\nrewrite ct_step with (r:=ar) at 2.\nby rewrite ct_cr, cr_ct.\n}\narewrite (rfe ⊆ ar).\narewrite (ar_int ⊆ ar).\narewrite (⦗R⦘ ⨾ ar⁺ ⨾ ⦗W⦘ ⊆ ar⁺) by basic_solver.\nrewrite ct_step with (r:=ar) at 2.\nsin_rewrite !unionK.\nred.\nby rewrite ct_of_ct.\n"},{"statement":"Lemma acyc_ext_implies_s_acyc_ext (AC : imm.acyc_ext G) :\n  exists sc, wf_sc G sc /\\ imm_s.acyc_ext G sc /\\ coh_sc G sc.","proof":"apply imm_s.s_acyc_ext_helper; auto.\nby apply acyc_ext_implies_s_acyc_ext_helper.\n"},{"statement":"Lemma imm_consistentimplies_s_imm_consistent (AC : imm.acyc_ext G) :\n  imm.imm_consistent G -> exists sc, imm_s.imm_consistent G sc.","proof":"unfold imm_s.imm_consistent, imm.imm_consistent.\nins; desf.\nedestruct acyc_ext_implies_s_acyc_ext as [sc]; auto.\ndesf.\nexists sc; splits; eauto 10 using coherence_implies_s_coherence.\n"},{"statement":"Lemma imm_consistentimplies_s_imm_psc_consistent\n      (IC : imm.imm_consistent G) :\n  exists sc, imm_s.imm_psc_consistent G sc.","proof":"edestruct imm_consistentimplies_s_imm_consistent as [sc]; eauto.\n{\napply IC.\n}\nexists sc.\nred.\nsplits; auto.\nunfold psc_f, psc_base, scb.\nrewrite s_hb_in_hb.\napply IC.\n"},{"statement":"Lemma imm_consistentimplies_s_imm_psc_consistent_with_fsupp\n      (NOSC : E ∩₁ F ∩₁ Sc ⊆₁ ∅)\n      (FSUPPSB : fsupp sb) (* NEXT TODO: remove the restriction *)\n      (FSUPPRF : fsupp rf) (* NEXT TODO: remove the restriction *)\n      (FSUPP : fsupp ar⁺)\n      (IC : imm.imm_consistent G) :\n    ⟪ CONS : imm_s.imm_psc_consistent G ∅₂ ⟫ /\\\n    ⟪ FSUPP : fsupp (s_ar ∅₂)⁺ ⟫.","proof":"assert (transitive sb) as TSB by apply sb_trans.\nsplits.\n2: {\nunfold imm_s.ar.\nrewrite union_false_l.\nrewrite ct_unionE.\nassert (fsupp s_ar_int⁺) as AA.\n{\nrewrite imm_s_ppo.ar_int_in_sb; auto.\nrewrite ct_of_trans; auto.\n}\napply fsupp_union; auto.\napply fsupp_seq.\n{\nnow apply fsupp_ct_rt.\n}\nrewrite (wf_rfeD WF), !seqA.\nrewrite ct_rotl, !seqA.\nrepeat (apply fsupp_seq); try apply fsupp_eqv.\n3: {\nrewrite imm_s_ppo.ar_int_in_sb; auto.\nrewrite rt_of_trans; auto.\nnow apply fsupp_cr.\n}\n2: now rewrite rfe_in_rf.\narewrite (⦗R⦘ ⨾ s_ar_int＊ ⨾ ⦗W⦘ ⊆ ⦗R⦘ ⨾ s_ar_int⁺ ⨾ ⦗W⦘).\n{\nrewrite rtE.\nclear.\ntype_solver.\n}\nrewrite s_ar_int_in_ar_int.\narewrite (rfe ⊆ ar).\narewrite (ar_int ⊆ ar).\narewrite_id ⦗R⦘.\narewrite_id ⦗W⦘.\nrewrite seq_id_l, seq_id_r.\narewrite (ar ⊆ ar⁺) at 1.\nrewrite ct_ct.\nrewrite rt_of_ct.\nrewrite <- cr_of_ct.\nnow apply fsupp_cr.\n}\nred.\nsplits.\n2: {\nunfold psc_f, psc_base, scb.\nrewrite s_hb_in_hb.\napply IC.\n}\nred.\nsplits; try apply IC.\n{\nconstructor; rewrite ?NOSC.\nall: basic_solver.\n}\n{\nred.\nbasic_solver.\n}\n{\ncdes IC.\napply coherence_implies_s_coherence; auto.\n}\nred.\nunfold imm_s.ar.\narewrite (∅₂ ⊆ ⦗F∩₁Sc⦘ ⨾ s_hb ⨾ eco ⨾ s_hb ⨾ ⦗F∩₁Sc⦘).\napply acyc_ext_implies_s_acyc_ext_helper.\napply IC.\n"}]