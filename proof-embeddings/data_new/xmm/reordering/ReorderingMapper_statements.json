{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/xmm/src/reordering/ReorderingMapper.v","fileSamples":[{"statement":"(NEQ : a_t <> b_t) : upd (upd id a_t b_t) b_t a_t a_t = b_t.","conclusion":"upd (upd id a_t b_t) b_t a_t a_t = b_t","hypotheses":"(NEQ : a_t <> b_t)","proofString":"rewrite updo, upds; auto."},{"statement":"(NEQ : a_t <> b_t) : upd (upd id a_t b_t) b_t a_t b_t = a_t.","conclusion":"upd (upd id a_t b_t) b_t a_t b_t = a_t","hypotheses":"(NEQ : a_t <> b_t)","proofString":"rewrite upds; auto."},{"statement":"(x : actid) (NA : x <> a_t) (NB : x <> b_t) : upd (upd id a_t b_t) b_t a_t x = x.","conclusion":"upd (upd id a_t b_t) b_t a_t x = x","hypotheses":"(x : actid) (NA : x <> a_t) (NB : x <> b_t)","proofString":"rewrite !updo; auto."},{"statement":"(x : actid) (TID : tid a_t = tid b_t) : tid (upd (upd id a_t b_t) b_t a_t x) = tid x.","conclusion":"tid (upd (upd id a_t b_t) b_t a_t x) = tid x","hypotheses":"(x : actid) (TID : tid a_t = tid b_t)","proofString":"destruct classic with (x = b_t) as [EQ|XNB].\nsubst.\nnow rewrite upds.\nrewrite updo; auto.\ndestruct classic with (x = a_t) as [EQ|XNA].\nsubst.\nnow rewrite upds.\nrewrite updo; auto."},{"statement":"(x : actid) (TID : tid a_t = tid b_t) (EQ : x = b_t) : tid (upd (upd id a_t b_t) b_t a_t x) = tid x.","conclusion":"tid (upd (upd id a_t b_t) b_t a_t x) = tid x","hypotheses":"(x : actid) (TID : tid a_t = tid b_t) (EQ : x = b_t)","proofString":"subst.\nnow rewrite upds."},{"statement":"(TID : tid a_t = tid b_t) : tid (upd (upd id a_t b_t) b_t a_t b_t) = tid b_t.","conclusion":"tid (upd (upd id a_t b_t) b_t a_t b_t) = tid b_t","hypotheses":"(TID : tid a_t = tid b_t)","proofString":"now rewrite upds."},{"statement":"(x : actid) (TID : tid a_t = tid b_t) (XNB : x <> b_t) : tid (upd (upd id a_t b_t) b_t a_t x) = tid x.","conclusion":"tid (upd (upd id a_t b_t) b_t a_t x) = tid x","hypotheses":"(x : actid) (TID : tid a_t = tid b_t) (XNB : x <> b_t)","proofString":"rewrite updo; auto.\ndestruct classic with (x = a_t) as [EQ|XNA].\nsubst.\nnow rewrite upds.\nrewrite updo; auto."},{"statement":"(x : actid) (TID : tid a_t = tid b_t) (XNB : x <> b_t) : tid (upd id a_t b_t x) = tid x.","conclusion":"tid (upd id a_t b_t x) = tid x","hypotheses":"(x : actid) (TID : tid a_t = tid b_t) (XNB : x <> b_t)","proofString":"destruct classic with (x = a_t) as [EQ|XNA].\nsubst.\nnow rewrite upds.\nrewrite updo; auto."},{"statement":"(x : actid) (TID : tid a_t = tid b_t) (XNB : x <> b_t) (EQ : x = a_t) : tid (upd id a_t b_t x) = tid x.","conclusion":"tid (upd id a_t b_t x) = tid x","hypotheses":"(x : actid) (TID : tid a_t = tid b_t) (XNB : x <> b_t) (EQ : x = a_t)","proofString":"subst.\nnow rewrite upds."},{"statement":"(TID : tid a_t = tid b_t) (XNB : a_t <> b_t) : tid (upd id a_t b_t a_t) = tid a_t.","conclusion":"tid (upd id a_t b_t a_t) = tid a_t","hypotheses":"(TID : tid a_t = tid b_t) (XNB : a_t <> b_t)","proofString":"now rewrite upds."},{"statement":"(x : actid) (TID : tid a_t = tid b_t) (XNB : x <> b_t) (XNA : x <> a_t) : tid (upd id a_t b_t x) = tid x.","conclusion":"tid (upd id a_t b_t x) = tid x","hypotheses":"(x : actid) (TID : tid a_t = tid b_t) (XNB : x <> b_t) (XNA : x <> a_t)","proofString":"rewrite updo; auto."},{"statement":"(TID : tid a_t = tid b_t) : forall x : actid, ⊤₁ x -> tid (mapper x) = tid x.","conclusion":"forall x : actid, ⊤₁ x -> tid (mapper x) = tid x","hypotheses":"(TID : tid a_t = tid b_t)","proofString":"intros x _.\nnow apply rsr_mapper_tid'."},{"statement":"(TID : tid a_t = tid b_t) (x : actid) : tid (mapper x) = tid x.","conclusion":"tid (mapper x) = tid x","hypotheses":"(TID : tid a_t = tid b_t) (x : actid)","proofString":"now apply rsr_mapper_tid'."},{"statement":"(x : actid) (NEQ : a_t <> b_t) (EQ : mapper x = a_t) : mapper x = mapper b_t.","conclusion":"mapper x = mapper b_t","hypotheses":"(x : actid) (NEQ : a_t <> b_t) (EQ : mapper x = a_t)","proofString":"now rewrite EQ, rsr_mapper_bt."},{"statement":"(x : actid) (NEQ : a_t <> b_t) (EQ : mapper x = b_t) : mapper x = mapper a_t.","conclusion":"mapper x = mapper a_t","hypotheses":"(x : actid) (NEQ : a_t <> b_t) (EQ : mapper x = b_t)","proofString":"now rewrite EQ, rsr_mapper_at."},{"statement":"(x : actid) (NEQ : a_t <> b_t) : mapper (upd (upd id a_t b_t) b_t a_t x) = x.","conclusion":"mapper (upd (upd id a_t b_t) b_t a_t x) = x","hypotheses":"(x : actid) (NEQ : a_t <> b_t)","proofString":"unfold id at 1.\ndestruct classic with (x = b_t) as [XB|XNB].\ndesf.\nrewrite upds, rsr_mapper_at; auto.\ndestruct classic with (x = a_t) as [XA|XNA].\ndesf.\nrewrite updo, upds, rsr_mapper_bt; auto.\nrewrite !updo, rsr_mappero; auto."},{"statement":"(x : actid) (NEQ : a_t <> b_t) : mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x.","conclusion":"mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x","hypotheses":"(x : actid) (NEQ : a_t <> b_t)","proofString":"destruct classic with (x = b_t) as [XB|XNB].\ndesf.\nrewrite upds, rsr_mapper_at; auto.\ndestruct classic with (x = a_t) as [XA|XNA].\ndesf.\nrewrite updo, upds, rsr_mapper_bt; auto.\nrewrite !updo, rsr_mappero; auto."},{"statement":"(x : actid) (NEQ : a_t <> b_t) (XB : x = b_t) : mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x.","conclusion":"mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x","hypotheses":"(x : actid) (NEQ : a_t <> b_t) (XB : x = b_t)","proofString":"desf.\nrewrite upds, rsr_mapper_at; auto."},{"statement":"(NEQ : a_t <> b_t) : mapper (upd (upd (fun x : actid => x) a_t b_t) b_t a_t b_t) = b_t.","conclusion":"mapper (upd (upd (fun x : actid => x) a_t b_t) b_t a_t b_t) = b_t","hypotheses":"(NEQ : a_t <> b_t)","proofString":"rewrite upds, rsr_mapper_at; auto."},{"statement":"(x : actid) (NEQ : a_t <> b_t) (XNB : x <> b_t) : mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x.","conclusion":"mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x","hypotheses":"(x : actid) (NEQ : a_t <> b_t) (XNB : x <> b_t)","proofString":"destruct classic with (x = a_t) as [XA|XNA].\ndesf.\nrewrite updo, upds, rsr_mapper_bt; auto.\nrewrite !updo, rsr_mappero; auto."},{"statement":"(x : actid) (NEQ : a_t <> b_t) (XNB : x <> b_t) (XA : x = a_t) : mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x.","conclusion":"mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x","hypotheses":"(x : actid) (NEQ : a_t <> b_t) (XNB : x <> b_t) (XA : x = a_t)","proofString":"desf.\nrewrite updo, upds, rsr_mapper_bt; auto."},{"statement":"(NEQ XNB : a_t <> b_t) : mapper (upd (upd (fun x : actid => x) a_t b_t) b_t a_t a_t) = a_t.","conclusion":"mapper (upd (upd (fun x : actid => x) a_t b_t) b_t a_t a_t) = a_t","hypotheses":"(NEQ XNB : a_t <> b_t)","proofString":"rewrite updo, upds, rsr_mapper_bt; auto."},{"statement":"(x : actid) (NEQ : a_t <> b_t) (XNB : x <> b_t) (XNA : x <> a_t) : mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x.","conclusion":"mapper (upd (upd (fun x0 : actid => x0) a_t b_t) b_t a_t x) = x","hypotheses":"(x : actid) (NEQ : a_t <> b_t) (XNB : x <> b_t) (XNA : x <> a_t)","proofString":"rewrite !updo, rsr_mappero; auto."},{"statement":"(NEQ : a_t <> b_t) : forall x : actid, (mapper ∘ mapper) x = id x.","conclusion":"forall x : actid, (mapper ∘ mapper) x = id x","hypotheses":"(NEQ : a_t <> b_t)","proofString":"ins.\nnow apply rsr_mapper_self_inv."},{"statement":"(NEQ : a_t <> b_t) (x : actid) : (mapper ∘ mapper) x = id x.","conclusion":"(mapper ∘ mapper) x = id x","hypotheses":"(NEQ : a_t <> b_t) (x : actid)","proofString":"now apply rsr_mapper_self_inv."},{"statement":"(ANIN : ~ is_init a_t) (BNIN : ~ is_init b_t) : forall x : actid, is_init x -> mapper x = x.","conclusion":"forall x : actid, is_init x -> mapper x = x","hypotheses":"(ANIN : ~ is_init a_t) (BNIN : ~ is_init b_t)","proofString":"ins.\nrewrite rsr_mappero; congruence."},{"statement":"(ANIN : ~ is_init a_t) (BNIN : ~ is_init b_t) (x : actid) (SX : is_init x) : mapper x = x.","conclusion":"mapper x = x","hypotheses":"(ANIN : ~ is_init a_t) (BNIN : ~ is_init b_t) (x : actid) (SX : is_init x)","proofString":"rewrite rsr_mappero; congruence."}]}