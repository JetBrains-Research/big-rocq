{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/hardware/PowerFairness.v","fileSamples":[{"statement":"hbp ⊆ E × E.","proofString":"unfold \"hbp\".\nrewrite Power_ppo.wf_ppoE, wf_fenceE, wf_rfeE; auto; try apply CON.\nbasic_solver."},{"statement":"ppop ∪ fence ∪ rfe ⊆ E × E.","proofString":"rewrite Power_ppo.wf_ppoE, wf_fenceE, wf_rfeE; auto; try apply CON.\nbasic_solver."},{"statement":"⦗E⦘ ⨾ ppop ⨾ ⦗E⦘ ∪ ⦗E⦘ ⨾ fence ⨾ ⦗E⦘ ∪ ⦗E⦘ ⨾ rfe ⨾ ⦗E⦘ ⊆ E × E.","proofString":"basic_solver."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINTHREADS : threads_bound G b) (x : BinNums.positive) (IN : BinPos.Pos.compare x b = Lt) : BinPos.Pos.to_nat x < Datatypes.S (BinPos.Pos.to_nat b).","proofString":"apply Pnat.Pos2Nat.inj_lt in IN.\nlia."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINTHREADS : threads_bound G b) (x : BinNums.positive) (IN : BinPos.Pos.to_nat x < BinPos.Pos.to_nat b) : BinPos.Pos.to_nat x < Datatypes.S (BinPos.Pos.to_nat b).","proofString":"lia."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINTHREADS : threads_bound G b) : ~\nset_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a)).","proofString":"intros FIN.\ndestruct INF.\nrewrite AuxRel2.set_bunion_separation with (fab := tid).\nrewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : False.","proofString":"destruct INF.\nrewrite AuxRel2.set_bunion_separation with (fab := tid).\nrewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (f ↓₁ S).","proofString":"rewrite AuxRel2.set_bunion_separation with (fab := tid).\nrewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (f ↓₁ (⋃₁b0, S ∩₁ Tid_ b0)).","proofString":"rewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (⋃₁x, f ↓₁ (S ∩₁ Tid_ x)).","proofString":"rewrite AuxRel2.set_full_split with (S := flip BinPos.Pos.lt b).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite\n  (⋃₁x ∈ flip BinPos.Pos.lt b ∪₁ set_compl (flip BinPos.Pos.lt b),\n    f ↓₁ (S ∩₁ Tid_ x)).","proofString":"rewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (⋃₁x ∈ flip BinPos.Pos.lt b, f ↓₁ (S ∩₁ Tid_ x)) /\\\nset_finite (⋃₁x ∈ set_compl (flip BinPos.Pos.lt b), f ↓₁ (S ∩₁ Tid_ x)).","proofString":"split; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) : set_finite (⋃₁x ∈ set_compl (flip BinPos.Pos.lt b), f ↓₁ (S ∩₁ Tid_ x)).","proofString":"exists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (IN : (⋃₁x0 ∈ set_compl (flip BinPos.Pos.lt b), f ↓₁ (S ∩₁ Tid_ x0)) x) : False.","proofString":"unfolder in IN.\ndesc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (IN : exists y : BinNums.positive,\n  ~ flip BinPos.Pos.lt b y /\\ S (f x) /\\ tid (f x) = y) : False.","proofString":"desc.\ndestruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN : ~ flip BinPos.Pos.lt b y) (IN0 : S (f x)) (IN1 : tid (f x) = y) : False.","proofString":"destruct IN.\nred.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : flip BinPos.Pos.lt b y.","proofString":"red.\nrewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : BinPos.Pos.lt y b.","proofString":"rewrite <- IN1.\napply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : BinPos.Pos.lt (tid (f x)) b.","proofString":"apply FINTHREADS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : E (f x).","proofString":"apply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (b : thread_id) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINTHREADS : threads_bound G b) (FIN : set_finite\n  (⋃₁a ∈ fun a : BinNums.positive => BinPos.Pos.lt a b, f ↓₁ (S ∩₁ Tid_ a))) (x : nat) (y : BinNums.positive) (IN0 : S (f x)) (IN1 : tid (f x) = y) : (f ↑₁ ⊤₁) (f x).","proofString":"vauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) : ~ set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a)).","proofString":"intros FIN.\ndestruct INF.\nrewrite AuxRel2.set_bunion_separation with (fab := loc).\nrewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (INF : ~ set_finite (f ↓₁ S)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : False.","proofString":"destruct INF.\nrewrite AuxRel2.set_bunion_separation with (fab := loc).\nrewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite (f ↓₁ S).","proofString":"rewrite AuxRel2.set_bunion_separation with (fab := loc).\nrewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite (f ↓₁ (⋃₁b, S ∩₁ Loc_ b)).","proofString":"rewrite set_map_bunion.\nrewrite AuxRel2.set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite (⋃₁x, f ↓₁ (S ∩₁ Loc_ x)).","proofString":"rewrite AuxRel2.set_full_split with (S := fun l => In l locs).\nrewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite\n  (⋃₁\n    x ∈ (fun l : option location => In l locs)\n        ∪₁ set_compl (fun l : option location => In l locs),\n    f ↓₁ (S ∩₁ Loc_ x)).","proofString":"rewrite set_bunion_union_l, set_finite_union.\nsplit; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite (⋃₁x ∈ fun l : option location => In l locs, f ↓₁ (S ∩₁ Loc_ x)) /\\\nset_finite\n  (⋃₁x ∈ set_compl (fun l : option location => In l locs), f ↓₁ (S ∩₁ Loc_ x)).","proofString":"split; auto.\nexists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) : set_finite\n  (⋃₁x ∈ set_compl (fun l : option location => In l locs), f ↓₁ (S ∩₁ Loc_ x)).","proofString":"exists [].\nins.\nunfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (IN : (⋃₁x0 ∈ set_compl (fun l : option location => In l locs), f ↓₁ (S ∩₁ Loc_ x0))\n  x) : False.","proofString":"unfolder in IN.\ndesc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (IN : exists y : option location, ~ In y locs /\\ S (f x) /\\ loc (f x) = y) : False.","proofString":"desc.\ndestruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN : ~ In y locs) (IN0 : S (f x)) (IN1 : loc (f x) = y) : False.","proofString":"destruct IN.\nrewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN0 : S (f x)) (IN1 : loc (f x) = y) : In y locs.","proofString":"rewrite <- IN1.\napply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN0 : S (f x)) (IN1 : loc (f x) = y) : In (loc (f x)) locs.","proofString":"apply FINLOCS.\napply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN0 : S (f x)) (IN1 : loc (f x) = y) : (E \\₁ (fun a : actid => is_init a)) (f x).","proofString":"apply IN_E.\nvauto."},{"statement":"(f : nat -> actid) (S : actid -> Prop) (locs : list (option location)) (IN_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (FIN : set_finite (⋃₁a ∈ fun a : option location => In a locs, f ↓₁ (S ∩₁ Loc_ a))) (x : nat) (y : option location) (IN0 : S (f x)) (IN1 : loc (f x) = y) : (f ↑₁ ⊤₁) (f x).","proofString":"vauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ppop ∪ fence ∪ rfe)).","proofString":"rewrite Power_ppo.ppo_in_sb, fence_in_sb, unionK, rfe_in_rf; auto.\nrewrite seq_union_r.\napply fsupp_union.\nby apply fsupp_sb.\neapply fsupp_mori; [| by apply fsupp_rf; eauto].\nred.\nbasic_solver."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (sb ∪ rf)).","proofString":"rewrite seq_union_r.\napply fsupp_union.\nby apply fsupp_sb.\neapply fsupp_mori; [| by apply fsupp_rf; eauto].\nred.\nbasic_solver."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rf).","proofString":"apply fsupp_union.\nby apply fsupp_sb.\neapply fsupp_mori; [| by apply fsupp_rf; eauto].\nred.\nbasic_solver."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"by apply fsupp_sb."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rf).","proofString":"eapply fsupp_mori; [| by apply fsupp_rf; eauto].\nred.\nbasic_solver."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) : flip inclusion rf (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rf).","proofString":"red.\nbasic_solver."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rf ⊆ rf.","proofString":"basic_solver."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) : forall i : nat, hbp⁻¹ (f i) (f (i + 1)).","proofString":"ins.\nred.\neapply seq_eqv_l.\neauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i0 : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i0 + 1)) (f i0)) (i : nat) : hbp⁻¹ (f i) (f (i + 1)).","proofString":"red.\neapply seq_eqv_l.\neauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i0 : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i0 + 1)) (f i0)) (i : nat) : hbp (f (i + 1)) (f i).","proofString":"eapply seq_eqv_l.\neauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e0 : actid, (E \\₁ (fun a : actid => is_init a)) e0 -> In (loc e0) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (i : nat) (DECR' : forall i0 : nat, hbp⁻¹ (f i0) (f (i0 + 1))) (e : actid) (Fie : f i = e) (DECR : (⦗set_compl (fun a : actid => is_init a)⦘\n ⨾ (⦗E⦘ ⨾ hbp ⨾ ⦗E⦘) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) \n  (f (i + 1)) (f i)) : (⦗set_compl (fun a : actid => is_init a)⦘\n ⨾ (⦗E⦘ ⨾ hbp ⨾ ⦗E⦘) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) \n  (f (i + 1)) (f i) -> (E \\₁ (fun a : actid => is_init a)) e.","proofString":"subst e.\nbasic_solver."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (i : nat) (DECR' : forall i0 : nat, hbp⁻¹ (f i0) (f (i0 + 1))) (DECR : (⦗set_compl (fun a : actid => is_init a)⦘\n ⨾ (⦗E⦘ ⨾ hbp ⨾ ⦗E⦘) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) \n  (f (i + 1)) (f i)) : (⦗set_compl (fun a : actid => is_init a)⦘\n ⨾ (⦗E⦘ ⨾ hbp ⨾ ⦗E⦘) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) \n  (f (i + 1)) (f i) -> (E \\₁ (fun a : actid => is_init a)) (f i).","proofString":"basic_solver."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (j : nat) (DECR : set_compl (fun a : actid => is_init a) (f (j + 1))) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : (f ↓₁ W) (j + 1) -> In (j + 1) iws) (wb : nat) (GE : j >= wb) (H : rfe (f (j + 1)) (f j)) : (f ↓₁ W) (j + 1).","proofString":"apply wf_rfeD, seq_eqv_lr in H; auto.\ndesc.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (j : nat) (DECR : set_compl (fun a : actid => is_init a) (f (j + 1))) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : (f ↓₁ W) (j + 1) -> In (j + 1) iws) (wb : nat) (GE : j >= wb) (H : is_w lab (f (j + 1)) /\\ rfe (f (j + 1)) (f j) /\\ is_r lab (f j)) : (f ↓₁ W) (j + 1).","proofString":"desc.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (j : nat) (DECR : set_compl (fun a : actid => is_init a) (f (j + 1))) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : (f ↓₁ W) (j + 1) -> In (j + 1) iws) (wb : nat) (GE : j >= wb) (H : is_w lab (f (j + 1))) (H0 : rfe (f (j + 1)) (f j)) (H1 : is_r lab (f j)) : (f ↓₁ W) (j + 1).","proofString":"vauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) : False.","proofString":"forward eapply fsupp_dom_enum with (f := fun k => f (wb + k))                                       (r := ⦗set_compl is_init⦘ ⨾ sb) as [].\nins.\napply seq_eqv_l.\nsplit.\napply ENUM_E.\nvauto.\nrewrite PeanoNat.Nat.add_assoc.\napply SB_STEPS.\nlia.\neapply acyclic_mori; [| by apply sb_acyclic].\nred.\nbasic_solver.\neapply fsupp_mori; [| by apply fsupp_sb; eauto].\nred.\nrewrite inclusion_ct_seq_eqv_l.\nrewrite ct_of_trans; vauto.\napply sb_trans."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) (f (wb + (i + 1)))\n  (f (wb + i)).","proofString":"ins.\napply seq_eqv_l.\nsplit.\napply ENUM_E.\nvauto.\nrewrite PeanoNat.Nat.add_assoc.\napply SB_STEPS.\nlia."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i0 : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i0 + 1)) (f i0)) (DECR' : forall i0 : nat, hbp⁻¹ (f i0) (f (i0 + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) (i : nat) : (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) (f (wb + (i + 1)))\n  (f (wb + i)).","proofString":"apply seq_eqv_l.\nsplit.\napply ENUM_E.\nvauto.\nrewrite PeanoNat.Nat.add_assoc.\napply SB_STEPS.\nlia."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i0 : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i0 + 1)) (f i0)) (DECR' : forall i0 : nat, hbp⁻¹ (f i0) (f (i0 + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) (i : nat) : set_compl (fun a : actid => is_init a) (f (wb + (i + 1))) /\\\nsb (f (wb + (i + 1))) (f (wb + i)).","proofString":"split.\napply ENUM_E.\nvauto.\nrewrite PeanoNat.Nat.add_assoc.\napply SB_STEPS.\nlia."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i0 : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i0 + 1)) (f i0)) (DECR' : forall i0 : nat, hbp⁻¹ (f i0) (f (i0 + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) (i : nat) : set_compl (fun a : actid => is_init a) (f (wb + (i + 1))).","proofString":"apply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i0 : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i0 + 1)) (f i0)) (DECR' : forall i0 : nat, hbp⁻¹ (f i0) (f (i0 + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) (i : nat) : (f ↑₁ ⊤₁) (f (wb + (i + 1))).","proofString":"vauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i0 : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i0 + 1)) (f i0)) (DECR' : forall i0 : nat, hbp⁻¹ (f i0) (f (i0 + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) (i : nat) : sb (f (wb + (i + 1))) (f (wb + i)).","proofString":"rewrite PeanoNat.Nat.add_assoc.\napply SB_STEPS.\nlia."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i0 : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i0 + 1)) (f i0)) (DECR' : forall i0 : nat, hbp⁻¹ (f i0) (f (i0 + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) (i : nat) : sb (f (wb + i + 1)) (f (wb + i)).","proofString":"apply SB_STEPS.\nlia."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i0 : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i0 + 1)) (f i0)) (DECR' : forall i0 : nat, hbp⁻¹ (f i0) (f (i0 + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) (i : nat) : wb + i >= wb.","proofString":"lia."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) : acyclic (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"eapply acyclic_mori; [| by apply sb_acyclic].\nred.\nbasic_solver."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)⁺.","proofString":"eapply fsupp_mori; [| by apply fsupp_sb; eauto].\nred.\nrewrite inclusion_ct_seq_eqv_l.\nrewrite ct_of_trans; vauto.\napply sb_trans."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) : flip inclusion (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)⁺.","proofString":"red.\nrewrite inclusion_ct_seq_eqv_l.\nrewrite ct_of_trans; vauto.\napply sb_trans."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) : (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)⁺\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb.","proofString":"rewrite inclusion_ct_seq_eqv_l.\nrewrite ct_of_trans; vauto.\napply sb_trans."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb⁺\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb.","proofString":"rewrite ct_of_trans; vauto.\napply sb_trans."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (iws : list nat) (FINW : forall x : nat, (f ↓₁ W) x -> In x iws) (wb : nat) (SB_STEPS : forall j : nat, j >= wb -> sb (f (j + 1)) (f j)) : transitive sb.","proofString":"apply sb_trans."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (Ll : In None locs) : set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ None)).","proofString":"exists [].\nunfolder.\nins.\ndesc.\nforward eapply is_w_loc; eauto.\nins.\ndesc.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (Ll : In None locs) : forall x : nat, (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ None)) x -> In x [].","proofString":"unfolder.\nins.\ndesc.\nforward eapply is_w_loc; eauto.\nins.\ndesc.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (Ll : In None locs) : forall x : nat,\n(is_w lab (f x) /\\ tid (f x) = t) /\\ loc (f x) = None -> In x [].","proofString":"ins.\ndesc.\nforward eapply is_w_loc; eauto.\nins.\ndesc.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (Ll : In None locs) (x : nat) (IN : (is_w lab (f x) /\\ tid (f x) = t) /\\ loc (f x) = None) : False.","proofString":"desc.\nforward eapply is_w_loc; eauto.\nins.\ndesc.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (Ll : In None locs) (x : nat) (IN : is_w lab (f x)) (IN1 : tid (f x) = t) (IN0 : loc (f x) = None) : False.","proofString":"forward eapply is_w_loc; eauto.\nins.\ndesc.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (Ll : In None locs) (x : nat) (IN : is_w lab (f x)) (IN1 : tid (f x) = t) (IN0 : loc (f x) = None) : (exists l : location, loc (f x) = Some l) -> False.","proofString":"ins.\ndesc.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (Ll : In None locs) (x : nat) (IN : is_w lab (f x)) (IN1 : tid (f x) = t) (IN0 : loc (f x) = None) (H : exists l : location, loc (f x) = Some l) : False.","proofString":"desc.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (Ll : In None locs) (x : nat) (IN : is_w lab (f x)) (IN1 : tid (f x) = t) (IN0 : loc (f x) = None) (l : location) (H : loc (f x) = Some l) : False.","proofString":"vauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) : ~\nset_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))).","proofString":"intros FIN.\ndestruct INFtl.\neapply set_finite_mori; eauto.\nred.\nrewrite set_map_inter with (d := _ \\₁ _).\napply set_subset_inter_r.\nsplit; [| basic_solver].\nred.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) : False.","proofString":"destruct INFtl.\neapply set_finite_mori; eauto.\nred.\nrewrite set_map_inter with (d := _ \\₁ _).\napply set_subset_inter_r.\nsplit; [| basic_solver].\nred.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) : set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))).","proofString":"eapply set_finite_mori; eauto.\nred.\nrewrite set_map_inter with (d := _ \\₁ _).\napply set_subset_inter_r.\nsplit; [| basic_solver].\nred.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) : flip set_subset\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))\n  (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))).","proofString":"red.\nrewrite set_map_inter with (d := _ \\₁ _).\napply set_subset_inter_r.\nsplit; [| basic_solver].\nred.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) : f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))\n⊆₁ f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))).","proofString":"rewrite set_map_inter with (d := _ \\₁ _).\napply set_subset_inter_r.\nsplit; [| basic_solver].\nred.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) : f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))\n⊆₁ f ↓₁ (E \\₁ (fun a : actid => is_init a))\n   ∩₁ f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)).","proofString":"apply set_subset_inter_r.\nsplit; [| basic_solver].\nred.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) : f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))\n⊆₁ f ↓₁ (E \\₁ (fun a : actid => is_init a)) /\\\nf ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)) ⊆₁ f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)).","proofString":"split; [| basic_solver].\nred.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) : f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))\n⊆₁ f ↓₁ (E \\₁ (fun a : actid => is_init a)).","proofString":"red.\nins.\nred.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) : forall x : nat,\n(f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))) x ->\n(f ↓₁ (E \\₁ (fun a : actid => is_init a))) x.","proofString":"ins.\nred.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) (x : nat) (H : (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))) x) : (f ↓₁ (E \\₁ (fun a : actid => is_init a))) x.","proofString":"red.\nred in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) (x : nat) (H : (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))) x) : (E \\₁ (fun a : actid => is_init a)) (f x).","proofString":"red in H.\napply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) (x : nat) (H : (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)) (f x)) : (E \\₁ (fun a : actid => is_init a)) (f x).","proofString":"apply ENUM_E.\nvauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (FIN : set_finite\n  (f\n   ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))))) (x : nat) (H : (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)) (f x)) : (f ↑₁ ⊤₁) (f x).","proofString":"vauto."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) : is_total\n  ((E \\₁ (fun a : actid => is_init a)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))\n  (sb ∩ same_loc).","proofString":"red.\nins.\nforward eapply sb_total with (a := a) (b := b0) (t := t) as SB;      try by (generalize IWa; generalize IWb; vauto || basic_solver).\nunfolder in IWa.\nunfolder in IWb.\ndesc.\ndes; [left | right]; split; congruence."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a0 : actid => is_init a0)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a0 : actid => is_init a0)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a0 : actid => is_init a0)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) (a : actid) (IWa : ((E \\₁ (fun a0 : actid => is_init a0)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))) a) (b0 : actid) (IWb : ((E \\₁ (fun a0 : actid => is_init a0)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))) b0) (NEQ : a <> b0) : (sb ∩ same_loc) a b0 \\/ (sb ∩ same_loc) b0 a.","proofString":"forward eapply sb_total with (a := a) (b := b0) (t := t) as SB;      try by (generalize IWa; generalize IWb; vauto || basic_solver).\nunfolder in IWa.\nunfolder in IWb.\ndesc.\ndes; [left | right]; split; congruence."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a0 : actid => is_init a0)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a0 : actid => is_init a0)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a0 : actid => is_init a0)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) (a : actid) (IWa : ((E \\₁ (fun a0 : actid => is_init a0)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))) a) (b0 : actid) (IWb : ((E \\₁ (fun a0 : actid => is_init a0)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))) b0) (NEQ : a <> b0) (SB : sb a b0 \\/ sb b0 a) : (sb ∩ same_loc) a b0 \\/ (sb ∩ same_loc) b0 a.","proofString":"unfolder in IWa.\nunfolder in IWb.\ndesc.\ndes; [left | right]; split; congruence."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a0 : actid => is_init a0)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a0 : actid => is_init a0)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a0 : actid => is_init a0)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) (a : actid) (IWa : (E a /\\ ~ is_init a) /\\ (is_w lab a /\\ tid a = t) /\\ loc a = Some l) (b0 : actid) (IWb : ((E \\₁ (fun a0 : actid => is_init a0)) ∩₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l))) b0) (NEQ : a <> b0) (SB : sb a b0 \\/ sb b0 a) : (sb ∩ same_loc) a b0 \\/ (sb ∩ same_loc) b0 a.","proofString":"unfolder in IWb.\ndesc.\ndes; [left | right]; split; congruence."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a0 : actid => is_init a0)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a0 : actid => is_init a0)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a0 : actid => is_init a0)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) (a : actid) (IWa : (E a /\\ ~ is_init a) /\\ (is_w lab a /\\ tid a = t) /\\ loc a = Some l) (b0 : actid) (IWb : (E b0 /\\ ~ is_init b0) /\\ (is_w lab b0 /\\ tid b0 = t) /\\ loc b0 = Some l) (NEQ : a <> b0) (SB : sb a b0 \\/ sb b0 a) : (sb ∩ same_loc) a b0 \\/ (sb ∩ same_loc) b0 a.","proofString":"desc.\ndes; [left | right]; split; congruence."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a0 : actid => is_init a0)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a0 : actid => is_init a0)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a0 : actid => is_init a0)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) (a : actid) (IWa : E a) (IWa3 : ~ is_init a) (IWa0 : is_w lab a) (IWa2 : tid a = t) (IWa1 : loc a = Some l) (b0 : actid) (IWb : E b0) (IWb3 : ~ is_init b0) (IWb0 : is_w lab b0) (IWb2 : tid b0 = t) (IWb1 : loc b0 = Some l) (NEQ : a <> b0) (SB : sb a b0 \\/ sb b0 a) : (sb ∩ same_loc) a b0 \\/ (sb ∩ same_loc) b0 a.","proofString":"des; [left | right]; split; congruence."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) : acyclic hbp.","proofString":"by apply CON."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) : fsupp (sb ∩ same_loc).","proofString":"by apply fsupp_sb_loc."},{"statement":"(locs : list (option location)) (FINLOCS : forall e : actid, (E \\₁ (fun a : actid => is_init a)) e -> In (loc e) locs) (b : thread_id) (FINTHREADS : threads_bound G b) (WF : Wf G) (f : nat -> actid) (DECR : forall i : nat,\n(⦗set_compl (fun a : actid => is_init a)⦘ ⨾ hbp) (f (i + 1)) (f i)) (DECR' : forall i : nat, hbp⁻¹ (f i) (f (i + 1))) (ENUM_E : f ↑₁ ⊤₁ ⊆₁ E \\₁ (fun a : actid => is_init a)) (t : BinNums.positive) (TBt : BinPos.Pos.lt t b) (l : location) (Ll : In (Some l) locs) (INFtl : ~ set_finite (f ↓₁ (W ∩₁ Tid_ t ∩₁ Loc_ (Some l)))) : hbp⁺ ⨾ sb ∩ same_loc ⊆ hbp⁺.","proofString":"apply hb_po_loc_hb."}]}