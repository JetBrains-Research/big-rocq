{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/ConstpropOpproof.v","fileSamples":[{"statement":"(r : positive) (id : AST.ident) (ofs : ptrofs) (H : AE.get r ae = Ptr (Gl id ofs)) : Val.lessdef e # r (Genv.symbol_address ge id ofs).","proofString":"apply vmatch_ptr_gl with bc; auto.\nrewrite <- H.\napply MATCH."},{"statement":"(r : positive) (id : AST.ident) (ofs : ptrofs) (H : AE.get r ae = Ptr (Gl id ofs)) : vmatch bc e # r (Ptr (Gl id ofs)).","proofString":"rewrite <- H.\napply MATCH."},{"statement":"(r : positive) (id : AST.ident) (ofs : ptrofs) (H : AE.get r ae = Ptr (Gl id ofs)) : vmatch bc e # r (AE.get r ae).","proofString":"apply MATCH."},{"statement":"(r : positive) (ofs : ptrofs) (H : AE.get r ae = Ptr (Stk ofs)) : Val.lessdef e # r (Vptr sp ofs).","proofString":"apply vmatch_ptr_stk with bc; auto.\nrewrite <- H.\napply MATCH."},{"statement":"(r : positive) (ofs : ptrofs) (H : AE.get r ae = Ptr (Stk ofs)) : vmatch bc e # r (Ptr (Stk ofs)).","proofString":"rewrite <- H.\napply MATCH."},{"statement":"(r : positive) (ofs : ptrofs) (H : AE.get r ae = Ptr (Stk ofs)) : vmatch bc e # r (AE.get r ae).","proofString":"apply MATCH."},{"statement":"(n : int) (v : val) (H : v = Vint n) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst n) nil m = Some v' /\\\n  Val.lessdef (Vint n) v'.","proofString":"exists (Vint n); auto."},{"statement":"(n : int) (v : val) (H0 : vmatch bc v (IU n)) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst n) nil m = Some v' /\\\n  Val.lessdef v v'.","proofString":"exists (Vint n); split; auto.\ninv H0; auto."},{"statement":"(n : int) (v : val) (H0 : vmatch bc v (IU n)) : Val.lessdef v (Vint n).","proofString":"inv H0; auto."},{"statement":"(n : int64) (v : val) (H : v = Vlong n) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Olongconst n) nil m = Some v' /\\\n  Val.lessdef (Vlong n) v'.","proofString":"exists (Vlong n); auto."},{"statement":"(f : float) (op : operation) (v : val) (H2 : (if generate_float_constants tt then Some (Ofloatconst f) else None) =\nSome op) (H : v = Vfloat f) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op nil m = Some v' /\\\n  Val.lessdef (Vfloat f) v'.","proofString":"destruct (Compopts.generate_float_constants tt); inv H2.\nexists (Vfloat f); auto."},{"statement":"(f : float) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ofloatconst f) nil m = Some v' /\\\n  Val.lessdef (Vfloat f) v'.","proofString":"exists (Vfloat f); auto."},{"statement":"(f : float32) (op : operation) (v : val) (H2 : (if generate_float_constants tt then Some (Osingleconst f) else None) =\nSome op) (H : v = Vsingle f) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op nil m = Some v' /\\\n  Val.lessdef (Vsingle f) v'.","proofString":"destruct (Compopts.generate_float_constants tt); inv H2.\nexists (Vsingle f); auto."},{"statement":"(f : float32) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Osingleconst f) nil m = Some v' /\\\n  Val.lessdef (Vsingle f) v'.","proofString":"exists (Vsingle f); auto."},{"statement":"(p : aptr) (op : operation) (v : val) (H0 : vmatch bc v (Ptr p)) (H2 : match p with\n| Gl id ofs => Some (Oaddrsymbol id ofs)\n| Stk ofs => Some (Oaddrstack ofs)\n| _ => None\nend = Some op) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op nil m = Some v' /\\\n  Val.lessdef v v'.","proofString":"destruct p; try discriminate; SimplVM.\ninv H2.\nexists (Genv.symbol_address ge id ofs); auto.\ninv H2.\nexists (Vptr sp ofs); split; auto.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(id : AST.ident) (ofs : ptrofs) (op : operation) (v : val) (H2 : Some (Oaddrsymbol id ofs) = Some op) (H : Val.lessdef v (Genv.symbol_address ge id ofs)) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op nil m = Some v' /\\\n  Val.lessdef v v'.","proofString":"inv H2.\nexists (Genv.symbol_address ge id ofs); auto."},{"statement":"(id : AST.ident) (ofs : ptrofs) (v : val) (H : Val.lessdef v (Genv.symbol_address ge id ofs)) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oaddrsymbol id ofs) nil m =\n  Some v' /\\ Val.lessdef v v'.","proofString":"exists (Genv.symbol_address ge id ofs); auto."},{"statement":"(ofs : ptrofs) (op : operation) (v : val) (H2 : Some (Oaddrstack ofs) = Some op) (H : Val.lessdef v (Vptr sp ofs)) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op nil m = Some v' /\\\n  Val.lessdef v v'.","proofString":"inv H2.\nexists (Vptr sp ofs); split; auto.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(ofs : ptrofs) (v : val) (H : Val.lessdef v (Vptr sp ofs)) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oaddrstack ofs) nil m = Some v' /\\\n  Val.lessdef v v'.","proofString":"exists (Vptr sp ofs); split; auto.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(ofs : ptrofs) (v : val) (H : Val.lessdef v (Vptr sp ofs)) : eval_operation ge (Vptr sp Ptrofs.zero) (Oaddrstack ofs) nil m =\nSome (Vptr sp ofs).","proofString":"simpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(ofs : ptrofs) (v : val) (H : Val.lessdef v (Vptr sp ofs)) : Some (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) = Some (Vptr sp ofs).","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) : vl = map (fun r : positive => AE.get r ae) args ->\nlet (cond', args') := cond_strength_reduction cond args vl in\neval_condition cond' e ## args' m = eval_condition cond e ## args m.","proofString":"unfold cond_strength_reduction.\ncase (cond_strength_reduction_match cond args vl); simpl; intros; InvApproxRegs; SimplVM.\napply Val.swap_cmp_bool.\nauto.\napply Val.swap_cmpu_bool.\nauto.\nrewrite eval_static_shift_correct; auto.\nrewrite eval_static_shift_correct; auto.\napply Val.swap_cmpl_bool.\nauto.\napply Val.swap_cmplu_bool.\nauto.\nrewrite eval_static_shiftl_correct; auto.\nrewrite eval_static_shiftl_correct; auto.\ndestruct (Float.eq_dec n1 Float.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float.eq_dec n2 Float.zero).\nsubst n2.\nsimpl.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float.eq_dec n1 Float.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float.eq_dec n2 Float.zero); simpl; auto.\nsubst n2; auto.\nrewrite H1; auto.\ndestruct (Float32.eq_dec n1 Float32.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float32.eq_dec n2 Float32.zero).\nsubst n2.\nsimpl.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float32.eq_dec n1 Float32.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float32.eq_dec n2 Float32.zero); simpl; auto.\nsubst n2; auto.\nrewrite H1; auto.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) : vl = map (fun r : positive => AE.get r ae) args ->\nlet (cond', args') :=\n  match cond_strength_reduction_match cond args vl with\n  | cond_strength_reduction_case1 c _ r2 n1 _ =>\n      (Ccompimm (swap_comparison c) n1, r2 :: nil)\n  | cond_strength_reduction_case2 c r1 _ _ n2 => (Ccompimm c n2, r1 :: nil)\n  | cond_strength_reduction_case3 c _ r2 n1 _ =>\n      (Ccompuimm (swap_comparison c) n1, r2 :: nil)\n  | cond_strength_reduction_case4 c r1 _ _ n2 => (Ccompuimm c n2, r1 :: nil)\n  | cond_strength_reduction_case5 c s a r1 _ _ n2 =>\n      (Ccompimm c (eval_static_shift s n2 a), r1 :: nil)\n  | cond_strength_reduction_case6 c s a r1 _ _ n2 =>\n      (Ccompuimm c (eval_static_shift s n2 a), r1 :: nil)\n  | cond_strength_reduction_case7 c _ r2 n1 _ =>\n      (Ccomplimm (swap_comparison c) n1, r2 :: nil)\n  | cond_strength_reduction_case8 c r1 _ _ n2 => (Ccomplimm c n2, r1 :: nil)\n  | cond_strength_reduction_case9 c _ r2 n1 _ =>\n      (Ccompluimm (swap_comparison c) n1, r2 :: nil)\n  | cond_strength_reduction_case10 c r1 _ _ n2 =>\n      (Ccompluimm c n2, r1 :: nil)\n  | cond_strength_reduction_case11 c s a r1 _ _ n2 =>\n      (Ccomplimm c (eval_static_shiftl s n2 a), r1 :: nil)\n  | cond_strength_reduction_case12 c s a r1 _ _ n2 =>\n      (Ccompluimm c (eval_static_shiftl s n2 a), r1 :: nil)\n  | cond_strength_reduction_case13 c _ r2 n1 _ =>\n      if Float.eq_dec n1 Float.zero\n      then (Ccompfzero (swap_comparison c), r2 :: nil)\n      else (cond, args)\n  | cond_strength_reduction_case14 c r1 _ _ n2 =>\n      if Float.eq_dec n2 Float.zero\n      then (Ccompfzero c, r1 :: nil)\n      else (cond, args)\n  | cond_strength_reduction_case15 c _ r2 n1 _ =>\n      if Float.eq_dec n1 Float.zero\n      then (Cnotcompfzero (swap_comparison c), r2 :: nil)\n      else (cond, args)\n  | cond_strength_reduction_case16 c r1 _ _ n2 =>\n      if Float.eq_dec n2 Float.zero\n      then (Cnotcompfzero c, r1 :: nil)\n      else (cond, args)\n  | cond_strength_reduction_case17 c _ r2 n1 _ =>\n      if Float32.eq_dec n1 Float32.zero\n      then (Ccompfszero (swap_comparison c), r2 :: nil)\n      else (cond, args)\n  | cond_strength_reduction_case18 c r1 _ _ n2 =>\n      if Float32.eq_dec n2 Float32.zero\n      then (Ccompfszero c, r1 :: nil)\n      else (cond, args)\n  | cond_strength_reduction_case19 c _ r2 n1 _ =>\n      if Float32.eq_dec n1 Float32.zero\n      then (Cnotcompfszero (swap_comparison c), r2 :: nil)\n      else (cond, args)\n  | cond_strength_reduction_case20 c r1 _ _ n2 =>\n      if Float32.eq_dec n2 Float32.zero\n      then (Cnotcompfszero c, r1 :: nil)\n      else (cond, args)\n  | cond_strength_reduction_default cond0 args0 _ => (cond0, args0)\n  end in\neval_condition cond' e ## args' m = eval_condition cond e ## args m.","proofString":"case (cond_strength_reduction_match cond args vl); simpl; intros; InvApproxRegs; SimplVM.\napply Val.swap_cmp_bool.\nauto.\napply Val.swap_cmpu_bool.\nauto.\nrewrite eval_static_shift_correct; auto.\nrewrite eval_static_shift_correct; auto.\napply Val.swap_cmpl_bool.\nauto.\napply Val.swap_cmplu_bool.\nauto.\nrewrite eval_static_shiftl_correct; auto.\nrewrite eval_static_shiftl_correct; auto.\ndestruct (Float.eq_dec n1 Float.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float.eq_dec n2 Float.zero).\nsubst n2.\nsimpl.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float.eq_dec n1 Float.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float.eq_dec n2 Float.zero); simpl; auto.\nsubst n2; auto.\nrewrite H1; auto.\ndestruct (Float32.eq_dec n1 Float32.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float32.eq_dec n2 Float32.zero).\nsubst n2.\nsimpl.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float32.eq_dec n1 Float32.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto.\ndestruct (Float32.eq_dec n2 Float32.zero); simpl; auto.\nsubst n2; auto.\nrewrite H1; auto.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vint n1) : Val.cmp_bool (swap_comparison c) e # r2 (Vint n1) =\nVal.cmp_bool c (Vint n1) e # r2.","proofString":"apply Val.swap_cmp_bool."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : int) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vint n2) : Val.cmp_bool c e # r1 (Vint n2) = Val.cmp_bool c e # r1 (Vint n2).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vint n1) : Val.cmpu_bool (Mem.valid_pointer m) (swap_comparison c) e # r2 (Vint n1) =\nVal.cmpu_bool (Mem.valid_pointer m) c (Vint n1) e # r2.","proofString":"apply Val.swap_cmpu_bool."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : int) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vint n2) : Val.cmpu_bool (Mem.valid_pointer m) c e # r1 (Vint n2) =\nVal.cmpu_bool (Mem.valid_pointer m) c e # r1 (Vint n2).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vint n2) : Val.cmp_bool c e # r1 (Vint (eval_static_shift s n2 a)) =\nVal.cmp_bool c e # r1 (eval_shift s (Vint n2) a).","proofString":"rewrite eval_static_shift_correct; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vint n2) : Val.cmpu_bool (Mem.valid_pointer m) c e # r1\n  (Vint (eval_static_shift s n2 a)) =\nVal.cmpu_bool (Mem.valid_pointer m) c e # r1 (eval_shift s (Vint n2) a).","proofString":"rewrite eval_static_shift_correct; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vlong n1) : Val.cmpl_bool (swap_comparison c) e # r2 (Vlong n1) =\nVal.cmpl_bool c (Vlong n1) e # r2.","proofString":"apply Val.swap_cmpl_bool."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vlong n2) : Val.cmpl_bool c e # r1 (Vlong n2) = Val.cmpl_bool c e # r1 (Vlong n2).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vlong n1) : Val.cmplu_bool (Mem.valid_pointer m) (swap_comparison c) e # r2 (Vlong n1) =\nVal.cmplu_bool (Mem.valid_pointer m) c (Vlong n1) e # r2.","proofString":"apply Val.swap_cmplu_bool."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vlong n2) : Val.cmplu_bool (Mem.valid_pointer m) c e # r1 (Vlong n2) =\nVal.cmplu_bool (Mem.valid_pointer m) c e # r1 (Vlong n2).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vlong n2) : Val.cmpl_bool c e # r1 (Vlong (eval_static_shiftl s n2 a)) =\nVal.cmpl_bool c e # r1 (eval_shiftl s (Vlong n2) a).","proofString":"rewrite eval_static_shiftl_correct; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vlong n2) : Val.cmplu_bool (Mem.valid_pointer m) c e # r1\n  (Vlong (eval_static_shiftl s n2 a)) =\nVal.cmplu_bool (Mem.valid_pointer m) c e # r1 (eval_shiftl s (Vlong n2) a).","proofString":"rewrite eval_static_shiftl_correct; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat n1) : let (cond', args') :=\n  if Float.eq_dec n1 Float.zero\n  then (Ccompfzero (swap_comparison c), r2 :: nil)\n  else (Ccompf c, r1 :: r2 :: nil) in\neval_condition cond' e ## args' m = Val.cmpf_bool c (Vfloat n1) e # r2.","proofString":"destruct (Float.eq_dec n1 Float.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat n1) (e0 : n1 = Float.zero) : eval_condition (Ccompfzero (swap_comparison c)) e ## (r2 :: nil) m =\nVal.cmpf_bool c (Vfloat n1) e # r2.","proofString":"subst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat Float.zero) : eval_condition (Ccompfzero (swap_comparison c)) e ## (r2 :: nil) m =\nVal.cmpf_bool c (Vfloat Float.zero) e # r2.","proofString":"simpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat Float.zero) : Val.cmpf_bool (swap_comparison c) e # r2 (Vfloat Float.zero) =\nmatch e # r2 with\n| Vfloat f2 => Some (Float.cmp c Float.zero f2)\n| _ => None\nend.","proofString":"destruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (f : float) (H : vmatch bc (Vfloat f) v2) (H1 : e # r1 = Vfloat Float.zero) : Some (Float.cmp (swap_comparison c) f Float.zero) =\nSome (Float.cmp c Float.zero f).","proofString":"rewrite Float.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (f : float) (H : vmatch bc (Vfloat f) v2) (H1 : e # r1 = Vfloat Float.zero) : Some (Float.cmp c Float.zero f) = Some (Float.cmp c Float.zero f).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat n1) (n : n1 <> Float.zero) : eval_condition (Ccompf c) e ## (r1 :: r2 :: nil) m =\nVal.cmpf_bool c (Vfloat n1) e # r2.","proofString":"simpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat n1) (n : n1 <> Float.zero) : Val.cmpf_bool c e # r1 e # r2 =\nmatch e # r2 with\n| Vfloat f2 => Some (Float.cmp c n1 f2)\n| _ => None\nend.","proofString":"rewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vfloat n2) : let (cond', args') :=\n  if Float.eq_dec n2 Float.zero\n  then (Ccompfzero c, r1 :: nil)\n  else (Ccompf c, r1 :: r2 :: nil) in\neval_condition cond' e ## args' m = Val.cmpf_bool c e # r1 (Vfloat n2).","proofString":"destruct (Float.eq_dec n2 Float.zero).\nsubst n2.\nsimpl.\nauto.\nsimpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vfloat n2) (e0 : n2 = Float.zero) : eval_condition (Ccompfzero c) e ## (r1 :: nil) m =\nVal.cmpf_bool c e # r1 (Vfloat n2).","proofString":"subst n2.\nsimpl.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vfloat Float.zero) : eval_condition (Ccompfzero c) e ## (r1 :: nil) m =\nVal.cmpf_bool c e # r1 (Vfloat Float.zero).","proofString":"simpl.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vfloat Float.zero) : Val.cmpf_bool c e # r1 (Vfloat Float.zero) =\nVal.cmpf_bool c e # r1 (Vfloat Float.zero).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vfloat n2) (n : n2 <> Float.zero) : eval_condition (Ccompf c) e ## (r1 :: r2 :: nil) m =\nVal.cmpf_bool c e # r1 (Vfloat n2).","proofString":"simpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vfloat n2) (n : n2 <> Float.zero) : Val.cmpf_bool c e # r1 e # r2 = Val.cmpf_bool c e # r1 (Vfloat n2).","proofString":"rewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat n1) : let (cond', args') :=\n  if Float.eq_dec n1 Float.zero\n  then (Cnotcompfzero (swap_comparison c), r2 :: nil)\n  else (Cnotcompf c, r1 :: r2 :: nil) in\neval_condition cond' e ## args' m =\noption_map negb (Val.cmpf_bool c (Vfloat n1) e # r2).","proofString":"destruct (Float.eq_dec n1 Float.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat n1) (e0 : n1 = Float.zero) : eval_condition (Cnotcompfzero (swap_comparison c)) e ## (r2 :: nil) m =\noption_map negb (Val.cmpf_bool c (Vfloat n1) e # r2).","proofString":"subst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat Float.zero) : eval_condition (Cnotcompfzero (swap_comparison c)) e ## (r2 :: nil) m =\noption_map negb (Val.cmpf_bool c (Vfloat Float.zero) e # r2).","proofString":"simpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat Float.zero) : option_map negb\n  (Val.cmpf_bool (swap_comparison c) e # r2 (Vfloat Float.zero)) =\noption_map negb\n  match e # r2 with\n  | Vfloat f2 => Some (Float.cmp c Float.zero f2)\n  | _ => None\n  end.","proofString":"destruct (e#r2); simpl; auto.\nrewrite Float.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (f : float) (H : vmatch bc (Vfloat f) v2) (H1 : e # r1 = Vfloat Float.zero) : Some (negb (Float.cmp (swap_comparison c) f Float.zero)) =\nSome (negb (Float.cmp c Float.zero f)).","proofString":"rewrite Float.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (f : float) (H : vmatch bc (Vfloat f) v2) (H1 : e # r1 = Vfloat Float.zero) : Some (negb (Float.cmp c Float.zero f)) =\nSome (negb (Float.cmp c Float.zero f)).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat n1) (n : n1 <> Float.zero) : eval_condition (Cnotcompf c) e ## (r1 :: r2 :: nil) m =\noption_map negb (Val.cmpf_bool c (Vfloat n1) e # r2).","proofString":"simpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vfloat n1) (n : n1 <> Float.zero) : option_map negb (Val.cmpf_bool c e # r1 e # r2) =\noption_map negb\n  match e # r2 with\n  | Vfloat f2 => Some (Float.cmp c n1 f2)\n  | _ => None\n  end.","proofString":"rewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vfloat n2) : let (cond', args') :=\n  if Float.eq_dec n2 Float.zero\n  then (Cnotcompfzero c, r1 :: nil)\n  else (Cnotcompf c, r1 :: r2 :: nil) in\neval_condition cond' e ## args' m =\noption_map negb (Val.cmpf_bool c e # r1 (Vfloat n2)).","proofString":"destruct (Float.eq_dec n2 Float.zero); simpl; auto.\nsubst n2; auto.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vfloat n2) (e0 : n2 = Float.zero) : option_map negb (Val.cmpf_bool c e # r1 (Vfloat Float.zero)) =\noption_map negb (Val.cmpf_bool c e # r1 (Vfloat n2)).","proofString":"subst n2; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vfloat n2) (n : n2 <> Float.zero) : option_map negb (Val.cmpf_bool c e # r1 e # r2) =\noption_map negb (Val.cmpf_bool c e # r1 (Vfloat n2)).","proofString":"rewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle n1) : let (cond', args') :=\n  if Float32.eq_dec n1 Float32.zero\n  then (Ccompfszero (swap_comparison c), r2 :: nil)\n  else (Ccompfs c, r1 :: r2 :: nil) in\neval_condition cond' e ## args' m = Val.cmpfs_bool c (Vsingle n1) e # r2.","proofString":"destruct (Float32.eq_dec n1 Float32.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle n1) (e0 : n1 = Float32.zero) : eval_condition (Ccompfszero (swap_comparison c)) e ## (r2 :: nil) m =\nVal.cmpfs_bool c (Vsingle n1) e # r2.","proofString":"subst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle Float32.zero) : eval_condition (Ccompfszero (swap_comparison c)) e ## (r2 :: nil) m =\nVal.cmpfs_bool c (Vsingle Float32.zero) e # r2.","proofString":"simpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle Float32.zero) : Val.cmpfs_bool (swap_comparison c) e # r2 (Vsingle Float32.zero) =\nmatch e # r2 with\n| Vsingle f2 => Some (Float32.cmp c Float32.zero f2)\n| _ => None\nend.","proofString":"destruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (f : float32) (H : vmatch bc (Vsingle f) v2) (H1 : e # r1 = Vsingle Float32.zero) : Some (Float32.cmp (swap_comparison c) f Float32.zero) =\nSome (Float32.cmp c Float32.zero f).","proofString":"rewrite Float32.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (f : float32) (H : vmatch bc (Vsingle f) v2) (H1 : e # r1 = Vsingle Float32.zero) : Some (Float32.cmp c Float32.zero f) = Some (Float32.cmp c Float32.zero f).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle n1) (n : n1 <> Float32.zero) : eval_condition (Ccompfs c) e ## (r1 :: r2 :: nil) m =\nVal.cmpfs_bool c (Vsingle n1) e # r2.","proofString":"simpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle n1) (n : n1 <> Float32.zero) : Val.cmpfs_bool c e # r1 e # r2 =\nmatch e # r2 with\n| Vsingle f2 => Some (Float32.cmp c n1 f2)\n| _ => None\nend.","proofString":"rewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vsingle n2) : let (cond', args') :=\n  if Float32.eq_dec n2 Float32.zero\n  then (Ccompfszero c, r1 :: nil)\n  else (Ccompfs c, r1 :: r2 :: nil) in\neval_condition cond' e ## args' m = Val.cmpfs_bool c e # r1 (Vsingle n2).","proofString":"destruct (Float32.eq_dec n2 Float32.zero).\nsubst n2.\nsimpl.\nauto.\nsimpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vsingle n2) (e0 : n2 = Float32.zero) : eval_condition (Ccompfszero c) e ## (r1 :: nil) m =\nVal.cmpfs_bool c e # r1 (Vsingle n2).","proofString":"subst n2.\nsimpl.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vsingle Float32.zero) : eval_condition (Ccompfszero c) e ## (r1 :: nil) m =\nVal.cmpfs_bool c e # r1 (Vsingle Float32.zero).","proofString":"simpl.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vsingle Float32.zero) : Val.cmpfs_bool c e # r1 (Vsingle Float32.zero) =\nVal.cmpfs_bool c e # r1 (Vsingle Float32.zero).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vsingle n2) (n : n2 <> Float32.zero) : eval_condition (Ccompfs c) e ## (r1 :: r2 :: nil) m =\nVal.cmpfs_bool c e # r1 (Vsingle n2).","proofString":"simpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vsingle n2) (n : n2 <> Float32.zero) : Val.cmpfs_bool c e # r1 e # r2 = Val.cmpfs_bool c e # r1 (Vsingle n2).","proofString":"rewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle n1) : let (cond', args') :=\n  if Float32.eq_dec n1 Float32.zero\n  then (Cnotcompfszero (swap_comparison c), r2 :: nil)\n  else (Cnotcompfs c, r1 :: r2 :: nil) in\neval_condition cond' e ## args' m =\noption_map negb (Val.cmpfs_bool c (Vsingle n1) e # r2).","proofString":"destruct (Float32.eq_dec n1 Float32.zero).\nsubst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto.\nsimpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle n1) (e0 : n1 = Float32.zero) : eval_condition (Cnotcompfszero (swap_comparison c)) e ## (r2 :: nil) m =\noption_map negb (Val.cmpfs_bool c (Vsingle n1) e # r2).","proofString":"subst n1.\nsimpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle Float32.zero) : eval_condition (Cnotcompfszero (swap_comparison c)) e ## (r2 :: nil) m =\noption_map negb (Val.cmpfs_bool c (Vsingle Float32.zero) e # r2).","proofString":"simpl.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle Float32.zero) : option_map negb\n  (Val.cmpfs_bool (swap_comparison c) e # r2 (Vsingle Float32.zero)) =\noption_map negb\n  match e # r2 with\n  | Vsingle f2 => Some (Float32.cmp c Float32.zero f2)\n  | _ => None\n  end.","proofString":"destruct (e#r2); simpl; auto.\nrewrite Float32.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (f : float32) (H : vmatch bc (Vsingle f) v2) (H1 : e # r1 = Vsingle Float32.zero) : Some (negb (Float32.cmp (swap_comparison c) f Float32.zero)) =\nSome (negb (Float32.cmp c Float32.zero f)).","proofString":"rewrite Float32.cmp_swap.\nauto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v2 : aval) (f : float32) (H : vmatch bc (Vsingle f) v2) (H1 : e # r1 = Vsingle Float32.zero) : Some (negb (Float32.cmp c Float32.zero f)) =\nSome (negb (Float32.cmp c Float32.zero f)).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle n1) (n : n1 <> Float32.zero) : eval_condition (Cnotcompfs c) e ## (r1 :: r2 :: nil) m =\noption_map negb (Val.cmpfs_bool c (Vsingle n1) e # r2).","proofString":"simpl.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vsingle n1) (n : n1 <> Float32.zero) : option_map negb (Val.cmpfs_bool c e # r1 e # r2) =\noption_map negb\n  match e # r2 with\n  | Vsingle f2 => Some (Float32.cmp c n1 f2)\n  | _ => None\n  end.","proofString":"rewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vsingle n2) : let (cond', args') :=\n  if Float32.eq_dec n2 Float32.zero\n  then (Cnotcompfszero c, r1 :: nil)\n  else (Cnotcompfs c, r1 :: r2 :: nil) in\neval_condition cond' e ## args' m =\noption_map negb (Val.cmpfs_bool c e # r1 (Vsingle n2)).","proofString":"destruct (Float32.eq_dec n2 Float32.zero); simpl; auto.\nsubst n2; auto.\nrewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vsingle n2) (e0 : n2 = Float32.zero) : option_map negb (Val.cmpfs_bool c e # r1 (Vsingle Float32.zero)) =\noption_map negb (Val.cmpfs_bool c e # r1 (Vsingle n2)).","proofString":"subst n2; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vsingle n2) (n : n2 <> Float32.zero) : option_map negb (Val.cmpfs_bool c e # r1 e # r2) =\noption_map negb (Val.cmpfs_bool c e # r1 (Vsingle n2)).","proofString":"rewrite H1; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (cond0 : condition) (args0 : list reg) (vl0 : list aval) (H : vl0 = map (fun r : positive => AE.get r ae) args0) : eval_condition cond0 e ## args0 m = eval_condition cond0 e ## args0 m.","proofString":"auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) : let (op', args') := make_cmp_base c args vl in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c e ## args m)) v.","proofString":"unfold make_cmp_base.\ngeneralize (cond_strength_reduction_correct c args vl H).\ndestruct (cond_strength_reduction c args vl) as [c' args'].\nintros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) : let (op', args') :=\n  let (c', args') := cond_strength_reduction c args vl in (Ocmp c', args') in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c e ## args m)) v.","proofString":"generalize (cond_strength_reduction_correct c args vl H).\ndestruct (cond_strength_reduction c args vl) as [c' args'].\nintros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) : (let (cond', args') := cond_strength_reduction c args vl in\n eval_condition cond' e ## args' m = eval_condition c e ## args m) ->\nlet (op', args') :=\n  let (c', args') := cond_strength_reduction c args vl in (Ocmp c', args') in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c e ## args m)) v.","proofString":"destruct (cond_strength_reduction c args vl) as [c' args'].\nintros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (c' : condition) (args' : list reg) : eval_condition c' e ## args' m = eval_condition c e ## args m ->\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ocmp c') e ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c e ## args m)) v.","proofString":"intros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (c' : condition) (args' : list reg) (EQ : eval_condition c' e ## args' m = eval_condition c e ## args m) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ocmp c') e ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c e ## args m)) v.","proofString":"econstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (c' : condition) (args' : list reg) (EQ : eval_condition c' e ## args' m = eval_condition c e ## args m) : Val.lessdef (Val.of_optbool (eval_condition c e ## args m))\n  (Val.of_optbool (eval_condition c e ## args m)).","proofString":"auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) : vl = map (fun r : positive => AE.get r ae) args ->\nlet (op', args') := make_cmp c args vl in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c e ## args m)) v.","proofString":"assert (Y: forall r, vincl (AE.get r ae) (Uns Ptop 1) = true ->             e#r = Vundef \\/ e#r = Vint Int.zero \\/ e#r = Vint Int.one).\nintros.\napply vmatch_Uns_1 with bc Ptop.\neapply vmatch_ge.\neapply vincl_ge; eauto.\napply MATCH.\nunfold make_cmp.\ncase (make_cmp_match c args vl); intros.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one.","proofString":"intros.\napply vmatch_Uns_1 with bc Ptop.\neapply vmatch_ge.\neapply vincl_ge; eauto.\napply MATCH."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (r : positive) (H : vincl (AE.get r ae) (Uns Ptop 1) = true) : e # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one.","proofString":"apply vmatch_Uns_1 with bc Ptop.\neapply vmatch_ge.\neapply vincl_ge; eauto.\napply MATCH."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (r : positive) (H : vincl (AE.get r ae) (Uns Ptop 1) = true) : vmatch bc e # r (Uns Ptop 1).","proofString":"eapply vmatch_ge.\neapply vincl_ge; eauto.\napply MATCH."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) : vl = map (fun r : positive => AE.get r ae) args ->\nlet (op', args') := make_cmp c args vl in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c e ## args m)) v.","proofString":"unfold make_cmp.\ncase (make_cmp_match c args vl); intros.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) : vl = map (fun r : positive => AE.get r ae) args ->\nlet (op', args') :=\n  match make_cmp_match c args vl with\n  | make_cmp_case1 n r1 v1 | make_cmp_case3 n r1 v1 =>\n      make_cmp_imm_eq c args vl n r1 v1\n  | make_cmp_case2 n r1 v1 | make_cmp_case4 n r1 v1 =>\n      make_cmp_imm_ne c args vl n r1 v1\n  | make_cmp_default c0 args0 vl0 => make_cmp_base c0 args0 vl0\n  end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c e ## args m)) v.","proofString":"case (make_cmp_match c args vl); intros.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  make_cmp_imm_eq (Ccompimm Ceq n) (r1 :: nil) (v1 :: nil) n r1 v1 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"unfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n  then (Omove, r1 :: nil)\n  else\n   if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n   then (Oxorimm Int.one, r1 :: nil)\n   else make_cmp_base (Ccompimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompimm Ceq Int.one) e ## (r1 :: nil) m)) v.","proofString":"exists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool (eval_condition (Ccompimm Ceq Int.one) e ## (r1 :: nil) m))\n  e # r1.","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef (Val.of_optbool (Val.cmp_bool Ceq e # r1 (Vint Int.one))) e # r1.","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : e # r1 = Vundef \\/ e # r1 = Vint Int.zero \\/ e # r1 = Vint Int.one ->\nVal.lessdef (Val.of_optbool (Val.cmp_bool Ceq e # r1 (Vint Int.one))) e # r1.","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n  then (Oxorimm Int.one, r1 :: nil)\n  else make_cmp_base (Ccompimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = true) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompimm Ceq Int.zero) e ## (r1 :: nil) m)) v.","proofString":"exists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool (eval_condition (Ccompimm Ceq Int.zero) e ## (r1 :: nil) m))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef (Val.of_optbool (Val.cmp_bool Ceq e # r1 (Vint Int.zero)))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : e # r1 = Vundef \\/ e # r1 = Vint Int.zero \\/ e # r1 = Vint Int.one ->\nVal.lessdef (Val.of_optbool (Val.cmp_bool Ceq e # r1 (Vint Int.zero)))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) : let (op', args') := make_cmp_base (Ccompimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  make_cmp_imm_ne (Ccompimm Cne n) (r1 :: nil) (v1 :: nil) n r1 v1 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"unfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n  then (Omove, r1 :: nil)\n  else\n   if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n   then (Oxorimm Int.one, r1 :: nil)\n   else make_cmp_base (Ccompimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompimm Cne Int.zero) e ## (r1 :: nil) m)) v.","proofString":"exists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool (eval_condition (Ccompimm Cne Int.zero) e ## (r1 :: nil) m))\n  e # r1.","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef (Val.of_optbool (Val.cmp_bool Cne e # r1 (Vint Int.zero))) e # r1.","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : e # r1 = Vundef \\/ e # r1 = Vint Int.zero \\/ e # r1 = Vint Int.one ->\nVal.lessdef (Val.of_optbool (Val.cmp_bool Cne e # r1 (Vint Int.zero))) e # r1.","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n  then (Oxorimm Int.one, r1 :: nil)\n  else make_cmp_base (Ccompimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = true) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompimm Cne Int.one) e ## (r1 :: nil) m)) v.","proofString":"exists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool (eval_condition (Ccompimm Cne Int.one) e ## (r1 :: nil) m))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef (Val.of_optbool (Val.cmp_bool Cne e # r1 (Vint Int.one)))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : e # r1 = Vundef \\/ e # r1 = Vint Int.zero \\/ e # r1 = Vint Int.one ->\nVal.lessdef (Val.of_optbool (Val.cmp_bool Cne e # r1 (Vint Int.one)))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) : let (op', args') := make_cmp_base (Ccompimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  make_cmp_imm_eq (Ccompuimm Ceq n) (r1 :: nil) (v1 :: nil) n r1 v1 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"unfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n  then (Omove, r1 :: nil)\n  else\n   if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n   then (Oxorimm Int.one, r1 :: nil)\n   else make_cmp_base (Ccompuimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompuimm Ceq Int.one) e ## (r1 :: nil) m)) v.","proofString":"exists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool (eval_condition (Ccompuimm Ceq Int.one) e ## (r1 :: nil) m))\n  e # r1.","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Ceq e # r1 (Vint Int.one))) \n  e # r1.","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : e # r1 = Vundef \\/ e # r1 = Vint Int.zero \\/ e # r1 = Vint Int.one ->\nVal.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Ceq e # r1 (Vint Int.one))) \n  e # r1.","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n  then (Oxorimm Int.one, r1 :: nil)\n  else make_cmp_base (Ccompuimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = true) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompuimm Ceq Int.zero) e ## (r1 :: nil) m)) v.","proofString":"exists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (eval_condition (Ccompuimm Ceq Int.zero) e ## (r1 :: nil) m))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Ceq e # r1 (Vint Int.zero)))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : e # r1 = Vundef \\/ e # r1 = Vint Int.zero \\/ e # r1 = Vint Int.one ->\nVal.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Ceq e # r1 (Vint Int.zero)))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  make_cmp_base (Ccompuimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) e ## (r1 :: nil) m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  make_cmp_imm_ne (Ccompuimm Cne n) (r1 :: nil) (v1 :: nil) n r1 v1 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"unfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n  then (Omove, r1 :: nil)\n  else\n   if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n   then (Oxorimm Int.one, r1 :: nil)\n   else make_cmp_base (Ccompuimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompuimm Cne Int.zero) e ## (r1 :: nil) m)) v.","proofString":"exists (e#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (eval_condition (Ccompuimm Cne Int.zero) e ## (r1 :: nil) m)) \n  e # r1.","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Cne e # r1 (Vint Int.zero))) \n  e # r1.","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : e # r1 = Vundef \\/ e # r1 = Vint Int.zero \\/ e # r1 = Vint Int.one ->\nVal.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Cne e # r1 (Vint Int.zero))) \n  e # r1.","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n  then (Oxorimm Int.one, r1 :: nil)\n  else make_cmp_base (Ccompuimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = true) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompuimm Cne Int.one) e ## (r1 :: nil) m)) v.","proofString":"exists (Val.xor e#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool (eval_condition (Ccompuimm Cne Int.one) e ## (r1 :: nil) m))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Cne e # r1 (Vint Int.one)))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : e # r1 = Vundef \\/ e # r1 = Vint Int.zero \\/ e # r1 = Vint Int.one ->\nVal.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Cne e # r1 (Vint Int.one)))\n  (Val.xor e # r1 (Vint Int.one)).","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  make_cmp_base (Ccompuimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) e ## (r1 :: nil) m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\ne # r = Vundef \\/ e # r = Vint Int.zero \\/ e # r = Vint Int.one) (c0 : condition) (args0 : list reg) (vl0 : list aval) (H : vl0 = map (fun r : positive => AE.get r ae) args0) : let (op', args') := make_cmp_base c0 args0 vl0 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c0 e ## args0 m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) : let (op', args') :=\n  match resolve_branch (eval_static_condition c vl) with\n  | Some b => (Omove, (if b then r1 else r2) :: nil)\n  | None =>\n      let (c', args') := cond_strength_reduction c args vl in\n      (Osel c' ty, r1 :: r2 :: args')\n  end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c e ## args m) e # r1 e # r2 ty) v.","proofString":"destruct (resolve_branch (eval_static_condition c vl)) as [b|] eqn:RB.\nexists (if b then e#r1 else e#r2); split.\nsimpl.\ndestruct b; auto.\ndestruct (eval_condition c e##args m) as [b'|] eqn:EC; simpl; auto.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH).\nsubst b'.\napply Val.lessdef_normalize.\ngeneralize (cond_strength_reduction_correct c args vl H).\ndestruct (cond_strength_reduction c args vl) as [cond' args']; intros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ; auto."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove\n    e ## ((if b then r1 else r2) :: nil) m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c e ## args m) e # r1 e # r2 ty) v.","proofString":"exists (if b then e#r1 else e#r2); split.\nsimpl.\ndestruct b; auto.\ndestruct (eval_condition c e##args m) as [b'|] eqn:EC; simpl; auto.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH).\nsubst b'.\napply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) : eval_operation ge (Vptr sp Ptrofs.zero) Omove\n  e ## ((if b then r1 else r2) :: nil) m =\nSome (if b then e # r1 else e # r2).","proofString":"simpl.\ndestruct b; auto."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) : Some e # (if b then r1 else r2) = Some (if b then e # r1 else e # r2).","proofString":"destruct b; auto."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) : Val.lessdef (Val.select (eval_condition c e ## args m) e # r1 e # r2 ty)\n  (if b then e # r1 else e # r2).","proofString":"destruct (eval_condition c e##args m) as [b'|] eqn:EC; simpl; auto.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH).\nsubst b'.\napply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c e ## args m = Some b') : Val.lessdef (Val.normalize (if b' then e # r1 else e # r2) ty)\n  (if b then e # r1 else e # r2).","proofString":"assert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH).\nsubst b'.\napply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c e ## args m = Some b') : b = b'.","proofString":"eapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c e ## args m = Some b') : cmatch (Some b') (eval_static_condition c vl).","proofString":"rewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c e ## args m = Some b') : cmatch (eval_condition c e ## args m) (eval_static_condition c vl).","proofString":"apply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c e ## args m = Some b') : list_forall2 (vmatch bc) e ## args vl.","proofString":"subst vl.\nexact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (b : bool) (RB : resolve_branch\n  (eval_static_condition c (map (fun r : positive => AE.get r ae) args)) =\nSome b) (b' : bool) (EC : eval_condition c e ## args m = Some b') : list_forall2 (vmatch bc) e ## args\n  (map (fun r : positive => AE.get r ae) args).","proofString":"exact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c e ## args m = Some b') (H0 : b = b') : Val.lessdef (Val.normalize (if b' then e # r1 else e # r2) ty)\n  (if b then e # r1 else e # r2).","proofString":"subst b'.\napply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (EC : eval_condition c e ## args m = Some b) : Val.lessdef (Val.normalize (if b then e # r1 else e # r2) ty)\n  (if b then e # r1 else e # r2).","proofString":"apply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (RB : resolve_branch (eval_static_condition c vl) = None) : let (op', args') :=\n  let (c', args') := cond_strength_reduction c args vl in\n  (Osel c' ty, r1 :: r2 :: args') in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c e ## args m) e # r1 e # r2 ty) v.","proofString":"generalize (cond_strength_reduction_correct c args vl H).\ndestruct (cond_strength_reduction c args vl) as [cond' args']; intros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ; auto."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (RB : resolve_branch (eval_static_condition c vl) = None) : (let (cond', args') := cond_strength_reduction c args vl in\n eval_condition cond' e ## args' m = eval_condition c e ## args m) ->\nlet (op', args') :=\n  let (c', args') := cond_strength_reduction c args vl in\n  (Osel c' ty, r1 :: r2 :: args') in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c e ## args m) e # r1 e # r2 ty) v.","proofString":"destruct (cond_strength_reduction c args vl) as [cond' args']; intros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ; auto."},{"statement":"(c : condition) (ty : AST.typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (RB : resolve_branch (eval_static_condition c vl) = None) (cond' : condition) (args' : list reg) (EQ : eval_condition cond' e ## args' m = eval_condition c e ## args m) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Osel cond' ty)\n    e ## (r1 :: r2 :: args') m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c e ## args m) e # r1 e # r2 ty) v.","proofString":"econstructor; split.\nsimpl; eauto.\nrewrite EQ; auto."},{"statement":"(n : int) (r : reg) : let (op, args) := make_addimm n r in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.add e # r (Vint n)) v.","proofString":"unfold make_addimm.\npredSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; rewrite ?Int.add_zero; auto.\nexists (Val.add e#r (Vint n)); split; auto."},{"statement":"(n : int) (r : reg) : let (op, args) :=\n  if Int.eq n Int.zero then (Omove, r :: nil) else (Oaddimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.add e # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; rewrite ?Int.add_zero; auto.\nexists (Val.add e#r (Vint n)); split; auto."},{"statement":"(n : int) (r : reg) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.add e # r (Vint n)) v.","proofString":"subst.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; rewrite ?Int.add_zero; auto."},{"statement":"(r : reg) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.add e # r (Vint Int.zero)) v.","proofString":"exists (e#r); split; auto.\ndestruct (e#r); simpl; rewrite ?Int.add_zero; auto."},{"statement":"(r : reg) : Val.lessdef (Val.add e # r (Vint Int.zero)) e # r.","proofString":"destruct (e#r); simpl; rewrite ?Int.add_zero; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oaddimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.add e # r (Vint n)) v.","proofString":"exists (Val.add e#r (Vint n)); split; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) : let (op, args) :=\n  if Int.eq n Int.zero\n  then (Omove, r1 :: nil)\n  else\n   if Int.ltu n Int.iwordsize\n   then (Oshift Sasr (mk_amount32 n), r1 :: nil)\n   else (Oshr, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.shr e # r1 (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.shr_zero.\nauto.\ndestruct (Int.ltu n Int.iwordsize) eqn:L.\neconstructor; split.\nsimpl.\neauto.\nrewrite mk_amount32_eq; auto.\neconstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shr e # r1 (Vint n)) v.","proofString":"subst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.shr_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shr e # r1 (Vint Int.zero)) v.","proofString":"exists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.shr_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : Val.lessdef (Val.shr e # r1 (Vint Int.zero)) e # r1.","proofString":"destruct (e#r1); simpl; auto.\nrewrite Int.shr_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shr i Int.zero)\n   else Vundef) (Vint i).","proofString":"rewrite Int.shr_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int) : Val.lessdef (if Int.ltu Int.zero Int.iwordsize then Vint i else Vundef)\n  (Vint i).","proofString":"auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) : let (op, args) :=\n  if Int.ltu n Int.iwordsize\n  then (Oshift Sasr (mk_amount32 n), r1 :: nil)\n  else (Oshr, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.shr e # r1 (Vint n)) v.","proofString":"destruct (Int.ltu n Int.iwordsize) eqn:L.\neconstructor; split.\nsimpl.\neauto.\nrewrite mk_amount32_eq; auto.\neconstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshift Sasr (mk_amount32 n))\n    e ## (r1 :: nil) m = Some v /\\ Val.lessdef (Val.shr e # r1 (Vint n)) v.","proofString":"econstructor; split.\nsimpl.\neauto.\nrewrite mk_amount32_eq; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (L : Int.ltu n Int.iwordsize = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oshr e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.shr e # r1 (Vint n)) v.","proofString":"econstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) : let (op, args) :=\n  if Int.eq n Int.zero\n  then (Omove, r1 :: nil)\n  else\n   if Int.ltu n Int.iwordsize\n   then (Oshift Slsr (mk_amount32 n), r1 :: nil)\n   else (Oshru, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.shru e # r1 (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.shru_zero.\nauto.\ndestruct (Int.ltu n Int.iwordsize) eqn:L.\neconstructor; split.\nsimpl.\neauto.\nrewrite mk_amount32_eq; auto.\neconstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shru e # r1 (Vint n)) v.","proofString":"subst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.shru_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shru e # r1 (Vint Int.zero)) v.","proofString":"exists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.shru_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : Val.lessdef (Val.shru e # r1 (Vint Int.zero)) e # r1.","proofString":"destruct (e#r1); simpl; auto.\nrewrite Int.shru_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shru i Int.zero)\n   else Vundef) (Vint i).","proofString":"rewrite Int.shru_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int) : Val.lessdef (if Int.ltu Int.zero Int.iwordsize then Vint i else Vundef)\n  (Vint i).","proofString":"auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) : let (op, args) :=\n  if Int.ltu n Int.iwordsize\n  then (Oshift Slsr (mk_amount32 n), r1 :: nil)\n  else (Oshru, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.shru e # r1 (Vint n)) v.","proofString":"destruct (Int.ltu n Int.iwordsize) eqn:L.\neconstructor; split.\nsimpl.\neauto.\nrewrite mk_amount32_eq; auto.\neconstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshift Slsr (mk_amount32 n))\n    e ## (r1 :: nil) m = Some v /\\ Val.lessdef (Val.shru e # r1 (Vint n)) v.","proofString":"econstructor; split.\nsimpl.\neauto.\nrewrite mk_amount32_eq; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (L : Int.ltu n Int.iwordsize = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oshru e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.shru e # r1 (Vint n)) v.","proofString":"econstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) : let (op, args) :=\n  if Int.eq n Int.zero\n  then (Ointconst Int.zero, nil)\n  else\n   if Int.eq n Int.one\n   then (Omove, r1 :: nil)\n   else\n    match Int.is_power2 n with\n    | Some l => (Oshift Slsl (mk_amount32 l), r1 :: nil)\n    | None => (Omul, r1 :: r2 :: nil)\n    end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mul e # r1 (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst.\nexists (Vint Int.zero); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.mul_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.one; intros.\nsubst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.mul_one; auto.\ndestruct (Int.is_power2 n) eqn:?; intros.\nrewrite (Val.mul_pow2 e#r1 _ _ Heqo).\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount32_eq; auto.\neapply Int.is_power2_range; eauto.\neconstructor; split; eauto.\nsimpl.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.zero) e ## nil m =\n  Some v /\\ Val.lessdef (Val.mul e # r1 (Vint n)) v.","proofString":"subst.\nexists (Vint Int.zero); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.mul_zero; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.zero) e ## nil m =\n  Some v /\\ Val.lessdef (Val.mul e # r1 (Vint Int.zero)) v.","proofString":"exists (Vint Int.zero); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.mul_zero; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : Val.lessdef (Val.mul e # r1 (Vint Int.zero)) (Vint Int.zero).","proofString":"destruct (e#r1); simpl; auto.\nrewrite Int.mul_zero; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int) : Val.lessdef (Vint (Int.mul i Int.zero)) (Vint Int.zero).","proofString":"rewrite Int.mul_zero; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) : let (op, args) :=\n  if Int.eq n Int.one\n  then (Omove, r1 :: nil)\n  else\n   match Int.is_power2 n with\n   | Some l => (Oshift Slsl (mk_amount32 l), r1 :: nil)\n   | None => (Omul, r1 :: r2 :: nil)\n   end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mul e # r1 (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.one; intros.\nsubst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.mul_one; auto.\ndestruct (Int.is_power2 n) eqn:?; intros.\nrewrite (Val.mul_pow2 e#r1 _ _ Heqo).\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount32_eq; auto.\neapply Int.is_power2_range; eauto.\neconstructor; split; eauto.\nsimpl.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (H1 : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.mul e # r1 (Vint n)) v.","proofString":"subst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.mul_one; auto."},{"statement":"(r1 : reg) (r2 : positive) (H0 : Int.one <> Int.zero) (H : e # r2 = Vint Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.mul e # r1 (Vint Int.one)) v.","proofString":"exists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int.mul_one; auto."},{"statement":"(r1 : reg) (r2 : positive) (H0 : Int.one <> Int.zero) (H : e # r2 = Vint Int.one) : Val.lessdef (Val.mul e # r1 (Vint Int.one)) e # r1.","proofString":"destruct (e#r1); simpl; auto.\nrewrite Int.mul_one; auto."},{"statement":"(r1 : reg) (r2 : positive) (H0 : Int.one <> Int.zero) (H : e # r2 = Vint Int.one) (i : int) : Val.lessdef (Vint (Int.mul i Int.one)) (Vint i).","proofString":"rewrite Int.mul_one; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (H1 : n <> Int.one) : let (op, args) :=\n  match Int.is_power2 n with\n  | Some l => (Oshift Slsl (mk_amount32 l), r1 :: nil)\n  | None => (Omul, r1 :: r2 :: nil)\n  end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mul e # r1 (Vint n)) v.","proofString":"destruct (Int.is_power2 n) eqn:?; intros.\nrewrite (Val.mul_pow2 e#r1 _ _ Heqo).\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount32_eq; auto.\neapply Int.is_power2_range; eauto.\neconstructor; split; eauto.\nsimpl.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshift Slsl (mk_amount32 i))\n    e ## (r1 :: nil) m = Some v /\\ Val.lessdef (Val.mul e # r1 (Vint n)) v.","proofString":"rewrite (Val.mul_pow2 e#r1 _ _ Heqo).\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount32_eq; auto.\neapply Int.is_power2_range; eauto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshift Slsl (mk_amount32 i))\n    e ## (r1 :: nil) m = Some v /\\ Val.lessdef (Val.shl e # r1 (Vint i)) v.","proofString":"econstructor; split.\nsimpl; eauto.\nrewrite mk_amount32_eq; auto.\neapply Int.is_power2_range; eauto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) : Int.ltu i Int.iwordsize = true.","proofString":"eapply Int.is_power2_range; eauto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (H1 : n <> Int.one) (Heqo : Int.is_power2 n = None) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omul e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mul e # r1 (Vint n)) v.","proofString":"econstructor; split; eauto.\nsimpl.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (H1 : n <> Int.one) (Heqo : Int.is_power2 n = None) : eval_operation ge (Vptr sp Ptrofs.zero) Omul e ## (r1 :: r2 :: nil) m =\nSome (Val.mul e # r1 (Vint n)).","proofString":"simpl.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (H1 : n <> Int.one) (Heqo : Int.is_power2 n = None) : Some (Val.mul e # r1 e # r2) = Some (Val.mul e # r1 (Vint n)).","proofString":"rewrite H; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) : let (op, args) :=\n  if Int.eq n Int.one\n  then (Omove, r1 :: nil)\n  else\n   match Int.is_power2 n with\n   | Some l =>\n       if Int.ltu l (Int.repr 31)\n       then (Oshrximm l, r1 :: nil)\n       else (Odiv, r1 :: r2 :: nil)\n   | None => (Odiv, r1 :: r2 :: nil)\n   end in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"predSpec Int.eq Int.eq_spec n Int.one; intros.\nsubst.\nrewrite H0 in H.\ndestruct (e#r1) eqn:?;    try (rewrite Val.divs_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto.\ndestruct (Int.is_power2 n) eqn:?.\ndestruct (Int.ltu i (Int.repr 31)) eqn:?.\nexists v; split; auto.\nsimpl.\neapply Val.divs_pow2; eauto.\ncongruence.\nexists v; auto.\nexists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n = Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"subst.\nrewrite H0 in H.\ndestruct (e#r1) eqn:?;    try (rewrite Val.divs_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite H0 in H.\ndestruct (e#r1) eqn:?;    try (rewrite Val.divs_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(r1 r2 : positive) (v : val) (H : Val.divs e # r1 (Vint Int.one) = Some v) (H0 : e # r2 = Vint Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (e#r1) eqn:?;    try (rewrite Val.divs_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) : let (op, args) :=\n  match Int.is_power2 n with\n  | Some l =>\n      if Int.ltu l (Int.repr 31)\n      then (Oshrximm l, r1 :: nil)\n      else (Odiv, r1 :: r2 :: nil)\n  | None => (Odiv, r1 :: r2 :: nil)\n  end in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (Int.is_power2 n) eqn:?.\ndestruct (Int.ltu i (Int.repr 31)) eqn:?.\nexists v; split; auto.\nsimpl.\neapply Val.divs_pow2; eauto.\ncongruence.\nexists v; auto.\nexists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) : let (op, args) :=\n  if Int.ltu i (Int.repr 31)\n  then (Oshrximm i, r1 :: nil)\n  else (Odiv, r1 :: r2 :: nil) in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (Int.ltu i (Int.repr 31)) eqn:?.\nexists v; split; auto.\nsimpl.\neapply Val.divs_pow2; eauto.\ncongruence.\nexists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = true) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshrximm i) e ## (r1 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; split; auto.\nsimpl.\neapply Val.divs_pow2; eauto.\ncongruence."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = true) : eval_operation ge (Vptr sp Ptrofs.zero) (Oshrximm i) e ## (r1 :: nil) m =\nSome v.","proofString":"simpl.\neapply Val.divs_pow2; eauto.\ncongruence."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = true) : Val.shrx e # r1 (Vint i) = Some v.","proofString":"eapply Val.divs_pow2; eauto.\ncongruence."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = true) : Val.divs e # r1 (Vint n) = Some v.","proofString":"congruence."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = false) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Odiv e ## (r1 :: r2 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (Heqo : Int.is_power2 n = None) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Odiv e ## (r1 :: r2 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divu e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) : let (op, args) :=\n  if Int.eq n Int.one\n  then (Omove, r1 :: nil)\n  else\n   match Int.is_power2 n with\n   | Some l => (Oshift Slsr (mk_amount32 l), r1 :: nil)\n   | None => (Odivu, r1 :: r2 :: nil)\n   end in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"predSpec Int.eq Int.eq_spec n Int.one; intros.\nsubst.\nrewrite H0 in H.\ndestruct (e#r1) eqn:?;    try (rewrite Val.divu_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto.\ndestruct (Int.is_power2 n) eqn:?.\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount32_eq by (eapply Int.is_power2_range; eauto).\nrewrite H0 in H.\nerewrite Val.divu_pow2 by eauto.\nauto.\nexists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divu e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n = Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"subst.\nrewrite H0 in H.\ndestruct (e#r1) eqn:?;    try (rewrite Val.divu_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(r1 r2 : positive) (v : val) (H : Val.divu e # r1 e # r2 = Some v) (H0 : e # r2 = Vint Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite H0 in H.\ndestruct (e#r1) eqn:?;    try (rewrite Val.divu_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(r1 r2 : positive) (v : val) (H : Val.divu e # r1 (Vint Int.one) = Some v) (H0 : e # r2 = Vint Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (e#r1) eqn:?;    try (rewrite Val.divu_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divu e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) : let (op, args) :=\n  match Int.is_power2 n with\n  | Some l => (Oshift Slsr (mk_amount32 l), r1 :: nil)\n  | None => (Odivu, r1 :: r2 :: nil)\n  end in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (Int.is_power2 n) eqn:?.\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount32_eq by (eapply Int.is_power2_range; eauto).\nrewrite H0 in H.\nerewrite Val.divu_pow2 by eauto.\nauto.\nexists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divu e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshift Slsr (mk_amount32 i))\n    e ## (r1 :: nil) m = Some w /\\ Val.lessdef v w.","proofString":"econstructor; split.\nsimpl; eauto.\nrewrite mk_amount32_eq by (eapply Int.is_power2_range; eauto).\nrewrite H0 in H.\nerewrite Val.divu_pow2 by eauto.\nauto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divu e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) : Val.lessdef v (Val.shru e # r1 (Vint i)).","proofString":"rewrite H0 in H.\nerewrite Val.divu_pow2 by eauto.\nauto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divu e # r1 (Vint n) = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) : Val.lessdef v (Val.shru e # r1 (Vint i)).","proofString":"erewrite Val.divu_pow2 by eauto.\nauto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divu e # r1 (Vint n) = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) : Val.lessdef v v.","proofString":"auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divu e # r1 e # r2 = Some v) (H0 : e # r2 = Vint n) (H1 : n <> Int.one) (Heqo : Int.is_power2 n = None) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Odivu e ## (r1 :: r2 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; auto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc e # r x) : let (op, args) :=\n  if Int.eq n Int.zero\n  then (Ointconst Int.zero, nil)\n  else\n   if Int.eq n Int.mone\n   then (Omove, r :: nil)\n   else\n    if\n     match x with\n     | Uns _ m0 => Int.eq (Int.zero_ext m0 (Int.not n)) Int.zero\n     | _ => false\n     end\n    then (Omove, r :: nil)\n    else (Oandimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.and e # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst n.\nexists (Vint Int.zero); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.and_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.and_mone; auto.\ndestruct (match x with Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero                       | _ => false end) eqn:UNS.\ndestruct x; try congruence.\nexists (e#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc e # r x) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.zero) e ## nil m =\n  Some v /\\ Val.lessdef (Val.and e # r (Vint n)) v.","proofString":"subst n.\nexists (Vint Int.zero); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.and_zero; auto."},{"statement":"(r : positive) (x : aval) (H : vmatch bc e # r x) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.zero) e ## nil m =\n  Some v /\\ Val.lessdef (Val.and e # r (Vint Int.zero)) v.","proofString":"exists (Vint Int.zero); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.and_zero; auto."},{"statement":"(r : positive) (x : aval) (H : vmatch bc e # r x) : Val.lessdef (Val.and e # r (Vint Int.zero)) (Vint Int.zero).","proofString":"destruct (e#r); simpl; auto.\nrewrite Int.and_zero; auto."},{"statement":"(r : positive) (x : aval) (i : int) (H : vmatch bc (Vint i) x) : Val.lessdef (Vint (Int.and i Int.zero)) (Vint Int.zero).","proofString":"rewrite Int.and_zero; auto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc e # r x) (H0 : n <> Int.zero) : let (op, args) :=\n  if Int.eq n Int.mone\n  then (Omove, r :: nil)\n  else\n   if\n    match x with\n    | Uns _ m0 => Int.eq (Int.zero_ext m0 (Int.not n)) Int.zero\n    | _ => false\n    end\n   then (Omove, r :: nil)\n   else (Oandimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.and e # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.and_mone; auto.\ndestruct (match x with Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero                       | _ => false end) eqn:UNS.\ndestruct x; try congruence.\nexists (e#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc e # r x) (H0 : n <> Int.zero) (H1 : n = Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.and e # r (Vint n)) v.","proofString":"subst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.and_mone; auto."},{"statement":"(r : positive) (x : aval) (H : vmatch bc e # r x) (H0 : Int.mone <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.and e # r (Vint Int.mone)) v.","proofString":"exists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.and_mone; auto."},{"statement":"(r : positive) (x : aval) (H : vmatch bc e # r x) (H0 : Int.mone <> Int.zero) : Val.lessdef (Val.and e # r (Vint Int.mone)) e # r.","proofString":"destruct (e#r); simpl; auto.\nrewrite Int.and_mone; auto."},{"statement":"(r : positive) (x : aval) (i : int) (H : vmatch bc (Vint i) x) (H0 : Int.mone <> Int.zero) : Val.lessdef (Vint (Int.and i Int.mone)) (Vint i).","proofString":"rewrite Int.and_mone; auto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc e # r x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) : let (op, args) :=\n  if\n   match x with\n   | Uns _ m0 => Int.eq (Int.zero_ext m0 (Int.not n)) Int.zero\n   | _ => false\n   end\n  then (Omove, r :: nil)\n  else (Oandimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.and e # r (Vint n)) v.","proofString":"destruct (match x with Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero                       | _ => false end) eqn:UNS.\ndestruct x; try congruence.\nexists (e#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc e # r x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : match x with\n| Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero\n| _ => false\nend = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.and e # r (Vint n)) v.","proofString":"destruct x; try congruence.\nexists (e#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H : vmatch bc e # r (Uns p n0)) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.and e # r (Vint n)) v.","proofString":"exists (e#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H : vmatch bc e # r (Uns p n0)) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) : Val.lessdef (Val.and e # r (Vint n)) e # r.","proofString":"inv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) : Val.lessdef (Val.and (Vint i) (Vint n)) (Vint i).","proofString":"simpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) : Val.lessdef (Vint (Int.and i n)) (Vint i).","proofString":"replace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) : i = Int.and i n.","proofString":"generalize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) : i = Int.and i n.","proofString":"Int.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) : Int.testbit i i0 = Int.testbit i i0 && Int.testbit n i0.","proofString":"destruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0 && Int.testbit n i0.","proofString":"replace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0 && negb (Int.testbit Int.zero i0).","proofString":"rewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0 && negb false.","proofString":"simpl.\nrewrite andb_true_r.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0 && true.","proofString":"rewrite andb_true_r.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0.","proofString":"auto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (Int.testbit Int.zero i0) = Int.testbit n i0.","proofString":"rewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (Int.testbit (Int.zero_ext n0 (Int.not n)) i0) = Int.testbit n i0.","proofString":"rewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (if zlt i0 n0 then Int.testbit (Int.not n) i0 else false) =\nInt.testbit n i0.","proofString":"rewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (Int.testbit (Int.not n) i0) = Int.testbit n i0.","proofString":"rewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (negb (Int.testbit n i0)) = Int.testbit n i0.","proofString":"apply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (g : i0 >= n0) : Int.testbit i i0 = Int.testbit i i0 && Int.testbit n i0.","proofString":"rewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = e # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (g : i0 >= n0) : false = false && Int.testbit n i0.","proofString":"auto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc e # r x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : match x with\n| Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero\n| _ => false\nend = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oandimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.and e # r (Vint n)) v.","proofString":"econstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc e # r x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : match x with\n| Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero\n| _ => false\nend = false) : eval_operation ge (Vptr sp Ptrofs.zero) (Oandimm n) e ## (r :: nil) m =\nSome (Val.and e # r (Vint n)).","proofString":"auto."},{"statement":"(n : int) (r : reg) : let (op, args) :=\n  if Int.eq n Int.zero\n  then (Omove, r :: nil)\n  else\n   if Int.eq n Int.mone\n   then (Ointconst Int.mone, nil)\n   else (Oorimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.or e # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.or_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (Vint Int.mone); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.or_mone; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.or e # r (Vint n)) v.","proofString":"subst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(r : reg) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.or e # r (Vint Int.zero)) v.","proofString":"exists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(r : reg) : Val.lessdef (Val.or e # r (Vint Int.zero)) e # r.","proofString":"destruct (e#r); simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(r : reg) (i : int) : Val.lessdef (Vint (Int.or i Int.zero)) (Vint i).","proofString":"rewrite Int.or_zero; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) : let (op, args) :=\n  if Int.eq n Int.mone\n  then (Ointconst Int.mone, nil)\n  else (Oorimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.or e # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (Vint Int.mone); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.or_mone; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n = Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.mone) e ## nil m =\n  Some v /\\ Val.lessdef (Val.or e # r (Vint n)) v.","proofString":"subst n.\nexists (Vint Int.mone); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.mone) e ## nil m =\n  Some v /\\ Val.lessdef (Val.or e # r (Vint Int.mone)) v.","proofString":"exists (Vint Int.mone); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) : Val.lessdef (Val.or e # r (Vint Int.mone)) (Vint Int.mone).","proofString":"destruct (e#r); simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) (i : int) : Val.lessdef (Vint (Int.or i Int.mone)) (Vint Int.mone).","proofString":"rewrite Int.or_mone; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n <> Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oorimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.or e # r (Vint n)) v.","proofString":"econstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n <> Int.mone) : eval_operation ge (Vptr sp Ptrofs.zero) (Oorimm n) e ## (r :: nil) m =\nSome (Val.or e # r (Vint n)).","proofString":"auto."},{"statement":"(n : int) (r : reg) : let (op, args) :=\n  if Int.eq n Int.zero then (Omove, r :: nil) else (Oxorimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.xor e # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.xor_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (Val.notint e#r); split; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.xor e # r (Vint n)) v.","proofString":"subst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.xor_zero; auto."},{"statement":"(r : reg) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.xor e # r (Vint Int.zero)) v.","proofString":"exists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int.xor_zero; auto."},{"statement":"(r : reg) : Val.lessdef (Val.xor e # r (Vint Int.zero)) e # r.","proofString":"destruct (e#r); simpl; auto.\nrewrite Int.xor_zero; auto."},{"statement":"(r : reg) (i : int) : Val.lessdef (Vint (Int.xor i Int.zero)) (Vint i).","proofString":"rewrite Int.xor_zero; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.xor e # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (Val.notint e#r); split; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n = Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.xor e # r (Vint n)) v.","proofString":"subst n.\nexists (Val.notint e#r); split; auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.mone) \n    e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.xor e # r (Vint Int.mone)) v.","proofString":"exists (Val.notint e#r); split; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n <> Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.xor e # r (Vint n)) v.","proofString":"econstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n <> Int.mone) : eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm n) e ## (r :: nil) m =\nSome (Val.xor e # r (Vint n)).","proofString":"auto."},{"statement":"(n : int64) (r : reg) : let (op, args) := make_addlimm n r in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.addl e # r (Vlong n)) v.","proofString":"unfold make_addlimm.\npredSpec Int64.eq Int64.eq_spec n Int64.zero; intros.\nsubst.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto; rewrite ? Int64.add_zero, ? Ptrofs.add_zero; auto.\nexists (Val.addl e#r (Vlong n)); split; auto."},{"statement":"(n : int64) (r : reg) : let (op, args) :=\n  if Int64.eq n Int64.zero then (Omove, r :: nil) else (Oaddlimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.addl e # r (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero; intros.\nsubst.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto; rewrite ? Int64.add_zero, ? Ptrofs.add_zero; auto.\nexists (Val.addl e#r (Vlong n)); split; auto."},{"statement":"(n : int64) (r : reg) (H : n = Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.addl e # r (Vlong n)) v.","proofString":"subst.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto; rewrite ? Int64.add_zero, ? Ptrofs.add_zero; auto."},{"statement":"(r : reg) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.addl e # r (Vlong Int64.zero)) v.","proofString":"exists (e#r); split; auto.\ndestruct (e#r); simpl; auto; rewrite ? Int64.add_zero, ? Ptrofs.add_zero; auto."},{"statement":"(r : reg) : Val.lessdef (Val.addl e # r (Vlong Int64.zero)) e # r.","proofString":"destruct (e#r); simpl; auto; rewrite ? Int64.add_zero, ? Ptrofs.add_zero; auto."},{"statement":"(n : int64) (r : reg) (H : n <> Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oaddlimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.addl e # r (Vlong n)) v.","proofString":"exists (Val.addl e#r (Vlong n)); split; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) : let (op, args) :=\n  if Int.eq n Int.zero\n  then (Omove, r1 :: nil)\n  else\n   if Int.ltu n Int64.iwordsize'\n   then (Oshiftl Sasr (mk_amount64 n), r1 :: nil)\n   else (Oshrl, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.shrl e # r1 (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nunfold Int64.shr'.\nrewrite Z.shiftr_0_r, Int64.repr_signed.\nauto.\ndestruct (Int.ltu n Int64.iwordsize') eqn:L.\neconstructor; split.\nsimpl.\neauto.\nrewrite mk_amount64_eq; auto.\neconstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shrl e # r1 (Vint n)) v.","proofString":"subst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nunfold Int64.shr'.\nrewrite Z.shiftr_0_r, Int64.repr_signed.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shrl e # r1 (Vint Int.zero)) v.","proofString":"exists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nunfold Int64.shr'.\nrewrite Z.shiftr_0_r, Int64.repr_signed.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : Val.lessdef (Val.shrl e # r1 (Vint Int.zero)) e # r1.","proofString":"destruct (e#r1); simpl; auto.\nunfold Int64.shr'.\nrewrite Z.shiftr_0_r, Int64.repr_signed.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int64) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i).","proofString":"unfold Int64.shr'.\nrewrite Z.shiftr_0_r, Int64.repr_signed.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int64) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then\n    Vlong (Int64.repr (Z.shiftr (Int64.signed i) (Int.unsigned Int.zero)))\n   else Vundef) (Vlong i).","proofString":"rewrite Z.shiftr_0_r, Int64.repr_signed.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int64) : Val.lessdef (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i).","proofString":"auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) : let (op, args) :=\n  if Int.ltu n Int64.iwordsize'\n  then (Oshiftl Sasr (mk_amount64 n), r1 :: nil)\n  else (Oshrl, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.shrl e # r1 (Vint n)) v.","proofString":"destruct (Int.ltu n Int64.iwordsize') eqn:L.\neconstructor; split.\nsimpl.\neauto.\nrewrite mk_amount64_eq; auto.\neconstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshiftl Sasr (mk_amount64 n))\n    e ## (r1 :: nil) m = Some v /\\ Val.lessdef (Val.shrl e # r1 (Vint n)) v.","proofString":"econstructor; split.\nsimpl.\neauto.\nrewrite mk_amount64_eq; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oshrl e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.shrl e # r1 (Vint n)) v.","proofString":"econstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) : let (op, args) :=\n  if Int.eq n Int.zero\n  then (Omove, r1 :: nil)\n  else\n   if Int.ltu n Int64.iwordsize'\n   then (Oshiftl Slsr (mk_amount64 n), r1 :: nil)\n   else (Oshrlu, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.shrlu e # r1 (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nunfold Int64.shru'.\nrewrite Z.shiftr_0_r, Int64.repr_unsigned.\nauto.\ndestruct (Int.ltu n Int64.iwordsize') eqn:L.\neconstructor; split.\nsimpl.\neauto.\nrewrite mk_amount64_eq; auto.\neconstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shrlu e # r1 (Vint n)) v.","proofString":"subst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nunfold Int64.shru'.\nrewrite Z.shiftr_0_r, Int64.repr_unsigned.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shrlu e # r1 (Vint Int.zero)) v.","proofString":"exists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nunfold Int64.shru'.\nrewrite Z.shiftr_0_r, Int64.repr_unsigned.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) : Val.lessdef (Val.shrlu e # r1 (Vint Int.zero)) e # r1.","proofString":"destruct (e#r1); simpl; auto.\nunfold Int64.shru'.\nrewrite Z.shiftr_0_r, Int64.repr_unsigned.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int64) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru' i Int.zero)\n   else Vundef) (Vlong i).","proofString":"unfold Int64.shru'.\nrewrite Z.shiftr_0_r, Int64.repr_unsigned.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int64) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then\n    Vlong (Int64.repr (Z.shiftr (Int64.unsigned i) (Int.unsigned Int.zero)))\n   else Vundef) (Vlong i).","proofString":"rewrite Z.shiftr_0_r, Int64.repr_unsigned.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vint Int.zero) (i : int64) : Val.lessdef (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i).","proofString":"auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) : let (op, args) :=\n  if Int.ltu n Int64.iwordsize'\n  then (Oshiftl Slsr (mk_amount64 n), r1 :: nil)\n  else (Oshrlu, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.shrlu e # r1 (Vint n)) v.","proofString":"destruct (Int.ltu n Int64.iwordsize') eqn:L.\neconstructor; split.\nsimpl.\neauto.\nrewrite mk_amount64_eq; auto.\neconstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshiftl Slsr (mk_amount64 n))\n    e ## (r1 :: nil) m = Some v /\\ Val.lessdef (Val.shrlu e # r1 (Vint n)) v.","proofString":"econstructor; split.\nsimpl.\neauto.\nrewrite mk_amount64_eq; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : e # r2 = Vint n) (H0 : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oshrlu e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.shrlu e # r1 (Vint n)) v.","proofString":"econstructor; split.\nsimpl.\neauto.\nrewrite H; auto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) : let (op, args) :=\n  if Int64.eq n Int64.zero\n  then (Olongconst Int64.zero, nil)\n  else\n   if Int64.eq n Int64.one\n   then (Omove, r1 :: nil)\n   else\n    match Int64.is_power2' n with\n    | Some l => (Oshiftl Slsl (mk_amount64 l), r1 :: nil)\n    | None => (Omull, r1 :: r2 :: nil)\n    end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mull e # r1 (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero; intros.\nsubst.\nexists (Vlong Int64.zero); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int64.mul_zero; auto.\npredSpec Int64.eq Int64.eq_spec n Int64.one; intros.\nsubst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int64.mul_one; auto.\ndestruct (Int64.is_power2' n) eqn:?; intros.\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount64_eq by (eapply Int64.is_power2'_range; eauto).\ndestruct (e#r1); simpl; auto.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.mul_pow2' by eauto.\nauto.\neconstructor; split; eauto.\nsimpl; rewrite H; auto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n = Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Olongconst Int64.zero) e ## nil m =\n  Some v /\\ Val.lessdef (Val.mull e # r1 (Vlong n)) v.","proofString":"subst.\nexists (Vlong Int64.zero); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int64.mul_zero; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vlong Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Olongconst Int64.zero) e ## nil m =\n  Some v /\\ Val.lessdef (Val.mull e # r1 (Vlong Int64.zero)) v.","proofString":"exists (Vlong Int64.zero); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int64.mul_zero; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vlong Int64.zero) : Val.lessdef (Val.mull e # r1 (Vlong Int64.zero)) (Vlong Int64.zero).","proofString":"destruct (e#r1); simpl; auto.\nrewrite Int64.mul_zero; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vlong Int64.zero) (i : int64) : Val.lessdef (Vlong (Int64.mul i Int64.zero)) (Vlong Int64.zero).","proofString":"rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) : let (op, args) :=\n  if Int64.eq n Int64.one\n  then (Omove, r1 :: nil)\n  else\n   match Int64.is_power2' n with\n   | Some l => (Oshiftl Slsl (mk_amount64 l), r1 :: nil)\n   | None => (Omull, r1 :: r2 :: nil)\n   end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mull e # r1 (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.one; intros.\nsubst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int64.mul_one; auto.\ndestruct (Int64.is_power2' n) eqn:?; intros.\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount64_eq by (eapply Int64.is_power2'_range; eauto).\ndestruct (e#r1); simpl; auto.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.mul_pow2' by eauto.\nauto.\neconstructor; split; eauto.\nsimpl; rewrite H; auto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.mull e # r1 (Vlong n)) v.","proofString":"subst.\nexists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int64.mul_one; auto."},{"statement":"(r1 : reg) (r2 : positive) (H0 : Int64.one <> Int64.zero) (H : e # r2 = Vlong Int64.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.mull e # r1 (Vlong Int64.one)) v.","proofString":"exists (e#r1); split; auto.\ndestruct (e#r1); simpl; auto.\nrewrite Int64.mul_one; auto."},{"statement":"(r1 : reg) (r2 : positive) (H0 : Int64.one <> Int64.zero) (H : e # r2 = Vlong Int64.one) : Val.lessdef (Val.mull e # r1 (Vlong Int64.one)) e # r1.","proofString":"destruct (e#r1); simpl; auto.\nrewrite Int64.mul_one; auto."},{"statement":"(r1 : reg) (r2 : positive) (H0 : Int64.one <> Int64.zero) (H : e # r2 = Vlong Int64.one) (i : int64) : Val.lessdef (Vlong (Int64.mul i Int64.one)) (Vlong i).","proofString":"rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) : let (op, args) :=\n  match Int64.is_power2' n with\n  | Some l => (Oshiftl Slsl (mk_amount64 l), r1 :: nil)\n  | None => (Omull, r1 :: r2 :: nil)\n  end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mull e # r1 (Vlong n)) v.","proofString":"destruct (Int64.is_power2' n) eqn:?; intros.\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount64_eq by (eapply Int64.is_power2'_range; eauto).\ndestruct (e#r1); simpl; auto.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.mul_pow2' by eauto.\nauto.\neconstructor; split; eauto.\nsimpl; rewrite H; auto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int) (Heqo : Int64.is_power2' n = Some i) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshiftl Slsl (mk_amount64 i))\n    e ## (r1 :: nil) m = Some v /\\ Val.lessdef (Val.mull e # r1 (Vlong n)) v.","proofString":"econstructor; split.\nsimpl; eauto.\nrewrite mk_amount64_eq by (eapply Int64.is_power2'_range; eauto).\ndestruct (e#r1); simpl; auto.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.mul_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int) (Heqo : Int64.is_power2' n = Some i) : Val.lessdef (Val.mull e # r1 (Vlong n)) (Val.shll e # r1 (Vint i)).","proofString":"destruct (e#r1); simpl; auto.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.mul_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int) (Heqo : Int64.is_power2' n = Some i) (i0 : int64) : Val.lessdef (Vlong (Int64.mul i0 n))\n  (if Int.ltu i Int64.iwordsize' then Vlong (Int64.shl' i0 i) else Vundef).","proofString":"erewrite Int64.is_power2'_range by eauto.\nerewrite Int64.mul_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int) (Heqo : Int64.is_power2' n = Some i) (i0 : int64) : Val.lessdef (Vlong (Int64.mul i0 n)) (Vlong (Int64.shl' i0 i)).","proofString":"erewrite Int64.mul_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int) (Heqo : Int64.is_power2' n = Some i) (i0 : int64) : Val.lessdef (Vlong (Int64.shl' i0 i)) (Vlong (Int64.shl' i0 i)).","proofString":"auto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (Heqo : Int64.is_power2' n = None) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omull e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mull e # r1 (Vlong n)) v.","proofString":"econstructor; split; eauto.\nsimpl; rewrite H; auto."},{"statement":"(n : int64) (r1 : reg) (r2 : positive) (H : e # r2 = Vlong n) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (Heqo : Int64.is_power2' n = None) : eval_operation ge (Vptr sp Ptrofs.zero) Omull e ## (r1 :: r2 :: nil) m =\nSome (Val.mull e # r1 (Vlong n)).","proofString":"simpl; rewrite H; auto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divls e # r1 e # r2 = Some v) (H0 : e # r2 = Vlong n) : let (op, args) :=\n  match Int64.is_power2' n with\n  | Some l =>\n      if Int.ltu l (Int.repr 63)\n      then (Oshrlximm l, r1 :: nil)\n      else (Odivl, r1 :: r2 :: nil)\n  | None => (Odivl, r1 :: r2 :: nil)\n  end in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (Int64.is_power2' n) eqn:?.\ndestruct (Int.ltu i (Int.repr 63)) eqn:?.\nrewrite H0 in H.\neconstructor; split.\nsimpl; eauto.\neapply Val.divls_pow2; eauto.\nauto.\nexists v; auto.\nexists v; auto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divls e # r1 e # r2 = Some v) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) : let (op, args) :=\n  if Int.ltu i (Int.repr 63)\n  then (Oshrlximm i, r1 :: nil)\n  else (Odivl, r1 :: r2 :: nil) in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (Int.ltu i (Int.repr 63)) eqn:?.\nrewrite H0 in H.\neconstructor; split.\nsimpl; eauto.\neapply Val.divls_pow2; eauto.\nauto.\nexists v; auto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divls e # r1 e # r2 = Some v) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) (Heqb : Int.ltu i (Int.repr 63) = true) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshrlximm i) e ## (r1 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"rewrite H0 in H.\neconstructor; split.\nsimpl; eauto.\neapply Val.divls_pow2; eauto.\nauto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divls e # r1 (Vlong n) = Some v) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) (Heqb : Int.ltu i (Int.repr 63) = true) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshrlximm i) e ## (r1 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"econstructor; split.\nsimpl; eauto.\neapply Val.divls_pow2; eauto.\nauto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divls e # r1 e # r2 = Some v) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) (Heqb : Int.ltu i (Int.repr 63) = false) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Odivl e ## (r1 :: r2 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; auto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divls e # r1 e # r2 = Some v) (H0 : e # r2 = Vlong n) (Heqo : Int64.is_power2' n = None) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Odivl e ## (r1 :: r2 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; auto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divlu e # r1 e # r2 = Some v) (H0 : e # r2 = Vlong n) : let (op, args) :=\n  match Int64.is_power2' n with\n  | Some l => (Oshiftl Slsr (mk_amount64 l), r1 :: nil)\n  | None => (Odivlu, r1 :: r2 :: nil)\n  end in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (Int64.is_power2' n) eqn:?.\neconstructor; split.\nsimpl; eauto.\nrewrite mk_amount64_eq by (eapply Int64.is_power2'_range; eauto).\nrewrite H0 in H.\ndestruct (e#r1); inv H.\ndestruct (Int64.eq n Int64.zero); inv H2.\nsimpl.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.divu_pow2' by eauto.\nauto.\nexists v; auto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divlu e # r1 e # r2 = Some v) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshiftl Slsr (mk_amount64 i))\n    e ## (r1 :: nil) m = Some w /\\ Val.lessdef v w.","proofString":"econstructor; split.\nsimpl; eauto.\nrewrite mk_amount64_eq by (eapply Int64.is_power2'_range; eauto).\nrewrite H0 in H.\ndestruct (e#r1); inv H.\ndestruct (Int64.eq n Int64.zero); inv H2.\nsimpl.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.divu_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divlu e # r1 e # r2 = Some v) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) : Val.lessdef v (Val.shrlu e # r1 (Vint i)).","proofString":"rewrite H0 in H.\ndestruct (e#r1); inv H.\ndestruct (Int64.eq n Int64.zero); inv H2.\nsimpl.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.divu_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divlu e # r1 (Vlong n) = Some v) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) : Val.lessdef v (Val.shrlu e # r1 (Vint i)).","proofString":"destruct (e#r1); inv H.\ndestruct (Int64.eq n Int64.zero); inv H2.\nsimpl.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.divu_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (i0 : int64) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) (H2 : (if Int64.eq n Int64.zero then None else Some (Vlong (Int64.divu i0 n))) =\nSome v) : Val.lessdef v (Val.shrlu (Vlong i0) (Vint i)).","proofString":"destruct (Int64.eq n Int64.zero); inv H2.\nsimpl.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.divu_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 r2 : positive) (i0 : int64) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) : Val.lessdef (Vlong (Int64.divu i0 n)) (Val.shrlu (Vlong i0) (Vint i)).","proofString":"simpl.\nerewrite Int64.is_power2'_range by eauto.\nerewrite Int64.divu_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 r2 : positive) (i0 : int64) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) : Val.lessdef (Vlong (Int64.divu i0 n))\n  (if Int.ltu i Int64.iwordsize' then Vlong (Int64.shru' i0 i) else Vundef).","proofString":"erewrite Int64.is_power2'_range by eauto.\nerewrite Int64.divu_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 r2 : positive) (i0 : int64) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) : Val.lessdef (Vlong (Int64.divu i0 n)) (Vlong (Int64.shru' i0 i)).","proofString":"erewrite Int64.divu_pow2' by eauto.\nauto."},{"statement":"(n : int64) (r1 r2 : positive) (i0 : int64) (H0 : e # r2 = Vlong n) (i : int) (Heqo : Int64.is_power2' n = Some i) : Val.lessdef (Vlong (Int64.shru' i0 i)) (Vlong (Int64.shru' i0 i)).","proofString":"auto."},{"statement":"(n : int64) (r1 r2 : positive) (v : val) (H : Val.divlu e # r1 e # r2 = Some v) (H0 : e # r2 = Vlong n) (Heqo : Int64.is_power2' n = None) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Odivlu e ## (r1 :: r2 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; auto."},{"statement":"(n : int64) (r : reg) (x : aval) : let (op, args) :=\n  if Int64.eq n Int64.zero\n  then (Olongconst Int64.zero, nil)\n  else\n   if Int64.eq n Int64.mone\n   then (Omove, r :: nil)\n   else (Oandlimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.andl e # r (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero; intros.\nsubst n.\nexists (Vlong Int64.zero); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.and_zero; auto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone; intros.\nsubst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.and_mone; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int64) (r : reg) (x : aval) (H : n = Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Olongconst Int64.zero) e ## nil m =\n  Some v /\\ Val.lessdef (Val.andl e # r (Vlong n)) v.","proofString":"subst n.\nexists (Vlong Int64.zero); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.and_zero; auto."},{"statement":"(r : reg) (x : aval) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Olongconst Int64.zero) e ## nil m =\n  Some v /\\ Val.lessdef (Val.andl e # r (Vlong Int64.zero)) v.","proofString":"exists (Vlong Int64.zero); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.and_zero; auto."},{"statement":"(r : reg) (x : aval) : Val.lessdef (Val.andl e # r (Vlong Int64.zero)) (Vlong Int64.zero).","proofString":"destruct (e#r); simpl; auto.\nrewrite Int64.and_zero; auto."},{"statement":"(r : reg) (x : aval) (i : int64) : Val.lessdef (Vlong (Int64.and i Int64.zero)) (Vlong Int64.zero).","proofString":"rewrite Int64.and_zero; auto."},{"statement":"(n : int64) (r : reg) (x : aval) (H : n <> Int64.zero) : let (op, args) :=\n  if Int64.eq n Int64.mone then (Omove, r :: nil) else (Oandlimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.andl e # r (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.mone; intros.\nsubst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.and_mone; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int64) (r : reg) (x : aval) (H : n <> Int64.zero) (H0 : n = Int64.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.andl e # r (Vlong n)) v.","proofString":"subst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.and_mone; auto."},{"statement":"(r : reg) (x : aval) (H : Int64.mone <> Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.andl e # r (Vlong Int64.mone)) v.","proofString":"exists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.and_mone; auto."},{"statement":"(r : reg) (x : aval) (H : Int64.mone <> Int64.zero) : Val.lessdef (Val.andl e # r (Vlong Int64.mone)) e # r.","proofString":"destruct (e#r); simpl; auto.\nrewrite Int64.and_mone; auto."},{"statement":"(r : reg) (x : aval) (H : Int64.mone <> Int64.zero) (i : int64) : Val.lessdef (Vlong (Int64.and i Int64.mone)) (Vlong i).","proofString":"rewrite Int64.and_mone; auto."},{"statement":"(n : int64) (r : reg) (x : aval) (H : n <> Int64.zero) (H0 : n <> Int64.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oandlimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.andl e # r (Vlong n)) v.","proofString":"econstructor; split; eauto.\nauto."},{"statement":"(n : int64) (r : reg) (x : aval) (H : n <> Int64.zero) (H0 : n <> Int64.mone) : eval_operation ge (Vptr sp Ptrofs.zero) (Oandlimm n) e ## (r :: nil) m =\nSome (Val.andl e # r (Vlong n)).","proofString":"auto."},{"statement":"(n : int64) (r : reg) : let (op, args) :=\n  if Int64.eq n Int64.zero\n  then (Omove, r :: nil)\n  else\n   if Int64.eq n Int64.mone\n   then (Olongconst Int64.mone, nil)\n   else (Oorlimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.orl e # r (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero; intros.\nsubst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.or_zero; auto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone; intros.\nsubst n.\nexists (Vlong Int64.mone); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.or_mone; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int64) (r : reg) (H : n = Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.orl e # r (Vlong n)) v.","proofString":"subst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(r : reg) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.orl e # r (Vlong Int64.zero)) v.","proofString":"exists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(r : reg) : Val.lessdef (Val.orl e # r (Vlong Int64.zero)) e # r.","proofString":"destruct (e#r); simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(r : reg) (i : int64) : Val.lessdef (Vlong (Int64.or i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.or_zero; auto."},{"statement":"(n : int64) (r : reg) (H : n <> Int64.zero) : let (op, args) :=\n  if Int64.eq n Int64.mone\n  then (Olongconst Int64.mone, nil)\n  else (Oorlimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.orl e # r (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.mone; intros.\nsubst n.\nexists (Vlong Int64.mone); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.or_mone; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int64) (r : reg) (H : n <> Int64.zero) (H0 : n = Int64.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Olongconst Int64.mone) e ## nil m =\n  Some v /\\ Val.lessdef (Val.orl e # r (Vlong n)) v.","proofString":"subst n.\nexists (Vlong Int64.mone); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.or_mone; auto."},{"statement":"(r : reg) (H : Int64.mone <> Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Olongconst Int64.mone) e ## nil m =\n  Some v /\\ Val.lessdef (Val.orl e # r (Vlong Int64.mone)) v.","proofString":"exists (Vlong Int64.mone); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.or_mone; auto."},{"statement":"(r : reg) (H : Int64.mone <> Int64.zero) : Val.lessdef (Val.orl e # r (Vlong Int64.mone)) (Vlong Int64.mone).","proofString":"destruct (e#r); simpl; auto.\nrewrite Int64.or_mone; auto."},{"statement":"(r : reg) (H : Int64.mone <> Int64.zero) (i : int64) : Val.lessdef (Vlong (Int64.or i Int64.mone)) (Vlong Int64.mone).","proofString":"rewrite Int64.or_mone; auto."},{"statement":"(n : int64) (r : reg) (H : n <> Int64.zero) (H0 : n <> Int64.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oorlimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.orl e # r (Vlong n)) v.","proofString":"econstructor; split; eauto.\nauto."},{"statement":"(n : int64) (r : reg) (H : n <> Int64.zero) (H0 : n <> Int64.mone) : eval_operation ge (Vptr sp Ptrofs.zero) (Oorlimm n) e ## (r :: nil) m =\nSome (Val.orl e # r (Vlong n)).","proofString":"auto."},{"statement":"(n : int64) (r : reg) : let (op, args) :=\n  if Int64.eq n Int64.zero then (Omove, r :: nil) else (Oxorlimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.xorl e # r (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero; intros.\nsubst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.xor_zero; auto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone; intros.\nsubst n.\nexists (Val.notl e#r); split; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int64) (r : reg) (H : n = Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.xorl e # r (Vlong n)) v.","proofString":"subst n.\nexists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.xor_zero; auto."},{"statement":"(r : reg) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.xorl e # r (Vlong Int64.zero)) v.","proofString":"exists (e#r); split; auto.\ndestruct (e#r); simpl; auto.\nrewrite Int64.xor_zero; auto."},{"statement":"(r : reg) : Val.lessdef (Val.xorl e # r (Vlong Int64.zero)) e # r.","proofString":"destruct (e#r); simpl; auto.\nrewrite Int64.xor_zero; auto."},{"statement":"(r : reg) (i : int64) : Val.lessdef (Vlong (Int64.xor i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.xor_zero; auto."},{"statement":"(n : int64) (r : reg) (H : n <> Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorlimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.xorl e # r (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.mone; intros.\nsubst n.\nexists (Val.notl e#r); split; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int64) (r : reg) (H : n <> Int64.zero) (H0 : n = Int64.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorlimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.xorl e # r (Vlong n)) v.","proofString":"subst n.\nexists (Val.notl e#r); split; auto."},{"statement":"(r : reg) (H : Int64.mone <> Int64.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorlimm Int64.mone)\n    e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.xorl e # r (Vlong Int64.mone)) v.","proofString":"exists (Val.notl e#r); split; auto."},{"statement":"(n : int64) (r : reg) (H : n <> Int64.zero) (H0 : n <> Int64.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorlimm n) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.xorl e # r (Vlong n)) v.","proofString":"econstructor; split; eauto.\nauto."},{"statement":"(n : int64) (r : reg) (H : n <> Int64.zero) (H0 : n <> Int64.mone) : eval_operation ge (Vptr sp Ptrofs.zero) (Oxorlimm n) e ## (r :: nil) m =\nSome (Val.xorl e # r (Vlong n)).","proofString":"auto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : e # r2 = Vfloat n) : let (op, args) :=\n  if Float.eq_dec n (Float.of_int (Int.repr 2))\n  then (Oaddf, r1 :: r1 :: nil)\n  else (Omulf, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"destruct (Float.eq_dec n (Float.of_int (Int.repr 2))); intros.\nsimpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r1); simpl; auto.\nrewrite Float.mul2_add; auto.\nsimpl.\neconstructor; split; eauto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : e # r2 = Vfloat n) (e0 : n = Float.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oaddf e ## (r1 :: r1 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"simpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r1); simpl; auto.\nrewrite Float.mul2_add; auto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : e # r2 = Vfloat n) (e0 : n = Float.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.addf e # r1 e # r1) = Some v /\\\n  Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"econstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r1); simpl; auto.\nrewrite Float.mul2_add; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vfloat (Float.of_int (Int.repr 2))) : Val.lessdef (Val.mulf e # r1 (Vfloat (Float.of_int (Int.repr 2))))\n  (Val.addf e # r1 e # r1).","proofString":"destruct (e#r1); simpl; auto.\nrewrite Float.mul2_add; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vfloat (Float.of_int (Int.repr 2))) (f : float) : Val.lessdef (Vfloat (Float.mul f (Float.of_int (Int.repr 2))))\n  (Vfloat (Float.add f f)).","proofString":"rewrite Float.mul2_add; auto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : e # r2 = Vfloat n) (n0 : n <> Float.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omulf e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"simpl.\neconstructor; split; eauto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : e # r2 = Vfloat n) (n0 : n <> Float.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.mulf e # r1 e # r2) = Some v /\\\n  Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"econstructor; split; eauto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : e # r1 = Vfloat n) : let (op, args) :=\n  if Float.eq_dec n (Float.of_int (Int.repr 2))\n  then (Oaddf, r2 :: r2 :: nil)\n  else (Omulf, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"destruct (Float.eq_dec n (Float.of_int (Int.repr 2))); intros.\nsimpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r2); simpl; auto.\nrewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto.\nsimpl.\neconstructor; split; eauto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : e # r1 = Vfloat n) (e0 : n = Float.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oaddf e ## (r2 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"simpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r2); simpl; auto.\nrewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : e # r1 = Vfloat n) (e0 : n = Float.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.addf e # r2 e # r2) = Some v /\\\n  Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"econstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r2); simpl; auto.\nrewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : e # r1 = Vfloat (Float.of_int (Int.repr 2))) : Val.lessdef (Val.mulf (Vfloat (Float.of_int (Int.repr 2))) e # r2)\n  (Val.addf e # r2 e # r2).","proofString":"destruct (e#r2); simpl; auto.\nrewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : e # r1 = Vfloat (Float.of_int (Int.repr 2))) (f : float) : Val.lessdef (Vfloat (Float.mul (Float.of_int (Int.repr 2)) f))\n  (Vfloat (Float.add f f)).","proofString":"rewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : e # r1 = Vfloat (Float.of_int (Int.repr 2))) (f : float) : Val.lessdef (Vfloat (Float.mul (Float.of_int (Int.repr 2)) f))\n  (Vfloat (Float.mul f (Float.of_int (Int.repr 2)))).","proofString":"rewrite Float.mul_commut; auto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : e # r1 = Vfloat n) (n0 : n <> Float.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omulf e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"simpl.\neconstructor; split; eauto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : e # r1 = Vfloat n) (n0 : n <> Float.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.mulf e # r1 e # r2) = Some v /\\\n  Val.lessdef (Val.mulf e # r1 e # r2) v.","proofString":"econstructor; split; eauto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : e # r2 = Vsingle n) : let (op, args) :=\n  if Float32.eq_dec n (Float32.of_int (Int.repr 2))\n  then (Oaddfs, r1 :: r1 :: nil)\n  else (Omulfs, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"destruct (Float32.eq_dec n (Float32.of_int (Int.repr 2))); intros.\nsimpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r1); simpl; auto.\nrewrite Float32.mul2_add; auto.\nsimpl.\neconstructor; split; eauto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : e # r2 = Vsingle n) (e0 : n = Float32.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oaddfs e ## (r1 :: r1 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"simpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r1); simpl; auto.\nrewrite Float32.mul2_add; auto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : e # r2 = Vsingle n) (e0 : n = Float32.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.addfs e # r1 e # r1) = Some v /\\\n  Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"econstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r1); simpl; auto.\nrewrite Float32.mul2_add; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vsingle (Float32.of_int (Int.repr 2))) : Val.lessdef (Val.mulfs e # r1 (Vsingle (Float32.of_int (Int.repr 2))))\n  (Val.addfs e # r1 e # r1).","proofString":"destruct (e#r1); simpl; auto.\nrewrite Float32.mul2_add; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : e # r2 = Vsingle (Float32.of_int (Int.repr 2))) (f : float32) : Val.lessdef (Vsingle (Float32.mul f (Float32.of_int (Int.repr 2))))\n  (Vsingle (Float32.add f f)).","proofString":"rewrite Float32.mul2_add; auto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : e # r2 = Vsingle n) (n0 : n <> Float32.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omulfs e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"simpl.\neconstructor; split; eauto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : e # r2 = Vsingle n) (n0 : n <> Float32.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.mulfs e # r1 e # r2) = Some v /\\\n  Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"econstructor; split; eauto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : e # r1 = Vsingle n) : let (op, args) :=\n  if Float32.eq_dec n (Float32.of_int (Int.repr 2))\n  then (Oaddfs, r2 :: r2 :: nil)\n  else (Omulfs, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"destruct (Float32.eq_dec n (Float32.of_int (Int.repr 2))); intros.\nsimpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto.\nsimpl.\neconstructor; split; eauto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : e # r1 = Vsingle n) (e0 : n = Float32.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oaddfs e ## (r2 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"simpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : e # r1 = Vsingle n) (e0 : n = Float32.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.addfs e # r2 e # r2) = Some v /\\\n  Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"econstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (e#r2); simpl; auto.\nrewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : e # r1 = Vsingle (Float32.of_int (Int.repr 2))) : Val.lessdef (Val.mulfs (Vsingle (Float32.of_int (Int.repr 2))) e # r2)\n  (Val.addfs e # r2 e # r2).","proofString":"destruct (e#r2); simpl; auto.\nrewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : e # r1 = Vsingle (Float32.of_int (Int.repr 2))) (f : float32) : Val.lessdef (Vsingle (Float32.mul (Float32.of_int (Int.repr 2)) f))\n  (Vsingle (Float32.add f f)).","proofString":"rewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : e # r1 = Vsingle (Float32.of_int (Int.repr 2))) (f : float32) : Val.lessdef (Vsingle (Float32.mul (Float32.of_int (Int.repr 2)) f))\n  (Vsingle (Float32.mul f (Float32.of_int (Int.repr 2)))).","proofString":"rewrite Float32.mul_commut; auto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : e # r1 = Vsingle n) (n0 : n <> Float32.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omulfs e ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"simpl.\neconstructor; split; eauto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : e # r1 = Vsingle n) (n0 : n <> Float32.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.mulfs e # r1 e # r2) = Some v /\\\n  Val.lessdef (Val.mulfs e # r1 e # r2) v.","proofString":"econstructor; split; eauto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) : let (op, args) :=\n  if vincl x (Uns Ptop s) then (Omove, r :: nil) else (Ozext s, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.zero_ext s e # r) v.","proofString":"destruct (vincl x (Uns Ptop s)) eqn:INCL.\nexists e#r; split; auto.\nassert (V: vmatch bc e#r (Uns Ptop s)).\neapply vmatch_ge; eauto.\napply vincl_ge; auto.\ninv V; simpl; auto.\nrewrite is_uns_zero_ext in H4 by auto.\nrewrite H4; auto.\neconstructor; split; simpl; eauto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Uns Ptop s) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.zero_ext s e # r) v.","proofString":"exists e#r; split; auto.\nassert (V: vmatch bc e#r (Uns Ptop s)).\neapply vmatch_ge; eauto.\napply vincl_ge; auto.\ninv V; simpl; auto.\nrewrite is_uns_zero_ext in H4 by auto.\nrewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Uns Ptop s) = true) : Val.lessdef (Val.zero_ext s e # r) e # r.","proofString":"assert (V: vmatch bc e#r (Uns Ptop s)).\neapply vmatch_ge; eauto.\napply vincl_ge; auto.\ninv V; simpl; auto.\nrewrite is_uns_zero_ext in H4 by auto.\nrewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Uns Ptop s) = true) : vmatch bc e # r (Uns Ptop s).","proofString":"eapply vmatch_ge; eauto.\napply vincl_ge; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Uns Ptop s) = true) : vge (Uns Ptop s) x.","proofString":"apply vincl_ge; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Uns Ptop s) = true) (V : vmatch bc e # r (Uns Ptop s)) : Val.lessdef (Val.zero_ext s e # r) e # r.","proofString":"inv V; simpl; auto.\nrewrite is_uns_zero_ext in H4 by auto.\nrewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Uns Ptop s) = true) (i : int) (H3 : 0 <= s) (H4 : is_uns s i) (H0 : Vint i = e # r) : Val.lessdef (Vint (Int.zero_ext s i)) (Vint i).","proofString":"rewrite is_uns_zero_ext in H4 by auto.\nrewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Uns Ptop s) = true) (i : int) (H3 : 0 <= s) (H4 : Int.zero_ext s i = i) (H0 : Vint i = e # r) : Val.lessdef (Vint (Int.zero_ext s i)) (Vint i).","proofString":"rewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Uns Ptop s) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ozext s) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.zero_ext s e # r) v.","proofString":"econstructor; split; simpl; eauto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) : let (op, args) :=\n  if vincl x (Sgn Ptop s) then (Omove, r :: nil) else (Osext s, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op e ## args m = Some v /\\\n  Val.lessdef (Val.sign_ext s e # r) v.","proofString":"destruct (vincl x (Sgn Ptop s)) eqn:INCL.\nexists e#r; split; auto.\nassert (V: vmatch bc e#r (Sgn Ptop s)).\neapply vmatch_ge; eauto.\napply vincl_ge; auto.\ninv V; simpl; auto.\nrewrite is_sgn_sign_ext in H4 by auto.\nrewrite H4; auto.\neconstructor; split; simpl; eauto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Sgn Ptop s) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove e ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.sign_ext s e # r) v.","proofString":"exists e#r; split; auto.\nassert (V: vmatch bc e#r (Sgn Ptop s)).\neapply vmatch_ge; eauto.\napply vincl_ge; auto.\ninv V; simpl; auto.\nrewrite is_sgn_sign_ext in H4 by auto.\nrewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Sgn Ptop s) = true) : Val.lessdef (Val.sign_ext s e # r) e # r.","proofString":"assert (V: vmatch bc e#r (Sgn Ptop s)).\neapply vmatch_ge; eauto.\napply vincl_ge; auto.\ninv V; simpl; auto.\nrewrite is_sgn_sign_ext in H4 by auto.\nrewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Sgn Ptop s) = true) : vmatch bc e # r (Sgn Ptop s).","proofString":"eapply vmatch_ge; eauto.\napply vincl_ge; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Sgn Ptop s) = true) : vge (Sgn Ptop s) x.","proofString":"apply vincl_ge; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Sgn Ptop s) = true) (V : vmatch bc e # r (Sgn Ptop s)) : Val.lessdef (Val.sign_ext s e # r) e # r.","proofString":"inv V; simpl; auto.\nrewrite is_sgn_sign_ext in H4 by auto.\nrewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Sgn Ptop s) = true) (i : int) (H3 : 0 < s) (H4 : is_sgn s i) (H0 : Vint i = e # r) : Val.lessdef (Vint (Int.sign_ext s i)) (Vint i).","proofString":"rewrite is_sgn_sign_ext in H4 by auto.\nrewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Sgn Ptop s) = true) (i : int) (H3 : 0 < s) (H4 : Int.sign_ext s i = i) (H0 : Vint i = e # r) : Val.lessdef (Vint (Int.sign_ext s i)) (Vint i).","proofString":"rewrite H4; auto."},{"statement":"(s : Z) (r : positive) (x : aval) (H : vmatch bc e # r x) (INCL : vincl x (Sgn Ptop s) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Osext s) e ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.sign_ext s e # r) v.","proofString":"econstructor; split; simpl; eauto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.add e # r1 e # r2) = Some v) : let (op', args') := make_addimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.add_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.add e # r2 e # r1) = Some v) : let (op', args') := make_addimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vint n1) : let (op', args') := make_addimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.add e # r2 (Vint n1)) w.","proofString":"apply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.add e # r1 e # r2) = Some v) : let (op', args') := make_addimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_addimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.add e # r1 (Vint n2)) w.","proofString":"apply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.add e # r1 (eval_shift s e # r2 a)) = Some v) : let (op', args') := make_addimm (eval_static_shift s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shift_correct.\napply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_addimm (eval_static_shift s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.add e # r1 (eval_shift s (Vint n2) a)) w.","proofString":"rewrite eval_static_shift_correct.\napply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_addimm (eval_static_shift s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.add e # r1 (Vint (eval_static_shift s n2 a))) w.","proofString":"apply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.sub e # r1 e # r2) = Some v) : let (op', args') := make_addimm (Int.neg n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite Val.sub_add_opp.\napply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_addimm (Int.neg n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.sub e # r1 (Vint n2)) w.","proofString":"rewrite Val.sub_add_opp.\napply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_addimm (Int.neg n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.add e # r1 (Vint (Int.neg n2))) w.","proofString":"apply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.sub e # r1 (eval_shift s e # r2 a)) = Some v) : let (op', args') := make_addimm (Int.neg (eval_static_shift s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shift_correct, Val.sub_add_opp.\napply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_addimm (Int.neg (eval_static_shift s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.sub e # r1 (eval_shift s (Vint n2) a)) w.","proofString":"rewrite eval_static_shift_correct, Val.sub_add_opp.\napply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_addimm (Int.neg (eval_static_shift s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.add e # r1 (Vint (Int.neg (eval_static_shift s n2 a)))) w.","proofString":"apply make_addimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mul e # r1 e # r2) = Some v) : let (op', args') := make_mulimm n1 r2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.mul_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_mulimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mul e # r2 e # r1) = Some v) : let (op', args') := make_mulimm n1 r2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_mulimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vint n1) : let (op', args') := make_mulimm n1 r2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mul e # r2 (Vint n1)) w.","proofString":"apply make_mulimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mul e # r1 e # r2) = Some v) : let (op', args') := make_mulimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_mulimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_mulimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mul e # r1 (Vint n2)) w.","proofString":"apply make_mulimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divs e # r1 e # r2 = Some v) : let (op', args') := make_divimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"assert (e#r2 = Vint n2).\nclear H0.\nInvApproxRegs; SimplVM; auto.\napply make_divimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divs e # r1 e # r2 = Some v) : e # r2 = Vint n2.","proofString":"clear H0.\nInvApproxRegs; SimplVM; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) : e # r2 = Vint n2.","proofString":"InvApproxRegs; SimplVM; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divs e # r1 e # r2 = Some v) (H1 : e # r2 = Vint n2) : let (op', args') := make_divimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"apply make_divimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divu e # r1 e # r2 = Some v) : let (op', args') := make_divuimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"assert (e#r2 = Vint n2).\nclear H0.\nInvApproxRegs; SimplVM; auto.\napply make_divuimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divu e # r1 e # r2 = Some v) : e # r2 = Vint n2.","proofString":"clear H0.\nInvApproxRegs; SimplVM; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) : e # r2 = Vint n2.","proofString":"InvApproxRegs; SimplVM; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divu e # r1 e # r2 = Some v) (H1 : e # r2 = Vint n2) : let (op', args') := make_divuimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"apply make_divuimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.and e # r1 e # r2) = Some v) : let (op', args') := make_andimm n1 r2 v2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.and_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.and e # r2 e # r1) = Some v) : let (op', args') := make_andimm n1 r2 v2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vint n1) : let (op', args') := make_andimm n1 r2 v2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.and e # r2 (Vint n1)) w.","proofString":"apply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.and e # r1 e # r2) = Some v) : let (op', args') := make_andimm n2 r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_andimm n2 r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.and e # r1 (Vint n2)) w.","proofString":"apply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.and e # r1 (eval_shift s e # r2 a)) = Some v) : let (op', args') := make_andimm (eval_static_shift s n2 a) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shift_correct.\napply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_andimm (eval_static_shift s n2 a) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.and e # r1 (eval_shift s (Vint n2) a)) w.","proofString":"rewrite eval_static_shift_correct.\napply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_andimm (eval_static_shift s n2 a) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.and e # r1 (Vint (eval_static_shift s n2 a))) w.","proofString":"apply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = AE.get r1 ae :: nil) (H0 : Some (Val.and e # r1 (Vint n)) = Some v) : let (op', args') := make_andimm n r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"inv H; inv H0.\napply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (n : int) (r1 : reg) : let (op', args') := make_andimm n r1 (AE.get r1 ae) in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.and e # r1 (Vint n)) w.","proofString":"apply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.or e # r1 e # r2) = Some v) : let (op', args') := make_orimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.or_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.or e # r2 e # r1) = Some v) : let (op', args') := make_orimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vint n1) : let (op', args') := make_orimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.or e # r2 (Vint n1)) w.","proofString":"apply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.or e # r1 e # r2) = Some v) : let (op', args') := make_orimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_orimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.or e # r1 (Vint n2)) w.","proofString":"apply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.or e # r1 (eval_shift s e # r2 a)) = Some v) : let (op', args') := make_orimm (eval_static_shift s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shift_correct.\napply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_orimm (eval_static_shift s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.or e # r1 (eval_shift s (Vint n2) a)) w.","proofString":"rewrite eval_static_shift_correct.\napply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_orimm (eval_static_shift s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.or e # r1 (Vint (eval_static_shift s n2 a))) w.","proofString":"apply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xor e # r1 e # r2) = Some v) : let (op', args') := make_xorimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.xor_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : I n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xor e # r2 e # r1) = Some v) : let (op', args') := make_xorimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vint n1) : let (op', args') := make_xorimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xor e # r2 (Vint n1)) w.","proofString":"apply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xor e # r1 e # r2) = Some v) : let (op', args') := make_xorimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_xorimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xor e # r1 (Vint n2)) w.","proofString":"apply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xor e # r1 (eval_shift s e # r2 a)) = Some v) : let (op', args') := make_xorimm (eval_static_shift s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shift_correct.\napply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_xorimm (eval_static_shift s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xor e # r1 (eval_shift s (Vint n2) a)) w.","proofString":"rewrite eval_static_shift_correct.\napply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_xorimm (eval_static_shift s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xor e # r1 (Vint (eval_static_shift s n2 a))) w.","proofString":"apply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.and e # r1 (Val.notint e # r2)) = Some v) : let (op', args') := make_andimm (Int.not n2) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_andimm (Int.not n2) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.and e # r1 (Vint (Int.not n2))) w.","proofString":"apply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.and e # r1 (Val.notint (eval_shift s e # r2 a))) = Some v) : let (op', args') := make_andimm (Int.not (eval_static_shift s n2 a)) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shift_correct.\napply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_andimm (Int.not (eval_static_shift s n2 a)) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.and e # r1 (Val.notint (eval_shift s (Vint n2) a))) w.","proofString":"rewrite eval_static_shift_correct.\napply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_andimm (Int.not (eval_static_shift s n2 a)) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.and e # r1 (Val.notint (Vint (eval_static_shift s n2 a))))\n    w.","proofString":"apply make_andimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.or e # r1 (Val.notint e # r2)) = Some v) : let (op', args') := make_orimm (Int.not n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_orimm (Int.not n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.or e # r1 (Vint (Int.not n2))) w.","proofString":"apply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.or e # r1 (Val.notint (eval_shift s e # r2 a))) = Some v) : let (op', args') := make_orimm (Int.not (eval_static_shift s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shift_correct.\napply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_orimm (Int.not (eval_static_shift s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.or e # r1 (Val.notint (eval_shift s (Vint n2) a))) w.","proofString":"rewrite eval_static_shift_correct.\napply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_orimm (Int.not (eval_static_shift s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.or e # r1 (Val.notint (Vint (eval_static_shift s n2 a))))\n    w.","proofString":"apply make_orimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xor e # r1 (Val.notint e # r2)) = Some v) : let (op', args') := make_xorimm (Int.not n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_xorimm (Int.not n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xor e # r1 (Vint (Int.not n2))) w.","proofString":"apply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xor e # r1 (Val.notint (eval_shift s e # r2 a))) = Some v) : let (op', args') := make_xorimm (Int.not (eval_static_shift s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shift_correct.\napply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_xorimm (Int.not (eval_static_shift s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xor e # r1 (Val.notint (eval_shift s (Vint n2) a))) w.","proofString":"rewrite eval_static_shift_correct.\napply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount32) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_xorimm (Int.not (eval_static_shift s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xor e # r1 (Val.notint (Vint (eval_static_shift s n2 a))))\n    w.","proofString":"apply make_xorimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.shl e # r1 e # r2) = Some v) : let (op', args') := make_shlimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_shlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_shlimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.shl e # r1 (Vint n2)) w.","proofString":"apply make_shlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.shr e # r1 e # r2) = Some v) : let (op', args') := make_shrimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_shrimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_shrimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.shr e # r1 (Vint n2)) w.","proofString":"apply make_shrimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.shru e # r1 e # r2) = Some v) : let (op', args') := make_shruimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_shruimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_shruimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.shru e # r1 (Vint n2)) w.","proofString":"apply make_shruimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : Z) (r1 : reg) (v1 : aval) (H : v1 :: nil = AE.get r1 ae :: nil) (H0 : Some (Val.zero_ext s e # r1) = Some v) : let (op', args') := make_zext s r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_zext_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : Z) (r1 : reg) (v1 : aval) (H : vmatch bc e # r1 v1) : let (op', args') := make_zext s r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.zero_ext s e # r1) w.","proofString":"apply make_zext_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : Z) (r1 : reg) (v1 : aval) (H : v1 :: nil = AE.get r1 ae :: nil) (H0 : Some (Val.sign_ext s e # r1) = Some v) : let (op', args') := make_sext s r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_sext_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : Z) (r1 : reg) (v1 : aval) (H : vmatch bc e # r1 v1) : let (op', args') := make_sext s r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.sign_ext s e # r1) w.","proofString":"apply make_sext_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.addl e # r1 e # r2) = Some v) : let (op', args') := make_addlimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.addl_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.addl e # r2 e # r1) = Some v) : let (op', args') := make_addlimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vlong n1) : let (op', args') := make_addlimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.addl e # r2 (Vlong n1)) w.","proofString":"apply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.addl e # r1 e # r2) = Some v) : let (op', args') := make_addlimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_addlimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.addl e # r1 (Vlong n2)) w.","proofString":"apply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.addl e # r1 (eval_shiftl s e # r2 a)) = Some v) : let (op', args') := make_addlimm (eval_static_shiftl s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shiftl_correct.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_addlimm (eval_static_shiftl s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.addl e # r1 (eval_shiftl s (Vlong n2) a)) w.","proofString":"rewrite eval_static_shiftl_correct.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_addlimm (eval_static_shiftl s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.addl e # r1 (Vlong (eval_static_shiftl s n2 a))) w.","proofString":"apply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (x : extension) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.addl e # r1 (eval_extend x e # r2 a)) = Some v) : let (op', args') := make_addlimm (eval_static_extend x n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_extend_correct.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (x : extension) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_addlimm (eval_static_extend x n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.addl e # r1 (eval_extend x (Vint n2) a)) w.","proofString":"rewrite eval_static_extend_correct.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (x : extension) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_addlimm (eval_static_extend x n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.addl e # r1 (Vlong (eval_static_extend x n2 a))) w.","proofString":"apply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.subl e # r1 e # r2) = Some v) : let (op', args') := make_addlimm (Int64.neg n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite Val.subl_addl_opp.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_addlimm (Int64.neg n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.subl e # r1 (Vlong n2)) w.","proofString":"rewrite Val.subl_addl_opp.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_addlimm (Int64.neg n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.addl e # r1 (Vlong (Int64.neg n2))) w.","proofString":"apply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.subl e # r1 (eval_shiftl s e # r2 a)) = Some v) : let (op', args') :=\n  make_addlimm (Int64.neg (eval_static_shiftl s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shiftl_correct, Val.subl_addl_opp.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') :=\n  make_addlimm (Int64.neg (eval_static_shiftl s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.subl e # r1 (eval_shiftl s (Vlong n2) a)) w.","proofString":"rewrite eval_static_shiftl_correct, Val.subl_addl_opp.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') :=\n  make_addlimm (Int64.neg (eval_static_shiftl s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef\n    (Val.addl e # r1 (Vlong (Int64.neg (eval_static_shiftl s n2 a)))) w.","proofString":"apply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (x : extension) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.subl e # r1 (eval_extend x e # r2 a)) = Some v) : let (op', args') :=\n  make_addlimm (Int64.neg (eval_static_extend x n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_extend_correct, Val.subl_addl_opp.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (x : extension) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') :=\n  make_addlimm (Int64.neg (eval_static_extend x n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.subl e # r1 (eval_extend x (Vint n2) a)) w.","proofString":"rewrite eval_static_extend_correct, Val.subl_addl_opp.\napply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (x : extension) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') :=\n  make_addlimm (Int64.neg (eval_static_extend x n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef\n    (Val.addl e # r1 (Vlong (Int64.neg (eval_static_extend x n2 a)))) w.","proofString":"apply make_addlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mull e # r1 e # r2) = Some v) : let (op', args') := make_mullimm n1 r2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.mull_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_mullimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mull e # r2 e # r1) = Some v) : let (op', args') := make_mullimm n1 r2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_mullimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vlong n1) : let (op', args') := make_mullimm n1 r2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mull e # r2 (Vlong n1)) w.","proofString":"apply make_mullimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mull e # r1 e # r2) = Some v) : let (op', args') := make_mullimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_mullimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_mullimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mull e # r1 (Vlong n2)) w.","proofString":"apply make_mullimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divls e # r1 e # r2 = Some v) : let (op', args') := make_divlimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"assert (e#r2 = Vlong n2).\nclear H0.\nInvApproxRegs; SimplVM; auto.\napply make_divlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divls e # r1 e # r2 = Some v) : e # r2 = Vlong n2.","proofString":"clear H0.\nInvApproxRegs; SimplVM; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) : e # r2 = Vlong n2.","proofString":"InvApproxRegs; SimplVM; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divls e # r1 e # r2 = Some v) (H1 : e # r2 = Vlong n2) : let (op', args') := make_divlimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"apply make_divlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divlu e # r1 e # r2 = Some v) : let (op', args') := make_divluimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"assert (e#r2 = Vlong n2).\nclear H0.\nInvApproxRegs; SimplVM; auto.\napply make_divluimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divlu e # r1 e # r2 = Some v) : e # r2 = Vlong n2.","proofString":"clear H0.\nInvApproxRegs; SimplVM; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) : e # r2 = Vlong n2.","proofString":"InvApproxRegs; SimplVM; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Val.divlu e # r1 e # r2 = Some v) (H1 : e # r2 = Vlong n2) : let (op', args') := make_divluimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"apply make_divluimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.andl e # r1 e # r2) = Some v) : let (op', args') := make_andlimm n1 r2 v2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.andl_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.andl e # r2 e # r1) = Some v) : let (op', args') := make_andlimm n1 r2 v2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vlong n1) : let (op', args') := make_andlimm n1 r2 v2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.andl e # r2 (Vlong n1)) w.","proofString":"apply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.andl e # r1 e # r2) = Some v) : let (op', args') := make_andlimm n2 r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_andlimm n2 r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.andl e # r1 (Vlong n2)) w.","proofString":"apply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.andl e # r1 (eval_shiftl s e # r2 a)) = Some v) : let (op', args') := make_andlimm (eval_static_shiftl s n2 a) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shiftl_correct.\napply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_andlimm (eval_static_shiftl s n2 a) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.andl e # r1 (eval_shiftl s (Vlong n2) a)) w.","proofString":"rewrite eval_static_shiftl_correct.\napply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_andlimm (eval_static_shiftl s n2 a) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.andl e # r1 (Vlong (eval_static_shiftl s n2 a))) w.","proofString":"apply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (n : int64) (r1 : reg) (v1 : aval) (H : v1 :: nil = AE.get r1 ae :: nil) (H0 : Some (Val.andl e # r1 (Vlong n)) = Some v) : let (op', args') := make_andlimm n r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"inv H; inv H0.\napply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (n : int64) (r1 : reg) : let (op', args') := make_andlimm n r1 (AE.get r1 ae) in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.andl e # r1 (Vlong n)) w.","proofString":"apply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.orl e # r1 e # r2) = Some v) : let (op', args') := make_orlimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.orl_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.orl e # r2 e # r1) = Some v) : let (op', args') := make_orlimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vlong n1) : let (op', args') := make_orlimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.orl e # r2 (Vlong n1)) w.","proofString":"apply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.orl e # r1 e # r2) = Some v) : let (op', args') := make_orlimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_orlimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.orl e # r1 (Vlong n2)) w.","proofString":"apply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.orl e # r1 (eval_shiftl s e # r2 a)) = Some v) : let (op', args') := make_orlimm (eval_static_shiftl s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shiftl_correct.\napply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_orlimm (eval_static_shiftl s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.orl e # r1 (eval_shiftl s (Vlong n2) a)) w.","proofString":"rewrite eval_static_shiftl_correct.\napply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_orlimm (eval_static_shiftl s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.orl e # r1 (Vlong (eval_static_shiftl s n2 a))) w.","proofString":"apply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xorl e # r1 e # r2) = Some v) : let (op', args') := make_xorlimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite Val.xorl_commut in H0.\nInvApproxRegs; SimplVM; inv H0.\napply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : L n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xorl e # r2 e # r1) = Some v) : let (op', args') := make_xorlimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vlong n1) : let (op', args') := make_xorlimm n1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xorl e # r2 (Vlong n1)) w.","proofString":"apply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xorl e # r1 e # r2) = Some v) : let (op', args') := make_xorlimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_xorlimm n2 r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xorl e # r1 (Vlong n2)) w.","proofString":"apply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xorl e # r1 (eval_shiftl s e # r2 a)) = Some v) : let (op', args') := make_xorlimm (eval_static_shiftl s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shiftl_correct.\napply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_xorlimm (eval_static_shiftl s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xorl e # r1 (eval_shiftl s (Vlong n2) a)) w.","proofString":"rewrite eval_static_shiftl_correct.\napply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_xorlimm (eval_static_shiftl s n2 a) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xorl e # r1 (Vlong (eval_static_shiftl s n2 a))) w.","proofString":"apply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.andl e # r1 (Val.notl e # r2)) = Some v) : let (op', args') := make_andlimm (Int64.not n2) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_andlimm (Int64.not n2) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.andl e # r1 (Vlong (Int64.not n2))) w.","proofString":"apply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.andl e # r1 (Val.notl (eval_shiftl s e # r2 a))) = Some v) : let (op', args') :=\n  make_andlimm (Int64.not (eval_static_shiftl s n2 a)) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shiftl_correct.\napply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') :=\n  make_andlimm (Int64.not (eval_static_shiftl s n2 a)) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.andl e # r1 (Val.notl (eval_shiftl s (Vlong n2) a))) w.","proofString":"rewrite eval_static_shiftl_correct.\napply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') :=\n  make_andlimm (Int64.not (eval_static_shiftl s n2 a)) r1 v1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef\n    (Val.andl e # r1 (Val.notl (Vlong (eval_static_shiftl s n2 a)))) w.","proofString":"apply make_andlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.orl e # r1 (Val.notl e # r2)) = Some v) : let (op', args') := make_orlimm (Int64.not n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_orlimm (Int64.not n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.orl e # r1 (Vlong (Int64.not n2))) w.","proofString":"apply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.orl e # r1 (Val.notl (eval_shiftl s e # r2 a))) = Some v) : let (op', args') := make_orlimm (Int64.not (eval_static_shiftl s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shiftl_correct.\napply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_orlimm (Int64.not (eval_static_shiftl s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.orl e # r1 (Val.notl (eval_shiftl s (Vlong n2) a))) w.","proofString":"rewrite eval_static_shiftl_correct.\napply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_orlimm (Int64.not (eval_static_shiftl s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.orl e # r1 (Val.notl (Vlong (eval_static_shiftl s n2 a))))\n    w.","proofString":"apply make_orlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xorl e # r1 (Val.notl e # r2)) = Some v) : let (op', args') := make_xorlimm (Int64.not n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') := make_xorlimm (Int64.not n2) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xorl e # r1 (Vlong (Int64.not n2))) w.","proofString":"apply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H : v1 :: L n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.xorl e # r1 (Val.notl (eval_shiftl s e # r2 a))) = Some v) : let (op', args') :=\n  make_xorlimm (Int64.not (eval_static_shiftl s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite eval_static_shiftl_correct.\napply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') :=\n  make_xorlimm (Int64.not (eval_static_shiftl s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.xorl e # r1 (Val.notl (eval_shiftl s (Vlong n2) a))) w.","proofString":"rewrite eval_static_shiftl_correct.\napply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (s : shift) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vlong n2) : let (op', args') :=\n  make_xorlimm (Int64.not (eval_static_shiftl s n2 a)) r1 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef\n    (Val.xorl e # r1 (Val.notl (Vlong (eval_static_shiftl s n2 a)))) w.","proofString":"apply make_xorlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.shll e # r1 e # r2) = Some v) : let (op', args') := make_shllimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_shllimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_shllimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.shll e # r1 (Vint n2)) w.","proofString":"apply make_shllimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.shrl e # r1 e # r2) = Some v) : let (op', args') := make_shrlimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_shrlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_shrlimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.shrl e # r1 (Vint n2)) w.","proofString":"apply make_shrlimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : int) (H : v1 :: I n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.shrlu e # r1 e # r2) = Some v) : let (op', args') := make_shrluimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\napply make_shrluimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : int) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vint n2) : let (op', args') := make_shrluimm n2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.shrlu e # r1 (Vint n2)) w.","proofString":"apply make_shrluimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (c : condition) (args0 : list reg) (vl0 : list aval) (H : vl0 = map (fun r : positive => AE.get r ae) args0) (H0 : Some (Val.of_optbool (eval_condition c e ## args0 m)) = Some v) : let (op', args') := make_cmp c args0 vl0 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"inv H0.\napply make_cmp_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (c : condition) (args0 : list reg) : let (op', args') :=\n  make_cmp c args0 (map (fun r : positive => AE.get r ae) args0) in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.of_optbool (eval_condition c e ## args0 m)) w.","proofString":"apply make_cmp_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (c : condition) (ty : AST.typ) (r1 r2 : reg) (args0 : list reg) (v1 v2 : aval) (vl0 : list aval) (H : v1 :: v2 :: vl0 =\nAE.get r1 ae :: AE.get r2 ae :: map (fun r : positive => AE.get r ae) args0) (H0 : Some (Val.select (eval_condition c e ## args0 m) e # r1 e # r2 ty) = Some v) : let (op', args') := make_select c ty r1 r2 args0 vl0 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"inv H0.\napply make_select_correct; congruence."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (c : condition) (ty : AST.typ) (r1 r2 : reg) (args0 : list reg) (v1 v2 : aval) (vl0 : list aval) (H : v1 :: v2 :: vl0 =\nAE.get r1 ae :: AE.get r2 ae :: map (fun r : positive => AE.get r ae) args0) : let (op', args') := make_select c ty r1 r2 args0 vl0 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.select (eval_condition c e ## args0 m) e # r1 e # r2 ty) w.","proofString":"apply make_select_correct; congruence."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : float) (H : v1 :: F n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mulf e # r1 e # r2) = Some v) : let (op', args') := make_mulfimm n2 r1 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite <- H2.\napply make_mulfimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : float) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vfloat n2) : let (op', args') := make_mulfimm n2 r1 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mulf e # r1 (Vfloat n2)) w.","proofString":"rewrite <- H2.\napply make_mulfimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : float) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vfloat n2) : let (op', args') := make_mulfimm n2 r1 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mulf e # r1 e # r2) w.","proofString":"apply make_mulfimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : F n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mulf e # r1 e # r2) = Some v) : let (op', args') := make_mulfimm n1 r2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nfold (Val.mulf (Vfloat n1) e#r2).\nrewrite <- H2.\napply make_mulfimm_correct_2; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vfloat n1) : let (op', args') := make_mulfimm n1 r2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef\n    match e # r2 with\n    | Vfloat f2 => Vfloat (Float.mul n1 f2)\n    | _ => Vundef\n    end w.","proofString":"fold (Val.mulf (Vfloat n1) e#r2).\nrewrite <- H2.\napply make_mulfimm_correct_2; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vfloat n1) : let (op', args') := make_mulfimm n1 r2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mulf (Vfloat n1) e # r2) w.","proofString":"rewrite <- H2.\napply make_mulfimm_correct_2; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : float) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vfloat n1) : let (op', args') := make_mulfimm n1 r2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mulf e # r1 e # r2) w.","proofString":"apply make_mulfimm_correct_2; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H : v1 :: FS n2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mulfs e # r1 e # r2) = Some v) : let (op', args') := make_mulfsimm n2 r1 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nrewrite <- H2.\napply make_mulfsimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vsingle n2) : let (op', args') := make_mulfsimm n2 r1 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mulfs e # r1 (Vsingle n2)) w.","proofString":"rewrite <- H2.\napply make_mulfsimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (v1 : aval) (n2 : float32) (H1 : vmatch bc e # r1 v1) (H2 : e # r2 = Vsingle n2) : let (op', args') := make_mulfsimm n2 r1 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mulfs e # r1 e # r2) w.","proofString":"apply make_mulfsimm_correct; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : FS n1 :: v2 :: nil = AE.get r1 ae :: AE.get r2 ae :: nil) (H0 : Some (Val.mulfs e # r1 e # r2) = Some v) : let (op', args') := make_mulfsimm n1 r2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef v w.","proofString":"InvApproxRegs; SimplVM; inv H0.\nfold (Val.mulfs (Vsingle n1) e#r2).\nrewrite <- H2.\napply make_mulfsimm_correct_2; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vsingle n1) : let (op', args') := make_mulfsimm n1 r2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef\n    match e # r2 with\n    | Vsingle f2 => Vsingle (Float32.mul n1 f2)\n    | _ => Vundef\n    end w.","proofString":"fold (Val.mulfs (Vsingle n1) e#r2).\nrewrite <- H2.\napply make_mulfsimm_correct_2; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vsingle n1) : let (op', args') := make_mulfsimm n1 r2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mulfs (Vsingle n1) e # r2) w.","proofString":"rewrite <- H2.\napply make_mulfsimm_correct_2; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (r1 r2 : reg) (n1 : float32) (v2 : aval) (H : vmatch bc e # r2 v2) (H2 : e # r1 = Vsingle n1) : let (op', args') := make_mulfsimm n1 r2 r1 r2 in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' e ## args' m = Some w /\\\n  Val.lessdef (Val.mulfs e # r1 e # r2) w.","proofString":"apply make_mulfsimm_correct_2; auto."},{"statement":"(op : operation) (args : list positive) (vl : list AVal.t) (v : val) (op0 : operation) (args0 : list reg) (vl0 : list aval) (H : vl0 = map (fun r : positive => AE.get r ae) args0) (H0 : eval_operation ge (Vptr sp Ptrofs.zero) op0 e ## args0 m = Some v) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op0 e ## args0 m = Some w /\\\n  Val.lessdef v w.","proofString":"exists v; auto."},{"statement":"(addr : addressing) (args : list positive) (vl : list AVal.t) (res : val) : vl = map (fun r : positive => AE.get r ae) args ->\neval_addressing ge (Vptr sp Ptrofs.zero) addr e ## args = Some res ->\nlet (addr', args') := addr_strength_reduction addr args vl in\nexists res' : val,\n  eval_addressing ge (Vptr sp Ptrofs.zero) addr' e ## args' = Some res' /\\\n  Val.lessdef res res'.","proofString":"unfold addr_strength_reduction.\ndestruct (addr_strength_reduction_match addr args vl); simpl;  intros VL EA; InvApproxRegs; SimplVM; try (inv EA).\neconstructor; split; eauto.\ninv H0; simpl; auto.\nrewrite H2.\nunfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge symb); auto.\nrewrite Ptrofs.add_zero_l.\neconstructor; split; eauto.\ninv H0; auto.\nrewrite H2; auto.\nrewrite Ptrofs.add_zero_l.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto.\nrewrite Ptrofs.add_zero_l.\neconstructor; split; eauto.\ninv H0; auto.\nrewrite H3.\nrewrite Ptrofs.add_commut; auto.\neconstructor; split; eauto.\nrewrite Val.addl_commut.\nauto.\neconstructor; split; eauto.\nrewrite Ptrofs.add_zero_l.\nrewrite a64_range.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto.\nrewrite a64_range.\neconstructor; split; eauto.\nrewrite Ptrofs.add_zero_l, eval_static_extend_correct.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto.\nrewrite eval_static_extend_correct.\neconstructor; split; eauto.\nexists res; auto."},{"statement":"(addr : addressing) (args : list positive) (vl : list AVal.t) (res : val) : vl = map (fun r : positive => AE.get r ae) args ->\neval_addressing ge (Vptr sp Ptrofs.zero) addr e ## args = Some res ->\nlet (addr', args') :=\n  match addr_strength_reduction_match addr args vl with\n  | addr_strength_reduction_case1 n _ symb n1 =>\n      (Aglobal symb (Ptrofs.add n1 (Ptrofs.of_int64 n)), nil)\n  | addr_strength_reduction_case2 n _ n1 =>\n      (Ainstack (Ptrofs.add n1 (Ptrofs.of_int64 n)), nil)\n  | addr_strength_reduction_case3 _ _ n1 n2 =>\n      (Ainstack (Ptrofs.add n1 (Ptrofs.of_int64 n2)), nil)\n  | addr_strength_reduction_case4 _ _ n1 n2 =>\n      (Ainstack (Ptrofs.add (Ptrofs.of_int64 n1) n2), nil)\n  | addr_strength_reduction_case5 _ r2 n1 _ => (Aindexed n1, r2 :: nil)\n  | addr_strength_reduction_case6 r1 _ _ n2 => (Aindexed n2, r1 :: nil)\n  | addr_strength_reduction_case7 a _ _ n1 n2 =>\n      (Ainstack (Ptrofs.add n1 (Ptrofs.of_int64 (Int64.shl' n2 a))), nil)\n  | addr_strength_reduction_case8 a r1 _ _ n2 =>\n      (Aindexed (Int64.shl' n2 a), r1 :: nil)\n  | addr_strength_reduction_case9 x a _ _ n1 n2 =>\n      (Ainstack (Ptrofs.add n1 (Ptrofs.of_int64 (eval_static_extend x n2 a))),\n       nil)\n  | addr_strength_reduction_case10 x a r1 _ _ n2 =>\n      (Aindexed (eval_static_extend x n2 a), r1 :: nil)\n  | addr_strength_reduction_default addr0 args0 _ => (addr0, args0)\n  end in\nexists res' : val,\n  eval_addressing ge (Vptr sp Ptrofs.zero) addr' e ## args' = Some res' /\\\n  Val.lessdef res res'.","proofString":"destruct (addr_strength_reduction_match addr args vl); simpl;  intros VL EA; InvApproxRegs; SimplVM; try (inv EA).\neconstructor; split; eauto.\ninv H0; simpl; auto.\nrewrite H2.\nunfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge symb); auto.\nrewrite Ptrofs.add_zero_l.\neconstructor; split; eauto.\ninv H0; auto.\nrewrite H2; auto.\nrewrite Ptrofs.add_zero_l.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto.\nrewrite Ptrofs.add_zero_l.\neconstructor; split; eauto.\ninv H0; auto.\nrewrite H3.\nrewrite Ptrofs.add_commut; auto.\neconstructor; split; eauto.\nrewrite Val.addl_commut.\nauto.\neconstructor; split; eauto.\nrewrite Ptrofs.add_zero_l.\nrewrite a64_range.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto.\nrewrite a64_range.\neconstructor; split; eauto.\nrewrite Ptrofs.add_zero_l, eval_static_extend_correct.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto.\nrewrite eval_static_extend_correct.\neconstructor; split; eauto.\nexists res; auto."},{"statement":"(n : int64) (r1 : reg) (symb : AST.ident) (n1 : ptrofs) (H0 : Val.lessdef e # r1 (Genv.symbol_address ge symb n1)) : exists res' : val,\n  Some (Genv.symbol_address ge symb (Ptrofs.add n1 (Ptrofs.of_int64 n))) =\n  Some res' /\\ Val.lessdef (Val.addl e # r1 (Vlong n)) res'.","proofString":"econstructor; split; eauto.\ninv H0; simpl; auto.\nrewrite H2.\nunfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge symb); auto."},{"statement":"(n : int64) (r1 : reg) (symb : AST.ident) (n1 : ptrofs) (H0 : Val.lessdef e # r1 (Genv.symbol_address ge symb n1)) : Val.lessdef (Val.addl e # r1 (Vlong n))\n  (Genv.symbol_address ge symb (Ptrofs.add n1 (Ptrofs.of_int64 n))).","proofString":"inv H0; simpl; auto.\nrewrite H2.\nunfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge symb); auto."},{"statement":"(n : int64) (r1 : reg) (symb : AST.ident) (n1 : ptrofs) (H2 : e # r1 = Genv.symbol_address ge symb n1) : Val.lessdef (Val.addl e # r1 (Vlong n))\n  (Genv.symbol_address ge symb (Ptrofs.add n1 (Ptrofs.of_int64 n))).","proofString":"rewrite H2.\nunfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge symb); auto."},{"statement":"(n : int64) (r1 : reg) (symb : AST.ident) (n1 : ptrofs) (H2 : e # r1 = Genv.symbol_address ge symb n1) : Val.lessdef (Val.addl (Genv.symbol_address ge symb n1) (Vlong n))\n  (Genv.symbol_address ge symb (Ptrofs.add n1 (Ptrofs.of_int64 n))).","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge symb); auto."},{"statement":"(n : int64) (r1 : reg) (symb : AST.ident) (n1 : ptrofs) (H2 : e # r1 = Genv.symbol_address ge symb n1) : Val.lessdef\n  (Val.addl\n     match Genv.find_symbol ge symb with\n     | Some b => Vptr b n1\n     | None => Vundef\n     end (Vlong n))\n  match Genv.find_symbol ge symb with\n  | Some b => Vptr b (Ptrofs.add n1 (Ptrofs.of_int64 n))\n  | None => Vundef\n  end.","proofString":"destruct (Genv.find_symbol ge symb); auto."},{"statement":"(n : int64) (r1 : reg) (n1 : ptrofs) (H0 : Val.lessdef e # r1 (Vptr sp n1)) : exists res' : val,\n  Some (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add n1 (Ptrofs.of_int64 n)))) =\n  Some res' /\\ Val.lessdef (Val.addl e # r1 (Vlong n)) res'.","proofString":"rewrite Ptrofs.add_zero_l.\neconstructor; split; eauto.\ninv H0; auto.\nrewrite H2; auto."},{"statement":"(n : int64) (r1 : reg) (n1 : ptrofs) (H0 : Val.lessdef e # r1 (Vptr sp n1)) : exists res' : val,\n  Some (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n))) = Some res' /\\\n  Val.lessdef (Val.addl e # r1 (Vlong n)) res'.","proofString":"econstructor; split; eauto.\ninv H0; auto.\nrewrite H2; auto."},{"statement":"(n : int64) (r1 : reg) (n1 : ptrofs) (H0 : Val.lessdef e # r1 (Vptr sp n1)) : Val.lessdef (Val.addl e # r1 (Vlong n))\n  (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n))).","proofString":"inv H0; auto.\nrewrite H2; auto."},{"statement":"(n : int64) (r1 : reg) (n1 : ptrofs) (H2 : e # r1 = Vptr sp n1) : Val.lessdef (Val.addl e # r1 (Vlong n))\n  (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n))).","proofString":"rewrite H2; auto."},{"statement":"(r1 r2 : reg) (n1 : ptrofs) (n2 : int64) (H1 : e # r2 = Vlong n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : exists res' : val,\n  Some\n    (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add n1 (Ptrofs.of_int64 n2)))) =\n  Some res' /\\ Val.lessdef (Val.addl e # r1 (Vlong n2)) res'.","proofString":"rewrite Ptrofs.add_zero_l.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto."},{"statement":"(r1 r2 : reg) (n1 : ptrofs) (n2 : int64) (H1 : e # r2 = Vlong n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : exists res' : val,\n  Some (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2))) = Some res' /\\\n  Val.lessdef (Val.addl e # r1 (Vlong n2)) res'.","proofString":"econstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto."},{"statement":"(r1 r2 : reg) (n1 : ptrofs) (n2 : int64) (H1 : e # r2 = Vlong n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : Val.lessdef (Val.addl e # r1 (Vlong n2))\n  (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2))).","proofString":"inv H; auto.\nrewrite H3; auto."},{"statement":"(r1 r2 : reg) (n1 : ptrofs) (n2 : int64) (H1 : e # r2 = Vlong n2) (H3 : e # r1 = Vptr sp n1) : Val.lessdef (Val.addl e # r1 (Vlong n2))\n  (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2))).","proofString":"rewrite H3; auto."},{"statement":"(r1 r2 : reg) (n1 : int64) (n2 : ptrofs) (H1 : e # r1 = Vlong n1) (H0 : Val.lessdef e # r2 (Vptr sp n2)) : exists res' : val,\n  Some\n    (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add (Ptrofs.of_int64 n1) n2))) =\n  Some res' /\\\n  Val.lessdef\n    match e # r2 with\n    | Vlong n0 => Vlong (Int64.add n1 n0)\n    | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n    | _ => Vundef\n    end res'.","proofString":"rewrite Ptrofs.add_zero_l.\neconstructor; split; eauto.\ninv H0; auto.\nrewrite H3.\nrewrite Ptrofs.add_commut; auto."},{"statement":"(r1 r2 : reg) (n1 : int64) (n2 : ptrofs) (H1 : e # r1 = Vlong n1) (H0 : Val.lessdef e # r2 (Vptr sp n2)) : exists res' : val,\n  Some (Vptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2)) = Some res' /\\\n  Val.lessdef\n    match e # r2 with\n    | Vlong n0 => Vlong (Int64.add n1 n0)\n    | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n    | _ => Vundef\n    end res'.","proofString":"econstructor; split; eauto.\ninv H0; auto.\nrewrite H3.\nrewrite Ptrofs.add_commut; auto."},{"statement":"(r1 r2 : reg) (n1 : int64) (n2 : ptrofs) (H1 : e # r1 = Vlong n1) (H0 : Val.lessdef e # r2 (Vptr sp n2)) : Val.lessdef\n  match e # r2 with\n  | Vlong n0 => Vlong (Int64.add n1 n0)\n  | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n  | _ => Vundef\n  end (Vptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2)).","proofString":"inv H0; auto.\nrewrite H3.\nrewrite Ptrofs.add_commut; auto."},{"statement":"(r1 r2 : reg) (n1 : int64) (n2 : ptrofs) (H1 : e # r1 = Vlong n1) (H3 : e # r2 = Vptr sp n2) : Val.lessdef\n  match e # r2 with\n  | Vlong n0 => Vlong (Int64.add n1 n0)\n  | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n  | _ => Vundef\n  end (Vptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2)).","proofString":"rewrite H3.\nrewrite Ptrofs.add_commut; auto."},{"statement":"(r1 r2 : reg) (n1 : int64) (n2 : ptrofs) (H1 : e # r1 = Vlong n1) (H3 : e # r2 = Vptr sp n2) : Val.lessdef (Vptr sp (Ptrofs.add n2 (Ptrofs.of_int64 n1)))\n  (Vptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2)).","proofString":"rewrite Ptrofs.add_commut; auto."},{"statement":"(r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vlong n1) : exists res' : val,\n  Some (Val.addl e # r2 (Vlong n1)) = Some res' /\\\n  Val.lessdef\n    match e # r2 with\n    | Vlong n2 => Vlong (Int64.add n1 n2)\n    | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n    | _ => Vundef\n    end res'.","proofString":"econstructor; split; eauto.\nrewrite Val.addl_commut.\nauto."},{"statement":"(r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vlong n1) : Val.lessdef\n  match e # r2 with\n  | Vlong n2 => Vlong (Int64.add n1 n2)\n  | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n  | _ => Vundef\n  end (Val.addl e # r2 (Vlong n1)).","proofString":"rewrite Val.addl_commut.\nauto."},{"statement":"(r1 r2 : reg) (n1 : int64) (v2 : aval) (H : vmatch bc e # r2 v2) (H1 : e # r1 = Vlong n1) : Val.lessdef\n  match e # r2 with\n  | Vlong n2 => Vlong (Int64.add n1 n2)\n  | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n  | _ => Vundef\n  end (Val.addl (Vlong n1) e # r2).","proofString":"auto."},{"statement":"(r1 r2 : reg) (v1 : aval) (n2 : int64) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vlong n2) : exists res' : val,\n  Some (Val.addl e # r1 (Vlong n2)) = Some res' /\\\n  Val.lessdef (Val.addl e # r1 (Vlong n2)) res'.","proofString":"econstructor; split; eauto."},{"statement":"(a : amount64) (r1 r2 : reg) (n1 : ptrofs) (n2 : int64) (H1 : e # r2 = Vlong n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : exists res' : val,\n  Some\n    (Vptr sp\n       (Ptrofs.add Ptrofs.zero\n          (Ptrofs.add n1 (Ptrofs.of_int64 (Int64.shl' n2 a))))) = \n  Some res' /\\\n  Val.lessdef\n    (Val.addl e # r1\n       (if Int.ltu a Int64.iwordsize'\n        then Vlong (Int64.shl' n2 a)\n        else Vundef)) res'.","proofString":"rewrite Ptrofs.add_zero_l.\nrewrite a64_range.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto."},{"statement":"(a : amount64) (r1 r2 : reg) (n1 : ptrofs) (n2 : int64) (H1 : e # r2 = Vlong n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : exists res' : val,\n  Some (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 (Int64.shl' n2 a)))) =\n  Some res' /\\\n  Val.lessdef\n    (Val.addl e # r1\n       (if Int.ltu a Int64.iwordsize'\n        then Vlong (Int64.shl' n2 a)\n        else Vundef)) res'.","proofString":"rewrite a64_range.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto."},{"statement":"(a : amount64) (r1 r2 : reg) (n1 : ptrofs) (n2 : int64) (H1 : e # r2 = Vlong n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : exists res' : val,\n  Some (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 (Int64.shl' n2 a)))) =\n  Some res' /\\ Val.lessdef (Val.addl e # r1 (Vlong (Int64.shl' n2 a))) res'.","proofString":"econstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto."},{"statement":"(a : amount64) (r1 r2 : reg) (n1 : ptrofs) (n2 : int64) (H1 : e # r2 = Vlong n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : Val.lessdef (Val.addl e # r1 (Vlong (Int64.shl' n2 a)))\n  (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 (Int64.shl' n2 a)))).","proofString":"inv H; auto.\nrewrite H3; auto."},{"statement":"(a : amount64) (r1 r2 : reg) (n1 : ptrofs) (n2 : int64) (H1 : e # r2 = Vlong n2) (H3 : e # r1 = Vptr sp n1) : Val.lessdef (Val.addl e # r1 (Vlong (Int64.shl' n2 a)))\n  (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 (Int64.shl' n2 a)))).","proofString":"rewrite H3; auto."},{"statement":"(a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vlong n2) : exists res' : val,\n  Some (Val.addl e # r1 (Vlong (Int64.shl' n2 a))) = Some res' /\\\n  Val.lessdef\n    (Val.addl e # r1\n       (if Int.ltu a Int64.iwordsize'\n        then Vlong (Int64.shl' n2 a)\n        else Vundef)) res'.","proofString":"rewrite a64_range.\neconstructor; split; eauto."},{"statement":"(a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int64) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vlong n2) : exists res' : val,\n  Some (Val.addl e # r1 (Vlong (Int64.shl' n2 a))) = Some res' /\\\n  Val.lessdef (Val.addl e # r1 (Vlong (Int64.shl' n2 a))) res'.","proofString":"econstructor; split; eauto."},{"statement":"(x : extension) (a : amount64) (r1 r2 : reg) (n1 : ptrofs) (n2 : int) (H1 : e # r2 = Vint n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : exists res' : val,\n  Some\n    (Vptr sp\n       (Ptrofs.add Ptrofs.zero\n          (Ptrofs.add n1 (Ptrofs.of_int64 (eval_static_extend x n2 a))))) =\n  Some res' /\\ Val.lessdef (Val.addl e # r1 (eval_extend x (Vint n2) a)) res'.","proofString":"rewrite Ptrofs.add_zero_l, eval_static_extend_correct.\neconstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto."},{"statement":"(x : extension) (a : amount64) (r1 r2 : reg) (n1 : ptrofs) (n2 : int) (H1 : e # r2 = Vint n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : exists res' : val,\n  Some\n    (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 (eval_static_extend x n2 a)))) =\n  Some res' /\\\n  Val.lessdef (Val.addl e # r1 (Vlong (eval_static_extend x n2 a))) res'.","proofString":"econstructor; split; eauto.\ninv H; auto.\nrewrite H3; auto."},{"statement":"(x : extension) (a : amount64) (r1 r2 : reg) (n1 : ptrofs) (n2 : int) (H1 : e # r2 = Vint n2) (H : Val.lessdef e # r1 (Vptr sp n1)) : Val.lessdef (Val.addl e # r1 (Vlong (eval_static_extend x n2 a)))\n  (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 (eval_static_extend x n2 a)))).","proofString":"inv H; auto.\nrewrite H3; auto."},{"statement":"(x : extension) (a : amount64) (r1 r2 : reg) (n1 : ptrofs) (n2 : int) (H1 : e # r2 = Vint n2) (H3 : e # r1 = Vptr sp n1) : Val.lessdef (Val.addl e # r1 (Vlong (eval_static_extend x n2 a)))\n  (Vptr sp (Ptrofs.add n1 (Ptrofs.of_int64 (eval_static_extend x n2 a)))).","proofString":"rewrite H3; auto."},{"statement":"(x : extension) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vint n2) : exists res' : val,\n  Some (Val.addl e # r1 (Vlong (eval_static_extend x n2 a))) = Some res' /\\\n  Val.lessdef (Val.addl e # r1 (eval_extend x (Vint n2) a)) res'.","proofString":"rewrite eval_static_extend_correct.\neconstructor; split; eauto."},{"statement":"(x : extension) (a : amount64) (r1 r2 : reg) (v1 : aval) (n2 : int) (H0 : vmatch bc e # r1 v1) (H1 : e # r2 = Vint n2) : exists res' : val,\n  Some (Val.addl e # r1 (Vlong (eval_static_extend x n2 a))) = Some res' /\\\n  Val.lessdef (Val.addl e # r1 (Vlong (eval_static_extend x n2 a))) res'.","proofString":"econstructor; split; eauto."},{"statement":"(res : val) (addr : addressing) (args : list reg) (H0 : eval_addressing ge (Vptr sp Ptrofs.zero) addr e ## args = Some res) : exists res' : val,\n  eval_addressing ge (Vptr sp Ptrofs.zero) addr e ## args = Some res' /\\\n  Val.lessdef res res'.","proofString":"exists res; auto."}]}