[{"statement":"Lemma wf_pscE : psc ≡ ⦗E⦘ ⨾ psc ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold psc; rewrite (wf_hbE WF) at 1 2.\nbasic_solver 42.\n"},{"statement":"Lemma wf_arE : ar sc ≡ ⦗E⦘ ⨾ ar sc ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold ar.\nrewrite (wf_scE WF_SC), (wf_ar_intE WF), (wf_rfeE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_pscD : psc ≡ ⦗F∩₁Sc⦘ ⨾ psc ⨾ ⦗F∩₁Sc⦘.","proof":"split; [|basic_solver].\nunfold psc; basic_solver 42.\n"},{"statement":"Lemma no_psc_to_init : psc ≡ psc ⨾  ⦗fun x => ~ is_init x⦘.","proof":"split; [|basic_solver].\nrewrite wf_pscD at 1.\ngeneralize (read_or_fence_is_not_init WF).\nbasic_solver 42.\n"},{"statement":"Lemma sc_not_init:\n  sc ≡ ⦗set_compl is_init⦘ ⨾ sc ⨾ ⦗set_compl is_init⦘.","proof":"apply dom_helper_3.\nrewrite wf_scD, init_pln; eauto.\nmode_solver.\n"},{"statement":"Lemma no_sc_to_init :\n sc ≡ sc ⨾  ⦗fun x => ~ is_init x⦘.","proof":"rewrite sc_not_init.\nbasic_solver.\n"},{"statement":"Lemma n_Wex_co_rf_rmw_rt_transp_in_co_cr :\n  ⦗set_compl W_ex⦘ ⨾ co ⨾ ((rf ⨾ rmw)＊)⁻¹ ⊆ co^?.","proof":"clear AT.\nrewrite transp_rt.\neapply rt_ind_right with (P:= fun r => ⦗set_compl W_ex⦘ ⨾ co ⨾ r).\n{\nby eauto with hahn.\n}\n{\nbasic_solver.\n}\nins.\narewrite (⦗set_compl W_ex⦘ ⊆ ⦗set_compl W_ex⦘ ⨾ ⦗set_compl W_ex⦘) by basic_solver.\nsin_rewrite H.\nrewrite crE at 1.\nrelsf.\nunionL.\n{\nrewrite rmw_W_ex.\nbasic_solver.\n}\nrewrite rf_rmw_in_coimm; auto; try apply IMMCON.\n{\nrewrite co_immediate_co_in_co_cr; auto.\nbasic_solver.\n}\napply coherence_sc_per_loc.\napply IMMCON.\n"},{"statement":"Lemma sc_rfe_ct_in_sc_rfe : (sc ∪ rfe)⁺ ⊆ sc ∪ rfe.","proof":"rewrite path_union.\ngeneralize (sc_trans WF_SC); ins; relsf; unionL; [basic_solver|].\nrewrite crE at 2; relsf; unionL.\n{\narewrite (sc^? ⨾ rfe ⊆ rfe).\n{\nrewrite crE; relsf; unionL; [basic_solver|].\nrewrite (dom_l (wf_rfeD WF)) at 1.\nrewrite (dom_r (wf_scD WF_SC)) at 1.\ntype_solver.\n}\nrewrite ct_begin, rtE; relsf; unionL; [basic_solver|].\nrewrite ct_begin.\nrewrite (wf_rfeD WF).\ntype_solver.\n}\nrewrite (dom_r (wf_rfeD WF)).\nrewrite <- !seqA.\nrewrite inclusion_ct_seq_eqv_r, !seqA.\nrewrite (dom_l (wf_scD WF_SC)) at 2.\ntype_solver.\n"},{"statement":"Lemma F_sc_ar_F_sc :\n  ⦗F ∩₁ Sc⦘ ⨾ (ar sc)⁺ ⨾ ⦗F ∩₁ Sc⦘ ⊆ sc.","proof":"rewrite wf_arE; try done.\nrewrite inclusion_ct_seq_eqv_l, inclusion_ct_seq_eqv_r.\nunfold ar.\ndestruct WF_SC.\nunfolder; ins; desf.\neapply tot_ex; eauto; try basic_solver.\nintro; eapply ACYC_EXT.\neapply t_trans; unfold ar; [basic_solver| apply t_step; basic_solver].\nintro; eapply ACYC_EXT; unfold ar; basic_solver.\n"},{"statement":"Lemma sw_in_ar0 :\n  sw ⊆\n     ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⨾ (rfe ∪ ar_int)⁺\n     ∪ sb.","proof":"remember (rfe ∪ ar_int) as ax.\nunfold imm_s_hb.sw, imm_s_hb.release, imm_s_hb.rs.\nrewrite rt_rf_rmw.\narewrite ((sb ∩ same_loc)^? ⨾ ⦗W⦘ ⨾ (rfi ⨾ rmw)＊ ⊆ (sb ∩ same_loc)^? ⨾ ⦗W⦘).\n{\nrewrite (dom_r (wf_rmwD WF)).\nsin_rewrite (rfi_rmw_in_sb_loc WF).\nrewrite rtE.\nrewrite inclusion_ct_seq_eqv_r.\ngeneralize (@sb_same_loc_trans G); intros HH.\nrewrite ct_of_trans; auto.\ngeneralize HH; basic_solver 10.\n}\narewrite (⦗W⦘ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊ ⊆ ⦗W⦘ ⨾ (ax⁺ ⨾ ⦗W_ex⦘)^?).\n{\nrewrite crE.\nrewrite rtE at 1.\nrewrite seq_union_r.\nunionL.\n{\nbasic_solver.\n}\nrewrite ct_begin, !seqA.\nrewrite rmw_W_ex at 1.\nrewrite !seqA.\nsin_rewrite rfe_rmw_in_rfe_ar_int_ct; auto.\narewrite ((rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊ ⊆ (rf ⨾ rmw)＊).\n{\narewrite (rfi ⊆ rf).\narewrite (rfe ⊆ rf).\nrewrite <- seqA, <- ct_begin.\nrewrite rt_of_ct.\napply rt_rt.\n}\narewrite (⦗W_ex⦘ ⨾ (rf ⨾ rmw)＊ ⊆ ⦗W_ex⦘ ⨾ (rf ⨾ rmw)＊ ⨾  ⦗W_ex⦘).\n{\nrewrite <- seqA.\napply codom_rel_helper.\nrewrite rtE, seq_union_r, codom_union.\nunionL; [basic_solver|].\nrewrite rmw_W_ex at 1.\nrewrite <- seqA.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver.\n}\narewrite_id ⦗W_ex⦘ at 1.\nrewrite seq_id_l.\nsin_rewrite ar_int_rfe_ct_rfrmw_rt_in_ar_int_rfe_ct; auto.\nsubst ax.\nbasic_solver.\n}\narewrite ((ax⁺ ⨾ ⦗W_ex⦘)^? ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⊆ ax⁺ ∪ sb).\n2: {\nrewrite !seq_union_r.\nunionL; eauto with hahn.\ngeneralize (@sb_trans G).\nbasic_solver.\n}\nrewrite rfi_union_rfe.\nassert ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⊆ ax^? ⨾ ⦗Acq⦘) as AA.\n{\nrewrite !crE, !seq_union_l.\napply union_mori; [done|].\narewrite (⦗Acq⦘ ⊆ ⦗Acq/Rel⦘ ⨾ ⦗Acq⦘) at 1 by mode_solver.\nhahn_frame_r.\nrewrite <- id_inter.\nrewrite sb_to_f_in_bob.\nrewrite bob_in_ar_int.\nsubst ax.\neauto with hahn.\n}\nrewrite !seq_union_l, !seq_union_r.\nunionL.\n2: {\narewrite (rfe ⊆ ax) by subst ax; eauto with hahn.\nrewrite AA.\narewrite_id ⦗W_ex⦘.\nrewrite seq_id_r.\nrewrite cr_of_ct.\nseq_rewrite <- ct_end.\nseq_rewrite ct_cr.\nbasic_solver.\n}\nrewrite crE at 1.\nrewrite !seq_union_l, seq_id_l.\nunionL.\n{\narewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nbasic_solver.\n}\nrewrite seqA.\nrewrite crE at 1.\nrewrite !seq_union_l, !seq_union_r, !seq_id_l.\narewrite (⦗W_ex⦘ ⨾ rfi ⨾ ⦗Acq⦘ ⊆ ax).\n{\nsubst ax.\nunfold imm_s_ppo.ar_int.\nrewrite (dom_r (wf_rfiD WF)) at 1.\nbasic_solver 10.\n}\nrewrite ct_unit.\narewrite_id ⦗W_ex⦘.\nrewrite seq_id_l.\narewrite (rfi ⨾ sb ⨾ ⦗F⦘ ⨾ ⦗Acq⦘ ⊆ sb ⨾ ⦗F ∩₁ Acq/Rel⦘).\n2: {\nrewrite sb_to_f_in_bob.\nrewrite bob_in_ar_int.\narewrite (ar_int ⊆ ax) by subst ax; eauto with hahn.\nrewrite ct_unit.\neauto with hahn.\n}\narewrite (rfi ⊆ sb).\ngeneralize (@sb_trans G).\nmode_solver 10.\n"},{"statement":"Lemma sw_in_ar1 :\n  sw ⊆ (⦗F ∩₁ Rel⦘ ⨾ sb ∪ ⦗W ∩₁ Rel⦘ ⨾ (sb ∩ same_loc⨾ ⦗W⦘)^?) ⨾ \n  (rfe ∪ ar_int)⁺ ⨾ sb^? ∪ sb.","proof":"rewrite sw_in_ar0.\napply union_mori; [|done].\nassert (⦗fun _ => True⦘ ⊆ sb^?) as HH by basic_solver.\nrewrite <- HH, seq_id_r.\nhahn_frame_r.\ngeneralize (@sb_trans G).\nbasic_solver 10.\n"},{"statement":"Lemma f_sc_hb_f_sc_in_rfe_ar_int :\n  ⦗F ∩₁ Sc⦘ ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⊆ (rfe ∪ ar_int)⁺.","proof":"unfold imm_s_hb.hb.\nrewrite (dom_l (wf_swD WF)).\nrewrite sw_in_ar1.\nremember (rfe ∪ ar_int) as ax.\nrewrite seq_union_r.\narewrite (⦗FW ∩₁ Rel⦘ ⨾ sb ⊆ sb).\nrewrite unionC.\nrewrite unionA.\narewrite (sb ∪ sb ⊆ sb).\nrewrite unionC.\nrewrite path_union.\nrewrite seq_union_l, seq_union_r.\nunionL.\n{\nrewrite ct_of_trans; [|by apply sb_trans].\ndesf.\nrewrite <- ct_step; unfold imm_s_ppo.ar_int, imm_bob.bob, imm_bob.fwbob.\nmode_solver 21.\n}\nrewrite rt_of_trans; [|by apply sb_trans].\nrewrite ct_seq_swap.\nrewrite !seqA.\narewrite (sb^? ⨾ sb^? ⊆ sb^?).\n{\ngeneralize (@sb_trans G).\nbasic_solver.\n}\nrewrite ct_rotl, !seqA.\nassert (sb^? ⨾ ⦗FW ∩₁ Rel⦘ ⊆ ax^?) as BB.\n{\ndesf.\nrewrite <- bob_in_ar_int, <- fwbob_in_bob.\nunfold imm_bob.fwbob.\nmode_solver 12.\n}\nsin_rewrite !BB.\narewrite (sb^? ⨾ ⦗F ∩₁ Sc⦘ ⊆ ax^?).\n{\ndesf.\nrewrite <- bob_in_ar_int, <- fwbob_in_bob.\nunfold imm_bob.fwbob.\nmode_solver 12.\n}\nrels.\narewrite ((⦗F ∩₁ Rel⦘ ⨾ sb ∪ ⦗W ∩₁ Rel⦘ ⨾ (sb ∩ same_loc ⨾ ⦗W⦘)^?) ⊆ ax^?).\n{\nunionL.\n2: {\nrewrite crE.\nrewrite seq_union_r.\nunionL.\n{\nbasic_solver.\n}\nrewrite sb_from_w_rel_in_bob.\nsubst.\nunfold imm_s_ppo.ar_int.\nbasic_solver 10.\n}\narewrite (Rel ⊆₁ Acq/Rel) by mode_solver.\nrewrite sb_from_f_in_fwbob.\nrewrite fwbob_in_bob.\nsubst.\nunfold imm_s_ppo.ar_int.\nbasic_solver 10.\n}\nrels.\nbasic_solver.\n"},{"statement":"Lemma f_sc_hb_f_sc_in_ar : \n  ⦗F ∩₁ Sc⦘ ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⊆ (ar sc)⁺.","proof":"rewrite f_sc_hb_f_sc_in_rfe_ar_int.\nunfold ar.\napply clos_trans_mori.\neauto with hahn.\n"},{"statement":"Lemma f_sc_hb_f_sc_in_sc : \n  ⦗F ∩₁ Sc⦘ ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⊆ sc.","proof":"arewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) by basic_solver.\nsin_rewrite f_sc_hb_f_sc_in_ar.\napply F_sc_ar_F_sc; done.\n"},{"statement":"Lemma f_sc_sb_f_sc_in_sc : ⦗F ∩₁ Sc⦘ ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⊆ sc.","proof":"rewrite sb_in_hb.\napply f_sc_hb_f_sc_in_sc; auto.\n"},{"statement":"Lemma sc_sb_sc_in_sc : sc ⨾ sb ⨾ sc ⊆ sc.","proof":"assert (transitive sc) as TSC.\n{\nnow apply WF_SC.\n}\nrewrite (wf_scD WF_SC) at 1 2.\nrewrite !seqA.\nsin_rewrite f_sc_sb_f_sc_in_sc; auto.\nsin_rewrite !rewrite_trans; auto.\nclear; basic_solver 1.\n"},{"statement":"Lemma sb_sc_acyclic : acyclic (sb ∪ sc).","proof":"assert (transitive sc) as TSC.\n{\nnow apply WF_SC.\n}\nassert (transitive sb) as TSB.\n{\napply sb_trans.\n}\napply acyclic_utt; auto.\nsplits.\n{\napply sb_irr.\n}\n{\napply WF_SC.\n}\nrewrite (wf_scD WF_SC).\nrewrite <- !seqA, acyclic_rotl, !seqA.\nsin_rewrite f_sc_sb_f_sc_in_sc; auto.\nrewrite rewrite_trans; auto.\nred.\nrewrite ct_of_trans; auto.\napply WF_SC.\n"},{"statement":"Lemma sb_sc_rt : (sb ∪ sc)^* ≡ sb^? ;; sc^? ;; sb^?.","proof":"assert (transitive sc) as TSC.\n{\nnow apply WF_SC.\n}\nassert (transitive sb) as TSB.\n{\napply sb_trans.\n}\nassert (transitive (sb ⨾ sc)) as TSBSC.\n{\napply transitiveI.\nrewrite seqA.\nnow rewrite sc_sb_sc_in_sc; auto.\n}\nsplit.\n2: {\narewrite (sb^? ⊆ (sb ∪ sc)＊).\narewrite (sc^? ⊆ (sb ∪ sc)＊).\nnow rewrite !rt_rt.\n}\nrewrite unionC.\nrewrite path_ut; auto.\nrewrite ct_of_trans; auto.\nrewrite rt_of_trans; auto.\nrewrite rt_of_trans; auto.\nrewrite !crE.\nrewrite !seq_union_l, !seq_id_l, !seq_union_r, !seqA.\nrewrite !seq_id_r.\nrewrite sc_sb_sc_in_sc; auto.\nunionL; eauto with hahn.\nsin_rewrite sc_sb_sc_in_sc; auto.\neauto with hahn.\n"},{"statement":"Lemma ar_int_in_ar : ar_int ⊆ ar sc.","proof":"unfold ar.\nbasic_solver.\n"},{"statement":"Lemma ppo_in_ar : ppo ⊆ ar sc.","proof":"etransitivity; [|by apply ar_int_in_ar].\napply ppo_in_ar_int.\n"},{"statement":"Lemma bob_in_ar : bob ⊆ ar sc.","proof":"etransitivity; [|by apply ar_int_in_ar].\napply bob_in_ar_int.\n"},{"statement":"Lemma detour_in_ar : detour ⊆ ar sc.","proof":"etransitivity; [|by apply ar_int_in_ar].\napply detour_in_ar_int.\n"},{"statement":"Lemma rfe_in_ar : rfe ⊆ ar sc.","proof":"unfold ar.\nbasic_solver.\n"},{"statement":"Lemma sc_in_ar : sc ⊆ ar sc.","proof":"unfold ar.\nbasic_solver.\n"},{"statement":"Lemma w_ex_acq_sb_w_in_ar : ⦗W_ex_acq⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ar sc.","proof":"etransitivity; [|by apply ar_int_in_ar].\napply w_ex_acq_sb_w_in_ar_int.\n"},{"statement":"Lemma rmwrf_ct_Acq_in_ar_rfrmw_ct : (rmw ⨾ rf)⁺ ⨾ ⦗Acq⦘ ⊆ (ar sc ∪ rf ⨾ rmw)⁺.","proof":"rewrite rmw_W_ex at 1.\nrewrite !seqA.\nrewrite clos_trans_rotl, !seqA.\narewrite (⦗W_ex⦘ ⨾ rf ⨾ ⦗Acq⦘ ⊆ ar sc).\n{\nrewrite rfi_union_rfe, !seq_union_l, !seq_union_r.\nunionL.\n2: {\nrewrite rfe_in_ar.\nbasic_solver.\n}\nrewrite (dom_r (wf_rfiD WF)), !seqA.\nrewrite <- id_inter.\nunfold ar, imm_s_ppo.ar_int.\neauto with hahn.\n}\nrewrite (rmw_in_ar_int WF) at 1.\nrewrite ar_int_in_ar.\narewrite (⦗W_ex⦘ ⨾ rf ⨾ rmw ⊆ ar sc ∪ rf ⨾ rmw).\narewrite (ar sc ⊆ ar sc ∪ rf ⨾ rmw) at 1.\narewrite (ar sc ⊆ ar sc ∪ rf ⨾ rmw) at 3.\nrewrite <- ct_end.\nrewrite ct_step with (r:=ar sc ∪ rf ⨾ rmw) at 1.\napply ct_ct.\n"},{"statement":"Lemma rmwrf_rt_Acq_in_ar_rfrmw_rt : (rmw ⨾ rf)＊ ⨾ ⦗Acq⦘ ⊆ (ar sc ∪ rf ⨾ rmw)＊.","proof":"rewrite !rtE, seq_union_l.\nrewrite rmwrf_ct_Acq_in_ar_rfrmw_ct.\nbasic_solver.\n"},{"statement":"Lemma coh_sc_alt : ⦗F∩₁Sc⦘ ⨾  hb ⨾ eco ⨾ hb ⨾ ⦗F∩₁Sc⦘ ⊆ sc.","proof":"rewrite (dom_l (wf_hbE WF)) at 1.\nrewrite (dom_r (wf_hbE WF)) at 2.\nunfolder; ins; desf.\neapply tot_ex.\napply WF_SC.\nbasic_solver.\nbasic_solver.\nintro; eapply CSC; basic_solver 10.\nintro; subst.\neapply COH.\neexists; splits; [ | eby right].\neapply hb_trans; eauto.\n"},{"statement":"Proposition coh_helper_alt :\n  irreflexive (hb ⨾ sc^? ∪ hb ⨾ (sc ⨾ hb)^? ⨾ rfe ∪ \n  hb ⨾ (sc ⨾ hb)^? ⨾ co ∪ hb ⨾ (sc ⨾ hb)^? ⨾ co ⨾ rfe ∪ \n  hb ⨾ (sc ⨾ hb)^? ⨾ fr ∪ hb ⨾ (sc ⨾ hb)^? ⨾ fr ⨾ rfe) -> \n  irreflexive (hb ⨾ (sc ⨾ hb)^? ⨾ eco^?).","proof":"unfold Execution_eco.eco; relsf.\nrewrite rfi_union_rfe; relsf.\narewrite (rfi ⊆ sb); rewrite sb_in_hb; rewrite !crE; relsf.\nins; unionL.\nall: try rotate 1.\nall: generalize (@hb_trans G); ins; relsf.\nall: try (unfolder in *; basic_solver 12).\nall: try (unfolder in *; basic_solver 16).\n"},{"statement":"Lemma init_co_w\n      e e' (INIT : is_init e) (NINIT : ~ is_init e')\n      (EE : E e') (WW : W e') (SL : same_loc e e') :\n  co e e'.","proof":"destruct (is_w_loc lab e' WW) as [l LOC].\nred in SL.\nrewrite LOC in SL.\nunfold is_init in INIT.\nunfold Events.loc in SL.\ndestruct e; [|done].\nrewrite (wf_init_lab WF) in SL.\ninv SL.\nassert (E (InitEvent l)) as EL.\n{\napply (wf_init WF).\neexists.\neauto.\n}\nedestruct (wf_co_total WF) as [CO|CO]; eauto; desf.\n{\nsplit; [split|]; auto.\nby apply init_w.\nunfold Events.loc at 1.\nby rewrite (wf_init_lab WF).\n}\n{\nintros H.\nsubst.\ndesf.\n}\nexfalso.\ncdes IMMCON.\neapply Cint.\neexists.\nsplit.\n{\napply sb_in_hb.\nby apply init_ninit_sb with (y:=e'); eauto.\n}\napply r_step.\napply Execution_eco.co_in_eco; eauto.\n"},{"statement":"Lemma wf_rfrmw_irr : irreflexive (rf ⨾ rmw).","proof":"arewrite (rmw ⊆ sb).\n{\nrewrite (wf_rmwi WF).\nbasic_solver.\n}\nrewrite Execution_eco.rf_in_eco.\nrewrite sb_in_hb.\ncdes IMMCON.\nred in Cint.\ngeneralize Cint.\nbasic_solver 10.\n"},{"statement":"Lemma rfrmw_in_im_co :\n  rf ⨾ rmw ⊆ immediate co.","proof":"cdes IMMCON.\napply rf_rmw_in_coimm; auto using coherence_sc_per_loc.\n"},{"statement":"Lemma wf_rfrmwsf : functional (rf ⨾ rmw).","proof":"rewrite rfrmw_in_im_co; eauto.\napply wf_immcof; auto.\n"},{"statement":"Lemma wf_rfirmwsf : functional (rfi ⨾ rmw).","proof":"arewrite (rfi ⊆ rf).\neapply wf_rfrmwsf; eauto.\n"},{"statement":"Lemma W_ex_in_codom_rfrmw : W_ex ⊆₁ codom_rel (rf ⨾ rmw).","proof":"intros x [y RMW].\nenough (exists z, rf z y) as [z RF].\n{\nexists z.\neexists.\neauto.\n}\napply IMMCON.\napply (dom_l (wf_rmwE WF)) in RMW.\ndestruct_seq_l RMW as AA.\nsplit; auto.\napply (dom_l (wf_rmwD WF)) in RMW.\ndestruct_seq_l RMW as BB.\ntype_solver.\n"},{"statement":"Lemma rfrmwP_in_immPco P P'\n    (DRES : dom_rel (rf ⨾ rmw ⨾ ⦗P'⦘) ⊆₁ P) :\n  rf ⨾ rmw ⨾ ⦗P'⦘ ⊆ immediate (⦗P⦘ ⨾ co).","proof":"assert (sc_per_loc G) as SPL.\n{\napply coherence_sc_per_loc.\napply IMMCON.\n}\nrewrite <- immediate_inter_mori with (x:=co).\n2: basic_solver.\napply inclusion_inter_r.\n2: {\nrewrite <- seqA.\nrewrite rfrmw_in_im_co; eauto.\nbasic_solver.\n}\nrewrite <- rf_rmw_in_co; auto.\ngeneralize DRES.\nbasic_solver 10.\n"},{"statement":"Lemma rfrmw_in_eco (SPL : sc_per_loc G) (COMP : complete G) :\n  rf ⨾ rmw ⊆ eco.","proof":"rewrite rf_in_eco.\nrewrite rmw_in_fr; auto.\nrewrite fr_in_eco.\napply transitiveI.\nby apply eco_trans.\n"},{"statement":"Lemma rfrmw_sb_irr : \n  irreflexive (rf ⨾ rmw ⨾ sb).","proof":"arewrite (rf ⨾ rmw ⊆ eco).\n{\napply rfrmw_in_eco; auto.\napply coherence_sc_per_loc.\nall: by apply IMMCON.\n}\nrewrite sb_in_hb.\nrewrite irreflexive_seqC.\narewrite (eco ⊆ eco^?).\napply IMMCON.\n"},{"statement":"Lemma rfe_rmw_in_ar_ct : rfe ⨾ rmw ⊆ (ar sc)⁺.","proof":"rewrite <- ct_ct.\nrewrite rfe_in_ar, (rmw_in_ppo WF), ppo_in_ar.\neby rewrite <- ct_step.\n"},{"statement":"Lemma rfe_ppo_in_ar_ct : rfe ⨾ ppo ⊆ (ar sc)⁺.","proof":"rewrite <- ct_ct.\nrewrite rfe_in_ar, ppo_in_ar.\neby rewrite <- ct_step.\n"},{"statement":"Lemma sb_release_rmw_in_fwbob\n      (COMPL : complete G)\n      (SPL   : Execution_eco.sc_per_loc G) :\n  sb^? ∩ release G ⨾ sb ∩ Events.same_loc lab ⨾ rmw ⊆ fwbob G.","proof":"rewrite (dom_r (wf_rmwD WF)).\nrewrite (rmw_in_sb_loc WF).\nsin_rewrite rewrite_trans.\n2: by apply sb_same_loc_trans.\nrewrite (dom_l (wf_releaseD WF)).\narewrite (sb^? ∩ (⦗(F ∪₁ W) ∩₁ Rel⦘ ⨾ release G) ⊆            ⦗(F ∪₁ W) ∩₁ Rel⦘ ⨾ (sb^? ∩ release G)).\n{\nbasic_solver.\n}\nrewrite set_inter_union_l.\nrewrite id_union, seq_union_l.\nunionL.\n{\nunfold fwbob.\nunionR right.\narewrite (sb^? ∩ release G ⨾ sb ∩ Events.same_loc lab ⊆ sb).\n{\ngeneralize (@sb_trans G).\nbasic_solver.\n}\nmode_solver.\n}\nunfold release.\narewrite (⦗W ∩₁ Rel⦘ ⨾ sb^? ∩ (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs G) ⊆            ⦗W ∩₁ Rel⦘ ⨾ sb^? ∩ (⦗Rel⦘ ⨾ rs G)).\n{\ntype_solver 10.\n}\nrewrite rs_in_co; auto.\nrewrite (wf_col WF).\narewrite (sb^? ∩ (⦗Rel⦘ ⨾ ⦗W⦘ ⨾ (Events.same_loc lab)^?) ⊆               (sb ∩ Events.same_loc lab)^?).\n{\nbasic_solver.\n}\nsin_rewrite rewrite_trans_seq_cr_l.\n2: by apply sb_same_loc_trans.\nunfold fwbob.\neauto with hahn.\n"},{"statement":"Lemma rf_sb_sc_sb_fwbob_in_ar : rf^? ⨾ sb^? ⨾ sc^? ⨾ sb^? ⨾ (fwbob G) ⊆ (ar sc)⁺.","proof":"arewrite (rf^? ⊆ rfe^? ;; sb^?).\n{\nrewrite rfi_union_rfe, cr_union_r.\nrewrite rfi_in_sb.\nclear.\nbasic_solver 10.\n}\nrewrite <- cr_ct.\nrewrite rfe_in_ar.\nhahn_frame_l.\nassert (sb^? ⨾ sb^? ⊆ sb^?) as SBSB.\n{\napply transitiveI.\napply transitive_cr.\napply sb_trans.\n}\nsin_rewrite SBSB.\narewrite (sb^? ⨾ sc^? ⊆ sb^? ∪ (fwbob G)^? ;; sc^?).\n{\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nunionL; eauto with hahn.\ntransitivity (fwbob G ⨾ sc); eauto with hahn.\nrewrite (dom_l (wf_scD WF_SC)) at 1.\nhahn_frame.\nunfold imm_bob.fwbob.\nclear.\nmode_solver 10.\n}\nrewrite !seq_union_l.\nsin_rewrite SBSB.\narewrite (sb^? ⨾ (fwbob G) ⊆ (ar sc)⁺).\n{\nrewrite crE, !seq_union_l, seq_id_l.\nrewrite sb_fwbob_in_fwbob.\nrewrite fwbob_in_bob, bob_in_ar.\neauto with hahn.\n}\nrewrite fwbob_in_bob, bob_in_ar.\narewrite (sc^? ⊆ (ar sc)^?).\nrewrite !cr_ct.\neauto with hahn.\n"},{"statement":"Lemma rf_sb_sc_rt_sb_fwbob_in_ar : rf^? ⨾ (sb ∪ sc)^* ⨾ fwbob G ⊆ (ar sc)⁺.","proof":"rewrite sb_sc_rt, !seqA; auto.\nnow apply rf_sb_sc_sb_fwbob_in_ar.\n"},{"statement":"Lemma no_ar_to_init : ar sc ⨾ ⦗is_init⦘ ≡ ∅₂.","proof":"split; [|basic_solver].\nunfold ar.\nrewrite (ar_int_in_sb WF).\nrewrite no_sb_to_init.\nrewrite wf_scD with (sc:=sc); [|by apply IMMCON].\nrewrite (wf_rfeD WF).\nrewrite seq_union_l.\nunionL; [|basic_solver].\nrewrite (init_w WF).\ntype_solver 10.\n"},{"statement":"Lemma no_ar_rfrmw_to_init : (ar sc ∪ rf ⨾ rmw) ⨾ ⦗is_init⦘ ≡ ∅₂.","proof":"split; [|basic_solver].\nrewrite seq_union_l, seqA, no_ar_to_init; auto.\nrewrite (rmw_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver.\n"},{"statement":"Lemma wf_ar_rfrmwE :\n  ar sc ∪ rf ⨾ rmw ≡ ⦗E⦘ ⨾ (ar sc ∪ rf ⨾ rmw) ⨾ ⦗E⦘.","proof":"rewrite wf_arE at 1; auto.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (dom_r (wf_rmwE WF)) at 1.\nbasic_solver 10.\n"},{"statement":"Lemma wf_ar_rfrmw_ctE :\n  (ar sc ∪ rf ⨾ rmw)⁺ ≡ ⦗E⦘ ⨾ (ar sc ∪ rf ⨾ rmw)⁺ ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nrewrite wf_ar_rfrmwE at 1; auto.\nrewrite inclusion_ct_seq_eqv_l.\nby rewrite inclusion_ct_seq_eqv_r.\n"},{"statement":"Lemma ar_ar_in_ar_ct : ar sc ⨾ ar sc ⊆ (ar sc)⁺.","proof":"rewrite ct_step with (r:=ar sc) at 1 2.\napply ct_ct.\n"},{"statement":"Lemma no_ar_rf_ppo_loc_to_init : (ar sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗is_init⦘ ≡ ∅₂.","proof":"split; [|basic_solver].\nrewrite seq_union_l, seqA, no_ar_to_init; auto.\narewrite (ppo ∩ same_loc ⊆ ppo).\nrewrite (ppo_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver.\n"},{"statement":"Lemma wf_ar_rf_ppo_locE :\n  ar sc ∪ rf ⨾ ppo ∩ same_loc ≡ ⦗E⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗E⦘.","proof":"rewrite wf_arE at 1; auto.\nrewrite (dom_l (wf_rfE WF)) at 1.\nrewrite (dom_r (wf_ppoE WF)) at 1.\nbasic_solver 10.\n"},{"statement":"Lemma wf_ar_rf_ppo_loc_ctE :\n  (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ≡ ⦗E⦘ ⨾ (ar sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nrewrite wf_ar_rf_ppo_locE at 1; auto.\nrewrite inclusion_ct_seq_eqv_l.\nby rewrite inclusion_ct_seq_eqv_r.\n"},{"statement":"Lemma rfe_n_same_tid : rfe ∩ same_tid ⊆ ∅₂.","proof":"arewrite (rfe ∩ same_tid ⊆ rfe ∩ (⦗E⦘ ⨾ same_tid ⨾ ⦗E⦘)).\n{\nrewrite (wf_rfeE WF) at 1.\nbasic_solver.\n}\narewrite (⦗E⦘ ⨾ same_tid ⨾ ⦗E⦘ ⊆ same_tid ∩ (⦗E⦘ ⨾ same_tid ⨾ ⦗E⦘)) by basic_solver.\nrewrite tid_sb.\nrewrite !inter_union_r.\nunionL.\n3: {\nrewrite (wf_rfeD WF).\nrewrite init_w; eauto.\ntype_solver.\n}\n2: {\nunfolder.\nins.\ndesf.\neapply COH.\neexists.\nsplit.\n{\neby apply sb_in_hb.\n}\nright.\napply rf_in_eco.\nmatch goal with       | H : rfe _ _ |- _ => apply H       end.\n}\nunfolder.\nins.\ndesf.\n{\neapply eco_irr; eauto.\napply rf_in_eco.\nmatch goal with    | H : rfe _ _ |- _ => apply H    end.\n}\neapply (thread_rfe_sb WF (coherence_sc_per_loc COH)).\nbasic_solver 10.\n"},{"statement":"Lemma ar_W_in_ar_int : ar sc ⨾ ⦗W⦘ ⊆ ar_int.","proof":"unfold ar.\nerewrite wf_scD with (sc:=sc); [|by apply IMMCON].\nrewrite (wf_rfeD WF).\ntype_solver.\n"},{"statement":"Lemma C_EXT_helper2 : (psc ∪ rfe)⁺ ⊆ psc⁺ ∪ rfe.","proof":"apply ct_ind_left with (P:= fun r => r).\nby eauto with hahn.\nby unionL; vauto.\nins; rewrite H; relsf; unionL.\narewrite (psc ⊆ psc＊); relsf.\nrewrite ct_begin.\nrewrite (dom_l wf_pscD) at 1; rewrite (dom_r (wf_rfeD WF)); type_solver 12.\nrewrite (dom_r wf_pscD) at 1; rewrite (dom_l (wf_rfeD WF)); type_solver 12.\nrewrite (dom_r (wf_rfeD WF)) at 1; rewrite (dom_l (wf_rfeD WF)); type_solver 12.\n"},{"statement":"Lemma s_acyc_ext_psc_helper\n      (AC : acyclic (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘)) :\n  acyclic (psc ∪ rfe ∪ ar_int).","proof":"generalize (@sb_trans G); intro SBT.\nred.\napply acyclic_mon with (r:= ar_int ∪ (psc ∪ rfe)).\n2: by basic_solver 12.\napply acyclic_union1.\n{\nrewrite (ar_int_in_sb WF).\napply sb_acyclic.\n}\n{\neapply acyclic_mon; [edone|basic_solver 12].\n}\nrewrite C_EXT_helper2; unionL.\narewrite (psc ⊆ sb^? ⨾ psc ⨾ sb^?) by basic_solver 12.\nrelsf.\nrewrite (imm_s_ppo.ar_int_in_sb WF) at 1; relsf.\nrewrite ct_begin, !seqA; relsf.\narewrite (sb ⊆ sb^?) at 1.\nrewrite <- !seqA, <- ct_begin, !seqA.\napply acyclic_union1.\n{\nred; rels; eapply acyclic_mon; [edone|basic_solver 12].\n}\n{\nrewrite (dom_l (wf_rfeD WF)), <- seqA, acyclic_rotl.\nrewrite (dom_r (wf_rfeD WF)), !seqA.\napply acyclic_seq_from_union.\nred; rels; eapply acyclic_mon; [edone|basic_solver 12].\n}\nrelsf.\nrewrite (ct_begin (ar_int⁺ ⨾ rfe)).\nrewrite (imm_s_ppo.ar_int_in_sb WF) at 1.\nrewrite !seqA; relsf.\narewrite ((sb^? ⨾ psc ⨾ sb^?)⁺ ⨾ sb ⊆ (sb^? ⨾ psc ⨾ sb^?)⁺).\n{\nrewrite ct_end at 1; rewrite !seqA.\narewrite (sb^? ⨾ sb ⊆ sb^?).\n{\ngeneralize (@sb_trans G); basic_solver.\n}\nby rewrite <- ct_end.\n}\nrewrite (dom_l (wf_rfeD WF)) at 2.\narewrite (rfe ⨾ (ar_int⁺ ⨾ ⦗W⦘ ⨾ rfe)＊ ⊆ (rfe ⨾ ar_int⁺ ⨾ ⦗W⦘)＊ ⨾ rfe).\n{\nby rewrite <- seqA; apply rt_seq_swap.\n}\nrewrite (dom_r (wf_rfeD WF)) at 1.\nrewrite !seqA.\narewrite ((sb^? ⨾ psc ⨾ sb^?)⁺ ⊆ (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘)⁺).\narewrite (rfe ⊆ (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘)＊) at 2.\narewrite (⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘ ⊆ (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘)＊) at 3.\nrelsf.\narewrite (rfe ⊆ (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘)＊) at 2.\nrelsf; red; rels.\n"},{"statement":"Lemma s_acyc_ext_helper\n      (FINDOM : set_finite E)\n      (AC : acyclic (psc ∪ rfe ∪ ar_int)) :\n  exists sc, wf_sc sc /\\ acyc_ext sc /\\ coh_sc sc.","proof":"cdes FINDOM.\nset (ar' := psc ∪ rfe ∪ ar_int).\nunfold acyc_ext.\nexists (⦗ E ∩₁ F ∩₁ Sc ⦘ ⨾ tot_ext findom ar' ⨾ ⦗ E ∩₁ F ∩₁ Sc ⦘).\nsplits.\n{\nconstructor.\n1,2: apply dom_helper_3; basic_solver.\n{\nrewrite <- restr_relE; apply transitive_restr, tot_ext_trans.\n}\n{\nunfolder; ins; desf.\ncut (tot_ext findom ar' a b \\/ tot_ext findom ar' b a).\n{\nbasic_solver 12.\n}\neapply tot_ext_total; desf; eauto.\n}\nrewrite <- restr_relE.\napply irreflexive_restr.\nby apply tot_ext_irr.\n}\n{\nunfold ar.\napply acyclic_mon with (r:= tot_ext findom ar').\n{\napply trans_irr_acyclic.\n{\napply tot_ext_irr, AC.\n}\napply tot_ext_trans.\n}\napply inclusion_union_l; [apply inclusion_union_l|].\n{\nbasic_solver.\n}\nall: subst ar'; rewrite <- tot_ext_extends; unfold ar; basic_solver.\n}\nunfold coh_sc.\nrotate 4.\narewrite (⦗E ∩₁ F ∩₁ Sc⦘ ⨾ hb ⨾ (eco ⨾ hb)^? ⨾ ⦗E ∩₁ F ∩₁ Sc⦘ ⊆ ar'⁺).\n2: {\narewrite (ar' ⊆ tot_ext findom ar') at 2.\n{\napply tot_ext_extends.\n}\nrewrite ct_step with (r:= tot_ext findom ar') at 1.\nrewrite ct_ct.\napply trans_irr_acyclic.\n{\napply tot_ext_irr, AC.\n}\napply tot_ext_trans.\n}\narewrite (⦗E ∩₁ F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘) by basic_solver.\ncase_refl _.\n{\nerewrite f_sc_hb_f_sc_in_rfe_ar_int; eauto.\napply clos_trans_mori.\nsubst ar'.\neauto with hahn.\n}\nrewrite !seqA.\nrewrite <- ct_step.\nsubst ar'.\nunfold psc.\neauto with hahn.\n"}]