{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Separation.v","fileSamples":[{"statement":"(p : massert) : ((forall m : mem, m_pred p m -> m_pred p m) /\\\n (forall (b : block) (ofs : Z), m_footprint p b ofs -> m_footprint p b ofs)) /\\\n(forall m : mem, m_pred p m -> m_pred p m) /\\\n(forall (b : block) (ofs : Z), m_footprint p b ofs -> m_footprint p b ofs).","proofString":"tauto."},{"statement":"(p q : massert) (H : ((forall m : mem, m_pred p m -> m_pred q m) /\\\n (forall (b : block) (ofs : Z), m_footprint q b ofs -> m_footprint p b ofs)) /\\\n(forall m : mem, m_pred q m -> m_pred p m) /\\\n(forall (b : block) (ofs : Z), m_footprint p b ofs -> m_footprint q b ofs)) : ((forall m : mem, m_pred q m -> m_pred p m) /\\\n (forall (b : block) (ofs : Z), m_footprint p b ofs -> m_footprint q b ofs)) /\\\n(forall m : mem, m_pred p m -> m_pred q m) /\\\n(forall (b : block) (ofs : Z), m_footprint q b ofs -> m_footprint p b ofs).","proofString":"tauto."},{"statement":"(p q r : massert) (H : ((forall m : mem, m_pred p m -> m_pred q m) /\\\n (forall (b : block) (ofs : Z), m_footprint q b ofs -> m_footprint p b ofs)) /\\\n(forall m : mem, m_pred q m -> m_pred p m) /\\\n(forall (b : block) (ofs : Z), m_footprint p b ofs -> m_footprint q b ofs)) (H0 : ((forall m : mem, m_pred q m -> m_pred r m) /\\\n (forall (b : block) (ofs : Z), m_footprint r b ofs -> m_footprint q b ofs)) /\\\n(forall m : mem, m_pred r m -> m_pred q m) /\\\n(forall (b : block) (ofs : Z), m_footprint q b ofs -> m_footprint r b ofs)) : ((forall m : mem, m_pred p m -> m_pred r m) /\\\n (forall (b : block) (ofs : Z), m_footprint r b ofs -> m_footprint p b ofs)) /\\\n(forall m : mem, m_pred r m -> m_pred p m) /\\\n(forall (b : block) (ofs : Z), m_footprint p b ofs -> m_footprint r b ofs).","proofString":"firstorder auto."},{"statement":"(P P' Q Q' : massert) (m : mem) (H : m |= P ** Q) (H0 : massert_imp P P') (H1 : massert_imp Q Q') : m |= P' ** Q'.","proofString":"rewrite <- H0, <- H1; auto."},{"statement":"(P Q : massert) (m : mem) (H : m |= P /\\ m |= Q /\\ disjoint_footprint P Q) : m |= Q /\\ m |= P /\\ disjoint_footprint Q P.","proofString":"intuition auto.\nred; intros; eapply H2; eauto."},{"statement":"(P Q : massert) (m : mem) (H0 : m |= P) (H : m |= Q) (H2 : disjoint_footprint P Q) : disjoint_footprint Q P.","proofString":"red; intros; eapply H2; eauto."},{"statement":"(P Q : massert) (b : block) (ofs : Z) (H : m_footprint Q b ofs \\/ m_footprint P b ofs) : m_footprint P b ofs \\/ m_footprint Q b ofs.","proofString":"intuition auto."},{"statement":"(P Q R : massert) : massert_imp ((P ** Q) ** R) (P ** Q ** R).","proofString":"unfold massert_imp, sepconj, disjoint_footprint; simpl; firstorder auto."},{"statement":"(P Q R : massert) : massert_imp (P ** Q ** R) ((P ** Q) ** R).","proofString":"unfold massert_imp, sepconj, disjoint_footprint; simpl; firstorder auto."},{"statement":"(P Q R : massert) : massert_imp ((P ** Q) ** R) (P ** Q ** R).","proofString":"apply sep_assoc_1."},{"statement":"(P Q R : massert) : massert_imp (P ** Q ** R) ((P ** Q) ** R).","proofString":"apply sep_assoc_2."},{"statement":"(P Q R : massert) : massert_eqv (P ** Q ** R) (Q ** P ** R).","proofString":"rewrite <- sep_assoc.\nrewrite (sep_comm P).\nrewrite sep_assoc.\nreflexivity."},{"statement":"(P Q R : massert) : massert_eqv ((P ** Q) ** R) (Q ** P ** R).","proofString":"rewrite (sep_comm P).\nrewrite sep_assoc.\nreflexivity."},{"statement":"(P Q R : massert) : massert_eqv ((Q ** P) ** R) (Q ** P ** R).","proofString":"rewrite sep_assoc.\nreflexivity."},{"statement":"(P Q R : massert) : massert_eqv (Q ** P ** R) (Q ** P ** R).","proofString":"reflexivity."},{"statement":"(P Q R S : massert) : massert_eqv (P ** Q ** R ** S) (P ** R ** Q ** S).","proofString":"rewrite (sep_swap Q).\nreflexivity."},{"statement":"(P Q R S : massert) : massert_eqv (P ** R ** Q ** S) (P ** R ** Q ** S).","proofString":"reflexivity."},{"statement":"(P Q R S T : massert) : massert_eqv (P ** Q ** R ** S ** T) (P ** Q ** S ** R ** T).","proofString":"rewrite (sep_swap R).\nreflexivity."},{"statement":"(P Q R S T : massert) : massert_eqv (P ** Q ** S ** R ** T) (P ** Q ** S ** R ** T).","proofString":"reflexivity."},{"statement":"(P Q R S T U : massert) : massert_eqv (P ** Q ** R ** S ** T ** U) (P ** Q ** R ** T ** S ** U).","proofString":"rewrite (sep_swap S).\nreflexivity."},{"statement":"(P Q R S T U : massert) : massert_eqv (P ** Q ** R ** T ** S ** U) (P ** Q ** R ** T ** S ** U).","proofString":"reflexivity."},{"statement":"(P Q R S : massert) : massert_eqv (P ** Q ** R ** S) (R ** Q ** P ** S).","proofString":"rewrite sep_swap.\nrewrite (sep_swap P).\nrewrite sep_swap.\nreflexivity."},{"statement":"(P Q R S : massert) : massert_eqv (Q ** P ** R ** S) (R ** Q ** P ** S).","proofString":"rewrite (sep_swap P).\nrewrite sep_swap.\nreflexivity."},{"statement":"(P Q R S : massert) : massert_eqv (Q ** R ** P ** S) (R ** Q ** P ** S).","proofString":"rewrite sep_swap.\nreflexivity."},{"statement":"(P Q R S : massert) : massert_eqv (R ** Q ** P ** S) (R ** Q ** P ** S).","proofString":"reflexivity."},{"statement":"(P Q R S T : massert) : massert_eqv (P ** Q ** R ** S ** T) (S ** Q ** R ** P ** T).","proofString":"rewrite sep_swap.\nrewrite (sep_swap3 P).\nrewrite sep_swap.\nreflexivity."},{"statement":"(P Q R S T : massert) : massert_eqv (Q ** P ** R ** S ** T) (S ** Q ** R ** P ** T).","proofString":"rewrite (sep_swap3 P).\nrewrite sep_swap.\nreflexivity."},{"statement":"(P Q R S T : massert) : massert_eqv (Q ** S ** R ** P ** T) (S ** Q ** R ** P ** T).","proofString":"rewrite sep_swap.\nreflexivity."},{"statement":"(P Q R S T : massert) : massert_eqv (S ** Q ** R ** P ** T) (S ** Q ** R ** P ** T).","proofString":"reflexivity."},{"statement":"(P Q R S T U : massert) : massert_eqv (P ** Q ** R ** S ** T ** U) (T ** Q ** R ** S ** P ** U).","proofString":"rewrite sep_swap.\nrewrite (sep_swap4 P).\nrewrite sep_swap.\nreflexivity."},{"statement":"(P Q R S T U : massert) : massert_eqv (Q ** P ** R ** S ** T ** U) (T ** Q ** R ** S ** P ** U).","proofString":"rewrite (sep_swap4 P).\nrewrite sep_swap.\nreflexivity."},{"statement":"(P Q R S T U : massert) : massert_eqv (Q ** T ** R ** S ** P ** U) (T ** Q ** R ** S ** P ** U).","proofString":"rewrite sep_swap.\nreflexivity."},{"statement":"(P Q R S T U : massert) : massert_eqv (T ** Q ** R ** S ** P ** U) (T ** Q ** R ** S ** P ** U).","proofString":"reflexivity."},{"statement":"(P Q : massert) (m : mem) (H : m |= P /\\ m |= Q /\\ disjoint_footprint P Q) : m |= Q.","proofString":"tauto."},{"statement":"(P Q R : massert) (m : mem) (H : m |= P ** Q ** R) : m |= P ** R.","proofString":"rewrite sep_swap in H.\neapply sep_drop; eauto."},{"statement":"(P Q R : massert) (m : mem) (H : m |= Q ** P ** R) : m |= P ** R.","proofString":"eapply sep_drop; eauto."},{"statement":"(Q P : massert) (m : mem) (H : m |= P ** Q) : m |= P.","proofString":"destruct H; auto."},{"statement":"(P Q R : massert) (m : mem) (H : m |= P ** Q ** R) : m |= Q.","proofString":"eapply sep_proj1; eapply sep_proj2; eauto."},{"statement":"(P Q R S : massert) (m : mem) (H : m |= P ** Q ** R ** S) : m |= R.","proofString":"eapply sep_pick2; eapply sep_proj2; eauto."},{"statement":"(P Q R S T : massert) (m : mem) (H : m |= P ** Q ** R ** S ** T) : m |= S.","proofString":"eapply sep_pick3; eapply sep_proj2; eauto."},{"statement":"(P Q R S T U : massert) (m : mem) (H : m |= P ** Q ** R ** S ** T ** U) : m |= T.","proofString":"eapply sep_pick4; eapply sep_proj2; eauto."},{"statement":"(m m' : mem) (P Q : massert) (H : m |= P /\\ m |= Q /\\ disjoint_footprint P Q) (H0 : m |= P -> m' |= P) (H1 : m |= Q -> m' |= Q) : m' |= P /\\ m' |= Q /\\ disjoint_footprint P Q.","proofString":"intuition auto."},{"statement":"(P : Prop) (Q : massert) (m : mem) : P /\\ m |= Q /\\ disjoint_footprint (pure P) Q <-> P /\\ m |= Q.","proofString":"intuition auto.\nred; simpl; tauto."},{"statement":"(P : Prop) (Q : massert) (m : mem) (H0 : P) (H1 : m |= Q) : disjoint_footprint (pure P) Q.","proofString":"red; simpl; tauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) : (0 <= lo /\\\n hi <= Ptrofs.modulus /\\\n (forall (i : Z) (k : perm_kind) (p : permission),\n  lo <= i < hi -> Mem.perm m' b i k p)) /\\\nm' |= P /\\ disjoint_footprint (range b lo hi) P.","proofString":"split; [|split].\nsplit; auto.\nsplit; auto.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\napply (m_invar P) with m; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl.\nintros.\ndestruct H3; subst b0.\neelim Mem.fresh_block_alloc; eauto.\neapply (m_valid P); eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) : 0 <= lo /\\\nhi <= Ptrofs.modulus /\\\n(forall (i : Z) (k : perm_kind) (p : permission),\n lo <= i < hi -> Mem.perm m' b i k p).","proofString":"split; auto.\nsplit; auto.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) : hi <= Ptrofs.modulus /\\\n(forall (i : Z) (k : perm_kind) (p : permission),\n lo <= i < hi -> Mem.perm m' b i k p).","proofString":"split; auto.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m' b i k p.","proofString":"intros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) (i : Z) (k : perm_kind) (p : permission) (H3 : lo <= i < hi) : Mem.perm m' b i k p.","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) (i : Z) (k : perm_kind) (p : permission) (H3 : lo <= i < hi) : Mem.perm m' b i k Freeable.","proofString":"eapply Mem.perm_alloc_2; eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) : m' |= P.","proofString":"apply (m_invar P) with m; auto.\neapply Mem.alloc_unchanged_on; eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) : Mem.unchanged_on (m_footprint P) m m'.","proofString":"eapply Mem.alloc_unchanged_on; eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) : disjoint_footprint (range b lo hi) P.","proofString":"red; simpl.\nintros.\ndestruct H3; subst b0.\neelim Mem.fresh_block_alloc; eauto.\neapply (m_valid P); eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) : forall (b0 : block) (ofs : Z),\nb0 = b /\\ lo <= ofs < hi -> m_footprint P b0 ofs -> False.","proofString":"intros.\ndestruct H3; subst b0.\neelim Mem.fresh_block_alloc; eauto.\neapply (m_valid P); eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) (b0 : block) (ofs : Z) (H3 : b0 = b /\\ lo <= ofs < hi) (H4 : m_footprint P b0 ofs) : False.","proofString":"destruct H3; subst b0.\neelim Mem.fresh_block_alloc; eauto.\neapply (m_valid P); eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) (ofs : Z) (H5 : lo <= ofs < hi) (H4 : m_footprint P b ofs) : False.","proofString":"eelim Mem.fresh_block_alloc; eauto.\neapply (m_valid P); eauto."},{"statement":"(m : mem) (lo hi : Z) (b : block) (m' : Mem.mem') (P : massert) (H : Mem.alloc m lo hi = (m', b)) (H0 : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H2 : m |= P) (ofs : Z) (H5 : lo <= ofs < hi) (H4 : m_footprint P b ofs) : Mem.valid_block m b.","proofString":"eapply (m_valid P); eauto."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H : lo <= mid <= hi) (H0 : m |= range b lo hi ** P) : m |= range b lo mid ** range b mid hi ** P.","proofString":"rewrite <- sep_assoc.\neapply sep_imp; eauto.\nsplit; simpl; intros.\nintuition auto.\nlia.\napply H5; lia.\nlia.\napply H5; lia.\nred; simpl; intros; lia.\nintuition lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H : lo <= mid <= hi) (H0 : m |= range b lo hi ** P) : m |= (range b lo mid ** range b mid hi) ** P.","proofString":"eapply sep_imp; eauto.\nsplit; simpl; intros.\nintuition auto.\nlia.\napply H5; lia.\nlia.\napply H5; lia.\nred; simpl; intros; lia.\nintuition lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H : lo <= mid <= hi) (H0 : m |= range b lo hi ** P) : massert_imp (range b lo hi) (range b lo mid ** range b mid hi).","proofString":"split; simpl; intros.\nintuition auto.\nlia.\napply H5; lia.\nlia.\napply H5; lia.\nred; simpl; intros; lia.\nintuition lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H : lo <= mid <= hi) (H0 : m |= range b lo hi ** P) (m0 : mem) (H1 : 0 <= lo /\\\nhi <= Ptrofs.modulus /\\\n(forall (i : Z) (k : perm_kind) (p : permission),\n lo <= i < hi -> Mem.perm m0 b i k p)) : (0 <= lo /\\\n mid <= Ptrofs.modulus /\\\n (forall (i : Z) (k : perm_kind) (p : permission),\n  lo <= i < mid -> Mem.perm m0 b i k p)) /\\\n(0 <= mid /\\\n hi <= Ptrofs.modulus /\\\n (forall (i : Z) (k : perm_kind) (p : permission),\n  mid <= i < hi -> Mem.perm m0 b i k p)) /\\\ndisjoint_footprint (range b lo mid) (range b mid hi).","proofString":"intuition auto.\nlia.\napply H5; lia.\nlia.\napply H5; lia.\nred; simpl; intros; lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H0 : m |= range b lo hi ** P) (m0 : mem) (H2 : lo <= mid) (H3 : mid <= hi) (H : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H5 : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m0 b i k p) : mid <= Ptrofs.modulus.","proofString":"lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H0 : m |= range b lo hi ** P) (m0 : mem) (H2 : lo <= mid) (H3 : mid <= hi) (H : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H5 : forall (i0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= i0 < hi -> Mem.perm m0 b i0 k0 p0) (i : Z) (k : perm_kind) (p : permission) (H6 : lo <= i) (H7 : i < mid) : Mem.perm m0 b i k p.","proofString":"apply H5; lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H0 : m |= range b lo hi ** P) (m0 : mem) (H2 : lo <= mid) (H3 : mid <= hi) (H : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H5 : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m0 b i k p) : 0 <= mid.","proofString":"lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H0 : m |= range b lo hi ** P) (m0 : mem) (H2 : lo <= mid) (H3 : mid <= hi) (H : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H5 : forall (i0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= i0 < hi -> Mem.perm m0 b i0 k0 p0) (i : Z) (k : perm_kind) (p : permission) (H6 : mid <= i) (H7 : i < hi) : Mem.perm m0 b i k p.","proofString":"apply H5; lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H0 : m |= range b lo hi ** P) (m0 : mem) (H2 : lo <= mid) (H3 : mid <= hi) (H : 0 <= lo) (H1 : hi <= Ptrofs.modulus) (H5 : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m0 b i k p) : disjoint_footprint (range b lo mid) (range b mid hi).","proofString":"red; simpl; intros; lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H : lo <= mid <= hi) (H0 : m |= range b lo hi ** P) (b0 : block) (ofs : Z) (H1 : b0 = b /\\ lo <= ofs < mid \\/ b0 = b /\\ mid <= ofs < hi) : b0 = b /\\ lo <= ofs < hi.","proofString":"intuition lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H : lo <= mid <= hi) (H0 : m |= range b lo hi ** P) : m |= range b mid hi ** P.","proofString":"apply sep_drop with (range b lo mid).\napply range_split; auto."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H : lo <= mid <= hi) (H0 : m |= range b lo hi ** P) : m |= range b lo mid ** range b mid hi ** P.","proofString":"apply range_split; auto."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H : lo <= mid <= hi) (H0 : m |= range b lo hi ** P) : m |= range b lo mid ** P.","proofString":"apply sep_drop2 with (range b mid hi).\napply range_split; auto."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid : Z) (m : mem) (H : lo <= mid <= hi) (H0 : m |= range b lo hi ** P) : m |= range b lo mid ** range b mid hi ** P.","proofString":"apply range_split; auto."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H : lo <= align mid al <= hi) (H0 : al > 0) (H1 : m |= range b lo hi ** P) : m |= range b lo mid ** range b (align mid al) hi ** P.","proofString":"rewrite <- sep_assoc.\neapply sep_imp; eauto.\nassert (mid <= align mid al) by (apply align_le; auto).\nsplit; simpl; intros.\nintuition auto.\nlia.\napply H7; lia.\nlia.\napply H7; lia.\nred; simpl; intros; lia.\nintuition lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H : lo <= align mid al <= hi) (H0 : al > 0) (H1 : m |= range b lo hi ** P) : m |= (range b lo mid ** range b (align mid al) hi) ** P.","proofString":"eapply sep_imp; eauto.\nassert (mid <= align mid al) by (apply align_le; auto).\nsplit; simpl; intros.\nintuition auto.\nlia.\napply H7; lia.\nlia.\napply H7; lia.\nred; simpl; intros; lia.\nintuition lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H : lo <= align mid al <= hi) (H0 : al > 0) (H1 : m |= range b lo hi ** P) : massert_imp (range b lo hi) (range b lo mid ** range b (align mid al) hi).","proofString":"assert (mid <= align mid al) by (apply align_le; auto).\nsplit; simpl; intros.\nintuition auto.\nlia.\napply H7; lia.\nlia.\napply H7; lia.\nred; simpl; intros; lia.\nintuition lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H : lo <= align mid al <= hi) (H0 : al > 0) (H1 : m |= range b lo hi ** P) (H2 : mid <= align mid al) : massert_imp (range b lo hi) (range b lo mid ** range b (align mid al) hi).","proofString":"split; simpl; intros.\nintuition auto.\nlia.\napply H7; lia.\nlia.\napply H7; lia.\nred; simpl; intros; lia.\nintuition lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H : lo <= align mid al <= hi) (H0 : al > 0) (H1 : m |= range b lo hi ** P) (H2 : mid <= align mid al) (m0 : mem) (H3 : 0 <= lo /\\\nhi <= Ptrofs.modulus /\\\n(forall (i : Z) (k : perm_kind) (p : permission),\n lo <= i < hi -> Mem.perm m0 b i k p)) : (0 <= lo /\\\n mid <= Ptrofs.modulus /\\\n (forall (i : Z) (k : perm_kind) (p : permission),\n  lo <= i < mid -> Mem.perm m0 b i k p)) /\\\n(0 <= align mid al /\\\n hi <= Ptrofs.modulus /\\\n (forall (i : Z) (k : perm_kind) (p : permission),\n  align mid al <= i < hi -> Mem.perm m0 b i k p)) /\\\ndisjoint_footprint (range b lo mid) (range b (align mid al) hi).","proofString":"intuition auto.\nlia.\napply H7; lia.\nlia.\napply H7; lia.\nred; simpl; intros; lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H0 : al > 0) (H1 : m |= range b lo hi ** P) (H2 : mid <= align mid al) (m0 : mem) (H4 : lo <= align mid al) (H5 : align mid al <= hi) (H : 0 <= lo) (H3 : hi <= Ptrofs.modulus) (H7 : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m0 b i k p) : mid <= Ptrofs.modulus.","proofString":"lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H0 : al > 0) (H1 : m |= range b lo hi ** P) (H2 : mid <= align mid al) (m0 : mem) (H4 : lo <= align mid al) (H5 : align mid al <= hi) (H : 0 <= lo) (H3 : hi <= Ptrofs.modulus) (H7 : forall (i0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= i0 < hi -> Mem.perm m0 b i0 k0 p0) (i : Z) (k : perm_kind) (p : permission) (H8 : lo <= i) (H9 : i < mid) : Mem.perm m0 b i k p.","proofString":"apply H7; lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H0 : al > 0) (H1 : m |= range b lo hi ** P) (H2 : mid <= align mid al) (m0 : mem) (H4 : lo <= align mid al) (H5 : align mid al <= hi) (H : 0 <= lo) (H3 : hi <= Ptrofs.modulus) (H7 : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m0 b i k p) : 0 <= align mid al.","proofString":"lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H0 : al > 0) (H1 : m |= range b lo hi ** P) (H2 : mid <= align mid al) (m0 : mem) (H4 : lo <= align mid al) (H5 : align mid al <= hi) (H : 0 <= lo) (H3 : hi <= Ptrofs.modulus) (H7 : forall (i0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= i0 < hi -> Mem.perm m0 b i0 k0 p0) (i : Z) (k : perm_kind) (p : permission) (H8 : align mid al <= i) (H9 : i < hi) : Mem.perm m0 b i k p.","proofString":"apply H7; lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H0 : al > 0) (H1 : m |= range b lo hi ** P) (H2 : mid <= align mid al) (m0 : mem) (H4 : lo <= align mid al) (H5 : align mid al <= hi) (H : 0 <= lo) (H3 : hi <= Ptrofs.modulus) (H7 : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m0 b i k p) : disjoint_footprint (range b lo mid) (range b (align mid al) hi).","proofString":"red; simpl; intros; lia."},{"statement":"(b : block) (lo hi : Z) (P : massert) (mid al : Z) (m : mem) (H : lo <= align mid al <= hi) (H0 : al > 0) (H1 : m |= range b lo hi ** P) (H2 : mid <= align mid al) (b0 : block) (ofs : Z) (H3 : b0 = b /\\ lo <= ofs < mid \\/ b0 = b /\\ align mid al <= ofs < hi) : b0 = b /\\ lo <= ofs < hi.","proofString":"intuition lia."},{"statement":"(m m' : mem) (b : block) (lo hi : Z) (H : m |= range b lo hi) (H0 : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m b i k p -> Mem.perm m' b i k p) : m' |= range b lo hi.","proofString":"destruct H as (A & B & C).\nsimpl; intuition auto."},{"statement":"(m m' : mem) (b : block) (lo hi : Z) (A : 0 <= lo) (B : hi <= Ptrofs.modulus) (C : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m b i k p) (H0 : forall (i : Z) (k : perm_kind) (p : permission),\nlo <= i < hi -> Mem.perm m b i k p -> Mem.perm m' b i k p) : m' |= range b lo hi.","proofString":"simpl; intuition auto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : m |= contains chunk b ofs spec) : 0 <= ofs <= Ptrofs.max_unsigned.","proofString":"simpl in H.\ntauto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : 0 <= ofs <= Ptrofs.max_unsigned /\\\nMem.valid_access m chunk b ofs Freeable /\\\n(exists v : val, Mem.load chunk m b ofs = Some v /\\ spec v)) : 0 <= ofs <= Ptrofs.max_unsigned.","proofString":"tauto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : m |= contains chunk b ofs spec) : exists v : val, Mem.load chunk m b ofs = Some v /\\ spec v.","proofString":"destruct H as (D & E & v & F & G).\nexists v; auto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (D : 0 <= ofs <= Ptrofs.max_unsigned) (E : Mem.valid_access m chunk b ofs Freeable) (v : val) (F : Mem.load chunk m b ofs = Some v) (G : spec v) : exists v0 : val, Mem.load chunk m b ofs = Some v0 /\\ spec v0.","proofString":"exists v; auto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : m |= contains chunk b ofs spec) : exists v : val,\n  Mem.loadv chunk m (Vptr b (Ptrofs.repr ofs)) = Some v /\\ spec v.","proofString":"exploit load_rule; eauto.\nintros (v & A & B).\nexists v; split; auto.\nsimpl.\nrewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow; eauto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : m |= contains chunk b ofs spec) : (exists v : val, Mem.load chunk m b ofs = Some v /\\ spec v) ->\nexists v : val,\n  Mem.loadv chunk m (Vptr b (Ptrofs.repr ofs)) = Some v /\\ spec v.","proofString":"intros (v & A & B).\nexists v; split; auto.\nsimpl.\nrewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow; eauto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : m |= contains chunk b ofs spec) (v : val) (A : Mem.load chunk m b ofs = Some v) (B : spec v) : exists v0 : val,\n  Mem.loadv chunk m (Vptr b (Ptrofs.repr ofs)) = Some v0 /\\ spec v0.","proofString":"exists v; split; auto.\nsimpl.\nrewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow; eauto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : m |= contains chunk b ofs spec) (v : val) (A : Mem.load chunk m b ofs = Some v) (B : spec v) : Mem.loadv chunk m (Vptr b (Ptrofs.repr ofs)) = Some v.","proofString":"simpl.\nrewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow; eauto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : m |= contains chunk b ofs spec) (v : val) (A : Mem.load chunk m b ofs = Some v) (B : spec v) : Mem.load chunk m b (Ptrofs.unsigned (Ptrofs.repr ofs)) = Some v.","proofString":"rewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow; eauto."},{"statement":"(spec : val -> Prop) (m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : m |= contains chunk b ofs spec) (v : val) (A : Mem.load chunk m b ofs = Some v) (B : spec v) : 0 <= ofs <= Ptrofs.max_unsigned.","proofString":"eapply contains_no_overflow; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (H : m |= contains chunk b ofs spec1 ** P) (H0 : spec (Val.load_result chunk v)) : exists m' : mem,\n  Mem.store chunk m b ofs v = Some m' /\\ m' |= contains chunk b ofs spec ** P.","proofString":"destruct H as (A & B & C).\ndestruct A as (D & E & v0 & F & G).\nassert (H: Mem.valid_access m chunk b ofs Writable) by eauto with mem.\ndestruct (Mem.valid_access_store _ _ _ _ v H) as [m' STORE].\nexists m'; split; auto.\nsimpl.\nintuition auto.\neapply Mem.store_valid_access_1; eauto.\nexists (Val.load_result chunk v); split; auto.\neapply Mem.load_store_same; eauto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (A : m |= contains chunk b ofs spec1) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) : exists m' : mem,\n  Mem.store chunk m b ofs v = Some m' /\\ m' |= contains chunk b ofs spec ** P.","proofString":"destruct A as (D & E & v0 & F & G).\nassert (H: Mem.valid_access m chunk b ofs Writable) by eauto with mem.\ndestruct (Mem.valid_access_store _ _ _ _ v H) as [m' STORE].\nexists m'; split; auto.\nsimpl.\nintuition auto.\neapply Mem.store_valid_access_1; eauto.\nexists (Val.load_result chunk v); split; auto.\neapply Mem.load_store_same; eauto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (D : 0 <= ofs <= Ptrofs.max_unsigned) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) : exists m' : mem,\n  Mem.store chunk m b ofs v = Some m' /\\ m' |= contains chunk b ofs spec ** P.","proofString":"assert (H: Mem.valid_access m chunk b ofs Writable) by eauto with mem.\ndestruct (Mem.valid_access_store _ _ _ _ v H) as [m' STORE].\nexists m'; split; auto.\nsimpl.\nintuition auto.\neapply Mem.store_valid_access_1; eauto.\nexists (Val.load_result chunk v); split; auto.\neapply Mem.load_store_same; eauto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (D : 0 <= ofs <= Ptrofs.max_unsigned) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) : exists m' : mem,\n  Mem.store chunk m b ofs v = Some m' /\\ m' |= contains chunk b ofs spec ** P.","proofString":"destruct (Mem.valid_access_store _ _ _ _ v H) as [m' STORE].\nexists m'; split; auto.\nsimpl.\nintuition auto.\neapply Mem.store_valid_access_1; eauto.\nexists (Val.load_result chunk v); split; auto.\neapply Mem.load_store_same; eauto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (D : 0 <= ofs <= Ptrofs.max_unsigned) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') : exists m'0 : mem,\n  Mem.store chunk m b ofs v = Some m'0 /\\\n  m'0 |= contains chunk b ofs spec ** P.","proofString":"exists m'; split; auto.\nsimpl.\nintuition auto.\neapply Mem.store_valid_access_1; eauto.\nexists (Val.load_result chunk v); split; auto.\neapply Mem.load_store_same; eauto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (D : 0 <= ofs <= Ptrofs.max_unsigned) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') : m' |= contains chunk b ofs spec ** P.","proofString":"simpl.\nintuition auto.\neapply Mem.store_valid_access_1; eauto.\nexists (Val.load_result chunk v); split; auto.\neapply Mem.load_store_same; eauto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (D : 0 <= ofs <= Ptrofs.max_unsigned) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') : (0 <= ofs <= Ptrofs.max_unsigned /\\\n Mem.valid_access m' chunk b ofs Freeable /\\\n (exists v1 : val, Mem.load chunk m' b ofs = Some v1 /\\ spec v1)) /\\\nm' |= P /\\ disjoint_footprint (contains chunk b ofs spec) P.","proofString":"intuition auto.\neapply Mem.store_valid_access_1; eauto.\nexists (Val.load_result chunk v); split; auto.\neapply Mem.load_store_same; eauto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') (H1 : 0 <= ofs) (H2 : ofs <= Ptrofs.max_unsigned) : Mem.valid_access m' chunk b ofs Freeable.","proofString":"eapply Mem.store_valid_access_1; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') (H1 : 0 <= ofs) (H2 : ofs <= Ptrofs.max_unsigned) : exists v1 : val, Mem.load chunk m' b ofs = Some v1 /\\ spec v1.","proofString":"exists (Val.load_result chunk v); split; auto.\neapply Mem.load_store_same; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') (H1 : 0 <= ofs) (H2 : ofs <= Ptrofs.max_unsigned) : Mem.load chunk m' b ofs = Some (Val.load_result chunk v).","proofString":"eapply Mem.load_store_same; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') (H1 : 0 <= ofs) (H2 : ofs <= Ptrofs.max_unsigned) : m' |= P.","proofString":"apply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') (H1 : 0 <= ofs) (H2 : ofs <= Ptrofs.max_unsigned) : Mem.unchanged_on (m_footprint P) m m'.","proofString":"eapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') (H1 : 0 <= ofs) (H2 : ofs <= Ptrofs.max_unsigned) : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ m_footprint P b i.","proofString":"intros; red; intros.\napply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (E : Mem.valid_access m chunk b ofs Freeable) (v0 : val) (F : Mem.load chunk m b ofs = Some v0) (G : spec1 v0) (B : m |= P) (C : disjoint_footprint (contains chunk b ofs spec1) P) (H0 : spec (Val.load_result chunk v)) (H : Mem.valid_access m chunk b ofs Writable) (m' : mem) (STORE : Mem.store chunk m b ofs v = Some m') (H1 : 0 <= ofs) (H2 : ofs <= Ptrofs.max_unsigned) (i : Z) (H3 : ofs <= i < ofs + size_chunk chunk) (H4 : m_footprint P b i) : False.","proofString":"apply (C b i); simpl; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (H : m |= contains chunk b ofs spec1 ** P) (H0 : spec (Val.load_result chunk v)) : exists m' : mem,\n  Mem.storev chunk m (Vptr b (Ptrofs.repr ofs)) v = Some m' /\\\n  m' |= contains chunk b ofs spec ** P.","proofString":"exploit store_rule; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nsimpl.\nrewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow.\neapply sep_pick1; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (H : m |= contains chunk b ofs spec1 ** P) (H0 : spec (Val.load_result chunk v)) : (exists m' : mem,\n   Mem.store chunk m b ofs v = Some m' /\\\n   m' |= contains chunk b ofs spec ** P) ->\nexists m' : mem,\n  Mem.storev chunk m (Vptr b (Ptrofs.repr ofs)) v = Some m' /\\\n  m' |= contains chunk b ofs spec ** P.","proofString":"intros (m' & A & B).\nexists m'; split; auto.\nsimpl.\nrewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow.\neapply sep_pick1; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (H : m |= contains chunk b ofs spec1 ** P) (H0 : spec (Val.load_result chunk v)) (m' : mem) (A : Mem.store chunk m b ofs v = Some m') (B : m' |= contains chunk b ofs spec ** P) : exists m'0 : mem,\n  Mem.storev chunk m (Vptr b (Ptrofs.repr ofs)) v = Some m'0 /\\\n  m'0 |= contains chunk b ofs spec ** P.","proofString":"exists m'; split; auto.\nsimpl.\nrewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow.\neapply sep_pick1; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (H : m |= contains chunk b ofs spec1 ** P) (H0 : spec (Val.load_result chunk v)) (m' : mem) (A : Mem.store chunk m b ofs v = Some m') (B : m' |= contains chunk b ofs spec ** P) : Mem.storev chunk m (Vptr b (Ptrofs.repr ofs)) v = Some m'.","proofString":"simpl.\nrewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow.\neapply sep_pick1; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (H : m |= contains chunk b ofs spec1 ** P) (H0 : spec (Val.load_result chunk v)) (m' : mem) (A : Mem.store chunk m b ofs v = Some m') (B : m' |= contains chunk b ofs spec ** P) : Mem.store chunk m b (Ptrofs.unsigned (Ptrofs.repr ofs)) v = Some m'.","proofString":"rewrite Ptrofs.unsigned_repr; auto.\neapply contains_no_overflow.\neapply sep_pick1; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 spec : val -> Prop) (P : massert) (H : m |= contains chunk b ofs spec1 ** P) (H0 : spec (Val.load_result chunk v)) (m' : mem) (A : Mem.store chunk m b ofs v = Some m') (B : m' |= contains chunk b ofs spec ** P) : 0 <= ofs <= Ptrofs.max_unsigned.","proofString":"eapply contains_no_overflow.\neapply sep_pick1; eauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (H : m |= range b ofs (ofs + size_chunk chunk) ** P) (H0 : (align_chunk chunk | ofs)) : m |= contains chunk b ofs (fun _ : val => True) ** P.","proofString":"destruct H as (A & B & C).\ndestruct A as (D & E & F).\nsplit; [|split].\nassert (Mem.valid_access m chunk b ofs Freeable).\nsplit; auto.\nred; auto.\nsplit.\ngeneralize (size_chunk_pos chunk).\nunfold Ptrofs.max_unsigned.\nlia.\nsplit.\nauto.\ndestruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].\neauto with mem.\nexists v; auto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (A : m |= range b ofs (ofs + size_chunk chunk)) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) : m |= contains chunk b ofs (fun _ : val => True) ** P.","proofString":"destruct A as (D & E & F).\nsplit; [|split].\nassert (Mem.valid_access m chunk b ofs Freeable).\nsplit; auto.\nred; auto.\nsplit.\ngeneralize (size_chunk_pos chunk).\nunfold Ptrofs.max_unsigned.\nlia.\nsplit.\nauto.\ndestruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].\neauto with mem.\nexists v; auto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) : m |= contains chunk b ofs (fun _ : val => True) ** P.","proofString":"split; [|split].\nassert (Mem.valid_access m chunk b ofs Freeable).\nsplit; auto.\nred; auto.\nsplit.\ngeneralize (size_chunk_pos chunk).\nunfold Ptrofs.max_unsigned.\nlia.\nsplit.\nauto.\ndestruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].\neauto with mem.\nexists v; auto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) : m |= contains chunk b ofs (fun _ : val => True).","proofString":"assert (Mem.valid_access m chunk b ofs Freeable).\nsplit; auto.\nred; auto.\nsplit.\ngeneralize (size_chunk_pos chunk).\nunfold Ptrofs.max_unsigned.\nlia.\nsplit.\nauto.\ndestruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].\neauto with mem.\nexists v; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) : Mem.valid_access m chunk b ofs Freeable.","proofString":"split; auto.\nred; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Freeable.","proofString":"red; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) (H : Mem.valid_access m chunk b ofs Freeable) : m |= contains chunk b ofs (fun _ : val => True).","proofString":"split.\ngeneralize (size_chunk_pos chunk).\nunfold Ptrofs.max_unsigned.\nlia.\nsplit.\nauto.\ndestruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].\neauto with mem.\nexists v; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) (H : Mem.valid_access m chunk b ofs Freeable) : 0 <= ofs <= Ptrofs.max_unsigned.","proofString":"generalize (size_chunk_pos chunk).\nunfold Ptrofs.max_unsigned.\nlia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) (H : Mem.valid_access m chunk b ofs Freeable) : size_chunk chunk > 0 -> 0 <= ofs <= Ptrofs.max_unsigned.","proofString":"unfold Ptrofs.max_unsigned.\nlia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) (H : Mem.valid_access m chunk b ofs Freeable) : size_chunk chunk > 0 -> 0 <= ofs <= Ptrofs.modulus - 1.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) (H : Mem.valid_access m chunk b ofs Freeable) : Mem.valid_access m chunk b ofs Freeable /\\\n(exists v : val, Mem.load chunk m b ofs = Some v /\\ True).","proofString":"split.\nauto.\ndestruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].\neauto with mem.\nexists v; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) (H : Mem.valid_access m chunk b ofs Freeable) : Mem.valid_access m chunk b ofs Freeable.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) (H : Mem.valid_access m chunk b ofs Freeable) : exists v : val, Mem.load chunk m b ofs = Some v /\\ True.","proofString":"destruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].\neauto with mem.\nexists v; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) (H : Mem.valid_access m chunk b ofs Freeable) : Mem.valid_access m chunk b ofs Readable.","proofString":"eauto with mem."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) (H : Mem.valid_access m chunk b ofs Freeable) (v : val) (LOAD : Mem.load chunk m b ofs = Some v) : exists v0 : val, Mem.load chunk m b ofs = Some v0 /\\ True.","proofString":"exists v; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) : m |= P.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (P : massert) (m : mem) (D : 0 <= ofs) (E : ofs + size_chunk chunk <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\nofs <= i < ofs + size_chunk chunk -> Mem.perm m b i k p) (B : m |= P) (C : disjoint_footprint (range b ofs (ofs + size_chunk chunk)) P) (H0 : (align_chunk chunk | ofs)) : disjoint_footprint (contains chunk b ofs (fun _ : val => True)) P.","proofString":"auto."},{"statement":"(spec1 spec2 : val -> Prop) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall v : val, spec1 v -> spec2 v) (m : mem) (H0 : 0 <= ofs <= Ptrofs.max_unsigned /\\\nMem.valid_access m chunk b ofs Freeable /\\\n(exists v : val, Mem.load chunk m b ofs = Some v /\\ spec1 v)) : 0 <= ofs <= Ptrofs.max_unsigned /\\\nMem.valid_access m chunk b ofs Freeable /\\\n(exists v : val, Mem.load chunk m b ofs = Some v /\\ spec2 v).","proofString":"intuition auto.\ndestruct H4 as (v & A & B).\nexists v; auto."},{"statement":"(spec1 spec2 : val -> Prop) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall v : val, spec1 v -> spec2 v) (m : mem) (H0 : 0 <= ofs) (H3 : ofs <= Ptrofs.max_unsigned) (H1 : Mem.valid_access m chunk b ofs Freeable) (H4 : exists v : val, Mem.load chunk m b ofs = Some v /\\ spec1 v) : exists v : val, Mem.load chunk m b ofs = Some v /\\ spec2 v.","proofString":"destruct H4 as (v & A & B).\nexists v; auto."},{"statement":"(spec1 spec2 : val -> Prop) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall v0 : val, spec1 v0 -> spec2 v0) (m : mem) (H0 : 0 <= ofs) (H3 : ofs <= Ptrofs.max_unsigned) (H1 : Mem.valid_access m chunk b ofs Freeable) (v : val) (A : Mem.load chunk m b ofs = Some v) (B : spec1 v) : exists v0 : val, Mem.load chunk m b ofs = Some v0 /\\ spec2 v0.","proofString":"exists v; auto."},{"statement":"(spec1 spec2 : val -> Prop) (chunk : memory_chunk) (b : block) (ofs : Z) (H : forall v : val, spec1 v -> spec2 v) (b0 : block) (ofs0 : Z) (H0 : b0 = b /\\ ofs <= ofs0 < ofs + size_chunk chunk) : b0 = b /\\ ofs <= ofs0 < ofs + size_chunk chunk.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 : val -> Prop) (P : massert) (H : m |= contains chunk b ofs spec1 ** P) : exists m' : mem,\n  Mem.store chunk m b ofs v = Some m' /\\\n  m' |= hasvalue chunk b ofs (Val.load_result chunk v) ** P.","proofString":"eapply store_rule; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (spec1 : val -> Prop) (P : massert) (H : m |= contains chunk b ofs spec1 ** P) : exists m' : mem,\n  Mem.storev chunk m (Vptr b (Ptrofs.repr ofs)) v = Some m' /\\\n  m' |= hasvalue chunk b ofs (Val.load_result chunk v) ** P.","proofString":"eapply storev_rule; eauto."},{"statement":"(P Q R : massert) (m : mem) (H : m |= P ** R) (H0 : m |= Q ** R) : m |= mconj P Q ** R.","proofString":"destruct H as (A & B & C).\ndestruct H0 as (D & E & F).\nsplit; [|split].\nsimpl; auto.\nauto.\nred; simpl; intros.\ndestruct H; [eelim C | eelim F]; eauto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P) (B : m |= R) (C : disjoint_footprint P R) (H0 : m |= Q ** R) : m |= mconj P Q ** R.","proofString":"destruct H0 as (D & E & F).\nsplit; [|split].\nsimpl; auto.\nauto.\nred; simpl; intros.\ndestruct H; [eelim C | eelim F]; eauto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P) (B : m |= R) (C : disjoint_footprint P R) (D : m |= Q) (E : m |= R) (F : disjoint_footprint Q R) : m |= mconj P Q ** R.","proofString":"split; [|split].\nsimpl; auto.\nauto.\nred; simpl; intros.\ndestruct H; [eelim C | eelim F]; eauto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P) (B : m |= R) (C : disjoint_footprint P R) (D : m |= Q) (E : m |= R) (F : disjoint_footprint Q R) : m |= mconj P Q.","proofString":"simpl; auto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P) (B : m |= R) (C : disjoint_footprint P R) (D : m |= Q) (E : m |= R) (F : disjoint_footprint Q R) : m |= R.","proofString":"auto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P) (B : m |= R) (C : disjoint_footprint P R) (D : m |= Q) (E : m |= R) (F : disjoint_footprint Q R) : disjoint_footprint (mconj P Q) R.","proofString":"red; simpl; intros.\ndestruct H; [eelim C | eelim F]; eauto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P) (B : m |= R) (C : disjoint_footprint P R) (D : m |= Q) (E : m |= R) (F : disjoint_footprint Q R) (b : block) (ofs : Z) (H : m_footprint P b ofs \\/ m_footprint Q b ofs) (H0 : m_footprint R b ofs) : False.","proofString":"destruct H; [eelim C | eelim F]; eauto."},{"statement":"(P Q R : massert) (m : mem) (H : m |= mconj P Q ** R) : m |= P ** R.","proofString":"destruct H as (A & B & C); simpl in A.\nsimpl.\nintuition auto.\nred; intros; eapply C; eauto; simpl; auto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P /\\ m |= Q) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) : m |= P ** R.","proofString":"simpl.\nintuition auto.\nred; intros; eapply C; eauto; simpl; auto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P /\\ m |= Q) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) : m |= P /\\ m |= R /\\ disjoint_footprint P R.","proofString":"intuition auto.\nred; intros; eapply C; eauto; simpl; auto."},{"statement":"(P Q R : massert) (m : mem) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) (H : m |= P) (H0 : m |= Q) : disjoint_footprint P R.","proofString":"red; intros; eapply C; eauto; simpl; auto."},{"statement":"(P Q R : massert) (m : mem) (H : m |= mconj P Q ** R) : m |= Q ** R.","proofString":"destruct H as (A & B & C); simpl in A.\nsimpl.\nintuition auto.\nred; intros; eapply C; eauto; simpl; auto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P /\\ m |= Q) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) : m |= Q ** R.","proofString":"simpl.\nintuition auto.\nred; intros; eapply C; eauto; simpl; auto."},{"statement":"(P Q R : massert) (m : mem) (A : m |= P /\\ m |= Q) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) : m |= Q /\\ m |= R /\\ disjoint_footprint Q R.","proofString":"intuition auto.\nred; intros; eapply C; eauto; simpl; auto."},{"statement":"(P Q R : massert) (m : mem) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) (H : m |= P) (H0 : m |= Q) : disjoint_footprint Q R.","proofString":"red; intros; eapply C; eauto; simpl; auto."},{"statement":"(P P' Q R : massert) (m m' : mem) (H : m |= mconj P Q ** R) (H0 : m' |= P' ** R) (H1 : m' |= Q) : m' |= mconj P' Q ** R.","proofString":"destruct H as (A & B & C); simpl in A.\ndestruct H0 as (D & E & F).\nsimpl.\nintuition auto.\nred; simpl; intros.\ndestruct H2.\neapply F; eauto.\neapply C; simpl; eauto."},{"statement":"(P P' Q R : massert) (m m' : mem) (A : m |= P /\\ m |= Q) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) (H0 : m' |= P' ** R) (H1 : m' |= Q) : m' |= mconj P' Q ** R.","proofString":"destruct H0 as (D & E & F).\nsimpl.\nintuition auto.\nred; simpl; intros.\ndestruct H2.\neapply F; eauto.\neapply C; simpl; eauto."},{"statement":"(P P' Q R : massert) (m m' : mem) (A : m |= P /\\ m |= Q) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) (D : m' |= P') (E : m' |= R) (F : disjoint_footprint P' R) (H1 : m' |= Q) : m' |= mconj P' Q ** R.","proofString":"simpl.\nintuition auto.\nred; simpl; intros.\ndestruct H2.\neapply F; eauto.\neapply C; simpl; eauto."},{"statement":"(P P' Q R : massert) (m m' : mem) (A : m |= P /\\ m |= Q) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) (D : m' |= P') (E : m' |= R) (F : disjoint_footprint P' R) (H1 : m' |= Q) : (m' |= P' /\\ m' |= Q) /\\ m' |= R /\\ disjoint_footprint (mconj P' Q) R.","proofString":"intuition auto.\nred; simpl; intros.\ndestruct H2.\neapply F; eauto.\neapply C; simpl; eauto."},{"statement":"(P P' Q R : massert) (m m' : mem) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) (D : m' |= P') (E : m' |= R) (F : disjoint_footprint P' R) (H1 : m' |= Q) (H : m |= P) (H0 : m |= Q) : disjoint_footprint (mconj P' Q) R.","proofString":"red; simpl; intros.\ndestruct H2.\neapply F; eauto.\neapply C; simpl; eauto."},{"statement":"(P P' Q R : massert) (m m' : mem) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) (D : m' |= P') (E : m' |= R) (F : disjoint_footprint P' R) (H1 : m' |= Q) (H : m |= P) (H0 : m |= Q) (b : block) (ofs : Z) (H2 : m_footprint P' b ofs \\/ m_footprint Q b ofs) (H3 : m_footprint R b ofs) : False.","proofString":"destruct H2.\neapply F; eauto.\neapply C; simpl; eauto."},{"statement":"(P P' Q R : massert) (m m' : mem) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) (D : m' |= P') (E : m' |= R) (F : disjoint_footprint P' R) (H1 : m' |= Q) (H : m |= P) (H0 : m |= Q) (b : block) (ofs : Z) (H2 : m_footprint P' b ofs) (H3 : m_footprint R b ofs) : False.","proofString":"eapply F; eauto."},{"statement":"(P P' Q R : massert) (m m' : mem) (B : m |= R) (C : disjoint_footprint (mconj P Q) R) (D : m' |= P') (E : m' |= R) (F : disjoint_footprint P' R) (H1 : m' |= Q) (H : m |= P) (H0 : m |= Q) (b : block) (ofs : Z) (H2 : m_footprint Q b ofs) (H3 : m_footprint R b ofs) : False.","proofString":"eapply C; simpl; eauto."},{"statement":"(j : meminj) (m1 m2 : mem) (chunk : memory_chunk) (addr1 v1 addr2 : val) (H : m2 |= minjection j m1) (H0 : Mem.loadv chunk m1 addr1 = Some v1) (H1 : Val.inject j addr1 addr2) : exists v2 : val, Mem.loadv chunk m2 addr2 = Some v2 /\\ Val.inject j v1 v2.","proofString":"simpl in H.\neapply Mem.loadv_inject; eauto."},{"statement":"(j : meminj) (m1 m2 : mem) (chunk : memory_chunk) (addr1 v1 addr2 : val) (H : Mem.inject j m1 m2) (H0 : Mem.loadv chunk m1 addr1 = Some v1) (H1 : Val.inject j addr1 addr2) : exists v2 : val, Mem.loadv chunk m2 addr2 = Some v2 /\\ Val.inject j v1 v2.","proofString":"eapply Mem.loadv_inject; eauto."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (addr1 v1 : val) (m1' : mem) (addr2 v2 : val) (H : m2 |= minjection j m1 ** P) (H0 : Mem.storev chunk m1 addr1 v1 = Some m1') (H1 : Val.inject j addr1 addr2) (H2 : Val.inject j v1 v2) : exists m2' : mem,\n  Mem.storev chunk m2 addr2 v2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"destruct H as (A & B & C).\nsimpl in A.\nexploit Mem.storev_mapped_inject; eauto.\nintros (m2' & STORE & INJ).\ninv H1; simpl in STORE; try discriminate.\nassert (VALID: Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable)    by eauto with mem.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) = Ptrofs.unsigned ofs1 + delta).\neapply Mem.address_inject'; eauto with mem.\nexists m2'; split; auto.\nsplit; [|split].\nexact INJ.\napply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia.\nred; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (addr1 v1 : val) (m1' : mem) (addr2 v2 : val) (A : m2 |= minjection j m1) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (H0 : Mem.storev chunk m1 addr1 v1 = Some m1') (H1 : Val.inject j addr1 addr2) (H2 : Val.inject j v1 v2) : exists m2' : mem,\n  Mem.storev chunk m2 addr2 v2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"simpl in A.\nexploit Mem.storev_mapped_inject; eauto.\nintros (m2' & STORE & INJ).\ninv H1; simpl in STORE; try discriminate.\nassert (VALID: Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable)    by eauto with mem.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) = Ptrofs.unsigned ofs1 + delta).\neapply Mem.address_inject'; eauto with mem.\nexists m2'; split; auto.\nsplit; [|split].\nexact INJ.\napply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia.\nred; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (addr1 v1 : val) (m1' : mem) (addr2 v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (H0 : Mem.storev chunk m1 addr1 v1 = Some m1') (H1 : Val.inject j addr1 addr2) (H2 : Val.inject j v1 v2) : exists m2' : mem,\n  Mem.storev chunk m2 addr2 v2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"exploit Mem.storev_mapped_inject; eauto.\nintros (m2' & STORE & INJ).\ninv H1; simpl in STORE; try discriminate.\nassert (VALID: Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable)    by eauto with mem.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) = Ptrofs.unsigned ofs1 + delta).\neapply Mem.address_inject'; eauto with mem.\nexists m2'; split; auto.\nsplit; [|split].\nexact INJ.\napply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia.\nred; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (addr1 v1 : val) (m1' : mem) (addr2 v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (H0 : Mem.storev chunk m1 addr1 v1 = Some m1') (H1 : Val.inject j addr1 addr2) (H2 : Val.inject j v1 v2) : (exists n2 : mem,\n   Mem.storev chunk m2 addr2 v2 = Some n2 /\\ Mem.inject j m1' n2) ->\nexists m2' : mem,\n  Mem.storev chunk m2 addr2 v2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"intros (m2' & STORE & INJ).\ninv H1; simpl in STORE; try discriminate.\nassert (VALID: Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable)    by eauto with mem.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) = Ptrofs.unsigned ofs1 + delta).\neapply Mem.address_inject'; eauto with mem.\nexists m2'; split; auto.\nsplit; [|split].\nexact INJ.\napply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia.\nred; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (addr1 v1 : val) (m1' : mem) (addr2 v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (H0 : Mem.storev chunk m1 addr1 v1 = Some m1') (H1 : Val.inject j addr1 addr2) (H2 : Val.inject j v1 v2) (m2' : mem) (STORE : Mem.storev chunk m2 addr2 v2 = Some m2') (INJ : Mem.inject j m1' m2') : exists m2'0 : mem,\n  Mem.storev chunk m2 addr2 v2 = Some m2'0 /\\ m2'0 |= minjection j m1' ** P.","proofString":"inv H1; simpl in STORE; try discriminate.\nassert (VALID: Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable)    by eauto with mem.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) = Ptrofs.unsigned ofs1 + delta).\neapply Mem.address_inject'; eauto with mem.\nexists m2'; split; auto.\nsplit; [|split].\nexact INJ.\napply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia.\nred; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) : exists m2'0 : mem,\n  Mem.storev chunk m2 (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) v2 =\n  Some m2'0 /\\ m2'0 |= minjection j m1' ** P.","proofString":"assert (VALID: Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable)    by eauto with mem.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) = Ptrofs.unsigned ofs1 + delta).\neapply Mem.address_inject'; eauto with mem.\nexists m2'; split; auto.\nsplit; [|split].\nexact INJ.\napply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia.\nred; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) : exists m2'0 : mem,\n  Mem.storev chunk m2 (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) v2 =\n  Some m2'0 /\\ m2'0 |= minjection j m1' ** P.","proofString":"assert (EQ: Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) = Ptrofs.unsigned ofs1 + delta).\neapply Mem.address_inject'; eauto with mem.\nexists m2'; split; auto.\nsplit; [|split].\nexact INJ.\napply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia.\nred; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"eapply Mem.address_inject'; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) : exists m2'0 : mem,\n  Mem.storev chunk m2 (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) v2 =\n  Some m2'0 /\\ m2'0 |= minjection j m1' ** P.","proofString":"exists m2'; split; auto.\nsplit; [|split].\nexact INJ.\napply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia.\nred; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) : m2' |= minjection j m1' ** P.","proofString":"split; [|split].\nexact INJ.\napply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia.\nred; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) : m2' |= minjection j m1'.","proofString":"exact INJ."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) : m2' |= P.","proofString":"apply (m_invar P) with m2; auto.\neapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) : Mem.unchanged_on (m_footprint P) m2 m2'.","proofString":"eapply Mem.store_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) : forall i : Z,\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) + size_chunk chunk ->\n~ m_footprint P b2 i.","proofString":"intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (i : Z) (H1 : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) + size_chunk chunk) (H3 : m_footprint P b2 i) : False.","proofString":"eelim C; eauto.\nsimpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (i : Z) (H1 : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) + size_chunk chunk) (H3 : m_footprint P b2 i) : m_footprint (minjection j m1) b2 i.","proofString":"simpl.\nexists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (i : Z) (H1 : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) + size_chunk chunk) (H3 : m_footprint P b2 i) : exists (b0 : block) (delta0 : Z),\n  j b0 = Some (b2, delta0) /\\ Mem.perm m1 b0 (i - delta0) Max Nonempty.","proofString":"exists b1, delta; split; auto.\ndestruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (i : Z) (H1 : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) + size_chunk chunk) (H3 : m_footprint P b2 i) : Mem.perm m1 b1 (i - delta) Max Nonempty.","proofString":"destruct VALID as [V1 V2].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (V1 : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk) Cur Writable) (V2 : (align_chunk chunk | Ptrofs.unsigned ofs1)) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (i : Z) (H1 : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) + size_chunk chunk) (H3 : m_footprint P b2 i) : Mem.perm m1 b1 (i - delta) Max Nonempty.","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (V1 : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk) Cur Writable) (V2 : (align_chunk chunk | Ptrofs.unsigned ofs1)) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (i : Z) (H1 : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) + size_chunk chunk) (H3 : m_footprint P b2 i) : Mem.perm m1 b1 (i - delta) Cur Nonempty.","proofString":"apply Mem.perm_implies with Writable; auto with mem.\napply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (V1 : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk) Cur Writable) (V2 : (align_chunk chunk | Ptrofs.unsigned ofs1)) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (i : Z) (H1 : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) + size_chunk chunk) (H3 : m_footprint P b2 i) : Mem.perm m1 b1 (i - delta) Cur Writable.","proofString":"apply V1.\nlia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (V1 : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk) Cur Writable) (V2 : (align_chunk chunk | Ptrofs.unsigned ofs1)) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (i : Z) (H1 : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) + size_chunk chunk) (H3 : m_footprint P b2 i) : Ptrofs.unsigned ofs1 <= i - delta < Ptrofs.unsigned ofs1 + size_chunk chunk.","proofString":"lia."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) : disjoint_footprint (minjection j m1') P.","proofString":"red; simpl; intros.\ndestruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (b : block) (ofs : Z) (H1 : exists (b0 : block) (delta0 : Z),\n  j b0 = Some (b, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H3 : m_footprint P b ofs) : False.","proofString":"destruct H1 as (b0 & delta0 & U & V).\neelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (U : j b0 = Some (b, delta0)) (V : Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H3 : m_footprint P b ofs) : False.","proofString":"eelim C; eauto.\nsimpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (U : j b0 = Some (b, delta0)) (V : Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H3 : m_footprint P b ofs) : m_footprint (minjection j m1) b ofs.","proofString":"simpl.\nexists b0, delta0; eauto with mem."},{"statement":"(j : meminj) (m1 m2 : mem) (P : massert) (chunk : memory_chunk) (v1 : val) (m1' : mem) (v2 : val) (A : Mem.inject j m1 m2) (B : m2 |= P) (C : disjoint_footprint (minjection j m1) P) (b1 : block) (ofs1 : ptrofs) (H0 : Mem.storev chunk m1 (Vptr b1 ofs1) v1 = Some m1') (H2 : Val.inject j v1 v2) (m2' : mem) (b2 : block) (delta : Z) (STORE : Mem.store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n  v2 = Some m2') (INJ : Mem.inject j m1' m2') (H : j b1 = Some (b2, delta)) (VALID : Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable) (EQ : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (U : j b0 = Some (b, delta0)) (V : Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H3 : m_footprint P b ofs) : exists (b3 : block) (delta1 : Z),\n  j b3 = Some (b, delta1) /\\ Mem.perm m1 b3 (ofs - delta1) Max Nonempty.","proofString":"exists b0, delta0; eauto with mem."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (SEP : m2 |= minjection j m1 ** P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) : exists j' : meminj,\n  m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j' m1' ** P /\\\n  inject_incr j j' /\\\n  j' b1 = Some (b2, delta) /\\ (forall b : block, b <> b1 -> j' b = j b).","proofString":"assert (RANGE4: lo <= hi) by extlia.\nassert (FRESH1: ~Mem.valid_block m1 b1) by (eapply Mem.fresh_block_alloc; eauto).\nassert (FRESH2: ~Mem.valid_block m2 b2) by (eapply Mem.fresh_block_alloc; eauto).\ndestruct SEP as (INJ & SP & DISJ).\nsimpl in INJ.\nexploit Mem.alloc_left_mapped_inject.\neapply Mem.alloc_right_inject; eauto.\neexact ALLOC1.\ninstantiate (1 := b2).\neauto with mem.\ninstantiate (1 := delta).\nextlia.\nintros.\nassert (0 <= ofs < sz2) by (eapply Mem.perm_alloc_3; eauto).\nlia.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nextlia.\nred; intros.\napply Z.divide_trans with 8; auto.\nexists (8 / align_chunk chunk).\ndestruct chunk; reflexivity.\nintros.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\nintros (j' & INJ' & J1 & J2 & J3).\nexists j'; split; auto.\nrewrite <- ! sep_assoc.\nsplit; [|split].\nsimpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (SEP : m2 |= minjection j m1 ** P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) : exists j' : meminj,\n  m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j' m1' ** P /\\\n  inject_incr j j' /\\\n  j' b1 = Some (b2, delta) /\\ (forall b : block, b <> b1 -> j' b = j b).","proofString":"assert (FRESH1: ~Mem.valid_block m1 b1) by (eapply Mem.fresh_block_alloc; eauto).\nassert (FRESH2: ~Mem.valid_block m2 b2) by (eapply Mem.fresh_block_alloc; eauto).\ndestruct SEP as (INJ & SP & DISJ).\nsimpl in INJ.\nexploit Mem.alloc_left_mapped_inject.\neapply Mem.alloc_right_inject; eauto.\neexact ALLOC1.\ninstantiate (1 := b2).\neauto with mem.\ninstantiate (1 := delta).\nextlia.\nintros.\nassert (0 <= ofs < sz2) by (eapply Mem.perm_alloc_3; eauto).\nlia.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nextlia.\nred; intros.\napply Z.divide_trans with 8; auto.\nexists (8 / align_chunk chunk).\ndestruct chunk; reflexivity.\nintros.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\nintros (j' & INJ' & J1 & J2 & J3).\nexists j'; split; auto.\nrewrite <- ! sep_assoc.\nsplit; [|split].\nsimpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (SEP : m2 |= minjection j m1 ** P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) : exists j' : meminj,\n  m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j' m1' ** P /\\\n  inject_incr j j' /\\\n  j' b1 = Some (b2, delta) /\\ (forall b : block, b <> b1 -> j' b = j b).","proofString":"assert (FRESH2: ~Mem.valid_block m2 b2) by (eapply Mem.fresh_block_alloc; eauto).\ndestruct SEP as (INJ & SP & DISJ).\nsimpl in INJ.\nexploit Mem.alloc_left_mapped_inject.\neapply Mem.alloc_right_inject; eauto.\neexact ALLOC1.\ninstantiate (1 := b2).\neauto with mem.\ninstantiate (1 := delta).\nextlia.\nintros.\nassert (0 <= ofs < sz2) by (eapply Mem.perm_alloc_3; eauto).\nlia.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nextlia.\nred; intros.\napply Z.divide_trans with 8; auto.\nexists (8 / align_chunk chunk).\ndestruct chunk; reflexivity.\nintros.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\nintros (j' & INJ' & J1 & J2 & J3).\nexists j'; split; auto.\nrewrite <- ! sep_assoc.\nsplit; [|split].\nsimpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (SEP : m2 |= minjection j m1 ** P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) : exists j' : meminj,\n  m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j' m1' ** P /\\\n  inject_incr j j' /\\\n  j' b1 = Some (b2, delta) /\\ (forall b : block, b <> b1 -> j' b = j b).","proofString":"destruct SEP as (INJ & SP & DISJ).\nsimpl in INJ.\nexploit Mem.alloc_left_mapped_inject.\neapply Mem.alloc_right_inject; eauto.\neexact ALLOC1.\ninstantiate (1 := b2).\neauto with mem.\ninstantiate (1 := delta).\nextlia.\nintros.\nassert (0 <= ofs < sz2) by (eapply Mem.perm_alloc_3; eauto).\nlia.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nextlia.\nred; intros.\napply Z.divide_trans with 8; auto.\nexists (8 / align_chunk chunk).\ndestruct chunk; reflexivity.\nintros.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\nintros (j' & INJ' & J1 & J2 & J3).\nexists j'; split; auto.\nrewrite <- ! sep_assoc.\nsplit; [|split].\nsimpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : m2 |= minjection j m1) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) : exists j' : meminj,\n  m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j' m1' ** P /\\\n  inject_incr j j' /\\\n  j' b1 = Some (b2, delta) /\\ (forall b : block, b <> b1 -> j' b = j b).","proofString":"simpl in INJ.\nexploit Mem.alloc_left_mapped_inject.\neapply Mem.alloc_right_inject; eauto.\neexact ALLOC1.\ninstantiate (1 := b2).\neauto with mem.\ninstantiate (1 := delta).\nextlia.\nintros.\nassert (0 <= ofs < sz2) by (eapply Mem.perm_alloc_3; eauto).\nlia.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nextlia.\nred; intros.\napply Z.divide_trans with 8; auto.\nexists (8 / align_chunk chunk).\ndestruct chunk; reflexivity.\nintros.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\nintros (j' & INJ' & J1 & J2 & J3).\nexists j'; split; auto.\nrewrite <- ! sep_assoc.\nsplit; [|split].\nsimpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) : exists j' : meminj,\n  m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j' m1' ** P /\\\n  inject_incr j j' /\\\n  j' b1 = Some (b2, delta) /\\ (forall b : block, b <> b1 -> j' b = j b).","proofString":"exploit Mem.alloc_left_mapped_inject.\neapply Mem.alloc_right_inject; eauto.\neexact ALLOC1.\ninstantiate (1 := b2).\neauto with mem.\ninstantiate (1 := delta).\nextlia.\nintros.\nassert (0 <= ofs < sz2) by (eapply Mem.perm_alloc_3; eauto).\nlia.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nextlia.\nred; intros.\napply Z.divide_trans with 8; auto.\nexists (8 / align_chunk chunk).\ndestruct chunk; reflexivity.\nintros.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\nintros (j' & INJ' & J1 & J2 & J3).\nexists j'; split; auto.\nrewrite <- ! sep_assoc.\nsplit; [|split].\nsimpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) : Mem.valid_block m2' b2.","proofString":"eauto with mem."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) : 0 <= delta <= Ptrofs.max_unsigned.","proofString":"extlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.perm m2' b2 ofs k p) : delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned.","proofString":"assert (0 <= ofs < sz2) by (eapply Mem.perm_alloc_3; eauto).\nlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.perm m2' b2 ofs k p) (H0 : 0 <= ofs < sz2) : delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (ofs : Z) (k : perm_kind) (p : permission) (H : 0 <= ofs < sz1) : Mem.perm m2' b2 (ofs + delta) k p.","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nextlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (ofs : Z) (k : perm_kind) (p : permission) (H : 0 <= ofs < sz1) : Mem.perm m2' b2 (ofs + delta) k Freeable.","proofString":"eapply Mem.perm_alloc_2; eauto.\nextlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (ofs : Z) (k : perm_kind) (p : permission) (H : 0 <= ofs < sz1) : 0 <= ofs + delta < sz2.","proofString":"extlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (chunk : memory_chunk) (H : size_chunk chunk <= sz1 - 0) : (align_chunk chunk | delta).","proofString":"apply Z.divide_trans with 8; auto.\nexists (8 / align_chunk chunk).\ndestruct chunk; reflexivity."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (chunk : memory_chunk) (H : size_chunk chunk <= sz1 - 0) : (align_chunk chunk | 8).","proofString":"exists (8 / align_chunk chunk).\ndestruct chunk; reflexivity."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (chunk : memory_chunk) (H : size_chunk chunk <= sz1 - 0) : 8 = 8 / align_chunk chunk * align_chunk chunk.","proofString":"destruct chunk; reflexivity."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H : j b = Some (b2, delta')) (H0 : Mem.perm m1 b ofs k p) (H1 : 0 + delta <= ofs + delta' < sz1 + delta) : False.","proofString":"elim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H : j b = Some (b2, delta')) (H0 : Mem.perm m1 b ofs k p) (H1 : 0 + delta <= ofs + delta' < sz1 + delta) : Mem.valid_block m2 b2.","proofString":"eapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) : exists j'0 : meminj,\n  m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j'0 m1' ** P /\\\n  inject_incr j j'0 /\\\n  j'0 b1 = Some (b2, delta) /\\ (forall b : block, b <> b1 -> j'0 b = j b).","proofString":"exists j'; split; auto.\nrewrite <- ! sep_assoc.\nsplit; [|split].\nsimpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) : m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j' m1' ** P.","proofString":"rewrite <- ! sep_assoc.\nsplit; [|split].\nsimpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) : m2' |= ((range b2 0 lo ** range b2 hi sz2) ** minjection j' m1') ** P.","proofString":"split; [|split].\nsimpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto.\nred; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) : m2' |= (range b2 0 lo ** range b2 hi sz2) ** minjection j' m1'.","proofString":"simpl.\nintuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) : ((0 <= 0 /\\\n  lo <= Ptrofs.modulus /\\\n  (forall (i : Z) (k : perm_kind) (p : permission),\n   0 <= i < lo -> Mem.perm m2' b2 i k p)) /\\\n (0 <= hi /\\\n  sz2 <= Ptrofs.modulus /\\\n  (forall (i : Z) (k : perm_kind) (p : permission),\n   hi <= i < sz2 -> Mem.perm m2' b2 i k p)) /\\\n disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) /\\\nMem.inject j' m1' m2' /\\\ndisjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j' m1').","proofString":"intuition auto; try (unfold Ptrofs.max_unsigned in *; lia).\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia.\nred; simpl; intros.\ndestruct H1, H2.\nlia.\nred; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (i : Z) (k : perm_kind) (p : permission) (H2 : 0 <= i) (H3 : i < lo) : Mem.perm m2' b2 i k p.","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (i : Z) (k : perm_kind) (p : permission) (H2 : 0 <= i) (H3 : i < lo) : Mem.perm m2' b2 i k Freeable.","proofString":"eapply Mem.perm_alloc_2; eauto.\nlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (i : Z) (k : perm_kind) (p : permission) (H2 : 0 <= i) (H3 : i < lo) : 0 <= i < sz2.","proofString":"lia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (i : Z) (k : perm_kind) (p : permission) (H2 : hi <= i) (H3 : i < sz2) : Mem.perm m2' b2 i k p.","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\nlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (i : Z) (k : perm_kind) (p : permission) (H2 : hi <= i) (H3 : i < sz2) : Mem.perm m2' b2 i k Freeable.","proofString":"eapply Mem.perm_alloc_2; eauto.\nlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (i : Z) (k : perm_kind) (p : permission) (H2 : hi <= i) (H3 : i < sz2) : 0 <= i < sz2.","proofString":"lia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) : disjoint_footprint (range b2 0 lo) (range b2 hi sz2).","proofString":"red; simpl; intros.\ndestruct H1, H2.\nlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, (b0 = b1 -> False) -> j' b0 = j b0) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (b : block) (ofs : Z) (H1 : b = b2 /\\ 0 <= ofs < lo) (H2 : b = b2 /\\ hi <= ofs < sz2) : False.","proofString":"destruct H1, H2.\nlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, (b0 = b1 -> False) -> j' b0 = j b0) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (b : block) (ofs : Z) (H1 : b = b2) (H3 : 0 <= ofs < lo) (H2 : b = b2) (H4 : hi <= ofs < sz2) : False.","proofString":"lia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j' m1').","proofString":"red; simpl; intros.\nassert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, (b0 = b1 -> False) -> j' b0 = j b0) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (b : block) (ofs : Z) (H1 : b = b2 /\\ 0 <= ofs < lo \\/ b = b2 /\\ hi <= ofs < sz2) (H2 : exists (b0 : block) (delta0 : Z),\n  j' b0 = Some (b, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) : False.","proofString":"assert (b = b2) by tauto.\nsubst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, (b0 = b1 -> False) -> j' b0 = j b0) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (b : block) (ofs : Z) (H1 : b = b2 /\\ 0 <= ofs < lo \\/ b = b2 /\\ hi <= ofs < sz2) (H2 : exists (b0 : block) (delta0 : Z),\n  j' b0 = Some (b, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H3 : b = b2) : False.","proofString":"subst b.\nassert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (H2 : exists (b0 : block) (delta0 : Z),\n  j' b0 = Some (b2, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H1 : b2 = b2 /\\ 0 <= ofs < lo \\/ b2 = b2 /\\ hi <= ofs < sz2) : False.","proofString":"assert (0 <= ofs < lo \\/ hi <= ofs < sz2) by tauto.\nclear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (H2 : exists (b0 : block) (delta0 : Z),\n  j' b0 = Some (b2, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H1 : b2 = b2 /\\ 0 <= ofs < lo \\/ b2 = b2 /\\ hi <= ofs < sz2) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) : False.","proofString":"clear H1.\ndestruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (H2 : exists (b0 : block) (delta0 : Z),\n  j' b0 = Some (b2, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) : False.","proofString":"destruct H2 as (b0 & delta0 & D & E).\neapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (b0 : block) (delta0 : Z) (D : j' b0 = Some (b2, delta0)) (E : Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) : False.","proofString":"eapply Mem.perm_alloc_inv in E; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (b0 : block) (delta0 : Z) (D : j' b0 = Some (b2, delta0)) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) (E : if eq_block b0 b1\nthen 0 <= ofs - delta0 < sz1\nelse Mem.perm m1 b0 (ofs - delta0) Max Nonempty) : False.","proofString":"destruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia.\nrewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (b0 : block) (delta0 : Z) (D : j' b0 = Some (b2, delta0)) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) (e : b0 = b1) (E : 0 <= ofs - delta0 < sz1) : False.","proofString":"subst b0.\nrewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs delta0 : Z) (D : j' b1 = Some (b2, delta0)) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) (E : 0 <= ofs - delta0 < sz1) : False.","proofString":"rewrite J2 in D.\ninversion D; clear D; subst delta0.\nextlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs delta0 : Z) (D : Some (b2, delta) = Some (b2, delta0)) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) (E : 0 <= ofs - delta0 < sz1) : False.","proofString":"inversion D; clear D; subst delta0.\nextlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) (E : 0 <= ofs - delta < sz1) : False.","proofString":"extlia."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (b0 : block) (delta0 : Z) (D : j' b0 = Some (b2, delta0)) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) (n : b0 <> b1) (E : Mem.perm m1 b0 (ofs - delta0) Max Nonempty) : False.","proofString":"rewrite J3 in D by auto.\nelim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (b0 : block) (delta0 : Z) (D : j b0 = Some (b2, delta0)) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) (n : b0 <> b1) (E : Mem.perm m1 b0 (ofs - delta0) Max Nonempty) : False.","proofString":"elim FRESH2.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : Mem.valid_block m1 b1 -> False) (FRESH2 : Mem.valid_block m2 b2 -> False) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, (b = b1 -> False) -> j' b = j b) (H : 0 <= sz2) (H0 : sz2 <= Ptrofs.max_unsigned) (ofs : Z) (b0 : block) (delta0 : Z) (D : j b0 = Some (b2, delta0)) (H3 : 0 <= ofs < lo \\/ hi <= ofs < sz2) (n : b0 <> b1) (E : Mem.perm m1 b0 (ofs - delta0) Max Nonempty) : Mem.valid_block m2 b2.","proofString":"eapply Mem.valid_block_inject_2; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) : m2' |= P.","proofString":"apply (m_invar P) with m2; auto.\neapply Mem.alloc_unchanged_on; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) : Mem.unchanged_on (m_footprint P) m2 m2'.","proofString":"eapply Mem.alloc_unchanged_on; eauto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j' m1')\n  P.","proofString":"red; simpl; intros.\nassert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, b0 <> b1 -> j' b0 = j b0) (b : block) (ofs : Z) (H : (b = b2 /\\ 0 <= ofs < lo \\/ b = b2 /\\ hi <= ofs < sz2) \\/\n(exists (b0 : block) (delta0 : Z),\n   j' b0 = Some (b, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty)) (H0 : m_footprint P b ofs) : False.","proofString":"assert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).\ndestruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, b0 <> b1 -> j' b0 = j b0) (b : block) (ofs : Z) (H : (b = b2 /\\ 0 <= ofs < lo \\/ b = b2 /\\ hi <= ofs < sz2) \\/\n(exists (b0 : block) (delta0 : Z),\n   j' b0 = Some (b, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty)) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) : False.","proofString":"destruct H as [A | (b0 & delta0 & A & B)].\nassert (b = b2) by tauto.\nsubst b.\ncontradiction.\neelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, b0 <> b1 -> j' b0 = j b0) (b : block) (ofs : Z) (A : b = b2 /\\ 0 <= ofs < lo \\/ b = b2 /\\ hi <= ofs < sz2) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) : False.","proofString":"assert (b = b2) by tauto.\nsubst b.\ncontradiction."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, b0 <> b1 -> j' b0 = j b0) (b : block) (ofs : Z) (A : b = b2 /\\ 0 <= ofs < lo \\/ b = b2 /\\ hi <= ofs < sz2) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) (H : b = b2) : False.","proofString":"subst b.\ncontradiction."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) (ofs : Z) (VALID : Mem.valid_block m2 b2) (H0 : m_footprint P b2 ofs) (A : b2 = b2 /\\ 0 <= ofs < lo \\/ b2 = b2 /\\ hi <= ofs < sz2) : False.","proofString":"contradiction."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b3 : block, b3 <> b1 -> j' b3 = j b3) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (A : j' b0 = Some (b, delta0)) (B : Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) : False.","proofString":"eelim DISJ; eauto.\nsimpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b3 : block, b3 <> b1 -> j' b3 = j b3) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (A : j' b0 = Some (b, delta0)) (B : Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) : m_footprint (minjection j m1) b ofs.","proofString":"simpl.\neapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b3 : block, b3 <> b1 -> j' b3 = j b3) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (A : j' b0 = Some (b, delta0)) (B : Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) : exists (b3 : block) (delta1 : Z),\n  j b3 = Some (b, delta1) /\\ Mem.perm m1 b3 (ofs - delta1) Max Nonempty.","proofString":"eapply Mem.perm_alloc_inv in B; eauto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b3 : block, b3 <> b1 -> j' b3 = j b3) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (A : j' b0 = Some (b, delta0)) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) (B : if eq_block b0 b1\nthen 0 <= ofs - delta0 < sz1\nelse Mem.perm m1 b0 (ofs - delta0) Max Nonempty) : exists (b3 : block) (delta1 : Z),\n  j b3 = Some (b, delta1) /\\ Mem.perm m1 b3 (ofs - delta1) Max Nonempty.","proofString":"destruct (eq_block b0 b1).\nsubst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction.\nrewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b3 : block, b3 <> b1 -> j' b3 = j b3) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (A : j' b0 = Some (b, delta0)) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) (e : b0 = b1) (B : 0 <= ofs - delta0 < sz1) : exists (b3 : block) (delta1 : Z),\n  j b3 = Some (b, delta1) /\\ Mem.perm m1 b3 (ofs - delta1) Max Nonempty.","proofString":"subst b0.\nrewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, b0 <> b1 -> j' b0 = j b0) (b : block) (ofs delta0 : Z) (A : j' b1 = Some (b, delta0)) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) (B : 0 <= ofs - delta0 < sz1) : exists (b0 : block) (delta1 : Z),\n  j b0 = Some (b, delta1) /\\ Mem.perm m1 b0 (ofs - delta1) Max Nonempty.","proofString":"rewrite J2 in A.\ninversion A; clear A; subst b delta0.\ncontradiction."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b0 : block, b0 <> b1 -> j' b0 = j b0) (b : block) (ofs delta0 : Z) (A : Some (b2, delta) = Some (b, delta0)) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) (B : 0 <= ofs - delta0 < sz1) : exists (b0 : block) (delta1 : Z),\n  j b0 = Some (b, delta1) /\\ Mem.perm m1 b0 (ofs - delta1) Max Nonempty.","proofString":"inversion A; clear A; subst b delta0.\ncontradiction."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b : block, b <> b1 -> j' b = j b) (ofs : Z) (VALID : Mem.valid_block m2 b2) (H0 : m_footprint P b2 ofs) (B : 0 <= ofs - delta < sz1) : exists (b0 : block) (delta0 : Z),\n  j b0 = Some (b2, delta0) /\\ Mem.perm m1 b0 (ofs - delta0) Max Nonempty.","proofString":"contradiction."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b3 : block, b3 <> b1 -> j' b3 = j b3) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (A : j' b0 = Some (b, delta0)) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) (n : b0 <> b1) (B : Mem.perm m1 b0 (ofs - delta0) Max Nonempty) : exists (b3 : block) (delta1 : Z),\n  j b3 = Some (b, delta1) /\\ Mem.perm m1 b3 (ofs - delta1) Max Nonempty.","proofString":"rewrite J3 in A by auto.\nexists b0, delta0; auto."},{"statement":"(m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (INJ : Mem.inject j m1 m2) (SP : m2 |= P) (DISJ : disjoint_footprint (minjection j m1) P) (ALLOC1 : Mem.alloc m1 0 sz1 = (m1', b1)) (ALLOC2 : Mem.alloc m2 0 sz2 = (m2', b2)) (ALIGN : (8 | delta)) (LO : lo = delta) (HI : hi = delta + Z.max 0 sz1) (RANGE1 : 0 <= sz2 <= Ptrofs.max_unsigned) (RANGE2 : 0 <= delta) (RANGE3 : hi <= sz2) (RANGE4 : lo <= hi) (FRESH1 : ~ Mem.valid_block m1 b1) (FRESH2 : ~ Mem.valid_block m2 b2) (j' : meminj) (INJ' : Mem.inject j' m1' m2') (J1 : inject_incr j j') (J2 : j' b1 = Some (b2, delta)) (J3 : forall b3 : block, b3 <> b1 -> j' b3 = j b3) (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (A : j b0 = Some (b, delta0)) (H0 : m_footprint P b ofs) (VALID : Mem.valid_block m2 b) (n : b0 <> b1) (B : Mem.perm m1 b0 (ofs - delta0) Max Nonempty) : exists (b3 : block) (delta1 : Z),\n  j b3 = Some (b, delta1) /\\ Mem.perm m1 b3 (ofs - delta1) Max Nonempty.","proofString":"exists b0, delta0; auto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (H : m2 |= range b2 0 lo ** range b2 hi sz2 ** minjection j m1 ** P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) : exists m2' : mem,\n  Mem.free m2 b2 0 sz2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"rewrite <- ! sep_assoc in H.\ndestruct H as (A & B & C).\ndestruct A as (D & E & F).\ndestruct D as (J & K & L).\ndestruct J as (_ & _ & J).\ndestruct K as (_ & _ & K).\nsimpl in E.\nassert (PERM: Mem.range_perm m2 b2 0 sz2 Cur Freeable).\nred; intros.\ndestruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia.\ndestruct (Mem.range_perm_free _ _ _ _ PERM) as [m2' FREE].\nexists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (H : m2 |= ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) ** P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) : exists m2' : mem,\n  Mem.free m2 b2 0 sz2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"destruct H as (A & B & C).\ndestruct A as (D & E & F).\ndestruct D as (J & K & L).\ndestruct J as (_ & _ & J).\ndestruct K as (_ & _ & K).\nsimpl in E.\nassert (PERM: Mem.range_perm m2 b2 0 sz2 Cur Freeable).\nred; intros.\ndestruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia.\ndestruct (Mem.range_perm_free _ _ _ _ PERM) as [m2' FREE].\nexists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (A : m2 |= (range b2 0 lo ** range b2 hi sz2) ** minjection j m1) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) : exists m2' : mem,\n  Mem.free m2 b2 0 sz2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"destruct A as (D & E & F).\ndestruct D as (J & K & L).\ndestruct J as (_ & _ & J).\ndestruct K as (_ & _ & K).\nsimpl in E.\nassert (PERM: Mem.range_perm m2 b2 0 sz2 Cur Freeable).\nred; intros.\ndestruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia.\ndestruct (Mem.range_perm_free _ _ _ _ PERM) as [m2' FREE].\nexists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (D : m2 |= range b2 0 lo ** range b2 hi sz2) (E : m2 |= minjection j m1) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) : exists m2' : mem,\n  Mem.free m2 b2 0 sz2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"destruct D as (J & K & L).\ndestruct J as (_ & _ & J).\ndestruct K as (_ & _ & K).\nsimpl in E.\nassert (PERM: Mem.range_perm m2 b2 0 sz2 Cur Freeable).\nred; intros.\ndestruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia.\ndestruct (Mem.range_perm_free _ _ _ _ PERM) as [m2' FREE].\nexists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : m2 |= range b2 0 lo) (K : m2 |= range b2 hi sz2) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : m2 |= minjection j m1) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) : exists m2' : mem,\n  Mem.free m2 b2 0 sz2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"destruct J as (_ & _ & J).\ndestruct K as (_ & _ & K).\nsimpl in E.\nassert (PERM: Mem.range_perm m2 b2 0 sz2 Cur Freeable).\nred; intros.\ndestruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia.\ndestruct (Mem.range_perm_free _ _ _ _ PERM) as [m2' FREE].\nexists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : m2 |= range b2 hi sz2) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : m2 |= minjection j m1) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) : exists m2' : mem,\n  Mem.free m2 b2 0 sz2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"destruct K as (_ & _ & K).\nsimpl in E.\nassert (PERM: Mem.range_perm m2 b2 0 sz2 Cur Freeable).\nred; intros.\ndestruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia.\ndestruct (Mem.range_perm_free _ _ _ _ PERM) as [m2' FREE].\nexists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : m2 |= minjection j m1) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) : exists m2' : mem,\n  Mem.free m2 b2 0 sz2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"simpl in E.\nassert (PERM: Mem.range_perm m2 b2 0 sz2 Cur Freeable).\nred; intros.\ndestruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia.\ndestruct (Mem.range_perm_free _ _ _ _ PERM) as [m2' FREE].\nexists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) : exists m2' : mem,\n  Mem.free m2 b2 0 sz2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"assert (PERM: Mem.range_perm m2 b2 0 sz2 Cur Freeable).\nred; intros.\ndestruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia.\ndestruct (Mem.range_perm_free _ _ _ _ PERM) as [m2' FREE].\nexists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) : Mem.range_perm m2 b2 0 sz2 Cur Freeable.","proofString":"red; intros.\ndestruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (ofs : Z) (H : 0 <= ofs < sz2) : Mem.perm m2 b2 ofs Cur Freeable.","proofString":"destruct (zlt ofs lo).\napply J; lia.\ndestruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (ofs : Z) (H : 0 <= ofs < sz2) (l : ofs < lo) : Mem.perm m2 b2 ofs Cur Freeable.","proofString":"apply J; lia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (ofs : Z) (H : 0 <= ofs < sz2) (g : ofs >= lo) : Mem.perm m2 b2 ofs Cur Freeable.","proofString":"destruct (zle hi ofs).\napply K; lia.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (ofs : Z) (H : 0 <= ofs < sz2) (g : ofs >= lo) (l : hi <= ofs) : Mem.perm m2 b2 ofs Cur Freeable.","proofString":"apply K; lia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (ofs : Z) (H : 0 <= ofs < sz2) (g : ofs >= lo) (g0 : hi > ofs) : Mem.perm m2 b2 ofs Cur Freeable.","proofString":"replace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (ofs : Z) (H : 0 <= ofs < sz2) (g : ofs >= lo) (g0 : hi > ofs) : Mem.perm m2 b2 (ofs - delta + delta) Cur Freeable.","proofString":"eapply Mem.perm_inject; eauto.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (ofs : Z) (H : 0 <= ofs < sz2) (g : ofs >= lo) (g0 : hi > ofs) : Mem.perm m1 b1 (ofs - delta) Cur Freeable.","proofString":"eapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (ofs : Z) (H : 0 <= ofs < sz2) (g : ofs >= lo) (g0 : hi > ofs) : 0 <= ofs - delta < sz1.","proofString":"extlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) : exists m2' : mem,\n  Mem.free m2 b2 0 sz2 = Some m2' /\\ m2' |= minjection j m1' ** P.","proofString":"destruct (Mem.range_perm_free _ _ _ _ PERM) as [m2' FREE].\nexists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : exists m2'0 : mem,\n  Mem.free m2 b2 0 sz2 = Some m2'0 /\\ m2'0 |= minjection j m1' ** P.","proofString":"exists m2'; split; auto.\nsplit; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : m2' |= minjection j m1' ** P.","proofString":"split; [|split].\nsimpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia.\nred; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : m2' |= minjection j m1'.","proofString":"simpl.\neapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : Mem.inject j m1' m2'.","proofString":"eapply Mem.free_right_inject; eauto.\neapply Mem.free_left_inject; eauto.\nintros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : Mem.inject j m1' m2.","proofString":"eapply Mem.free_left_inject; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : forall (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission),\nj b0 = Some (b2, delta0) ->\nMem.perm m1' b0 ofs k p -> 0 <= ofs + delta0 < sz2 -> False.","proofString":"intros.\napply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) : False.","proofString":"apply (F b2 (ofs + delta0)).\nsimpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia.\nsimpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) : m_footprint (range b2 0 lo ** range b2 hi sz2) b2 (ofs + delta0).","proofString":"simpl.\ndestruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"destruct (zlt (ofs + delta0) lo).\nintuition auto.\ndestruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) (l : ofs + delta0 < lo) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"intuition auto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) (g : ofs + delta0 >= lo) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"destruct (zle hi (ofs + delta0)).\nintuition auto.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) (g : ofs + delta0 >= lo) (l : hi <= ofs + delta0) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"intuition auto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) (g : ofs + delta0 >= lo) (g0 : hi > ofs + delta0) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"destruct (eq_block b0 b1).\nsubst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia.\nexploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) (g : ofs + delta0 >= lo) (g0 : hi > ofs + delta0) (e : b0 = b1) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"subst b0.\nrewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (delta0 ofs : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m1' b1 ofs k p) (H : j b1 = Some (b2, delta0)) (H5 : 0 <= ofs + delta0 < sz2) (g : ofs + delta0 >= lo) (g0 : hi > ofs + delta0) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"rewrite H1 in H; inversion H; clear H; subst delta0.\neelim (Mem.perm_free_2 m1); eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (ofs : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m1' b1 ofs k p) (g0 : hi > ofs + delta) (g : ofs + delta >= lo) (H5 : 0 <= ofs + delta < sz2) : b2 = b2 /\\ 0 <= ofs + delta < lo \\/ b2 = b2 /\\ hi <= ofs + delta < sz2.","proofString":"eelim (Mem.perm_free_2 m1); eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (ofs : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m1' b1 ofs k p) (g0 : hi > ofs + delta) (g : ofs + delta >= lo) (H5 : 0 <= ofs + delta < sz2) : 0 <= ofs < sz1.","proofString":"extlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) (g : ofs + delta0 >= lo) (g0 : hi > ofs + delta0) (n : b0 <> b1) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"exploit Mem.mi_no_overlap; eauto.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply (Mem.free_range_perm m1); eauto.\ninstantiate (1 := ofs + delta0 - delta).\nextlia.\nintros [X|X].\ncongruence.\nlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) (g : ofs + delta0 >= lo) (g0 : hi > ofs + delta0) (n : b0 <> b1) : 0 <= ofs + delta0 - delta < sz1.","proofString":"extlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) (g : ofs + delta0 >= lo) (g0 : hi > ofs + delta0) (n : b0 <> b1) (X : b2 <> b2) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"congruence."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) (g : ofs + delta0 >= lo) (g0 : hi > ofs + delta0) (n : b0 <> b1) (X : ofs + delta0 <> ofs + delta0 - delta + delta) : b2 = b2 /\\ 0 <= ofs + delta0 < lo \\/ b2 = b2 /\\ hi <= ofs + delta0 < sz2.","proofString":"lia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) : m_footprint (minjection j m1) b2 (ofs + delta0).","proofString":"simpl.\nexists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) : exists (b3 : block) (delta1 : Z),\n  j b3 = Some (b2, delta1) /\\\n  Mem.perm m1 b3 (ofs + delta0 - delta1) Max Nonempty.","proofString":"exists b0, delta0; split; auto.\nreplace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) : Mem.perm m1 b0 (ofs + delta0 - delta0) Max Nonempty.","proofString":"replace (ofs + delta0 - delta0) with ofs by lia.\napply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) : Mem.perm m1 b0 ofs Max Nonempty.","proofString":"apply Mem.perm_max with k.\napply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) : Mem.perm m1 b0 ofs k Nonempty.","proofString":"apply Mem.perm_implies with p; auto with mem.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k0 : perm_kind) (p0 : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k0 p0) (K : forall (i : Z) (k0 : perm_kind) (p0 : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k0 p0) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b0 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H : j b0 = Some (b2, delta0)) (H4 : Mem.perm m1' b0 ofs k p) (H5 : 0 <= ofs + delta0 < sz2) : Mem.perm m1 b0 ofs k p.","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : m2' |= P.","proofString":"apply (m_invar P) with m2; auto.\neapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : Mem.unchanged_on (m_footprint P) m2 m2'.","proofString":"eapply Mem.free_unchanged_on; eauto.\nintros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : forall i : Z, 0 <= i < sz2 -> ~ m_footprint P b2 i.","proofString":"intros; red; intros.\neelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) : False.","proofString":"eelim C; eauto.\nsimpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) : m_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) b2 i.","proofString":"simpl.\ndestruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) : (b2 = b2 /\\ 0 <= i < lo \\/ b2 = b2 /\\ hi <= i < sz2) \\/\n(exists (b0 : block) (delta0 : Z),\n   j b0 = Some (b2, delta0) /\\ Mem.perm m1 b0 (i - delta0) Max Nonempty).","proofString":"destruct (zlt i lo).\nintuition auto.\ndestruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) (l : i < lo) : (b2 = b2 /\\ 0 <= i < lo \\/ b2 = b2 /\\ hi <= i < sz2) \\/\n(exists (b0 : block) (delta0 : Z),\n   j b0 = Some (b2, delta0) /\\ Mem.perm m1 b0 (i - delta0) Max Nonempty).","proofString":"intuition auto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) (g : i >= lo) : (b2 = b2 /\\ 0 <= i < lo \\/ b2 = b2 /\\ hi <= i < sz2) \\/\n(exists (b0 : block) (delta0 : Z),\n   j b0 = Some (b2, delta0) /\\ Mem.perm m1 b0 (i - delta0) Max Nonempty).","proofString":"destruct (zle hi i).\nintuition auto.\nright; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) (g : i >= lo) (l : hi <= i) : (b2 = b2 /\\ 0 <= i < lo \\/ b2 = b2 /\\ hi <= i < sz2) \\/\n(exists (b0 : block) (delta0 : Z),\n   j b0 = Some (b2, delta0) /\\ Mem.perm m1 b0 (i - delta0) Max Nonempty).","proofString":"intuition auto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) (g : i >= lo) (g0 : hi > i) : (b2 = b2 /\\ 0 <= i < lo \\/ b2 = b2 /\\ hi <= i < sz2) \\/\n(exists (b0 : block) (delta0 : Z),\n   j b0 = Some (b2, delta0) /\\ Mem.perm m1 b0 (i - delta0) Max Nonempty).","proofString":"right; exists b1, delta; split; auto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) (g : i >= lo) (g0 : hi > i) : Mem.perm m1 b1 (i - delta) Max Nonempty.","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) (g : i >= lo) (g0 : hi > i) : Mem.perm m1 b1 (i - delta) Cur Nonempty.","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) (g : i >= lo) (g0 : hi > i) : Mem.perm m1 b1 (i - delta) Cur Freeable.","proofString":"eapply Mem.free_range_perm; eauto.\nextlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i0 : Z) (k : perm_kind) (p : permission),\n0 <= i0 < lo -> Mem.perm m2 b2 i0 k p) (K : forall (i0 : Z) (k : perm_kind) (p : permission),\nhi <= i0 < sz2 -> Mem.perm m2 b2 i0 k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (i : Z) (H : 0 <= i < sz2) (H4 : m_footprint P b2 i) (g : i >= lo) (g0 : hi > i) : 0 <= i - delta < sz1.","proofString":"extlia."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') : disjoint_footprint (minjection j m1') P.","proofString":"red; simpl; intros.\neelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b : block) (ofs : Z) (H : exists (b0 : block) (delta0 : Z),\n  j b0 = Some (b, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H4 : m_footprint P b ofs) : False.","proofString":"eelim C; eauto.\nsimpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b : block) (ofs : Z) (H : exists (b0 : block) (delta0 : Z),\n  j b0 = Some (b, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H4 : m_footprint P b ofs) : m_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) b ofs.","proofString":"simpl.\nright.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b : block) (ofs : Z) (H : exists (b0 : block) (delta0 : Z),\n  j b0 = Some (b, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H4 : m_footprint P b ofs) : (b = b2 /\\ 0 <= ofs < lo \\/ b = b2 /\\ hi <= ofs < sz2) \\/\n(exists (b0 : block) (delta0 : Z),\n   j b0 = Some (b, delta0) /\\ Mem.perm m1 b0 (ofs - delta0) Max Nonempty).","proofString":"right.\ndestruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b : block) (ofs : Z) (H : exists (b0 : block) (delta0 : Z),\n  j b0 = Some (b, delta0) /\\ Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H4 : m_footprint P b ofs) : exists (b0 : block) (delta0 : Z),\n  j b0 = Some (b, delta0) /\\ Mem.perm m1 b0 (ofs - delta0) Max Nonempty.","proofString":"destruct H as (b0 & delta0 & U & V).\nexists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (U : j b0 = Some (b, delta0)) (V : Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H4 : m_footprint P b ofs) : exists (b3 : block) (delta1 : Z),\n  j b3 = Some (b, delta1) /\\ Mem.perm m1 b3 (ofs - delta1) Max Nonempty.","proofString":"exists b0, delta0; split; auto.\neapply Mem.perm_free_3; eauto."},{"statement":"(j : meminj) (m1 : mem) (b1 : block) (sz1 : Z) (m1' m2 : mem) (b2 : block) (sz2 lo hi delta : Z) (P : massert) (J : forall (i : Z) (k : perm_kind) (p : permission),\n0 <= i < lo -> Mem.perm m2 b2 i k p) (K : forall (i : Z) (k : perm_kind) (p : permission),\nhi <= i < sz2 -> Mem.perm m2 b2 i k p) (L : disjoint_footprint (range b2 0 lo) (range b2 hi sz2)) (E : Mem.inject j m1 m2) (F : disjoint_footprint (range b2 0 lo ** range b2 hi sz2) (minjection j m1)) (B : m2 |= P) (C : disjoint_footprint ((range b2 0 lo ** range b2 hi sz2) ** minjection j m1) P) (H0 : Mem.free m1 b1 0 sz1 = Some m1') (H1 : j b1 = Some (b2, delta)) (H2 : lo = delta) (H3 : hi = delta + Z.max 0 sz1) (PERM : Mem.range_perm m2 b2 0 sz2 Cur Freeable) (m2' : mem) (FREE : Mem.free m2 b2 0 sz2 = Some m2') (b : block) (ofs : Z) (b0 : block) (delta0 : Z) (U : j b0 = Some (b, delta0)) (V : Mem.perm m1' b0 (ofs - delta0) Max Nonempty) (H4 : m_footprint P b ofs) : Mem.perm m1 b0 (ofs - delta0) Max Nonempty.","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (j : meminj) (m : mem) (H : m |= globalenv_inject ge j) : meminj_preserves_globals ge j.","proofString":"destruct H as (bound & A & B).\ndestruct B.\nsplit; [|split]; intros.\neauto.\neauto.\nsymmetry; eauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (j : meminj) (m : mem) (bound : positive) (A : Ple bound (Mem.nextblock m)) (B : globalenv_preserved ge j bound) : meminj_preserves_globals ge j.","proofString":"destruct B.\nsplit; [|split]; intros.\neauto.\neauto.\nsymmetry; eauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (j : meminj) (m : mem) (bound : positive) (A : Ple bound (Mem.nextblock m)) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> Plt b bound) : meminj_preserves_globals ge j.","proofString":"split; [|split]; intros.\neauto.\neauto.\nsymmetry; eauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (j : meminj) (m : mem) (bound : positive) (A : Ple bound (Mem.nextblock m)) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : F),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) : j b = Some (b, 0).","proofString":"eauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (j : meminj) (m : mem) (bound : positive) (A : Ple bound (Mem.nextblock m)) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : F),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv0 : globvar V),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 bound) (b : block) (gv : globvar V) (H : Genv.find_var_info ge b = Some gv) : j b = Some (b, 0).","proofString":"eauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (j : meminj) (m : mem) (bound : positive) (A : Ple bound (Mem.nextblock m)) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nj b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv0 : globvar V),\nGenv.find_var_info ge b = Some gv0 -> Plt b bound) (b1 b2 : block) (delta : Z) (gv : globvar V) (H : Genv.find_var_info ge b2 = Some gv) (H0 : j b1 = Some (b2, delta)) : b2 = b1.","proofString":"symmetry; eauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (H1 : m |= globalenv_inject ge j ** P) : m |= globalenv_inject ge j' ** P.","proofString":"destruct H1 as (A & B & C).\ndestruct A as (bound & D & E).\nsplit; [|split]; auto.\nexists bound; split; auto.\ninv E; constructor; intros.\neauto.\ndestruct (j b1) as [[b0 delta0]|] eqn:JB1.\nerewrite H in H1 by eauto.\ninv H1.\neauto.\nexploit H0; eauto.\nintros (X & Y).\nelim Y.\napply Pos.lt_le_trans with bound; auto.\neauto.\neauto.\neauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (A : m |= globalenv_inject ge j) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) : m |= globalenv_inject ge j' ** P.","proofString":"destruct A as (bound & D & E).\nsplit; [|split]; auto.\nexists bound; split; auto.\ninv E; constructor; intros.\neauto.\ndestruct (j b1) as [[b0 delta0]|] eqn:JB1.\nerewrite H in H1 by eauto.\ninv H1.\neauto.\nexploit H0; eauto.\nintros (X & Y).\nelim Y.\napply Pos.lt_le_trans with bound; auto.\neauto.\neauto.\neauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (E : globalenv_preserved ge j bound) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) : m |= globalenv_inject ge j' ** P.","proofString":"split; [|split]; auto.\nexists bound; split; auto.\ninv E; constructor; intros.\neauto.\ndestruct (j b1) as [[b0 delta0]|] eqn:JB1.\nerewrite H in H1 by eauto.\ninv H1.\neauto.\nexploit H0; eauto.\nintros (X & Y).\nelim Y.\napply Pos.lt_le_trans with bound; auto.\neauto.\neauto.\neauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (E : globalenv_preserved ge j bound) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) : m |= globalenv_inject ge j'.","proofString":"exists bound; split; auto.\ninv E; constructor; intros.\neauto.\ndestruct (j b1) as [[b0 delta0]|] eqn:JB1.\nerewrite H in H1 by eauto.\ninv H1.\neauto.\nexploit H0; eauto.\nintros (X & Y).\nelim Y.\napply Pos.lt_le_trans with bound; auto.\neauto.\neauto.\neauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (E : globalenv_preserved ge j bound) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) : globalenv_preserved ge j' bound.","proofString":"inv E; constructor; intros.\neauto.\ndestruct (j b1) as [[b0 delta0]|] eqn:JB1.\nerewrite H in H1 by eauto.\ninv H1.\neauto.\nexploit H0; eauto.\nintros (X & Y).\nelim Y.\napply Pos.lt_le_trans with bound; auto.\neauto.\neauto.\neauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : F),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : positive) (H1 : Plt b bound) : j' b = Some (b, 0).","proofString":"eauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nj b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b1 b2 : block) (delta : Z) (H1 : j' b1 = Some (b2, delta)) (H2 : Plt b2 bound) : b1 = b2.","proofString":"destruct (j b1) as [[b0 delta0]|] eqn:JB1.\nerewrite H in H1 by eauto.\ninv H1.\neauto.\nexploit H0; eauto.\nintros (X & Y).\nelim Y.\napply Pos.lt_le_trans with bound; auto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b3 b4 : block) (delta1 : Z),\nj b3 = Some (b4, delta1) -> Plt b4 bound -> b3 = b4) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b1 b2 : block) (delta : Z) (H1 : j' b1 = Some (b2, delta)) (H2 : Plt b2 bound) (b0 : block) (delta0 : Z) (JB1 : j b1 = Some (b0, delta0)) : b1 = b2.","proofString":"erewrite H in H1 by eauto.\ninv H1.\neauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b3 b4 : block) (delta1 : Z),\nj b3 = Some (b4, delta1) -> Plt b4 bound -> b3 = b4) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b1 b2 : block) (delta : Z) (H2 : Plt b2 bound) (b0 : block) (delta0 : Z) (JB1 : j b1 = Some (b0, delta0)) (H1 : Some (b0, delta0) = Some (b2, delta)) : b1 = b2.","proofString":"inv H1.\neauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nj b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b1 b2 : block) (delta : Z) (H2 : Plt b2 bound) (JB1 : j b1 = Some (b2, delta)) : b1 = b2.","proofString":"eauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nj b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b1 b2 : block) (delta : Z) (H1 : j' b1 = Some (b2, delta)) (H2 : Plt b2 bound) (JB1 : j b1 = None) : b1 = b2.","proofString":"exploit H0; eauto.\nintros (X & Y).\nelim Y.\napply Pos.lt_le_trans with bound; auto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nj b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b1 b2 : block) (delta : Z) (H1 : j' b1 = Some (b2, delta)) (H2 : Plt b2 bound) (JB1 : j b1 = None) : ~ Mem.valid_block m0 b1 /\\ ~ Mem.valid_block m b2 -> b1 = b2.","proofString":"intros (X & Y).\nelim Y.\napply Pos.lt_le_trans with bound; auto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nj b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b1 b2 : block) (delta : Z) (H1 : j' b1 = Some (b2, delta)) (H2 : Plt b2 bound) (JB1 : j b1 = None) (X : ~ Mem.valid_block m0 b1) (Y : ~ Mem.valid_block m b2) : b1 = b2.","proofString":"elim Y.\napply Pos.lt_le_trans with bound; auto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nj b0 = Some (b3, delta0) -> Plt b3 bound -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : F),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b1 b2 : block) (delta : Z) (H1 : j' b1 = Some (b2, delta)) (H2 : Plt b2 bound) (JB1 : j b1 = None) (X : ~ Mem.valid_block m0 b1) (Y : ~ Mem.valid_block m b2) : Mem.valid_block m b2.","proofString":"apply Pos.lt_le_trans with bound; auto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : F),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (id : ident) (b : block) (H1 : Genv.find_symbol ge id = Some b) : Plt b bound.","proofString":"eauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : F),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (fd : F) (H1 : Genv.find_funct_ptr ge b = Some fd) : Plt b bound.","proofString":"eauto."},{"statement":"(j : meminj) (m0 : mem) (F : Type) (V : Type) (ge : Genv.t F V) (m : mem) (j' : meminj) (P : massert) (H : inject_incr j j') (H0 : inject_separated j j' m0 m) (bound : positive) (D : Ple bound (Mem.nextblock m)) (B : m |= P) (C : disjoint_footprint (globalenv_inject ge j) P) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : F),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv0 : globvar V),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 bound) (b : block) (gv : globvar V) (H1 : Genv.find_var_info ge b = Some gv) : Plt b bound.","proofString":"eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (SEP : m2 |= minjection j m1 ** globalenv_inject ge j ** P) (ARGS : Val.inject_list j vargs1 vargs2) : exists (j' : meminj) (vres2 : val) (m2' : mem),\n  external_call ef ge vargs2 m2 t vres2 m2' /\\\n  Val.inject j' vres1 vres2 /\\\n  m2' |= minjection j' m1' ** globalenv_inject ge j' ** P /\\\n  inject_incr j j' /\\ inject_separated j j' m1 m2.","proofString":"destruct SEP as (A & B & C).\nsimpl in A.\nexploit external_call_mem_inject; eauto.\neapply globalenv_inject_preserves_globals.\neapply sep_pick1; eauto.\nintros (j' & vres2 & m2' & CALL' & RES & INJ' & UNCH1 & UNCH2 & INCR & ISEP).\nassert (MAXPERMS: forall b ofs p,            Mem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p).\nintros.\neapply external_call_max_perm; eauto.\nexists j', vres2, m2'; intuition auto.\nsplit; [|split].\nexact INJ'.\napply (m_invar _ m2).\napply globalenv_inject_incr with j m1; auto.\neapply Mem.unchanged_on_implies; eauto.\nintros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto.\nred; intros.\ndestruct H as (b0 & delta & J' & E).\ndestruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : m2 |= minjection j m1) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) : exists (j' : meminj) (vres2 : val) (m2' : mem),\n  external_call ef ge vargs2 m2 t vres2 m2' /\\\n  Val.inject j' vres1 vres2 /\\\n  m2' |= minjection j' m1' ** globalenv_inject ge j' ** P /\\\n  inject_incr j j' /\\ inject_separated j j' m1 m2.","proofString":"simpl in A.\nexploit external_call_mem_inject; eauto.\neapply globalenv_inject_preserves_globals.\neapply sep_pick1; eauto.\nintros (j' & vres2 & m2' & CALL' & RES & INJ' & UNCH1 & UNCH2 & INCR & ISEP).\nassert (MAXPERMS: forall b ofs p,            Mem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p).\nintros.\neapply external_call_max_perm; eauto.\nexists j', vres2, m2'; intuition auto.\nsplit; [|split].\nexact INJ'.\napply (m_invar _ m2).\napply globalenv_inject_incr with j m1; auto.\neapply Mem.unchanged_on_implies; eauto.\nintros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto.\nred; intros.\ndestruct H as (b0 & delta & J' & E).\ndestruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) : exists (j' : meminj) (vres2 : val) (m2' : mem),\n  external_call ef ge vargs2 m2 t vres2 m2' /\\\n  Val.inject j' vres1 vres2 /\\\n  m2' |= minjection j' m1' ** globalenv_inject ge j' ** P /\\\n  inject_incr j j' /\\ inject_separated j j' m1 m2.","proofString":"exploit external_call_mem_inject; eauto.\neapply globalenv_inject_preserves_globals.\neapply sep_pick1; eauto.\nintros (j' & vres2 & m2' & CALL' & RES & INJ' & UNCH1 & UNCH2 & INCR & ISEP).\nassert (MAXPERMS: forall b ofs p,            Mem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p).\nintros.\neapply external_call_max_perm; eauto.\nexists j', vres2, m2'; intuition auto.\nsplit; [|split].\nexact INJ'.\napply (m_invar _ m2).\napply globalenv_inject_incr with j m1; auto.\neapply Mem.unchanged_on_implies; eauto.\nintros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto.\nred; intros.\ndestruct H as (b0 & delta & J' & E).\ndestruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) : meminj_preserves_globals ge j.","proofString":"eapply globalenv_inject_preserves_globals.\neapply sep_pick1; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) : (exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge vargs2 m2 t vres' m2' /\\\n   Val.inject f' vres1 vres' /\\\n   Mem.inject f' m1' m2' /\\\n   Mem.unchanged_on (loc_unmapped j) m1 m1' /\\\n   Mem.unchanged_on (loc_out_of_reach j m1) m2 m2' /\\\n   inject_incr j f' /\\ inject_separated j f' m1 m2) ->\nexists (j' : meminj) (vres2 : val) (m2' : mem),\n  external_call ef ge vargs2 m2 t vres2 m2' /\\\n  Val.inject j' vres1 vres2 /\\\n  m2' |= minjection j' m1' ** globalenv_inject ge j' ** P /\\\n  inject_incr j j' /\\ inject_separated j j' m1 m2.","proofString":"intros (j' & vres2 & m2' & CALL' & RES & INJ' & UNCH1 & UNCH2 & INCR & ISEP).\nassert (MAXPERMS: forall b ofs p,            Mem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p).\nintros.\neapply external_call_max_perm; eauto.\nexists j', vres2, m2'; intuition auto.\nsplit; [|split].\nexact INJ'.\napply (m_invar _ m2).\napply globalenv_inject_incr with j m1; auto.\neapply Mem.unchanged_on_implies; eauto.\nintros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto.\nred; intros.\ndestruct H as (b0 & delta & J' & E).\ndestruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) : exists (j'0 : meminj) (vres0 : val) (m2'0 : mem),\n  external_call ef ge vargs2 m2 t vres0 m2'0 /\\\n  Val.inject j'0 vres1 vres0 /\\\n  m2'0 |= minjection j'0 m1' ** globalenv_inject ge j'0 ** P /\\\n  inject_incr j j'0 /\\ inject_separated j j'0 m1 m2.","proofString":"assert (MAXPERMS: forall b ofs p,            Mem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p).\nintros.\neapply external_call_max_perm; eauto.\nexists j', vres2, m2'; intuition auto.\nsplit; [|split].\nexact INJ'.\napply (m_invar _ m2).\napply globalenv_inject_incr with j m1; auto.\neapply Mem.unchanged_on_implies; eauto.\nintros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto.\nred; intros.\ndestruct H as (b0 & delta & J' & E).\ndestruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p.","proofString":"intros.\neapply external_call_max_perm; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (b : block) (ofs : Z) (p : permission) (H : Mem.valid_block m1 b) (H0 : Mem.perm m1' b ofs Max p) : Mem.perm m1 b ofs Max p.","proofString":"eapply external_call_max_perm; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p) : exists (j'0 : meminj) (vres0 : val) (m2'0 : mem),\n  external_call ef ge vargs2 m2 t vres0 m2'0 /\\\n  Val.inject j'0 vres1 vres0 /\\\n  m2'0 |= minjection j'0 m1' ** globalenv_inject ge j'0 ** P /\\\n  inject_incr j j'0 /\\ inject_separated j j'0 m1 m2.","proofString":"exists j', vres2, m2'; intuition auto.\nsplit; [|split].\nexact INJ'.\napply (m_invar _ m2).\napply globalenv_inject_incr with j m1; auto.\neapply Mem.unchanged_on_implies; eauto.\nintros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto.\nred; intros.\ndestruct H as (b0 & delta & J' & E).\ndestruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p) : m2' |= minjection j' m1' ** globalenv_inject ge j' ** P.","proofString":"split; [|split].\nexact INJ'.\napply (m_invar _ m2).\napply globalenv_inject_incr with j m1; auto.\neapply Mem.unchanged_on_implies; eauto.\nintros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto.\nred; intros.\ndestruct H as (b0 & delta & J' & E).\ndestruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p) : m2' |= minjection j' m1'.","proofString":"exact INJ'."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p) : m2' |= globalenv_inject ge j' ** P.","proofString":"apply (m_invar _ m2).\napply globalenv_inject_incr with j m1; auto.\neapply Mem.unchanged_on_implies; eauto.\nintros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p) : m2 |= globalenv_inject ge j' ** P.","proofString":"apply globalenv_inject_incr with j m1; auto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p) : Mem.unchanged_on (m_footprint (globalenv_inject ge j' ** P)) m2 m2'.","proofString":"eapply Mem.unchanged_on_implies; eauto.\nintros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p) : forall (b : block) (ofs : Z),\nm_footprint (globalenv_inject ge j' ** P) b ofs ->\nMem.valid_block m2 b -> loc_out_of_reach j m1 b ofs.","proofString":"intros; red; intros; red; intros.\neelim C; eauto.\nsimpl.\nexists b0, delta; auto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (H : m_footprint (globalenv_inject ge j' ** P) b ofs) (H0 : Mem.valid_block m2 b) (b0 : block) (delta : Z) (H1 : j b0 = Some (b, delta)) (H2 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) : False.","proofString":"eelim C; eauto.\nsimpl.\nexists b0, delta; auto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (H : m_footprint (globalenv_inject ge j' ** P) b ofs) (H0 : Mem.valid_block m2 b) (b0 : block) (delta : Z) (H1 : j b0 = Some (b, delta)) (H2 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) : m_footprint (minjection j m1) b ofs.","proofString":"simpl.\nexists b0, delta; auto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (H : m_footprint (globalenv_inject ge j' ** P) b ofs) (H0 : Mem.valid_block m2 b) (b0 : block) (delta : Z) (H1 : j b0 = Some (b, delta)) (H2 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) : exists (b1 : block) (delta0 : Z),\n  j b1 = Some (b, delta0) /\\ Mem.perm m1 b1 (ofs - delta0) Max Nonempty.","proofString":"exists b0, delta; auto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p) : disjoint_footprint (minjection j' m1') (globalenv_inject ge j' ** P).","proofString":"red; intros.\ndestruct H as (b0 & delta & J' & E).\ndestruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m1' b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (b : block) (ofs : Z) (H : m_footprint (minjection j' m1') b ofs) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) : False.","proofString":"destruct H as (b0 & delta & J' & E).\ndestruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (J' : j' b0 = Some (b, delta)) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) : False.","proofString":"destruct (j b0) as [[b' delta'] | ] eqn:J.\nerewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto.\nexploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (J' : j' b0 = Some (b, delta)) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (b' : block) (delta' : Z) (J : j b0 = Some (b', delta')) : False.","proofString":"erewrite INCR in J' by eauto.\ninv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (b' : block) (delta' : Z) (J : j b0 = Some (b', delta')) (J' : Some (b', delta') = Some (b, delta)) : False.","proofString":"inv J'.\neelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (J : j b0 = Some (b, delta)) : False.","proofString":"eelim C; eauto.\nsimpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (J : j b0 = Some (b, delta)) : m_footprint (minjection j m1) b ofs.","proofString":"simpl.\nexists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (J : j b0 = Some (b, delta)) : exists (b1 : block) (delta0 : Z),\n  j b1 = Some (b, delta0) /\\ Mem.perm m1 b1 (ofs - delta0) Max Nonempty.","proofString":"exists b0, delta; split; auto.\napply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (J : j b0 = Some (b, delta)) : Mem.perm m1 b0 (ofs - delta) Max Nonempty.","proofString":"apply MAXPERMS; auto.\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (J : j b0 = Some (b, delta)) : Mem.valid_block m1 b0.","proofString":"eapply Mem.valid_block_inject_1; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (J' : j' b0 = Some (b, delta)) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (J : j b0 = None) : False.","proofString":"exploit ISEP; eauto.\nintros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (J' : j' b0 = Some (b, delta)) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (J : j b0 = None) : ~ Mem.valid_block m1 b0 /\\ ~ Mem.valid_block m2 b -> False.","proofString":"intros (X & Y).\nelim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (J' : j' b0 = Some (b, delta)) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (J : j b0 = None) (X : ~ Mem.valid_block m1 b0) (Y : ~ Mem.valid_block m2 b) : False.","proofString":"elim Y.\neapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ef : external_function) (ge : Genv.t F V) (vargs1 : list val) (m1 : mem) (t : trace) (vres1 : val) (m1' m2 : mem) (j : meminj) (P : massert) (vargs2 : list val) (CALL : external_call ef ge vargs1 m1 t vres1 m1') (A : Mem.inject j m1 m2) (B : m2 |= globalenv_inject ge j ** P) (C : disjoint_footprint (minjection j m1) (globalenv_inject ge j ** P)) (ARGS : Val.inject_list j vargs1 vargs2) (j' : meminj) (vres2 : val) (m2' : mem) (CALL' : external_call ef ge vargs2 m2 t vres2 m2') (RES : Val.inject j' vres1 vres2) (INJ' : Mem.inject j' m1' m2') (UNCH1 : Mem.unchanged_on (loc_unmapped j) m1 m1') (UNCH2 : Mem.unchanged_on (loc_out_of_reach j m1) m2 m2') (INCR : inject_incr j j') (ISEP : inject_separated j j' m1 m2) (MAXPERMS : forall (b1 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b1 ->\nMem.perm m1' b1 ofs0 Max p -> Mem.perm m1 b1 ofs0 Max p) (b : block) (ofs : Z) (b0 : block) (delta : Z) (J' : j' b0 = Some (b, delta)) (E : Mem.perm m1' b0 (ofs - delta) Max Nonempty) (H0 : m_footprint (globalenv_inject ge j' ** P) b ofs) (J : j b0 = None) (X : ~ Mem.valid_block m1 b0) (Y : ~ Mem.valid_block m2 b) : Mem.valid_block m2 b.","proofString":"eapply m_valid; eauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (H : m2 |= minjection j m1 ** globalenv_inject ge j ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) : exists j' : meminj,\n  m2'\n  |= range b2 0 lo **\n     range b2 hi sz2 ** minjection j' m1' ** globalenv_inject ge j' ** P /\\\n  inject_incr j j' /\\ j' b1 = Some (b2, delta).","proofString":"set (j1 := fun b => if eq_block b b1 then Some(b2, delta) else j b).\nassert (X: inject_incr j j1).\nunfold j1; red; intros.\ndestruct (eq_block b b1); auto.\nsubst b.\neelim Mem.fresh_block_alloc.\neexact H0.\neapply Mem.valid_block_inject_1.\neauto.\napply sep_proj1 in H.\neexact H.\nassert (Y: inject_separated j j1 m1 m2).\nunfold j1; red; intros.\ndestruct (eq_block b0 b1).\ninversion H9; clear H9; subst b3 delta0 b0.\nsplit; eapply Mem.fresh_block_alloc; eauto.\ncongruence.\nrewrite sep_swap in H.\neapply globalenv_inject_incr with (j' := j1) in H; eauto.\nrewrite sep_swap in H.\nclear X Y.\nexploit alloc_parallel_rule; eauto.\nintros (j' & A & B & C & D).\nexists j'; split; auto.\nrewrite sep_swap4 in A.\nrewrite sep_swap4.\napply globalenv_inject_incr with j1 m1; auto.\nred; unfold j1; intros.\ndestruct (eq_block b b1).\ncongruence.\nrewrite D; auto.\nred; unfold j1; intros.\ndestruct (eq_block b0 b1).\ncongruence.\nrewrite D in H9 by auto.\ncongruence."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (H : m2 |= minjection j m1 ** globalenv_inject ge j ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j1 : positive -> option (block * Z)) (b b' : block) (delta0 : Z) (H8 : j b = Some (b', delta0)) : (if eq_block b b1 then Some (b2, delta) else j b) = Some (b', delta0).","proofString":"destruct (eq_block b b1); auto.\nsubst b.\neelim Mem.fresh_block_alloc.\neexact H0.\neapply Mem.valid_block_inject_1.\neauto.\napply sep_proj1 in H.\neexact H."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (H : m2 |= minjection j m1 ** globalenv_inject ge j ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j1 : positive -> option (block * Z)) (b b' : block) (delta0 : Z) (H8 : j b = Some (b', delta0)) (e : b = b1) : Some (b2, delta) = Some (b', delta0).","proofString":"subst b.\neelim Mem.fresh_block_alloc.\neexact H0.\neapply Mem.valid_block_inject_1.\neauto.\napply sep_proj1 in H.\neexact H."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (H : m2 |= minjection j m1 ** globalenv_inject ge j ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j1 : positive -> option (block * Z)) (b' : block) (delta0 : Z) (H8 : j b1 = Some (b', delta0)) : Some (b2, delta) = Some (b', delta0).","proofString":"eelim Mem.fresh_block_alloc.\neexact H0.\neapply Mem.valid_block_inject_1.\neauto.\napply sep_proj1 in H.\neexact H."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (H : m2 |= minjection j m1 ** globalenv_inject ge j ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j1 : positive -> option (block * Z)) (X : inject_incr j j1) (b0 b3 : block) (delta0 : Z) (H8 : j b0 = None) (H9 : (if eq_block b0 b1 then Some (b2, delta) else j b0) = Some (b3, delta0)) : ~ Mem.valid_block m1 b0 /\\ ~ Mem.valid_block m2 b3.","proofString":"destruct (eq_block b0 b1).\ninversion H9; clear H9; subst b3 delta0 b0.\nsplit; eapply Mem.fresh_block_alloc; eauto.\ncongruence."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (H : m2 |= minjection j m1 ** globalenv_inject ge j ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j1 : positive -> option (block * Z)) (X : inject_incr j j1) (b0 b3 : block) (delta0 : Z) (H8 : j b0 = None) (e : b0 = b1) (H9 : Some (b2, delta) = Some (b3, delta0)) : ~ Mem.valid_block m1 b0 /\\ ~ Mem.valid_block m2 b3.","proofString":"inversion H9; clear H9; subst b3 delta0 b0.\nsplit; eapply Mem.fresh_block_alloc; eauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (H : m2 |= minjection j m1 ** globalenv_inject ge j ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j1 : positive -> option (block * Z)) (X : inject_incr j j1) (H8 : j b1 = None) : ~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m2 b2.","proofString":"split; eapply Mem.fresh_block_alloc; eauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (H : m2 |= minjection j m1 ** globalenv_inject ge j ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j1 : positive -> option (block * Z)) (X : inject_incr j j1) (b0 b3 : block) (delta0 : Z) (H8 : j b0 = None) (n : b0 <> b1) (H9 : j b0 = Some (b3, delta0)) : ~ Mem.valid_block m1 b0 /\\ ~ Mem.valid_block m2 b3.","proofString":"congruence."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (j1 : positive -> option (block * Z)) (H : m2 |= minjection j m1 ** globalenv_inject ge j1 ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j' : meminj) (A : m2'\n|= globalenv_inject ge j1 **\n   range b2 hi sz2 ** minjection j' m1' ** range b2 0 lo ** P) (B : inject_incr j j') (C : j' b1 = Some (b2, delta)) (D : forall b0 : block, b0 <> b1 -> j' b0 = j b0) (b b' : block) (delta0 : Z) (H8 : (if eq_block b b1 then Some (b2, delta) else j b) = Some (b', delta0)) : j' b = Some (b', delta0).","proofString":"destruct (eq_block b b1).\ncongruence.\nrewrite D; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (j1 : positive -> option (block * Z)) (H : m2 |= minjection j m1 ** globalenv_inject ge j1 ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j' : meminj) (A : m2'\n|= globalenv_inject ge j1 **\n   range b2 hi sz2 ** minjection j' m1' ** range b2 0 lo ** P) (B : inject_incr j j') (C : j' b1 = Some (b2, delta)) (D : forall b0 : block, b0 <> b1 -> j' b0 = j b0) (b b' : block) (delta0 : Z) (e : b = b1) (H8 : Some (b2, delta) = Some (b', delta0)) : j' b = Some (b', delta0).","proofString":"congruence."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (j1 : positive -> option (block * Z)) (H : m2 |= minjection j m1 ** globalenv_inject ge j1 ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j' : meminj) (A : m2'\n|= globalenv_inject ge j1 **\n   range b2 hi sz2 ** minjection j' m1' ** range b2 0 lo ** P) (B : inject_incr j j') (C : j' b1 = Some (b2, delta)) (D : forall b0 : block, b0 <> b1 -> j' b0 = j b0) (b b' : block) (delta0 : Z) (n : b <> b1) (H8 : j b = Some (b', delta0)) : j' b = Some (b', delta0).","proofString":"rewrite D; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (j1 : positive -> option (block * Z)) (H : m2 |= minjection j m1 ** globalenv_inject ge j1 ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j' : meminj) (A : m2'\n|= globalenv_inject ge j1 **\n   range b2 hi sz2 ** minjection j' m1' ** range b2 0 lo ** P) (B : inject_incr j j') (C : j' b1 = Some (b2, delta)) (D : forall b : block, b <> b1 -> j' b = j b) (b0 b3 : block) (delta0 : Z) (H8 : (if eq_block b0 b1 then Some (b2, delta) else j b0) = None) (H9 : j' b0 = Some (b3, delta0)) : ~ Mem.valid_block m1 b0 /\\ ~ Mem.valid_block m2' b3.","proofString":"destruct (eq_block b0 b1).\ncongruence.\nrewrite D in H9 by auto.\ncongruence."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (j1 : positive -> option (block * Z)) (H : m2 |= minjection j m1 ** globalenv_inject ge j1 ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j' : meminj) (A : m2'\n|= globalenv_inject ge j1 **\n   range b2 hi sz2 ** minjection j' m1' ** range b2 0 lo ** P) (B : inject_incr j j') (C : j' b1 = Some (b2, delta)) (D : forall b : block, b <> b1 -> j' b = j b) (b0 b3 : block) (delta0 : Z) (e : b0 = b1) (H8 : Some (b2, delta) = None) (H9 : j' b0 = Some (b3, delta0)) : ~ Mem.valid_block m1 b0 /\\ ~ Mem.valid_block m2' b3.","proofString":"congruence."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (j1 : positive -> option (block * Z)) (H : m2 |= minjection j m1 ** globalenv_inject ge j1 ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j' : meminj) (A : m2'\n|= globalenv_inject ge j1 **\n   range b2 hi sz2 ** minjection j' m1' ** range b2 0 lo ** P) (B : inject_incr j j') (C : j' b1 = Some (b2, delta)) (D : forall b : block, b <> b1 -> j' b = j b) (b0 b3 : block) (delta0 : Z) (n : b0 <> b1) (H8 : j b0 = None) (H9 : j' b0 = Some (b3, delta0)) : ~ Mem.valid_block m1 b0 /\\ ~ Mem.valid_block m2' b3.","proofString":"rewrite D in H9 by auto.\ncongruence."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (m1 : mem) (sz1 : Z) (m1' : Mem.mem') (b1 : block) (m2 : mem) (sz2 : Z) (m2' : Mem.mem') (b2 : block) (P : massert) (j : meminj) (lo hi delta : Z) (j1 : positive -> option (block * Z)) (H : m2 |= minjection j m1 ** globalenv_inject ge j1 ** P) (H0 : Mem.alloc m1 0 sz1 = (m1', b1)) (H1 : Mem.alloc m2 0 sz2 = (m2', b2)) (H2 : (8 | delta)) (H3 : lo = delta) (H4 : hi = delta + Z.max 0 sz1) (H5 : 0 <= sz2 <= Ptrofs.max_unsigned) (H6 : 0 <= delta) (H7 : hi <= sz2) (j' : meminj) (A : m2'\n|= globalenv_inject ge j1 **\n   range b2 hi sz2 ** minjection j' m1' ** range b2 0 lo ** P) (B : inject_incr j j') (C : j' b1 = Some (b2, delta)) (D : forall b : block, b <> b1 -> j' b = j b) (b0 b3 : block) (delta0 : Z) (n : b0 <> b1) (H8 : j b0 = None) (H9 : j b0 = Some (b3, delta0)) : ~ Mem.valid_block m1 b0 /\\ ~ Mem.valid_block m2' b3.","proofString":"congruence."}]}