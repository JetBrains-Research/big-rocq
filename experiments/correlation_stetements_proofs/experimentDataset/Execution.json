[{"statement":"Lemma sb_trans : transitive sb.","proof":"unfold sb; unfolder; ins; desf; splits; auto.\neby eapply ext_sb_trans.\n"},{"statement":"Lemma sb_sb : sb ⨾ sb ⊆ sb.","proof":"generalize sb_trans; basic_solver 21.\n"},{"statement":"Lemma sb_same_loc_trans: transitive (sb ∩ same_loc).","proof":"apply transitiveI.\nunfold Events.same_loc.\nunfolder; ins; desf; eauto.\nsplits.\ngeneralize sb_trans; basic_solver 21.\ncongruence.\n"},{"statement":"Lemma sb_same_loc_W_trans : transitive (sb ∩ same_loc ⨾ ⦗W⦘).","proof":"generalize sb_same_loc_trans; unfold transitive.\nbasic_solver 21.\n"},{"statement":"Lemma E_in_RW_F_AcqRel (FACQREL : E ∩₁ F ⊆₁ Acq/Rel) :\n  E ⊆₁ R ∪₁ W ∪₁ F ∩₁  Acq/Rel.","proof":"arewrite (E ⊆₁ E ∩₁ E).\narewrite (E ⊆₁ R ∪₁ W ∪₁ F) at 2 by type_solver.\nrewrite set_inter_union_r.\ngeneralize FACQREL.\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma sb_neq_loc_in_sb : sb \\ same_loc ⊆ sb.","proof":"basic_solver.\n"},{"statement":"Lemma fr_co WF : fr ⨾ co ⊆ fr.","proof":"by unfold fr; rewrite seqA, rewrite_trans; [|apply WF].\n"},{"statement":"Lemma rmw_in_sb WF: rmw ⊆ sb.","proof":"rewrite wf_rmwi; basic_solver.\n"},{"statement":"Lemma deps_in_sb WF: deps ⊆ sb.","proof":"unfold deps; unionL; apply WF.\n"},{"statement":"Lemma loceq_rf WF : funeq loc rf.","proof":"apply WF.\n"},{"statement":"Lemma loceq_co WF : funeq loc co.","proof":"apply WF.\n"},{"statement":"Lemma loceq_rmw WF : funeq loc rmw.","proof":"apply WF.\n"},{"statement":"Lemma loceq_fr WF : funeq loc fr.","proof":"unfold funeq.\nunfold fr; unfolder; ins; desf.\ngeneralize (loceq_co WF), (loceq_rf WF).\ntransitivity (loc z); [symmetry; eauto|eauto].\n"},{"statement":"Lemma wf_frl WF : fr ⊆ same_loc.","proof":"unfold fr.\nrewrite (wf_rfl WF), (wf_col WF).\nunfold Events.same_loc.\nunfolder; ins; desc; congruence.\n"},{"statement":"Lemma wf_sbE : sb ≡ ⦗E⦘ ⨾ sb ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold sb; basic_solver 42.\n"},{"statement":"Lemma wf_dataE WF: data ≡ ⦗E⦘ ⨾ data ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\narewrite (data ⊆ data ∩ data) at 1.\nrewrite (data_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver.\n"},{"statement":"Lemma wf_addrE WF: addr ≡ ⦗E⦘ ⨾ addr ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\narewrite (addr ⊆ addr ∩ addr) at 1.\nrewrite (addr_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver.\n"},{"statement":"Lemma wf_ctrlE WF: ctrl ≡ ⦗E⦘ ⨾ ctrl ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\narewrite (ctrl ⊆ ctrl ∩ ctrl) at 1.\nrewrite (ctrl_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver.\n"},{"statement":"Lemma wf_rmw_depE WF: rmw_dep ≡ ⦗E⦘ ⨾ rmw_dep ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\narewrite (rmw_dep ⊆ rmw_dep ∩ rmw_dep) at 1.\nrewrite (rmw_dep_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver.\n"},{"statement":"Lemma wf_depsE WF: deps ≡ ⦗E⦘ ⨾ deps ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold deps.\nrewrite (wf_dataE WF) at 1.\nrewrite (wf_ctrlE WF) at 1.\nrewrite (wf_addrE WF) at 1.\nbasic_solver.\n"},{"statement":"Lemma wf_rmwE WF : rmw ≡ ⦗E⦘ ⨾ rmw ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\narewrite (rmw ⊆ rmw ∩ rmw) at 1.\nrewrite (wf_rmwi WF) at 1.\narewrite (immediate sb ⊆ sb).\nrewrite wf_sbE.\nbasic_solver.\n"},{"statement":"Lemma wf_frE WF : fr ≡ ⦗E⦘ ⨾ fr ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold fr.\nrewrite (wf_rfE WF) at 1.\nrewrite (wf_coE WF) at 1.\nbasic_solver.\n"},{"statement":"Lemma wf_frD WF : fr ≡ ⦗R⦘ ⨾ fr ⨾ ⦗W⦘.","proof":"split; [|basic_solver].\nunfold fr.\nrewrite (wf_rfD WF) at 1.\nrewrite (wf_coD WF) at 1.\nbasic_solver.\n"},{"statement":"Lemma wf_depsD WF : deps ≡ ⦗R⦘ ⨾ deps.","proof":"split; [|basic_solver].\nunfold deps.\nrewrite (wf_dataD WF) at 1.\nrewrite (wf_ctrlD WF) at 1.\nrewrite (wf_addrD WF) at 1.\nbasic_solver.\n"},{"statement":"Lemma sb_irr : irreflexive sb.","proof":"unfold sb; unfolder; ins; desf.\neby eapply ext_sb_irr.\n"},{"statement":"Lemma fr_irr WF : irreflexive fr.","proof":"rewrite (wf_frD WF); type_solver.\n"},{"statement":"Lemma sb_acyclic : acyclic sb.","proof":"apply trans_irr_acyclic; [apply sb_irr| apply sb_trans].\n"},{"statement":"Lemma co_acyclic WF: acyclic co.","proof":"by apply trans_irr_acyclic; [apply co_irr| apply co_trans].\n"},{"statement":"Lemma wf_sb : well_founded sb.","proof":"unfold Execution.sb.\nrewrite <- restr_relE.\neapply wf_mon; [by apply inclusion_restr| ].\napply Wf_nat.well_founded_lt_compat    with (f := fun (e: actid) => if e then 0 else index e + 1).\nintros x y SB.\ndestruct x, y; simpl in *; lia.\n"},{"statement":"Lemma init_w WF: is_init ⊆₁ W.","proof":"unfolder; ins.\nunfold is_init in *; destruct x; desf.\nspecialize (wf_init_lab WF l); unfold is_w; desf.\n"},{"statement":"Lemma init_pln WF: is_init ⊆₁ Pln.","proof":"unfolder; ins.\nunfold is_init in *; destruct x; desf.\nspecialize (wf_init_lab WF l); unfold is_only_pln, Events.mod; desf.\n"},{"statement":"Lemma read_or_fence_is_not_init WF a (A: R a \\/ F a) : ~ is_init a.","proof":"generalize ((init_w WF) a).\ntype_solver.\n"},{"statement":"Lemma no_sb_to_init : sb ≡ sb ⨾  ⦗fun x => ~ is_init x⦘.","proof":"split; [|basic_solver].\nunfold sb; rewrite ext_sb_to_non_init at 1; basic_solver.\n"},{"statement":"Lemma no_sb_cr_to_init :\n  ⦗set_compl is_init⦘ ⨾ sb^? ⊆ ⦗set_compl is_init⦘ ⨾ sb^? ⨾ ⦗set_compl is_init⦘.","proof":"rewrite no_sb_to_init at 1.\nclear.\nbasic_solver.\n"},{"statement":"Lemma no_rf_to_init WF : rf ≡ rf ⨾  ⦗fun x => ~ is_init x⦘.","proof":"split; [|basic_solver].\nrewrite (wf_rfD WF) at 1.\ngeneralize (read_or_fence_is_not_init WF).\nbasic_solver 42.\n"},{"statement":"Lemma rmw_from_non_init WF : rmw ≡ ⦗fun x => ~ is_init x⦘ ⨾ rmw.","proof":"split; [|basic_solver].\nrewrite (wf_rmwD WF).\ngeneralize (read_or_fence_is_not_init WF).\nbasic_solver 42.\n"},{"statement":"Lemma rmw_non_init_lr WF : rmw ≡ ⦗set_compl is_init⦘ ⨾ rmw ⨾ ⦗set_compl is_init⦘.","proof":"split; [|basic_solver].\nrewrite (rmw_from_non_init WF) at 1.\nrewrite <- seqA.\napply codom_rel_helper.\nrewrite (rmw_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver.\n"},{"statement":"Lemma init_same_loc WF a b (A: is_init a) (B: is_init b) (LOC: loc a = loc b): \n  a = b.","proof":"destruct a, b; desf.\ncut (l = l0); [by ins; subst|].\nunfold Events.loc in LOC.\nrewrite (wf_init_lab WF l), (wf_init_lab WF l0) in LOC; desf.\n"},{"statement":"Lemma Rel_not_init WF : Rel ⊆₁ set_compl is_init.","proof":"rewrite (init_pln WF).\nmode_solver.\n"},{"statement":"Lemma sb_semi_total_l x y z \n  WF (N: ~ is_init x) (NEQ: y <> z) (XY: sb x y) (XZ: sb x z): \n  sb y z \\/ sb z y.","proof":"unfold sb in *; unfolder in *; desf.\ncut (ext_sb y z \\/ ext_sb z y); [basic_solver 12|].\neapply ext_sb_semi_total_l; eauto.\neapply WF; splits; eauto.\nby unfold ext_sb in *; destruct y,z; ins; desf; desf.\nby unfold ext_sb in *; destruct y,z; ins; desf; desf.\n"},{"statement":"Lemma sb_semi_total_r x y z \n  WF (N: ~ is_init z) (NEQ: y <> z) (XY: sb y x) (XZ: sb z x): \n  sb y z \\/ sb z y.","proof":"cut ((sb ∪ sb⁻¹) y z); [basic_solver|].\nunfold sb in *; unfolder in *; desf.\ndestruct (classic (is_init y)).\nunfold ext_sb; basic_solver.\ncut (ext_sb y z \\/ ext_sb z y); [basic_solver|].\neapply ext_sb_semi_total_r; eauto.\neapply WF; splits; eauto.\nunfold ext_sb in *; destruct y,z; ins; desf; desf.\n"},{"statement":"Lemma sb_tid_init x y (SB : sb x y): tid x = tid y \\/ is_init x.","proof":"generalize ext_sb_tid_init; unfold sb in *.\nunfolder in *; basic_solver.\n"},{"statement":"Lemma E_ntid_sb_prcl thread :\n  dom_rel (⦗set_compl is_init⦘ ⨾ sb ⨾ ⦗E ∩₁ NTid_ thread⦘) ⊆₁ E ∩₁ NTid_ thread.","proof":"rewrite (dom_l wf_sbE).\nunfolder.\nins.\ndesf.\nsplits; auto.\nmatch goal with  | H : sb _ _ |- _ => rename H into SB  end.\napply sb_tid_init in SB.\ndesf.\nintros BB.\nrewrite BB in *.\ndesf.\n"},{"statement":"Lemma sb_tid_init': sb ≡ sb ∩ same_tid ∪ ⦗is_init⦘ ⨾ sb.","proof":"split; [|basic_solver].\nunfold sb.\nrewrite ext_sb_tid_init' at 1.\nbasic_solver 42.\n"},{"statement":"Lemma ninit_sb_same_tid : ⦗ set_compl is_init ⦘ ⨾ sb ⊆ same_tid.","proof":"rewrite sb_tid_init'.\nbasic_solver.\n"},{"statement":"Lemma same_tid_trans : transitive same_tid.","proof":"red.\nunfold same_tid.\nins.\netransitivity; eauto.\n"},{"statement":"Lemma tid_sb: ⦗E⦘ ⨾ same_tid ⨾  ⦗E⦘ ⊆ sb^? ∪ sb^{-1} ∪ (is_init × is_init).","proof":"unfold sb.\nrewrite tid_ext_sb.\nbasic_solver 21.\n"},{"statement":"Lemma tid_n_init_sb: ⦗E⦘ ⨾ same_tid ⨾ ⦗set_compl is_init⦘  ⨾  ⦗E⦘ ⊆ sb^? ∪ sb^{-1}.","proof":"unfold sb.\nsin_rewrite tid_n_init_ext_sb.\nbasic_solver 21.\n"},{"statement":"Lemma init_ninit_sb (WF : Wf) x y (INIT : is_init x) (ININE : E x) (INE : E y)\n      (NINIT : ~ is_init y): sb x y.","proof":"unfold sb, ext_sb; basic_solver.\n"},{"statement":"Lemma same_thread x y (X : E x) (Y : E y)\n      (NINIT : ~ is_init x) (ST : tid x = tid y):\n  sb^? x y \\/ sb y x.","proof":"cut (sb^? y x \\/ sb x y); [basic_solver|].\ngeneralize tid_n_init_sb.\nunfold same_tid; basic_solver 10.\n"},{"statement":"Lemma sb_immediate_adjacent WF:\n ⦗fun a => ~ is_init a⦘ ⨾ immediate sb ≡ ⦗fun a => ~ is_init a⦘ ⨾ (adjacent sb ∩ sb).","proof":"apply immediate_adjacent.\n- unfolder; ins; desf; destruct (classic (x=y)); auto.\nforward (apply (@sb_semi_total_r z y x)); eauto; tauto.\n- unfolder; ins; desf; destruct (classic (x=y)); auto.\nforward (apply (@sb_semi_total_l z y x)); eauto; tauto.\n- apply sb_trans.\n- apply sb_irr.\n"},{"statement":"Lemma sb_total t:\n  is_total ((E \\₁ is_init) ∩₁ Tid_ t) sb.","proof":"red.\nins.\nunfolder in IWa.\nunfolder in IWb.\ndesc.\nsubst.\ndestruct a, b; try by vauto.\nsimpl in *.\nsubst.\nassert (index < index0 \\/ index = index0 \\/ index0 < index) as HH by lia.\ndes; [left | congruence | right].\nall: red; apply seq_eqv_lr; splits; vauto.\n"},{"statement":"Lemma sb_transp_rmw  WF : sb ⨾ rmw ^{-1} ⊆ sb^?.","proof":"rewrite (rmw_from_non_init WF).\nrewrite (wf_rmwi WF); clear -WF.\nrewrite (sb_immediate_adjacent WF).\nunfold adjacent; basic_solver.\n"},{"statement":"Lemma transp_rmw_sb  WF :  rmw ^{-1} ⨾ sb ⊆ sb^?.","proof":"rewrite (rmw_from_non_init WF).\nrewrite (wf_rmwi WF); clear -WF.\nrewrite (sb_immediate_adjacent WF).\nunfold adjacent; basic_solver.\n"},{"statement":"Lemma rf_rf WF : rf ⨾ rf ≡ ∅₂.","proof":"rewrite (wf_rfD WF); type_solver.\n"},{"statement":"Lemma rf_co WF : rf ⨾ co ≡ ∅₂.","proof":"rewrite (wf_rfD WF), (wf_coD WF); type_solver.\n"},{"statement":"Lemma co_transp_rf WF : co ⨾  rf⁻¹ ≡ ∅₂.","proof":"rewrite (wf_rfD WF), (wf_coD WF); type_solver.\n"},{"statement":"Lemma co_fr WF : co ⨾ fr ≡ ∅₂.","proof":"rewrite (wf_coD WF), (wf_frD WF); type_solver.\n"},{"statement":"Lemma fr_fr WF : fr ⨾ fr ≡ ∅₂.","proof":"rewrite (wf_frD WF); type_solver.\n"},{"statement":"Lemma rf_transp_rf WF: rf ⨾ rf⁻¹ ⊆ ⦗fun _ => True⦘.","proof":"by apply functional_alt, WF.\n"},{"statement":"Lemma rf_fr WF : rf ⨾ fr ⊆ co.","proof":"unfold fr; sin_rewrite rf_transp_rf; rels.\n"},{"statement":"Lemma rmw_in_sb_loc WF: rmw ⊆ sb ∩ same_loc.","proof":"by rewrite (loceq_same_loc (loceq_rmw WF)), (rmw_in_sb WF).\n"},{"statement":"Lemma rf_irr WF: irreflexive rf.","proof":"rewrite (wf_rfD WF); type_solver.\n"},{"statement":"Lemma co_co WF: co ⨾ co ⊆ co.","proof":"apply rewrite_trans, WF.\n"},{"statement":"Lemma wf_rmwt WF: rmw ⊆ same_tid.","proof":"rewrite (rmw_from_non_init WF).\nrewrite (rmw_in_sb WF), sb_tid_init'.\nbasic_solver.\n"},{"statement":"Lemma wf_rmwf WF: functional rmw.","proof":"rewrite (rmw_from_non_init WF).\nrewrite (wf_rmwi WF).\nrewrite (sb_immediate_adjacent WF).\nunfolder; ins; desc.\neapply adjacent_unique1; eauto.\napply sb_acyclic.\n"},{"statement":"Lemma wf_rmw_invf WF: functional (rmw)⁻¹.","proof":"rewrite (rmw_from_non_init WF).\nrewrite (wf_rmwi WF).\nrewrite (sb_immediate_adjacent WF).\nunfolder; ins; desc.\neapply adjacent_unique2; eauto.\napply sb_acyclic.\n"},{"statement":"Lemma ri_union_re r : r ≡ r ∩ sb ∪ r \\ sb.","proof":"unfolder; split; ins; desf; tauto.\n"},{"statement":"Lemma rfi_union_rfe : rf ≡ rfi ∪ rfe.","proof":"apply ri_union_re.\n"},{"statement":"Lemma coi_union_coe : co ≡ coi ∪ coe.","proof":"apply ri_union_re.\n"},{"statement":"Lemma fri_union_fre : fr ≡ fri ∪ fre.","proof":"apply ri_union_re.\n"},{"statement":"Lemma ri_dom r d1 d2 (DOM: r ≡ ⦗d1⦘ ⨾ r ⨾ ⦗d2⦘) : r ∩ sb ⊆ ⦗d1⦘ ⨾ r ∩ sb ⨾ ⦗d2⦘.","proof":"rewrite DOM at 1; basic_solver.\n"},{"statement":"Lemma re_dom r d1 d2 (DOM: r ≡ ⦗d1⦘ ⨾ r ⨾ ⦗d2⦘) : r \\ sb ⊆ ⦗d1⦘ ⨾ (r \\ sb) ⨾ ⦗d2⦘.","proof":"rewrite DOM at 1; basic_solver.\n"},{"statement":"Lemma wf_rfiE WF: rfi ≡ ⦗E⦘ ⨾ rfi ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\napply (ri_dom (wf_rfE WF)).\n"},{"statement":"Lemma wf_coiE WF: coi ≡ ⦗E⦘ ⨾ coi ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\napply (ri_dom (wf_coE WF)).\n"},{"statement":"Lemma wf_friE WF: fri ≡ ⦗E⦘ ⨾ fri ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\napply (ri_dom (wf_frE WF)).\n"},{"statement":"Lemma wf_rfeE WF: rfe ≡ ⦗E⦘ ⨾ rfe ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\napply (re_dom (wf_rfE WF)).\n"},{"statement":"Lemma wf_coeE WF: coe ≡ ⦗E⦘ ⨾ coe ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\napply (re_dom (wf_coE WF)).\n"},{"statement":"Lemma wf_freE WF: fre ≡ ⦗E⦘ ⨾ fre ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\napply (re_dom (wf_frE WF)).\n"},{"statement":"Lemma wf_rfiD WF : rfi ≡ ⦗W⦘ ⨾ rfi ⨾ ⦗R⦘.","proof":"split; [|basic_solver].\napply (ri_dom (wf_rfD WF)).\n"},{"statement":"Lemma wf_coiD WF : coi ≡ ⦗W⦘ ⨾ coi ⨾ ⦗W⦘.","proof":"split; [|basic_solver].\napply (ri_dom (wf_coD WF)).\n"},{"statement":"Lemma wf_friD WF : fri ≡ ⦗R⦘ ⨾ fri ⨾ ⦗W⦘.","proof":"split; [|basic_solver].\napply (ri_dom (wf_frD WF)).\n"},{"statement":"Lemma wf_rfeD WF : rfe ≡ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘.","proof":"split; [|basic_solver].\napply (re_dom (wf_rfD WF)).\n"},{"statement":"Lemma wf_coeD WF : coe ≡ ⦗W⦘ ⨾ coe ⨾ ⦗W⦘.","proof":"split; [|basic_solver].\napply (re_dom (wf_coD WF)).\n"},{"statement":"Lemma wf_freD WF : fre ≡ ⦗R⦘ ⨾ fre ⨾ ⦗W⦘.","proof":"split; [|basic_solver].\napply (re_dom (wf_frD WF)).\n"},{"statement":"Lemma rfi_in_sb : rfi ⊆ sb.","proof":"unfold rfi; basic_solver.\n"},{"statement":"Lemma rfi_in_rf : rfi ⊆ rf.","proof":"unfold rfi; basic_solver.\n"},{"statement":"Lemma rfe_in_rf : rfe ⊆ rf.","proof":"unfold rfe; basic_solver.\n"},{"statement":"Lemma coi_in_sb : coi ⊆ sb.","proof":"unfold coi; basic_solver.\n"},{"statement":"Lemma coi_in_co : coi ⊆ co.","proof":"unfold coi; basic_solver.\n"},{"statement":"Lemma coe_in_co : coe ⊆ co.","proof":"unfold coe; basic_solver.\n"},{"statement":"Lemma ninit_rfi_same_tid : ⦗ set_compl is_init ⦘ ⨾ rfi ⊆ same_tid.","proof":"arewrite (rfi ⊆ sb).\napply ninit_sb_same_tid.\n"},{"statement":"Lemma coi_trans WF : transitive coi.","proof":"apply transitiveI.\ngeneralize sb_trans (co_trans WF).\nintros SB CO.\nunfold coi.\nunfolder.\nins.\ndesf.\nsplit; [eapply CO|eapply SB]; eauto.\n"},{"statement":"Lemma fri_in_sb : fri ⊆ sb.","proof":"unfold fri; basic_solver.\n"},{"statement":"Lemma fri_in_fr : fri ⊆ fr.","proof":"unfold fri; basic_solver.\n"},{"statement":"Lemma fre_in_fr : fre ⊆ fr.","proof":"unfold fre; basic_solver.\n"},{"statement":"Lemma fri_coi WF : fri ⨾ coi ⊆ fri.","proof":"unfold fri, coi.\nunfolder.\nins.\ndesf.\nsplit.\n{\napply fr_co; auto.\nbasic_solver.\n}\neapply sb_trans; eauto.\n"},{"statement":"Lemma codom_rfi_rfe_empty WF : codom_rel rfi ∩₁ codom_rel rfe ⊆₁ ∅.","proof":"unfold rfi, rfe.\nunfolder.\nins.\ndesf.\nassert (x0 = x1); subst; eauto.\neapply (wf_rff WF); eauto.\n"},{"statement":"Lemma seq_ii r1 r2 r3 (A: r1 ⨾ r2 ⊆ r3): r1 ∩ sb ⨾ r2 ∩ sb ⊆ r3 ∩ sb.","proof":"generalize sb_trans.\nunfolder in *; basic_solver 21.\n"},{"statement":"Lemma re_ri WF  r r' (IRR: irreflexive r)  (IRR2: irreflexive (r ⨾ sb))\n  (N: r ⊆ r ⨾  ⦗ fun x => ~ is_init x ⦘): (r \\ sb) ⨾ (r' ∩ sb) ⊆ r ⨾  r' \\ sb.","proof":"rewrite N at 1.\nunfolder; ins; desf; splits; eauto.\nintro.\neapply sb_semi_total_r with (x:=y) (y:=x) in H1; eauto.\nby desf; revert IRR2; basic_solver.\neby intro; subst; eapply IRR.\n"},{"statement":"Lemma ri_re WF  r r' (IRR: irreflexive r')  (IRR2: irreflexive (r' ⨾ sb)): \n ⦗ fun x => ~ is_init x ⦘ ⨾ (r ∩ sb) ⨾ (r' \\ sb) ⊆ r ⨾  r' \\ sb.","proof":"unfolder; ins; desf; splits; eauto.\nintro.\neapply sb_semi_total_l with (x:=x) (y:=z) (z:=y) in H4; eauto.\nby desf; revert IRR2; basic_solver.\neby intro; subst; eapply IRR.\n"},{"statement":"Lemma rfi_in_sbloc WF : rf ∩ sb ⊆ restr_eq_rel loc sb.","proof":"rewrite wf_rfl; basic_solver 12.\n"},{"statement":"Lemma coi_in_sbloc WF : co ∩ sb ⊆ restr_eq_rel loc sb.","proof":"rewrite wf_col; basic_solver 12.\n"},{"statement":"Lemma fri_in_sbloc WF : fr ∩ sb ⊆ restr_eq_rel loc sb.","proof":"rewrite (loceq_same_loc (loceq_fr WF)).\nunfolder; unfold Events.same_loc in *.\nins; desf; splits; eauto; congruence.\n"},{"statement":"Lemma rfi_in_sbloc' WF : rfi ⊆ sb ∩ same_loc.","proof":"generalize (wf_rfl WF); unfold rfi; basic_solver 12.\n"},{"statement":"Lemma coi_in_sbloc' WF : coi ⊆ sb ∩ same_loc.","proof":"generalize (wf_col WF); unfold coi; basic_solver 12.\n"},{"statement":"Lemma fri_in_sbloc' WF : fri ⊆ sb ∩ same_loc.","proof":"generalize (wf_frl WF); unfold fri; basic_solver 12.\n"},{"statement":"Lemma rf_rmw_sb_minus_sb WF: (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) \\ sb ⊆ rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘.","proof":"rewrite (seq_minus_transitive sb_trans).\nunionL; [by unfold rfe; basic_solver 12|].\nrewrite (rmw_in_sb WF) at 1.\narewrite (sb ⨾ sb^? ⨾ ⦗W⦘ ⊆ sb) by generalize sb_trans; basic_solver 21.\nrelsf.\n"},{"statement":"Lemma rf_rmw_sb_rt_rf WF: ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf) \\ sb ⊆ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)＊.","proof":"rewrite rtE; relsf.\nrewrite rtE, minus_union_l.\nrelsf; unionL; [by unfold rfe; basic_solver 12|].\nrewrite (seq_minus_transitive sb_trans).\nunionL; [|by unfold rfe; basic_solver 12].\nunionR right.\nrewrite (ct_minus_transitive sb_trans).\narewrite ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ∩ sb ⊆ sb).\ngeneralize sb_trans; ins; relsf.\nrewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA.\n"},{"statement":"Lemma rmw_rf_ct WF : (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺ ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)⁺ ⨾ rf.","proof":"apply inclusion_t_ind_left.\n{\nhahn_frame; vauto.\n}\nrewrite ct_begin; hahn_frame; relsf.\narewrite (rfe ⊆ rf) at 2.\nseq_rewrite (rf_rf WF).\nrelsf.\nrewrite rfi_union_rfe; relsf; unionL.\n{\narewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF) at 2.\narewrite (sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?).\ngeneralize sb_trans; basic_solver 21.\nbasic_solver 21.\n}\nrewrite rt_begin at 2.\nrewrite rt_begin at 2.\nbasic_solver 42.\n"},{"statement":"Lemma rmw_rf_rt_1 WF : (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)＊ ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfi^?.","proof":"rewrite rtE; unionL; [basic_solver 12|].\nrewrite (rmw_rf_ct WF).\nrewrite rfi_union_rfe; relsf.\nrewrite inclusion_t_rt.\nrelsf; unionL.\nbasic_solver 12.\nrewrite rt_end at 2; basic_solver 12.\n"},{"statement":"Lemma wf_detourE WF: detour ≡ ⦗E⦘ ⨾ detour ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold detour.\nsin_rewrite (wf_coeE WF).\nsin_rewrite (wf_rfeE WF).\nbasic_solver 42.\n"},{"statement":"Lemma wf_detourD WF: detour ≡ ⦗W⦘ ⨾ detour ⨾ ⦗R⦘.","proof":"split; [|basic_solver].\nunfold detour.\nsin_rewrite (wf_coeD WF).\nsin_rewrite (wf_rfeD WF).\nbasic_solver 42.\n"},{"statement":"Lemma detour_fr_in_co WF: detour ⨾ fr ⊆ co.","proof":"unfold detour, coe, rfe.\ngeneralize (rf_fr WF) (co_trans WF).\nbasic_solver 42.\n"},{"statement":"Lemma detour_transp_rfi WF: detour ⨾ rfi^{-1} ⊆ ∅₂.","proof":"unfold detour, rfe, rfi.\nunfolder; ins; desf.\nassert (y=z0); subst; auto.\neapply WF; basic_solver.\n"},{"statement":"Lemma detour_in_sb : detour ⊆ sb.","proof":"unfold detour; basic_solver.\n"},{"statement":"Lemma detour_to_codom_rfe WF: detour ⊆ detour ⨾ ⦗ codom_rel rfe ⦘.","proof":"unfold detour, rfe, rfi.\nunfolder; ins; desf; eauto 20.\n"},{"statement":"Lemma W_ex_not_init WF : W_ex ⊆₁ set_compl is_init.","proof":"unfolder.\nins.\ndesf.\nmatch goal with  | H : W_ex _ |- _ => rename H into WEX  end.\ndestruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf.\n"},{"statement":"Lemma W_ex_in_W WF : W_ex ⊆₁ W.","proof":"unfold W_ex; rewrite (dom_r (wf_rmwD WF)); basic_solver.\n"},{"statement":"Lemma W_ex_in_E WF : W_ex ⊆₁ E.","proof":"unfold W_ex.\nrewrite (dom_r (wf_rmwE WF)).\nbasic_solver.\n"},{"statement":"Lemma W_ex_eq_EW_W_ex WF : W_ex ≡₁ E ∩₁ W ∩₁ W_ex.","proof":"generalize (W_ex_in_E WF).\ngeneralize (W_ex_in_W WF).\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma W_ex_acq_in_W WF : W_ex_acq ⊆₁ W.","proof":"rewrite (W_ex_in_W WF); basic_solver.\n"},{"statement":"Lemma rmw_W_ex : rmw ⊆ rmw ⨾ ⦗W_ex⦘.","proof":"unfold W_ex; basic_solver.\n"},{"statement":"Lemma W_ex_acq_not_init WF : W_ex_acq ⊆₁ set_compl is_init.","proof":"unfolder.\nins.\ndesf.\nmatch goal with  | H : W_ex _ |- _ => rename H into WEX  end.\ndestruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf.\n"},{"statement":"Lemma wf_rfrmwE WF: rf ⨾ rmw ≡ ⦗ E ⦘ ⨾ (rf ⨾ rmw) ⨾ ⦗ E ⦘.","proof":"split; [|basic_solver].\nrewrite (wf_rfE WF) at 1.\nrewrite (wf_rmwE WF) at 1.\nbasic_solver.\n"},{"statement":"Lemma wf_rfrmwD WF: rf ⨾ rmw ≡ ⦗ W ⦘ ⨾ (rf ⨾ rmw) ⨾ ⦗ W ⦘.","proof":"split; [|basic_solver].\nrewrite (wf_rfD WF) at 1.\nrewrite (wf_rmwD WF) at 1.\nbasic_solver.\n"},{"statement":"Lemma wf_rfrmwl WF: rf ⨾ rmw ⊆ same_loc.","proof":"rewrite (wf_rfl WF), (wf_rmwl WF).\ngeneralize same_loc_trans; basic_solver.\n"},{"statement":"Lemma wf_rfrmwf WF: functional (rf ⨾ rmw)⁻¹.","proof":"hahn_rewrite transp_seq.\nby apply functional_seq; [apply wf_rmw_invf|apply WF].\n"},{"statement":"Lemma wf_rfirmwf WF : functional (rfi ⨾ rmw)⁻¹.","proof":"arewrite (rfi ⊆ rf).\neapply wf_rfrmwf; eauto.\n"},{"statement":"Lemma wf_rfermwf WF : functional (rfe ⨾ rmw)⁻¹.","proof":"arewrite (rfe ⊆ rf).\neapply wf_rfrmwf; eauto.\n"},{"statement":"Lemma rt_rf_rmw : (rf ⨾ rmw)＊ ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊.","proof":"eapply rt_ind_left with (P:=fun r=> r); eauto with hahn.\nbasic_solver 12.\nintros k H.\nrewrite !seqA, H.\nrewrite rfi_union_rfe; relsf; unionL.\n{\nrewrite rt_begin at 3.\nbasic_solver 21.\n}\nrewrite (rt_begin (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)) at 2.\nbasic_solver 21.\n"},{"statement":"Lemma ninit_rfi_rmw_same_tid WF : ⦗ set_compl is_init ⦘ ⨾ rfi ⨾ rmw ⊆ same_tid.","proof":"rewrite (wf_rmwt WF).\nsin_rewrite ninit_rfi_same_tid.\napply transitiveI.\napply same_tid_trans.\n"},{"statement":"Lemma ninit_rfi_rmw_rt_same_tid WF : ⦗ set_compl is_init ⦘ ⨾ (rfi ⨾ rmw)＊ ⊆ same_tid.","proof":"apply rt_ind_left with (P:= fun r => ⦗set_compl is_init⦘ ⨾ r).\n{\nby eauto with hahn.\n}\n{\nunfold same_tid.\nbasic_solver 12.\n}\nintros k AA.\nrewrite !seqA.\nrewrite (dom_r (rmw_non_init_lr WF)).\nrewrite !seqA.\nrewrite AA.\nsin_rewrite ninit_rfi_rmw_same_tid; auto.\napply transitiveI.\napply same_tid_trans.\n"},{"statement":"Lemma sw_in_ar_helper WF:\n  ((sb ∩ same_loc)^? ⨾ rf ⨾ rmw)＊ ⊆\n  (sb ∩ same_loc ⨾ ⦗W⦘)^? ∪ (sb ∩ same_loc)^? ⨾ (rfe ⨾ rmw ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘)⁺.","proof":"rewrite rtE at 1; relsf; unionL; [basic_solver 21|].\nrewrite rfi_union_rfe; relsf.\nrewrite path_union.\nunionL.\n{\nrewrite (dom_r (wf_rmwD WF)) at 1.\nrewrite (rfi_in_sbloc' WF) at 1.\nrewrite (rmw_in_sb_loc WF) at 1.\ngeneralize sb_same_loc_trans; ins; relsf.\nassert (transitive (sb ∩ same_loc ⨾ ⦗W⦘)).\n2: by relsf.\ngeneralize sb_same_loc_trans; unfold transitive.\nbasic_solver 21.\n}\nrewrite ct_seq_swap, !seqA.\nrewrite (dom_r (wf_rmwD WF)) at 3.\nrewrite (rfi_in_sbloc' WF) at 1 2.\nrewrite (rmw_in_sb_loc WF) at 1 3.\ngeneralize sb_same_loc_trans; intros HH; relsf.\nunionR right.\nrewrite (dom_l (wf_rfeD WF)), !seqA.\nrewrite <- seqA with (r2:= ⦗W⦘).\nrewrite ct_rotl, !seqA.\narewrite ((sb ∩ same_loc)^? ⨾ (sb ∩ same_loc)^? ⊆ (sb ∩ same_loc)^?).\n{\ngeneralize HH.\nbasic_solver 10.\n}\nhahn_frame.\narewrite (((sb ∩ same_loc) ⨾ ⦗W⦘)＊ ⨾ (sb ∩ same_loc)^? ⊆ (sb ∩ same_loc)^?).\n{\narewrite_id ⦗W⦘.\nrewrite seq_id_r.\nrewrite rt_of_trans.\n2: by apply sb_same_loc_trans.\ngeneralize sb_same_loc_trans.\nbasic_solver 10.\n}\narewrite (rmw ⨾ (sb ∩ same_loc ⨾ ⦗W⦘)＊ ⊆ rmw ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘).\n2: {\nrewrite (dom_l (wf_rfeD WF)) at 1 2; rewrite !seqA.\narewrite_id ⦗W⦘ at 1.\nrewrite seq_id_l.\napply ct_end.\n}\nrewrite rtE, seq_union_r.\nunionL.\n{\nrewrite (dom_r (wf_rmwD WF)) at 1.\nbasic_solver 10.\n}\nrewrite ct_of_trans.\n{\nbasic_solver 10.\n}\ngeneralize sb_trans, same_loc_trans.\nbasic_solver 20.\n"},{"statement":"Lemma s_sw_in_ar_helper WF:\n  (rf ⨾ rmw)＊ ⊆ (sb ∩ same_loc ⨾ ⦗W⦘)^? ∪ (sb ∩ same_loc)^? ⨾ (rfe ⨾ rmw ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘)⁺.","proof":"arewrite (rf ⨾ rmw ⊆ (sb ∩ same_loc)^? ⨾ rf ⨾ rmw).\n{\nbasic_solver 10.\n}\napply (sw_in_ar_helper WF).\n"},{"statement":"Lemma sb_co_trans WF :\n  transitive ((⦗F⦘ ⨾ sb)^? ⨾ co).","proof":"apply transitiveI.\nrewrite !seqA.\nrewrite (dom_r (wf_coD WF)).\nrewrite !seqA.\narewrite_id (⦗W⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\n{\ntype_solver.\n}\nrewrite seq_id_l.\nby sin_rewrite (co_co WF).\n"},{"statement":"Lemma rel_sb_co_trans WF :\n  transitive (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co).","proof":"apply transitiveI.\nrewrite !seqA.\nrewrite (dom_r (wf_coD WF)).\nrewrite !seqA.\narewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\n{\ntype_solver.\n}\nrewrite seq_id_l.\nby sin_rewrite (co_co WF).\n"},{"statement":"Lemma sb_co_irr WF :\n  irreflexive ((⦗F⦘ ⨾ sb)^? ⨾ co).","proof":"rewrite crE.\nrewrite seq_union_l, !seq_id_l.\napply irreflexive_union.\nsplit.\n{\nby apply co_irr.\n}\nrewrite (wf_coD WF).\ntype_solver.\n"},{"statement":"Lemma rel_sb_co_irr WF :\n  irreflexive (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co).","proof":"arewrite_id ⦗Rel⦘.\nrewrite seq_id_l.\nby apply sb_co_irr.\n"},{"statement":"Lemma co_E_W_Loc WF l x y (CO : co x y): (E ∩₁ W ∩₁ Loc_ l) x <-> (E ∩₁ W ∩₁ Loc_ l) y.","proof":"apply (wf_coE WF) in CO.\napply seq_eqv_l in CO.\ndestruct CO as [EX CO].\napply seq_eqv_r in CO.\ndestruct CO as [CO EY].\napply (wf_coD WF) in CO.\napply seq_eqv_l in CO.\ndestruct CO as [WX CO].\napply seq_eqv_r in CO.\ndestruct CO as [CO WY].\napply (wf_col WF) in CO.\nsplit; intros [_ LL].\nall: by split; [split|rewrite <- LL].\n"},{"statement":"Lemma rfi_rmw_in_sb_same_loc_W WF : rfi ⨾ rmw ⊆ (sb ∩ same_loc) ⨾ ⦗W⦘.","proof":"rewrite (dom_r (wf_rmwD WF)).\nrewrite rfi_in_sbloc', rmw_in_sb_loc; auto.\nsin_rewrite rewrite_trans; [done|].\napply sb_same_loc_trans.\n"},{"statement":"Lemma rfi_rmw_in_sb_loc WF : rfi ⨾ rmw ⊆ sb ∩ same_loc.","proof":"rewrite (rfi_rmw_in_sb_same_loc_W WF).\nbasic_solver.\n"},{"statement":"Lemma wf_immcof WF : functional (immediate co).","proof":"intros x y z ICOXY ICOXZ.\nassert (co x y) as COXY by apply ICOXY.\nassert (co x z) as COXZ by apply ICOXZ.\napply (wf_coD WF) in COXY.\ndestruct_seq COXY as [BB1 BB2].\napply (wf_coE WF) in COXY.\ndestruct_seq COXY as [BB3 BB4].\napply (wf_coD WF) in COXZ.\ndestruct_seq COXZ as [AA1 AA2].\napply (wf_coE WF) in COXZ.\ndestruct_seq COXZ as [AA3 AA4].\napply is_w_loc in AA1.\ndesf.\nset (CC:=COXY).\napply (wf_col WF) in CC.\nred in CC.\nset (DD:=COXZ).\napply (wf_col WF) in DD.\nred in DD.\ndestruct (classic (y = z)); auto.\nedestruct (wf_co_total WF); eauto.\n1,2: split; [split|]; eauto.\n{\nby etransitivity; [|by eauto].\n}\n{\nexfalso.\nby apply ICOXZ with (c:=y).\n}\nexfalso.\nby apply ICOXY with (c:=z).\n"},{"statement":"Lemma wf_immcotf WF : functional (immediate co)⁻¹.","proof":"intros x y z ICOXY ICOXZ.\nred in ICOXY.\nred in ICOXZ.\nassert (co y x) as COXY by apply ICOXY.\nassert (co z x) as COXZ by apply ICOXZ.\napply (wf_coD WF) in COXY.\ndestruct_seq COXY as [BB1 BB2].\napply (wf_coE WF) in COXY.\ndestruct_seq COXY as [BB3 BB4].\napply (wf_coD WF) in COXZ.\ndestruct_seq COXZ as [AA1 AA2].\napply (wf_coE WF) in COXZ.\ndestruct_seq COXZ as [AA3 AA4].\napply is_w_loc in AA2.\ndesf.\nset (CC:=COXY).\napply (wf_col WF) in CC.\nred in CC.\nset (DD:=COXZ).\napply (wf_col WF) in DD.\nred in DD.\ndestruct (classic (y = z)); auto.\nedestruct (wf_co_total WF); eauto.\n1,2: split; [split|]; eauto.\n{\nexfalso.\nby apply ICOXY with (c:=z).\n}\nexfalso.\nby apply ICOXZ with (c:=y).\n"},{"statement":"Lemma wf_immcoPtf WF P : functional (immediate (⦗P⦘ ⨾ co))⁻¹.","proof":"intros x y z ICOXY ICOXZ.\nred in ICOXY.\nred in ICOXZ.\nassert (co y x /\\ P y) as [COXY PY].\n{\ndestruct ICOXY as [AA BB].\ngeneralize AA.\nbasic_solver.\n}\nassert (co z x /\\ P z) as [COXZ PZ].\n{\ndestruct ICOXZ as [AA BB].\ngeneralize AA.\nbasic_solver.\n}\napply (wf_coD WF) in COXY.\ndestruct_seq COXY as [BB1 BB2].\napply (wf_coE WF) in COXY.\ndestruct_seq COXY as [BB3 BB4].\napply (wf_coD WF) in COXZ.\ndestruct_seq COXZ as [AA1 AA2].\napply (wf_coE WF) in COXZ.\ndestruct_seq COXZ as [AA3 AA4].\napply is_w_loc in AA2.\ndesf.\nset (CC:=COXY).\napply (wf_col WF) in CC.\nred in CC.\nset (DD:=COXZ).\napply (wf_col WF) in DD.\nred in DD.\ndestruct (classic (y = z)); auto.\nedestruct (wf_co_total WF); eauto.\n1,2: split; [split|]; eauto.\n{\nexfalso.\napply ICOXY with (c:=z).\nall: apply seq_eqv_l; split; auto.\n}\nexfalso.\napply ICOXZ with (c:=y).\nall: apply seq_eqv_l; split; auto.\n"},{"statement":"Lemma P_co_nP_co_P_imm WF P\n      (P_in_E : P ⊆₁ E)\n      (P_in_W : P ⊆₁ W) :\n  immediate (⦗P⦘ ⨾ co) ⨾ ⦗set_compl P⦘ ⨾ immediate (co ⨾ ⦗P⦘) ⊆\n            immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘).","proof":"intros x y [z [AA BB]].\ndestruct_seq_l BB as CC.\nset (DD := AA).\ndestruct DD as [DD _].\ndestruct_seq_l DD as PX.\nset (EE := BB).\ndestruct EE as [EE _].\ndestruct_seq_r EE as PY.\nassert (co x y) as CO.\n{\neapply (co_trans WF); eauto.\n}\napply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\n{\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\n}\nsplit.\n{\napply seq_eqv_lr.\nby splits.\n}\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\n{\nrewrite <- YLOC.\nby apply (wf_col WF).\n}\nassert (E c) as EC.\n{\nby apply P_in_E.\n}\nassert (W c) as WC.\n{\nby apply P_in_W.\n}\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\n{\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\n}\nassert (co c z \\/ co z c) as [QQ|QQ].\n{\neapply (wf_co_total WF); eauto; unfolder; eauto.\n}\n{\neapply AA with (c:=c); apply seq_eqv_l; eauto.\n}\neapply BB with (c:=c); apply seq_eqv_r; eauto.\n"},{"statement":"Lemma P_co_immediate_P_co_transp_in_co_cr WF P\n      (P_in_E : P ⊆₁ E)\n      (P_in_W : P ⊆₁ W) :\n  (⦗P⦘ ⨾ co) ⨾ (immediate (⦗P⦘⨾ co))⁻¹ ⊆ co^?.","proof":"intros x y [z [AA [BB CC]]].\ndestruct_seq_l AA as PZ.\ndestruct_seq_l BB as DD.\ndestruct (classic (x = y)) as [|NEQ]; subst; [by left|right].\napply (wf_coD WF) in AA.\ndestruct_seq AA as [WX WZ].\napply (wf_coE WF) in AA.\ndestruct_seq AA as [EX EZ].\napply (wf_coD WF) in BB.\ndestruct_seq BB as [WY ZLOC].\napply (wf_coE WF) in BB.\ndestruct_seq BB as [EY FF].\napply is_w_loc in ZLOC.\ndesf.\nassert (loc x = Some l /\\ loc y = Some l) as [XLOC YLOC].\n{\nrewrite <- !ZLOC.\nsplit; by apply (wf_col WF).\n}\nedestruct (wf_co_total WF); eauto.\n1,2: by split; [split|]; eauto.\nexfalso.\napply CC with (c:=x).\nall: apply seq_eqv_l; split; auto.\n"},{"statement":"Lemma co_immediate_co_in_co_cr WF : co ⨾ (immediate co)⁻¹ ⊆ co^?.","proof":"assert (co ≡ ⦗E∩₁W⦘ ⨾ co) as AA.\n{\nsplit; [|basic_solver].\nrewrite (wf_coE WF) at 1.\nrewrite (wf_coD WF) at 1.\nbasic_solver.\n}\nrewrite AA at 1 2.\napply P_co_immediate_P_co_transp_in_co_cr.\nall: basic_solver.\n"},{"statement":"Lemma immediate_co_P_transp_co_P_in_co_cr WF P\n      (P_in_E : P ⊆₁ E)\n      (P_in_W : P ⊆₁ W) :\n  (immediate (co ⨾ ⦗P⦘))⁻¹ ⨾ (co ⨾ ⦗P⦘) ⊆ co^?.","proof":"intros x y [z [[BB CC] AA]].\ndestruct_seq_r AA as PZ.\ndestruct_seq_r BB as DD.\ndestruct (classic (x = y)) as [|NEQ]; subst; [by left|right].\napply (wf_coD WF) in AA.\ndestruct_seq AA as [WZ WY].\napply (wf_coE WF) in AA.\ndestruct_seq AA as [EZ EY].\napply (wf_coD WF) in BB.\ndestruct_seq BB as [ZLOC WX].\napply (wf_coE WF) in BB.\ndestruct_seq BB as [FF EX].\napply is_w_loc in ZLOC.\ndesf.\nassert (loc x = Some l /\\ loc y = Some l) as [XLOC YLOC].\n{\nrewrite <- !ZLOC.\nsplit; symmetry; by apply (wf_col WF).\n}\nedestruct (wf_co_total WF); eauto.\n1,2: by split; [split|]; eauto.\nexfalso.\napply CC with (c:=y).\nall: apply seq_eqv_r; split; auto.\n"}]