{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Stackingproof.v","fileSamples":[{"statement":"(p : Linear.program) (tp : program) (H : transf_program p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Linear.program) (tp : program) (H : transf_program p = OK tp)","proofString":"eapply match_transform_partial_program; eauto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) : slot_valid f Outgoing ofs ty = true.","conclusion":"slot_valid f Outgoing ofs ty = true","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)))","proofString":"exploit loc_arguments_acceptable_2; eauto.\nintros [A B].\nunfold slot_valid.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nauto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) : loc_argument_acceptable (S Outgoing ofs ty) ->\nslot_valid f Outgoing ofs ty = true.","conclusion":"loc_argument_acceptable (S Outgoing ofs ty) ->\nslot_valid f Outgoing ofs ty = true","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)))","proofString":"intros [A B].\nunfold slot_valid.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nauto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs)) : slot_valid f Outgoing ofs ty = true.","conclusion":"slot_valid f Outgoing ofs ty = true","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs))","proofString":"unfold slot_valid.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nauto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs)) : zle 0 ofs && Zdivide_dec (typealign ty) ofs = true.","conclusion":"zle 0 ofs && Zdivide_dec (typealign ty) ofs = true","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs))","proofString":"unfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nauto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs)) : (if zle 0 ofs then true else false) &&\n(if Zdivide_dec (typealign ty) ofs then true else false) = true.","conclusion":"(if zle 0 ofs then true else false) &&\n(if Zdivide_dec (typealign ty) ofs then true else false) = true","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs))","proofString":"rewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nauto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs)) : true && (if Zdivide_dec (typealign ty) ofs then true else false) = true.","conclusion":"true && (if Zdivide_dec (typealign ty) ofs then true else false) = true","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs))","proofString":"rewrite pred_dec_true by auto.\nauto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs)) : true && true = true.","conclusion":"true && true = true","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (sg : signature) (H : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))) (A : ofs >= 0) (B : (typealign ty | ofs))","proofString":"auto."},{"statement":"transf_function f = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}.","conclusion":"transf_function f = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}","hypotheses":"","proofString":"unfold transf_function.\ndestruct (wt_function f); simpl negb.\ndestruct (zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))).\nintros; discriminate.\nintros.\nunfold fe.\nunfold b.\ncongruence.\nintros; discriminate."},{"statement":"(if negb (wt_function f)\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}.","conclusion":"(if negb (wt_function f)\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}","hypotheses":"","proofString":"destruct (wt_function f); simpl negb.\ndestruct (zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))).\nintros; discriminate.\nintros.\nunfold fe.\nunfold b.\ncongruence.\nintros; discriminate."},{"statement":"(if false\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}.","conclusion":"(if false\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}","hypotheses":"","proofString":"destruct (zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))).\nintros; discriminate.\nintros.\nunfold fe.\nunfold b.\ncongruence."},{"statement":"(l : Ptrofs.max_unsigned < fe_size (make_env (function_bounds f))) : Error (msg \"Too many spilled variables, stack size exceeded\") = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}.","conclusion":"Error (msg \"Too many spilled variables, stack size exceeded\") = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}","hypotheses":"(l : Ptrofs.max_unsigned < fe_size (make_env (function_bounds f)))","proofString":"intros; discriminate."},{"statement":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}.","conclusion":"OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}","hypotheses":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f)))","proofString":"intros.\nunfold fe.\nunfold b.\ncongruence."},{"statement":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf) : tf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}.","conclusion":"tf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}","hypotheses":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf)","proofString":"unfold fe.\nunfold b.\ncongruence."},{"statement":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf) : tf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f (make_env b);\n  fn_stacksize := fe_size (make_env b);\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env b));\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr (make_env b))\n|}.","conclusion":"tf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f (make_env b);\n  fn_stacksize := fe_size (make_env b);\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env b));\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr (make_env b))\n|}","hypotheses":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf)","proofString":"unfold b.\ncongruence."},{"statement":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf) : tf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f (make_env (function_bounds f));\n  fn_stacksize := fe_size (make_env (function_bounds f));\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n  fn_retaddr_ofs :=\n    Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n|}.","conclusion":"tf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f (make_env (function_bounds f));\n  fn_stacksize := fe_size (make_env (function_bounds f));\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n  fn_retaddr_ofs :=\n    Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n|}","hypotheses":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf)","proofString":"congruence."},{"statement":"(if true\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}.","conclusion":"(if true\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf ->\ntf =\n{|\n  fn_sig := Linear.fn_sig f;\n  fn_code := transl_body f fe;\n  fn_stacksize := fe_size fe;\n  fn_link_ofs := Ptrofs.repr (fe_ofs_link fe);\n  fn_retaddr_ofs := Ptrofs.repr (fe_ofs_retaddr fe)\n|}","hypotheses":"","proofString":"intros; discriminate."},{"statement":"transf_function f = OK tf -> wt_function f = true.","conclusion":"transf_function f = OK tf -> wt_function f = true","hypotheses":"","proofString":"unfold transf_function.\ndestruct (wt_function f); simpl negb.\nauto.\nintros; discriminate."},{"statement":"(if negb (wt_function f)\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> wt_function f = true.","conclusion":"(if negb (wt_function f)\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> wt_function f = true","hypotheses":"","proofString":"destruct (wt_function f); simpl negb.\nauto.\nintros; discriminate."},{"statement":"(if false\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> true = true.","conclusion":"(if false\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> true = true","hypotheses":"","proofString":"auto."},{"statement":"(if true\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> false = true.","conclusion":"(if true\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> false = true","hypotheses":"","proofString":"intros; discriminate."},{"statement":"transf_function f = OK tf -> fe_size fe <= Ptrofs.max_unsigned.","conclusion":"transf_function f = OK tf -> fe_size fe <= Ptrofs.max_unsigned","hypotheses":"","proofString":"unfold transf_function.\ndestruct (wt_function f); simpl negb.\ndestruct (zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))).\nintros; discriminate.\nintros.\nunfold fe.\nunfold b.\nlia.\nintros; discriminate."},{"statement":"(if negb (wt_function f)\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> fe_size fe <= Ptrofs.max_unsigned.","conclusion":"(if negb (wt_function f)\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> fe_size fe <= Ptrofs.max_unsigned","hypotheses":"","proofString":"destruct (wt_function f); simpl negb.\ndestruct (zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))).\nintros; discriminate.\nintros.\nunfold fe.\nunfold b.\nlia.\nintros; discriminate."},{"statement":"(if false\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> fe_size fe <= Ptrofs.max_unsigned.","conclusion":"(if false\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> fe_size fe <= Ptrofs.max_unsigned","hypotheses":"","proofString":"destruct (zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))).\nintros; discriminate.\nintros.\nunfold fe.\nunfold b.\nlia."},{"statement":"(l : Ptrofs.max_unsigned < fe_size (make_env (function_bounds f))) : Error (msg \"Too many spilled variables, stack size exceeded\") = OK tf ->\nfe_size fe <= Ptrofs.max_unsigned.","conclusion":"Error (msg \"Too many spilled variables, stack size exceeded\") = OK tf ->\nfe_size fe <= Ptrofs.max_unsigned","hypotheses":"(l : Ptrofs.max_unsigned < fe_size (make_env (function_bounds f)))","proofString":"intros; discriminate."},{"statement":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf -> fe_size fe <= Ptrofs.max_unsigned.","conclusion":"OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf -> fe_size fe <= Ptrofs.max_unsigned","hypotheses":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f)))","proofString":"intros.\nunfold fe.\nunfold b.\nlia."},{"statement":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf) : fe_size fe <= Ptrofs.max_unsigned.","conclusion":"fe_size fe <= Ptrofs.max_unsigned","hypotheses":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf)","proofString":"unfold fe.\nunfold b.\nlia."},{"statement":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf) : fe_size (make_env b) <= Ptrofs.max_unsigned.","conclusion":"fe_size (make_env b) <= Ptrofs.max_unsigned","hypotheses":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf)","proofString":"unfold b.\nlia."},{"statement":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf) : fe_size (make_env (function_bounds f)) <= Ptrofs.max_unsigned.","conclusion":"fe_size (make_env (function_bounds f)) <= Ptrofs.max_unsigned","hypotheses":"(g : Ptrofs.max_unsigned >= fe_size (make_env (function_bounds f))) (TRANSF_F0 : OK\n  {|\n    fn_sig := Linear.fn_sig f;\n    fn_code := transl_body f (make_env (function_bounds f));\n    fn_stacksize := fe_size (make_env (function_bounds f));\n    fn_link_ofs := Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n    fn_retaddr_ofs :=\n      Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n  |} = OK tf)","proofString":"lia."},{"statement":"(if true\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> fe_size fe <= Ptrofs.max_unsigned.","conclusion":"(if true\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK tf -> fe_size fe <= Ptrofs.max_unsigned","hypotheses":"","proofString":"intros; discriminate."},{"statement":"Linear.fn_stacksize f <= Z.max (Linear.fn_stacksize f) 0.","conclusion":"Linear.fn_stacksize f <= Z.max (Linear.fn_stacksize f) 0","hypotheses":"","proofString":"apply Z.le_max_l."},{"statement":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v /\\ spec v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v /\\ spec v","hypotheses":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec)","proofString":"unfold load_stack.\nreplace (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)) with (Vptr sp (Ptrofs.repr ofs)).\neapply loadv_rule; eauto.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec) : exists v : val,\n  Mem.loadv (chunk_of_type ty) m\n    (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)) = \n  Some v /\\ spec v.","conclusion":"exists v : val,\n  Mem.loadv (chunk_of_type ty) m\n    (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)) = \n  Some v /\\ spec v","hypotheses":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec)","proofString":"replace (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)) with (Vptr sp (Ptrofs.repr ofs)).\neapply loadv_rule; eauto.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec) : exists v : val,\n  Mem.loadv (chunk_of_type ty) m (Vptr sp (Ptrofs.repr ofs)) = Some v /\\\n  spec v.","conclusion":"exists v : val,\n  Mem.loadv (chunk_of_type ty) m (Vptr sp (Ptrofs.repr ofs)) = Some v /\\\n  spec v","hypotheses":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec)","proofString":"eapply loadv_rule; eauto."},{"statement":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec) : Vptr sp (Ptrofs.repr ofs) =\nVal.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs).","conclusion":"Vptr sp (Ptrofs.repr ofs) =\nVal.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)","hypotheses":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec)","proofString":"simpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec) : Vptr sp (Ptrofs.repr ofs) =\nVptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.repr ofs)).","conclusion":"Vptr sp (Ptrofs.repr ofs) =\nVptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.repr ofs))","hypotheses":"(spec : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (H : m |= contains (chunk_of_type ty) sp ofs spec)","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(ty : typ) (m : mem) (sp : block) (ofs : Z) (v : val) (H : m |= hasvalue (chunk_of_type ty) sp ofs v) : load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v","hypotheses":"(ty : typ) (m : mem) (sp : block) (ofs : Z) (v : val) (H : m |= hasvalue (chunk_of_type ty) sp ofs v)","proofString":"exploit contains_get_stack; eauto.\nintros (v' & A & B).\ncongruence."},{"statement":"(ty : typ) (m : mem) (sp : block) (ofs : Z) (v : val) (H : m |= hasvalue (chunk_of_type ty) sp ofs v) : (exists v0 : val,\n   load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v0 /\\\n   (fun v' : val => v' = v) v0) ->\nload_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v.","conclusion":"(exists v0 : val,\n   load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v0 /\\\n   (fun v' : val => v' = v) v0) ->\nload_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v","hypotheses":"(ty : typ) (m : mem) (sp : block) (ofs : Z) (v : val) (H : m |= hasvalue (chunk_of_type ty) sp ofs v)","proofString":"intros (v' & A & B).\ncongruence."},{"statement":"(ty : typ) (m : mem) (sp : block) (ofs : Z) (v : val) (H : m |= hasvalue (chunk_of_type ty) sp ofs v) (v' : val) (A : load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v') (B : v' = v) : load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v","hypotheses":"(ty : typ) (m : mem) (sp : block) (ofs : Z) (v : val) (H : m |= hasvalue (chunk_of_type ty) sp ofs v) (v' : val) (A : load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) = Some v') (B : v' = v)","proofString":"congruence."},{"statement":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v)) : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) v = Some m' /\\\n  m' |= contains (chunk_of_type ty) sp ofs spec ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr ofs) v = Some m' /\\\n  m' |= contains (chunk_of_type ty) sp ofs spec ** P","hypotheses":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v))","proofString":"unfold store_stack.\nreplace (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)) with (Vptr sp (Ptrofs.repr ofs)).\neapply storev_rule; eauto.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v)) : exists m' : mem,\n  Mem.storev (chunk_of_type ty) m\n    (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)) v = \n  Some m' /\\ m' |= contains (chunk_of_type ty) sp ofs spec ** P.","conclusion":"exists m' : mem,\n  Mem.storev (chunk_of_type ty) m\n    (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)) v = \n  Some m' /\\ m' |= contains (chunk_of_type ty) sp ofs spec ** P","hypotheses":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v))","proofString":"replace (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)) with (Vptr sp (Ptrofs.repr ofs)).\neapply storev_rule; eauto.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v)) : exists m' : mem,\n  Mem.storev (chunk_of_type ty) m (Vptr sp (Ptrofs.repr ofs)) v = Some m' /\\\n  m' |= contains (chunk_of_type ty) sp ofs spec ** P.","conclusion":"exists m' : mem,\n  Mem.storev (chunk_of_type ty) m (Vptr sp (Ptrofs.repr ofs)) v = Some m' /\\\n  m' |= contains (chunk_of_type ty) sp ofs spec ** P","hypotheses":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v))","proofString":"eapply storev_rule; eauto."},{"statement":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v)) : Vptr sp (Ptrofs.repr ofs) =\nVal.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs).","conclusion":"Vptr sp (Ptrofs.repr ofs) =\nVal.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)","hypotheses":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v))","proofString":"simpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v)) : Vptr sp (Ptrofs.repr ofs) =\nVptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.repr ofs)).","conclusion":"Vptr sp (Ptrofs.repr ofs) =\nVptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.repr ofs))","hypotheses":"(spec : val -> Prop) (v : val) (spec1 : val -> Prop) (m : mem) (ty : typ) (sp : block) (ofs : Z) (P : massert) (H : m |= contains (chunk_of_type ty) sp ofs spec1 ** P) (H0 : spec (Val.load_result (chunk_of_type ty) v))","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : Mem.range_perm m sp (pos + 4 * ofs)\n  (pos + 4 * ofs + size_chunk (chunk_of_type ty)) Cur p.","conclusion":"Mem.range_perm m sp (pos + 4 * ofs)\n  (pos + 4 * ofs + size_chunk (chunk_of_type ty)) Cur p","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"red; intros.\napply Mem.perm_implies with Freeable; auto with mem.\napply H0.\nrewrite size_type_chunk, typesize_typesize in H4.\nlia."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (ofs0 : Z) (H4 : pos + 4 * ofs <= ofs0 < pos + 4 * ofs + size_chunk (chunk_of_type ty)) : Mem.perm m sp ofs0 Cur p.","conclusion":"Mem.perm m sp ofs0 Cur p","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (ofs0 : Z) (H4 : pos + 4 * ofs <= ofs0 < pos + 4 * ofs + size_chunk (chunk_of_type ty))","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\napply H0.\nrewrite size_type_chunk, typesize_typesize in H4.\nlia."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (ofs0 : Z) (H4 : pos + 4 * ofs <= ofs0 < pos + 4 * ofs + size_chunk (chunk_of_type ty)) : Mem.perm m sp ofs0 Cur Freeable.","conclusion":"Mem.perm m sp ofs0 Cur Freeable","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (ofs0 : Z) (H4 : pos + 4 * ofs <= ofs0 < pos + 4 * ofs + size_chunk (chunk_of_type ty))","proofString":"apply H0.\nrewrite size_type_chunk, typesize_typesize in H4.\nlia."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (ofs0 : Z) (H4 : pos + 4 * ofs <= ofs0 < pos + 4 * ofs + size_chunk (chunk_of_type ty)) : pos <= ofs0 < pos + 4 * bound.","conclusion":"pos <= ofs0 < pos + 4 * bound","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (ofs0 : Z) (H4 : pos + 4 * ofs <= ofs0 < pos + 4 * ofs + size_chunk (chunk_of_type ty))","proofString":"rewrite size_type_chunk, typesize_typesize in H4.\nlia."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (ofs0 : Z) (H4 : pos + 4 * ofs <= ofs0 < pos + 4 * ofs + 4 * typesize ty) : pos <= ofs0 < pos + 4 * bound.","conclusion":"pos <= ofs0 < pos + 4 * bound","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (ofs0 : Z) (H4 : pos + 4 * ofs <= ofs0 < pos + 4 * ofs + 4 * typesize ty)","proofString":"lia."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : (align_chunk (chunk_of_type ty) | pos + 4 * ofs).","conclusion":"(align_chunk (chunk_of_type ty) | pos + 4 * ofs)","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"rewrite align_type_chunk.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists (8 / (4 * typealign ty)); destruct ty; reflexivity.\napply Z.mul_divide_mono_l.\nauto."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : (4 * typealign ty | pos + 4 * ofs).","conclusion":"(4 * typealign ty | pos + 4 * ofs)","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"apply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists (8 / (4 * typealign ty)); destruct ty; reflexivity.\napply Z.mul_divide_mono_l.\nauto."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : (4 * typealign ty | pos).","conclusion":"(4 * typealign ty | pos)","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"apply Z.divide_trans with 8; auto.\nexists (8 / (4 * typealign ty)); destruct ty; reflexivity."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : (4 * typealign ty | 8).","conclusion":"(4 * typealign ty | 8)","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"exists (8 / (4 * typealign ty)); destruct ty; reflexivity."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : (4 * typealign ty | 4 * ofs).","conclusion":"(4 * typealign ty | 4 * ofs)","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"apply Z.mul_divide_mono_l.\nauto."},{"statement":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : (typealign ty | ofs).","conclusion":"(typealign ty | ofs)","hypotheses":"(m : mem) (sp : block) (pos bound ofs : Z) (ty : typ) (p : permission) (H : (8 | pos)) (H0 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H1 : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (H : m |= contains_locations j sp pos bound sl ls) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) =\n  Some v /\\ Val.inject j (ls (S sl ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) =\n  Some v /\\ Val.inject j (ls (S sl ofs ty)) v","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (H : m |= contains_locations j sp pos bound sl ls) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs))","proofString":"destruct H as (D & E & F & G & H).\nexploit H; eauto.\nintros (v & U & V).\nexists v; split; auto.\nunfold load_stack; simpl.\nrewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; auto.\nunfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) =\n  Some v /\\ Val.inject j (ls (S sl ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) =\n  Some v /\\ Val.inject j (ls (S sl ofs ty)) v","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs))","proofString":"exploit H; eauto.\nintros (v & U & V).\nexists v; split; auto.\nunfold load_stack; simpl.\nrewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; auto.\nunfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) : (exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v) ->\nexists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) =\n  Some v /\\ Val.inject j (ls (S sl ofs ty)) v.","conclusion":"(exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v) ->\nexists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) =\n  Some v /\\ Val.inject j (ls (S sl ofs ty)) v","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs))","proofString":"intros (v & U & V).\nexists v; split; auto.\nunfold load_stack; simpl.\nrewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; auto.\nunfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v) : exists v0 : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) =\n  Some v0 /\\ Val.inject j (ls (S sl ofs ty)) v0.","conclusion":"exists v0 : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) =\n  Some v0 /\\ Val.inject j (ls (S sl ofs ty)) v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v)","proofString":"exists v; split; auto.\nunfold load_stack; simpl.\nrewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; auto.\nunfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v) : load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) = Some v.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) = Some v","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v)","proofString":"unfold load_stack; simpl.\nrewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; auto.\nunfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v) : Mem.load (chunk_of_type ty) m sp\n  (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero (Ptrofs.repr (pos + 4 * ofs)))) =\nSome v.","conclusion":"Mem.load (chunk_of_type ty) m sp\n  (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero (Ptrofs.repr (pos + 4 * ofs)))) =\nSome v","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v)","proofString":"rewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; auto.\nunfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v) : 0 <= pos + 4 * ofs <= Ptrofs.max_unsigned.","conclusion":"0 <= pos + 4 * ofs <= Ptrofs.max_unsigned","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v)","proofString":"unfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v) : 0 <= pos + 4 * ofs <= Ptrofs.modulus - 1.","conclusion":"0 <= pos + 4 * ofs <= Ptrofs.modulus - 1","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v)","proofString":"generalize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v) : typesize ty > 0 -> 0 <= pos + 4 * ofs <= Ptrofs.modulus - 1.","conclusion":"typesize ty > 0 -> 0 <= pos + 4 * ofs <= Ptrofs.modulus - 1","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (ofs : Z) (ty : typ) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (v : val) (U : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (V : Val.inject j (ls (S sl ofs ty)) v)","proofString":"lia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (H : m |= contains_locations j sp pos bound sl ls ** P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) v' =\n  Some m' /\\\n  m'\n  |= contains_locations j sp pos bound sl (Locmap.set (S sl ofs ty) v ls) **\n     P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) v' =\n  Some m' /\\\n  m'\n  |= contains_locations j sp pos bound sl (Locmap.set (S sl ofs ty) v ls) **\n     P","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (H : m |= contains_locations j sp pos bound sl ls ** P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v')","proofString":"destruct H as (A & B & C).\ndestruct A as (D & E & F & G & H).\nedestruct Mem.valid_access_store as [m' STORE].\neapply valid_access_location; eauto.\nassert (PERM: Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable).\nred; intros; eauto with mem.\nexists m'; split.\nunfold store_stack; simpl.\nrewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; eauto.\nunfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia.\nsimpl.\nintuition auto.\nunfold Locmap.set.\ndestruct (Loc.eq (S sl ofs ty) (S sl ofs0 ty0)); [|destruct (Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0))].\ninv e.\nrename ofs0 into ofs.\nrename ty0 into ty.\nexists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto.\nexploit H; eauto.\nintros (v0 & X & Y).\nexists v0; split; auto.\nrewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia.\ndestruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].\napply Mem.valid_access_implies with Writable; auto with mem.\neapply valid_access_location; eauto.\nexists v''; auto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros i; rewrite size_type_chunk, typesize_typesize.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (A : m |= contains_locations j sp pos bound sl ls) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) v' =\n  Some m' /\\\n  m'\n  |= contains_locations j sp pos bound sl (Locmap.set (S sl ofs ty) v ls) **\n     P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) v' =\n  Some m' /\\\n  m'\n  |= contains_locations j sp pos bound sl (Locmap.set (S sl ofs ty) v ls) **\n     P","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (A : m |= contains_locations j sp pos bound sl ls) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v')","proofString":"destruct A as (D & E & F & G & H).\nedestruct Mem.valid_access_store as [m' STORE].\neapply valid_access_location; eauto.\nassert (PERM: Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable).\nred; intros; eauto with mem.\nexists m'; split.\nunfold store_stack; simpl.\nrewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; eauto.\nunfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia.\nsimpl.\nintuition auto.\nunfold Locmap.set.\ndestruct (Loc.eq (S sl ofs ty) (S sl ofs0 ty0)); [|destruct (Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0))].\ninv e.\nrename ofs0 into ofs.\nrename ty0 into ty.\nexists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto.\nexploit H; eauto.\nintros (v0 & X & Y).\nexists v0; split; auto.\nrewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia.\ndestruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].\napply Mem.valid_access_implies with Writable; auto with mem.\neapply valid_access_location; eauto.\nexists v''; auto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros i; rewrite size_type_chunk, typesize_typesize.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) v' =\n  Some m' /\\\n  m'\n  |= contains_locations j sp pos bound sl (Locmap.set (S sl ofs ty) v ls) **\n     P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) v' =\n  Some m' /\\\n  m'\n  |= contains_locations j sp pos bound sl (Locmap.set (S sl ofs ty) v ls) **\n     P","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v')","proofString":"edestruct Mem.valid_access_store as [m' STORE].\neapply valid_access_location; eauto.\nassert (PERM: Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable).\nred; intros; eauto with mem.\nexists m'; split.\nunfold store_stack; simpl.\nrewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; eauto.\nunfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia.\nsimpl.\nintuition auto.\nunfold Locmap.set.\ndestruct (Loc.eq (S sl ofs ty) (S sl ofs0 ty0)); [|destruct (Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0))].\ninv e.\nrename ofs0 into ofs.\nrename ty0 into ty.\nexists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto.\nexploit H; eauto.\nintros (v0 & X & Y).\nexists v0; split; auto.\nrewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia.\ndestruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].\napply Mem.valid_access_implies with Writable; auto with mem.\neapply valid_access_location; eauto.\nexists v''; auto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros i; rewrite size_type_chunk, typesize_typesize.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) : 0 <= pos + 4 * ofs <= Ptrofs.max_unsigned.","conclusion":"0 <= pos + 4 * ofs <= Ptrofs.max_unsigned","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable)","proofString":"unfold Ptrofs.max_unsigned.\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) : 0 <= pos + 4 * ofs <= Ptrofs.modulus - 1.","conclusion":"0 <= pos + 4 * ofs <= Ptrofs.modulus - 1","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable)","proofString":"generalize (typesize_pos ty).\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) : typesize ty > 0 -> 0 <= pos + 4 * ofs <= Ptrofs.modulus - 1.","conclusion":"typesize ty > 0 -> 0 <= pos + 4 * ofs <= Ptrofs.modulus - 1","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable)","proofString":"lia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) : ((8 | pos) /\\\n 0 <= pos /\\\n pos + 4 * bound <= Ptrofs.modulus /\\\n Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable /\\\n (forall (ofs0 : Z) (ty0 : typ),\n  0 <= ofs0 ->\n  ofs0 + typesize ty0 <= bound ->\n  (typealign ty0 | ofs0) ->\n  exists v0 : val,\n    Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n    Val.inject j (Locmap.set (S sl ofs ty) v ls (S sl ofs0 ty0)) v0)) /\\\nm' |= P /\\\ndisjoint_footprint\n  (contains_locations j sp pos bound sl (Locmap.set (S sl ofs ty) v ls)) P.","conclusion":"((8 | pos) /\\\n 0 <= pos /\\\n pos + 4 * bound <= Ptrofs.modulus /\\\n Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable /\\\n (forall (ofs0 : Z) (ty0 : typ),\n  0 <= ofs0 ->\n  ofs0 + typesize ty0 <= bound ->\n  (typealign ty0 | ofs0) ->\n  exists v0 : val,\n    Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n    Val.inject j (Locmap.set (S sl ofs ty) v ls (S sl ofs0 ty0)) v0)) /\\\nm' |= P /\\\ndisjoint_footprint\n  (contains_locations j sp pos bound sl (Locmap.set (S sl ofs ty) v ls)) P","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable)","proofString":"intuition auto.\nunfold Locmap.set.\ndestruct (Loc.eq (S sl ofs ty) (S sl ofs0 ty0)); [|destruct (Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0))].\ninv e.\nrename ofs0 into ofs.\nrename ty0 into ty.\nexists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto.\nexploit H; eauto.\nintros (v0 & X & Y).\nexists v0; split; auto.\nrewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia.\ndestruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].\napply Mem.valid_access_implies with Writable; auto with mem.\neapply valid_access_location; eauto.\nexists v''; auto.\napply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros i; rewrite size_type_chunk, typesize_typesize.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) : exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (Locmap.set (S sl ofs ty) v ls (S sl ofs0 ty0)) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (Locmap.set (S sl ofs ty) v ls (S sl ofs0 ty0)) v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0))","proofString":"unfold Locmap.set.\ndestruct (Loc.eq (S sl ofs ty) (S sl ofs0 ty0)); [|destruct (Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0))].\ninv e.\nrename ofs0 into ofs.\nrename ty0 into ty.\nexists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto.\nexploit H; eauto.\nintros (v0 & X & Y).\nexists v0; split; auto.\nrewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia.\ndestruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].\napply Mem.valid_access_implies with Writable; auto with mem.\neapply valid_access_location; eauto.\nexists v''; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) : exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j\n    (if Loc.eq (S sl ofs ty) (S sl ofs0 ty0)\n     then Val.load_result (chunk_of_type ty) v\n     else\n      if Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0)\n      then ls (S sl ofs0 ty0)\n      else Vundef) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j\n    (if Loc.eq (S sl ofs ty) (S sl ofs0 ty0)\n     then Val.load_result (chunk_of_type ty) v\n     else\n      if Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0)\n      then ls (S sl ofs0 ty0)\n      else Vundef) v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0))","proofString":"destruct (Loc.eq (S sl ofs ty) (S sl ofs0 ty0)); [|destruct (Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0))].\ninv e.\nrename ofs0 into ofs.\nrename ty0 into ty.\nexists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto.\nexploit H; eauto.\nintros (v0 & X & Y).\nexists v0; split; auto.\nrewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia.\ndestruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].\napply Mem.valid_access_implies with Writable; auto with mem.\neapply valid_access_location; eauto.\nexists v''; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (e : S sl ofs ty = S sl ofs0 ty0) : exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (Val.load_result (chunk_of_type ty) v) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (Val.load_result (chunk_of_type ty) v) v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (e : S sl ofs ty = S sl ofs0 ty0)","proofString":"inv e.\nrename ofs0 into ofs.\nrename ty0 into ty.\nexists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs : Z) (ty : typ),\n0 <= ofs ->\nofs + typesize ty <= bound ->\n(typealign ty | ofs) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (ls (S sl ofs ty)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs0 : Z) (ty0 : typ) (H1 : ofs0 + typesize ty0 <= bound) (H2 : (typealign ty0 | ofs0)) (H0 : 0 <= ofs0) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty0) m sp (pos + 4 * ofs0) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) : exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (Val.load_result (chunk_of_type ty0) v) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (Val.load_result (chunk_of_type ty0) v) v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs : Z) (ty : typ),\n0 <= ofs ->\nofs + typesize ty <= bound ->\n(typealign ty | ofs) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (ls (S sl ofs ty)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs0 : Z) (ty0 : typ) (H1 : ofs0 + typesize ty0 <= bound) (H2 : (typealign ty0 | ofs0)) (H0 : 0 <= ofs0) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty0) m sp (pos + 4 * ofs0) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0))","proofString":"rename ofs0 into ofs.\nrename ty0 into ty.\nexists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty : typ),\n0 <= ofs0 ->\nofs0 + typesize ty <= bound ->\n(typealign ty | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty0 : typ) (H1 : ofs + typesize ty0 <= bound) (H2 : (typealign ty0 | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty0) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs)) : exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (Val.load_result (chunk_of_type ty0) v) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (Val.load_result (chunk_of_type ty0) v) v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty : typ),\n0 <= ofs0 ->\nofs0 + typesize ty <= bound ->\n(typealign ty | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty0 : typ) (H1 : ofs + typesize ty0 <= bound) (H2 : (typealign ty0 | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty0) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs))","proofString":"rename ty0 into ty.\nexists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty : typ) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty <= bound) (H6 : (typealign ty | ofs)) : exists v0 : val,\n  Mem.load (chunk_of_type ty) m' sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (Val.load_result (chunk_of_type ty) v) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty) m' sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (Val.load_result (chunk_of_type ty) v) v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty : typ) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty <= bound) (H6 : (typealign ty | ofs))","proofString":"exists (Val.load_result (chunk_of_type ty) v'); split.\neapply Mem.load_store_similar_2; eauto.\nlia.\napply Val.load_result_inject; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty : typ) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty <= bound) (H6 : (typealign ty | ofs)) : Mem.load (chunk_of_type ty) m' sp (pos + 4 * ofs) =\nSome (Val.load_result (chunk_of_type ty) v').","conclusion":"Mem.load (chunk_of_type ty) m' sp (pos + 4 * ofs) =\nSome (Val.load_result (chunk_of_type ty) v')","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty : typ) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty <= bound) (H6 : (typealign ty | ofs))","proofString":"eapply Mem.load_store_similar_2; eauto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty : typ) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty <= bound) (H6 : (typealign ty | ofs)) : align_chunk (chunk_of_type ty) <= align_chunk (chunk_of_type ty).","conclusion":"align_chunk (chunk_of_type ty) <= align_chunk (chunk_of_type ty)","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty : typ) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty <= bound) (H6 : (typealign ty | ofs))","proofString":"lia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty : typ) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty <= bound) (H6 : (typealign ty | ofs)) : Val.inject j (Val.load_result (chunk_of_type ty) v)\n  (Val.load_result (chunk_of_type ty) v').","conclusion":"Val.inject j (Val.load_result (chunk_of_type ty) v)\n  (Val.load_result (chunk_of_type ty) v')","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (ofs : Z) (ty : typ) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H0 : 0 <= ofs) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (H4 : 0 <= ofs) (H5 : ofs + typesize ty <= bound) (H6 : (typealign ty | ofs))","proofString":"apply Val.load_result_inject; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) : exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0))","proofString":"exploit H; eauto.\nintros (v0 & X & Y).\nexists v0; split; auto.\nrewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) : (exists v0 : val,\n   Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n   Val.inject j (ls (S sl ofs0 ty0)) v0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0.","conclusion":"(exists v0 : val,\n   Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n   Val.inject j (ls (S sl ofs0 ty0)) v0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0))","proofString":"intros (v0 & X & Y).\nexists v0; split; auto.\nrewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0) : exists v1 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v1 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v1.","conclusion":"exists v1 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v1 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v1","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0)","proofString":"exists v0; split; auto.\nrewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0) : Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0.","conclusion":"Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0)","proofString":"rewrite <- X; eapply Mem.load_store_other; eauto.\ndestruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0) : sp <> sp \\/\npos + 4 * ofs0 + size_chunk (chunk_of_type ty0) <= pos + 4 * ofs \\/\npos + 4 * ofs + size_chunk (chunk_of_type ty) <= pos + 4 * ofs0.","conclusion":"sp <> sp \\/\npos + 4 * ofs0 + size_chunk (chunk_of_type ty0) <= pos + 4 * ofs \\/\npos + 4 * ofs + size_chunk (chunk_of_type ty) <= pos + 4 * ofs0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (d : Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0)","proofString":"destruct d.\ncongruence.\nright.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (H7 : sl <> sl) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0) : sp <> sp \\/\npos + 4 * ofs0 + size_chunk (chunk_of_type ty0) <= pos + 4 * ofs \\/\npos + 4 * ofs + size_chunk (chunk_of_type ty) <= pos + 4 * ofs0.","conclusion":"sp <> sp \\/\npos + 4 * ofs0 + size_chunk (chunk_of_type ty0) <= pos + 4 * ofs \\/\npos + 4 * ofs + size_chunk (chunk_of_type ty) <= pos + 4 * ofs0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (H7 : sl <> sl) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0)","proofString":"congruence."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (H7 : ofs + typesize ty <= ofs0 \\/ ofs0 + typesize ty0 <= ofs) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0) : sp <> sp \\/\npos + 4 * ofs0 + size_chunk (chunk_of_type ty0) <= pos + 4 * ofs \\/\npos + 4 * ofs + size_chunk (chunk_of_type ty) <= pos + 4 * ofs0.","conclusion":"sp <> sp \\/\npos + 4 * ofs0 + size_chunk (chunk_of_type ty0) <= pos + 4 * ofs \\/\npos + 4 * ofs + size_chunk (chunk_of_type ty) <= pos + 4 * ofs0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (H7 : ofs + typesize ty <= ofs0 \\/ ofs0 + typesize ty0 <= ofs) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0)","proofString":"right.\nrewrite ! size_type_chunk, ! typesize_typesize.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (H7 : ofs + typesize ty <= ofs0 \\/ ofs0 + typesize ty0 <= ofs) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0) : pos + 4 * ofs0 + size_chunk (chunk_of_type ty0) <= pos + 4 * ofs \\/\npos + 4 * ofs + size_chunk (chunk_of_type ty) <= pos + 4 * ofs0.","conclusion":"pos + 4 * ofs0 + size_chunk (chunk_of_type ty0) <= pos + 4 * ofs \\/\npos + 4 * ofs + size_chunk (chunk_of_type ty) <= pos + 4 * ofs0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (H7 : ofs + typesize ty <= ofs0 \\/ ofs0 + typesize ty0 <= ofs) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0)","proofString":"rewrite ! size_type_chunk, ! typesize_typesize.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (H7 : ofs + typesize ty <= ofs0 \\/ ofs0 + typesize ty0 <= ofs) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0) : pos + 4 * ofs0 + 4 * typesize ty0 <= pos + 4 * ofs \\/\npos + 4 * ofs + 4 * typesize ty <= pos + 4 * ofs0.","conclusion":"pos + 4 * ofs0 + 4 * typesize ty0 <= pos + 4 * ofs \\/\npos + 4 * ofs + 4 * typesize ty <= pos + 4 * ofs0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v1 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v1 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v1) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (H7 : ofs + typesize ty <= ofs0 \\/ ofs0 + typesize ty0 <= ofs) (v0 : val) (X : Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0) (Y : Val.inject j (ls (S sl ofs0 ty0)) v0)","proofString":"lia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (n0 : ~ Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) : exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j Vundef v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j Vundef v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (n0 : ~ Loc.diff (S sl ofs ty) (S sl ofs0 ty0))","proofString":"destruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].\napply Mem.valid_access_implies with Writable; auto with mem.\neapply valid_access_location; eauto.\nexists v''; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (n0 : ~ Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) : Mem.valid_access m' (chunk_of_type ty0) sp (pos + 4 * ofs0) Readable.","conclusion":"Mem.valid_access m' (chunk_of_type ty0) sp (pos + 4 * ofs0) Readable","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (n0 : ~ Loc.diff (S sl ofs ty) (S sl ofs0 ty0))","proofString":"apply Mem.valid_access_implies with Writable; auto with mem.\neapply valid_access_location; eauto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (n0 : ~ Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) : Mem.valid_access m' (chunk_of_type ty0) sp (pos + 4 * ofs0) Writable.","conclusion":"Mem.valid_access m' (chunk_of_type ty0) sp (pos + 4 * ofs0) Writable","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (n0 : ~ Loc.diff (S sl ofs ty) (S sl ofs0 ty0))","proofString":"eapply valid_access_location; eauto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (n0 : ~ Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) (v'' : val) (LOAD : Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v'') : exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j Vundef v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j Vundef v0","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs1 : Z) (ty1 : typ),\n0 <= ofs1 ->\nofs1 + typesize ty1 <= bound ->\n(typealign ty1 | ofs1) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty1) m sp (pos + 4 * ofs1) = Some v0 /\\\n  Val.inject j (ls (S sl ofs1 ty1)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (ofs0 : Z) (ty0 : typ) (H4 : 0 <= ofs0) (H5 : ofs0 + typesize ty0 <= bound) (H6 : (typealign ty0 | ofs0)) (n : S sl ofs ty <> S sl ofs0 ty0) (n0 : ~ Loc.diff (S sl ofs ty) (S sl ofs0 ty0)) (v'' : val) (LOAD : Mem.load (chunk_of_type ty0) m' sp (pos + 4 * ofs0) = Some v'')","proofString":"exists v''; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) : m' |= P.","conclusion":"m' |= P","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable)","proofString":"apply (m_invar P) with m; auto.\neapply Mem.store_unchanged_on; eauto.\nintros i; rewrite size_type_chunk, typesize_typesize.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) : Mem.unchanged_on (m_footprint P) m m'.","conclusion":"Mem.unchanged_on (m_footprint P) m m'","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable)","proofString":"eapply Mem.store_unchanged_on; eauto.\nintros i; rewrite size_type_chunk, typesize_typesize.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) : forall i : Z,\npos + 4 * ofs <= i < pos + 4 * ofs + size_chunk (chunk_of_type ty) ->\n~ m_footprint P sp i.","conclusion":"forall i : Z,\npos + 4 * ofs <= i < pos + 4 * ofs + size_chunk (chunk_of_type ty) ->\n~ m_footprint P sp i","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable)","proofString":"intros i; rewrite size_type_chunk, typesize_typesize.\nintros; red; intros.\neelim C; eauto.\nsimpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z) : pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty -> ~ m_footprint P sp i.","conclusion":"pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty -> ~ m_footprint P sp i","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z)","proofString":"intros; red; intros.\neelim C; eauto.\nsimpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z) (H4 : pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty) (H5 : m_footprint P sp i) : False.","conclusion":"False","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z) (H4 : pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty) (H5 : m_footprint P sp i)","proofString":"eelim C; eauto.\nsimpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z) (H4 : pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty) (H5 : m_footprint P sp i) : m_footprint (contains_locations j sp pos bound sl ls) sp i.","conclusion":"m_footprint (contains_locations j sp pos bound sl ls) sp i","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z) (H4 : pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty) (H5 : m_footprint P sp i)","proofString":"simpl.\nsplit; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z) (H4 : pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty) (H5 : m_footprint P sp i) : sp = sp /\\ pos <= i < pos + 4 * bound.","conclusion":"sp = sp /\\ pos <= i < pos + 4 * bound","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z) (H4 : pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty) (H5 : m_footprint P sp i)","proofString":"split; auto.\nlia."},{"statement":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z) (H4 : pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty) (H5 : m_footprint P sp i) : pos <= i < pos + 4 * bound.","conclusion":"pos <= i < pos + 4 * bound","hypotheses":"(m : mem) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (P : massert) (ofs : Z) (ty : typ) (v v' : val) (D : (8 | pos)) (E : 0 <= pos) (F : pos + 4 * bound <= Ptrofs.modulus) (G : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (B : m |= P) (C : disjoint_footprint (contains_locations j sp pos bound sl ls) P) (H0 : 0 <= ofs) (H1 : ofs + typesize ty <= bound) (H2 : (typealign ty | ofs)) (H3 : Val.inject j v v') (m' : mem) (STORE : Mem.store (chunk_of_type ty) m sp (pos + 4 * ofs) v' = Some m') (PERM : Mem.range_perm m' sp pos (pos + 4 * bound) Cur Freeable) (i : Z) (H4 : pos + 4 * ofs <= i < pos + 4 * ofs + 4 * typesize ty) (H5 : m_footprint P sp i)","proofString":"lia."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (H : m |= range sp pos (pos + 4 * bound) ** P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef) : m |= contains_locations j sp pos bound sl ls ** P.","conclusion":"m |= contains_locations j sp pos bound sl ls ** P","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (H : m |= range sp pos (pos + 4 * bound) ** P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef)","proofString":"destruct H as (A & B & C).\ndestruct A as (D & E & F).\nsplit.\nsimpl; intuition auto.\nred; intros; eauto with mem.\ndestruct (Mem.valid_access_load m (chunk_of_type ty) sp (pos + 4 * ofs)) as [v LOAD].\neapply valid_access_location; eauto.\nred; intros; eauto with mem.\nexists v; split; auto.\nrewrite H1; auto.\nsplit; assumption."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (A : m |= range sp pos (pos + 4 * bound)) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef) : m |= contains_locations j sp pos bound sl ls ** P.","conclusion":"m |= contains_locations j sp pos bound sl ls ** P","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (A : m |= range sp pos (pos + 4 * bound)) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef)","proofString":"destruct A as (D & E & F).\nsplit.\nsimpl; intuition auto.\nred; intros; eauto with mem.\ndestruct (Mem.valid_access_load m (chunk_of_type ty) sp (pos + 4 * ofs)) as [v LOAD].\neapply valid_access_location; eauto.\nred; intros; eauto with mem.\nexists v; split; auto.\nrewrite H1; auto.\nsplit; assumption."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef) : m |= contains_locations j sp pos bound sl ls ** P.","conclusion":"m |= contains_locations j sp pos bound sl ls ** P","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef)","proofString":"split.\nsimpl; intuition auto.\nred; intros; eauto with mem.\ndestruct (Mem.valid_access_load m (chunk_of_type ty) sp (pos + 4 * ofs)) as [v LOAD].\neapply valid_access_location; eauto.\nred; intros; eauto with mem.\nexists v; split; auto.\nrewrite H1; auto.\nsplit; assumption."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef) : m |= contains_locations j sp pos bound sl ls.","conclusion":"m |= contains_locations j sp pos bound sl ls","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef)","proofString":"simpl; intuition auto.\nred; intros; eauto with mem.\ndestruct (Mem.valid_access_load m (chunk_of_type ty) sp (pos + 4 * ofs)) as [v LOAD].\neapply valid_access_location; eauto.\nred; intros; eauto with mem.\nexists v; split; auto.\nrewrite H1; auto."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef) (X : state -> trace -> state -> Prop) : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable.","conclusion":"Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef) (X : state -> trace -> state -> Prop)","proofString":"red; intros; eauto with mem."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : exists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j (ls (S sl ofs ty)) v.","conclusion":"exists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j (ls (S sl ofs ty)) v","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"destruct (Mem.valid_access_load m (chunk_of_type ty) sp (pos + 4 * ofs)) as [v LOAD].\neapply valid_access_location; eauto.\nred; intros; eauto with mem.\nexists v; split; auto.\nrewrite H1; auto."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : Mem.valid_access m (chunk_of_type ty) sp (pos + 4 * ofs) Readable.","conclusion":"Mem.valid_access m (chunk_of_type ty) sp (pos + 4 * ofs) Readable","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"eapply valid_access_location; eauto.\nred; intros; eauto with mem."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable.","conclusion":"Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs))","proofString":"red; intros; eauto with mem."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (v : val) (LOAD : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) : exists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (ls (S sl ofs ty)) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (ls (S sl ofs ty)) v0","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (v : val) (LOAD : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v)","proofString":"exists v; split; auto.\nrewrite H1; auto."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (v : val) (LOAD : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) : Val.inject j (ls (S sl ofs ty)) v.","conclusion":"Val.inject j (ls (S sl ofs ty)) v","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs0 : Z) (ty0 : typ), ls (S sl ofs0 ty0) = Vundef) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H : 0 <= ofs) (H2 : ofs + typesize ty <= bound) (H3 : (typealign ty | ofs)) (v : val) (LOAD : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v)","proofString":"rewrite H1; auto."},{"statement":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef) : m |= P /\\ disjoint_footprint (contains_locations j sp pos bound sl ls) P.","conclusion":"m |= P /\\ disjoint_footprint (contains_locations j sp pos bound sl ls) P","hypotheses":"(j : meminj) (sp : block) (pos bound : Z) (P : massert) (sl : slot) (ls : loc -> val) (m : mem) (D : 0 <= pos) (E : pos + 4 * bound <= Ptrofs.modulus) (F : forall (i : Z) (k : perm_kind) (p : permission),\npos <= i < pos + 4 * bound -> Mem.perm m sp i k p) (B : m |= P) (C : disjoint_footprint (range sp pos (pos + 4 * bound)) P) (H0 : (8 | pos)) (H1 : forall (ofs : Z) (ty : typ), ls (S sl ofs ty) = Vundef)","proofString":"split; assumption."},{"statement":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S sl ofs ty)) (ls (S sl ofs ty))) (m : mem) (H0 : (8 | pos) /\\\n0 <= pos /\\\npos + 4 * bound <= Ptrofs.modulus /\\\nMem.range_perm m sp pos (pos + 4 * bound) Cur Freeable /\\\n(forall (ofs : Z) (ty : typ),\n 0 <= ofs ->\n ofs + typesize ty <= bound ->\n (typealign ty | ofs) ->\n exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v)) : (8 | pos) /\\\n0 <= pos /\\\npos + 4 * bound <= Ptrofs.modulus /\\\nMem.range_perm m sp pos (pos + 4 * bound) Cur Freeable /\\\n(forall (ofs : Z) (ty : typ),\n 0 <= ofs ->\n ofs + typesize ty <= bound ->\n (typealign ty | ofs) ->\n exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls' (S sl ofs ty)) v).","conclusion":"(8 | pos) /\\\n0 <= pos /\\\npos + 4 * bound <= Ptrofs.modulus /\\\nMem.range_perm m sp pos (pos + 4 * bound) Cur Freeable /\\\n(forall (ofs : Z) (ty : typ),\n 0 <= ofs ->\n ofs + typesize ty <= bound ->\n (typealign ty | ofs) ->\n exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls' (S sl ofs ty)) v)","hypotheses":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S sl ofs ty)) (ls (S sl ofs ty))) (m : mem) (H0 : (8 | pos) /\\\n0 <= pos /\\\npos + 4 * bound <= Ptrofs.modulus /\\\nMem.range_perm m sp pos (pos + 4 * bound) Cur Freeable /\\\n(forall (ofs : Z) (ty : typ),\n 0 <= ofs ->\n ofs + typesize ty <= bound ->\n (typealign ty | ofs) ->\n exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v))","proofString":"intuition auto.\nexploit H5; eauto.\nintros (v & A & B).\nexists v; split; auto.\nspecialize (H ofs ty).\ninv H.\ncongruence.\nauto."},{"statement":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs0 : Z) (ty0 : typ),\nVal.lessdef (ls' (S sl ofs0 ty0)) (ls (S sl ofs0 ty0))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) : exists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j (ls' (S sl ofs ty)) v.","conclusion":"exists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j (ls' (S sl ofs ty)) v","hypotheses":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs0 : Z) (ty0 : typ),\nVal.lessdef (ls' (S sl ofs0 ty0)) (ls (S sl ofs0 ty0))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs))","proofString":"exploit H5; eauto.\nintros (v & A & B).\nexists v; split; auto.\nspecialize (H ofs ty).\ninv H.\ncongruence.\nauto."},{"statement":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs0 : Z) (ty0 : typ),\nVal.lessdef (ls' (S sl ofs0 ty0)) (ls (S sl ofs0 ty0))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) : (exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v) ->\nexists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j (ls' (S sl ofs ty)) v.","conclusion":"(exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v) ->\nexists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j (ls' (S sl ofs ty)) v","hypotheses":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs0 : Z) (ty0 : typ),\nVal.lessdef (ls' (S sl ofs0 ty0)) (ls (S sl ofs0 ty0))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs))","proofString":"intros (v & A & B).\nexists v; split; auto.\nspecialize (H ofs ty).\ninv H.\ncongruence.\nauto."},{"statement":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs0 : Z) (ty0 : typ),\nVal.lessdef (ls' (S sl ofs0 ty0)) (ls (S sl ofs0 ty0))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v) : exists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (ls' (S sl ofs ty)) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j (ls' (S sl ofs ty)) v0","hypotheses":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs0 : Z) (ty0 : typ),\nVal.lessdef (ls' (S sl ofs0 ty0)) (ls (S sl ofs0 ty0))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v)","proofString":"exists v; split; auto.\nspecialize (H ofs ty).\ninv H.\ncongruence.\nauto."},{"statement":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs0 : Z) (ty0 : typ),\nVal.lessdef (ls' (S sl ofs0 ty0)) (ls (S sl ofs0 ty0))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v) : Val.inject j (ls' (S sl ofs ty)) v.","conclusion":"Val.inject j (ls' (S sl ofs ty)) v","hypotheses":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (H : forall (ofs0 : Z) (ty0 : typ),\nVal.lessdef (ls' (S sl ofs0 ty0)) (ls (S sl ofs0 ty0))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v)","proofString":"specialize (H ofs ty).\ninv H.\ncongruence.\nauto."},{"statement":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ofs : Z) (ty : typ) (H : Val.lessdef (ls' (S sl ofs ty)) (ls (S sl ofs ty))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v) : Val.inject j (ls' (S sl ofs ty)) v.","conclusion":"Val.inject j (ls' (S sl ofs ty)) v","hypotheses":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ofs : Z) (ty : typ) (H : Val.lessdef (ls' (S sl ofs ty)) (ls (S sl ofs ty))) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v)","proofString":"inv H.\ncongruence.\nauto."},{"statement":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ofs : Z) (ty : typ) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v) (H10 : ls' (S sl ofs ty) = ls (S sl ofs ty)) : Val.inject j (ls' (S sl ofs ty)) v.","conclusion":"Val.inject j (ls' (S sl ofs ty)) v","hypotheses":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ofs : Z) (ty : typ) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v) (H10 : ls' (S sl ofs ty) = ls (S sl ofs ty))","proofString":"congruence."},{"statement":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ofs : Z) (ty : typ) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v) (H9 : Vundef = ls' (S sl ofs ty)) : Val.inject j Vundef v.","conclusion":"Val.inject j Vundef v","hypotheses":"(ls ls' : loc -> val) (j : meminj) (sp : block) (pos bound : Z) (sl : slot) (ofs : Z) (ty : typ) (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v) (H9 : Vundef = ls' (S sl ofs ty))","proofString":"auto."},{"statement":"(j j' : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (H : inject_incr j j') (m : mem) (H0 : (8 | pos) /\\\n0 <= pos /\\\npos + 4 * bound <= Ptrofs.modulus /\\\nMem.range_perm m sp pos (pos + 4 * bound) Cur Freeable /\\\n(forall (ofs : Z) (ty : typ),\n 0 <= ofs ->\n ofs + typesize ty <= bound ->\n (typealign ty | ofs) ->\n exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v)) : (8 | pos) /\\\n0 <= pos /\\\npos + 4 * bound <= Ptrofs.modulus /\\\nMem.range_perm m sp pos (pos + 4 * bound) Cur Freeable /\\\n(forall (ofs : Z) (ty : typ),\n 0 <= ofs ->\n ofs + typesize ty <= bound ->\n (typealign ty | ofs) ->\n exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j' (ls (S sl ofs ty)) v).","conclusion":"(8 | pos) /\\\n0 <= pos /\\\npos + 4 * bound <= Ptrofs.modulus /\\\nMem.range_perm m sp pos (pos + 4 * bound) Cur Freeable /\\\n(forall (ofs : Z) (ty : typ),\n 0 <= ofs ->\n ofs + typesize ty <= bound ->\n (typealign ty | ofs) ->\n exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j' (ls (S sl ofs ty)) v)","hypotheses":"(j j' : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (H : inject_incr j j') (m : mem) (H0 : (8 | pos) /\\\n0 <= pos /\\\npos + 4 * bound <= Ptrofs.modulus /\\\nMem.range_perm m sp pos (pos + 4 * bound) Cur Freeable /\\\n(forall (ofs : Z) (ty : typ),\n 0 <= ofs ->\n ofs + typesize ty <= bound ->\n (typealign ty | ofs) ->\n exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v))","proofString":"intuition auto.\nexploit H5; eauto.\nintros (v & A & B).\nexists v; eauto."},{"statement":"(j j' : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (H : inject_incr j j') (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) : exists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j' (ls (S sl ofs ty)) v.","conclusion":"exists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j' (ls (S sl ofs ty)) v","hypotheses":"(j j' : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (H : inject_incr j j') (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs))","proofString":"exploit H5; eauto.\nintros (v & A & B).\nexists v; eauto."},{"statement":"(j j' : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (H : inject_incr j j') (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) : (exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v) ->\nexists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j' (ls (S sl ofs ty)) v.","conclusion":"(exists v : val,\n   Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n   Val.inject j (ls (S sl ofs ty)) v) ->\nexists v : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v /\\\n  Val.inject j' (ls (S sl ofs ty)) v","hypotheses":"(j j' : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (H : inject_incr j j') (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs))","proofString":"intros (v & A & B).\nexists v; eauto."},{"statement":"(j j' : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (H : inject_incr j j') (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v) : exists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j' (ls (S sl ofs ty)) v0.","conclusion":"exists v0 : val,\n  Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v0 /\\\n  Val.inject j' (ls (S sl ofs ty)) v0","hypotheses":"(j j' : meminj) (sp : block) (pos bound : Z) (sl : slot) (ls : locset) (H : inject_incr j j') (m : mem) (H1 : (8 | pos)) (H0 : 0 <= pos) (H2 : pos + 4 * bound <= Ptrofs.modulus) (H3 : Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable) (H5 : forall (ofs0 : Z) (ty0 : typ),\n0 <= ofs0 ->\nofs0 + typesize ty0 <= bound ->\n(typealign ty0 | ofs0) ->\nexists v0 : val,\n  Mem.load (chunk_of_type ty0) m sp (pos + 4 * ofs0) = Some v0 /\\\n  Val.inject j (ls (S sl ofs0 ty0)) v0) (X : state -> trace -> state -> Prop) (ofs : Z) (ty : typ) (H4 : 0 <= ofs) (H6 : ofs + typesize ty <= bound) (H7 : (typealign ty | ofs)) (v : val) (A : Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v) (B : Val.inject j (ls (S sl ofs ty)) v)","proofString":"exists v; eauto."},{"statement":"(j j' : meminj) (sp : block) (ls : locset) (H : inject_incr j j') (pos : Z) : massert_imp (pure True) (pure True).","conclusion":"massert_imp (pure True) (pure True)","hypotheses":"(j j' : meminj) (sp : block) (ls : locset) (H : inject_incr j j') (pos : Z)","proofString":"reflexivity."},{"statement":"(j j' : meminj) (sp : block) (ls : locset) (H : inject_incr j j') (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\nmassert_imp (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j' sp pos0 rl ls)) (pos : Z) : massert_imp\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v) **\n   contains_callee_saves j sp (align pos 8 + 8) rl ls)\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j' (ls (R r1)) v) **\n   contains_callee_saves j' sp (align pos 8 + 8) rl ls).","conclusion":"massert_imp\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v) **\n   contains_callee_saves j sp (align pos 8 + 8) rl ls)\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j' (ls (R r1)) v) **\n   contains_callee_saves j' sp (align pos 8 + 8) rl ls)","hypotheses":"(j j' : meminj) (sp : block) (ls : locset) (H : inject_incr j j') (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\nmassert_imp (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j' sp pos0 rl ls)) (pos : Z)","proofString":"apply sepconj_morph_1; auto.\napply contains_imp.\neauto."},{"statement":"(j j' : meminj) (sp : block) (ls : locset) (H : inject_incr j j') (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\nmassert_imp (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j' sp pos0 rl ls)) (pos : Z) : massert_imp\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v))\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j' (ls (R r1)) v)).","conclusion":"massert_imp\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v))\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j' (ls (R r1)) v))","hypotheses":"(j j' : meminj) (sp : block) (ls : locset) (H : inject_incr j j') (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\nmassert_imp (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j' sp pos0 rl ls)) (pos : Z)","proofString":"apply contains_imp.\neauto."},{"statement":"(j j' : meminj) (sp : block) (ls : locset) (H : inject_incr j j') (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\nmassert_imp (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j' sp pos0 rl ls)) (pos : Z) : forall v : val, Val.inject j (ls (R r1)) v -> Val.inject j' (ls (R r1)) v.","conclusion":"forall v : val, Val.inject j (ls (R r1)) v -> Val.inject j' (ls (R r1)) v","hypotheses":"(j j' : meminj) (sp : block) (ls : locset) (H : inject_incr j j') (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\nmassert_imp (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j' sp pos0 rl ls)) (pos : Z)","proofString":"eauto."},{"statement":"(j : meminj) (sp : block) (ls ls' : loc -> val) (pos : Z) (H : forall r : mreg, False -> ls' (R r) = ls (R r)) : massert_eqv (pure True) (pure True).","conclusion":"massert_eqv (pure True) (pure True)","hypotheses":"(j : meminj) (sp : block) (ls ls' : loc -> val) (pos : Z) (H : forall r : mreg, False -> ls' (R r) = ls (R r))","proofString":"reflexivity."},{"statement":"(j : meminj) (sp : block) (ls ls' : loc -> val) (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\n(forall r : mreg, In r rl -> ls' (R r) = ls (R r)) ->\nmassert_eqv (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j sp pos0 rl ls')) (pos : Z) (H : forall r : mreg, r1 = r \\/ In r rl -> ls' (R r) = ls (R r)) : massert_eqv\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v) **\n   contains_callee_saves j sp (align pos 8 + 8) rl ls)\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls' (R r1)) v) **\n   contains_callee_saves j sp (align pos 8 + 8) rl ls').","conclusion":"massert_eqv\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v) **\n   contains_callee_saves j sp (align pos 8 + 8) rl ls)\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls' (R r1)) v) **\n   contains_callee_saves j sp (align pos 8 + 8) rl ls')","hypotheses":"(j : meminj) (sp : block) (ls ls' : loc -> val) (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\n(forall r : mreg, In r rl -> ls' (R r) = ls (R r)) ->\nmassert_eqv (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j sp pos0 rl ls')) (pos : Z) (H : forall r : mreg, r1 = r \\/ In r rl -> ls' (R r) = ls (R r))","proofString":"apply sepconj_morph_2; auto.\nrewrite H by auto.\nreflexivity."},{"statement":"(j : meminj) (sp : block) (ls ls' : loc -> val) (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\n(forall r : mreg, In r rl -> ls' (R r) = ls (R r)) ->\nmassert_eqv (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j sp pos0 rl ls')) (pos : Z) (H : forall r : mreg, r1 = r \\/ In r rl -> ls' (R r) = ls (R r)) : massert_eqv\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v))\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls' (R r1)) v)).","conclusion":"massert_eqv\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v))\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls' (R r1)) v))","hypotheses":"(j : meminj) (sp : block) (ls ls' : loc -> val) (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\n(forall r : mreg, In r rl -> ls' (R r) = ls (R r)) ->\nmassert_eqv (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j sp pos0 rl ls')) (pos : Z) (H : forall r : mreg, r1 = r \\/ In r rl -> ls' (R r) = ls (R r))","proofString":"rewrite H by auto.\nreflexivity."},{"statement":"(j : meminj) (sp : block) (ls ls' : loc -> val) (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\n(forall r : mreg, In r rl -> ls' (R r) = ls (R r)) ->\nmassert_eqv (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j sp pos0 rl ls')) (pos : Z) (H : forall r : mreg, r1 = r \\/ In r rl -> ls' (R r) = ls (R r)) : massert_eqv\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v))\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v)).","conclusion":"massert_eqv\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v))\n  (contains Many64 sp (align pos 8)\n     (fun v : val => Val.inject j (ls (R r1)) v))","hypotheses":"(j : meminj) (sp : block) (ls ls' : loc -> val) (r1 : mreg) (rl : list mreg) (IHrl : forall pos0 : Z,\n(forall r : mreg, In r rl -> ls' (R r) = ls (R r)) ->\nmassert_eqv (contains_callee_saves j sp pos0 rl ls)\n  (contains_callee_saves j sp pos0 rl ls')) (pos : Z) (H : forall r : mreg, r1 = r \\/ In r rl -> ls' (R r) = ls (R r))","proofString":"reflexivity."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true)","proofString":"unfold slot_valid in H1; InvBooleans.\napply mconj_proj1 in H.\napply sep_proj1 in H.\napply sep_proj1 in H.\neapply get_location; eauto."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs)","proofString":"apply mconj_proj1 in H.\napply sep_proj1 in H.\napply sep_proj1 in H.\neapply get_location; eauto."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs)","proofString":"apply sep_proj1 in H.\napply sep_proj1 in H.\neapply get_location; eauto."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : slot_within_bounds b Local ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : slot_within_bounds b Local ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs)","proofString":"apply sep_proj1 in H.\neapply get_location; eauto."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls) (H0 : slot_within_bounds b Local ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs)) =\n  Some v /\\ Val.inject j (ls (S Local ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls) (H0 : slot_within_bounds b Local ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs)","proofString":"eapply get_location; eauto."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true)","proofString":"unfold slot_valid in H1; InvBooleans.\napply mconj_proj1 in H.\napply sep_proj1 in H.\napply sep_pick2 in H.\neapply get_location; eauto."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs)","proofString":"apply mconj_proj1 in H.\napply sep_proj1 in H.\napply sep_pick2 in H.\neapply get_location; eauto."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs)","proofString":"apply sep_proj1 in H.\napply sep_pick2 in H.\neapply get_location; eauto."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs)","proofString":"apply sep_pick2 in H.\neapply get_location; eauto."},{"statement":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs) : exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v.","conclusion":"exists v : val,\n  load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n  Some v /\\ Val.inject j (ls (S Outgoing ofs ty)) v","hypotheses":"(ofs : Z) (ty : typ) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : (typealign ty | ofs)) (H2 : 0 <= ofs)","proofString":"eapply get_location; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P)","proofString":"apply mconj_proj1 in H.\napply sep_proj1 in H.\napply sep_pick3 in H.\nrewrite <- chunk_of_Tptr in H.\neapply hasvalue_get_stack; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P)","proofString":"apply sep_proj1 in H.\napply sep_pick3 in H.\nrewrite <- chunk_of_Tptr in H.\neapply hasvalue_get_stack; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0)","proofString":"apply sep_pick3 in H.\nrewrite <- chunk_of_Tptr in H.\neapply hasvalue_get_stack; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= hasvalue Mptr sp (fe_ofs_link fe) parent) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= hasvalue Mptr sp (fe_ofs_link fe) parent)","proofString":"rewrite <- chunk_of_Tptr in H.\neapply hasvalue_get_stack; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= hasvalue (chunk_of_type Tptr) sp (fe_ofs_link fe) parent) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome parent","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= hasvalue (chunk_of_type Tptr) sp (fe_ofs_link fe) parent)","proofString":"eapply hasvalue_get_stack; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P)","proofString":"apply mconj_proj1 in H.\napply sep_proj1 in H.\napply sep_pick4 in H.\nrewrite <- chunk_of_Tptr in H.\neapply hasvalue_get_stack; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P)","proofString":"apply sep_proj1 in H.\napply sep_pick4 in H.\nrewrite <- chunk_of_Tptr in H.\neapply hasvalue_get_stack; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0)","proofString":"apply sep_pick4 in H.\nrewrite <- chunk_of_Tptr in H.\neapply hasvalue_get_stack; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr)","proofString":"rewrite <- chunk_of_Tptr in H.\neapply hasvalue_get_stack; eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= hasvalue (chunk_of_type Tptr) sp (fe_ofs_retaddr fe) retaddr) : load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr.","conclusion":"load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome retaddr","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= hasvalue (chunk_of_type Tptr) sp (fe_ofs_retaddr fe) retaddr)","proofString":"eapply hasvalue_get_stack; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v') : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v')","proofString":"unfold frame_contents in H.\nexploit mconj_proj1; eauto.\nunfold frame_contents_1.\nrewrite ! sep_assoc; intros SEP.\nunfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v') : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v')","proofString":"exploit mconj_proj1; eauto.\nunfold frame_contents_1.\nrewrite ! sep_assoc; intros SEP.\nunfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v') : m |= frame_contents_1 j sp ls ls0 parent retaddr ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"m |= frame_contents_1 j sp ls ls0 parent retaddr ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v')","proofString":"unfold frame_contents_1.\nrewrite ! sep_assoc; intros SEP.\nunfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v') : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v')","proofString":"rewrite ! sep_assoc; intros SEP.\nunfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H1 : slot_valid f Local ofs ty = true) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P)","proofString":"unfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Local ofs ty) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs)","proofString":"simpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs)","proofString":"exploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) : (exists m' : mem,\n   store_stack m (Vptr sp Ptrofs.zero) ty\n     (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = \n   Some m' /\\\n   m'\n   |= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n        (Locmap.set (S Local ofs ty) v ls) **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0 ** P) ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"(exists m' : mem,\n   store_stack m (Vptr sp Ptrofs.zero) ty\n     (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = \n   Some m' /\\\n   m'\n   |= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n        (Locmap.set (S Local ofs ty) v ls) **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0 ** P) ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs)","proofString":"intros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) : exists m'0 : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m'0 /\\\n  m'0\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m'0 : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_local fe ofs))\n    v' = Some m'0 /\\\n  m'0\n  |= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P)","proofString":"exists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) : m'\n|= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent retaddr **\n   P.","conclusion":"m'\n|= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent retaddr **\n   P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P)","proofString":"assert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p.","conclusion":"forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P)","proofString":"intros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (i : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m sp i k p) : Mem.perm m' sp i k p.","conclusion":"Mem.perm m' sp i k p","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (i : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m sp i k p)","proofString":"unfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : Mem.store (chunk_of_type ty) m sp\n  (Ptrofs.unsigned\n     (Ptrofs.add Ptrofs.zero\n        (Ptrofs.repr\n           (align\n              (size_callee_save_area b\n                 (align\n                    (4 *\n                     Z.max (max_over_instrs f outgoing_space)\n                       (max_over_slots_of_funct f outgoing_slot)) 8 + 8 + 8))\n              8 + 4 * ofs)))) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (i : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m sp i k p) : Mem.perm m' sp i k p.","conclusion":"Mem.perm m' sp i k p","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : Mem.store (chunk_of_type ty) m sp\n  (Ptrofs.unsigned\n     (Ptrofs.add Ptrofs.zero\n        (Ptrofs.repr\n           (align\n              (size_callee_save_area b\n                 (align\n                    (4 *\n                     Z.max (max_over_instrs f outgoing_space)\n                       (max_over_slots_of_funct f outgoing_slot)) 8 + 8 + 8))\n              8 + 4 * ofs)))) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (i : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m sp i k p)","proofString":"eapply Mem.perm_store_1; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p) : m'\n|= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent retaddr **\n   P.","conclusion":"m'\n|= frame_contents j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent retaddr **\n   P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p)","proofString":"eapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc; exact B.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p) : m'\n|= frame_contents_1 j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n     retaddr ** P.","conclusion":"m'\n|= frame_contents_1 j sp (Locmap.set (S Local ofs ty) v ls) ls0 parent\n     retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p)","proofString":"unfold frame_contents_1; rewrite ! sep_assoc; exact B."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p) : m'\n|= range sp 0 (fe_stack_data fe) **\n   range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe).","conclusion":"m'\n|= range sp 0 (fe_stack_data fe) **\n   range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <= max_over_slots_of_funct f local_slot) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty\n  (Ptrofs.repr (fe_ofs_local fe + 4 * ofs)) v' = Some m') (B : m'\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local\n     (Locmap.set (S Local ofs ty) v ls) **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p)","proofString":"eapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v') : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v')","proofString":"unfold frame_contents in H.\nexploit mconj_proj1; eauto.\nunfold frame_contents_1.\nrewrite ! sep_assoc, sep_swap.\nintros SEP.\nunfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v') : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v')","proofString":"exploit mconj_proj1; eauto.\nunfold frame_contents_1.\nrewrite ! sep_assoc, sep_swap.\nintros SEP.\nunfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v') : m |= frame_contents_1 j sp ls ls0 parent retaddr ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"m |= frame_contents_1 j sp ls ls0 parent retaddr ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v')","proofString":"unfold frame_contents_1.\nrewrite ! sep_assoc, sep_swap.\nintros SEP.\nunfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v') : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) parent **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v')","proofString":"rewrite ! sep_assoc, sep_swap.\nintros SEP.\nunfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v') : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v')","proofString":"intros SEP.\nunfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H1 : slot_valid f Outgoing ofs ty = true) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P)","proofString":"unfold slot_valid in H1; InvBooleans.\nsimpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : slot_within_bounds b Outgoing ofs ty) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs)","proofString":"simpl in H0.\nexploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) : exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs)","proofString":"exploit set_location; eauto.\nintros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) : (exists m' : mem,\n   store_stack m (Vptr sp Ptrofs.zero) ty\n     (Ptrofs.repr (fe_ofs_arg + 4 * ofs)) v' = Some m' /\\\n   m'\n   |= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n        (Locmap.set (S Outgoing ofs ty) v ls) **\n      contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0 ** P) ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"(exists m' : mem,\n   store_stack m (Vptr sp Ptrofs.zero) ty\n     (Ptrofs.repr (fe_ofs_arg + 4 * ofs)) v' = Some m' /\\\n   m'\n   |= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n        (Locmap.set (S Outgoing ofs ty) v ls) **\n      contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0 ** P) ->\nexists m' : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m' /\\\n  m'\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs)","proofString":"intros (m' & A & B).\nexists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) : exists m'0 : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m'0 /\\\n  m'0\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P.","conclusion":"exists m'0 : mem,\n  store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) v' =\n  Some m'0 /\\\n  m'0\n  |= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n       retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P)","proofString":"exists m'; split; auto.\nassert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) : m'\n|= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n     retaddr ** P.","conclusion":"m'\n|= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n     retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P)","proofString":"assert (forall i k p, Mem.perm m sp i k p -> Mem.perm m' sp i k p).\nintros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto.\neapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p.","conclusion":"forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P)","proofString":"intros.\nunfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (i : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m sp i k p) : Mem.perm m' sp i k p.","conclusion":"Mem.perm m' sp i k p","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (i : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m sp i k p)","proofString":"unfold store_stack in A; simpl in A.\neapply Mem.perm_store_1; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : Mem.store (chunk_of_type ty) m sp\n  (Ptrofs.unsigned\n     (Ptrofs.add Ptrofs.zero (Ptrofs.repr (fe_ofs_arg + 4 * ofs)))) v' =\nSome m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (i : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m sp i k p) : Mem.perm m' sp i k p.","conclusion":"Mem.perm m' sp i k p","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : Mem.store (chunk_of_type ty) m sp\n  (Ptrofs.unsigned\n     (Ptrofs.add Ptrofs.zero (Ptrofs.repr (fe_ofs_arg + 4 * ofs)))) v' =\nSome m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (i : Z) (k : perm_kind) (p : permission) (H4 : Mem.perm m sp i k p)","proofString":"eapply Mem.perm_store_1; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p) : m'\n|= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n     retaddr ** P.","conclusion":"m'\n|= frame_contents j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n     retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p)","proofString":"eapply frame_mconj.\neauto.\nunfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto.\neapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p) : m'\n|= frame_contents_1 j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n     retaddr ** P.","conclusion":"m'\n|= frame_contents_1 j sp (Locmap.set (S Outgoing ofs ty) v ls) ls0 parent\n     retaddr ** P","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p)","proofString":"unfold frame_contents_1; rewrite ! sep_assoc, sep_swap; eauto."},{"statement":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p) : m'\n|= range sp 0 (fe_stack_data fe) **\n   range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe).","conclusion":"m'\n|= range sp 0 (fe_stack_data fe) **\n   range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)","hypotheses":"(ofs : Z) (ty : typ) (v v' : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m\n|= mconj (frame_contents_1 j sp ls ls0 parent retaddr)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : ofs + typesize ty <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (H2 : Val.inject j v v') (SEP : m\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H1 : (typealign ty | ofs)) (H3 : 0 <= ofs) (m' : mem) (A : store_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * ofs))\n  v' = Some m') (B : m'\n|= contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing\n     (Locmap.set (S Outgoing ofs ty) v ls) **\n   contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   hasvalue Mptr sp (fe_ofs_link fe) parent **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H4 : forall (i : Z) (k : perm_kind) (p : permission),\nMem.perm m sp i k p -> Mem.perm m' sp i k p)","proofString":"eapply sep_preserved.\neapply sep_proj1.\neapply mconj_proj2.\neassumption.\nintros; eapply range_preserved; eauto.\nintros; eapply range_preserved; eauto."},{"statement":"(ls ls0 ls' ls0' : loc -> val) (j : meminj) (sp : block) (parent retaddr : val) (P : massert) (m : mem) (H : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Local ofs ty)) (ls (S Local ofs ty))) (H0 : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Outgoing ofs ty)) (ls (S Outgoing ofs ty))) (H1 : forall r : mreg, In r (used_callee_save b) -> ls0' (R r) = ls0 (R r)) (H2 : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls' **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls' **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0')\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P.","conclusion":"m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls' **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls' **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0')\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P","hypotheses":"(ls ls0 ls' ls0' : loc -> val) (j : meminj) (sp : block) (parent retaddr : val) (P : massert) (m : mem) (H : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Local ofs ty)) (ls (S Local ofs ty))) (H0 : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Outgoing ofs ty)) (ls (S Outgoing ofs ty))) (H1 : forall r : mreg, In r (used_callee_save b) -> ls0' (R r) = ls0 (R r)) (H2 : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P)","proofString":"rewrite <- ! (contains_locations_exten ls ls') by auto.\nerewrite  <- contains_callee_saves_exten by eauto.\nassumption."},{"statement":"(ls ls0 ls' ls0' : loc -> val) (j : meminj) (sp : block) (parent retaddr : val) (P : massert) (m : mem) (H : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Local ofs ty)) (ls (S Local ofs ty))) (H0 : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Outgoing ofs ty)) (ls (S Outgoing ofs ty))) (H1 : forall r : mreg, In r (used_callee_save b) -> ls0' (R r) = ls0 (R r)) (H2 : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0')\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P.","conclusion":"m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0')\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P","hypotheses":"(ls ls0 ls' ls0' : loc -> val) (j : meminj) (sp : block) (parent retaddr : val) (P : massert) (m : mem) (H : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Local ofs ty)) (ls (S Local ofs ty))) (H0 : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Outgoing ofs ty)) (ls (S Outgoing ofs ty))) (H1 : forall r : mreg, In r (used_callee_save b) -> ls0' (R r) = ls0 (R r)) (H2 : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P)","proofString":"erewrite  <- contains_callee_saves_exten by eauto.\nassumption."},{"statement":"(ls ls0 ls' ls0' : loc -> val) (j : meminj) (sp : block) (parent retaddr : val) (P : massert) (m : mem) (H : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Local ofs ty)) (ls (S Local ofs ty))) (H0 : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Outgoing ofs ty)) (ls (S Outgoing ofs ty))) (H1 : forall r : mreg, In r (used_callee_save b) -> ls0' (R r) = ls0 (R r)) (H2 : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P.","conclusion":"m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P","hypotheses":"(ls ls0 ls' ls0' : loc -> val) (j : meminj) (sp : block) (parent retaddr : val) (P : massert) (m : mem) (H : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Local ofs ty)) (ls (S Local ofs ty))) (H0 : forall (ofs : Z) (ty : typ),\nVal.lessdef (ls' (S Outgoing ofs ty)) (ls (S Outgoing ofs ty))) (H1 : forall r : mreg, In r (used_callee_save b) -> ls0' (R r) = ls0 (R r)) (H2 : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P)","proofString":"assumption."},{"statement":"(r : mreg) (v : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) : m |= frame_contents j sp (Locmap.set (R r) v ls) ls0 parent retaddr ** P.","conclusion":"m |= frame_contents j sp (Locmap.set (R r) v ls) ls0 parent retaddr ** P","hypotheses":"(r : mreg) (v : val) (j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P)","proofString":"apply frame_contents_exten with ls ls0; auto."},{"statement":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (p : rpair mreg) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) : m |= frame_contents j sp (Locmap.setpair p v ls) ls0 parent retaddr ** P.","conclusion":"m |= frame_contents j sp (Locmap.setpair p v ls) ls0 parent retaddr ** P","hypotheses":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (p : rpair mreg) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P)","proofString":"destruct p; simpl.\napply frame_set_reg; auto.\napply frame_set_reg; apply frame_set_reg; auto."},{"statement":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (r : mreg) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) : m |= frame_contents j sp (Locmap.set (R r) v ls) ls0 parent retaddr ** P.","conclusion":"m |= frame_contents j sp (Locmap.set (R r) v ls) ls0 parent retaddr ** P","hypotheses":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (r : mreg) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P)","proofString":"apply frame_set_reg; auto."},{"statement":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (rhi rlo : mreg) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) : m\n|= frame_contents j sp\n     (Locmap.set (R rlo) (Val.loword v)\n        (Locmap.set (R rhi) (Val.hiword v) ls)) ls0 parent retaddr ** P.","conclusion":"m\n|= frame_contents j sp\n     (Locmap.set (R rlo) (Val.loword v)\n        (Locmap.set (R rhi) (Val.hiword v) ls)) ls0 parent retaddr ** P","hypotheses":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (rhi rlo : mreg) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P)","proofString":"apply frame_set_reg; apply frame_set_reg; auto."},{"statement":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (x : mreg) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) : m |= frame_contents j sp (Locmap.set (R x) v ls) ls0 parent retaddr ** P.","conclusion":"m |= frame_contents j sp (Locmap.set (R x) v ls) ls0 parent retaddr ** P","hypotheses":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (x : mreg) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P)","proofString":"apply frame_set_reg; auto."},{"statement":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) : m |= frame_contents j sp ls ls0 parent retaddr ** P.","conclusion":"m |= frame_contents j sp ls ls0 parent retaddr ** P","hypotheses":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P)","proofString":"auto."},{"statement":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 : val) (ls1 : locset),\nm |= frame_contents j sp ls1 ls0 parent retaddr ** P ->\nm |= frame_contents j sp (Locmap.setres res1 v0 ls1) ls0 parent retaddr ** P) (IHres2 : forall (v0 : val) (ls1 : locset),\nm |= frame_contents j sp ls1 ls0 parent retaddr ** P ->\nm |= frame_contents j sp (Locmap.setres res2 v0 ls1) ls0 parent retaddr ** P) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P) : m\n|= frame_contents j sp\n     (Locmap.setres res2 (Val.loword v)\n        (Locmap.setres res1 (Val.hiword v) ls)) ls0 parent retaddr ** P.","conclusion":"m\n|= frame_contents j sp\n     (Locmap.setres res2 (Val.loword v)\n        (Locmap.setres res1 (Val.hiword v) ls)) ls0 parent retaddr ** P","hypotheses":"(j : meminj) (sp : block) (ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 : val) (ls1 : locset),\nm |= frame_contents j sp ls1 ls0 parent retaddr ** P ->\nm |= frame_contents j sp (Locmap.setres res1 v0 ls1) ls0 parent retaddr ** P) (IHres2 : forall (v0 : val) (ls1 : locset),\nm |= frame_contents j sp ls1 ls0 parent retaddr ** P ->\nm |= frame_contents j sp (Locmap.setres res2 v0 ls1) ls0 parent retaddr ** P) (v : val) (ls : locset) (H : m |= frame_contents j sp ls ls0 parent retaddr ** P)","proofString":"eauto."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (j' : meminj) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : inject_incr j j') : m\n|= mconj\n     (contains_locations j' sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j' sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j' sp (fe_ofs_callee_save fe)\n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P.","conclusion":"m\n|= mconj\n     (contains_locations j' sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j' sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j' sp (fe_ofs_callee_save fe)\n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (j' : meminj) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : inject_incr j j')","proofString":"rewrite <- (contains_locations_incr j j') by auto.\nrewrite <- (contains_locations_incr j j') by auto.\nerewrite  <- contains_callee_saves_incr by eauto.\nassumption."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (j' : meminj) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : inject_incr j j') : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j' sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j' sp (fe_ofs_callee_save fe)\n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P.","conclusion":"m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j' sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j' sp (fe_ofs_callee_save fe)\n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (j' : meminj) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : inject_incr j j')","proofString":"rewrite <- (contains_locations_incr j j') by auto.\nerewrite  <- contains_callee_saves_incr by eauto.\nassumption."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (j' : meminj) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : inject_incr j j') : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j' sp (fe_ofs_callee_save fe)\n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P.","conclusion":"m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j' sp (fe_ofs_callee_save fe)\n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (j' : meminj) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : inject_incr j j')","proofString":"erewrite  <- contains_callee_saves_incr by eauto.\nassumption."},{"statement":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (j' : meminj) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : inject_incr j j') : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P.","conclusion":"m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P","hypotheses":"(j : meminj) (sp : block) (ls ls0 : locset) (parent retaddr : val) (m : mem) (P : massert) (j' : meminj) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) parent **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) retaddr **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : inject_incr j j')","proofString":"assumption."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (H : agree_regs j ls rs) : Val.inject j (ls (R r)) (rs r).","conclusion":"Val.inject j (ls (R r)) (rs r)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (H : agree_regs j ls rs)","proofString":"auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs) : Val.inject_list j nil nil.","conclusion":"Val.inject_list j nil nil","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs)","proofString":"auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (a : mreg) (rl : list mreg) (IHrl : agree_regs j ls rs -> Val.inject_list j (reglist ls rl) rs ## rl) (H : agree_regs j ls rs) : Val.inject_list j (ls (R a) :: reglist ls rl) (rs a :: rs ## rl).","conclusion":"Val.inject_list j (ls (R a) :: reglist ls rl) (rs a :: rs ## rl)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (a : mreg) (rl : list mreg) (IHrl : agree_regs j ls rs -> Val.inject_list j (reglist ls rl) rs ## rl) (H : agree_regs j ls rs)","proofString":"constructor; auto using agree_reg."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) : Val.inject j (Locmap.set (R r) v ls (R r0)) (rs # r <- v' r0).","conclusion":"Val.inject j (Locmap.set (R r) v ls (R r0)) (rs # r <- v' r0)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg)","proofString":"unfold Regmap.set.\ndestruct (RegEq.eq r0 r).\nsubst r0.\nrewrite Locmap.gss; auto.\nrewrite Locmap.gso; auto.\nred.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) : Val.inject j (Locmap.set (R r) v ls (R r0))\n  (if RegEq.eq r0 r then v' else rs r0).","conclusion":"Val.inject j (Locmap.set (R r) v ls (R r0))\n  (if RegEq.eq r0 r then v' else rs r0)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg)","proofString":"destruct (RegEq.eq r0 r).\nsubst r0.\nrewrite Locmap.gss; auto.\nrewrite Locmap.gso; auto.\nred.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) (e : r0 = r) : Val.inject j (Locmap.set (R r) v ls (R r0)) v'.","conclusion":"Val.inject j (Locmap.set (R r) v ls (R r0)) v'","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) (e : r0 = r)","proofString":"subst r0.\nrewrite Locmap.gss; auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : Val.inject j (Locmap.set (R r) v ls (R r)) v'.","conclusion":"Val.inject j (Locmap.set (R r) v ls (R r)) v'","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"rewrite Locmap.gss; auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) (n : r0 <> r) : Val.inject j (Locmap.set (R r) v ls (R r0)) (rs r0).","conclusion":"Val.inject j (Locmap.set (R r) v ls (R r0)) (rs r0)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) (n : r0 <> r)","proofString":"rewrite Locmap.gso; auto.\nred.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) (n : r0 <> r) : Loc.diff (R r) (R r0).","conclusion":"Loc.diff (R r) (R r0)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) (n : r0 <> r)","proofString":"red.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) (n : r0 <> r) : r <> r0.","conclusion":"r <> r0","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (r : mreg) (v v' : val) (H : agree_regs j ls rs) (H0 : Val.inject j v v') (r0 : mreg) (n : r0 <> r)","proofString":"auto."},{"statement":"(j : meminj) (p : rpair mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : agree_regs j (Locmap.setpair p v ls) (set_pair p v' rs).","conclusion":"agree_regs j (Locmap.setpair p v ls) (set_pair p v' rs)","hypotheses":"(j : meminj) (p : rpair mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"destruct p; simpl.\napply agree_regs_set_reg; auto.\napply agree_regs_set_reg.\napply agree_regs_set_reg; auto.\napply Val.hiword_inject; auto.\napply Val.loword_inject; auto."},{"statement":"(j : meminj) (r : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : agree_regs j (Locmap.set (R r) v ls) rs # r <- v'.","conclusion":"agree_regs j (Locmap.set (R r) v ls) rs # r <- v'","hypotheses":"(j : meminj) (r : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply agree_regs_set_reg; auto."},{"statement":"(j : meminj) (rhi rlo : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : agree_regs j\n  (Locmap.set (R rlo) (Val.loword v) (Locmap.set (R rhi) (Val.hiword v) ls))\n  (rs # rhi <- (Val.hiword v')) # rlo <- (Val.loword v').","conclusion":"agree_regs j\n  (Locmap.set (R rlo) (Val.loword v) (Locmap.set (R rhi) (Val.hiword v) ls))\n  (rs # rhi <- (Val.hiword v')) # rlo <- (Val.loword v')","hypotheses":"(j : meminj) (rhi rlo : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply agree_regs_set_reg.\napply agree_regs_set_reg; auto.\napply Val.hiword_inject; auto.\napply Val.loword_inject; auto."},{"statement":"(j : meminj) (rhi rlo : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : agree_regs j (Locmap.set (R rhi) (Val.hiword v) ls)\n  rs # rhi <- (Val.hiword v').","conclusion":"agree_regs j (Locmap.set (R rhi) (Val.hiword v) ls)\n  rs # rhi <- (Val.hiword v')","hypotheses":"(j : meminj) (rhi rlo : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply agree_regs_set_reg; auto.\napply Val.hiword_inject; auto."},{"statement":"(j : meminj) (rhi rlo : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : Val.inject j (Val.hiword v) (Val.hiword v').","conclusion":"Val.inject j (Val.hiword v) (Val.hiword v')","hypotheses":"(j : meminj) (rhi rlo : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply Val.hiword_inject; auto."},{"statement":"(j : meminj) (rhi rlo : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : Val.inject j (Val.loword v) (Val.loword v').","conclusion":"Val.inject j (Val.loword v) (Val.loword v')","hypotheses":"(j : meminj) (rhi rlo : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply Val.loword_inject; auto."},{"statement":"(j : meminj) (x : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : agree_regs j (Locmap.set (R x) v ls) rs # x <- v'.","conclusion":"agree_regs j (Locmap.set (R x) v ls) rs # x <- v'","hypotheses":"(j : meminj) (x : mreg) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply agree_regs_set_reg; auto."},{"statement":"(j : meminj) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : agree_regs j ls rs.","conclusion":"agree_regs j ls rs","hypotheses":"(j : meminj) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"auto."},{"statement":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : agree_regs j\n  (Locmap.setres res2 (Val.loword v) (Locmap.setres res1 (Val.hiword v) ls))\n  (set_res res2 (Val.loword v') (set_res res1 (Val.hiword v') rs)).","conclusion":"agree_regs j\n  (Locmap.setres res2 (Val.loword v) (Locmap.setres res1 (Val.hiword v) ls))\n  (set_res res2 (Val.loword v') (set_res res1 (Val.hiword v') rs))","hypotheses":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply IHres2.\napply IHres1.\nauto.\napply Val.hiword_inject; auto.\napply Val.loword_inject; auto."},{"statement":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : agree_regs j (Locmap.setres res1 (Val.hiword v) ls)\n  (set_res res1 (Val.hiword v') rs).","conclusion":"agree_regs j (Locmap.setres res1 (Val.hiword v) ls)\n  (set_res res1 (Val.hiword v') rs)","hypotheses":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply IHres1.\nauto.\napply Val.hiword_inject; auto."},{"statement":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : agree_regs j ls rs.","conclusion":"agree_regs j ls rs","hypotheses":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"auto."},{"statement":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : Val.inject j (Val.hiword v) (Val.hiword v').","conclusion":"Val.inject j (Val.hiword v) (Val.hiword v')","hypotheses":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply Val.hiword_inject; auto."},{"statement":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v') : Val.inject j (Val.loword v) (Val.loword v').","conclusion":"Val.inject j (Val.loword v) (Val.loword v')","hypotheses":"(j : meminj) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res1 v0 ls0) (set_res res1 v'0 rs0)) (IHres2 : forall (v0 v'0 : val) (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nVal.inject j v0 v'0 ->\nagree_regs j (Locmap.setres res2 v0 ls0) (set_res res2 v'0 rs0)) (v v' : val) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (H0 : Val.inject j v v')","proofString":"apply Val.loword_inject; auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (ls' : loc -> val) (rs' : mreg -> val) (H : agree_regs j ls rs) (H0 : forall r0 : mreg,\nls' (R r0) = Vundef \\/ ls' (R r0) = ls (R r0) /\\ rs' r0 = rs r0) (r : mreg) : Val.inject j (ls' (R r)) (rs' r).","conclusion":"Val.inject j (ls' (R r)) (rs' r)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (ls' : loc -> val) (rs' : mreg -> val) (H : agree_regs j ls rs) (H0 : forall r0 : mreg,\nls' (R r0) = Vundef \\/ ls' (R r0) = ls (R r0) /\\ rs' r0 = rs r0) (r : mreg)","proofString":"destruct (H0 r) as [A | [A B]].\nrewrite A.\nconstructor.\nrewrite A; rewrite B; auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (ls' : loc -> val) (rs' : mreg -> val) (H : agree_regs j ls rs) (H0 : forall r0 : mreg,\nls' (R r0) = Vundef \\/ ls' (R r0) = ls (R r0) /\\ rs' r0 = rs r0) (r : mreg) (A : ls' (R r) = Vundef) : Val.inject j (ls' (R r)) (rs' r).","conclusion":"Val.inject j (ls' (R r)) (rs' r)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (ls' : loc -> val) (rs' : mreg -> val) (H : agree_regs j ls rs) (H0 : forall r0 : mreg,\nls' (R r0) = Vundef \\/ ls' (R r0) = ls (R r0) /\\ rs' r0 = rs r0) (r : mreg) (A : ls' (R r) = Vundef)","proofString":"rewrite A.\nconstructor."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (ls' : loc -> val) (rs' : mreg -> val) (H : agree_regs j ls rs) (H0 : forall r0 : mreg,\nls' (R r0) = Vundef \\/ ls' (R r0) = ls (R r0) /\\ rs' r0 = rs r0) (r : mreg) (A : ls' (R r) = Vundef) : Val.inject j Vundef (rs' r).","conclusion":"Val.inject j Vundef (rs' r)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (ls' : loc -> val) (rs' : mreg -> val) (H : agree_regs j ls rs) (H0 : forall r0 : mreg,\nls' (R r0) = Vundef \\/ ls' (R r0) = ls (R r0) /\\ rs' r0 = rs r0) (r : mreg) (A : ls' (R r) = Vundef)","proofString":"constructor."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (ls' : loc -> val) (rs' : mreg -> val) (H : agree_regs j ls rs) (H0 : forall r0 : mreg,\nls' (R r0) = Vundef \\/ ls' (R r0) = ls (R r0) /\\ rs' r0 = rs r0) (r : mreg) (A : ls' (R r) = ls (R r)) (B : rs' r = rs r) : Val.inject j (ls' (R r)) (rs' r).","conclusion":"Val.inject j (ls' (R r)) (rs' r)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (ls' : loc -> val) (rs' : mreg -> val) (H : agree_regs j ls rs) (H0 : forall r0 : mreg,\nls' (R r0) = Vundef \\/ ls' (R r0) = ls (R r0) /\\ rs' r0 = rs r0) (r : mreg) (A : ls' (R r) = ls (R r)) (B : rs' r = rs r)","proofString":"rewrite A; rewrite B; auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs) : agree_regs j ls rs.","conclusion":"agree_regs j ls rs","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs)","proofString":"auto."},{"statement":"(j : meminj) (a : mreg) (rl : list mreg) (IHrl : forall (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nagree_regs j (LTL.undef_regs rl ls0) (undef_regs rl rs0)) (ls : locset) (rs : regset) (H : agree_regs j ls rs) : agree_regs j (Locmap.set (R a) Vundef (LTL.undef_regs rl ls))\n  (undef_regs rl rs) # a <- Vundef.","conclusion":"agree_regs j (Locmap.set (R a) Vundef (LTL.undef_regs rl ls))\n  (undef_regs rl rs) # a <- Vundef","hypotheses":"(j : meminj) (a : mreg) (rl : list mreg) (IHrl : forall (ls0 : locset) (rs0 : regset),\nagree_regs j ls0 rs0 ->\nagree_regs j (LTL.undef_regs rl ls0) (undef_regs rl rs0)) (ls : locset) (rs : regset) (H : agree_regs j ls rs)","proofString":"apply agree_regs_set_reg; auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (r : mreg) : Val.inject j (LTL.undef_caller_save_regs ls (R r))\n  (undef_caller_save_regs rs r).","conclusion":"Val.inject j (LTL.undef_caller_save_regs ls (R r))\n  (undef_caller_save_regs rs r)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (r : mreg)","proofString":"unfold LTL.undef_caller_save_regs, Mach.undef_caller_save_regs.\ndestruct (is_callee_save r); auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (r : mreg) : Val.inject j (if is_callee_save r then ls (R r) else Vundef)\n  (if is_callee_save r then rs r else Vundef).","conclusion":"Val.inject j (if is_callee_save r then ls (R r) else Vundef)\n  (if is_callee_save r then rs r else Vundef)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs) (r : mreg)","proofString":"destruct (is_callee_save r); auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : agree_regs j ls rs) (r : mreg) : Val.inject j (Locmap.set (S sl ofs ty) v ls (R r)) (rs r).","conclusion":"Val.inject j (Locmap.set (S sl ofs ty) v ls (R r)) (rs r)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : agree_regs j ls rs) (r : mreg)","proofString":"rewrite Locmap.gso; auto.\nred.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : agree_regs j ls rs) (r : mreg) : Loc.diff (S sl ofs ty) (R r).","conclusion":"Loc.diff (S sl ofs ty) (R r)","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : agree_regs j ls rs) (r : mreg)","proofString":"red.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : agree_regs j ls rs) (r : mreg) : True.","conclusion":"True","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : agree_regs j ls rs) (r : mreg)","proofString":"auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs) : agree_regs j (call_regs ls) rs.","conclusion":"agree_regs j (call_regs ls) rs","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (H : agree_regs j ls rs)","proofString":"unfold call_regs; intros; red; intros; auto."},{"statement":"(ls ls0 : locset) (r : mreg) (v : val) (H : agree_locs ls ls0) (H0 : mreg_within_bounds b r) : agree_locs (Locmap.set (R r) v ls) ls0.","conclusion":"agree_locs (Locmap.set (R r) v ls) ls0","hypotheses":"(ls ls0 : locset) (r : mreg) (v : val) (H : agree_locs ls ls0) (H0 : mreg_within_bounds b r)","proofString":"inv H; constructor; auto; intros.\nrewrite Locmap.gso.\nauto.\nred.\nintuition congruence."},{"statement":"(ls ls0 : locset) (r : mreg) (v : val) (H0 : mreg_within_bounds b r) (agree_unused_reg0 : forall r1 : mreg, ~ mreg_within_bounds b r1 -> ls (R r1) = ls0 (R r1)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r0 : mreg) (H : ~ mreg_within_bounds b r0) : Locmap.set (R r) v ls (R r0) = ls0 (R r0).","conclusion":"Locmap.set (R r) v ls (R r0) = ls0 (R r0)","hypotheses":"(ls ls0 : locset) (r : mreg) (v : val) (H0 : mreg_within_bounds b r) (agree_unused_reg0 : forall r1 : mreg, ~ mreg_within_bounds b r1 -> ls (R r1) = ls0 (R r1)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r0 : mreg) (H : ~ mreg_within_bounds b r0)","proofString":"rewrite Locmap.gso.\nauto.\nred.\nintuition congruence."},{"statement":"(ls ls0 : locset) (r : mreg) (v : val) (H0 : mreg_within_bounds b r) (agree_unused_reg0 : forall r1 : mreg, ~ mreg_within_bounds b r1 -> ls (R r1) = ls0 (R r1)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r0 : mreg) (H : ~ mreg_within_bounds b r0) : ls (R r0) = ls0 (R r0).","conclusion":"ls (R r0) = ls0 (R r0)","hypotheses":"(ls ls0 : locset) (r : mreg) (v : val) (H0 : mreg_within_bounds b r) (agree_unused_reg0 : forall r1 : mreg, ~ mreg_within_bounds b r1 -> ls (R r1) = ls0 (R r1)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r0 : mreg) (H : ~ mreg_within_bounds b r0)","proofString":"auto."},{"statement":"(ls ls0 : locset) (r : mreg) (v : val) (H0 : mreg_within_bounds b r) (agree_unused_reg0 : forall r1 : mreg, ~ mreg_within_bounds b r1 -> ls (R r1) = ls0 (R r1)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r0 : mreg) (H : ~ mreg_within_bounds b r0) : Loc.diff (R r) (R r0).","conclusion":"Loc.diff (R r) (R r0)","hypotheses":"(ls ls0 : locset) (r : mreg) (v : val) (H0 : mreg_within_bounds b r) (agree_unused_reg0 : forall r1 : mreg, ~ mreg_within_bounds b r1 -> ls (R r1) = ls0 (R r1)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r0 : mreg) (H : ~ mreg_within_bounds b r0)","proofString":"red.\nintuition congruence."},{"statement":"(ls ls0 : locset) (r : mreg) (v : val) (H0 : mreg_within_bounds b r) (agree_unused_reg0 : forall r1 : mreg, ~ mreg_within_bounds b r1 -> ls (R r1) = ls0 (R r1)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r0 : mreg) (H : ~ mreg_within_bounds b r0) : r <> r0.","conclusion":"r <> r0","hypotheses":"(ls ls0 : locset) (r : mreg) (v : val) (H0 : mreg_within_bounds b r) (agree_unused_reg0 : forall r1 : mreg, ~ mreg_within_bounds b r1 -> ls (R r1) = ls0 (R r1)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r0 : mreg) (H : ~ mreg_within_bounds b r0)","proofString":"intuition congruence."},{"statement":"(r : mreg) (H : is_callee_save r = false) (H0 : is_callee_save r = true) : In r (used_callee_save b).","conclusion":"In r (used_callee_save b)","hypotheses":"(r : mreg) (H : is_callee_save r = false) (H0 : is_callee_save r = true)","proofString":"congruence."},{"statement":"(ls0 : locset) (p : rpair mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : forall_rpair (fun r : mreg => is_callee_save r = false) p) : agree_locs (Locmap.setpair p v ls) ls0.","conclusion":"agree_locs (Locmap.setpair p v ls) ls0","hypotheses":"(ls0 : locset) (p : rpair mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : forall_rpair (fun r : mreg => is_callee_save r = false) p)","proofString":"destruct p; simpl in *.\napply agree_locs_set_reg; auto.\napply caller_save_reg_within_bounds; auto.\ndestruct H0.\napply agree_locs_set_reg; auto.\napply agree_locs_set_reg; auto.\napply caller_save_reg_within_bounds; auto.\napply caller_save_reg_within_bounds; auto."},{"statement":"(ls0 : locset) (r : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save r = false) : agree_locs (Locmap.set (R r) v ls) ls0.","conclusion":"agree_locs (Locmap.set (R r) v ls) ls0","hypotheses":"(ls0 : locset) (r : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save r = false)","proofString":"apply agree_locs_set_reg; auto.\napply caller_save_reg_within_bounds; auto."},{"statement":"(ls0 : locset) (r : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save r = false) : mreg_within_bounds b r.","conclusion":"mreg_within_bounds b r","hypotheses":"(ls0 : locset) (r : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save r = false)","proofString":"apply caller_save_reg_within_bounds; auto."},{"statement":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false /\\ is_callee_save rlo = false) : agree_locs\n  (Locmap.set (R rlo) (Val.loword v) (Locmap.set (R rhi) (Val.hiword v) ls))\n  ls0.","conclusion":"agree_locs\n  (Locmap.set (R rlo) (Val.loword v) (Locmap.set (R rhi) (Val.hiword v) ls))\n  ls0","hypotheses":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false /\\ is_callee_save rlo = false)","proofString":"destruct H0.\napply agree_locs_set_reg; auto.\napply agree_locs_set_reg; auto.\napply caller_save_reg_within_bounds; auto.\napply caller_save_reg_within_bounds; auto."},{"statement":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false) (H1 : is_callee_save rlo = false) : agree_locs\n  (Locmap.set (R rlo) (Val.loword v) (Locmap.set (R rhi) (Val.hiword v) ls))\n  ls0.","conclusion":"agree_locs\n  (Locmap.set (R rlo) (Val.loword v) (Locmap.set (R rhi) (Val.hiword v) ls))\n  ls0","hypotheses":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false) (H1 : is_callee_save rlo = false)","proofString":"apply agree_locs_set_reg; auto.\napply agree_locs_set_reg; auto.\napply caller_save_reg_within_bounds; auto.\napply caller_save_reg_within_bounds; auto."},{"statement":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false) (H1 : is_callee_save rlo = false) : agree_locs (Locmap.set (R rhi) (Val.hiword v) ls) ls0.","conclusion":"agree_locs (Locmap.set (R rhi) (Val.hiword v) ls) ls0","hypotheses":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false) (H1 : is_callee_save rlo = false)","proofString":"apply agree_locs_set_reg; auto.\napply caller_save_reg_within_bounds; auto."},{"statement":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false) (H1 : is_callee_save rlo = false) : mreg_within_bounds b rhi.","conclusion":"mreg_within_bounds b rhi","hypotheses":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false) (H1 : is_callee_save rlo = false)","proofString":"apply caller_save_reg_within_bounds; auto."},{"statement":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false) (H1 : is_callee_save rlo = false) : mreg_within_bounds b rlo.","conclusion":"mreg_within_bounds b rlo","hypotheses":"(ls0 : locset) (rhi rlo : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : is_callee_save rhi = false) (H1 : is_callee_save rlo = false)","proofString":"apply caller_save_reg_within_bounds; auto."},{"statement":"(ls0 : locset) (x : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, x = r \\/ False -> mreg_within_bounds b r) : agree_locs (Locmap.set (R x) v ls) ls0.","conclusion":"agree_locs (Locmap.set (R x) v ls) ls0","hypotheses":"(ls0 : locset) (x : mreg) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, x = r \\/ False -> mreg_within_bounds b r)","proofString":"eapply agree_locs_set_reg; eauto."},{"statement":"(ls0 : locset) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, False -> mreg_within_bounds b r) : agree_locs ls ls0.","conclusion":"agree_locs ls ls0","hypotheses":"(ls0 : locset) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, False -> mreg_within_bounds b r)","proofString":"auto."},{"statement":"(ls0 : locset) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 : val) (ls1 : locset),\nagree_locs ls1 ls0 ->\n(forall r : mreg, In r (params_of_builtin_res res1) -> mreg_within_bounds b r) ->\nagree_locs (Locmap.setres res1 v0 ls1) ls0) (IHres2 : forall (v0 : val) (ls1 : locset),\nagree_locs ls1 ls0 ->\n(forall r : mreg, In r (params_of_builtin_res res2) -> mreg_within_bounds b r) ->\nagree_locs (Locmap.setres res2 v0 ls1) ls0) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg,\nIn r (params_of_builtin_res res1 ++ params_of_builtin_res res2) ->\nmreg_within_bounds b r) : agree_locs\n  (Locmap.setres res2 (Val.loword v) (Locmap.setres res1 (Val.hiword v) ls))\n  ls0.","conclusion":"agree_locs\n  (Locmap.setres res2 (Val.loword v) (Locmap.setres res1 (Val.hiword v) ls))\n  ls0","hypotheses":"(ls0 : locset) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 : val) (ls1 : locset),\nagree_locs ls1 ls0 ->\n(forall r : mreg, In r (params_of_builtin_res res1) -> mreg_within_bounds b r) ->\nagree_locs (Locmap.setres res1 v0 ls1) ls0) (IHres2 : forall (v0 : val) (ls1 : locset),\nagree_locs ls1 ls0 ->\n(forall r : mreg, In r (params_of_builtin_res res2) -> mreg_within_bounds b r) ->\nagree_locs (Locmap.setres res2 v0 ls1) ls0) (v : val) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg,\nIn r (params_of_builtin_res res1 ++ params_of_builtin_res res2) ->\nmreg_within_bounds b r)","proofString":"apply IHres2; auto using in_or_app."},{"statement":"(ls0 ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, False -> mreg_within_bounds b r) : agree_locs ls ls0.","conclusion":"agree_locs ls ls0","hypotheses":"(ls0 ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, False -> mreg_within_bounds b r)","proofString":"auto."},{"statement":"(ls0 : locset) (a : mreg) (regs : list mreg) (IHregs : forall ls1 : locset,\nagree_locs ls1 ls0 ->\n(forall r : mreg, In r regs -> mreg_within_bounds b r) ->\nagree_locs (LTL.undef_regs regs ls1) ls0) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, a = r \\/ In r regs -> mreg_within_bounds b r) : agree_locs (Locmap.set (R a) Vundef (LTL.undef_regs regs ls)) ls0.","conclusion":"agree_locs (Locmap.set (R a) Vundef (LTL.undef_regs regs ls)) ls0","hypotheses":"(ls0 : locset) (a : mreg) (regs : list mreg) (IHregs : forall ls1 : locset,\nagree_locs ls1 ls0 ->\n(forall r : mreg, In r regs -> mreg_within_bounds b r) ->\nagree_locs (LTL.undef_regs regs ls1) ls0) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, a = r \\/ In r regs -> mreg_within_bounds b r)","proofString":"apply agree_locs_set_reg; auto."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, In r regs -> is_callee_save r = false) : agree_locs (LTL.undef_regs regs ls) ls0.","conclusion":"agree_locs (LTL.undef_regs regs ls) ls0","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, In r regs -> is_callee_save r = false)","proofString":"eapply agree_locs_undef_regs; eauto.\nintros.\napply caller_save_reg_within_bounds.\nauto."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, In r regs -> is_callee_save r = false) : forall r : mreg, In r regs -> mreg_within_bounds b r.","conclusion":"forall r : mreg, In r regs -> mreg_within_bounds b r","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r : mreg, In r regs -> is_callee_save r = false)","proofString":"intros.\napply caller_save_reg_within_bounds.\nauto."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r0 : mreg, In r0 regs -> is_callee_save r0 = false) (r : mreg) (H1 : In r regs) : mreg_within_bounds b r.","conclusion":"mreg_within_bounds b r","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r0 : mreg, In r0 regs -> is_callee_save r0 = false) (r : mreg) (H1 : In r regs)","proofString":"apply caller_save_reg_within_bounds.\nauto."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r0 : mreg, In r0 regs -> is_callee_save r0 = false) (r : mreg) (H1 : In r regs) : is_callee_save r = false.","conclusion":"is_callee_save r = false","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : forall r0 : mreg, In r0 regs -> is_callee_save r0 = false) (r : mreg) (H1 : In r regs)","proofString":"auto."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) : agree_locs (LTL.undef_regs regs ls) ls0.","conclusion":"agree_locs (LTL.undef_regs regs ls) ls0","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false)","proofString":"eapply agree_locs_undef_locs_1; eauto.\nintros.\ndestruct (is_callee_save r) eqn:CS; auto.\nassert (existsb is_callee_save regs = true).\napply existsb_exists.\nexists r; auto.\ncongruence."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) : forall r : mreg, In r regs -> is_callee_save r = false.","conclusion":"forall r : mreg, In r regs -> is_callee_save r = false","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false)","proofString":"intros.\ndestruct (is_callee_save r) eqn:CS; auto.\nassert (existsb is_callee_save regs = true).\napply existsb_exists.\nexists r; auto.\ncongruence."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs) : is_callee_save r = false.","conclusion":"is_callee_save r = false","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs)","proofString":"destruct (is_callee_save r) eqn:CS; auto.\nassert (existsb is_callee_save regs = true).\napply existsb_exists.\nexists r; auto.\ncongruence."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs) (CS : is_callee_save r = true) : true = false.","conclusion":"true = false","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs) (CS : is_callee_save r = true)","proofString":"assert (existsb is_callee_save regs = true).\napply existsb_exists.\nexists r; auto.\ncongruence."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs) (CS : is_callee_save r = true) : existsb is_callee_save regs = true.","conclusion":"existsb is_callee_save regs = true","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs) (CS : is_callee_save r = true)","proofString":"apply existsb_exists.\nexists r; auto."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs) (CS : is_callee_save r = true) : exists x : mreg, In x regs /\\ is_callee_save x = true.","conclusion":"exists x : mreg, In x regs /\\ is_callee_save x = true","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs) (CS : is_callee_save r = true)","proofString":"exists r; auto."},{"statement":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs) (CS : is_callee_save r = true) (H2 : existsb is_callee_save regs = true) : true = false.","conclusion":"true = false","hypotheses":"(ls0 : locset) (regs : list mreg) (ls : locset) (H : agree_locs ls ls0) (H0 : existsb is_callee_save regs = false) (r : mreg) (H1 : In r regs) (CS : is_callee_save r = true) (H2 : existsb is_callee_save regs = true)","proofString":"congruence."},{"statement":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : agree_locs ls ls0) (H0 : slot_writable sl = true) : agree_locs (Locmap.set (S sl ofs ty) v ls) ls0.","conclusion":"agree_locs (Locmap.set (S sl ofs ty) v ls) ls0","hypotheses":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : agree_locs ls ls0) (H0 : slot_writable sl = true)","proofString":"destruct H; constructor; intros.\nrewrite Locmap.gso; auto.\nred; auto.\nrewrite Locmap.gso; auto.\nred.\nleft.\ndestruct sl; discriminate."},{"statement":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (H0 : slot_writable sl = true) (r : mreg) (H : ~ mreg_within_bounds b r) : Locmap.set (S sl ofs ty) v ls (R r) = ls0 (R r).","conclusion":"Locmap.set (S sl ofs ty) v ls (R r) = ls0 (R r)","hypotheses":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (H0 : slot_writable sl = true) (r : mreg) (H : ~ mreg_within_bounds b r)","proofString":"rewrite Locmap.gso; auto.\nred; auto."},{"statement":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (H0 : slot_writable sl = true) (r : mreg) (H : ~ mreg_within_bounds b r) : Loc.diff (S sl ofs ty) (R r).","conclusion":"Loc.diff (S sl ofs ty) (R r)","hypotheses":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (H0 : slot_writable sl = true) (r : mreg) (H : ~ mreg_within_bounds b r)","proofString":"red; auto."},{"statement":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs1 : Z) (ty1 : typ),\nIn (S Incoming ofs1 ty1) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs1 ty1) = ls0 (S Outgoing ofs1 ty1)) (H0 : slot_writable sl = true) (ofs0 : Z) (ty0 : typ) (H : In (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) : Locmap.set (S sl ofs ty) v ls (S Incoming ofs0 ty0) =\nls0 (S Outgoing ofs0 ty0).","conclusion":"Locmap.set (S sl ofs ty) v ls (S Incoming ofs0 ty0) =\nls0 (S Outgoing ofs0 ty0)","hypotheses":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs1 : Z) (ty1 : typ),\nIn (S Incoming ofs1 ty1) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs1 ty1) = ls0 (S Outgoing ofs1 ty1)) (H0 : slot_writable sl = true) (ofs0 : Z) (ty0 : typ) (H : In (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))))","proofString":"rewrite Locmap.gso; auto.\nred.\nleft.\ndestruct sl; discriminate."},{"statement":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs1 : Z) (ty1 : typ),\nIn (S Incoming ofs1 ty1) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs1 ty1) = ls0 (S Outgoing ofs1 ty1)) (H0 : slot_writable sl = true) (ofs0 : Z) (ty0 : typ) (H : In (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) : Loc.diff (S sl ofs ty) (S Incoming ofs0 ty0).","conclusion":"Loc.diff (S sl ofs ty) (S Incoming ofs0 ty0)","hypotheses":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs1 : Z) (ty1 : typ),\nIn (S Incoming ofs1 ty1) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs1 ty1) = ls0 (S Outgoing ofs1 ty1)) (H0 : slot_writable sl = true) (ofs0 : Z) (ty0 : typ) (H : In (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))))","proofString":"red.\nleft.\ndestruct sl; discriminate."},{"statement":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs1 : Z) (ty1 : typ),\nIn (S Incoming ofs1 ty1) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs1 ty1) = ls0 (S Outgoing ofs1 ty1)) (H0 : slot_writable sl = true) (ofs0 : Z) (ty0 : typ) (H : In (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) : sl <> Incoming \\/ ofs + typesize ty <= ofs0 \\/ ofs0 + typesize ty0 <= ofs.","conclusion":"sl <> Incoming \\/ ofs + typesize ty <= ofs0 \\/ ofs0 + typesize ty0 <= ofs","hypotheses":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs1 : Z) (ty1 : typ),\nIn (S Incoming ofs1 ty1) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs1 ty1) = ls0 (S Outgoing ofs1 ty1)) (H0 : slot_writable sl = true) (ofs0 : Z) (ty0 : typ) (H : In (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))))","proofString":"left.\ndestruct sl; discriminate."},{"statement":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs1 : Z) (ty1 : typ),\nIn (S Incoming ofs1 ty1) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs1 ty1) = ls0 (S Outgoing ofs1 ty1)) (H0 : slot_writable sl = true) (ofs0 : Z) (ty0 : typ) (H : In (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) : sl <> Incoming.","conclusion":"sl <> Incoming","hypotheses":"(ls ls0 : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs1 : Z) (ty1 : typ),\nIn (S Incoming ofs1 ty1) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs1 ty1) = ls0 (S Outgoing ofs1 ty1)) (H0 : slot_writable sl = true) (ofs0 : Z) (ty0 : typ) (H : In (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))))","proofString":"destruct sl; discriminate."},{"statement":"(ls ls0 : locset) (ls' : Locmap.t) (H : agree_locs ls ls0) (H0 : agree_callee_save ls' ls) : agree_locs ls' ls0.","conclusion":"agree_locs ls' ls0","hypotheses":"(ls ls0 : locset) (ls' : Locmap.t) (H : agree_locs ls ls0) (H0 : agree_callee_save ls' ls)","proofString":"red in H0.\ninv H; constructor; auto; intros.\nrewrite H0; auto.\nunfold mreg_within_bounds in H.\ntauto.\nrewrite <- agree_incoming0 by auto.\napply H0.\ncongruence."},{"statement":"(ls ls0 : locset) (ls' : Locmap.t) (H : agree_locs ls ls0) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) : agree_locs ls' ls0.","conclusion":"agree_locs ls' ls0","hypotheses":"(ls ls0 : locset) (ls' : Locmap.t) (H : agree_locs ls ls0) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l)","proofString":"inv H; constructor; auto; intros.\nrewrite H0; auto.\nunfold mreg_within_bounds in H.\ntauto.\nrewrite <- agree_incoming0 by auto.\napply H0.\ncongruence."},{"statement":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r : mreg) (H : ~ mreg_within_bounds b r) : ls' (R r) = ls0 (R r).","conclusion":"ls' (R r) = ls0 (R r)","hypotheses":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r : mreg) (H : ~ mreg_within_bounds b r)","proofString":"rewrite H0; auto.\nunfold mreg_within_bounds in H.\ntauto."},{"statement":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r : mreg) (H : ~ mreg_within_bounds b r) : callee_save_loc (R r).","conclusion":"callee_save_loc (R r)","hypotheses":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r : mreg) (H : ~ mreg_within_bounds b r)","proofString":"unfold mreg_within_bounds in H.\ntauto."},{"statement":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r : mreg) (H : ~ (is_callee_save r = true -> In r (used_callee_save b))) : callee_save_loc (R r).","conclusion":"callee_save_loc (R r)","hypotheses":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (r : mreg) (H : ~ (is_callee_save r = true -> In r (used_callee_save b)))","proofString":"tauto."},{"statement":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (ofs : Z) (ty : typ) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) : ls' (S Incoming ofs ty) = ls0 (S Outgoing ofs ty).","conclusion":"ls' (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)","hypotheses":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (ofs : Z) (ty : typ) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))))","proofString":"rewrite <- agree_incoming0 by auto.\napply H0.\ncongruence."},{"statement":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (ofs : Z) (ty : typ) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) : ls' (S Incoming ofs ty) = ls (S Incoming ofs ty).","conclusion":"ls' (S Incoming ofs ty) = ls (S Incoming ofs ty)","hypotheses":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (ofs : Z) (ty : typ) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))))","proofString":"apply H0.\ncongruence."},{"statement":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (ofs : Z) (ty : typ) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) : callee_save_loc (S Incoming ofs ty).","conclusion":"callee_save_loc (S Incoming ofs ty)","hypotheses":"(ls ls0 : locset) (ls' : Locmap.t) (H0 : forall l : loc, callee_save_loc l -> ls' l = ls l) (agree_unused_reg0 : forall r : mreg, ~ mreg_within_bounds b r -> ls (R r) = ls0 (R r)) (agree_incoming0 : forall (ofs0 : Z) (ty0 : typ),\nIn (S Incoming ofs0 ty0) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs0 ty0) = ls0 (S Outgoing ofs0 ty0)) (ofs : Z) (ty : typ) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))))","proofString":"congruence."},{"statement":"(r : mreg) (ls : LTL.locset) (H : False) : ls (R r) = Vundef.","conclusion":"ls (R r) = Vundef","hypotheses":"(r : mreg) (ls : LTL.locset) (H : False)","proofString":"contradiction."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) : Locmap.set (R a) Vundef (LTL.undef_regs rl ls) (R r) = Vundef.","conclusion":"Locmap.set (R a) Vundef (LTL.undef_regs rl ls) (R r) = Vundef","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl)","proofString":"unfold Locmap.set.\ndestruct (Loc.eq (R a) (R r)).\nauto.\ndestruct (Loc.diff_dec (R a) (R r)); auto.\napply IHrl.\nintuition congruence."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) : (if Loc.eq (R a) (R r)\n then Vundef\n else if Loc.diff_dec (R a) (R r) then LTL.undef_regs rl ls (R r) else Vundef) =\nVundef.","conclusion":"(if Loc.eq (R a) (R r)\n then Vundef\n else if Loc.diff_dec (R a) (R r) then LTL.undef_regs rl ls (R r) else Vundef) =\nVundef","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl)","proofString":"destruct (Loc.eq (R a) (R r)).\nauto.\ndestruct (Loc.diff_dec (R a) (R r)); auto.\napply IHrl.\nintuition congruence."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) (e : R a = R r) : Vundef = Vundef.","conclusion":"Vundef = Vundef","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) (e : R a = R r)","proofString":"auto."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) (n : R a <> R r) : (if Loc.diff_dec (R a) (R r) then LTL.undef_regs rl ls (R r) else Vundef) =\nVundef.","conclusion":"(if Loc.diff_dec (R a) (R r) then LTL.undef_regs rl ls (R r) else Vundef) =\nVundef","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) (n : R a <> R r)","proofString":"destruct (Loc.diff_dec (R a) (R r)); auto.\napply IHrl.\nintuition congruence."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) (n : R a <> R r) (d : Loc.diff (R a) (R r)) : LTL.undef_regs rl ls (R r) = Vundef.","conclusion":"LTL.undef_regs rl ls (R r) = Vundef","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) (n : R a <> R r) (d : Loc.diff (R a) (R r))","proofString":"apply IHrl.\nintuition congruence."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) (n : R a <> R r) (d : Loc.diff (R a) (R r)) : In r rl.","conclusion":"In r rl","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, In r rl -> LTL.undef_regs rl ls0 (R r) = Vundef) (ls : LTL.locset) (H : a = r \\/ In r rl) (n : R a <> R r) (d : Loc.diff (R a) (R r))","proofString":"intuition congruence."},{"statement":"(r : mreg) (ls : LTL.locset) (H : ~ False) : ls (R r) = ls (R r).","conclusion":"ls (R r) = ls (R r)","hypotheses":"(r : mreg) (ls : LTL.locset) (H : ~ False)","proofString":"auto."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl)) : Locmap.set (R a) Vundef (LTL.undef_regs rl ls) (R r) = ls (R r).","conclusion":"Locmap.set (R a) Vundef (LTL.undef_regs rl ls) (R r) = ls (R r)","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl))","proofString":"rewrite Locmap.gso.\napply IHrl.\nintuition.\nred.\nintuition."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl)) : LTL.undef_regs rl ls (R r) = ls (R r).","conclusion":"LTL.undef_regs rl ls (R r) = ls (R r)","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl))","proofString":"apply IHrl.\nintuition."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl)) : ~ In r rl.","conclusion":"~ In r rl","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl))","proofString":"intuition."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl)) : Loc.diff (R a) (R r).","conclusion":"Loc.diff (R a) (R r)","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl))","proofString":"red.\nintuition."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl)) : a <> r.","conclusion":"a <> r","hypotheses":"(r a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset, ~ In r rl -> LTL.undef_regs rl ls0 (R r) = ls0 (R r)) (ls : LTL.locset) (H : ~ (a = r \\/ In r rl))","proofString":"intuition."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (ls : LTL.locset) : ls (S sl ofs ty) = ls (S sl ofs ty).","conclusion":"ls (S sl ofs ty) = ls (S sl ofs ty)","hypotheses":"(sl : slot) (ofs : Z) (ty : typ) (ls : LTL.locset)","proofString":"auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset,\nLTL.undef_regs rl ls0 (S sl ofs ty) = ls0 (S sl ofs ty)) (ls : LTL.locset) : Locmap.set (R a) Vundef (LTL.undef_regs rl ls) (S sl ofs ty) =\nls (S sl ofs ty).","conclusion":"Locmap.set (R a) Vundef (LTL.undef_regs rl ls) (S sl ofs ty) =\nls (S sl ofs ty)","hypotheses":"(sl : slot) (ofs : Z) (ty : typ) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset,\nLTL.undef_regs rl ls0 (S sl ofs ty) = ls0 (S sl ofs ty)) (ls : LTL.locset)","proofString":"rewrite Locmap.gso.\napply IHrl.\nred; auto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset,\nLTL.undef_regs rl ls0 (S sl ofs ty) = ls0 (S sl ofs ty)) (ls : LTL.locset) : LTL.undef_regs rl ls (S sl ofs ty) = ls (S sl ofs ty).","conclusion":"LTL.undef_regs rl ls (S sl ofs ty) = ls (S sl ofs ty)","hypotheses":"(sl : slot) (ofs : Z) (ty : typ) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset,\nLTL.undef_regs rl ls0 (S sl ofs ty) = ls0 (S sl ofs ty)) (ls : LTL.locset)","proofString":"apply IHrl."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset,\nLTL.undef_regs rl ls0 (S sl ofs ty) = ls0 (S sl ofs ty)) (ls : LTL.locset) : Loc.diff (R a) (S sl ofs ty).","conclusion":"Loc.diff (R a) (S sl ofs ty)","hypotheses":"(sl : slot) (ofs : Z) (ty : typ) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : LTL.locset,\nLTL.undef_regs rl ls0 (S sl ofs ty) = ls0 (S sl ofs ty)) (ls : LTL.locset)","proofString":"red; auto."},{"statement":"(ty : typ) (l : loc) (ls : loc -> val) (H : Val.has_type (ls l) ty) : Val.has_type (ls l) ty.","conclusion":"Val.has_type (ls l) ty","hypotheses":"(ty : typ) (l : loc) (ls : loc -> val) (H : Val.has_type (ls l) ty)","proofString":"auto."},{"statement":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty) : Val.has_type (Locmap.set (R a) Vundef (LTL.undef_regs rl ls) l) ty.","conclusion":"Val.has_type (Locmap.set (R a) Vundef (LTL.undef_regs rl ls) l) ty","hypotheses":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty)","proofString":"unfold Locmap.set.\ndestruct (Loc.eq (R a) l).\nred; auto.\ndestruct (Loc.diff_dec (R a) l); auto.\nred; auto."},{"statement":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty) : Val.has_type\n  (if Loc.eq (R a) l\n   then Vundef\n   else if Loc.diff_dec (R a) l then LTL.undef_regs rl ls l else Vundef) ty.","conclusion":"Val.has_type\n  (if Loc.eq (R a) l\n   then Vundef\n   else if Loc.diff_dec (R a) l then LTL.undef_regs rl ls l else Vundef) ty","hypotheses":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty)","proofString":"destruct (Loc.eq (R a) l).\nred; auto.\ndestruct (Loc.diff_dec (R a) l); auto.\nred; auto."},{"statement":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty) (e : R a = l) : Val.has_type Vundef ty.","conclusion":"Val.has_type Vundef ty","hypotheses":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty) (e : R a = l)","proofString":"red; auto."},{"statement":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty) (n : R a <> l) : Val.has_type\n  (if Loc.diff_dec (R a) l then LTL.undef_regs rl ls l else Vundef) ty.","conclusion":"Val.has_type\n  (if Loc.diff_dec (R a) l then LTL.undef_regs rl ls l else Vundef) ty","hypotheses":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty) (n : R a <> l)","proofString":"destruct (Loc.diff_dec (R a) l); auto.\nred; auto."},{"statement":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty) (n : R a <> l) (n0 : ~ Loc.diff (R a) l) : Val.has_type Vundef ty.","conclusion":"Val.has_type Vundef ty","hypotheses":"(ty : typ) (l : loc) (a : mreg) (rl : list mreg) (IHrl : forall ls0 : loc -> val,\nVal.has_type (ls0 l) ty -> Val.has_type (LTL.undef_regs rl ls0 l) ty) (ls : loc -> val) (H : Val.has_type (ls l) ty) (n : R a <> l) (n0 : ~ Loc.diff (R a) l)","proofString":"red; auto."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (ty : typ) (r : mreg) (H : In r (destroyed_by_setstack ty)) : LTL.undef_regs destroyed_at_function_entry (call_regs ls) (R r) = Vundef.","conclusion":"LTL.undef_regs destroyed_at_function_entry (call_regs ls) (R r) = Vundef","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (ty : typ) (r : mreg) (H : In r (destroyed_by_setstack ty))","proofString":"apply LTL_undef_regs_same.\neapply destroyed_by_setstack_function_entry; eauto."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (ty : typ) (r : mreg) (H : In r (destroyed_by_setstack ty)) : In r destroyed_at_function_entry.","conclusion":"In r destroyed_at_function_entry","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (ty : typ) (r : mreg) (H : In r (destroyed_by_setstack ty))","proofString":"eapply destroyed_by_setstack_function_entry; eauto."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (r : mreg) : Val.has_type\n  (LTL.undef_regs destroyed_at_function_entry (call_regs ls) (R r))\n  (mreg_type r).","conclusion":"Val.has_type\n  (LTL.undef_regs destroyed_at_function_entry (call_regs ls) (R r))\n  (mreg_type r)","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (r : mreg)","proofString":"apply undef_regs_type.\napply TY."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (r : mreg) : Val.has_type (call_regs ls (R r)) (mreg_type r).","conclusion":"Val.has_type (call_regs ls (R r)) (mreg_type r)","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (r : mreg)","proofString":"apply TY."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) : agree_regs j (call_regs ls) rs.","conclusion":"agree_regs j (call_regs ls) rs","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset)","proofString":"apply agree_regs_call_regs.\nauto."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) : agree_regs j ls rs.","conclusion":"agree_regs j ls rs","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (SEP : m\n|= range sp (fe_ofs_callee_save fe)\n     (size_callee_save_area b (fe_ofs_callee_save fe)) ** P) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset)","proofString":"auto."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P.","conclusion":"m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs')","proofString":"exact SEP."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) : LTL.undef_regs destroyed_at_function_entry (call_regs ls) (R r) = ls0 (R r).","conclusion":"LTL.undef_regs destroyed_at_function_entry (call_regs ls) (R r) = ls0 (R r)","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true)","proofString":"rewrite LTL_undef_regs_others.\nunfold call_regs.\napply AGCS; auto.\nred; intros.\nassert (existsb is_callee_save destroyed_at_function_entry = false)       by  (apply destroyed_at_function_entry_caller_save).\nassert (existsb is_callee_save destroyed_at_function_entry = true).\napply existsb_exists.\nexists r; auto.\ncongruence."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) : call_regs ls (R r) = ls0 (R r).","conclusion":"call_regs ls (R r) = ls0 (R r)","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true)","proofString":"unfold call_regs.\napply AGCS; auto."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) : ls (R r) = ls0 (R r).","conclusion":"ls (R r) = ls0 (R r)","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true)","proofString":"apply AGCS; auto."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) : ~ In r destroyed_at_function_entry.","conclusion":"~ In r destroyed_at_function_entry","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true)","proofString":"red; intros.\nassert (existsb is_callee_save destroyed_at_function_entry = false)       by  (apply destroyed_at_function_entry_caller_save).\nassert (existsb is_callee_save destroyed_at_function_entry = true).\napply existsb_exists.\nexists r; auto.\ncongruence."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry) : False.","conclusion":"False","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry)","proofString":"assert (existsb is_callee_save destroyed_at_function_entry = false)       by  (apply destroyed_at_function_entry_caller_save).\nassert (existsb is_callee_save destroyed_at_function_entry = true).\napply existsb_exists.\nexists r; auto.\ncongruence."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry) (H1 : existsb is_callee_save destroyed_at_function_entry = false) : False.","conclusion":"False","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry) (H1 : existsb is_callee_save destroyed_at_function_entry = false)","proofString":"assert (existsb is_callee_save destroyed_at_function_entry = true).\napply existsb_exists.\nexists r; auto.\ncongruence."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry) (H1 : existsb is_callee_save destroyed_at_function_entry = false) : existsb is_callee_save destroyed_at_function_entry = true.","conclusion":"existsb is_callee_save destroyed_at_function_entry = true","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry) (H1 : existsb is_callee_save destroyed_at_function_entry = false)","proofString":"apply existsb_exists.\nexists r; auto."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry) (H1 : existsb is_callee_save destroyed_at_function_entry = false) : exists x : mreg, In x destroyed_at_function_entry /\\ is_callee_save x = true.","conclusion":"exists x : mreg, In x destroyed_at_function_entry /\\ is_callee_save x = true","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry) (H1 : existsb is_callee_save destroyed_at_function_entry = false)","proofString":"exists r; auto."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry) (H1 : existsb is_callee_save destroyed_at_function_entry = false) (H2 : existsb is_callee_save destroyed_at_function_entry = true) : False.","conclusion":"False","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r0 : mreg, Val.has_type (ls (R r0)) (mreg_type r0)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') (r : mreg) (H : is_callee_save r = true) (H0 : In r destroyed_at_function_entry) (H1 : existsb is_callee_save destroyed_at_function_entry = false) (H2 : existsb is_callee_save destroyed_at_function_entry = true)","proofString":"congruence."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') : (forall (ofs : Z) (k0 : perm_kind) (p : permission),\n Mem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) /\\ \nagree_regs j ls1 rs'.","conclusion":"(forall (ofs : Z) (k0 : perm_kind) (p : permission),\n Mem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) /\\ \nagree_regs j ls1 rs'","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs')","proofString":"split.\nexact PERMS.\nexact AG'."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p.","conclusion":"forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs')","proofString":"exact PERMS."},{"statement":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs') : agree_regs j ls1 rs'.","conclusion":"agree_regs j ls1 rs'","hypotheses":"(j : meminj) (ls : loc -> val) (ls0 : Locmap.t) (rs : regset) (sp : block) (cs : list stackframe) (fb : block) (k : code) (m : mem) (P : massert) (TY : forall r : mreg, Val.has_type (ls (R r)) (mreg_type r)) (AGCS : agree_callee_save ls ls0) (AG : agree_regs j ls rs) (ls1 : LTL.locset) (rs1 : regset) (rs' : regset) (m' : mem) (EXEC : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (save_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs1 m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')) (SEP : m'\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls1 ** P) (PERMS : forall (ofs : Z) (k0 : perm_kind) (p : permission),\nMem.perm m sp ofs k0 p -> Mem.perm m' sp ofs k0 p) (AG' : agree_regs j ls1 rs')","proofString":"exact AG'."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m |= frame_contents j sp ls ls0 pa ra ** P) (H0 : agree_unused j ls0 rs) : exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r).","conclusion":"exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m |= frame_contents j sp ls ls0 pa ra ** P) (H0 : agree_unused j ls0 rs)","proofString":"unfold frame_contents, frame_contents_1 in H.\napply mconj_proj1 in H.\nrewrite ! sep_assoc in H.\napply sep_pick5 in H.\nexploit restore_callee_save_rec_correct; eauto.\nintros; unfold mreg_within_bounds; auto.\nintros (rs' & A & B & C & D).\nexists rs'.\nsplit.\neexact A.\nsplit; intros.\ndestruct (In_dec mreg_eq r (used_callee_save b)).\napply B; auto.\nrewrite C by auto.\napply H0.\nunfold mreg_within_bounds; tauto.\napply C.\nred; intros.\napply (used_callee_save_prop b) in H2.\ncongruence."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) pa **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) ra **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : agree_unused j ls0 rs) : exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r).","conclusion":"exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= mconj\n     (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n      contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n      hasvalue Mptr sp (fe_ofs_link fe) pa **\n      hasvalue Mptr sp (fe_ofs_retaddr fe) ra **\n      contains_callee_saves j sp (fe_ofs_callee_save fe) \n        (used_callee_save b) ls0)\n     (range sp 0 (fe_stack_data fe) **\n      range sp (fe_stack_data fe + bound_stack_data b) (fe_size fe)) ** P) (H0 : agree_unused j ls0 rs)","proofString":"apply mconj_proj1 in H.\nrewrite ! sep_assoc in H.\napply sep_pick5 in H.\nexploit restore_callee_save_rec_correct; eauto.\nintros; unfold mreg_within_bounds; auto.\nintros (rs' & A & B & C & D).\nexists rs'.\nsplit.\neexact A.\nsplit; intros.\ndestruct (In_dec mreg_eq r (used_callee_save b)).\napply B; auto.\nrewrite C by auto.\napply H0.\nunfold mreg_within_bounds; tauto.\napply C.\nred; intros.\napply (used_callee_save_prop b) in H2.\ncongruence."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) pa **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) ra **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P) (H0 : agree_unused j ls0 rs) : exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r).","conclusion":"exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= (contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n    contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n    hasvalue Mptr sp (fe_ofs_link fe) pa **\n    hasvalue Mptr sp (fe_ofs_retaddr fe) ra **\n    contains_callee_saves j sp (fe_ofs_callee_save fe) \n      (used_callee_save b) ls0) ** P) (H0 : agree_unused j ls0 rs)","proofString":"rewrite ! sep_assoc in H.\napply sep_pick5 in H.\nexploit restore_callee_save_rec_correct; eauto.\nintros; unfold mreg_within_bounds; auto.\nintros (rs' & A & B & C & D).\nexists rs'.\nsplit.\neexact A.\nsplit; intros.\ndestruct (In_dec mreg_eq r (used_callee_save b)).\napply B; auto.\nrewrite C by auto.\napply H0.\nunfold mreg_within_bounds; tauto.\napply C.\nred; intros.\napply (used_callee_save_prop b) in H2.\ncongruence."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) pa **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) ra **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H0 : agree_unused j ls0 rs) : exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r).","conclusion":"exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_locations j sp (fe_ofs_local fe) (bound_local b) Local ls **\n   contains_locations j sp fe_ofs_arg (bound_outgoing b) Outgoing ls **\n   hasvalue Mptr sp (fe_ofs_link fe) pa **\n   hasvalue Mptr sp (fe_ofs_retaddr fe) ra **\n   contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0 ** P) (H0 : agree_unused j ls0 rs)","proofString":"apply sep_pick5 in H.\nexploit restore_callee_save_rec_correct; eauto.\nintros; unfold mreg_within_bounds; auto.\nintros (rs' & A & B & C & D).\nexists rs'.\nsplit.\neexact A.\nsplit; intros.\ndestruct (In_dec mreg_eq r (used_callee_save b)).\napply B; auto.\nrewrite C by auto.\napply H0.\nunfold mreg_within_bounds; tauto.\napply C.\nred; intros.\napply (used_callee_save_prop b) in H2.\ncongruence."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) : exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r).","conclusion":"exists rs' : regset,\n  star step tge\n    (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m) E0\n    (State cs fb (Vptr sp Ptrofs.zero) k rs' m) /\\\n  (forall r : mreg,\n   is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) /\\\n  (forall r : mreg, is_callee_save r = false -> rs' r = rs r)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs)","proofString":"exploit restore_callee_save_rec_correct; eauto.\nintros; unfold mreg_within_bounds; auto.\nintros (rs' & A & B & C & D).\nexists rs'.\nsplit.\neexact A.\nsplit; intros.\ndestruct (In_dec mreg_eq r (used_callee_save b)).\napply B; auto.\nrewrite C by auto.\napply H0.\nunfold mreg_within_bounds; tauto.\napply C.\nred; intros.\napply (used_callee_save_prop b) in H2.\ncongruence."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) : forall r : mreg, In r (used_callee_save b) -> mreg_within_bounds b r.","conclusion":"forall r : mreg, In r (used_callee_save b) -> mreg_within_bounds b r","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs)","proofString":"intros; unfold mreg_within_bounds; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true) : Val.inject j (ls0 (R r)) (rs' r).","conclusion":"Val.inject j (ls0 (R r)) (rs' r)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true)","proofString":"destruct (In_dec mreg_eq r (used_callee_save b)).\napply B; auto.\nrewrite C by auto.\napply H0.\nunfold mreg_within_bounds; tauto."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true) (i : In r (used_callee_save b)) : Val.inject j (ls0 (R r)) (rs' r).","conclusion":"Val.inject j (ls0 (R r)) (rs' r)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true) (i : In r (used_callee_save b))","proofString":"apply B; auto."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true) (n : ~ In r (used_callee_save b)) : Val.inject j (ls0 (R r)) (rs' r).","conclusion":"Val.inject j (ls0 (R r)) (rs' r)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true) (n : ~ In r (used_callee_save b))","proofString":"rewrite C by auto.\napply H0.\nunfold mreg_within_bounds; tauto."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true) (n : ~ In r (used_callee_save b)) : Val.inject j (ls0 (R r)) (rs r).","conclusion":"Val.inject j (ls0 (R r)) (rs r)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true) (n : ~ In r (used_callee_save b))","proofString":"apply H0.\nunfold mreg_within_bounds; tauto."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true) (n : ~ In r (used_callee_save b)) : ~ mreg_within_bounds b r.","conclusion":"~ mreg_within_bounds b r","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = true) (n : ~ In r (used_callee_save b))","proofString":"unfold mreg_within_bounds; tauto."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = false) : rs' r = rs r.","conclusion":"rs' r = rs r","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = false)","proofString":"apply C.\nred; intros.\napply (used_callee_save_prop b) in H2.\ncongruence."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = false) : ~ In r (used_callee_save b).","conclusion":"~ In r (used_callee_save b)","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = false)","proofString":"red; intros.\napply (used_callee_save_prop b) in H2.\ncongruence."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = false) (H2 : In r (used_callee_save b)) : False.","conclusion":"False","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = false) (H2 : In r (used_callee_save b))","proofString":"apply (used_callee_save_prop b) in H2.\ncongruence."},{"statement":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = false) (H2 : is_callee_save r = true) : False.","conclusion":"False","hypotheses":"(m : mem) (j : meminj) (sp : block) (ls ls0 : locset) (pa ra : val) (P : massert) (rs : regset) (k : code) (cs : list stackframe) (fb : block) (H : m\n|= contains_callee_saves j sp (fe_ofs_callee_save fe) \n     (used_callee_save b) ls0) (H0 : agree_unused j ls0 rs) (rs' : regset) (A : star step tge\n  (State cs fb (Vptr sp Ptrofs.zero)\n     (restore_callee_save_rec (used_callee_save b) (fe_ofs_callee_save fe) k)\n     rs m) E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)) (B : forall r0 : mreg,\nIn r0 (used_callee_save b) -> Val.inject j (ls0 (R r0)) (rs' r0)) (C : forall r0 : mreg, ~ In r0 (used_callee_save b) -> rs' r0 = rs r0) (D : agree_unused j ls0 rs') (r : mreg) (H1 : is_callee_save r = false) (H2 : is_callee_save r = true)","proofString":"congruence."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) : exists (rs1 : regset) (m1' : mem),\n  load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) = Some pa /\\\n  load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) = Some ra /\\\n  Mem.free m' sp' 0 (fn_stacksize tf) = Some m1' /\\\n  star step tge\n    (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n    (State cs fb (Vptr sp' Ptrofs.zero) k rs1 m') /\\\n  agree_regs j (return_regs ls0 ls) rs1 /\\\n  agree_callee_save (return_regs ls0 ls) ls0 /\\ m1' |= minjection j m1 ** P.","conclusion":"exists (rs1 : regset) (m1' : mem),\n  load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) = Some pa /\\\n  load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) = Some ra /\\\n  Mem.free m' sp' 0 (fn_stacksize tf) = Some m1' /\\\n  star step tge\n    (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n    (State cs fb (Vptr sp' Ptrofs.zero) k rs1 m') /\\\n  agree_regs j (return_regs ls0 ls) rs1 /\\\n  agree_callee_save (return_regs ls0 ls) ls0 /\\ m1' |= minjection j m1 ** P","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1)","proofString":"exploit free_parallel_rule.\nrewrite <- sep_assoc.\neapply mconj_proj2.\neexact SEP.\neexact FREE.\neexact INJ.\nauto.\nrewrite Z.max_comm; reflexivity.\nintros (m1' & FREE' & SEP').\nexploit restore_callee_save_correct.\neexact SEP.\ninstantiate (1 := rs).\nred; intros.\ndestruct AGL.\nrewrite <- agree_unused_reg0 by auto.\napply AGR.\nintros (rs' & LOAD_CS & CS & NCS).\nunfold frame_contents in SEP; apply mconj_proj1 in SEP.\nunfold frame_contents_1 in SEP; rewrite ! sep_assoc in SEP.\nexploit (hasvalue_get_stack Tptr).\nrewrite chunk_of_Tptr.\neapply sep_pick3; eexact SEP.\nintros LOAD_LINK.\nexploit (hasvalue_get_stack Tptr).\nrewrite chunk_of_Tptr.\neapply sep_pick4; eexact SEP.\nintros LOAD_RETADDR.\nclear SEP.\nrewrite unfold_transf_function; simpl.\nexists rs', m1'.\nsplit.\nassumption.\nsplit.\nassumption.\nsplit.\nassumption.\nsplit.\neassumption.\nsplit.\nred; unfold return_regs; intros.\ndestruct (is_callee_save r) eqn:C.\napply CS; auto.\nrewrite NCS by auto.\napply AGR.\nsplit.\nred; unfold return_regs; intros.\ndestruct l.\nrewrite H; auto.\ndestruct sl; auto; contradiction.\nassumption."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) : exists (rs1 : regset) (m1'0 : mem),\n  load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) = Some pa /\\\n  load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) = Some ra /\\\n  Mem.free m' sp' 0 (fn_stacksize tf) = Some m1'0 /\\\n  star step tge\n    (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n    (State cs fb (Vptr sp' Ptrofs.zero) k rs1 m') /\\\n  agree_regs j (return_regs ls0 ls) rs1 /\\\n  agree_callee_save (return_regs ls0 ls) ls0 /\\ m1'0 |= minjection j m1 ** P.","conclusion":"exists (rs1 : regset) (m1'0 : mem),\n  load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) = Some pa /\\\n  load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) = Some ra /\\\n  Mem.free m' sp' 0 (fn_stacksize tf) = Some m1'0 /\\\n  star step tge\n    (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n    (State cs fb (Vptr sp' Ptrofs.zero) k rs1 m') /\\\n  agree_regs j (return_regs ls0 ls) rs1 /\\\n  agree_callee_save (return_regs ls0 ls) ls0 /\\ m1'0 |= minjection j m1 ** P","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P)","proofString":"exploit restore_callee_save_correct.\neexact SEP.\ninstantiate (1 := rs).\nred; intros.\ndestruct AGL.\nrewrite <- agree_unused_reg0 by auto.\napply AGR.\nintros (rs' & LOAD_CS & CS & NCS).\nunfold frame_contents in SEP; apply mconj_proj1 in SEP.\nunfold frame_contents_1 in SEP; rewrite ! sep_assoc in SEP.\nexploit (hasvalue_get_stack Tptr).\nrewrite chunk_of_Tptr.\neapply sep_pick3; eexact SEP.\nintros LOAD_LINK.\nexploit (hasvalue_get_stack Tptr).\nrewrite chunk_of_Tptr.\neapply sep_pick4; eexact SEP.\nintros LOAD_RETADDR.\nclear SEP.\nrewrite unfold_transf_function; simpl.\nexists rs', m1'.\nsplit.\nassumption.\nsplit.\nassumption.\nsplit.\nassumption.\nsplit.\neassumption.\nsplit.\nred; unfold return_regs; intros.\ndestruct (is_callee_save r) eqn:C.\napply CS; auto.\nrewrite NCS by auto.\napply AGR.\nsplit.\nred; unfold return_regs; intros.\ndestruct l.\nrewrite H; auto.\ndestruct sl; auto; contradiction.\nassumption."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) : agree_unused j ls0 rs.","conclusion":"agree_unused j ls0 rs","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P)","proofString":"red; intros.\ndestruct AGL.\nrewrite <- agree_unused_reg0 by auto.\napply AGR."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (r : mreg) (H : ~ mreg_within_bounds b r) : Val.inject j (ls0 (R r)) (rs r).","conclusion":"Val.inject j (ls0 (R r)) (rs r)","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (r : mreg) (H : ~ mreg_within_bounds b r)","proofString":"destruct AGL.\nrewrite <- agree_unused_reg0 by auto.\napply AGR."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (r : mreg) (H : ~ mreg_within_bounds b r) : Val.inject j (ls0 (R r)) (rs r).","conclusion":"Val.inject j (ls0 (R r)) (rs r)","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (r : mreg) (H : ~ mreg_within_bounds b r)","proofString":"rewrite <- agree_unused_reg0 by auto.\napply AGR."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (r : mreg) (H : ~ mreg_within_bounds b r) : Val.inject j (ls (R r)) (rs r).","conclusion":"Val.inject j (ls (R r)) (rs r)","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (SEP : m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P) (AGR : agree_regs j ls rs) (agree_unused_reg0 : forall r0 : mreg, ~ mreg_within_bounds b r0 -> ls (R r0) = ls0 (R r0)) (agree_incoming0 : forall (ofs : Z) (ty : typ),\nIn (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) ->\nls (S Incoming ofs ty) = ls0 (S Outgoing ofs ty)) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (r : mreg) (H : ~ mreg_within_bounds b r)","proofString":"apply AGR."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) : agree_regs j (return_regs ls0 ls) rs'.","conclusion":"agree_regs j (return_regs ls0 ls) rs'","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra)","proofString":"red; unfold return_regs; intros.\ndestruct (is_callee_save r) eqn:C.\napply CS; auto.\nrewrite NCS by auto.\napply AGR."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg) : Val.inject j (if is_callee_save r then ls0 (R r) else ls (R r)) (rs' r).","conclusion":"Val.inject j (if is_callee_save r then ls0 (R r) else ls (R r)) (rs' r)","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg)","proofString":"destruct (is_callee_save r) eqn:C.\napply CS; auto.\nrewrite NCS by auto.\napply AGR."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg) (C : is_callee_save r = true) : Val.inject j (ls0 (R r)) (rs' r).","conclusion":"Val.inject j (ls0 (R r)) (rs' r)","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg) (C : is_callee_save r = true)","proofString":"apply CS; auto."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg) (C : is_callee_save r = false) : Val.inject j (ls (R r)) (rs' r).","conclusion":"Val.inject j (ls (R r)) (rs' r)","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg) (C : is_callee_save r = false)","proofString":"rewrite NCS by auto.\napply AGR."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg) (C : is_callee_save r = false) : Val.inject j (ls (R r)) (rs r).","conclusion":"Val.inject j (ls (R r)) (rs r)","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg) (C : is_callee_save r = false)","proofString":"apply AGR."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) : agree_callee_save (return_regs ls0 ls) ls0 /\\ m1' |= minjection j m1 ** P.","conclusion":"agree_callee_save (return_regs ls0 ls) ls0 /\\ m1' |= minjection j m1 ** P","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra)","proofString":"split.\nred; unfold return_regs; intros.\ndestruct l.\nrewrite H; auto.\ndestruct sl; auto; contradiction.\nassumption."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) : agree_callee_save (return_regs ls0 ls) ls0.","conclusion":"agree_callee_save (return_regs ls0 ls) ls0","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra)","proofString":"red; unfold return_regs; intros.\ndestruct l.\nrewrite H; auto.\ndestruct sl; auto; contradiction."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (l : loc) (H : callee_save_loc l) : match l with\n| R r => if is_callee_save r then ls0 (R r) else ls (R r)\n| S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => ls0 (S sl ofs ty)\n| S Outgoing _ _ => Vundef\nend = ls0 l.","conclusion":"match l with\n| R r => if is_callee_save r then ls0 (R r) else ls (R r)\n| S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => ls0 (S sl ofs ty)\n| S Outgoing _ _ => Vundef\nend = ls0 l","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (l : loc) (H : callee_save_loc l)","proofString":"destruct l.\nrewrite H; auto.\ndestruct sl; auto; contradiction."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg) (H : callee_save_loc (R r)) : (if is_callee_save r then ls0 (R r) else ls (R r)) = ls0 (R r).","conclusion":"(if is_callee_save r then ls0 (R r) else ls (R r)) = ls0 (R r)","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r0 : mreg,\nis_callee_save r0 = true -> Val.inject j (ls0 (R r0)) (rs' r0)) (NCS : forall r0 : mreg, is_callee_save r0 = false -> rs' r0 = rs r0) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (r : mreg) (H : callee_save_loc (R r))","proofString":"rewrite H; auto."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (sl : slot) (pos : Z) (ty : typ) (H : callee_save_loc (S sl pos ty)) : match sl with\n| Outgoing => Vundef\n| _ => ls0 (S sl pos ty)\nend = ls0 (S sl pos ty).","conclusion":"match sl with\n| Outgoing => Vundef\n| _ => ls0 (S sl pos ty)\nend = ls0 (S sl pos ty)","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) (sl : slot) (pos : Z) (ty : typ) (H : callee_save_loc (S sl pos ty))","proofString":"destruct sl; auto; contradiction."},{"statement":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra) : m1' |= minjection j m1 ** P.","conclusion":"m1' |= minjection j m1 ** P","hypotheses":"(m' : mem) (j : meminj) (sp' : block) (ls ls0 : locset) (pa ra : val) (P : massert) (m : mem) (rs : regset) (sp : block) (m1 : mem) (k : code) (cs : list stackframe) (fb : block) (AGR : agree_regs j ls rs) (AGL : agree_locs ls ls0) (INJ : j sp = Some (sp', fe_stack_data fe)) (FREE : Mem.free m sp 0 (Linear.fn_stacksize f) = Some m1) (m1' : mem) (FREE' : Mem.free m' sp' 0 (fe_size fe) = Some m1') (SEP' : m1' |= minjection j m1 ** P) (rs' : regset) (LOAD_CS : star step tge\n  (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m') E0\n  (State cs fb (Vptr sp' Ptrofs.zero) k rs' m')) (CS : forall r : mreg, is_callee_save r = true -> Val.inject j (ls0 (R r)) (rs' r)) (NCS : forall r : mreg, is_callee_save r = false -> rs' r = rs r) (LOAD_LINK : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_link fe)) =\nSome pa) (LOAD_RETADDR : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (Ptrofs.repr (fe_ofs_retaddr fe)) =\nSome ra)","proofString":"assumption."},{"statement":"(chunk : memory_chunk) (m : mem) (a v : val) (H : Mem.loadv chunk m a = Some v) : exists v' : val,\n  Mem.loadv (simplify_load chunk) m a = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  Mem.loadv (simplify_load chunk) m a = Some v' /\\ Val.lessdef v v'","hypotheses":"(chunk : memory_chunk) (m : mem) (a v : val) (H : Mem.loadv chunk m a = Some v)","proofString":"destruct a; simpl in *; try discriminate.\ndestruct chunk; simpl; try (exists v; auto; fail).\nrewrite Mem.load_bool_int8_unsigned in H.\ndestruct (Mem.load Mint8unsigned m b (Ptrofs.unsigned i)) as [v'|]; simpl in H; inv H.\nexists v'; auto using Val.norm_bool_is_lessdef."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (H : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) : exists v' : val,\n  Mem.load (simplify_load chunk) m b (Ptrofs.unsigned i) = Some v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  Mem.load (simplify_load chunk) m b (Ptrofs.unsigned i) = Some v' /\\\n  Val.lessdef v v'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (H : Mem.load chunk m b (Ptrofs.unsigned i) = Some v)","proofString":"destruct chunk; simpl; try (exists v; auto; fail).\nrewrite Mem.load_bool_int8_unsigned in H.\ndestruct (Mem.load Mint8unsigned m b (Ptrofs.unsigned i)) as [v'|]; simpl in H; inv H.\nexists v'; auto using Val.norm_bool_is_lessdef."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (H : Mem.load Mbool m b (Ptrofs.unsigned i) = Some v) : exists v' : val,\n  Mem.load Mint8unsigned m b (Ptrofs.unsigned i) = Some v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  Mem.load Mint8unsigned m b (Ptrofs.unsigned i) = Some v' /\\\n  Val.lessdef v v'","hypotheses":"(m : mem) (b : block) (i : ptrofs) (v : val) (H : Mem.load Mbool m b (Ptrofs.unsigned i) = Some v)","proofString":"rewrite Mem.load_bool_int8_unsigned in H.\ndestruct (Mem.load Mint8unsigned m b (Ptrofs.unsigned i)) as [v'|]; simpl in H; inv H.\nexists v'; auto using Val.norm_bool_is_lessdef."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (H : option_map Val.norm_bool (Mem.load Mint8unsigned m b (Ptrofs.unsigned i)) =\nSome v) : exists v' : val,\n  Mem.load Mint8unsigned m b (Ptrofs.unsigned i) = Some v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  Mem.load Mint8unsigned m b (Ptrofs.unsigned i) = Some v' /\\\n  Val.lessdef v v'","hypotheses":"(m : mem) (b : block) (i : ptrofs) (v : val) (H : option_map Val.norm_bool (Mem.load Mint8unsigned m b (Ptrofs.unsigned i)) =\nSome v)","proofString":"destruct (Mem.load Mint8unsigned m b (Ptrofs.unsigned i)) as [v'|]; simpl in H; inv H.\nexists v'; auto using Val.norm_bool_is_lessdef."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v' : val) : exists v'0 : val, Some v' = Some v'0 /\\ Val.lessdef (Val.norm_bool v') v'0.","conclusion":"exists v'0 : val, Some v' = Some v'0 /\\ Val.lessdef (Val.norm_bool v') v'0","hypotheses":"(m : mem) (b : block) (i : ptrofs) (v' : val)","proofString":"exists v'; auto using Val.norm_bool_is_lessdef."},{"statement":"(chunk : memory_chunk) (m : mem) (a v : val) (m' : mem) (H : Mem.storev chunk m a v = Some m') : Mem.storev (simplify_store chunk) m a v = Some m'.","conclusion":"Mem.storev (simplify_store chunk) m a v = Some m'","hypotheses":"(chunk : memory_chunk) (m : mem) (a v : val) (m' : mem) (H : Mem.storev chunk m a v = Some m')","proofString":"destruct a; simpl in *; try discriminate.\nrewrite <- H.\nsymmetry.\ndestruct chunk; simpl; auto.\napply Mem.store_bool_unsigned_8.\napply Mem.store_signed_unsigned_8.\napply Mem.store_signed_unsigned_16."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') : Mem.store (simplify_store chunk) m b (Ptrofs.unsigned i) v = Some m'.","conclusion":"Mem.store (simplify_store chunk) m b (Ptrofs.unsigned i) v = Some m'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m')","proofString":"rewrite <- H.\nsymmetry.\ndestruct chunk; simpl; auto.\napply Mem.store_bool_unsigned_8.\napply Mem.store_signed_unsigned_8.\napply Mem.store_signed_unsigned_16."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') : Mem.store (simplify_store chunk) m b (Ptrofs.unsigned i) v =\nMem.store chunk m b (Ptrofs.unsigned i) v.","conclusion":"Mem.store (simplify_store chunk) m b (Ptrofs.unsigned i) v =\nMem.store chunk m b (Ptrofs.unsigned i) v","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m')","proofString":"symmetry.\ndestruct chunk; simpl; auto.\napply Mem.store_bool_unsigned_8.\napply Mem.store_signed_unsigned_8.\napply Mem.store_signed_unsigned_16."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') : Mem.store chunk m b (Ptrofs.unsigned i) v =\nMem.store (simplify_store chunk) m b (Ptrofs.unsigned i) v.","conclusion":"Mem.store chunk m b (Ptrofs.unsigned i) v =\nMem.store (simplify_store chunk) m b (Ptrofs.unsigned i) v","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m')","proofString":"destruct chunk; simpl; auto.\napply Mem.store_bool_unsigned_8.\napply Mem.store_signed_unsigned_8.\napply Mem.store_signed_unsigned_16."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store Mbool m b (Ptrofs.unsigned i) v = Some m') : Mem.store Mbool m b (Ptrofs.unsigned i) v =\nMem.store Mint8unsigned m b (Ptrofs.unsigned i) v.","conclusion":"Mem.store Mbool m b (Ptrofs.unsigned i) v =\nMem.store Mint8unsigned m b (Ptrofs.unsigned i) v","hypotheses":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store Mbool m b (Ptrofs.unsigned i) v = Some m')","proofString":"apply Mem.store_bool_unsigned_8."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store Mint8signed m b (Ptrofs.unsigned i) v = Some m') : Mem.store Mint8signed m b (Ptrofs.unsigned i) v =\nMem.store Mint8unsigned m b (Ptrofs.unsigned i) v.","conclusion":"Mem.store Mint8signed m b (Ptrofs.unsigned i) v =\nMem.store Mint8unsigned m b (Ptrofs.unsigned i) v","hypotheses":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store Mint8signed m b (Ptrofs.unsigned i) v = Some m')","proofString":"apply Mem.store_signed_unsigned_8."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store Mint16signed m b (Ptrofs.unsigned i) v = Some m') : Mem.store Mint16signed m b (Ptrofs.unsigned i) v =\nMem.store Mint16unsigned m b (Ptrofs.unsigned i) v.","conclusion":"Mem.store Mint16signed m b (Ptrofs.unsigned i) v =\nMem.store Mint16unsigned m b (Ptrofs.unsigned i) v","hypotheses":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store Mint16signed m b (Ptrofs.unsigned i) v = Some m')","proofString":"apply Mem.store_signed_unsigned_16."},{"statement":"(j j' : meminj) (H : inject_incr j j') (sg : signature) (H0 : tailcall_possible sg) : match_stacks j' nil nil sg.","conclusion":"match_stacks j' nil nil sg","hypotheses":"(j j' : meminj) (H : inject_incr j j') (sg : signature) (H0 : tailcall_possible sg)","proofString":"constructor; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H0 : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : match_stacks j' cs cs' (Linear.fn_sig f)) : match_stacks j' (Linear.Stackframe f (Vptr sp Ptrofs.zero) ls c :: cs)\n  (Stackframe fb (Vptr sp' Ptrofs.zero) ra c' :: cs') sg.","conclusion":"match_stacks j' (Linear.Stackframe f (Vptr sp Ptrofs.zero) ls c :: cs)\n  (Stackframe fb (Vptr sp' Ptrofs.zero) ra c' :: cs') sg","hypotheses":"(j j' : meminj) (H : inject_incr j j') (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H0 : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : match_stacks j' cs cs' (Linear.fn_sig f))","proofString":"econstructor; eauto."},{"statement":"(sg1 : signature) (j : meminj) (sg : signature) (H : tailcall_possible sg) (H0 : tailcall_possible sg1) : match_stacks j nil nil sg1.","conclusion":"match_stacks j nil nil sg1","hypotheses":"(sg1 : signature) (j : meminj) (sg : signature) (H : tailcall_possible sg) (H0 : tailcall_possible sg1)","proofString":"econstructor; eauto."},{"statement":"(sg1 : signature) (j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : tailcall_possible sg1 -> match_stacks j cs cs' sg1) (H0 : tailcall_possible sg1) : match_stacks j (Linear.Stackframe f (Vptr sp Ptrofs.zero) ls c :: cs)\n  (Stackframe fb (Vptr sp' Ptrofs.zero) ra c' :: cs') sg1.","conclusion":"match_stacks j (Linear.Stackframe f (Vptr sp Ptrofs.zero) ls c :: cs)\n  (Stackframe fb (Vptr sp' Ptrofs.zero) ra c' :: cs') sg1","hypotheses":"(sg1 : signature) (j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : tailcall_possible sg1 -> match_stacks j cs cs' sg1) (H0 : tailcall_possible sg1)","proofString":"econstructor; eauto.\nintros.\nelim (H0 _ H1)."},{"statement":"(sg1 : signature) (j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : tailcall_possible sg1 -> match_stacks j cs cs' sg1) (H0 : tailcall_possible sg1) : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg1)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty.","conclusion":"forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg1)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty","hypotheses":"(sg1 : signature) (j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : tailcall_possible sg1 -> match_stacks j cs cs' sg1) (H0 : tailcall_possible sg1)","proofString":"intros.\nelim (H0 _ H1)."},{"statement":"(sg1 : signature) (j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs0 ty0) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : tailcall_possible sg1 -> match_stacks j cs cs' sg1) (H0 : tailcall_possible sg1) (ofs : Z) (ty : typ) (H1 : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg1))) : slot_within_bounds (function_bounds f) Outgoing ofs ty.","conclusion":"slot_within_bounds (function_bounds f) Outgoing ofs ty","hypotheses":"(sg1 : signature) (j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs0 ty0) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : tailcall_possible sg1 -> match_stacks j cs cs' sg1) (H0 : tailcall_possible sg1) (ofs : Z) (ty : typ) (H1 : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg1)))","proofString":"elim (H0 _ H1)."},{"statement":"(j : meminj) (sg : signature) (H : tailcall_possible sg) : Val.has_type Vnullptr Tptr.","conclusion":"Val.has_type Vnullptr Tptr","hypotheses":"(j : meminj) (sg : signature) (H : tailcall_possible sg)","proofString":"apply Val.Vnullptr_has_type."},{"statement":"(j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : Val.has_type (parent_sp cs') Tptr) : Val.has_type (Vptr sp' Ptrofs.zero) Tptr.","conclusion":"Val.has_type (Vptr sp' Ptrofs.zero) Tptr","hypotheses":"(j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : Val.has_type (parent_sp cs') Tptr)","proofString":"apply Val.Vptr_has_type."},{"statement":"(j : meminj) (sg : signature) (H : tailcall_possible sg) : Val.has_type Vnullptr Tptr.","conclusion":"Val.has_type Vnullptr Tptr","hypotheses":"(j : meminj) (sg : signature) (H : tailcall_possible sg)","proofString":"apply Val.Vnullptr_has_type."},{"statement":"(j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : Val.has_type (parent_ra cs') Tptr) : Val.has_type ra Tptr.","conclusion":"Val.has_type ra Tptr","hypotheses":"(j : meminj) (f : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb sp' : block) (ra : val) (c' : code) (cs' : list stackframe) (sg : signature) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (TRC : transl_code (make_env (function_bounds f)) c = c') (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls (parent_locset cs)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (H : match_stacks j cs cs' (Linear.fn_sig f)) (IHmatch_stacks : Val.has_type (parent_ra cs') Tptr)","proofString":"auto."},{"statement":"(fe : frame_env) (i : Linear.instruction) (c : list Linear.instruction) : list_fold_right (transl_instr fe) (i :: c) nil =\ntransl_instr fe i (list_fold_right (transl_instr fe) c nil).","conclusion":"list_fold_right (transl_instr fe) (i :: c) nil =\ntransl_instr fe i (list_fold_right (transl_instr fe) c nil)","hypotheses":"(fe : frame_env) (i : Linear.instruction) (c : list Linear.instruction)","proofString":"rewrite list_fold_right_eq.\nauto."},{"statement":"(fe : frame_env) (i : Linear.instruction) (c : list Linear.instruction) : transl_instr fe i (list_fold_right (transl_instr fe) c nil) =\ntransl_instr fe i (list_fold_right (transl_instr fe) c nil).","conclusion":"transl_instr fe i (list_fold_right (transl_instr fe) c nil) =\ntransl_instr fe i (list_fold_right (transl_instr fe) c nil)","hypotheses":"(fe : frame_env) (i : Linear.instruction) (c : list Linear.instruction)","proofString":"auto."},{"statement":"(fe : frame_env) (lbl : label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl (transl_code fe (a :: c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl a then Some c else Linear.find_label lbl c).","conclusion":"find_label lbl (transl_code fe (a :: c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl a then Some c else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"rewrite transl_code_eq.\ndestruct a; unfold transl_instr; auto.\ndestruct s; simpl; auto.\ndestruct s; simpl; auto.\nunfold restore_callee_save.\nrewrite find_label_restore_callee_save.\nauto.\nsimpl.\ndestruct (peq lbl l).\nreflexivity.\nauto.\nunfold restore_callee_save.\nrewrite find_label_restore_callee_save.\nauto."},{"statement":"(fe : frame_env) (lbl : label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl (transl_instr fe a (transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl a then Some c else Linear.find_label lbl c).","conclusion":"find_label lbl (transl_instr fe a (transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl a then Some c else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"destruct a; unfold transl_instr; auto.\ndestruct s; simpl; auto.\ndestruct s; simpl; auto.\nunfold restore_callee_save.\nrewrite find_label_restore_callee_save.\nauto.\nsimpl.\ndestruct (peq lbl l).\nreflexivity.\nauto.\nunfold restore_callee_save.\nrewrite find_label_restore_callee_save.\nauto."},{"statement":"(fe : frame_env) (lbl : label) (s : slot) (z : Z) (t : typ) (m : mreg) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl\n  match s with\n  | Local =>\n      Mgetstack (Ptrofs.repr (offset_local fe z)) t m :: transl_code fe c\n  | Incoming =>\n      Mgetparam (Ptrofs.repr (offset_arg z)) t m :: transl_code fe c\n  | Outgoing =>\n      Mgetstack (Ptrofs.repr (offset_arg z)) t m :: transl_code fe c\n  end =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Lgetstack s z t m)\n   then Some c\n   else Linear.find_label lbl c).","conclusion":"find_label lbl\n  match s with\n  | Local =>\n      Mgetstack (Ptrofs.repr (offset_local fe z)) t m :: transl_code fe c\n  | Incoming =>\n      Mgetparam (Ptrofs.repr (offset_arg z)) t m :: transl_code fe c\n  | Outgoing =>\n      Mgetstack (Ptrofs.repr (offset_arg z)) t m :: transl_code fe c\n  end =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Lgetstack s z t m)\n   then Some c\n   else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (s : slot) (z : Z) (t : typ) (m : mreg) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"destruct s; simpl; auto."},{"statement":"(fe : frame_env) (lbl : label) (m : mreg) (s : slot) (z : Z) (t : typ) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl\n  match s with\n  | Local =>\n      Msetstack m (Ptrofs.repr (offset_local fe z)) t :: transl_code fe c\n  | Incoming => transl_code fe c\n  | Outgoing =>\n      Msetstack m (Ptrofs.repr (offset_arg z)) t :: transl_code fe c\n  end =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Lsetstack m s z t)\n   then Some c\n   else Linear.find_label lbl c).","conclusion":"find_label lbl\n  match s with\n  | Local =>\n      Msetstack m (Ptrofs.repr (offset_local fe z)) t :: transl_code fe c\n  | Incoming => transl_code fe c\n  | Outgoing =>\n      Msetstack m (Ptrofs.repr (offset_arg z)) t :: transl_code fe c\n  end =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Lsetstack m s z t)\n   then Some c\n   else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (m : mreg) (s : slot) (z : Z) (t : typ) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"destruct s; simpl; auto."},{"statement":"(fe : frame_env) (lbl : label) (s : signature) (s0 : mreg + ident) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl (restore_callee_save fe (Mtailcall s s0 :: transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Ltailcall s s0)\n   then Some c\n   else Linear.find_label lbl c).","conclusion":"find_label lbl (restore_callee_save fe (Mtailcall s s0 :: transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Ltailcall s s0)\n   then Some c\n   else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (s : signature) (s0 : mreg + ident) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"unfold restore_callee_save.\nrewrite find_label_restore_callee_save.\nauto."},{"statement":"(fe : frame_env) (lbl : label) (s : signature) (s0 : mreg + ident) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl\n  (restore_callee_save_rec (fe_used_callee_save fe) \n     (fe_ofs_callee_save fe) (Mtailcall s s0 :: transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Ltailcall s s0)\n   then Some c\n   else Linear.find_label lbl c).","conclusion":"find_label lbl\n  (restore_callee_save_rec (fe_used_callee_save fe) \n     (fe_ofs_callee_save fe) (Mtailcall s s0 :: transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Ltailcall s s0)\n   then Some c\n   else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (s : signature) (s0 : mreg + ident) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"rewrite find_label_restore_callee_save.\nauto."},{"statement":"(fe : frame_env) (lbl : label) (s : signature) (s0 : mreg + ident) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl (Mtailcall s s0 :: transl_code fe c) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Ltailcall s s0)\n   then Some c\n   else Linear.find_label lbl c).","conclusion":"find_label lbl (Mtailcall s s0 :: transl_code fe c) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Ltailcall s s0)\n   then Some c\n   else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (s : signature) (s0 : mreg + ident) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"auto."},{"statement":"(fe : frame_env) (lbl : label) (l : Linear.label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl (Mlabel l :: transl_code fe c) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Llabel l) then Some c else Linear.find_label lbl c).","conclusion":"find_label lbl (Mlabel l :: transl_code fe c) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl (Llabel l) then Some c else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (l : Linear.label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"simpl.\ndestruct (peq lbl l).\nreflexivity.\nauto."},{"statement":"(fe : frame_env) (lbl : label) (l : Linear.label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : (if if peq lbl l then true else false\n then Some (transl_code fe c)\n else find_label lbl (transl_code fe c)) =\noption_map (transl_code fe)\n  (if if peq lbl l then true else false\n   then Some c\n   else Linear.find_label lbl c).","conclusion":"(if if peq lbl l then true else false\n then Some (transl_code fe c)\n else find_label lbl (transl_code fe c)) =\noption_map (transl_code fe)\n  (if if peq lbl l then true else false\n   then Some c\n   else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (l : Linear.label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"destruct (peq lbl l).\nreflexivity.\nauto."},{"statement":"(fe : frame_env) (lbl : label) (l : Linear.label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) (e : lbl = l) : Some (transl_code fe c) = option_map (transl_code fe) (Some c).","conclusion":"Some (transl_code fe c) = option_map (transl_code fe) (Some c)","hypotheses":"(fe : frame_env) (lbl : label) (l : Linear.label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) (e : lbl = l)","proofString":"reflexivity."},{"statement":"(fe : frame_env) (lbl : label) (l : Linear.label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) (n : lbl <> l) : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c).","conclusion":"find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (l : Linear.label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) (n : lbl <> l)","proofString":"auto."},{"statement":"(fe : frame_env) (lbl : label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl (restore_callee_save fe (Mreturn :: transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl Lreturn then Some c else Linear.find_label lbl c).","conclusion":"find_label lbl (restore_callee_save fe (Mreturn :: transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl Lreturn then Some c else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"unfold restore_callee_save.\nrewrite find_label_restore_callee_save.\nauto."},{"statement":"(fe : frame_env) (lbl : label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl\n  (restore_callee_save_rec (fe_used_callee_save fe) \n     (fe_ofs_callee_save fe) (Mreturn :: transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl Lreturn then Some c else Linear.find_label lbl c).","conclusion":"find_label lbl\n  (restore_callee_save_rec (fe_used_callee_save fe) \n     (fe_ofs_callee_save fe) (Mreturn :: transl_code fe c)) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl Lreturn then Some c else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"rewrite find_label_restore_callee_save.\nauto."},{"statement":"(fe : frame_env) (lbl : label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c)) : find_label lbl (Mreturn :: transl_code fe c) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl Lreturn then Some c else Linear.find_label lbl c).","conclusion":"find_label lbl (Mreturn :: transl_code fe c) =\noption_map (transl_code fe)\n  (if Linear.is_label lbl Lreturn then Some c else Linear.find_label lbl c)","hypotheses":"(fe : frame_env) (lbl : label) (c : list Linear.instruction) (IHc : find_label lbl (transl_code fe c) =\noption_map (transl_code fe) (Linear.find_label lbl c))","proofString":"auto."},{"statement":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c) : find_label lbl (fn_code tf) =\nSome (transl_code (make_env (function_bounds f)) c).","conclusion":"find_label lbl (fn_code tf) =\nSome (transl_code (make_env (function_bounds f)) c)","hypotheses":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c)","proofString":"rewrite (unfold_transf_function _ _ H).\nsimpl.\nunfold transl_body.\nunfold save_callee_save.\nrewrite find_label_save_callee_save.\nrewrite find_label_transl_code.\nrewrite H0.\nreflexivity."},{"statement":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c) : find_label lbl\n  (fn_code\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = Some (transl_code (make_env (function_bounds f)) c).","conclusion":"find_label lbl\n  (fn_code\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = Some (transl_code (make_env (function_bounds f)) c)","hypotheses":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c)","proofString":"simpl.\nunfold transl_body.\nunfold save_callee_save.\nrewrite find_label_save_callee_save.\nrewrite find_label_transl_code.\nrewrite H0.\nreflexivity."},{"statement":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c) : find_label lbl (transl_body f (make_env (function_bounds f))) =\nSome (transl_code (make_env (function_bounds f)) c).","conclusion":"find_label lbl (transl_body f (make_env (function_bounds f))) =\nSome (transl_code (make_env (function_bounds f)) c)","hypotheses":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c)","proofString":"unfold transl_body.\nunfold save_callee_save.\nrewrite find_label_save_callee_save.\nrewrite find_label_transl_code.\nrewrite H0.\nreflexivity."},{"statement":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c) : find_label lbl\n  (save_callee_save (make_env (function_bounds f))\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f))) =\nSome (transl_code (make_env (function_bounds f)) c).","conclusion":"find_label lbl\n  (save_callee_save (make_env (function_bounds f))\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f))) =\nSome (transl_code (make_env (function_bounds f)) c)","hypotheses":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c)","proofString":"unfold save_callee_save.\nrewrite find_label_save_callee_save.\nrewrite find_label_transl_code.\nrewrite H0.\nreflexivity."},{"statement":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c) : find_label lbl\n  (save_callee_save_rec (fe_used_callee_save (make_env (function_bounds f)))\n     (fe_ofs_callee_save (make_env (function_bounds f)))\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f))) =\nSome (transl_code (make_env (function_bounds f)) c).","conclusion":"find_label lbl\n  (save_callee_save_rec (fe_used_callee_save (make_env (function_bounds f)))\n     (fe_ofs_callee_save (make_env (function_bounds f)))\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f))) =\nSome (transl_code (make_env (function_bounds f)) c)","hypotheses":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c)","proofString":"rewrite find_label_save_callee_save.\nrewrite find_label_transl_code.\nrewrite H0.\nreflexivity."},{"statement":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c) : find_label lbl\n  (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) =\nSome (transl_code (make_env (function_bounds f)) c).","conclusion":"find_label lbl\n  (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) =\nSome (transl_code (make_env (function_bounds f)) c)","hypotheses":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c)","proofString":"rewrite find_label_transl_code.\nrewrite H0.\nreflexivity."},{"statement":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c) : option_map (transl_code (make_env (function_bounds f)))\n  (Linear.find_label lbl (Linear.fn_code f)) =\nSome (transl_code (make_env (function_bounds f)) c).","conclusion":"option_map (transl_code (make_env (function_bounds f)))\n  (Linear.find_label lbl (Linear.fn_code f)) =\nSome (transl_code (make_env (function_bounds f)) c)","hypotheses":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c)","proofString":"rewrite H0.\nreflexivity."},{"statement":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c) : option_map (transl_code (make_env (function_bounds f))) (Some c) =\nSome (transl_code (make_env (function_bounds f)) c).","conclusion":"option_map (transl_code (make_env (function_bounds f))) (Some c) =\nSome (transl_code (make_env (function_bounds f)) c)","hypotheses":"(f : Linear.function) (tf : function) (lbl : Linear.label) (c : Linear.code) (H : transf_function f = OK tf) (H0 : Linear.find_label lbl (Linear.fn_code f) = Some c)","proofString":"reflexivity."},{"statement":"(lbl : Linear.label) : forall c' : Linear.code, None = Some c' -> is_tail c' nil.","conclusion":"forall c' : Linear.code, None = Some c' -> is_tail c' nil","hypotheses":"(lbl : Linear.label)","proofString":"intros; discriminate."},{"statement":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c' : Linear.code, Linear.find_label lbl c = Some c' -> is_tail c' c) : forall c' : Linear.code,\n(if Linear.is_label lbl a then Some c else Linear.find_label lbl c) = Some c' ->\nis_tail c' (a :: c).","conclusion":"forall c' : Linear.code,\n(if Linear.is_label lbl a then Some c else Linear.find_label lbl c) = Some c' ->\nis_tail c' (a :: c)","hypotheses":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c' : Linear.code, Linear.find_label lbl c = Some c' -> is_tail c' c)","proofString":"intro c'.\ncase (Linear.is_label lbl a); intros.\ninjection H; intro; subst c'.\nauto with coqlib.\nauto with coqlib."},{"statement":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c'0 : Linear.code, Linear.find_label lbl c = Some c'0 -> is_tail c'0 c) (c' : Linear.code) : (if Linear.is_label lbl a then Some c else Linear.find_label lbl c) = Some c' ->\nis_tail c' (a :: c).","conclusion":"(if Linear.is_label lbl a then Some c else Linear.find_label lbl c) = Some c' ->\nis_tail c' (a :: c)","hypotheses":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c'0 : Linear.code, Linear.find_label lbl c = Some c'0 -> is_tail c'0 c) (c' : Linear.code)","proofString":"case (Linear.is_label lbl a); intros.\ninjection H; intro; subst c'.\nauto with coqlib.\nauto with coqlib."},{"statement":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c'0 : Linear.code, Linear.find_label lbl c = Some c'0 -> is_tail c'0 c) (c' : Linear.code) (H : Some c = Some c') : is_tail c' (a :: c).","conclusion":"is_tail c' (a :: c)","hypotheses":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c'0 : Linear.code, Linear.find_label lbl c = Some c'0 -> is_tail c'0 c) (c' : Linear.code) (H : Some c = Some c')","proofString":"injection H; intro; subst c'.\nauto with coqlib."},{"statement":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c' : Linear.code, Linear.find_label lbl c = Some c' -> is_tail c' c) (H : Some c = Some c) : is_tail c (a :: c).","conclusion":"is_tail c (a :: c)","hypotheses":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c' : Linear.code, Linear.find_label lbl c = Some c' -> is_tail c' c) (H : Some c = Some c)","proofString":"auto with coqlib."},{"statement":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c'0 : Linear.code, Linear.find_label lbl c = Some c'0 -> is_tail c'0 c) (c' : Linear.code) (H : Linear.find_label lbl c = Some c') : is_tail c' (a :: c).","conclusion":"is_tail c' (a :: c)","hypotheses":"(lbl : Linear.label) (a : Linear.instruction) (c : list Linear.instruction) (IHc : forall c'0 : Linear.code, Linear.find_label lbl c = Some c'0 -> is_tail c'0 c) (c' : Linear.code) (H : Linear.find_label lbl c = Some c')","proofString":"auto with coqlib."},{"statement":"(ofs : Z) (k : list instruction) : is_tail k k.","conclusion":"is_tail k k","hypotheses":"(ofs : Z) (k : list instruction)","proofString":"auto with coqlib."},{"statement":"(a : mreg) (l : list mreg) (IHl : forall (ofs0 : Z) (k0 : list instruction),\nis_tail k0 (save_callee_save_rec l ofs0 k0)) (ofs : Z) (k : list instruction) : is_tail k\n  (Msetstack a (Ptrofs.repr (align ofs 8)) (mreg_type a)\n   :: save_callee_save_rec l (align ofs 8 + 8) k).","conclusion":"is_tail k\n  (Msetstack a (Ptrofs.repr (align ofs 8)) (mreg_type a)\n   :: save_callee_save_rec l (align ofs 8 + 8) k)","hypotheses":"(a : mreg) (l : list mreg) (IHl : forall (ofs0 : Z) (k0 : list instruction),\nis_tail k0 (save_callee_save_rec l ofs0 k0)) (ofs : Z) (k : list instruction)","proofString":"constructor; auto."},{"statement":"(ofs : Z) (k : list instruction) : is_tail k k.","conclusion":"is_tail k k","hypotheses":"(ofs : Z) (k : list instruction)","proofString":"auto with coqlib."},{"statement":"(a : mreg) (l : list mreg) (IHl : forall (ofs0 : Z) (k0 : list instruction),\nis_tail k0 (restore_callee_save_rec l ofs0 k0)) (ofs : Z) (k : list instruction) : is_tail k\n  (Mgetstack (Ptrofs.repr (align ofs 8)) (mreg_type a) a\n   :: restore_callee_save_rec l (align ofs 8 + 8) k).","conclusion":"is_tail k\n  (Mgetstack (Ptrofs.repr (align ofs 8)) (mreg_type a) a\n   :: restore_callee_save_rec l (align ofs 8 + 8) k)","hypotheses":"(a : mreg) (l : list mreg) (IHl : forall (ofs0 : Z) (k0 : list instruction),\nis_tail k0 (restore_callee_save_rec l ofs0 k0)) (ofs : Z) (k : list instruction)","proofString":"constructor; auto."},{"statement":"(fe : frame_env) (c : list Linear.instruction) : is_tail (transl_code fe c) (transl_code fe c).","conclusion":"is_tail (transl_code fe c) (transl_code fe c)","hypotheses":"(fe : frame_env) (c : list Linear.instruction)","proofString":"auto with coqlib."},{"statement":"(fe : frame_env) (i : Linear.instruction) (c1 c2 : list Linear.instruction) (H : is_tail c1 c2) (IHis_tail : is_tail (transl_code fe c1) (transl_code fe c2)) : is_tail (transl_code fe c1) (transl_code fe (i :: c2)).","conclusion":"is_tail (transl_code fe c1) (transl_code fe (i :: c2))","hypotheses":"(fe : frame_env) (i : Linear.instruction) (c1 c2 : list Linear.instruction) (H : is_tail c1 c2) (IHis_tail : is_tail (transl_code fe c1) (transl_code fe c2))","proofString":"rewrite transl_code_eq.\neapply is_tail_trans.\neauto.\napply is_tail_transl_instr."},{"statement":"(fe : frame_env) (i : Linear.instruction) (c1 c2 : list Linear.instruction) (H : is_tail c1 c2) (IHis_tail : is_tail (transl_code fe c1) (transl_code fe c2)) : is_tail (transl_code fe c1) (transl_instr fe i (transl_code fe c2)).","conclusion":"is_tail (transl_code fe c1) (transl_instr fe i (transl_code fe c2))","hypotheses":"(fe : frame_env) (i : Linear.instruction) (c1 c2 : list Linear.instruction) (H : is_tail c1 c2) (IHis_tail : is_tail (transl_code fe c1) (transl_code fe c2))","proofString":"eapply is_tail_trans.\neauto.\napply is_tail_transl_instr."},{"statement":"(f : Linear.fundef) (tf : fundef) : match f with\n| Internal f0 =>\n    bind (transf_function f0) (fun f' : function => OK (Internal f'))\n| External ef => OK (External ef)\nend = OK tf -> funsig tf = Linear.funsig f.","conclusion":"match f with\n| Internal f0 =>\n    bind (transf_function f0) (fun f' : function => OK (Internal f'))\n| External ef => OK (External ef)\nend = OK tf -> funsig tf = Linear.funsig f","hypotheses":"(f : Linear.fundef) (tf : fundef)","proofString":"destruct f; intros; monadInv H.\nrewrite (unfold_transf_function _ _ EQ).\nauto.\nauto."},{"statement":"(f : Linear.function) (x : function) (EQ : transf_function f = OK x) : funsig (Internal x) = Linear.funsig (Internal f).","conclusion":"funsig (Internal x) = Linear.funsig (Internal f)","hypotheses":"(f : Linear.function) (x : function) (EQ : transf_function f = OK x)","proofString":"rewrite (unfold_transf_function _ _ EQ).\nauto."},{"statement":"(f : Linear.function) (x : function) (EQ : transf_function f = OK x) : funsig\n  (Internal\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = Linear.funsig (Internal f).","conclusion":"funsig\n  (Internal\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = Linear.funsig (Internal f)","hypotheses":"(f : Linear.function) (x : function) (EQ : transf_function f = OK x)","proofString":"auto."},{"statement":"(e : external_function) : funsig (External e) = Linear.funsig (External e).","conclusion":"funsig (External e) = Linear.funsig (External e)","hypotheses":"(e : external_function)","proofString":"auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (ros : mreg + ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (FF : find_function ge ros ls = Some f) : exists (bf : block) (tf : fundef),\n  find_function_ptr tge ros rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists (bf : block) (tf : fundef),\n  find_function_ptr tge ros rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (ros : mreg + ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (FF : find_function ge ros ls = Some f)","proofString":"destruct ros; simpl in FF.\nexploit Genv.find_funct_inv; eauto.\nintros [b EQ].\nrewrite EQ in FF.\nrewrite Genv.find_funct_find_funct_ptr in FF.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\ngeneralize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto.\ndestruct (Genv.find_symbol ge i) as [b|] eqn:?; try discriminate.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\nrewrite symbols_preserved.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (FF : Genv.find_funct ge (ls (R m0)) = Some f) : exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (FF : Genv.find_funct ge (ls (R m0)) = Some f)","proofString":"exploit Genv.find_funct_inv; eauto.\nintros [b EQ].\nrewrite EQ in FF.\nrewrite Genv.find_funct_find_funct_ptr in FF.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\ngeneralize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (FF : Genv.find_funct ge (ls (R m0)) = Some f) : (exists b : block, ls (R m0) = Vptr b Ptrofs.zero) ->\nexists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"(exists b : block, ls (R m0) = Vptr b Ptrofs.zero) ->\nexists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (FF : Genv.find_funct ge (ls (R m0)) = Some f)","proofString":"intros [b EQ].\nrewrite EQ in FF.\nrewrite Genv.find_funct_find_funct_ptr in FF.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\ngeneralize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (FF : Genv.find_funct ge (ls (R m0)) = Some f) (b : block) (EQ : ls (R m0) = Vptr b Ptrofs.zero) : exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (FF : Genv.find_funct ge (ls (R m0)) = Some f) (b : block) (EQ : ls (R m0) = Vptr b Ptrofs.zero)","proofString":"rewrite EQ in FF.\nrewrite Genv.find_funct_find_funct_ptr in FF.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\ngeneralize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) : exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero)","proofString":"rewrite Genv.find_funct_find_funct_ptr in FF.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\ngeneralize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) : exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero)","proofString":"exploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\ngeneralize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) : (exists tf : fundef,\n   Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf) ->\nexists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"(exists tf : fundef,\n   Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf) ->\nexists (bf : block) (tf : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero)","proofString":"intros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\ngeneralize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : exists (bf : block) (tf0 : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf0 /\\ transf_fundef f = OK tf0.","conclusion":"exists (bf : block) (tf0 : fundef),\n  find_function_ptr tge (inl m0) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf0 /\\ transf_fundef f = OK tf0","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"exists b; exists tf; split; auto.\nsimpl.\ngeneralize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : find_function_ptr tge (inl m0) rs = Some b.","conclusion":"find_function_ptr tge (inl m0) rs = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"simpl.\ngeneralize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : match rs m0 with\n| Vptr b0 ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b0 else None\n| _ => None\nend = Some b.","conclusion":"match rs m0 with\n| Vptr b0 ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b0 else None\n| _ => None\nend = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"generalize (AG m0).\nrewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : Val.inject j (ls (R m0)) (rs m0) ->\nmatch rs m0 with\n| Vptr b0 ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b0 else None\n| _ => None\nend = Some b.","conclusion":"Val.inject j (ls (R m0)) (rs m0) ->\nmatch rs m0 with\n| Vptr b0 ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b0 else None\n| _ => None\nend = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"rewrite EQ.\nintro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : Val.inject j (Vptr b Ptrofs.zero) (rs m0) ->\nmatch rs m0 with\n| Vptr b0 ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b0 else None\n| _ => None\nend = Some b.","conclusion":"Val.inject j (Vptr b Ptrofs.zero) (rs m0) ->\nmatch rs m0 with\n| Vptr b0 ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b0 else None\n| _ => None\nend = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"intro INJ.\ninv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (INJ : Val.inject j (Vptr b Ptrofs.zero) (rs m0)) : match rs m0 with\n| Vptr b0 ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b0 else None\n| _ => None\nend = Some b.","conclusion":"match rs m0 with\n| Vptr b0 ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b0 else None\n| _ => None\nend = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (INJ : Val.inject j (Vptr b Ptrofs.zero) (rs m0))","proofString":"inv INJ.\nrewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nj b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (b2 : block) (delta : Z) (H2 : j b = Some (b2, delta)) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs m0) : (if Ptrofs.eq (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) Ptrofs.zero\n then Some b2\n else None) = Some b.","conclusion":"(if Ptrofs.eq (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) Ptrofs.zero\n then Some b2\n else None) = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nj b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (b2 : block) (delta : Z) (H2 : j b = Some (b2, delta)) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs m0)","proofString":"rewrite DOMAIN in H2.\ninv H2.\nsimpl.\nauto.\neapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nj b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (b2 : block) (delta : Z) (H2 : Some (b, 0) = Some (b2, delta)) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs m0) : (if Ptrofs.eq (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) Ptrofs.zero\n then Some b2\n else None) = Some b.","conclusion":"(if Ptrofs.eq (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) Ptrofs.zero\n then Some b2\n else None) = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nj b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (b2 : block) (delta : Z) (H2 : Some (b, 0) = Some (b2, delta)) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs m0)","proofString":"inv H2.\nsimpl.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nj b1 = Some (b0, delta) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b2 : block) (EQ : ls (R m0) = Vptr b2 Ptrofs.zero) (FF : Genv.find_funct_ptr ge b2 = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b2 = Some tf) (B : transf_fundef f = OK tf) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) = rs m0) : (if Ptrofs.eq (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) Ptrofs.zero\n then Some b2\n else None) = Some b2.","conclusion":"(if Ptrofs.eq (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) Ptrofs.zero\n then Some b2\n else None) = Some b2","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nj b1 = Some (b0, delta) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b2 : block) (EQ : ls (R m0) = Vptr b2 Ptrofs.zero) (FF : Genv.find_funct_ptr ge b2 = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b2 = Some tf) (B : transf_fundef f = OK tf) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) = rs m0)","proofString":"simpl.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nj b1 = Some (b0, delta) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b2 : block) (EQ : ls (R m0) = Vptr b2 Ptrofs.zero) (FF : Genv.find_funct_ptr ge b2 = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b2 = Some tf) (B : transf_fundef f = OK tf) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) = rs m0) : (if Ptrofs.eq (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) Ptrofs.zero\n then Some b2\n else None) = Some b2.","conclusion":"(if Ptrofs.eq (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) Ptrofs.zero\n then Some b2\n else None) = Some b2","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b0 : block) (delta : Z),\nj b1 = Some (b0, delta) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (b2 : block) (EQ : ls (R m0) = Vptr b2 Ptrofs.zero) (FF : Genv.find_funct_ptr ge b2 = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b2 = Some tf) (B : transf_fundef f = OK tf) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) = rs m0)","proofString":"auto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nj b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (b2 : block) (delta : Z) (H2 : j b = Some (b2, delta)) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs m0) : Plt b bound.","conclusion":"Plt b bound","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (m0 : mreg) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b0 : block) (delta0 : Z),\nj b1 = Some (b0, delta0) -> Plt b0 bound -> b1 = b0) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (EQ : ls (R m0) = Vptr b Ptrofs.zero) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) (b2 : block) (delta : Z) (H2 : j b = Some (b2, delta)) (H1 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = rs m0)","proofString":"eapply FUNCTIONS; eauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (FF : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) : exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inr i) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inr i) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b : positive, Plt b bound -> j b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b bound) (FUNCTIONS : forall (b : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b bound) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b bound) (FF : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f)","proofString":"destruct (Genv.find_symbol ge i) as [b|] eqn:?; try discriminate.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\nrewrite symbols_preserved.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) : exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inr i) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists (bf : block) (tf : fundef),\n  find_function_ptr tge (inr i) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f)","proofString":"exploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\nrewrite symbols_preserved.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) : (exists tf : fundef,\n   Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf) ->\nexists (bf : block) (tf : fundef),\n  find_function_ptr tge (inr i) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf.","conclusion":"(exists tf : fundef,\n   Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf) ->\nexists (bf : block) (tf : fundef),\n  find_function_ptr tge (inr i) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f)","proofString":"intros [tf [A B]].\nexists b; exists tf; split; auto.\nsimpl.\nrewrite symbols_preserved.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : exists (bf : block) (tf0 : fundef),\n  find_function_ptr tge (inr i) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf0 /\\ transf_fundef f = OK tf0.","conclusion":"exists (bf : block) (tf0 : fundef),\n  find_function_ptr tge (inr i) rs = Some bf /\\\n  Genv.find_funct_ptr tge bf = Some tf0 /\\ transf_fundef f = OK tf0","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"exists b; exists tf; split; auto.\nsimpl.\nrewrite symbols_preserved.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : find_function_ptr tge (inr i) rs = Some b.","conclusion":"find_function_ptr tge (inr i) rs = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"simpl.\nrewrite symbols_preserved.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : Genv.find_symbol tge i = Some b.","conclusion":"Genv.find_symbol tge i = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"rewrite symbols_preserved.\nauto."},{"statement":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : Genv.find_symbol ge i = Some b.","conclusion":"Genv.find_symbol ge i = Some b","hypotheses":"(j : meminj) (ls : locset) (rs : regset) (m : mem) (i : ident) (f : Linear.fundef) (AG : agree_regs j ls rs) (bound : positive) (DOMAIN : forall b0 : positive, Plt b0 bound -> j b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nj b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd : Linear.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) (b : block) (Heqo : Genv.find_symbol ge i = Some b) (FF : Genv.find_funct_ptr ge b = Some f) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"auto."},{"statement":"(l : loc) (H : In l (regs_of_rpairs (loc_arguments sg))) : exists v : val,\n  extcall_arg rs m' (parent_sp cs') l v /\\ Val.inject j (ls l) v.","conclusion":"exists v : val,\n  extcall_arg rs m' (parent_sp cs') l v /\\ Val.inject j (ls l) v","hypotheses":"(l : loc) (H : In l (regs_of_rpairs (loc_arguments sg)))","proofString":"assert (loc_argument_acceptable l) by (apply loc_arguments_acceptable_2 with sg; auto).\ndestruct l; red in H0.\nexists (rs r); split.\nconstructor.\nauto.\ndestruct sl; try contradiction.\ninv MS.\nelim (H1 _ H).\nsimpl in SEP.\nunfold parent_sp.\nassert (slot_valid f Outgoing pos ty = true).\ndestruct H0.\nunfold slot_valid, proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nreflexivity.\nassert (slot_within_bounds (function_bounds f) Outgoing pos ty) by eauto.\nexploit frame_get_outgoing; eauto.\nintros (v & A & B).\nexists v; split.\nconstructor.\nexact A.\nrewrite AGARGS by auto.\nexact B."},{"statement":"(l : loc) (H : In l (regs_of_rpairs (loc_arguments sg))) (H0 : loc_argument_acceptable l) : exists v : val,\n  extcall_arg rs m' (parent_sp cs') l v /\\ Val.inject j (ls l) v.","conclusion":"exists v : val,\n  extcall_arg rs m' (parent_sp cs') l v /\\ Val.inject j (ls l) v","hypotheses":"(l : loc) (H : In l (regs_of_rpairs (loc_arguments sg))) (H0 : loc_argument_acceptable l)","proofString":"destruct l; red in H0.\nexists (rs r); split.\nconstructor.\nauto.\ndestruct sl; try contradiction.\ninv MS.\nelim (H1 _ H).\nsimpl in SEP.\nunfold parent_sp.\nassert (slot_valid f Outgoing pos ty = true).\ndestruct H0.\nunfold slot_valid, proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nreflexivity.\nassert (slot_within_bounds (function_bounds f) Outgoing pos ty) by eauto.\nexploit frame_get_outgoing; eauto.\nintros (v & A & B).\nexists v; split.\nconstructor.\nexact A.\nrewrite AGARGS by auto.\nexact B."},{"statement":"(r : mreg) (H : In (R r) (regs_of_rpairs (loc_arguments sg))) (H0 : is_callee_save r = false) : exists v : val,\n  extcall_arg rs m' (parent_sp cs') (R r) v /\\ Val.inject j (ls (R r)) v.","conclusion":"exists v : val,\n  extcall_arg rs m' (parent_sp cs') (R r) v /\\ Val.inject j (ls (R r)) v","hypotheses":"(r : mreg) (H : In (R r) (regs_of_rpairs (loc_arguments sg))) (H0 : is_callee_save r = false)","proofString":"exists (rs r); split.\nconstructor.\nauto."},{"statement":"(r : mreg) (H : In (R r) (regs_of_rpairs (loc_arguments sg))) (H0 : is_callee_save r = false) : extcall_arg rs m' (parent_sp cs') (R r) (rs r).","conclusion":"extcall_arg rs m' (parent_sp cs') (R r) (rs r)","hypotheses":"(r : mreg) (H : In (R r) (regs_of_rpairs (loc_arguments sg))) (H0 : is_callee_save r = false)","proofString":"constructor."},{"statement":"(r : mreg) (H : In (R r) (regs_of_rpairs (loc_arguments sg))) (H0 : is_callee_save r = false) : Val.inject j (ls (R r)) (rs r).","conclusion":"Val.inject j (ls (R r)) (rs r)","hypotheses":"(r : mreg) (H : In (R r) (regs_of_rpairs (loc_arguments sg))) (H0 : is_callee_save r = false)","proofString":"auto."},{"statement":"(sl : slot) (pos : Z) (ty : typ) (H : In (S sl pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : match sl with\n| Outgoing => pos >= 0 /\\ (typealign ty | pos)\n| _ => False\nend) : exists v : val,\n  extcall_arg rs m' (parent_sp cs') (S sl pos ty) v /\\\n  Val.inject j (ls (S sl pos ty)) v.","conclusion":"exists v : val,\n  extcall_arg rs m' (parent_sp cs') (S sl pos ty) v /\\\n  Val.inject j (ls (S sl pos ty)) v","hypotheses":"(sl : slot) (pos : Z) (ty : typ) (H : In (S sl pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : match sl with\n| Outgoing => pos >= 0 /\\ (typealign ty | pos)\n| _ => False\nend)","proofString":"destruct sl; try contradiction.\ninv MS.\nelim (H1 _ H).\nsimpl in SEP.\nunfold parent_sp.\nassert (slot_valid f Outgoing pos ty = true).\ndestruct H0.\nunfold slot_valid, proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nreflexivity.\nassert (slot_within_bounds (function_bounds f) Outgoing pos ty) by eauto.\nexploit frame_get_outgoing; eauto.\nintros (v & A & B).\nexists v; split.\nconstructor.\nexact A.\nrewrite AGARGS by auto.\nexact B."},{"statement":"(pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) : exists v : val,\n  extcall_arg rs m' (parent_sp cs') (S Outgoing pos ty) v /\\\n  Val.inject j (ls (S Outgoing pos ty)) v.","conclusion":"exists v : val,\n  extcall_arg rs m' (parent_sp cs') (S Outgoing pos ty) v /\\\n  Val.inject j (ls (S Outgoing pos ty)) v","hypotheses":"(pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos))","proofString":"inv MS.\nelim (H1 _ H).\nsimpl in SEP.\nunfold parent_sp.\nassert (slot_valid f Outgoing pos ty = true).\ndestruct H0.\nunfold slot_valid, proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nreflexivity.\nassert (slot_within_bounds (function_bounds f) Outgoing pos ty) by eauto.\nexploit frame_get_outgoing; eauto.\nintros (v & A & B).\nexists v; split.\nconstructor.\nexact A.\nrewrite AGARGS by auto.\nexact B."},{"statement":"(pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (H1 : tailcall_possible sg) : exists v : val,\n  extcall_arg rs m' (parent_sp nil) (S Outgoing pos ty) v /\\\n  Val.inject j (ls (S Outgoing pos ty)) v.","conclusion":"exists v : val,\n  extcall_arg rs m' (parent_sp nil) (S Outgoing pos ty) v /\\\n  Val.inject j (ls (S Outgoing pos ty)) v","hypotheses":"(pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (H1 : tailcall_possible sg)","proofString":"elim (H1 _ H)."},{"statement":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) : slot_valid f Outgoing pos ty = true.","conclusion":"slot_valid f Outgoing pos ty = true","hypotheses":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f))","proofString":"destruct H0.\nunfold slot_valid, proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nreflexivity."},{"statement":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0) (H1 : (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) : slot_valid f Outgoing pos ty = true.","conclusion":"slot_valid f Outgoing pos ty = true","hypotheses":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0) (H1 : (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f))","proofString":"unfold slot_valid, proj_sumbool.\nrewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nreflexivity."},{"statement":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0) (H1 : (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) : (if zle 0 pos then true else false) &&\n(if Zdivide_dec (typealign ty) pos then true else false) = true.","conclusion":"(if zle 0 pos then true else false) &&\n(if Zdivide_dec (typealign ty) pos then true else false) = true","hypotheses":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0) (H1 : (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f))","proofString":"rewrite zle_true by lia.\nrewrite pred_dec_true by auto.\nreflexivity."},{"statement":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0) (H1 : (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) : true && (if Zdivide_dec (typealign ty) pos then true else false) = true.","conclusion":"true && (if Zdivide_dec (typealign ty) pos then true else false) = true","hypotheses":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0) (H1 : (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f))","proofString":"rewrite pred_dec_true by auto.\nreflexivity."},{"statement":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0) (H1 : (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) : true && true = true.","conclusion":"true && true = true","hypotheses":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0) (H1 : (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f))","proofString":"reflexivity."},{"statement":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) (H1 : slot_valid f Outgoing pos ty = true) (H2 : slot_within_bounds (function_bounds f) Outgoing pos ty) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg pos)) =\nSome v) (B : Val.inject j (ls0 (S Outgoing pos ty)) v) : extcall_arg rs m' (Vptr sp' Ptrofs.zero) (S Outgoing pos ty) v.","conclusion":"extcall_arg rs m' (Vptr sp' Ptrofs.zero) (S Outgoing pos ty) v","hypotheses":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) (H1 : slot_valid f Outgoing pos ty = true) (H2 : slot_within_bounds (function_bounds f) Outgoing pos ty) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg pos)) =\nSome v) (B : Val.inject j (ls0 (S Outgoing pos ty)) v)","proofString":"constructor.\nexact A."},{"statement":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) (H1 : slot_valid f Outgoing pos ty = true) (H2 : slot_within_bounds (function_bounds f) Outgoing pos ty) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg pos)) =\nSome v) (B : Val.inject j (ls0 (S Outgoing pos ty)) v) : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * pos)) =\nSome v.","conclusion":"load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (fe_ofs_arg + 4 * pos)) =\nSome v","hypotheses":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) (H1 : slot_valid f Outgoing pos ty = true) (H2 : slot_within_bounds (function_bounds f) Outgoing pos ty) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg pos)) =\nSome v) (B : Val.inject j (ls0 (S Outgoing pos ty)) v)","proofString":"exact A."},{"statement":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) (H1 : slot_valid f Outgoing pos ty = true) (H2 : slot_within_bounds (function_bounds f) Outgoing pos ty) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg pos)) =\nSome v) (B : Val.inject j (ls0 (S Outgoing pos ty)) v) : Val.inject j\n  (parent_locset (Linear.Stackframe f (Vptr sp Ptrofs.zero) ls0 c :: cs0)\n     (S Outgoing pos ty)) v.","conclusion":"Val.inject j\n  (parent_locset (Linear.Stackframe f (Vptr sp Ptrofs.zero) ls0 c :: cs0)\n     (S Outgoing pos ty)) v","hypotheses":"(f : Linear.function) (sp : block) (ls0 : locset) (c : list Linear.instruction) (cs0 : list Linear.stackframe) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (pos : Z) (ty : typ) (H : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty | pos)) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f ls0 (parent_locset cs0)) (ARGS : forall (ofs : Z) (ty0 : typ),\nIn (S Outgoing ofs ty0) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty0) (STK : match_stacks j cs0 cs'0 (Linear.fn_sig f)) (H1 : slot_valid f Outgoing pos ty = true) (H2 : slot_within_bounds (function_bounds f) Outgoing pos ty) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg pos)) =\nSome v) (B : Val.inject j (ls0 (S Outgoing pos ty)) v)","proofString":"exact B."},{"statement":"(p : rpair loc) (H : In p (loc_arguments sg)) : exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') p v /\\\n  Val.inject j (Locmap.getpair p ls) v.","conclusion":"exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') p v /\\\n  Val.inject j (Locmap.getpair p ls) v","hypotheses":"(p : rpair loc) (H : In p (loc_arguments sg))","proofString":"destruct p as [l | l1 l2].\ndestruct (transl_external_argument l) as (v & A & B).\neapply in_regs_of_rpairs; eauto; simpl; auto.\nexists v; split; auto.\nconstructor; auto.\ndestruct (transl_external_argument l1) as (v1 & A1 & B1).\neapply in_regs_of_rpairs; eauto; simpl; auto.\ndestruct (transl_external_argument l2) as (v2 & A2 & B2).\neapply in_regs_of_rpairs; eauto; simpl; auto.\nexists (Val.longofwords v1 v2); split.\nconstructor; auto.\napply Val.longofwords_inject; auto."},{"statement":"(l : loc) (H : In (One l) (loc_arguments sg)) : exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') (One l) v /\\\n  Val.inject j (Locmap.getpair (One l) ls) v.","conclusion":"exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') (One l) v /\\\n  Val.inject j (Locmap.getpair (One l) ls) v","hypotheses":"(l : loc) (H : In (One l) (loc_arguments sg))","proofString":"destruct (transl_external_argument l) as (v & A & B).\neapply in_regs_of_rpairs; eauto; simpl; auto.\nexists v; split; auto.\nconstructor; auto."},{"statement":"(l : loc) (H : In (One l) (loc_arguments sg)) : In l (regs_of_rpairs (loc_arguments sg)).","conclusion":"In l (regs_of_rpairs (loc_arguments sg))","hypotheses":"(l : loc) (H : In (One l) (loc_arguments sg))","proofString":"eapply in_regs_of_rpairs; eauto; simpl; auto."},{"statement":"(l : loc) (H : In (One l) (loc_arguments sg)) (v : val) (A : extcall_arg rs m' (parent_sp cs') l v) (B : Val.inject j (ls l) v) : exists v0 : val,\n  extcall_arg_pair rs m' (parent_sp cs') (One l) v0 /\\\n  Val.inject j (Locmap.getpair (One l) ls) v0.","conclusion":"exists v0 : val,\n  extcall_arg_pair rs m' (parent_sp cs') (One l) v0 /\\\n  Val.inject j (Locmap.getpair (One l) ls) v0","hypotheses":"(l : loc) (H : In (One l) (loc_arguments sg)) (v : val) (A : extcall_arg rs m' (parent_sp cs') l v) (B : Val.inject j (ls l) v)","proofString":"exists v; split; auto.\nconstructor; auto."},{"statement":"(l : loc) (H : In (One l) (loc_arguments sg)) (v : val) (A : extcall_arg rs m' (parent_sp cs') l v) (B : Val.inject j (ls l) v) : extcall_arg_pair rs m' (parent_sp cs') (One l) v.","conclusion":"extcall_arg_pair rs m' (parent_sp cs') (One l) v","hypotheses":"(l : loc) (H : In (One l) (loc_arguments sg)) (v : val) (A : extcall_arg rs m' (parent_sp cs') l v) (B : Val.inject j (ls l) v)","proofString":"constructor; auto."},{"statement":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) : exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') (Twolong l1 l2) v /\\\n  Val.inject j (Locmap.getpair (Twolong l1 l2) ls) v.","conclusion":"exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') (Twolong l1 l2) v /\\\n  Val.inject j (Locmap.getpair (Twolong l1 l2) ls) v","hypotheses":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg))","proofString":"destruct (transl_external_argument l1) as (v1 & A1 & B1).\neapply in_regs_of_rpairs; eauto; simpl; auto.\ndestruct (transl_external_argument l2) as (v2 & A2 & B2).\neapply in_regs_of_rpairs; eauto; simpl; auto.\nexists (Val.longofwords v1 v2); split.\nconstructor; auto.\napply Val.longofwords_inject; auto."},{"statement":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) : In l1 (regs_of_rpairs (loc_arguments sg)).","conclusion":"In l1 (regs_of_rpairs (loc_arguments sg))","hypotheses":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg))","proofString":"eapply in_regs_of_rpairs; eauto; simpl; auto."},{"statement":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1) : exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') (Twolong l1 l2) v /\\\n  Val.inject j (Locmap.getpair (Twolong l1 l2) ls) v.","conclusion":"exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') (Twolong l1 l2) v /\\\n  Val.inject j (Locmap.getpair (Twolong l1 l2) ls) v","hypotheses":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1)","proofString":"destruct (transl_external_argument l2) as (v2 & A2 & B2).\neapply in_regs_of_rpairs; eauto; simpl; auto.\nexists (Val.longofwords v1 v2); split.\nconstructor; auto.\napply Val.longofwords_inject; auto."},{"statement":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1) : In l2 (regs_of_rpairs (loc_arguments sg)).","conclusion":"In l2 (regs_of_rpairs (loc_arguments sg))","hypotheses":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1)","proofString":"eapply in_regs_of_rpairs; eauto; simpl; auto."},{"statement":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1) (v2 : val) (A2 : extcall_arg rs m' (parent_sp cs') l2 v2) (B2 : Val.inject j (ls l2) v2) : exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') (Twolong l1 l2) v /\\\n  Val.inject j (Locmap.getpair (Twolong l1 l2) ls) v.","conclusion":"exists v : val,\n  extcall_arg_pair rs m' (parent_sp cs') (Twolong l1 l2) v /\\\n  Val.inject j (Locmap.getpair (Twolong l1 l2) ls) v","hypotheses":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1) (v2 : val) (A2 : extcall_arg rs m' (parent_sp cs') l2 v2) (B2 : Val.inject j (ls l2) v2)","proofString":"exists (Val.longofwords v1 v2); split.\nconstructor; auto.\napply Val.longofwords_inject; auto."},{"statement":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1) (v2 : val) (A2 : extcall_arg rs m' (parent_sp cs') l2 v2) (B2 : Val.inject j (ls l2) v2) : extcall_arg_pair rs m' (parent_sp cs') (Twolong l1 l2)\n  (Val.longofwords v1 v2).","conclusion":"extcall_arg_pair rs m' (parent_sp cs') (Twolong l1 l2)\n  (Val.longofwords v1 v2)","hypotheses":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1) (v2 : val) (A2 : extcall_arg rs m' (parent_sp cs') l2 v2) (B2 : Val.inject j (ls l2) v2)","proofString":"constructor; auto."},{"statement":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1) (v2 : val) (A2 : extcall_arg rs m' (parent_sp cs') l2 v2) (B2 : Val.inject j (ls l2) v2) : Val.inject j (Locmap.getpair (Twolong l1 l2) ls) (Val.longofwords v1 v2).","conclusion":"Val.inject j (Locmap.getpair (Twolong l1 l2) ls) (Val.longofwords v1 v2)","hypotheses":"(l1 l2 : loc) (H : In (Twolong l1 l2) (loc_arguments sg)) (v1 : val) (A1 : extcall_arg rs m' (parent_sp cs') l1 v1) (B1 : Val.inject j (ls l1) v1) (v2 : val) (A2 : extcall_arg rs m' (parent_sp cs') l2 v2) (B2 : Val.inject j (ls l2) v2)","proofString":"apply Val.longofwords_inject; auto."},{"statement":"(H : incl nil (loc_arguments sg)) : exists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) nil vl /\\\n  Val.inject_list j nil vl.","conclusion":"exists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) nil vl /\\\n  Val.inject_list j nil vl","hypotheses":"(H : incl nil (loc_arguments sg))","proofString":"exists (@nil val); split.\nconstructor.\nconstructor."},{"statement":"(H : incl nil (loc_arguments sg)) : list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) nil nil.","conclusion":"list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) nil nil","hypotheses":"(H : incl nil (loc_arguments sg))","proofString":"constructor."},{"statement":"(H : incl nil (loc_arguments sg)) : Val.inject_list j nil nil.","conclusion":"Val.inject_list j nil nil","hypotheses":"(H : incl nil (loc_arguments sg))","proofString":"constructor."},{"statement":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) (H : incl (a :: locs) (loc_arguments sg)) : exists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl.","conclusion":"exists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl","hypotheses":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) (H : incl (a :: locs) (loc_arguments sg))","proofString":"exploit transl_external_argument_2; eauto with coqlib.\nintros [v [A B]].\nexploit IHlocs; eauto with coqlib.\nintros [vl [C D]].\nexists (v :: vl); split; constructor; auto."},{"statement":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) (H : incl (a :: locs) (loc_arguments sg)) : (exists v : val,\n   extcall_arg_pair rs m' (parent_sp cs') a v /\\\n   Val.inject j (Locmap.getpair a ls) v) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl.","conclusion":"(exists v : val,\n   extcall_arg_pair rs m' (parent_sp cs') a v /\\\n   Val.inject j (Locmap.getpair a ls) v) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl","hypotheses":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) (H : incl (a :: locs) (loc_arguments sg))","proofString":"intros [v [A B]].\nexploit IHlocs; eauto with coqlib.\nintros [vl [C D]].\nexists (v :: vl); split; constructor; auto."},{"statement":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) (H : incl (a :: locs) (loc_arguments sg)) (v : val) (A : extcall_arg_pair rs m' (parent_sp cs') a v) (B : Val.inject j (Locmap.getpair a ls) v) : exists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl.","conclusion":"exists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl","hypotheses":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) (H : incl (a :: locs) (loc_arguments sg)) (v : val) (A : extcall_arg_pair rs m' (parent_sp cs') a v) (B : Val.inject j (Locmap.getpair a ls) v)","proofString":"exploit IHlocs; eauto with coqlib.\nintros [vl [C D]].\nexists (v :: vl); split; constructor; auto."},{"statement":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) (H : incl (a :: locs) (loc_arguments sg)) (v : val) (A : extcall_arg_pair rs m' (parent_sp cs') a v) (B : Val.inject j (Locmap.getpair a ls) v) : (exists vl : list val,\n   list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n   Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl.","conclusion":"(exists vl : list val,\n   list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n   Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl","hypotheses":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) (H : incl (a :: locs) (loc_arguments sg)) (v : val) (A : extcall_arg_pair rs m' (parent_sp cs') a v) (B : Val.inject j (Locmap.getpair a ls) v)","proofString":"intros [vl [C D]].\nexists (v :: vl); split; constructor; auto."},{"statement":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl0 : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl0 /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl0) (H : incl (a :: locs) (loc_arguments sg)) (v : val) (A : extcall_arg_pair rs m' (parent_sp cs') a v) (B : Val.inject j (Locmap.getpair a ls) v) (vl : list val) (C : list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl) (D : Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl) : exists vl0 : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl0 /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl0.","conclusion":"exists vl0 : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (a :: locs) vl0 /\\\n  Val.inject_list j\n    (Locmap.getpair a ls\n     :: (fun p : rpair loc => Locmap.getpair p ls) ## locs) vl0","hypotheses":"(a : rpair loc) (locs : list (rpair loc)) (IHlocs : incl locs (loc_arguments sg) ->\nexists vl0 : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl0 /\\\n  Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl0) (H : incl (a :: locs) (loc_arguments sg)) (v : val) (A : extcall_arg_pair rs m' (parent_sp cs') a v) (B : Val.inject j (Locmap.getpair a ls) v) (vl : list val) (C : list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl) (D : Val.inject_list j (fun p : rpair loc => Locmap.getpair p ls) ## locs vl)","proofString":"exists (v :: vl); split; constructor; auto."},{"statement":"exists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (loc_arguments sg) vl /\\\n  Val.inject_list j\n    (fun p : rpair loc => Locmap.getpair p ls) ## (loc_arguments sg) vl.","conclusion":"exists vl : list val,\n  list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) (loc_arguments sg) vl /\\\n  Val.inject_list j\n    (fun p : rpair loc => Locmap.getpair p ls) ## (loc_arguments sg) vl","hypotheses":"","proofString":"apply transl_external_arguments_rec.\nauto with coqlib."},{"statement":"incl (loc_arguments sg) (loc_arguments sg).","conclusion":"incl (loc_arguments sg) (loc_arguments sg)","hypotheses":"","proofString":"auto with coqlib."},{"statement":"(VALID : forall l : loc, False -> loc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nFalse -> slot_within_bounds b sl ofs ty) : exists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m' nil vl' /\\\n  Val.inject_list j nil vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m' nil vl' /\\\n  Val.inject_list j nil vl'","hypotheses":"(VALID : forall l : loc, False -> loc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nFalse -> slot_within_bounds b sl ofs ty)","proofString":"exists (@nil val); split; constructor."},{"statement":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty) : exists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'","hypotheses":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty)","proofString":"exploit transl_builtin_arg_correct; eauto using in_or_app.\nintros (v1' & A & B).\nexploit IHlist_forall2; eauto using in_or_app.\nintros (vl' & C & D).\nexists (v1'::vl'); split; constructor; auto."},{"statement":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty) : (exists v' : val,\n   eval_builtin_arg ge rs (Vptr sp' Ptrofs.zero) m'\n     (transl_builtin_arg fe a1) v' /\\ Val.inject j b1 v') ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'.","conclusion":"(exists v' : val,\n   eval_builtin_arg ge rs (Vptr sp' Ptrofs.zero) m'\n     (transl_builtin_arg fe a1) v' /\\ Val.inject j b1 v') ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'","hypotheses":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty)","proofString":"intros (v1' & A & B).\nexploit IHlist_forall2; eauto using in_or_app.\nintros (vl' & C & D).\nexists (v1'::vl'); split; constructor; auto."},{"statement":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty) (v1' : val) (A : eval_builtin_arg ge rs (Vptr sp' Ptrofs.zero) m' (transl_builtin_arg fe a1)\n  v1') (B : Val.inject j b1 v1') : exists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'","hypotheses":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty) (v1' : val) (A : eval_builtin_arg ge rs (Vptr sp' Ptrofs.zero) m' (transl_builtin_arg fe a1)\n  v1') (B : Val.inject j b1 v1')","proofString":"exploit IHlist_forall2; eauto using in_or_app.\nintros (vl' & C & D).\nexists (v1'::vl'); split; constructor; auto."},{"statement":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty) (v1' : val) (A : eval_builtin_arg ge rs (Vptr sp' Ptrofs.zero) m' (transl_builtin_arg fe a1)\n  v1') (B : Val.inject j b1 v1') : (exists vl' : list val,\n   eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n     (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'.","conclusion":"(exists vl' : list val,\n   eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n     (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'","hypotheses":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl' : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl' /\\ Val.inject_list j bl vl') (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty) (v1' : val) (A : eval_builtin_arg ge rs (Vptr sp' Ptrofs.zero) m' (transl_builtin_arg fe a1)\n  v1') (B : Val.inject j b1 v1')","proofString":"intros (vl' & C & D).\nexists (v1'::vl'); split; constructor; auto."},{"statement":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl'0 : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl'0 /\\ Val.inject_list j bl vl'0) (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty) (v1' : val) (A : eval_builtin_arg ge rs (Vptr sp' Ptrofs.zero) m' (transl_builtin_arg fe a1)\n  v1') (B : Val.inject j b1 v1') (vl' : list val) (C : eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n  (transl_builtin_arg fe) ## al vl') (D : Val.inject_list j bl vl') : exists vl'0 : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl'0 /\\\n  Val.inject_list j (b1 :: bl) vl'0.","conclusion":"exists vl'0 : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe a1 :: (transl_builtin_arg fe) ## al) vl'0 /\\\n  Val.inject_list j (b1 :: bl) vl'0","hypotheses":"(a1 : builtin_arg loc) (al : list (builtin_arg loc)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge ls (Vptr sp Ptrofs.zero) m) al bl) (IHlist_forall2 : (forall l : loc, In l (params_of_builtin_args al) -> loc_valid f l = true) ->\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args al) ->\n slot_within_bounds b sl ofs ty) ->\nexists vl'0 : list val,\n  eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n    (transl_builtin_arg fe) ## al vl'0 /\\ Val.inject_list j bl vl'0) (VALID : forall l : loc,\nIn l (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nloc_valid f l = true) (BOUNDS : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_arg a1 ++ params_of_builtin_args al) ->\nslot_within_bounds b sl ofs ty) (v1' : val) (A : eval_builtin_arg ge rs (Vptr sp' Ptrofs.zero) m' (transl_builtin_arg fe a1)\n  v1') (B : Val.inject j b1 v1') (vl' : list val) (C : eval_builtin_args ge rs (Vptr sp' Ptrofs.zero) m'\n  (transl_builtin_arg fe) ## al vl') (D : Val.inject_list j bl vl')","proofString":"exists (v1'::vl'); split; constructor; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack sl ofs ty dst :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack sl ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty /\\\nmreg_within_bounds (function_bounds f) dst) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Mgetstack\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty dst :: transl_code (make_env (function_bounds f)) b\n       | Incoming =>\n           Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (destroyed_by_getstack sl) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Mgetstack\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty dst :: transl_code (make_env (function_bounds f)) b\n       | Incoming =>\n           Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (destroyed_by_getstack sl) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack sl ofs ty dst :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack sl ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty /\\\nmreg_within_bounds (function_bounds f) dst)","proofString":"destruct BOUND as [BOUND1 BOUND2].\nexploit wt_state_getstack; eauto.\nintros SV.\nunfold destroyed_by_getstack; destruct sl.\nexploit frame_get_local; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto.\nunfold slot_valid in SV.\nInvBooleans.\nexploit incoming_slot_in_parameters; eauto.\nintros IN_ARGS.\ninversion STACKS; clear STACKS.\nelim (H1 _ IN_ARGS).\nsubst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto.\nexploit frame_get_outgoing; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack sl ofs ty dst :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack sl ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) sl ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Mgetstack\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty dst :: transl_code (make_env (function_bounds f)) b\n       | Incoming =>\n           Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (destroyed_by_getstack sl) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Mgetstack\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty dst :: transl_code (make_env (function_bounds f)) b\n       | Incoming =>\n           Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (destroyed_by_getstack sl) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack sl ofs ty dst :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack sl ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) sl ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst)","proofString":"exploit wt_state_getstack; eauto.\nintros SV.\nunfold destroyed_by_getstack; destruct sl.\nexploit frame_get_local; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto.\nunfold slot_valid in SV.\nInvBooleans.\nexploit incoming_slot_in_parameters; eauto.\nintros IN_ARGS.\ninversion STACKS; clear STACKS.\nelim (H1 _ IN_ARGS).\nsubst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto.\nexploit frame_get_outgoing; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack sl ofs ty dst :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack sl ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) sl ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) : slot_valid f sl ofs ty = true ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Mgetstack\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty dst :: transl_code (make_env (function_bounds f)) b\n       | Incoming =>\n           Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (destroyed_by_getstack sl) rs)) m) s2'.","conclusion":"slot_valid f sl ofs ty = true ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Mgetstack\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty dst :: transl_code (make_env (function_bounds f)) b\n       | Incoming =>\n           Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (destroyed_by_getstack sl) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack sl ofs ty dst :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack sl ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) sl ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst)","proofString":"intros SV.\nunfold destroyed_by_getstack; destruct sl.\nexploit frame_get_local; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto.\nunfold slot_valid in SV.\nInvBooleans.\nexploit incoming_slot_in_parameters; eauto.\nintros IN_ARGS.\ninversion STACKS; clear STACKS.\nelim (H1 _ IN_ARGS).\nsubst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto.\nexploit frame_get_outgoing; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack sl ofs ty dst :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack sl ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) sl ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f sl ofs ty = true) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Mgetstack\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty dst :: transl_code (make_env (function_bounds f)) b\n       | Incoming =>\n           Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (destroyed_by_getstack sl) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Mgetstack\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty dst :: transl_code (make_env (function_bounds f)) b\n       | Incoming =>\n           Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S sl ofs ty))\n          (LTL.undef_regs (destroyed_by_getstack sl) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack sl ofs ty dst :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack sl ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) sl ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f sl ofs ty = true)","proofString":"unfold destroyed_by_getstack; destruct sl.\nexploit frame_get_local; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto.\nunfold slot_valid in SV.\nInvBooleans.\nexploit incoming_slot_in_parameters; eauto.\nintros IN_ARGS.\ninversion STACKS; clear STACKS.\nelim (H1 _ IN_ARGS).\nsubst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto.\nexploit frame_get_outgoing; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack\n          (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) ty\n          dst :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs)) m)\n    s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack\n          (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) ty\n          dst :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs)) m)\n    s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true)","proofString":"exploit frame_get_local; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true) : (exists v : val,\n   load_stack m' (Vptr sp' Ptrofs.zero) ty\n     (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) = \n   Some v /\\ Val.inject j (rs (S Local ofs ty)) v) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack\n          (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) ty\n          dst :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs)) m)\n    s2'.","conclusion":"(exists v : val,\n   load_stack m' (Vptr sp' Ptrofs.zero) ty\n     (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) = \n   Some v /\\ Val.inject j (rs (S Local ofs ty)) v) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack\n          (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) ty\n          dst :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs)) m)\n    s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true)","proofString":"intros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty\n  (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) = \nSome v) (B : Val.inject j (rs (S Local ofs ty)) v) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack\n          (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) ty\n          dst :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs)) m)\n    s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack\n          (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) ty\n          dst :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs)) m)\n    s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty\n  (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) = \nSome v) (B : Val.inject j (rs (S Local ofs ty)) v)","proofString":"econstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty\n  (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) = \nSome v) (B : Val.inject j (rs (S Local ofs ty)) v) : agree_regs j\n  (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs))\n  rs0 # dst <- v.","conclusion":"agree_regs j\n  (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs))\n  rs0 # dst <- v","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty\n  (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) = \nSome v) (B : Val.inject j (rs (S Local ofs ty)) v)","proofString":"apply agree_regs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty\n  (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) = \nSome v) (B : Val.inject j (rs (S Local ofs ty)) v) : agree_locs f\n  (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs))\n  (parent_locset s).","conclusion":"agree_locs f\n  (Locmap.set (R dst) (rs (S Local ofs ty)) (LTL.undef_regs nil rs))\n  (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgetstack Local ofs ty dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Local ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Local ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Local ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty\n  (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) = \nSome v) (B : Val.inject j (rs (S Local ofs ty)) v)","proofString":"apply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Incoming ofs ty = true) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Incoming ofs ty = true)","proofString":"unfold slot_valid in SV.\nInvBooleans.\nexploit incoming_slot_in_parameters; eauto.\nintros IN_ARGS.\ninversion STACKS; clear STACKS.\nelim (H1 _ IN_ARGS).\nsubst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : in_dec Loc.eq (S Incoming ofs ty)\n  (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) &&\nZdivide_dec (typealign ty) ofs = true) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : in_dec Loc.eq (S Incoming ofs ty)\n  (regs_of_rpairs (loc_parameters (Linear.fn_sig f))) &&\nZdivide_dec (typealign ty) ofs = true)","proofString":"InvBooleans.\nexploit incoming_slot_in_parameters; eauto.\nintros IN_ARGS.\ninversion STACKS; clear STACKS.\nelim (H1 _ IN_ARGS).\nsubst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))))","proofString":"exploit incoming_slot_in_parameters; eauto.\nintros IN_ARGS.\ninversion STACKS; clear STACKS.\nelim (H1 _ IN_ARGS).\nsubst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'.","conclusion":"In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f))))","proofString":"intros IN_ARGS.\ninversion STACKS; clear STACKS.\nelim (H1 _ IN_ARGS).\nsubst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))))","proofString":"inversion STACKS; clear STACKS.\nelim (H1 _ IN_ARGS).\nsubst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (H1 : tailcall_possible (Linear.fn_sig f)) (H2 : nil = s) (H3 : nil = cs') (H4 : sg = Linear.fn_sig f) : exists s2' : state,\n  plus step tge\n    (State nil fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State nil f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State nil fb (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State nil f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (H1 : tailcall_possible (Linear.fn_sig f)) (H2 : nil = s) (H3 : nil = cs') (H4 : sg = Linear.fn_sig f)","proofString":"elim (H1 _ IN_ARGS)."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H1 : Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs = s) (H2 : Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0 = cs') (H3 : sg = Linear.fn_sig f) : exists s2' : state,\n  plus step tge\n    (State (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) fb\n       (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n       (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) fb\n       (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n       (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Incoming ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H1 : Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs = s) (H2 : Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0 = cs') (H3 : sg = Linear.fn_sig f)","proofString":"subst s cs'.\nexploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) : exists s2' : state,\n  plus step tge\n    (State (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) fb\n       (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n       (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) fb\n       (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n       (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f)","proofString":"exploit frame_get_outgoing.\napply sep_proj2 in SEP.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neexact SEP.\neapply ARGS; eauto.\neapply slot_outgoing_argument_valid; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : exists s2' : state,\n  plus step tge\n    (State (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) fb\n       (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n       (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) fb\n       (Vptr sp' Ptrofs.zero)\n       (Mgetparam (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n       (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Incoming ofs ty))\n          (LTL.undef_regs (temp_for_parent_frame :: nil) rs)) m) s2'","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"econstructor; split.\napply plus_one.\neapply exec_Mgetparam; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP.\neconstructor; eauto with coqlib.\neconstructor; eauto.\napply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)).","conclusion":"load_stack m' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"rewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : load_stack m' (Vptr sp' Ptrofs.zero) Tptr\n  (fn_link_ofs\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) =\nSome (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)).","conclusion":"load_stack m' (Vptr sp' Ptrofs.zero) Tptr\n  (fn_link_ofs\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) =\nSome (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"unfold fn_link_ofs.\neapply frame_get_parent.\neexact SEP."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : load_stack m' (Vptr sp' Ptrofs.zero) Tptr\n  (Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)))) =\nSome (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)).","conclusion":"load_stack m' (Vptr sp' Ptrofs.zero) Tptr\n  (Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)))) =\nSome (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"eapply frame_get_parent.\neexact SEP."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : match_stacks j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n  (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) \n  (Linear.fn_sig f).","conclusion":"match_stacks j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n  (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) \n  (Linear.fn_sig f)","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"econstructor; eauto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : agree_regs j\n  (Locmap.set (R dst) (rs (S Incoming ofs ty))\n     (LTL.undef_regs (temp_for_parent_frame :: nil) rs))\n  (rs0 # temp_for_parent_frame <- Vundef) # dst <- v.","conclusion":"agree_regs j\n  (Locmap.set (R dst) (rs (S Incoming ofs ty))\n     (LTL.undef_regs (temp_for_parent_frame :: nil) rs))\n  (rs0 # temp_for_parent_frame <- Vundef) # dst <- v","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"apply agree_regs_set_reg.\napply agree_regs_set_reg.\nauto.\nauto.\nerewrite agree_incoming by eauto.\nexact B."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : agree_regs j (LTL.undef_regs (temp_for_parent_frame :: nil) rs)\n  rs0 # temp_for_parent_frame <- Vundef.","conclusion":"agree_regs j (LTL.undef_regs (temp_for_parent_frame :: nil) rs)\n  rs0 # temp_for_parent_frame <- Vundef","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"apply agree_regs_set_reg.\nauto.\nauto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : agree_regs j rs rs0.","conclusion":"agree_regs j rs rs0","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"auto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : Val.inject j Vundef Vundef.","conclusion":"Val.inject j Vundef Vundef","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"auto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : Val.inject j (rs (S Incoming ofs ty)) v.","conclusion":"Val.inject j (rs (S Incoming ofs ty)) v","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"erewrite agree_incoming by eauto.\nexact B."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : Val.inject j\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (S Outgoing ofs ty)) v.","conclusion":"Val.inject j\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (S Outgoing ofs ty)) v","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"exact B."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : agree_locs f\n  (Locmap.set (R dst) (rs (S Incoming ofs ty))\n     (LTL.undef_regs (temp_for_parent_frame :: nil) rs))\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)).","conclusion":"agree_locs f\n  (Locmap.set (R dst) (rs (S Incoming ofs ty))\n     (LTL.undef_regs (temp_for_parent_frame :: nil) rs))\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"apply agree_locs_set_reg; auto.\napply agree_locs_undef_locs; auto."},{"statement":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v) : agree_locs f (LTL.undef_regs (temp_for_parent_frame :: nil) rs)\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)).","conclusion":"agree_locs f (LTL.undef_regs (temp_for_parent_frame :: nil) rs)\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))","hypotheses":"(f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (f0 : Linear.function) (sp : block) (ls : locset) (c : list Linear.instruction) (cs : list Linear.stackframe) (WTS : wt_state\n  (Linear.State (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs) f\n     (Vptr sp0 Ptrofs.zero) (Lgetstack Incoming ofs ty dst :: b) rs m)) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs\n  (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Incoming ofs ty dst :: b) (Linear.fn_code f)) (fb0 sp'0 : block) (ra : val) (c' : code) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs\n     (parent_locset (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs))\n     (parent_sp (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0))\n     (parent_ra (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0)) **\n   stack_contents j (Linear.Stackframe f0 (Vptr sp Ptrofs.zero) ls c :: cs)\n     (Stackframe fb0 (Vptr sp'0 Ptrofs.zero) ra c' :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Incoming ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (H0 : (typealign ty | ofs)) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters (Linear.fn_sig f)))) (IN_ARGS : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.fn_sig f)))) (sg : signature) (trf : function) (TAIL0 : is_tail c (Linear.fn_code f0)) (FINDF : Genv.find_funct_ptr tge fb0 = Some (Internal trf)) (TRF : transf_function f0 = OK trf) (TRC : transl_code (make_env (function_bounds f0)) c = c') (INJ : j sp = Some (sp'0, fe_stack_data (make_env (function_bounds f0)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f0 ls (parent_locset cs)) (ARGS : forall (ofs0 : Z) (ty0 : typ),\nIn (S Outgoing ofs0 ty0) (regs_of_rpairs (loc_arguments (Linear.fn_sig f))) ->\nslot_within_bounds (function_bounds f0) Outgoing ofs0 ty0) (STK : match_stacks j cs cs'0 (Linear.fn_sig f0)) (H3 : sg = Linear.fn_sig f) (v : val) (A : load_stack m' (Vptr sp'0 Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (ls (S Outgoing ofs ty)) v)","proofString":"apply agree_locs_undef_locs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n       m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n       m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true)","proofString":"exploit frame_get_outgoing; eauto.\nintros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true) : (exists v : val,\n   load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n   Some v /\\ Val.inject j (rs (S Outgoing ofs ty)) v) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n       m) s2'.","conclusion":"(exists v : val,\n   load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\n   Some v /\\ Val.inject j (rs (S Outgoing ofs ty)) v) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n       m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true)","proofString":"intros (v & A & B).\neconstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (rs (S Outgoing ofs ty)) v) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n       m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgetstack (Ptrofs.repr (offset_arg ofs)) ty dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n       m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (rs (S Outgoing ofs ty)) v)","proofString":"econstructor; split.\napply plus_one.\napply exec_Mgetstack.\nexact A.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\napply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (rs (S Outgoing ofs ty)) v) : agree_regs j\n  (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n  rs0 # dst <- v.","conclusion":"agree_regs j\n  (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n  rs0 # dst <- v","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (rs (S Outgoing ofs ty)) v)","proofString":"apply agree_regs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (rs (S Outgoing ofs ty)) v) : agree_locs f\n  (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n  (parent_locset s).","conclusion":"agree_locs f\n  (Locmap.set (R dst) (rs (S Outgoing ofs ty)) (LTL.undef_regs nil rs))\n  (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ofs : Z) (ty : typ) (dst : mreg) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lgetstack Outgoing ofs ty dst :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgetstack Outgoing ofs ty dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND1 : slot_within_bounds (function_bounds f) Outgoing ofs ty) (BOUND2 : mreg_within_bounds (function_bounds f) dst) (SV : slot_valid f Outgoing ofs ty = true) (v : val) (A : load_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs)) =\nSome v) (B : Val.inject j (rs (S Outgoing ofs ty)) v)","proofString":"apply agree_locs_set_reg; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Msetstack src\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty :: transl_code (make_env (function_bounds f)) b\n       | Incoming => transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Msetstack src (Ptrofs.repr (offset_arg ofs)) ty\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (S sl ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Msetstack src\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty :: transl_code (make_env (function_bounds f)) b\n       | Incoming => transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Msetstack src (Ptrofs.repr (offset_arg ofs)) ty\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (S sl ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty)","proofString":"exploit wt_state_setstack; eauto.\nintros (SV & SW).\nset (ofs' := match sl with               | Local => offset_local (make_env (function_bounds f)) ofs               | Incoming => 0 (* dummy *)               | Outgoing => offset_arg ofs               end).\neapply frame_undef_regs with (rl := destroyed_by_setstack ty) in SEP.\nassert (A: exists m'',              store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) = Some m''           /\\ m'' |= frame_contents f j sp' (Locmap.set (S sl ofs ty) (rs (R src))                                               (LTL.undef_regs (destroyed_by_setstack ty) rs))                                            (parent_locset s) (parent_sp cs') (parent_ra cs')                  ** stack_contents j s cs' ** minjection j m ** globalenv_inject ge j).\nunfold ofs'; destruct sl; try discriminate.\neapply frame_set_local; eauto.\neapply frame_set_outgoing; eauto.\nclear SEP; destruct A as (m'' & STORE & SEP).\neconstructor; split.\napply plus_one.\ndestruct sl; try discriminate.\neconstructor.\neexact STORE.\neauto.\neconstructor.\neexact STORE.\neauto.\neconstructor.\neauto.\neauto.\neauto.\napply agree_regs_set_slot.\napply agree_regs_undef_regs.\nauto.\napply agree_locs_set_slot.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_setstack_caller_save.\nauto.\neauto.\neauto with coqlib.\neauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) : slot_valid f sl ofs ty = true /\\ slot_writable sl = true ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Msetstack src\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty :: transl_code (make_env (function_bounds f)) b\n       | Incoming => transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Msetstack src (Ptrofs.repr (offset_arg ofs)) ty\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (S sl ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) s2'.","conclusion":"slot_valid f sl ofs ty = true /\\ slot_writable sl = true ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Msetstack src\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty :: transl_code (make_env (function_bounds f)) b\n       | Incoming => transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Msetstack src (Ptrofs.repr (offset_arg ofs)) ty\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (S sl ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty)","proofString":"intros (SV & SW).\nset (ofs' := match sl with               | Local => offset_local (make_env (function_bounds f)) ofs               | Incoming => 0 (* dummy *)               | Outgoing => offset_arg ofs               end).\neapply frame_undef_regs with (rl := destroyed_by_setstack ty) in SEP.\nassert (A: exists m'',              store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) = Some m''           /\\ m'' |= frame_contents f j sp' (Locmap.set (S sl ofs ty) (rs (R src))                                               (LTL.undef_regs (destroyed_by_setstack ty) rs))                                            (parent_locset s) (parent_sp cs') (parent_ra cs')                  ** stack_contents j s cs' ** minjection j m ** globalenv_inject ge j).\nunfold ofs'; destruct sl; try discriminate.\neapply frame_set_local; eauto.\neapply frame_set_outgoing; eauto.\nclear SEP; destruct A as (m'' & STORE & SEP).\neconstructor; split.\napply plus_one.\ndestruct sl; try discriminate.\neconstructor.\neexact STORE.\neauto.\neconstructor.\neexact STORE.\neauto.\neconstructor.\neauto.\neauto.\neauto.\napply agree_regs_set_slot.\napply agree_regs_undef_regs.\nauto.\napply agree_locs_set_slot.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_setstack_caller_save.\nauto.\neauto.\neauto with coqlib.\neauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Msetstack src\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty :: transl_code (make_env (function_bounds f)) b\n       | Incoming => transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Msetstack src (Ptrofs.repr (offset_arg ofs)) ty\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (S sl ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       match sl with\n       | Local =>\n           Msetstack src\n             (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs))\n             ty :: transl_code (make_env (function_bounds f)) b\n       | Incoming => transl_code (make_env (function_bounds f)) b\n       | Outgoing =>\n           Msetstack src (Ptrofs.repr (offset_arg ofs)) ty\n           :: transl_code (make_env (function_bounds f)) b\n       end rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (S sl ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true)","proofString":"set (ofs' := match sl with               | Local => offset_local (make_env (function_bounds f)) ofs               | Incoming => 0 (* dummy *)               | Outgoing => offset_arg ofs               end).\neapply frame_undef_regs with (rl := destroyed_by_setstack ty) in SEP.\nassert (A: exists m'',              store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) = Some m''           /\\ m'' |= frame_contents f j sp' (Locmap.set (S sl ofs ty) (rs (R src))                                               (LTL.undef_regs (destroyed_by_setstack ty) rs))                                            (parent_locset s) (parent_sp cs') (parent_ra cs')                  ** stack_contents j s cs' ** minjection j m ** globalenv_inject ge j).\nunfold ofs'; destruct sl; try discriminate.\neapply frame_set_local; eauto.\neapply frame_set_outgoing; eauto.\nclear SEP; destruct A as (m'' & STORE & SEP).\neconstructor; split.\napply plus_one.\ndestruct sl; try discriminate.\neconstructor.\neexact STORE.\neauto.\neconstructor.\neexact STORE.\neauto.\neconstructor.\neauto.\neauto.\neauto.\napply agree_regs_set_slot.\napply agree_regs_undef_regs.\nauto.\napply agree_locs_set_slot.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_setstack_caller_save.\nauto.\neauto.\neauto with coqlib.\neauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src Local ofs ty :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src Local ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' (LTL.undef_regs (destroyed_by_setstack ty) rs)\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) Local ofs ty) (SV : slot_valid f Local ofs ty = true) (SW : slot_writable Local = true) (ofs' : Z) : exists m'' : mem,\n  store_stack m' (Vptr sp' Ptrofs.zero) ty\n    (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) \n    (rs0 src) = Some m'' /\\\n  m''\n  |= frame_contents f j sp'\n       (Locmap.set (S Local ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n       (parent_locset s) (parent_sp cs') (parent_ra cs') **\n     stack_contents j s cs' ** minjection j m ** globalenv_inject ge j.","conclusion":"exists m'' : mem,\n  store_stack m' (Vptr sp' Ptrofs.zero) ty\n    (Ptrofs.repr (offset_local (make_env (function_bounds f)) ofs)) \n    (rs0 src) = Some m'' /\\\n  m''\n  |= frame_contents f j sp'\n       (Locmap.set (S Local ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n       (parent_locset s) (parent_sp cs') (parent_ra cs') **\n     stack_contents j s cs' ** minjection j m ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src Local ofs ty :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src Local ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' (LTL.undef_regs (destroyed_by_setstack ty) rs)\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) Local ofs ty) (SV : slot_valid f Local ofs ty = true) (SW : slot_writable Local = true) (ofs' : Z)","proofString":"eapply frame_set_local; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lsetstack src Outgoing ofs ty :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src Outgoing ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' (LTL.undef_regs (destroyed_by_setstack ty) rs)\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) Outgoing ofs ty) (SV : slot_valid f Outgoing ofs ty = true) (SW : slot_writable Outgoing = true) (ofs' : Z) : exists m'' : mem,\n  store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs))\n    (rs0 src) = Some m'' /\\\n  m''\n  |= frame_contents f j sp'\n       (Locmap.set (S Outgoing ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n       (parent_locset s) (parent_sp cs') (parent_ra cs') **\n     stack_contents j s cs' ** minjection j m ** globalenv_inject ge j.","conclusion":"exists m'' : mem,\n  store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr (offset_arg ofs))\n    (rs0 src) = Some m'' /\\\n  m''\n  |= frame_contents f j sp'\n       (Locmap.set (S Outgoing ofs ty) (rs (R src))\n          (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n       (parent_locset s) (parent_sp cs') (parent_ra cs') **\n     stack_contents j s cs' ** minjection j m ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lsetstack src Outgoing ofs ty :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src Outgoing ofs ty :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' (LTL.undef_regs (destroyed_by_setstack ty) rs)\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : slot_within_bounds (function_bounds f) Outgoing ofs ty) (SV : slot_valid f Outgoing ofs ty = true) (SW : slot_writable Outgoing = true) (ofs' : Z)","proofString":"eapply frame_set_outgoing; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lsetstack src Outgoing ofs ty :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src Outgoing ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) Outgoing ofs ty) (SV : slot_valid f Outgoing ofs ty = true) (SW : slot_writable Outgoing = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S Outgoing ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : undef_regs (destroyed_by_setstack ty) rs0 =\nundef_regs (destroyed_by_setstack ty) rs0.","conclusion":"undef_regs (destroyed_by_setstack ty) rs0 =\nundef_regs (destroyed_by_setstack ty) rs0","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lsetstack src Outgoing ofs ty :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src Outgoing ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) Outgoing ofs ty) (SV : slot_valid f Outgoing ofs ty = true) (SW : slot_writable Outgoing = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S Outgoing ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : agree_regs j (LTL.undef_regs (destroyed_by_setstack ty) rs)\n  (undef_regs (destroyed_by_setstack ty) rs0).","conclusion":"agree_regs j (LTL.undef_regs (destroyed_by_setstack ty) rs)\n  (undef_regs (destroyed_by_setstack ty) rs0)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"apply agree_regs_undef_regs.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : agree_regs j rs rs0.","conclusion":"agree_regs j rs rs0","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : agree_locs f\n  (Locmap.set (S sl ofs ty) (rs (R src))\n     (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n  (parent_locset s).","conclusion":"agree_locs f\n  (Locmap.set (S sl ofs ty) (rs (R src))\n     (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n  (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"apply agree_locs_set_slot.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_setstack_caller_save.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : agree_locs f (LTL.undef_regs (destroyed_by_setstack ty) rs) (parent_locset s).","conclusion":"agree_locs f (LTL.undef_regs (destroyed_by_setstack ty) rs) (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"apply agree_locs_undef_locs.\nauto.\napply destroyed_by_setstack_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : agree_locs f rs (parent_locset s).","conclusion":"agree_locs f rs (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : existsb is_callee_save (destroyed_by_setstack ty) = false.","conclusion":"existsb is_callee_save (destroyed_by_setstack ty) = false","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"apply destroyed_by_setstack_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : slot_writable sl = true.","conclusion":"slot_writable sl = true","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : is_tail b (Linear.fn_code f).","conclusion":"is_tail b (Linear.fn_code f)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lsetstack src sl ofs ty :: b) rs\n     m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lsetstack src sl ofs ty :: b) (Linear.fn_code f)) (BOUND : slot_within_bounds (function_bounds f) sl ofs ty) (SV : slot_valid f sl ofs ty = true) (SW : slot_writable sl = true) (ofs' : Z) (m'' : mem) (STORE : store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) =\nSome m'') (SEP : m''\n|= frame_contents f j sp'\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) \n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"eauto with coqlib."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mop (transl_op (make_env (function_bounds f)) op) args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mop (transl_op (make_env (function_bounds f)) op) args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res)","proofString":"assert (exists v',          eval_operation ge (Vptr sp' Ptrofs.zero) (transl_op (make_env (function_bounds f)) op) rs0##args m' = Some v'       /\\ Val.inject j v v').\neapply eval_operation_inject; eauto.\neapply globalenv_inject_preserves_globals.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP.\neapply agree_reglist; eauto.\napply sep_proj2 in SEP.\napply sep_proj2 in SEP.\napply sep_proj1 in SEP.\nexact SEP.\ndestruct H0 as [v' [A B]].\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := v').\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\nrewrite transl_destroyed_by_op.\napply agree_regs_undef_regs; auto.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_op_caller_save.\napply frame_set_reg.\napply frame_undef_regs.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) : exists v' : val,\n  eval_operation ge (Vptr sp' Ptrofs.zero)\n    (transl_op (make_env (function_bounds f)) op) \n    rs0 ## args m' = Some v' /\\ Val.inject j v v'.","conclusion":"exists v' : val,\n  eval_operation ge (Vptr sp' Ptrofs.zero)\n    (transl_op (make_env (function_bounds f)) op) \n    rs0 ## args m' = Some v' /\\ Val.inject j v v'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res)","proofString":"eapply eval_operation_inject; eauto.\neapply globalenv_inject_preserves_globals.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP.\neapply agree_reglist; eauto.\napply sep_proj2 in SEP.\napply sep_proj2 in SEP.\napply sep_proj1 in SEP.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) : meminj_preserves_globals ge j.","conclusion":"meminj_preserves_globals ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res)","proofString":"eapply globalenv_inject_preserves_globals.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) : Val.inject_list j (reglist rs args) rs0 ## args.","conclusion":"Val.inject_list j (reglist rs args) rs0 ## args","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res)","proofString":"eapply agree_reglist; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) : Mem.inject j m m'.","conclusion":"Mem.inject j m m'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res)","proofString":"apply sep_proj2 in SEP.\napply sep_proj2 in SEP.\napply sep_proj1 in SEP.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m' |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) : Mem.inject j m m'.","conclusion":"Mem.inject j m m'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m' |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res)","proofString":"apply sep_proj2 in SEP.\napply sep_proj1 in SEP.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m' |= minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) : Mem.inject j m m'.","conclusion":"Mem.inject j m m'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m' |= minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res)","proofString":"apply sep_proj1 in SEP.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m' |= minjection j m) (BOUND : mreg_within_bounds (function_bounds f) res) : Mem.inject j m m'.","conclusion":"Mem.inject j m m'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m' |= minjection j m) (BOUND : mreg_within_bounds (function_bounds f) res)","proofString":"exact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (H0 : exists v' : val,\n  eval_operation ge (Vptr sp' Ptrofs.zero)\n    (transl_op (make_env (function_bounds f)) op) \n    rs0 ## args m' = Some v' /\\ Val.inject j v v') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mop (transl_op (make_env (function_bounds f)) op) args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mop (transl_op (make_env (function_bounds f)) op) args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (H0 : exists v' : val,\n  eval_operation ge (Vptr sp' Ptrofs.zero)\n    (transl_op (make_env (function_bounds f)) op) \n    rs0 ## args m' = Some v' /\\ Val.inject j v v')","proofString":"destruct H0 as [v' [A B]].\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := v').\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\nrewrite transl_destroyed_by_op.\napply agree_regs_undef_regs; auto.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_op_caller_save.\napply frame_set_reg.\napply frame_undef_regs.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mop (transl_op (make_env (function_bounds f)) op) args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mop (transl_op (make_env (function_bounds f)) op) args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"econstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := v').\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg; auto.\nrewrite transl_destroyed_by_op.\napply agree_regs_undef_regs; auto.\napply agree_locs_set_reg; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_op_caller_save.\napply frame_set_reg.\napply frame_undef_regs.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : eval_operation tge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v'.","conclusion":"eval_operation tge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"rewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : eval_operation tge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' =\neval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m'.","conclusion":"eval_operation tge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' =\neval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"apply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"exact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : agree_regs j (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs))\n  (undef_regs (destroyed_by_op (transl_op (make_env (function_bounds f)) op))\n     rs0) # res <- v'.","conclusion":"agree_regs j (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs))\n  (undef_regs (destroyed_by_op (transl_op (make_env (function_bounds f)) op))\n     rs0) # res <- v'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"apply agree_regs_set_reg; auto.\nrewrite transl_destroyed_by_op.\napply agree_regs_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : agree_regs j (LTL.undef_regs (destroyed_by_op op) rs)\n  (undef_regs (destroyed_by_op (transl_op (make_env (function_bounds f)) op))\n     rs0).","conclusion":"agree_regs j (LTL.undef_regs (destroyed_by_op op) rs)\n  (undef_regs (destroyed_by_op (transl_op (make_env (function_bounds f)) op))\n     rs0)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"rewrite transl_destroyed_by_op.\napply agree_regs_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : agree_regs j (LTL.undef_regs (destroyed_by_op op) rs)\n  (undef_regs (destroyed_by_op op) rs0).","conclusion":"agree_regs j (LTL.undef_regs (destroyed_by_op op) rs)\n  (undef_regs (destroyed_by_op op) rs0)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"apply agree_regs_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : agree_locs f (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs))\n  (parent_locset s).","conclusion":"agree_locs f (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs))\n  (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"apply agree_locs_set_reg; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_op_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : agree_locs f (LTL.undef_regs (destroyed_by_op op) rs) (parent_locset s).","conclusion":"agree_locs f (LTL.undef_regs (destroyed_by_op op) rs) (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"apply agree_locs_undef_locs.\nauto.\napply destroyed_by_op_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : agree_locs f rs (parent_locset s).","conclusion":"agree_locs f rs (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : existsb is_callee_save (destroyed_by_op op) = false.","conclusion":"existsb is_callee_save (destroyed_by_op op) = false","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"apply destroyed_by_op_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : m'\n|= frame_contents f j sp'\n     (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j.","conclusion":"m'\n|= frame_contents f j sp'\n     (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"apply frame_set_reg.\napply frame_undef_regs.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : m'\n|= frame_contents f j sp' (LTL.undef_regs (destroyed_by_op op) rs)\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j.","conclusion":"m'\n|= frame_contents f j sp' (LTL.undef_regs (destroyed_by_op op) rs)\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"apply frame_undef_regs.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v') : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j.","conclusion":"m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (op : operation) (args : list mreg) (res : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (v : val) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lop op args res :: b) rs m)) (H : eval_operation ge (Vptr sp0 Ptrofs.zero) op (reglist rs args) m = Some v) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lop op args res :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) res) (v' : val) (A : eval_operation ge (Vptr sp' Ptrofs.zero)\n  (transl_op (make_env (function_bounds f)) op) rs0 ## args m' = \nSome v') (B : Val.inject j v v')","proofString":"exact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst)","proofString":"assert (exists a',          eval_addressing ge (Vptr sp' Ptrofs.zero) (transl_addr (make_env (function_bounds f)) addr) rs0##args = Some a'       /\\ Val.inject j a a').\neapply eval_addressing_inject; eauto.\neapply globalenv_inject_preserves_globals.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP.\neapply agree_reglist; eauto.\ndestruct H1 as [a' [A B]].\nexploit loadv_parallel_rule.\napply sep_proj2 in SEP.\napply sep_proj2 in SEP.\napply sep_proj1 in SEP.\neexact SEP.\neauto.\neauto.\nintros [v' [C D]].\nexploit simplify_load_correct; eauto.\nintros [v'' [E F]].\nassert (G: Val.inject j v v'').\ninv F; auto.\ninv D; auto.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact E.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg.\nrewrite transl_destroyed_by_load, simplify_load_destroyed.\napply agree_regs_undef_regs; auto.\nauto.\napply agree_locs_set_reg.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_load_caller_save.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) : exists a' : val,\n  eval_addressing ge (Vptr sp' Ptrofs.zero)\n    (transl_addr (make_env (function_bounds f)) addr) \n    rs0 ## args = Some a' /\\ Val.inject j a a'.","conclusion":"exists a' : val,\n  eval_addressing ge (Vptr sp' Ptrofs.zero)\n    (transl_addr (make_env (function_bounds f)) addr) \n    rs0 ## args = Some a' /\\ Val.inject j a a'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst)","proofString":"eapply eval_addressing_inject; eauto.\neapply globalenv_inject_preserves_globals.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP.\neapply agree_reglist; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) : meminj_preserves_globals ge j.","conclusion":"meminj_preserves_globals ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst)","proofString":"eapply globalenv_inject_preserves_globals.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) : Val.inject_list j (reglist rs args) rs0 ## args.","conclusion":"Val.inject_list j (reglist rs args) rs0 ## args","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst)","proofString":"eapply agree_reglist; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (H1 : exists a' : val,\n  eval_addressing ge (Vptr sp' Ptrofs.zero)\n    (transl_addr (make_env (function_bounds f)) addr) \n    rs0 ## args = Some a' /\\ Val.inject j a a') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (H1 : exists a' : val,\n  eval_addressing ge (Vptr sp' Ptrofs.zero)\n    (transl_addr (make_env (function_bounds f)) addr) \n    rs0 ## args = Some a' /\\ Val.inject j a a')","proofString":"destruct H1 as [a' [A B]].\nexploit loadv_parallel_rule.\napply sep_proj2 in SEP.\napply sep_proj2 in SEP.\napply sep_proj1 in SEP.\neexact SEP.\neauto.\neauto.\nintros [v' [C D]].\nexploit simplify_load_correct; eauto.\nintros [v'' [E F]].\nassert (G: Val.inject j v v'').\ninv F; auto.\ninv D; auto.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact E.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg.\nrewrite transl_destroyed_by_load, simplify_load_destroyed.\napply agree_regs_undef_regs; auto.\nauto.\napply agree_locs_set_reg.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_load_caller_save.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a')","proofString":"exploit loadv_parallel_rule.\napply sep_proj2 in SEP.\napply sep_proj2 in SEP.\napply sep_proj1 in SEP.\neexact SEP.\neauto.\neauto.\nintros [v' [C D]].\nexploit simplify_load_correct; eauto.\nintros [v'' [E F]].\nassert (G: Val.inject j v v'').\ninv F; auto.\ninv D; auto.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact E.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg.\nrewrite transl_destroyed_by_load, simplify_load_destroyed.\napply agree_regs_undef_regs; auto.\nauto.\napply agree_locs_set_reg.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_load_caller_save.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v')","proofString":"exploit simplify_load_correct; eauto.\nintros [v'' [E F]].\nassert (G: Val.inject j v v'').\ninv F; auto.\ninv D; auto.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact E.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg.\nrewrite transl_destroyed_by_load, simplify_load_destroyed.\napply agree_regs_undef_regs; auto.\nauto.\napply agree_locs_set_reg.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_load_caller_save.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') : (exists v'0 : val,\n   Mem.loadv (simplify_load chunk) m' a' = Some v'0 /\\ Val.lessdef v' v'0) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'.","conclusion":"(exists v'0 : val,\n   Mem.loadv (simplify_load chunk) m' a' = Some v'0 /\\ Val.lessdef v' v'0) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v')","proofString":"intros [v'' [E F]].\nassert (G: Val.inject j v v'').\ninv F; auto.\ninv D; auto.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact E.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg.\nrewrite transl_destroyed_by_load, simplify_load_destroyed.\napply agree_regs_undef_regs; auto.\nauto.\napply agree_locs_set_reg.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_load_caller_save.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'')","proofString":"assert (G: Val.inject j v v'').\ninv F; auto.\ninv D; auto.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact E.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg.\nrewrite transl_destroyed_by_load, simplify_load_destroyed.\napply agree_regs_undef_regs; auto.\nauto.\napply agree_locs_set_reg.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_load_caller_save.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') : Val.inject j v v''.","conclusion":"Val.inject j v v''","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'')","proofString":"inv F; auto.\ninv D; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (D : Val.inject j v Vundef) (C : Mem.loadv chunk m' a' = Some Vundef) (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') : Val.inject j v v''.","conclusion":"Val.inject j v v''","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (D : Val.inject j v Vundef) (C : Mem.loadv chunk m' a' = Some Vundef) (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'')","proofString":"inv D; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mload (simplify_load chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args dst\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.set (R dst) v\n          (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"econstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact E.\neauto.\neconstructor; eauto with coqlib.\napply agree_regs_set_reg.\nrewrite transl_destroyed_by_load, simplify_load_destroyed.\napply agree_regs_undef_regs; auto.\nauto.\napply agree_locs_set_reg.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_load_caller_save.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : eval_addressing tge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a'.","conclusion":"eval_addressing tge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"rewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : eval_addressing tge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args =\neval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args.","conclusion":"eval_addressing tge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args =\neval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"exact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : agree_regs j\n  (Locmap.set (R dst) v (LTL.undef_regs (destroyed_by_load chunk addr) rs))\n  (undef_regs\n     (destroyed_by_load (simplify_load chunk)\n        (transl_addr (make_env (function_bounds f)) addr)) rs0) # dst <- v''.","conclusion":"agree_regs j\n  (Locmap.set (R dst) v (LTL.undef_regs (destroyed_by_load chunk addr) rs))\n  (undef_regs\n     (destroyed_by_load (simplify_load chunk)\n        (transl_addr (make_env (function_bounds f)) addr)) rs0) # dst <- v''","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"apply agree_regs_set_reg.\nrewrite transl_destroyed_by_load, simplify_load_destroyed.\napply agree_regs_undef_regs; auto.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : agree_regs j (LTL.undef_regs (destroyed_by_load chunk addr) rs)\n  (undef_regs\n     (destroyed_by_load (simplify_load chunk)\n        (transl_addr (make_env (function_bounds f)) addr)) rs0).","conclusion":"agree_regs j (LTL.undef_regs (destroyed_by_load chunk addr) rs)\n  (undef_regs\n     (destroyed_by_load (simplify_load chunk)\n        (transl_addr (make_env (function_bounds f)) addr)) rs0)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"rewrite transl_destroyed_by_load, simplify_load_destroyed.\napply agree_regs_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : agree_regs j (LTL.undef_regs (destroyed_by_load chunk addr) rs)\n  (undef_regs (destroyed_by_load chunk addr) rs0).","conclusion":"agree_regs j (LTL.undef_regs (destroyed_by_load chunk addr) rs)\n  (undef_regs (destroyed_by_load chunk addr) rs0)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"apply agree_regs_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : Val.inject j v v''.","conclusion":"Val.inject j v v''","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : agree_locs f\n  (Locmap.set (R dst) v (LTL.undef_regs (destroyed_by_load chunk addr) rs))\n  (parent_locset s).","conclusion":"agree_locs f\n  (Locmap.set (R dst) v (LTL.undef_regs (destroyed_by_load chunk addr) rs))\n  (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"apply agree_locs_set_reg.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_load_caller_save.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : agree_locs f (LTL.undef_regs (destroyed_by_load chunk addr) rs)\n  (parent_locset s).","conclusion":"agree_locs f (LTL.undef_regs (destroyed_by_load chunk addr) rs)\n  (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"apply agree_locs_undef_locs.\nauto.\napply destroyed_by_load_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : agree_locs f rs (parent_locset s).","conclusion":"agree_locs f rs (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : existsb is_callee_save (destroyed_by_load chunk addr) = false.","conclusion":"existsb is_callee_save (destroyed_by_load chunk addr) = false","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"apply destroyed_by_load_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'') : mreg_within_bounds (function_bounds f) dst.","conclusion":"mreg_within_bounds (function_bounds f) dst","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (a v : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lload chunk addr args dst :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lload chunk addr args dst :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : mreg_within_bounds (function_bounds f) dst) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (v' : val) (C : Mem.loadv chunk m' a' = Some v') (D : Val.inject j v v') (v'' : val) (E : Mem.loadv (simplify_load chunk) m' a' = Some v'') (F : Val.lessdef v' v'') (G : Val.inject j v v'')","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"assert (exists a',          eval_addressing ge (Vptr sp' Ptrofs.zero) (transl_addr (make_env (function_bounds f)) addr) rs0##args = Some a'       /\\ Val.inject j a a').\neapply eval_addressing_inject; eauto.\neapply globalenv_inject_preserves_globals.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP.\neapply agree_reglist; eauto.\ndestruct H1 as [a' [A B]].\nrewrite sep_swap3 in SEP.\nexploit storev_parallel_rule.\neexact SEP.\neauto.\neauto.\napply AGREGS.\nclear SEP; intros (m1' & C & SEP).\nrewrite sep_swap3 in SEP.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\napply simplify_store_correct.\neexact C.\neauto.\neconstructor.\neauto.\neauto.\neauto.\nrewrite transl_destroyed_by_store, simplify_store_destroyed.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_store_caller_save.\nauto.\neauto with coqlib.\neapply frame_undef_regs; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : exists a' : val,\n  eval_addressing ge (Vptr sp' Ptrofs.zero)\n    (transl_addr (make_env (function_bounds f)) addr) \n    rs0 ## args = Some a' /\\ Val.inject j a a'.","conclusion":"exists a' : val,\n  eval_addressing ge (Vptr sp' Ptrofs.zero)\n    (transl_addr (make_env (function_bounds f)) addr) \n    rs0 ## args = Some a' /\\ Val.inject j a a'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"eapply eval_addressing_inject; eauto.\neapply globalenv_inject_preserves_globals.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP.\neapply agree_reglist; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : meminj_preserves_globals ge j.","conclusion":"meminj_preserves_globals ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"eapply globalenv_inject_preserves_globals.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : Val.inject_list j (reglist rs args) rs0 ## args.","conclusion":"Val.inject_list j (reglist rs args) rs0 ## args","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"eapply agree_reglist; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H1 : exists a' : val,\n  eval_addressing ge (Vptr sp' Ptrofs.zero)\n    (transl_addr (make_env (function_bounds f)) addr) \n    rs0 ## args = Some a' /\\ Val.inject j a a') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H1 : exists a' : val,\n  eval_addressing ge (Vptr sp' Ptrofs.zero)\n    (transl_addr (make_env (function_bounds f)) addr) \n    rs0 ## args = Some a' /\\ Val.inject j a a')","proofString":"destruct H1 as [a' [A B]].\nrewrite sep_swap3 in SEP.\nexploit storev_parallel_rule.\neexact SEP.\neauto.\neauto.\napply AGREGS.\nclear SEP; intros (m1' & C & SEP).\nrewrite sep_swap3 in SEP.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\napply simplify_store_correct.\neexact C.\neauto.\neconstructor.\neauto.\neauto.\neauto.\nrewrite transl_destroyed_by_store, simplify_store_destroyed.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_store_caller_save.\nauto.\neauto with coqlib.\neapply frame_undef_regs; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a')","proofString":"rewrite sep_swap3 in SEP.\nexploit storev_parallel_rule.\neexact SEP.\neauto.\neauto.\napply AGREGS.\nclear SEP; intros (m1' & C & SEP).\nrewrite sep_swap3 in SEP.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\napply simplify_store_correct.\neexact C.\neauto.\neconstructor.\neauto.\neauto.\neauto.\nrewrite transl_destroyed_by_store, simplify_store_destroyed.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_store_caller_save.\nauto.\neauto with coqlib.\neapply frame_undef_regs; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= minjection j m **\n   stack_contents j s cs' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** globalenv_inject ge j) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (SEP : m'0\n|= minjection j m **\n   stack_contents j s cs' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** globalenv_inject ge j) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a')","proofString":"exploit storev_parallel_rule.\neexact SEP.\neauto.\neauto.\napply AGREGS.\nclear SEP; intros (m1' & C & SEP).\nrewrite sep_swap3 in SEP.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\napply simplify_store_correct.\neexact C.\neauto.\neconstructor.\neauto.\neauto.\neauto.\nrewrite transl_destroyed_by_store, simplify_store_destroyed.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_store_caller_save.\nauto.\neauto with coqlib.\neapply frame_undef_regs; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= minjection j m' **\n   stack_contents j s cs' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** globalenv_inject ge j) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= minjection j m' **\n   stack_contents j s cs' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** globalenv_inject ge j)","proofString":"rewrite sep_swap3 in SEP.\neconstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\napply simplify_store_correct.\neexact C.\neauto.\neconstructor.\neauto.\neauto.\neauto.\nrewrite transl_destroyed_by_store, simplify_store_destroyed.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_store_caller_save.\nauto.\neauto with coqlib.\neapply frame_undef_regs; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mstore (simplify_store chunk)\n          (transl_addr (make_env (function_bounds f)) addr) args src\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j)","proofString":"econstructor; split.\napply plus_one.\neconstructor.\ninstantiate (1 := a').\nrewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved.\napply simplify_store_correct.\neexact C.\neauto.\neconstructor.\neauto.\neauto.\neauto.\nrewrite transl_destroyed_by_store, simplify_store_destroyed.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_store_caller_save.\nauto.\neauto with coqlib.\neapply frame_undef_regs; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) : eval_addressing tge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a'.","conclusion":"eval_addressing tge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j)","proofString":"rewrite <- A.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) : eval_addressing tge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args =\neval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args.","conclusion":"eval_addressing tge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args =\neval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j)","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j)","proofString":"exact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) : agree_regs j (LTL.undef_regs (destroyed_by_store chunk addr) rs)\n  (undef_regs (destroyed_by_store chunk addr) rs0).","conclusion":"agree_regs j (LTL.undef_regs (destroyed_by_store chunk addr) rs)\n  (undef_regs (destroyed_by_store chunk addr) rs0)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j)","proofString":"apply agree_regs_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) : agree_locs f (LTL.undef_regs (destroyed_by_store chunk addr) rs)\n  (parent_locset s).","conclusion":"agree_locs f (LTL.undef_regs (destroyed_by_store chunk addr) rs)\n  (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j)","proofString":"apply agree_locs_undef_locs.\nauto.\napply destroyed_by_store_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) : agree_locs f rs (parent_locset s).","conclusion":"agree_locs f rs (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j)","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) : existsb is_callee_save (destroyed_by_store chunk addr) = false.","conclusion":"existsb is_callee_save (destroyed_by_store chunk addr) = false","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j)","proofString":"apply destroyed_by_store_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) : is_tail b (Linear.fn_code f).","conclusion":"is_tail b (Linear.fn_code f)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list Linear.instruction) (rs : LTL.locset) (m m' : mem) (a : val) (sp0 : block) (H : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lstore chunk addr args src :: b)\n     rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lstore chunk addr args src :: b) (Linear.fn_code f)) (BOUND : True) (a' : val) (A : eval_addressing ge (Vptr sp' Ptrofs.zero)\n  (transl_addr (make_env (function_bounds f)) addr) \n  rs0 ## args = Some a') (B : Val.inject j a a') (m1' : mem) (C : Mem.storev chunk m'0 a' (rs0 src) = Some m1') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j)","proofString":"eauto with coqlib."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot))","proofString":"exploit find_function_translated; eauto.\neapply sep_proj2.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP.\nintros [bf [tf' [A [B C]]]].\nexploit is_tail_transf_function; eauto.\nintros IST.\nrewrite transl_code_eq in IST.\nsimpl in IST.\nexploit return_address_offset_exists.\neexact IST.\nintros [ra D].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto with coqlib.\napply Val.Vptr_has_type.\nintros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto.\nsimpl.\nrewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) : (exists (bf : block) (tf0 : fundef),\n   find_function_ptr tge ros rs0 = Some bf /\\\n   Genv.find_funct_ptr tge bf = Some tf0 /\\ transf_fundef f' = OK tf0) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'.","conclusion":"(exists (bf : block) (tf0 : fundef),\n   find_function_ptr tge ros rs0 = Some bf /\\\n   Genv.find_funct_ptr tge bf = Some tf0 /\\ transf_fundef f' = OK tf0) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot))","proofString":"intros [bf [tf' [A [B C]]]].\nexploit is_tail_transf_function; eauto.\nintros IST.\nrewrite transl_code_eq in IST.\nsimpl in IST.\nexploit return_address_offset_exists.\neexact IST.\nintros [ra D].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto with coqlib.\napply Val.Vptr_has_type.\nintros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto.\nsimpl.\nrewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf')","proofString":"exploit is_tail_transf_function; eauto.\nintros IST.\nrewrite transl_code_eq in IST.\nsimpl in IST.\nexploit return_address_offset_exists.\neexact IST.\nintros [ra D].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto with coqlib.\napply Val.Vptr_has_type.\nintros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto.\nsimpl.\nrewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') : is_tail\n  (transl_code (make_env (function_bounds f))\n     (Lcall (Linear.funsig f') ros :: b)) (fn_code tf) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'.","conclusion":"is_tail\n  (transl_code (make_env (function_bounds f))\n     (Lcall (Linear.funsig f') ros :: b)) (fn_code tf) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf')","proofString":"intros IST.\nrewrite transl_code_eq in IST.\nsimpl in IST.\nexploit return_address_offset_exists.\neexact IST.\nintros [ra D].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto with coqlib.\napply Val.Vptr_has_type.\nintros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto.\nsimpl.\nrewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (transl_code (make_env (function_bounds f))\n     (Lcall (Linear.funsig f') ros :: b)) (fn_code tf)) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (transl_code (make_env (function_bounds f))\n     (Lcall (Linear.funsig f') ros :: b)) (fn_code tf))","proofString":"rewrite transl_code_eq in IST.\nsimpl in IST.\nexploit return_address_offset_exists.\neexact IST.\nintros [ra D].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto with coqlib.\napply Val.Vptr_has_type.\nintros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto.\nsimpl.\nrewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (transl_instr (make_env (function_bounds f)) (Lcall (Linear.funsig f') ros)\n     (transl_code (make_env (function_bounds f)) b)) \n  (fn_code tf)) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (transl_instr (make_env (function_bounds f)) (Lcall (Linear.funsig f') ros)\n     (transl_code (make_env (function_bounds f)) b)) \n  (fn_code tf))","proofString":"simpl in IST.\nexploit return_address_offset_exists.\neexact IST.\nintros [ra D].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto with coqlib.\napply Val.Vptr_has_type.\nintros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto.\nsimpl.\nrewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf))","proofString":"exploit return_address_offset_exists.\neexact IST.\nintros [ra D].\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto with coqlib.\napply Val.Vptr_has_type.\nintros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto.\nsimpl.\nrewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcall (Linear.funsig f') ros\n        :: transl_code (make_env (function_bounds f)) b) rs0 m') E0 s2' /\\\n  match_states\n    (Linear.Callstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n       f' rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra)","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto with coqlib.\napply Val.Vptr_has_type.\nintros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto.\nsimpl.\nrewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) : match_stacks j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n  (Stackframe fb (Vptr sp' Ptrofs.zero) (Vptr fb ra)\n     (transl_code (make_env (function_bounds f)) b) :: cs')\n  (Linear.funsig f').","conclusion":"match_stacks j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n  (Stackframe fb (Vptr sp' Ptrofs.zero) (Vptr fb ra)\n     (transl_code (make_env (function_bounds f)) b) :: cs')\n  (Linear.funsig f')","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra)","proofString":"econstructor; eauto with coqlib.\napply Val.Vptr_has_type.\nintros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) : Val.has_type (Vptr fb ra) Tptr.","conclusion":"Val.has_type (Vptr fb ra) Tptr","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra)","proofString":"apply Val.Vptr_has_type."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.funsig f'))) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty.","conclusion":"forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.funsig f'))) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra)","proofString":"intros; red.\napply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) (ofs : Z) (ty : typ) (H0 : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.funsig f')))) : ofs + typesize ty <= bound_outgoing (function_bounds f).","conclusion":"ofs + typesize ty <= bound_outgoing (function_bounds f)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) (ofs : Z) (ty : typ) (H0 : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.funsig f'))))","proofString":"apply Z.le_trans with (size_arguments (Linear.funsig f')); auto.\napply loc_arguments_bounded; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) (ofs : Z) (ty : typ) (H0 : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.funsig f')))) : ofs + typesize ty <= size_arguments (Linear.funsig f').","conclusion":"ofs + typesize ty <= size_arguments (Linear.funsig f')","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) (ofs : Z) (ty : typ) (H0 : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments (Linear.funsig f'))))","proofString":"apply loc_arguments_bounded; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) : m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) (Vptr fb ra)\n        (transl_code (make_env (function_bounds f)) b) :: cs') **\n   minjection j m ** globalenv_inject ge j.","conclusion":"m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs b :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) (Vptr fb ra)\n        (transl_code (make_env (function_bounds f)) b) :: cs') **\n   minjection j m ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra)","proofString":"simpl.\nrewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) : m'\n|= (frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n      (parent_ra cs') ** stack_contents j s cs') **\n   minjection j m ** globalenv_inject ge j.","conclusion":"m'\n|= (frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n      (parent_ra cs') ** stack_contents j s cs') **\n   minjection j m ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra)","proofString":"rewrite sep_assoc.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra) : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j.","conclusion":"m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (ros : mreg + ident) (b : list Linear.instruction) (rs : locset) (m : mem) (f' : Linear.fundef) (H : find_function ge ros rs = Some f') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero)\n     (Lcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : size_arguments (Linear.funsig f') <=\nZ.max (max_over_instrs f outgoing_space)\n  (max_over_slots_of_funct f outgoing_slot)) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs0 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') (IST : is_tail\n  (Mcall (Linear.funsig f') ros\n   :: transl_code (make_env (function_bounds f)) b) \n  (fn_code tf)) (ra : ptrofs) (D : return_address_offset tf (transl_code (make_env (function_bounds f)) b) ra)","proofString":"exact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (restore_callee_save (make_env (function_bounds f))\n          (Mtailcall (Linear.funsig f') ros\n           :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0 s2' /\\\n  match_states (Linear.Callstate s f' (return_regs (parent_locset s) rs) m')\n    s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (restore_callee_save (make_env (function_bounds f))\n          (Mtailcall (Linear.funsig f') ros\n           :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0 s2' /\\\n  match_states (Linear.Callstate s f' (return_regs (parent_locset s) rs) m')\n    s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"rewrite (sep_swap (stack_contents j s cs')) in SEP.\nexploit function_epilogue_correct; eauto.\nclear SEP.\nintros (rs1 & m1' & P & Q & R & S & T & U & SEP).\nrewrite sep_swap in SEP.\nexploit find_function_translated; eauto.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP.\nintros [bf [tf' [A [B C]]]].\neconstructor; split.\neapply plus_right.\neexact S.\neconstructor; eauto.\ntraceEq.\neconstructor; eauto.\napply match_stacks_change_sig with (Linear.fn_sig f); auto.\napply zero_size_arguments_tailcall_possible.\neapply wt_state_tailcall; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   minjection j m ** stack_contents j s cs' ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (restore_callee_save (make_env (function_bounds f))\n          (Mtailcall (Linear.funsig f') ros\n           :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0 s2' /\\\n  match_states (Linear.Callstate s f' (return_regs (parent_locset s) rs) m')\n    s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (restore_callee_save (make_env (function_bounds f))\n          (Mtailcall (Linear.funsig f') ros\n           :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0 s2' /\\\n  match_states (Linear.Callstate s f' (return_regs (parent_locset s) rs) m')\n    s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   minjection j m ** stack_contents j s cs' ** globalenv_inject ge j) (BOUND : True)","proofString":"exploit function_epilogue_correct; eauto.\nclear SEP.\nintros (rs1 & m1' & P & Q & R & S & T & U & SEP).\nrewrite sep_swap in SEP.\nexploit find_function_translated; eauto.\neapply sep_proj2.\neapply sep_proj2.\neexact SEP.\nintros [bf [tf' [A [B C]]]].\neconstructor; split.\neapply plus_right.\neexact S.\neconstructor; eauto.\ntraceEq.\neconstructor; eauto.\napply match_stacks_change_sig with (Linear.fn_sig f); auto.\napply zero_size_arguments_tailcall_possible.\neapply wt_state_tailcall; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (BOUND : True) (rs1 : regset) (m1' : mem) (P : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp cs')) (Q : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) =\nSome (parent_ra cs')) (R : Mem.free m'0 sp' 0 (fn_stacksize tf) = Some m1') (S : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (restore_callee_save (make_env (function_bounds f))\n        (Mtailcall (Linear.funsig f') ros\n         :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (Mtailcall (Linear.funsig f') ros\n      :: transl_code (make_env (function_bounds f)) b) rs1 m'0)) (T : agree_regs j (return_regs (parent_locset s) rs) rs1) (U : agree_callee_save (return_regs (parent_locset s) rs) (parent_locset s)) (SEP : m1' |= stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs1 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') : match_stacks j s cs' (Linear.funsig f').","conclusion":"match_stacks j s cs' (Linear.funsig f')","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (BOUND : True) (rs1 : regset) (m1' : mem) (P : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp cs')) (Q : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) =\nSome (parent_ra cs')) (R : Mem.free m'0 sp' 0 (fn_stacksize tf) = Some m1') (S : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (restore_callee_save (make_env (function_bounds f))\n        (Mtailcall (Linear.funsig f') ros\n         :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (Mtailcall (Linear.funsig f') ros\n      :: transl_code (make_env (function_bounds f)) b) rs1 m'0)) (T : agree_regs j (return_regs (parent_locset s) rs) rs1) (U : agree_callee_save (return_regs (parent_locset s) rs) (parent_locset s)) (SEP : m1' |= stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs1 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf')","proofString":"apply match_stacks_change_sig with (Linear.fn_sig f); auto.\napply zero_size_arguments_tailcall_possible.\neapply wt_state_tailcall; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (BOUND : True) (rs1 : regset) (m1' : mem) (P : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp cs')) (Q : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) =\nSome (parent_ra cs')) (R : Mem.free m'0 sp' 0 (fn_stacksize tf) = Some m1') (S : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (restore_callee_save (make_env (function_bounds f))\n        (Mtailcall (Linear.funsig f') ros\n         :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (Mtailcall (Linear.funsig f') ros\n      :: transl_code (make_env (function_bounds f)) b) rs1 m'0)) (T : agree_regs j (return_regs (parent_locset s) rs) rs1) (U : agree_callee_save (return_regs (parent_locset s) rs) (parent_locset s)) (SEP : m1' |= stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs1 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') : tailcall_possible (Linear.funsig f').","conclusion":"tailcall_possible (Linear.funsig f')","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (BOUND : True) (rs1 : regset) (m1' : mem) (P : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp cs')) (Q : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) =\nSome (parent_ra cs')) (R : Mem.free m'0 sp' 0 (fn_stacksize tf) = Some m1') (S : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (restore_callee_save (make_env (function_bounds f))\n        (Mtailcall (Linear.funsig f') ros\n         :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (Mtailcall (Linear.funsig f') ros\n      :: transl_code (make_env (function_bounds f)) b) rs1 m'0)) (T : agree_regs j (return_regs (parent_locset s) rs) rs1) (U : agree_callee_save (return_regs (parent_locset s) rs) (parent_locset s)) (SEP : m1' |= stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs1 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf')","proofString":"apply zero_size_arguments_tailcall_possible.\neapply wt_state_tailcall; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (BOUND : True) (rs1 : regset) (m1' : mem) (P : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp cs')) (Q : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) =\nSome (parent_ra cs')) (R : Mem.free m'0 sp' 0 (fn_stacksize tf) = Some m1') (S : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (restore_callee_save (make_env (function_bounds f))\n        (Mtailcall (Linear.funsig f') ros\n         :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (Mtailcall (Linear.funsig f') ros\n      :: transl_code (make_env (function_bounds f)) b) rs1 m'0)) (T : agree_regs j (return_regs (parent_locset s) rs) rs1) (U : agree_callee_save (return_regs (parent_locset s) rs) (parent_locset s)) (SEP : m1' |= stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs1 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf') : size_arguments (Linear.funsig f') = 0.","conclusion":"size_arguments (Linear.funsig f') = 0","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (ros : mreg + ident) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (f' : Linear.fundef) (m' : mem) (H0 : find_function ge ros (return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state\n  (Linear.State s f (Vptr stk Ptrofs.zero)\n     (Ltailcall (Linear.funsig f') ros :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ltailcall (Linear.funsig f') ros :: b) (Linear.fn_code f)) (BOUND : True) (rs1 : regset) (m1' : mem) (P : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp cs')) (Q : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) =\nSome (parent_ra cs')) (R : Mem.free m'0 sp' 0 (fn_stacksize tf) = Some m1') (S : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (restore_callee_save (make_env (function_bounds f))\n        (Mtailcall (Linear.funsig f') ros\n         :: transl_code (make_env (function_bounds f)) b)) rs0 m'0) E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (Mtailcall (Linear.funsig f') ros\n      :: transl_code (make_env (function_bounds f)) b) rs1 m'0)) (T : agree_regs j (return_regs (parent_locset s) rs) rs1) (U : agree_callee_save (return_regs (parent_locset s) rs) (parent_locset s)) (SEP : m1' |= stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j) (bf : block) (tf' : fundef) (A : find_function_ptr tge ros rs1 = Some bf) (B : Genv.find_funct_ptr tge bf = Some tf') (C : transf_fundef f' = OK tf')","proofString":"eapply wt_state_tailcall; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : (forall r : mreg,\n In r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\n mreg_within_bounds (function_bounds f) r) /\\\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args args) ->\n slot_within_bounds (function_bounds f) sl ofs ty)) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : (forall r : mreg,\n In r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\n mreg_within_bounds (function_bounds f) r) /\\\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args args) ->\n slot_within_bounds (function_bounds f) sl ofs ty))","proofString":"destruct BOUND as [BND1 BND2].\nexploit transl_builtin_args_correct.\neauto.\neauto.\nrewrite sep_swap in SEP; apply sep_proj2 in SEP; eexact SEP.\neauto.\nrewrite <- forallb_forall.\neapply wt_state_builtin; eauto.\nexact BND2.\nintros [vargs' [P Q]].\nrewrite <- sep_assoc, sep_comm, sep_assoc in SEP.\nexploit external_call_parallel_rule; eauto.\nclear SEP; intros (j' & res' & m1' & EC & RES & SEP & INCR & ISEP).\nrewrite <- sep_assoc, sep_comm, sep_assoc in SEP.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\napply agree_regs_set_res; auto.\napply agree_regs_undef_regs; auto.\neapply agree_regs_inject_incr; eauto.\napply agree_locs_set_res; auto.\napply agree_locs_undef_regs; auto.\napply frame_set_res.\napply frame_undef_regs.\napply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty)","proofString":"exploit transl_builtin_args_correct.\neauto.\neauto.\nrewrite sep_swap in SEP; apply sep_proj2 in SEP; eexact SEP.\neauto.\nrewrite <- forallb_forall.\neapply wt_state_builtin; eauto.\nexact BND2.\nintros [vargs' [P Q]].\nrewrite <- sep_assoc, sep_comm, sep_assoc in SEP.\nexploit external_call_parallel_rule; eauto.\nclear SEP; intros (j' & res' & m1' & EC & RES & SEP & INCR & ISEP).\nrewrite <- sep_assoc, sep_comm, sep_assoc in SEP.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\napply agree_regs_set_res; auto.\napply agree_regs_undef_regs; auto.\neapply agree_regs_inject_incr; eauto.\napply agree_locs_set_res; auto.\napply agree_locs_undef_regs; auto.\napply frame_set_res.\napply frame_undef_regs.\napply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) : forallb (loc_valid f) (params_of_builtin_args args) = true.","conclusion":"forallb (loc_valid f) (params_of_builtin_args args) = true","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty)","proofString":"eapply wt_state_builtin; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs')","proofString":"rewrite <- sep_assoc, sep_comm, sep_assoc in SEP.\nexploit external_call_parallel_rule; eauto.\nclear SEP; intros (j' & res' & m1' & EC & RES & SEP & INCR & ISEP).\nrewrite <- sep_assoc, sep_comm, sep_assoc in SEP.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\napply agree_regs_set_res; auto.\napply agree_regs_undef_regs; auto.\neapply agree_regs_inject_incr; eauto.\napply agree_locs_set_res; auto.\napply agree_locs_undef_regs; auto.\napply frame_set_res.\napply frame_undef_regs.\napply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= minjection j m **\n   globalenv_inject ge j **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** stack_contents j s cs') (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= minjection j m **\n   globalenv_inject ge j **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** stack_contents j s cs') (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs')","proofString":"exploit external_call_parallel_rule; eauto.\nclear SEP; intros (j' & res' & m1' & EC & RES & SEP & INCR & ISEP).\nrewrite <- sep_assoc, sep_comm, sep_assoc in SEP.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\napply agree_regs_set_res; auto.\napply agree_regs_undef_regs; auto.\neapply agree_regs_inject_incr; eauto.\napply agree_locs_set_res; auto.\napply agree_locs_undef_regs; auto.\napply frame_set_res.\napply frame_undef_regs.\napply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= minjection j m **\n   globalenv_inject ge j **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** stack_contents j s cs') (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') : (exists (j' : meminj) (vres2 : val) (m2' : mem),\n   external_call ef ge vargs' m'0 t vres2 m2' /\\\n   Val.inject j' vres vres2 /\\\n   m2'\n   |= minjection j' m' **\n      globalenv_inject ge j' **\n      frame_contents f j sp' rs (parent_locset s) \n        (parent_sp cs') (parent_ra cs') ** stack_contents j s cs' /\\\n   inject_incr j j' /\\ inject_separated j j' m m'0) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'.","conclusion":"(exists (j' : meminj) (vres2 : val) (m2' : mem),\n   external_call ef ge vargs' m'0 t vres2 m2' /\\\n   Val.inject j' vres vres2 /\\\n   m2'\n   |= minjection j' m' **\n      globalenv_inject ge j' **\n      frame_contents f j sp' rs (parent_locset s) \n        (parent_sp cs') (parent_ra cs') ** stack_contents j s cs' /\\\n   inject_incr j j' /\\ inject_separated j j' m m'0) ->\nexists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (SEP : m'0\n|= minjection j m **\n   globalenv_inject ge j **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** stack_contents j s cs') (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs')","proofString":"clear SEP; intros (j' & res' & m1' & EC & RES & SEP & INCR & ISEP).\nrewrite <- sep_assoc, sep_comm, sep_assoc in SEP.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\napply agree_regs_set_res; auto.\napply agree_regs_undef_regs; auto.\neapply agree_regs_inject_incr; eauto.\napply agree_locs_set_res; auto.\napply agree_locs_undef_regs; auto.\napply frame_set_res.\napply frame_undef_regs.\napply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= minjection j' m' **\n   globalenv_inject ge j' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** stack_contents j s cs') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= minjection j' m' **\n   globalenv_inject ge j' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** stack_contents j s cs') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"rewrite <- sep_assoc, sep_comm, sep_assoc in SEP.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\napply agree_regs_set_res; auto.\napply agree_regs_undef_regs; auto.\neapply agree_regs_inject_incr; eauto.\napply agree_locs_set_res; auto.\napply agree_locs_undef_regs; auto.\napply frame_set_res.\napply frame_undef_regs.\napply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mbuiltin ef\n          (transl_builtin_arg (make_env (function_bounds f))) ## args res\n        :: transl_code (make_env (function_bounds f)) b) rs0 m'0) t s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n       m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\napply agree_regs_set_res; auto.\napply agree_regs_undef_regs; auto.\neapply agree_regs_inject_incr; eauto.\napply agree_locs_set_res; auto.\napply agree_locs_undef_regs; auto.\napply frame_set_res.\napply frame_undef_regs.\napply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","conclusion":"forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"exact symbols_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"apply senv_preserved."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : match_stacks j' s cs' (Linear.fn_sig f).","conclusion":"match_stacks j' s cs' (Linear.fn_sig f)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"eapply match_stacks_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : agree_regs j'\n  (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n  (set_res res res' (undef_regs (destroyed_by_builtin ef) rs0)).","conclusion":"agree_regs j'\n  (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n  (set_res res res' (undef_regs (destroyed_by_builtin ef) rs0))","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"apply agree_regs_set_res; auto.\napply agree_regs_undef_regs; auto.\neapply agree_regs_inject_incr; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : agree_regs j' (LTL.undef_regs (destroyed_by_builtin ef) rs)\n  (undef_regs (destroyed_by_builtin ef) rs0).","conclusion":"agree_regs j' (LTL.undef_regs (destroyed_by_builtin ef) rs)\n  (undef_regs (destroyed_by_builtin ef) rs0)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"apply agree_regs_undef_regs; auto.\neapply agree_regs_inject_incr; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : agree_regs j' rs rs0.","conclusion":"agree_regs j' rs rs0","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"eapply agree_regs_inject_incr; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : agree_locs f\n  (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n  (parent_locset s).","conclusion":"agree_locs f\n  (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n  (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"apply agree_locs_set_res; auto.\napply agree_locs_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : agree_locs f (LTL.undef_regs (destroyed_by_builtin ef) rs) (parent_locset s).","conclusion":"agree_locs f (LTL.undef_regs (destroyed_by_builtin ef) rs) (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"apply agree_locs_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : m1'\n|= frame_contents f j' sp'\n     (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'.","conclusion":"m1'\n|= frame_contents f j' sp'\n     (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"apply frame_set_res.\napply frame_undef_regs.\napply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : m1'\n|= frame_contents f j' sp' (LTL.undef_regs (destroyed_by_builtin ef) rs)\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'.","conclusion":"m1'\n|= frame_contents f j' sp' (LTL.undef_regs (destroyed_by_builtin ef) rs)\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"apply frame_undef_regs.\napply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : m1'\n|= frame_contents f j' sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'.","conclusion":"m1'\n|= frame_contents f j' sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"apply frame_contents_incr with j; auto.\nrewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'.","conclusion":"m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"rewrite sep_swap2.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : m1'\n|= stack_contents j' s cs' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** minjection j' m' ** globalenv_inject ge j'.","conclusion":"m1'\n|= stack_contents j' s cs' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"apply stack_contents_change_meminj with j; auto.\nrewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : m1'\n|= stack_contents j s cs' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** minjection j' m' ** globalenv_inject ge j'.","conclusion":"m1'\n|= stack_contents j s cs' **\n   frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') ** minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"rewrite sep_swap2.\nexact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0) : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j'.","conclusion":"m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list Linear.instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (sp0 : block) (H : eval_builtin_args ge rs (Vptr sp0 Ptrofs.zero) m args vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lbuiltin ef args res :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lbuiltin ef args res :: b) (Linear.fn_code f)) (BND1 : forall r : mreg,\nIn r (params_of_builtin_res res) \\/ In r (destroyed_by_builtin ef) ->\nmreg_within_bounds (function_bounds f) r) (BND2 : forall (sl : slot) (ofs : Z) (ty : typ),\nIn (S sl ofs ty) (params_of_builtin_args args) ->\nslot_within_bounds (function_bounds f) sl ofs ty) (vargs' : list val) (P : eval_builtin_args ge rs0 (Vptr sp' Ptrofs.zero) m'0\n  (transl_builtin_arg (make_env (function_bounds f))) ## args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (res' : val) (m1' : mem) (EC : external_call ef ge vargs' m'0 t res' m1') (RES : Val.inject j' vres res') (SEP : m1'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (INCR : inject_incr j j') (ISEP : inject_separated j j' m m'0)","proofString":"exact SEP."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (lbl : Linear.label) (b : list Linear.instruction) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state (Linear.State s f (Vptr sp0 Ptrofs.zero) (Llabel lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Llabel lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mlabel lbl :: transl_code (make_env (function_bounds f)) b) rs0 m')\n    E0 s2' /\\\n  match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) b rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mlabel lbl :: transl_code (make_env (function_bounds f)) b) rs0 m')\n    E0 s2' /\\\n  match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) b rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (lbl : Linear.label) (b : list Linear.instruction) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state (Linear.State s f (Vptr sp0 Ptrofs.zero) (Llabel lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Llabel lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"econstructor; split.\napply plus_one; apply exec_Mlabel.\neconstructor; eauto with coqlib."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (lbl : Linear.label) (b : list Linear.instruction) (rs : locset) (m : mem) (b' : Linear.code) (H : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgoto lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgoto lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgoto lbl :: transl_code (make_env (function_bounds f)) b) rs0 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) b' rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mgoto lbl :: transl_code (make_env (function_bounds f)) b) rs0 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) b' rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (lbl : Linear.label) (b : list Linear.instruction) (rs : locset) (m : mem) (b' : Linear.code) (H : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgoto lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgoto lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"econstructor; split.\napply plus_one; eapply exec_Mgoto; eauto.\napply transl_find_label; eauto.\neconstructor; eauto.\neapply find_label_tail; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (lbl : Linear.label) (b : list Linear.instruction) (rs : locset) (m : mem) (b' : Linear.code) (H : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgoto lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgoto lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : is_tail b' (Linear.fn_code f).","conclusion":"is_tail b' (Linear.fn_code f)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (lbl : Linear.label) (b : list Linear.instruction) (rs : locset) (m : mem) (b' : Linear.code) (H : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lgoto lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lgoto lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"eapply find_label_tail; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcond cond args lbl :: transl_code (make_env (function_bounds f)) b)\n       rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b'\n       (LTL.undef_regs (destroyed_by_cond cond) rs) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcond cond args lbl :: transl_code (make_env (function_bounds f)) b)\n       rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b'\n       (LTL.undef_regs (destroyed_by_cond cond) rs) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"econstructor; split.\napply plus_one.\neapply exec_Mcond_true; eauto.\neapply eval_condition_inject with (m1 := m).\neapply agree_reglist; eauto.\napply sep_pick3 in SEP; exact SEP.\nauto.\neapply transl_find_label; eauto.\neconstructor.\neauto.\neauto.\neauto.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_cond_caller_save.\nauto.\neapply find_label_tail; eauto.\napply frame_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : eval_condition cond rs0 ## args m' = Some true.","conclusion":"eval_condition cond rs0 ## args m' = Some true","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"eapply eval_condition_inject with (m1 := m).\neapply agree_reglist; eauto.\napply sep_pick3 in SEP; exact SEP.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : agree_locs f (LTL.undef_regs (destroyed_by_cond cond) rs) (parent_locset s).","conclusion":"agree_locs f (LTL.undef_regs (destroyed_by_cond cond) rs) (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"apply agree_locs_undef_locs.\nauto.\napply destroyed_by_cond_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : agree_locs f rs (parent_locset s).","conclusion":"agree_locs f rs (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : existsb is_callee_save (destroyed_by_cond cond) = false.","conclusion":"existsb is_callee_save (destroyed_by_cond cond) = false","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"apply destroyed_by_cond_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : is_tail b' (Linear.fn_code f).","conclusion":"is_tail b' (Linear.fn_code f)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (b' : Linear.code) (H : eval_condition cond (reglist rs args) m = Some true) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"eapply find_label_tail; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcond cond args lbl :: transl_code (make_env (function_bounds f)) b)\n       rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_cond cond) rs) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mcond cond args lbl :: transl_code (make_env (function_bounds f)) b)\n       rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b\n       (LTL.undef_regs (destroyed_by_cond cond) rs) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"econstructor; split.\napply plus_one.\neapply exec_Mcond_false; eauto.\neapply eval_condition_inject with (m1 := m).\neapply agree_reglist; eauto.\napply sep_pick3 in SEP; exact SEP.\nauto.\neconstructor.\neauto.\neauto.\neauto.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_cond_caller_save.\nauto.\neauto with coqlib.\napply frame_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : eval_condition cond rs0 ## args m' = Some false.","conclusion":"eval_condition cond rs0 ## args m' = Some false","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"eapply eval_condition_inject with (m1 := m).\neapply agree_reglist; eauto.\napply sep_pick3 in SEP; exact SEP.\nauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : agree_locs f (LTL.undef_regs (destroyed_by_cond cond) rs) (parent_locset s).","conclusion":"agree_locs f (LTL.undef_regs (destroyed_by_cond cond) rs) (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"apply agree_locs_undef_locs.\nauto.\napply destroyed_by_cond_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : agree_locs f rs (parent_locset s).","conclusion":"agree_locs f rs (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : existsb is_callee_save (destroyed_by_cond cond) = false.","conclusion":"existsb is_callee_save (destroyed_by_cond cond) = false","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"apply destroyed_by_cond_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : is_tail b (Linear.fn_code f).","conclusion":"is_tail b (Linear.fn_code f)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (cond : condition) (args : list mreg) (lbl : Linear.label) (b : list Linear.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Lcond cond args lbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lcond cond args lbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"eauto with coqlib."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mjumptable arg tbl :: transl_code (make_env (function_bounds f)) b)\n       rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b'\n       (LTL.undef_regs destroyed_by_jumptable rs) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mjumptable arg tbl :: transl_code (make_env (function_bounds f)) b)\n       rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b'\n       (LTL.undef_regs destroyed_by_jumptable rs) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"assert (rs0 arg = Vint n).\ngeneralize (AGREGS arg).\nrewrite H.\nintro IJ; inv IJ; auto.\neconstructor; split.\napply plus_one; eapply exec_Mjumptable; eauto.\napply transl_find_label; eauto.\neconstructor.\neauto.\neauto.\neauto.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_jumptable_caller_save.\nauto.\neapply find_label_tail; eauto.\napply frame_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : rs0 arg = Vint n.","conclusion":"rs0 arg = Vint n","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"generalize (AGREGS arg).\nrewrite H.\nintro IJ; inv IJ; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : Val.inject j (rs (R arg)) (rs0 arg) -> rs0 arg = Vint n.","conclusion":"Val.inject j (rs (R arg)) (rs0 arg) -> rs0 arg = Vint n","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"rewrite H.\nintro IJ; inv IJ; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : Val.inject j (Vint n) (rs0 arg) -> rs0 arg = Vint n.","conclusion":"Val.inject j (Vint n) (rs0 arg) -> rs0 arg = Vint n","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"intro IJ; inv IJ; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mjumptable arg tbl :: transl_code (make_env (function_bounds f)) b)\n       rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b'\n       (LTL.undef_regs destroyed_by_jumptable rs) m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (Mjumptable arg tbl :: transl_code (make_env (function_bounds f)) b)\n       rs0 m') E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr sp0 Ptrofs.zero) b'\n       (LTL.undef_regs destroyed_by_jumptable rs) m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n)","proofString":"econstructor; split.\napply plus_one; eapply exec_Mjumptable; eauto.\napply transl_find_label; eauto.\neconstructor.\neauto.\neauto.\neauto.\napply agree_regs_undef_regs; auto.\napply agree_locs_undef_locs.\nauto.\napply destroyed_by_jumptable_caller_save.\nauto.\neapply find_label_tail; eauto.\napply frame_undef_regs; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n) : agree_locs f (LTL.undef_regs destroyed_by_jumptable rs) (parent_locset s).","conclusion":"agree_locs f (LTL.undef_regs destroyed_by_jumptable rs) (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n)","proofString":"apply agree_locs_undef_locs.\nauto.\napply destroyed_by_jumptable_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n) : agree_locs f rs (parent_locset s).","conclusion":"agree_locs f rs (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n)","proofString":"auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n) : existsb is_callee_save destroyed_by_jumptable = false.","conclusion":"existsb is_callee_save destroyed_by_jumptable = false","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n)","proofString":"apply destroyed_by_jumptable_caller_save."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n) : is_tail b' (Linear.fn_code f).","conclusion":"is_tail b' (Linear.fn_code f)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (arg : mreg) (tbl : list Linear.label) (b : list Linear.instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : Linear.label) (b' : Linear.code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Linear.find_label lbl (Linear.fn_code f) = Some b') (sp0 : block) (WTS : wt_state\n  (Linear.State s f (Vptr sp0 Ptrofs.zero) (Ljumptable arg tbl :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m' : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Ljumptable arg tbl :: b) (Linear.fn_code f)) (SEP : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) (H2 : rs0 arg = Vint n)","proofString":"eapply find_label_tail; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (b : list Linear.instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state (Linear.State s f (Vptr stk Ptrofs.zero) (Lreturn :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lreturn :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (restore_callee_save (make_env (function_bounds f))\n          (Mreturn :: transl_code (make_env (function_bounds f)) b)) rs0 m'0)\n    E0 s2' /\\\n  match_states (Linear.Returnstate s (return_regs (parent_locset s) rs) m')\n    s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (restore_callee_save (make_env (function_bounds f))\n          (Mreturn :: transl_code (make_env (function_bounds f)) b)) rs0 m'0)\n    E0 s2' /\\\n  match_states (Linear.Returnstate s (return_regs (parent_locset s) rs) m')\n    s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (b : list Linear.instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state (Linear.State s f (Vptr stk Ptrofs.zero) (Lreturn :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lreturn :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (BOUND : True)","proofString":"rewrite (sep_swap (stack_contents j s cs')) in SEP.\nexploit function_epilogue_correct; eauto.\nintros (rs' & m1' & A & B & C & D & E & F & G).\neconstructor; split.\neapply plus_right.\neexact D.\neconstructor; eauto.\ntraceEq.\neconstructor; eauto.\nrewrite sep_swap; exact G."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (b : list Linear.instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state (Linear.State s f (Vptr stk Ptrofs.zero) (Lreturn :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lreturn :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   minjection j m ** stack_contents j s cs' ** globalenv_inject ge j) (BOUND : True) : exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (restore_callee_save (make_env (function_bounds f))\n          (Mreturn :: transl_code (make_env (function_bounds f)) b)) rs0 m'0)\n    E0 s2' /\\\n  match_states (Linear.Returnstate s (return_regs (parent_locset s) rs) m')\n    s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (State cs' fb (Vptr sp' Ptrofs.zero)\n       (restore_callee_save (make_env (function_bounds f))\n          (Mreturn :: transl_code (make_env (function_bounds f)) b)) rs0 m'0)\n    E0 s2' /\\\n  match_states (Linear.Returnstate s (return_regs (parent_locset s) rs) m')\n    s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (b : list Linear.instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state (Linear.State s f (Vptr stk Ptrofs.zero) (Lreturn :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lreturn :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   minjection j m ** stack_contents j s cs' ** globalenv_inject ge j) (BOUND : True)","proofString":"exploit function_epilogue_correct; eauto.\nintros (rs' & m1' & A & B & C & D & E & F & G).\neconstructor; split.\neapply plus_right.\neexact D.\neconstructor; eauto.\ntraceEq.\neconstructor; eauto.\nrewrite sep_swap; exact G."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (b : list Linear.instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state (Linear.State s f (Vptr stk Ptrofs.zero) (Lreturn :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lreturn :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   minjection j m ** stack_contents j s cs' ** globalenv_inject ge j) (BOUND : True) (rs' : regset) (m1' : mem) (A : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp cs')) (B : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) =\nSome (parent_ra cs')) (C : Mem.free m'0 sp' 0 (fn_stacksize tf) = Some m1') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (restore_callee_save (make_env (function_bounds f))\n        (Mreturn :: transl_code (make_env (function_bounds f)) b)) rs0 m'0)\n  E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (Mreturn :: transl_code (make_env (function_bounds f)) b) rs' m'0)) (E : agree_regs j (return_regs (parent_locset s) rs) rs') (F : agree_callee_save (return_regs (parent_locset s) rs) (parent_locset s)) (G : m1' |= minjection j m' ** stack_contents j s cs' ** globalenv_inject ge j) : m1' |= stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j.","conclusion":"m1' |= stack_contents j s cs' ** minjection j m' ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (stk : block) (b : list Linear.instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (Linear.fn_stacksize f) = Some m') (WTS : wt_state (Linear.State s f (Vptr stk Ptrofs.zero) (Lreturn :: b) rs m)) (cs' : list stackframe) (fb sp' : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : function) (STACKS : match_stacks j s cs' (Linear.fn_sig f)) (TRANSL : transf_function f = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tf)) (AGREGS : agree_regs j rs rs0) (AGLOCS : agree_locs f rs (parent_locset s)) (INJSP : j stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TAIL : is_tail (Lreturn :: b) (Linear.fn_code f)) (SEP : m'0\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs')\n     (parent_ra cs') **\n   minjection j m ** stack_contents j s cs' ** globalenv_inject ge j) (BOUND : True) (rs' : regset) (m1' : mem) (A : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tf) =\nSome (parent_sp cs')) (B : load_stack m'0 (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tf) =\nSome (parent_ra cs')) (C : Mem.free m'0 sp' 0 (fn_stacksize tf) = Some m1') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (restore_callee_save (make_env (function_bounds f))\n        (Mreturn :: transl_code (make_env (function_bounds f)) b)) rs0 m'0)\n  E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (Mreturn :: transl_code (make_env (function_bounds f)) b) rs' m'0)) (E : agree_regs j (return_regs (parent_locset s) rs) rs') (F : agree_callee_save (return_regs (parent_locset s) rs) (parent_locset s)) (G : m1' |= minjection j m' ** stack_contents j s cs' ** globalenv_inject ge j)","proofString":"rewrite sep_swap; exact G."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (TRANSL : transf_fundef (Internal f) = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : exists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (TRANSL : transf_fundef (Internal f) = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"revert TRANSL.\nunfold transf_fundef, transf_partial_fundef.\ndestruct (transf_function f) as [tfn|] eqn:TRANSL; simpl; try congruence.\nintros EQ; inversion EQ; clear EQ; subst tf.\nrewrite sep_comm, sep_assoc in SEP.\nexploit wt_callstate_agree; eauto.\nintros [AGCS AGARGS].\nexploit function_prologue_correct; eauto.\nred; intros; eapply wt_callstate_wt_regs; eauto.\neapply match_stacks_type_sp; eauto.\neapply match_stacks_type_retaddr; eauto.\nclear SEP;  intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & A & B & C & D & E & F & SEP & J & K).\nrewrite (sep_comm (globalenv_inject ge j')) in SEP.\nrewrite (sep_swap (minjection j' m')) in SEP.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_code.\nunfold transl_body.\neexact D.\ntraceEq.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\nrewrite sep_swap in SEP.\nrewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : transf_fundef (Internal f) = OK tf ->\nexists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'.","conclusion":"transf_fundef (Internal f) = OK tf ->\nexists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"unfold transf_fundef, transf_partial_fundef.\ndestruct (transf_function f) as [tfn|] eqn:TRANSL; simpl; try congruence.\nintros EQ; inversion EQ; clear EQ; subst tf.\nrewrite sep_comm, sep_assoc in SEP.\nexploit wt_callstate_agree; eauto.\nintros [AGCS AGARGS].\nexploit function_prologue_correct; eauto.\nred; intros; eapply wt_callstate_wt_regs; eauto.\neapply match_stacks_type_sp; eauto.\neapply match_stacks_type_retaddr; eauto.\nclear SEP;  intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & A & B & C & D & E & F & SEP & J & K).\nrewrite (sep_comm (globalenv_inject ge j')) in SEP.\nrewrite (sep_swap (minjection j' m')) in SEP.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_code.\nunfold transl_body.\neexact D.\ntraceEq.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\nrewrite sep_swap in SEP.\nrewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : bind (transf_function f) (fun f' : function => OK (Internal f')) = OK tf ->\nexists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'.","conclusion":"bind (transf_function f) (fun f' : function => OK (Internal f')) = OK tf ->\nexists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"destruct (transf_function f) as [tfn|] eqn:TRANSL; simpl; try congruence.\nintros EQ; inversion EQ; clear EQ; subst tf.\nrewrite sep_comm, sep_assoc in SEP.\nexploit wt_callstate_agree; eauto.\nintros [AGCS AGARGS].\nexploit function_prologue_correct; eauto.\nred; intros; eapply wt_callstate_wt_regs; eauto.\neapply match_stacks_type_sp; eauto.\neapply match_stacks_type_retaddr; eauto.\nclear SEP;  intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & A & B & C & D & E & F & SEP & J & K).\nrewrite (sep_comm (globalenv_inject ge j')) in SEP.\nrewrite (sep_swap (minjection j' m')) in SEP.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_code.\nunfold transl_body.\neexact D.\ntraceEq.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\nrewrite sep_swap in SEP.\nrewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (tfn : function) (TRANSL : transf_function f = OK tfn) : OK (Internal tfn) = OK tf ->\nexists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'.","conclusion":"OK (Internal tfn) = OK tf ->\nexists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (tfn : function) (TRANSL : transf_function f = OK tfn)","proofString":"intros EQ; inversion EQ; clear EQ; subst tf.\nrewrite sep_comm, sep_assoc in SEP.\nexploit wt_callstate_agree; eauto.\nintros [AGCS AGARGS].\nexploit function_prologue_correct; eauto.\nred; intros; eapply wt_callstate_wt_regs; eauto.\neapply match_stacks_type_sp; eauto.\neapply match_stacks_type_retaddr; eauto.\nclear SEP;  intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & A & B & C & D & E & F & SEP & J & K).\nrewrite (sep_comm (globalenv_inject ge j')) in SEP.\nrewrite (sep_swap (minjection j' m')) in SEP.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_code.\nunfold transl_body.\neexact D.\ntraceEq.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\nrewrite sep_swap in SEP.\nrewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (TRANSL : transf_function f = OK tfn) : exists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) (TRANSL : transf_function f = OK tfn)","proofString":"rewrite sep_comm, sep_assoc in SEP.\nexploit wt_callstate_agree; eauto.\nintros [AGCS AGARGS].\nexploit function_prologue_correct; eauto.\nred; intros; eapply wt_callstate_wt_regs; eauto.\neapply match_stacks_type_sp; eauto.\neapply match_stacks_type_retaddr; eauto.\nclear SEP;  intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & A & B & C & D & E & F & SEP & J & K).\nrewrite (sep_comm (globalenv_inject ge j')) in SEP.\nrewrite (sep_swap (minjection j' m')) in SEP.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_code.\nunfold transl_body.\neexact D.\ntraceEq.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\nrewrite sep_swap in SEP.\nrewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= minjection j m ** globalenv_inject ge j ** stack_contents j s cs') (TRANSL : transf_function f = OK tfn) : exists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= minjection j m ** globalenv_inject ge j ** stack_contents j s cs') (TRANSL : transf_function f = OK tfn)","proofString":"exploit wt_callstate_agree; eauto.\nintros [AGCS AGARGS].\nexploit function_prologue_correct; eauto.\nred; intros; eapply wt_callstate_wt_regs; eauto.\neapply match_stacks_type_sp; eauto.\neapply match_stacks_type_retaddr; eauto.\nclear SEP;  intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & A & B & C & D & E & F & SEP & J & K).\nrewrite (sep_comm (globalenv_inject ge j')) in SEP.\nrewrite (sep_swap (minjection j' m')) in SEP.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_code.\nunfold transl_body.\neexact D.\ntraceEq.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\nrewrite sep_swap in SEP.\nrewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= minjection j m ** globalenv_inject ge j ** stack_contents j s cs') (TRANSL : transf_function f = OK tfn) : agree_callee_save rs (parent_locset s) /\\\nagree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s) ->\nexists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'.","conclusion":"agree_callee_save rs (parent_locset s) /\\\nagree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s) ->\nexists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= minjection j m ** globalenv_inject ge j ** stack_contents j s cs') (TRANSL : transf_function f = OK tfn)","proofString":"intros [AGCS AGARGS].\nexploit function_prologue_correct; eauto.\nred; intros; eapply wt_callstate_wt_regs; eauto.\neapply match_stacks_type_sp; eauto.\neapply match_stacks_type_retaddr; eauto.\nclear SEP;  intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & A & B & C & D & E & F & SEP & J & K).\nrewrite (sep_comm (globalenv_inject ge j')) in SEP.\nrewrite (sep_swap (minjection j' m')) in SEP.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_code.\nunfold transl_body.\neexact D.\ntraceEq.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\nrewrite sep_swap in SEP.\nrewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= minjection j m ** globalenv_inject ge j ** stack_contents j s cs') (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) : exists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge (Callstate cs' fb rs0 m'0) E0 s2' /\\\n  match_states\n    (Linear.State s f (Vptr stk Ptrofs.zero) (Linear.fn_code f)\n       (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) m') s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= minjection j m ** globalenv_inject ge j ** stack_contents j s cs') (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s))","proofString":"exploit function_prologue_correct; eauto.\nred; intros; eapply wt_callstate_wt_regs; eauto.\neapply match_stacks_type_sp; eauto.\neapply match_stacks_type_retaddr; eauto.\nclear SEP;  intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & A & B & C & D & E & F & SEP & J & K).\nrewrite (sep_comm (globalenv_inject ge j')) in SEP.\nrewrite (sep_swap (minjection j' m')) in SEP.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\nrewrite (unfold_transf_function _ _ TRANSL).\nunfold fn_code.\nunfold transl_body.\neexact D.\ntraceEq.\neapply match_states_intro with (j := j'); eauto with coqlib.\neapply match_stacks_change_meminj; eauto.\nrewrite sep_swap in SEP.\nrewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= minjection j m ** globalenv_inject ge j ** stack_contents j s cs') (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) : forall r : mreg, Val.has_type (rs (R r)) (mreg_type r).","conclusion":"forall r : mreg, Val.has_type (rs (R r)) (mreg_type r)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (SEP : m'0 |= minjection j m ** globalenv_inject ge j ** stack_contents j s cs') (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s))","proofString":"red; intros; eapply wt_callstate_wt_regs; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) (j' : meminj) (rs' : regset) (m2' : Mem.mem') (sp' : block) (m3' m4' m5' : mem) (A : Mem.alloc m'0 0 (fn_stacksize tfn) = (m2', sp')) (B : store_stack m2' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tfn) (parent_sp cs') =\nSome m3') (C : store_stack m3' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tfn)\n  (parent_ra cs') = Some m4') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (save_callee_save (make_env (function_bounds f))\n        (transl_code (make_env (function_bounds f)) (Linear.fn_code f)))\n     (undef_regs destroyed_at_function_entry rs0) m4') E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) rs' m5')) (E : agree_regs j' (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) rs') (F : agree_locs f (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n  (parent_locset s)) (SEP : m5'\n|= frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (J : j' stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (K : inject_incr j j') : match_stacks j' s cs' (Linear.fn_sig f).","conclusion":"match_stacks j' s cs' (Linear.fn_sig f)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) (j' : meminj) (rs' : regset) (m2' : Mem.mem') (sp' : block) (m3' m4' m5' : mem) (A : Mem.alloc m'0 0 (fn_stacksize tfn) = (m2', sp')) (B : store_stack m2' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tfn) (parent_sp cs') =\nSome m3') (C : store_stack m3' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tfn)\n  (parent_ra cs') = Some m4') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (save_callee_save (make_env (function_bounds f))\n        (transl_code (make_env (function_bounds f)) (Linear.fn_code f)))\n     (undef_regs destroyed_at_function_entry rs0) m4') E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) rs' m5')) (E : agree_regs j' (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) rs') (F : agree_locs f (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n  (parent_locset s)) (SEP : m5'\n|= frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (J : j' stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (K : inject_incr j j')","proofString":"eapply match_stacks_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) (j' : meminj) (rs' : regset) (m2' : Mem.mem') (sp' : block) (m3' m4' m5' : mem) (A : Mem.alloc m'0 0 (fn_stacksize tfn) = (m2', sp')) (B : store_stack m2' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tfn) (parent_sp cs') =\nSome m3') (C : store_stack m3' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tfn)\n  (parent_ra cs') = Some m4') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (save_callee_save (make_env (function_bounds f))\n        (transl_code (make_env (function_bounds f)) (Linear.fn_code f)))\n     (undef_regs destroyed_at_function_entry rs0) m4') E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) rs' m5')) (E : agree_regs j' (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) rs') (F : agree_locs f (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n  (parent_locset s)) (SEP : m5'\n|= frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (J : j' stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (K : inject_incr j j') : m5'\n|= frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'.","conclusion":"m5'\n|= frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) (j' : meminj) (rs' : regset) (m2' : Mem.mem') (sp' : block) (m3' m4' m5' : mem) (A : Mem.alloc m'0 0 (fn_stacksize tfn) = (m2', sp')) (B : store_stack m2' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tfn) (parent_sp cs') =\nSome m3') (C : store_stack m3' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tfn)\n  (parent_ra cs') = Some m4') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (save_callee_save (make_env (function_bounds f))\n        (transl_code (make_env (function_bounds f)) (Linear.fn_code f)))\n     (undef_regs destroyed_at_function_entry rs0) m4') E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) rs' m5')) (E : agree_regs j' (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) rs') (F : agree_locs f (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n  (parent_locset s)) (SEP : m5'\n|= frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j s cs' ** minjection j' m' ** globalenv_inject ge j') (J : j' stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (K : inject_incr j j')","proofString":"rewrite sep_swap in SEP.\nrewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) (j' : meminj) (rs' : regset) (m2' : Mem.mem') (sp' : block) (m3' m4' m5' : mem) (A : Mem.alloc m'0 0 (fn_stacksize tfn) = (m2', sp')) (B : store_stack m2' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tfn) (parent_sp cs') =\nSome m3') (C : store_stack m3' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tfn)\n  (parent_ra cs') = Some m4') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (save_callee_save (make_env (function_bounds f))\n        (transl_code (make_env (function_bounds f)) (Linear.fn_code f)))\n     (undef_regs destroyed_at_function_entry rs0) m4') E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) rs' m5')) (E : agree_regs j' (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) rs') (F : agree_locs f (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n  (parent_locset s)) (SEP : m5'\n|= stack_contents j s cs' **\n   frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   minjection j' m' ** globalenv_inject ge j') (J : j' stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (K : inject_incr j j') : m5'\n|= frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'.","conclusion":"m5'\n|= frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   stack_contents j' s cs' ** minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) (j' : meminj) (rs' : regset) (m2' : Mem.mem') (sp' : block) (m3' m4' m5' : mem) (A : Mem.alloc m'0 0 (fn_stacksize tfn) = (m2', sp')) (B : store_stack m2' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tfn) (parent_sp cs') =\nSome m3') (C : store_stack m3' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tfn)\n  (parent_ra cs') = Some m4') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (save_callee_save (make_env (function_bounds f))\n        (transl_code (make_env (function_bounds f)) (Linear.fn_code f)))\n     (undef_regs destroyed_at_function_entry rs0) m4') E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) rs' m5')) (E : agree_regs j' (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) rs') (F : agree_locs f (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n  (parent_locset s)) (SEP : m5'\n|= stack_contents j s cs' **\n   frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   minjection j' m' ** globalenv_inject ge j') (J : j' stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (K : inject_incr j j')","proofString":"rewrite sep_swap.\neapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) (j' : meminj) (rs' : regset) (m2' : Mem.mem') (sp' : block) (m3' m4' m5' : mem) (A : Mem.alloc m'0 0 (fn_stacksize tfn) = (m2', sp')) (B : store_stack m2' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tfn) (parent_sp cs') =\nSome m3') (C : store_stack m3' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tfn)\n  (parent_ra cs') = Some m4') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (save_callee_save (make_env (function_bounds f))\n        (transl_code (make_env (function_bounds f)) (Linear.fn_code f)))\n     (undef_regs destroyed_at_function_entry rs0) m4') E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) rs' m5')) (E : agree_regs j' (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) rs') (F : agree_locs f (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n  (parent_locset s)) (SEP : m5'\n|= stack_contents j s cs' **\n   frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   minjection j' m' ** globalenv_inject ge j') (J : j' stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (K : inject_incr j j') : m5'\n|= stack_contents j' s cs' **\n   frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   minjection j' m' ** globalenv_inject ge j'.","conclusion":"m5'\n|= stack_contents j' s cs' **\n   frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   minjection j' m' ** globalenv_inject ge j'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (Linear.fn_stacksize f) = (m', stk)) (WTS : wt_state (Linear.Callstate s (Internal f) rs m)) (cs' : list stackframe) (fb : block) (rs0 : regset) (m'0 : mem) (j : meminj) (STACKS : match_stacks j s cs' (Linear.funsig (Internal f))) (tfn : function) (FIND : Genv.find_funct_ptr tge fb = Some (Internal tfn)) (AGREGS : agree_regs j rs rs0) (TRANSL : transf_function f = OK tfn) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (Linear.funsig (Internal f)) rs (parent_locset s)) (j' : meminj) (rs' : regset) (m2' : Mem.mem') (sp' : block) (m3' m4' m5' : mem) (A : Mem.alloc m'0 0 (fn_stacksize tfn) = (m2', sp')) (B : store_stack m2' (Vptr sp' Ptrofs.zero) Tptr (fn_link_ofs tfn) (parent_sp cs') =\nSome m3') (C : store_stack m3' (Vptr sp' Ptrofs.zero) Tptr (fn_retaddr_ofs tfn)\n  (parent_ra cs') = Some m4') (D : star step tge\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (save_callee_save (make_env (function_bounds f))\n        (transl_code (make_env (function_bounds f)) (Linear.fn_code f)))\n     (undef_regs destroyed_at_function_entry rs0) m4') E0\n  (State cs' fb (Vptr sp' Ptrofs.zero)\n     (transl_code (make_env (function_bounds f)) (Linear.fn_code f)) rs' m5')) (E : agree_regs j' (LTL.undef_regs destroyed_at_function_entry (call_regs rs)) rs') (F : agree_locs f (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n  (parent_locset s)) (SEP : m5'\n|= stack_contents j s cs' **\n   frame_contents f j' sp'\n     (LTL.undef_regs destroyed_at_function_entry (call_regs rs))\n     (parent_locset s) (parent_sp cs') (parent_ra cs') **\n   minjection j' m' ** globalenv_inject ge j') (J : j' stk = Some (sp', fe_stack_data (make_env (function_bounds f)))) (K : inject_incr j j')","proofString":"eapply stack_contents_change_meminj; eauto."},{"statement":"(s : list Linear.stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (fun p : rpair loc => Locmap.getpair p rs1) ## (loc_arguments (ef_sig ef))\n  m t res m') (WTS : wt_state (Linear.Callstate s (External ef) rs1 m)) (cs' : list stackframe) (fb : block) (rs : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (External ef))) (TRANSL : transf_fundef (External ef) = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs1 rs) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : exists s2' : state,\n  plus step tge (Callstate cs' fb rs m'0) t s2' /\\\n  match_states\n    (Linear.Returnstate s\n       (Locmap.setpair (loc_result (ef_sig ef)) res\n          (LTL.undef_caller_save_regs rs1)) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge (Callstate cs' fb rs m'0) t s2' /\\\n  match_states\n    (Linear.Returnstate s\n       (Locmap.setpair (loc_result (ef_sig ef)) res\n          (LTL.undef_caller_save_regs rs1)) m') s2'","hypotheses":"(s : list Linear.stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (fun p : rpair loc => Locmap.getpair p rs1) ## (loc_arguments (ef_sig ef))\n  m t res m') (WTS : wt_state (Linear.Callstate s (External ef) rs1 m)) (cs' : list stackframe) (fb : block) (rs : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (External ef))) (TRANSL : transf_fundef (External ef) = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs1 rs) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"simpl in TRANSL.\ninversion TRANSL; subst tf.\nexploit wt_callstate_agree; eauto.\nintros [AGCS AGARGS].\nexploit transl_external_arguments; eauto.\napply sep_proj1 in SEP; eauto.\nintros [vl [ARGS VINJ]].\nrewrite sep_comm, sep_assoc in SEP.\nexploit external_call_parallel_rule; eauto.\nintros (j' & res' & m1' & A & B & C & D & E).\neconstructor; split.\napply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neapply match_states_return with (j := j').\neapply match_stacks_change_meminj; eauto.\napply agree_regs_set_pair.\napply agree_regs_undef_caller_save_regs.\napply agree_regs_inject_incr with j; auto.\nauto.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_comm, sep_assoc; auto."},{"statement":"(s : list Linear.stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (fun p : rpair loc => Locmap.getpair p rs1) ## (loc_arguments (ef_sig ef))\n  m t res m') (WTS : wt_state (Linear.Callstate s (External ef) rs1 m)) (cs' : list stackframe) (fb : block) (rs : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (External ef))) (TRANSL : OK (External ef) = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs1 rs) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j) : exists s2' : state,\n  plus step tge (Callstate cs' fb rs m'0) t s2' /\\\n  match_states\n    (Linear.Returnstate s\n       (Locmap.setpair (loc_result (ef_sig ef)) res\n          (LTL.undef_caller_save_regs rs1)) m') s2'.","conclusion":"exists s2' : state,\n  plus step tge (Callstate cs' fb rs m'0) t s2' /\\\n  match_states\n    (Linear.Returnstate s\n       (Locmap.setpair (loc_result (ef_sig ef)) res\n          (LTL.undef_caller_save_regs rs1)) m') s2'","hypotheses":"(s : list Linear.stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (fun p : rpair loc => Locmap.getpair p rs1) ## (loc_arguments (ef_sig ef))\n  m t res m') (WTS : wt_state (Linear.Callstate s (External ef) rs1 m)) (cs' : list stackframe) (fb : block) (rs : regset) (m'0 : mem) (j : meminj) (tf : fundef) (STACKS : match_stacks j s cs' (Linear.funsig (External ef))) (TRANSL : OK (External ef) = OK tf) (FIND : Genv.find_funct_ptr tge fb = Some tf) (AGREGS : agree_regs j rs1 rs) (SEP : m'0 |= stack_contents j s cs' ** minjection j m ** globalenv_inject ge j)","proofString":"inversion TRANSL; subst tf.\nexploit wt_callstate_agree; eauto.\nintros [AGCS AGARGS].\nexploit transl_external_arguments; eauto.\napply sep_proj1 in SEP; eauto.\nintros [vl [ARGS VINJ]].\nrewrite sep_comm, sep_assoc in SEP.\nexploit external_call_parallel_rule; eauto.\nintros (j' & res' & m1' & A & B & C & D & E).\neconstructor; split.\napply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neapply match_states_return with (j := j').\neapply match_stacks_change_meminj; eauto.\napply agree_regs_set_pair.\napply agree_regs_undef_caller_save_regs.\napply agree_regs_inject_incr with j; auto.\nauto.\napply stack_contents_change_meminj with j; auto.\nrewrite sep_comm, sep_assoc; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (sp : val) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (WTS : wt_state (Linear.Returnstate (Linear.Stackframe f sp rs0 c :: s) rs m)) (cs' : list stackframe) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (STACKS : match_stacks j (Linear.Stackframe f sp rs0 c :: s) cs' sg) (AGREGS : agree_regs j rs rs1) (SEP : m'\n|= stack_contents j (Linear.Stackframe f sp rs0 c :: s) cs' **\n   minjection j m ** globalenv_inject ge j) : exists s2' : state,\n  plus step tge (Returnstate cs' rs1 m') E0 s2' /\\\n  match_states (Linear.State s f sp c rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge (Returnstate cs' rs1 m') E0 s2' /\\\n  match_states (Linear.State s f sp c rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (sp : val) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (WTS : wt_state (Linear.Returnstate (Linear.Stackframe f sp rs0 c :: s) rs m)) (cs' : list stackframe) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (STACKS : match_stacks j (Linear.Stackframe f sp rs0 c :: s) cs' sg) (AGREGS : agree_regs j rs rs1) (SEP : m'\n|= stack_contents j (Linear.Stackframe f sp rs0 c :: s) cs' **\n   minjection j m ** globalenv_inject ge j)","proofString":"inv STACKS.\nexploit wt_returnstate_agree; eauto.\nintros [AGCS OUTU].\nsimpl in AGCS.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neconstructor; split.\napply plus_one.\napply exec_return.\neconstructor; eauto.\napply agree_locs_return with rs0; auto.\napply frame_contents_exten with rs0 (parent_locset s); auto.\nintros; apply Val.lessdef_same; apply AGCS; red; congruence.\nintros; rewrite (OUTU ty ofs); auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n        (transl_code (make_env (function_bounds f)) c) :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) : exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n        (transl_code (make_env (function_bounds f)) c) :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f))","proofString":"exploit wt_returnstate_agree; eauto.\nintros [AGCS OUTU].\nsimpl in AGCS.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neconstructor; split.\napply plus_one.\napply exec_return.\neconstructor; eauto.\napply agree_locs_return with rs0; auto.\napply frame_contents_exten with rs0 (parent_locset s); auto.\nintros; apply Val.lessdef_same; apply AGCS; red; congruence.\nintros; rewrite (OUTU ty ofs); auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n        (transl_code (make_env (function_bounds f)) c) :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) : agree_callee_save rs\n  (parent_locset (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)) /\\\noutgoing_undef rs ->\nexists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'.","conclusion":"agree_callee_save rs\n  (parent_locset (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)) /\\\noutgoing_undef rs ->\nexists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n        (transl_code (make_env (function_bounds f)) c) :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f))","proofString":"intros [AGCS OUTU].\nsimpl in AGCS.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neconstructor; split.\napply plus_one.\napply exec_return.\neconstructor; eauto.\napply agree_locs_return with rs0; auto.\napply frame_contents_exten with rs0 (parent_locset s); auto.\nintros; apply Val.lessdef_same; apply AGCS; red; congruence.\nintros; rewrite (OUTU ty ofs); auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n        (transl_code (make_env (function_bounds f)) c) :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs\n  (parent_locset (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s))) (OUTU : outgoing_undef rs) : exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n        (transl_code (make_env (function_bounds f)) c) :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs\n  (parent_locset (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s))) (OUTU : outgoing_undef rs)","proofString":"simpl in AGCS.\nsimpl in SEP.\nrewrite sep_assoc in SEP.\neconstructor; split.\napply plus_one.\napply exec_return.\neconstructor; eauto.\napply agree_locs_return with rs0; auto.\napply frame_contents_exten with rs0 (parent_locset s); auto.\nintros; apply Val.lessdef_same; apply AGCS; red; congruence.\nintros; rewrite (OUTU ty ofs); auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n        (transl_code (make_env (function_bounds f)) c) :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs) : exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= stack_contents j (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n        (transl_code (make_env (function_bounds f)) c) :: cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs)","proofString":"simpl in SEP.\nrewrite sep_assoc in SEP.\neconstructor; split.\napply plus_one.\napply exec_return.\neconstructor; eauto.\napply agree_locs_return with rs0; auto.\napply frame_contents_exten with rs0 (parent_locset s); auto.\nintros; apply Val.lessdef_same; apply AGCS; red; congruence.\nintros; rewrite (OUTU ty ofs); auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= (frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n      (parent_ra cs'0) ** stack_contents j s cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs) : exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= (frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n      (parent_ra cs'0) ** stack_contents j s cs'0) **\n   minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs)","proofString":"rewrite sep_assoc in SEP.\neconstructor; split.\napply plus_one.\napply exec_return.\neconstructor; eauto.\napply agree_locs_return with rs0; auto.\napply frame_contents_exten with rs0 (parent_locset s); auto.\nintros; apply Val.lessdef_same; apply AGCS; red; congruence.\nintros; rewrite (OUTU ty ofs); auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs) : exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'.","conclusion":"exists s2' : state,\n  plus step tge\n    (Returnstate\n       (Stackframe fb (Vptr sp' Ptrofs.zero) ra\n          (transl_code (make_env (function_bounds f)) c) :: cs'0) rs1 m') E0\n    s2' /\\ match_states (Linear.State s f (Vptr sp0 Ptrofs.zero) c rs m) s2'","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs)","proofString":"econstructor; split.\napply plus_one.\napply exec_return.\neconstructor; eauto.\napply agree_locs_return with rs0; auto.\napply frame_contents_exten with rs0 (parent_locset s); auto.\nintros; apply Val.lessdef_same; apply AGCS; red; congruence.\nintros; rewrite (OUTU ty ofs); auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs) : agree_locs f rs (parent_locset s).","conclusion":"agree_locs f rs (parent_locset s)","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs)","proofString":"apply agree_locs_return with rs0; auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs) : m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j.","conclusion":"m'\n|= frame_contents f j sp' rs (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs)","proofString":"apply frame_contents_exten with rs0 (parent_locset s); auto.\nintros; apply Val.lessdef_same; apply AGCS; red; congruence.\nintros; rewrite (OUTU ty ofs); auto."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs) : forall (ofs : Z) (ty : typ),\nVal.lessdef (rs (S Local ofs ty)) (rs0 (S Local ofs ty)).","conclusion":"forall (ofs : Z) (ty : typ),\nVal.lessdef (rs (S Local ofs ty)) (rs0 (S Local ofs ty))","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs)","proofString":"intros; apply Val.lessdef_same; apply AGCS; red; congruence."},{"statement":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs) : forall (ofs : Z) (ty : typ),\nVal.lessdef (rs (S Outgoing ofs ty)) (rs0 (S Outgoing ofs ty)).","conclusion":"forall (ofs : Z) (ty : typ),\nVal.lessdef (rs (S Outgoing ofs ty)) (rs0 (S Outgoing ofs ty))","hypotheses":"(s : list Linear.stackframe) (f : Linear.function) (rs0 : locset) (c : Linear.code) (rs : locset) (m : mem) (sp0 : block) (WTS : wt_state\n  (Linear.Returnstate (Linear.Stackframe f (Vptr sp0 Ptrofs.zero) rs0 c :: s)\n     rs m)) (rs1 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs1) (fb sp' : block) (ra : val) (cs'0 : list stackframe) (SEP : m'\n|= frame_contents f j sp' rs0 (parent_locset s) (parent_sp cs'0)\n     (parent_ra cs'0) **\n   stack_contents j s cs'0 ** minjection j m ** globalenv_inject ge j) (trf : function) (TAIL : is_tail c (Linear.fn_code f)) (FINDF : Genv.find_funct_ptr tge fb = Some (Internal trf)) (TRF : transf_function f = OK trf) (INJ : j sp0 = Some (sp', fe_stack_data (make_env (function_bounds f)))) (TY_RA : Val.has_type ra Tptr) (AGL : agree_locs f rs0 (parent_locset s)) (ARGS : forall (ofs : Z) (ty : typ),\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->\nslot_within_bounds (function_bounds f) Outgoing ofs ty) (STK : match_stacks j s cs'0 (Linear.fn_sig f)) (AGCS : agree_callee_save rs rs0) (OUTU : outgoing_undef rs)","proofString":"intros; rewrite (OUTU ty ofs); auto."},{"statement":"(st1 : Linear.state) (H : Linear.initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","conclusion":"exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2","hypotheses":"(st1 : Linear.state) (H : Linear.initial_state prog st1)","proofString":"inv H.\nexploit function_ptr_translated; eauto.\nintros [tf [FIND TR]].\neconstructor; split.\neconstructor.\neapply (Genv.init_mem_transf_partial TRANSF); eauto.\nrewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\neauto.\nset (j := Mem.flat_inj (Mem.nextblock m0)).\neapply match_states_call with (j := j); eauto.\nconstructor.\nred; intros.\nrewrite H3, loc_arguments_main in H.\ncontradiction.\nred; simpl; auto.\nsimpl.\nrewrite sep_pure.\nsplit; auto.\nsplit;[|split].\neapply Genv.initmem_inject; eauto.\nsimpl.\nexists (Mem.nextblock m0); split.\napply Ple_refl.\nunfold j, Mem.flat_inj; constructor; intros.\napply pred_dec_true; auto.\ndestruct (plt b1 (Mem.nextblock m0)); congruence.\nchange (Mem.valid_block m0 b0).\neapply Genv.find_symbol_not_fresh; eauto.\nchange (Mem.valid_block m0 b0).\neapply Genv.find_funct_ptr_not_fresh; eauto.\nchange (Mem.valid_block m0 b0).\neapply Genv.find_var_info_not_fresh; eauto.\nred; simpl; tauto."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) : match_stacks j nil nil (Linear.funsig f).","conclusion":"match_stacks j nil nil (Linear.funsig f)","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj)","proofString":"constructor.\nred; intros.\nrewrite H3, loc_arguments_main in H.\ncontradiction."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) : tailcall_possible (Linear.funsig f).","conclusion":"tailcall_possible (Linear.funsig f)","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj)","proofString":"red; intros.\nrewrite H3, loc_arguments_main in H.\ncontradiction."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (l : loc) (H : In l (regs_of_rpairs (loc_arguments (Linear.funsig f)))) : match l with\n| R _ => True\n| S _ _ _ => False\nend.","conclusion":"match l with\n| R _ => True\n| S _ _ _ => False\nend","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (l : loc) (H : In l (regs_of_rpairs (loc_arguments (Linear.funsig f))))","proofString":"rewrite H3, loc_arguments_main in H.\ncontradiction."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (l : loc) (H : In l (regs_of_rpairs nil)) : match l with\n| R _ => True\n| S _ _ _ => False\nend.","conclusion":"match l with\n| R _ => True\n| S _ _ _ => False\nend","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (l : loc) (H : In l (regs_of_rpairs nil))","proofString":"contradiction."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) : agree_regs j (Locmap.init Vundef) (Regmap.init Vundef).","conclusion":"agree_regs j (Locmap.init Vundef) (Regmap.init Vundef)","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj)","proofString":"red; simpl; auto."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) : Ple (Mem.nextblock m0) (Mem.nextblock m0).","conclusion":"Ple (Mem.nextblock m0) (Mem.nextblock m0)","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj)","proofString":"apply Ple_refl."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : positive) (H : Plt b0 (Mem.nextblock m0)) : (if plt b0 (Mem.nextblock m0) then Some (b0, 0) else None) = Some (b0, 0).","conclusion":"(if plt b0 (Mem.nextblock m0) then Some (b0, 0) else None) = Some (b0, 0)","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : positive) (H : Plt b0 (Mem.nextblock m0))","proofString":"apply pred_dec_true; auto."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b1 b2 : block) (delta : Z) (H : (if plt b1 (Mem.nextblock m0) then Some (b1, 0) else None) = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0)) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b1 b2 : block) (delta : Z) (H : (if plt b1 (Mem.nextblock m0) then Some (b1, 0) else None) = Some (b2, delta)) (H4 : Plt b2 (Mem.nextblock m0))","proofString":"destruct (plt b1 (Mem.nextblock m0)); congruence."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (id : ident) (b0 : block) (H : Genv.find_symbol ge id = Some b0) : Plt b0 (Mem.nextblock m0).","conclusion":"Plt b0 (Mem.nextblock m0)","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (id : ident) (b0 : block) (H : Genv.find_symbol ge id = Some b0)","proofString":"change (Mem.valid_block m0 b0).\neapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (id : ident) (b0 : block) (H : Genv.find_symbol ge id = Some b0) : Mem.valid_block m0 b0.","conclusion":"Mem.valid_block m0 b0","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (id : ident) (b0 : block) (H : Genv.find_symbol ge id = Some b0)","proofString":"eapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : block) (fd : Linear.fundef) (H : Genv.find_funct_ptr ge b0 = Some fd) : Plt b0 (Mem.nextblock m0).","conclusion":"Plt b0 (Mem.nextblock m0)","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : block) (fd : Linear.fundef) (H : Genv.find_funct_ptr ge b0 = Some fd)","proofString":"change (Mem.valid_block m0 b0).\neapply Genv.find_funct_ptr_not_fresh; eauto."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : block) (fd : Linear.fundef) (H : Genv.find_funct_ptr ge b0 = Some fd) : Mem.valid_block m0 b0.","conclusion":"Mem.valid_block m0 b0","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : block) (fd : Linear.fundef) (H : Genv.find_funct_ptr ge b0 = Some fd)","proofString":"eapply Genv.find_funct_ptr_not_fresh; eauto."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : block) (gv : globvar unit) (H : Genv.find_var_info ge b0 = Some gv) : Plt b0 (Mem.nextblock m0).","conclusion":"Plt b0 (Mem.nextblock m0)","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : block) (gv : globvar unit) (H : Genv.find_var_info ge b0 = Some gv)","proofString":"change (Mem.valid_block m0 b0).\neapply Genv.find_var_info_not_fresh; eauto."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : block) (gv : globvar unit) (H : Genv.find_var_info ge b0 = Some gv) : Mem.valid_block m0 b0.","conclusion":"Mem.valid_block m0 b0","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) (b0 : block) (gv : globvar unit) (H : Genv.find_var_info ge b0 = Some gv)","proofString":"eapply Genv.find_var_info_not_fresh; eauto."},{"statement":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj) : disjoint_footprint (minjection j m0) (globalenv_inject ge j).","conclusion":"disjoint_footprint (minjection j m0) (globalenv_inject ge j)","hypotheses":"(b : block) (f : Linear.fundef) (m0 : mem) (ge0 : Genv.t Linear.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Linear.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (j : meminj)","proofString":"red; simpl; tauto."},{"statement":"(st1 : Linear.state) (st2 : state) (r : int) (H : match_states st1 st2) (H0 : Linear.final_state st1 r) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st1 : Linear.state) (st2 : state) (r : int) (H : match_states st1 st2) (H0 : Linear.final_state st1 r)","proofString":"inv H0.\ninv H.\ninv STACKS.\nassert (R: exists r, loc_result signature_main = One r).\ndestruct (loc_result signature_main) as [r1 | r1 r2] eqn:LR.\nexists r1; auto.\ngeneralize (loc_result_type signature_main).\nrewrite LR.\ndiscriminate.\ndestruct R as [rres EQ].\nrewrite EQ in H1.\nsimpl in H1.\ngeneralize (AGREGS rres).\nrewrite H1.\nintros A; inv A.\neconstructor; eauto."},{"statement":"(st2 : state) (r : int) (rs : Locmap.t) (m : mem) (H : match_states (Linear.Returnstate nil rs m) st2) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st2 : state) (r : int) (rs : Locmap.t) (m : mem) (H : match_states (Linear.Returnstate nil rs m) st2) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r)","proofString":"inv H.\ninv STACKS.\nassert (R: exists r, loc_result signature_main = One r).\ndestruct (loc_result signature_main) as [r1 | r1 r2] eqn:LR.\nexists r1; auto.\ngeneralize (loc_result_type signature_main).\nrewrite LR.\ndiscriminate.\ndestruct R as [rres EQ].\nrewrite EQ in H1.\nsimpl in H1.\ngeneralize (AGREGS rres).\nrewrite H1.\nintros A; inv A.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (cs' : list stackframe) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (STACKS : match_stacks j nil cs' sg) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil cs' ** minjection j m ** globalenv_inject ge j) : final_state (Returnstate cs' rs0 m') r.","conclusion":"final_state (Returnstate cs' rs0 m') r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (cs' : list stackframe) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (STACKS : match_stacks j nil cs' sg) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil cs' ** minjection j m ** globalenv_inject ge j)","proofString":"inv STACKS.\nassert (R: exists r, loc_result signature_main = One r).\ndestruct (loc_result signature_main) as [r1 | r1 r2] eqn:LR.\nexists r1; auto.\ngeneralize (loc_result_type signature_main).\nrewrite LR.\ndiscriminate.\ndestruct R as [rres EQ].\nrewrite EQ in H1.\nsimpl in H1.\ngeneralize (AGREGS rres).\nrewrite H1.\nintros A; inv A.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) : final_state (Returnstate nil rs0 m') r.","conclusion":"final_state (Returnstate nil rs0 m') r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg)","proofString":"assert (R: exists r, loc_result signature_main = One r).\ndestruct (loc_result signature_main) as [r1 | r1 r2] eqn:LR.\nexists r1; auto.\ngeneralize (loc_result_type signature_main).\nrewrite LR.\ndiscriminate.\ndestruct R as [rres EQ].\nrewrite EQ in H1.\nsimpl in H1.\ngeneralize (AGREGS rres).\nrewrite H1.\nintros A; inv A.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) : exists r0 : mreg, loc_result signature_main = One r0.","conclusion":"exists r0 : mreg, loc_result signature_main = One r0","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg)","proofString":"destruct (loc_result signature_main) as [r1 | r1 r2] eqn:LR.\nexists r1; auto.\ngeneralize (loc_result_type signature_main).\nrewrite LR.\ndiscriminate."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (r1 : mreg) (LR : loc_result signature_main = One r1) (H1 : Locmap.getpair (map_rpair R (One r1)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) : exists r0 : mreg, One r1 = One r0.","conclusion":"exists r0 : mreg, One r1 = One r0","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (r1 : mreg) (LR : loc_result signature_main = One r1) (H1 : Locmap.getpair (map_rpair R (One r1)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg)","proofString":"exists r1; auto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (r1 r2 : mreg) (LR : loc_result signature_main = Twolong r1 r2) (H1 : Locmap.getpair (map_rpair R (Twolong r1 r2)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) : exists r0 : mreg, Twolong r1 r2 = One r0.","conclusion":"exists r0 : mreg, Twolong r1 r2 = One r0","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (r1 r2 : mreg) (LR : loc_result signature_main = Twolong r1 r2) (H1 : Locmap.getpair (map_rpair R (Twolong r1 r2)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg)","proofString":"generalize (loc_result_type signature_main).\nrewrite LR.\ndiscriminate."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (r1 r2 : mreg) (LR : loc_result signature_main = Twolong r1 r2) (H1 : Locmap.getpair (map_rpair R (Twolong r1 r2)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) : subtype (proj_sig_res signature_main)\n  (typ_rpair mreg_type (loc_result signature_main)) = true ->\nexists r0 : mreg, Twolong r1 r2 = One r0.","conclusion":"subtype (proj_sig_res signature_main)\n  (typ_rpair mreg_type (loc_result signature_main)) = true ->\nexists r0 : mreg, Twolong r1 r2 = One r0","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (r1 r2 : mreg) (LR : loc_result signature_main = Twolong r1 r2) (H1 : Locmap.getpair (map_rpair R (Twolong r1 r2)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg)","proofString":"rewrite LR.\ndiscriminate."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (r1 r2 : mreg) (LR : loc_result signature_main = Twolong r1 r2) (H1 : Locmap.getpair (map_rpair R (Twolong r1 r2)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) : subtype (proj_sig_res signature_main) (typ_rpair mreg_type (Twolong r1 r2)) =\ntrue -> exists r0 : mreg, Twolong r1 r2 = One r0.","conclusion":"subtype (proj_sig_res signature_main) (typ_rpair mreg_type (Twolong r1 r2)) =\ntrue -> exists r0 : mreg, Twolong r1 r2 = One r0","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (r1 r2 : mreg) (LR : loc_result signature_main = Twolong r1 r2) (H1 : Locmap.getpair (map_rpair R (Twolong r1 r2)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg)","proofString":"discriminate."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair Locations.R (loc_result signature_main)) rs =\nVint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (R : exists r0 : mreg, loc_result signature_main = One r0) : final_state (Returnstate nil rs0 m') r.","conclusion":"final_state (Returnstate nil rs0 m') r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair Locations.R (loc_result signature_main)) rs =\nVint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (R : exists r0 : mreg, loc_result signature_main = One r0)","proofString":"destruct R as [rres EQ].\nrewrite EQ in H1.\nsimpl in H1.\ngeneralize (AGREGS rres).\nrewrite H1.\nintros A; inv A.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (rres : mreg) (EQ : loc_result signature_main = One rres) : final_state (Returnstate nil rs0 m') r.","conclusion":"final_state (Returnstate nil rs0 m') r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (rres : mreg) (EQ : loc_result signature_main = One rres)","proofString":"rewrite EQ in H1.\nsimpl in H1.\ngeneralize (AGREGS rres).\nrewrite H1.\nintros A; inv A.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : Locmap.getpair (map_rpair R (One rres)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres) : final_state (Returnstate nil rs0 m') r.","conclusion":"final_state (Returnstate nil rs0 m') r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : Locmap.getpair (map_rpair R (One rres)) rs = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres)","proofString":"simpl in H1.\ngeneralize (AGREGS rres).\nrewrite H1.\nintros A; inv A.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : rs (R rres) = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres) : final_state (Returnstate nil rs0 m') r.","conclusion":"final_state (Returnstate nil rs0 m') r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : rs (R rres) = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres)","proofString":"generalize (AGREGS rres).\nrewrite H1.\nintros A; inv A.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : rs (R rres) = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres) : Val.inject j (rs (R rres)) (rs0 rres) ->\nfinal_state (Returnstate nil rs0 m') r.","conclusion":"Val.inject j (rs (R rres)) (rs0 rres) ->\nfinal_state (Returnstate nil rs0 m') r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : rs (R rres) = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres)","proofString":"rewrite H1.\nintros A; inv A.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : rs (R rres) = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres) : Val.inject j (Vint r) (rs0 rres) -> final_state (Returnstate nil rs0 m') r.","conclusion":"Val.inject j (Vint r) (rs0 rres) -> final_state (Returnstate nil rs0 m') r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : rs (R rres) = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres)","proofString":"intros A; inv A.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : rs (R rres) = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres) (H3 : Vint r = rs0 rres) : final_state (Returnstate nil rs0 m') r.","conclusion":"final_state (Returnstate nil rs0 m') r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (rres : mreg) (H1 : rs (R rres) = Vint r) (rs0 : regset) (m' : mem) (j : meminj) (sg : signature) (AGREGS : agree_regs j rs rs0) (SEP : m' |= stack_contents j nil nil ** minjection j m ** globalenv_inject ge j) (H : tailcall_possible sg) (EQ : loc_result signature_main = One rres) (H3 : Vint r = rs0 rres)","proofString":"econstructor; eauto."},{"statement":"(i : ident) (fd : Linear.fundef) (H : In (i, Gfun fd) (prog_defs prog)) : wt_fundef fd.","conclusion":"wt_fundef fd","hypotheses":"(i : ident) (fd : Linear.fundef) (H : In (i, Gfun fd) (prog_defs prog))","proofString":"exploit list_forall2_in_left.\neexact (proj1 TRANSF).\neauto.\nintros ([i' g] & P & Q & R).\nsimpl in *.\ninv R.\ndestruct fd; simpl in *.\nmonadInv H2.\nunfold transf_function in EQ.\ndestruct (wt_function f).\nauto.\ndiscriminate.\nauto."},{"statement":"(i : ident) (fd : Linear.fundef) (H : In (i, Gfun fd) (prog_defs prog)) (i' : ident) (g : globdef fundef unit) (P : In (i', g) (prog_defs tprog)) (Q : i = i') (R : match_globdef\n  (fun (_ : AST.program Linear.fundef unit) (f : Linear.fundef) (tf : fundef)\n   => transf_fundef f = OK tf) eq prog (Gfun fd) g) : wt_fundef fd.","conclusion":"wt_fundef fd","hypotheses":"(i : ident) (fd : Linear.fundef) (H : In (i, Gfun fd) (prog_defs prog)) (i' : ident) (g : globdef fundef unit) (P : In (i', g) (prog_defs tprog)) (Q : i = i') (R : match_globdef\n  (fun (_ : AST.program Linear.fundef unit) (f : Linear.fundef) (tf : fundef)\n   => transf_fundef f = OK tf) eq prog (Gfun fd) g)","proofString":"inv R.\ndestruct fd; simpl in *.\nmonadInv H2.\nunfold transf_function in EQ.\ndestruct (wt_function f).\nauto.\ndiscriminate.\nauto."},{"statement":"(fd : Linear.fundef) (i' : ident) (H : In (i', Gfun fd) (prog_defs prog)) (f2 : fundef) (P : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (H2 : transf_fundef fd = OK f2) : wt_fundef fd.","conclusion":"wt_fundef fd","hypotheses":"(fd : Linear.fundef) (i' : ident) (H : In (i', Gfun fd) (prog_defs prog)) (f2 : fundef) (P : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (H2 : transf_fundef fd = OK f2)","proofString":"destruct fd; simpl in *.\nmonadInv H2.\nunfold transf_function in EQ.\ndestruct (wt_function f).\nauto.\ndiscriminate.\nauto."},{"statement":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (f2 : fundef) (P : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (H2 : bind (transf_function f) (fun f' : function => OK (Internal f')) = OK f2) : wt_function f = true.","conclusion":"wt_function f = true","hypotheses":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (f2 : fundef) (P : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (H2 : bind (transf_function f) (fun f' : function => OK (Internal f')) = OK f2)","proofString":"monadInv H2.\nunfold transf_function in EQ.\ndestruct (wt_function f).\nauto.\ndiscriminate."},{"statement":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (x : function) (P : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (EQ : transf_function f = OK x) : wt_function f = true.","conclusion":"wt_function f = true","hypotheses":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (x : function) (P : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (EQ : transf_function f = OK x)","proofString":"unfold transf_function in EQ.\ndestruct (wt_function f).\nauto.\ndiscriminate."},{"statement":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (x : function) (P : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (EQ : (if negb (wt_function f)\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK x) : wt_function f = true.","conclusion":"wt_function f = true","hypotheses":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (x : function) (P : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (EQ : (if negb (wt_function f)\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK x)","proofString":"destruct (wt_function f).\nauto.\ndiscriminate."},{"statement":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (x : function) (P : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (EQ : (if negb true\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK x) : true = true.","conclusion":"true = true","hypotheses":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (x : function) (P : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (EQ : (if negb true\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK x)","proofString":"auto."},{"statement":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (x : function) (P : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (EQ : (if negb false\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK x) : false = true.","conclusion":"false = true","hypotheses":"(f : Linear.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (x : function) (P : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (EQ : (if negb false\n then Error (msg \"Ill-formed Linear code\")\n else\n  if zlt Ptrofs.max_unsigned (fe_size (make_env (function_bounds f)))\n  then Error (msg \"Too many spilled variables, stack size exceeded\")\n  else\n   OK\n     {|\n       fn_sig := Linear.fn_sig f;\n       fn_code := transl_body f (make_env (function_bounds f));\n       fn_stacksize := fe_size (make_env (function_bounds f));\n       fn_link_ofs :=\n         Ptrofs.repr (fe_ofs_link (make_env (function_bounds f)));\n       fn_retaddr_ofs :=\n         Ptrofs.repr (fe_ofs_retaddr (make_env (function_bounds f)))\n     |}) = OK x)","proofString":"discriminate."},{"statement":"(e : external_function) (i' : ident) (H : In (i', Gfun (External e)) (prog_defs prog)) (f2 : fundef) (P : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (H2 : OK (External e) = OK f2) : True.","conclusion":"True","hypotheses":"(e : external_function) (i' : ident) (H : In (i', Gfun (External e)) (prog_defs prog)) (f2 : fundef) (P : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Linear.fundef unit) (H1 : linkorder ctx' prog) (H2 : OK (External e) = OK f2)","proofString":"auto."},{"statement":"(ms : Linear.state -> state -> Prop) : forall id : ident,\nSenv.public_symbol (symbolenv (semantics return_address_offset tprog)) id =\nSenv.public_symbol (symbolenv (Linear.semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics return_address_offset tprog)) id =\nSenv.public_symbol (symbolenv (Linear.semantics prog)) id","hypotheses":"(ms : Linear.state -> state -> Prop)","proofString":"apply senv_preserved."},{"statement":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (H : Smallstep.initial_state (Linear.semantics prog) s1) (st2 : state) (A : initial_state tprog st2) (B : match_states s1 st2) : wt_state s1.","conclusion":"wt_state s1","hypotheses":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (H : Smallstep.initial_state (Linear.semantics prog) s1) (st2 : state) (A : initial_state tprog st2) (B : match_states s1 st2)","proofString":"apply wt_initial_state with (prog := prog); auto.\nexact wt_prog."},{"statement":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (H : Smallstep.initial_state (Linear.semantics prog) s1) (st2 : state) (A : initial_state tprog st2) (B : match_states s1 st2) : forall (i : ident) (fd : Linear.fundef),\nIn (i, Gfun fd) (prog_defs prog) -> wt_fundef fd.","conclusion":"forall (i : ident) (fd : Linear.fundef),\nIn (i, Gfun fd) (prog_defs prog) -> wt_fundef fd","hypotheses":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (H : Smallstep.initial_state (Linear.semantics prog) s1) (st2 : state) (A : initial_state tprog st2) (B : match_states s1 st2)","proofString":"exact wt_prog."},{"statement":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (s2 : Smallstep.state (semantics return_address_offset tprog)) (r : int) (H : wt_state s1) (H1 : match_states s1 s2) (H0 : Smallstep.final_state (Linear.semantics prog) s1 r) : Smallstep.final_state (semantics return_address_offset tprog) s2 r.","conclusion":"Smallstep.final_state (semantics return_address_offset tprog) s2 r","hypotheses":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (s2 : Smallstep.state (semantics return_address_offset tprog)) (r : int) (H : wt_state s1) (H1 : match_states s1 s2) (H0 : Smallstep.final_state (Linear.semantics prog) s1 r)","proofString":"eapply transf_final_states; eauto."},{"statement":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (t : trace) (s1' : Smallstep.state (Linear.semantics prog)) (H : Step (Linear.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics return_address_offset tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2') : Plus (semantics return_address_offset tprog) s2 t s2'.","conclusion":"Plus (semantics return_address_offset tprog) s2 t s2'","hypotheses":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (t : trace) (s1' : Smallstep.state (Linear.semantics prog)) (H : Step (Linear.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics return_address_offset tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2')","proofString":"exact A."},{"statement":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (t : trace) (s1' : Smallstep.state (Linear.semantics prog)) (H : Step (Linear.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics return_address_offset tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2') : wt_state s1'.","conclusion":"wt_state s1'","hypotheses":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (t : trace) (s1' : Smallstep.state (Linear.semantics prog)) (H : Step (Linear.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics return_address_offset tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2')","proofString":"eapply step_type_preservation; eauto.\neexact wt_prog.\neexact H."},{"statement":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (t : trace) (s1' : Smallstep.state (Linear.semantics prog)) (H : Step (Linear.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics return_address_offset tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2') : match_states s1' s2'.","conclusion":"match_states s1' s2'","hypotheses":"(ms : Linear.state -> state -> Prop) (s1 : Smallstep.state (Linear.semantics prog)) (t : trace) (s1' : Smallstep.state (Linear.semantics prog)) (H : Step (Linear.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics return_address_offset tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2')","proofString":"auto."}]}