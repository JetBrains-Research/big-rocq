[{"statement":"Lemma fsupp_rs : fsupp (⦗set_compl is_init⦘ ⨾ rs G).","proof":"assert (sc_per_loc G) as SCPL.\n{\napply coherence_sc_per_loc, IMMCON.\n}\nunfold imm_s_hb.rs.\nrewrite <- !seqA.\napply fsupp_seq.\n2: {\nrewrite rf_rmw_in_co; auto.\nrewrite rt_of_trans; [| apply co_trans; auto].\napply fsupp_cr.\napply FAIR.\n}\nrewrite inclusion_seq_eqv_r, seqA, inclusion_seq_eqv_l with (dom := is_w _).\nrewrite inclusion_inter_l1.\nrewrite crE.\nrelsf.\napply fsupp_union; auto using fsupp_eqv, fsupp_sb.\n"},{"statement":"Lemma fsupp_release : fsupp (release G).","proof":"rewrite no_release_from_init; auto.\nunfold imm_s_hb.release.\nrewrite inclusion_seq_eqv_l with (dom := is_rel _).\neapply fsupp_mori.\n2: {\napply fsupp_seq with (r1 := ⦗set_compl is_init⦘ ⨾ (sb G)^?).\n2: {\napply fsupp_rs.\n}\nrewrite crE.\nrelsf.\napply fsupp_union; auto using fsupp_sb, fsupp_eqv.\n}\nred.\nrewrite no_sb_to_init at 1.\nbasic_solver 10.\n"},{"statement":"Lemma fsupp_sw : fsupp (sw G).","proof":"unfold imm_s_hb.sw.\nrewrite (no_rf_to_init WF).\nrewrite !seqA.\nrewrite <- seqA with (r2 := rf G).\napply fsupp_seq.\n2: {\nrewrite !inclusion_seq_eqv_r.\nrewrite crE.\nrelsf.\napply fsupp_union; auto using fsupp_sb, fsupp_eqv.\n}\napply fsupp_seq; auto using fsupp_rf, fsupp_release.\n"},{"statement":"Lemma fsupp_hb : fsupp (⦗set_compl is_init⦘ ⨾ hb G).","proof":"rewrite (dom_l (wf_hbE WF)), <- !seqA.\nrewrite <- id_inter, set_interC, <- set_minusE.\nunfold imm_s_hb.hb.\nrewrite clos_trans_domb_l_strong.\n2: {\nrewrite no_sb_to_init, no_sw_to_init, wf_sbE, wf_swE; basic_solver.\n}\nrewrite inclusion_seq_eqv_r.\narewrite (acts_set G \\₁ is_init ⊆₁ set_compl is_init); [basic_solver| ].\nrewrite seq_union_r.\neapply fsupp_ct with (s := acts_set G \\₁ is_init), fsupp_union; ins; eauto.\n{\nrewrite 2!inclusion_seq_eqv_l.\ncdes IMMCON.\nred in Cint.\ngeneralize Cint.\nunfold acyclic, hb.\nbasic_solver 10.\n}\n{\nrewrite (dom_l (@wf_sbE G)), (dom_l (wf_swE WF)); basic_solver 10.\n}\n{\nrewrite <- inclusion_union_r1.\neapply (@has_finite_antichains_sb G); eauto.\napply WF.\n}\n{\napply fsupp_sb; auto.\n}\neapply fsupp_mori; [| apply fsupp_sw].\nred.\nbasic_solver 10.\n"},{"statement":"Lemma fsupp_furr:\n    fsupp (⦗set_compl is_init⦘ ⨾ furr G sc).","proof":"assert (wf_sc G sc) as WFSC by (apply IMMCON).\nrewrite furr_alt; auto.\nrewrite !crE, !seq_union_l, !seq_union_r.\nrewrite !seq_id_l, !seq_id_r.\narewrite (hb G ⨾ hb G ⊆ hb G).\nrewrite <- !seqA.\narewrite ((⦗set_compl (is_init)⦘ ;; ⦗is_w (lab G)⦘) ⨾ rf G ⊆ rf G) by basic_solver 10.\nassert (⦗is_w (lab G)⦘ ⨾ sc ⊆ ∅₂) as AA.\n{\nrewrite (wf_scD WFSC); type_solver.\n}\narewrite (⦗is_w (lab G)⦘ ⨾ sc ⊆ ∅₂); auto.\narewrite (⦗set_compl (is_init)⦘ ;; ⦗is_w (lab G)⦘ ⨾ sc ⊆ ∅₂).\n{\nrewrite AA.\nbasic_solver.\n}\nrewrite <- !seqA.\narewrite (rf G ⨾ sc ⊆ ∅₂).\n{\nrewrite (wf_scD WFSC), wf_rfD; auto.\ntype_solver.\n}\nrewrite seq_false_r, seq_false_l, union_false_l, union_false_r.\nrewrite <- !seqA.\narewrite ((⦗set_compl is_init⦘ ⨾ ⦗is_w (lab G)⦘) ⨾ hb G ⊆ ⦗set_compl (is_init)⦘ ;; hb G)      by basic_solver 10.\nassert (fsupp (rf G ⨾ hb G)) as CC.\n{\nrewrite no_rf_to_init, seqA; auto.\napply fsupp_seq; auto using fsupp_hb, fsupp_rf.\n}\nassert (fsupp (sc ⨾ hb G)) as DD.\n{\nrewrite (no_sc_to_init WF WFSC).\nrewrite seqA; auto.\napply fsupp_seq; auto using fsupp_hb.\n}\nrewrite <- id_inter.\nrepeat apply fsupp_union; try by auto using fsupp_rf, fsupp_hb, fsupp_eqv.\nall: try rewrite <- seqA.\nall: apply fsupp_seq; auto using fsupp_rf, fsupp_hb, fsupp_eqv.\n"}]