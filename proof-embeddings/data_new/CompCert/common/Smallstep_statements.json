{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Smallstep.v","fileSamples":[{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : step ge s1 t s2) : star ge s1 t s2.","conclusion":"star ge s1 t s2","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : step ge s1 t s2)","proofString":"eapply star_step; eauto.\napply star_refl.\ntraceEq."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2) : star ge s1 t s3.","conclusion":"star ge s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"eapply star_step; eauto.\napply star_one; auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2) : star ge s2 t2 s3.","conclusion":"star ge s2 t2 s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"apply star_one; auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : t = t1 ** t2 ** t3) : star ge s1 t s4.","conclusion":"star ge s1 t s4","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : t = t1 ** t2 ** t3)","proofString":"eapply star_step; eauto.\neapply star_two; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : t = t1 ** t2 ** t3) : star ge s2 (t2 ** t3) s4.","conclusion":"star ge s2 (t2 ** t3) s4","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : t = t1 ** t2 ** t3)","proofString":"eapply star_two; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t4 : trace) (s5 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : step ge s4 t4 s5) (H3 : t = t1 ** t2 ** t3 ** t4) : star ge s1 t s5.","conclusion":"star ge s1 t s5","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t4 : trace) (s5 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : step ge s4 t4 s5) (H3 : t = t1 ** t2 ** t3 ** t4)","proofString":"eapply star_step; eauto.\neapply star_three; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t4 : trace) (s5 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : step ge s4 t4 s5) (H3 : t = t1 ** t2 ** t3 ** t4) : star ge s2 (t2 ** t3 ** t4) s5.","conclusion":"star ge s2 (t2 ** t3 ** t4) s5","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t4 : trace) (s5 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : step ge s4 t4 s5) (H3 : t = t1 ** t2 ** t3 ** t4)","proofString":"eapply star_three; eauto."},{"statement":"(ge : genv) (s : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s t2 s3) (H0 : t = E0 ** t2) : star ge s t s3.","conclusion":"star ge s t s3","hypotheses":"(ge : genv) (s : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s t2 s3) (H0 : t = E0 ** t2)","proofString":"rewrite H0.\nsimpl.\nauto."},{"statement":"(ge : genv) (s : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s t2 s3) (H0 : t = E0 ** t2) : star ge s (E0 ** t2) s3.","conclusion":"star ge s (E0 ** t2) s3","hypotheses":"(ge : genv) (s : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s t2 s3) (H0 : t = E0 ** t2)","proofString":"simpl.\nauto."},{"statement":"(ge : genv) (s : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s t2 s3) (H0 : t = E0 ** t2) : star ge s t2 s3.","conclusion":"star ge s t2 s3","hypotheses":"(ge : genv) (s : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s t2 s3) (H0 : t = E0 ** t2)","proofString":"auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (t4 : trace) (s4 : state) (t5 : trace),\nstar ge s3 t4 s4 -> t5 = t2 ** t4 -> star ge s2 t5 s4) (t0 : trace) (s0 : state) (t3 : trace) (H2 : star ge s3 t0 s0) (H3 : t3 = t ** t0) : star ge s1 t3 s0.","conclusion":"star ge s1 t3 s0","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (t4 : trace) (s4 : state) (t5 : trace),\nstar ge s3 t4 s4 -> t5 = t2 ** t4 -> star ge s2 t5 s4) (t0 : trace) (s0 : state) (t3 : trace) (H2 : star ge s3 t0 s0) (H3 : t3 = t ** t0)","proofString":"eapply star_step; eauto.\ntraceEq."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (t4 : trace) (s4 : state) (t5 : trace),\nstar ge s3 t4 s4 -> t5 = t2 ** t4 -> star ge s2 t5 s4) (t0 : trace) (s0 : state) (t3 : trace) (H2 : star ge s3 t0 s0) (H3 : t3 = t ** t0) : t3 = t1 ** t2 ** t0.","conclusion":"t3 = t1 ** t2 ** t0","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (t4 : trace) (s4 : state) (t5 : trace),\nstar ge s3 t4 s4 -> t5 = t2 ** t4 -> star ge s2 t5 s4) (t0 : trace) (s0 : state) (t3 : trace) (H2 : star ge s3 t0 s0) (H3 : t3 = t ** t0)","proofString":"traceEq."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2) : star ge s1 t s3.","conclusion":"star ge s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"eapply star_trans.\neauto.\napply star_one.\neauto.\nauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s1 s2 s3 : state, step ge s1 E0 s2 -> P s2 s3 -> P s1 s3) : forall s1 s2 : state, star ge s1 E0 s2 -> P s1 s2.","conclusion":"forall s1 s2 : state, star ge s1 E0 s2 -> P s1 s2","hypotheses":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s1 s2 s3 : state, step ge s1 E0 s2 -> P s2 s3 -> P s1 s3)","proofString":"assert (forall s1 t s2, star ge s1 t s2 -> t = E0 -> P s1 s2).\ninduction 1; intros; subst.\nauto.\ndestruct (Eapp_E0_inv _ _ H2).\nsubst.\neauto.\neauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s1 s2 s3 : state, step ge s1 E0 s2 -> P s2 s3 -> P s1 s3) : forall (s1 : state) (t : trace) (s2 : state),\nstar ge s1 t s2 -> t = E0 -> P s1 s2.","conclusion":"forall (s1 : state) (t : trace) (s2 : state),\nstar ge s1 t s2 -> t = E0 -> P s1 s2","hypotheses":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s1 s2 s3 : state, step ge s1 E0 s2 -> P s2 s3 -> P s1 s3)","proofString":"induction 1; intros; subst.\nauto.\ndestruct (Eapp_E0_inv _ _ H2).\nsubst.\neauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s0 : state, P s0 s0) (REC : forall s1 s2 s3 : state, step ge s1 E0 s2 -> P s2 s3 -> P s1 s3) (s : state) (H : E0 = E0) : P s s.","conclusion":"P s s","hypotheses":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s0 : state, P s0 s0) (REC : forall s1 s2 s3 : state, step ge s1 E0 s2 -> P s2 s3 -> P s1 s3) (s : state) (H : E0 = E0)","proofString":"auto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s0 s4 s5 : state, step ge s0 E0 s4 -> P s4 s5 -> P s0 s5) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : t2 = E0 -> P s2 s3) (H2 : t1 ** t2 = E0) : P s1 s3.","conclusion":"P s1 s3","hypotheses":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s0 s4 s5 : state, step ge s0 E0 s4 -> P s4 s5 -> P s0 s5) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : t2 = E0 -> P s2 s3) (H2 : t1 ** t2 = E0)","proofString":"destruct (Eapp_E0_inv _ _ H2).\nsubst.\neauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s0 s4 s5 : state, step ge s0 E0 s4 -> P s4 s5 -> P s0 s5) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : t2 = E0 -> P s2 s3) (H2 : t1 ** t2 = E0) (H1 : t1 = E0) (H3 : t2 = E0) : P s1 s3.","conclusion":"P s1 s3","hypotheses":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s0 s4 s5 : state, step ge s0 E0 s4 -> P s4 s5 -> P s0 s5) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : t2 = E0 -> P s2 s3) (H2 : t1 ** t2 = E0) (H1 : t1 = E0) (H3 : t2 = E0)","proofString":"subst.\neauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s0 s4 s5 : state, step ge s0 E0 s4 -> P s4 s5 -> P s0 s5) (s1 s2 s3 : state) (H : step ge s1 E0 s2) (H2 : E0 ** E0 = E0) (IHstar : E0 = E0 -> P s2 s3) (H0 : star ge s2 E0 s3) : P s1 s3.","conclusion":"P s1 s3","hypotheses":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s0 s4 s5 : state, step ge s0 E0 s4 -> P s4 s5 -> P s0 s5) (s1 s2 s3 : state) (H : step ge s1 E0 s2) (H2 : E0 ** E0 = E0) (IHstar : E0 = E0 -> P s2 s3) (H0 : star ge s2 E0 s3)","proofString":"eauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s1 s2 s3 : state, step ge s1 E0 s2 -> P s2 s3 -> P s1 s3) (H : forall (s1 : state) (t : trace) (s2 : state),\nstar ge s1 t s2 -> t = E0 -> P s1 s2) : forall s1 s2 : state, star ge s1 E0 s2 -> P s1 s2.","conclusion":"forall s1 s2 : state, star ge s1 E0 s2 -> P s1 s2","hypotheses":"(ge : genv) (P : state -> state -> Prop) (BASE : forall s : state, P s s) (REC : forall s1 s2 s3 : state, step ge s1 E0 s2 -> P s2 s3 -> P s1 s3) (H : forall (s1 : state) (t : trace) (s2 : state),\nstar ge s1 t s2 -> t = E0 -> P s1 s2)","proofString":"eauto."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : step ge s1 t s2) : plus ge s1 t s2.","conclusion":"plus ge s1 t s2","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : step ge s1 t s2)","proofString":"econstructor; eauto.\napply star_refl.\ntraceEq."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2) : plus ge s1 t s3.","conclusion":"plus ge s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"eapply plus_left; eauto.\napply star_one; auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2) : star ge s2 t2 s3.","conclusion":"star ge s2 t2 s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"apply star_one; auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : t = t1 ** t2 ** t3) : plus ge s1 t s4.","conclusion":"plus ge s1 t s4","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : t = t1 ** t2 ** t3)","proofString":"eapply plus_left; eauto.\neapply star_two; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : t = t1 ** t2 ** t3) : star ge s2 (t2 ** t3) s4.","conclusion":"star ge s2 (t2 ** t3) s4","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : t = t1 ** t2 ** t3)","proofString":"eapply star_two; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t4 : trace) (s5 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : step ge s4 t4 s5) (H3 : t = t1 ** t2 ** t3 ** t4) : plus ge s1 t s5.","conclusion":"plus ge s1 t s5","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t4 : trace) (s5 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : step ge s4 t4 s5) (H3 : t = t1 ** t2 ** t3 ** t4)","proofString":"eapply plus_left; eauto.\neapply star_three; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t4 : trace) (s5 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : step ge s4 t4 s5) (H3 : t = t1 ** t2 ** t3 ** t4) : star ge s2 (t2 ** t3 ** t4) s5.","conclusion":"star ge s2 (t2 ** t3 ** t4) s5","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t3 : trace) (s4 : state) (t4 : trace) (s5 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : step ge s3 t3 s4) (H2 : step ge s4 t4 s5) (H3 : t = t1 ** t2 ** t3 ** t4)","proofString":"eapply star_three; eauto."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : plus ge s1 t s2) : star ge s1 t s2.","conclusion":"star ge s1 t s2","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : plus ge s1 t s2)","proofString":"inversion H; subst.\neapply star_step; eauto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 t2 : trace) (H : plus ge s1 (t1 ** t2) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 t2 s2) : star ge s1 (t1 ** t2) s2.","conclusion":"star ge s1 (t1 ** t2) s2","hypotheses":"(ge : genv) (s1 s2 : state) (t1 t2 : trace) (H : plus ge s1 (t1 ** t2) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 t2 s2)","proofString":"eapply star_step; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2) : plus ge s1 t s3.","conclusion":"plus ge s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"inversion H; subst.\nsimpl.\napply plus_one.\nauto.\nrewrite Eapp_assoc.\neapply plus_left; eauto.\neapply star_right; eauto."},{"statement":"(ge : genv) (s2 : state) (t2 : trace) (s3 : state) (H : star ge s2 E0 s2) (H0 : step ge s2 t2 s3) : plus ge s2 (E0 ** t2) s3.","conclusion":"plus ge s2 (E0 ** t2) s3","hypotheses":"(ge : genv) (s2 : state) (t2 : trace) (s3 : state) (H : star ge s2 E0 s2) (H0 : step ge s2 t2 s3)","proofString":"simpl.\napply plus_one.\nauto."},{"statement":"(ge : genv) (s2 : state) (t2 : trace) (s3 : state) (H : star ge s2 E0 s2) (H0 : step ge s2 t2 s3) : plus ge s2 t2 s3.","conclusion":"plus ge s2 t2 s3","hypotheses":"(ge : genv) (s2 : state) (t2 : trace) (s3 : state) (H : star ge s2 E0 s2) (H0 : step ge s2 t2 s3)","proofString":"apply plus_one.\nauto."},{"statement":"(ge : genv) (s2 : state) (t2 : trace) (s3 : state) (H : star ge s2 E0 s2) (H0 : step ge s2 t2 s3) : step ge s2 t2 s3.","conclusion":"step ge s2 t2 s3","hypotheses":"(ge : genv) (s2 : state) (t2 : trace) (s3 : state) (H : star ge s2 E0 s2) (H0 : step ge s2 t2 s3)","proofString":"auto."},{"statement":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : step ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2) : plus ge s1 ((t0 ** t3) ** t2) s3.","conclusion":"plus ge s1 ((t0 ** t3) ** t2) s3","hypotheses":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : step ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"rewrite Eapp_assoc.\neapply plus_left; eauto.\neapply star_right; eauto."},{"statement":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : step ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2) : plus ge s1 (t0 ** t3 ** t2) s3.","conclusion":"plus ge s1 (t0 ** t3 ** t2) s3","hypotheses":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : step ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"eapply plus_left; eauto.\neapply star_right; eauto."},{"statement":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : step ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2) : star ge s4 (t3 ** t2) s3.","conclusion":"star ge s4 (t3 ** t2) s3","hypotheses":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : step ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"eapply star_right; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : plus ge s2 t2 s3) (H1 : t = t1 ** t2) : plus ge s1 t s3.","conclusion":"plus ge s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : plus ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"eapply plus_left; eauto.\napply plus_star; auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : plus ge s2 t2 s3) (H1 : t = t1 ** t2) : star ge s2 t2 s3.","conclusion":"star ge s2 t2 s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : plus ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"apply plus_star; auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : plus ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2) : plus ge s1 t s3.","conclusion":"plus ge s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : plus ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"eapply plus_right; eauto.\napply plus_star; auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : plus ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2) : star ge s1 t1 s2.","conclusion":"star ge s1 t1 s2","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : plus ge s1 t1 s2) (H0 : step ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"apply plus_star; auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : plus ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) : plus ge s1 t s3.","conclusion":"plus ge s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : plus ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"inversion H; subst.\neconstructor; eauto.\neapply star_trans; eauto.\ntraceEq."},{"statement":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : plus ge s1 (t0 ** t3) s2) (H0 : star ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2) : plus ge s1 ((t0 ** t3) ** t2) s3.","conclusion":"plus ge s1 ((t0 ** t3) ** t2) s3","hypotheses":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : plus ge s1 (t0 ** t3) s2) (H0 : star ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"econstructor; eauto.\neapply star_trans; eauto.\ntraceEq."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s1 t1 s2) (H0 : plus ge s2 t2 s3) (H1 : t = t1 ** t2) : plus ge s1 t s3.","conclusion":"plus ge s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : star ge s1 t1 s2) (H0 : plus ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"inversion H; subst.\nsimpl; auto.\nrewrite Eapp_assoc.\neconstructor.\neauto.\neapply star_trans.\neauto.\napply plus_star.\neauto.\neauto.\nauto."},{"statement":"(ge : genv) (s2 : state) (t2 : trace) (s3 : state) (H : star ge s2 E0 s2) (H0 : plus ge s2 t2 s3) : plus ge s2 (E0 ** t2) s3.","conclusion":"plus ge s2 (E0 ** t2) s3","hypotheses":"(ge : genv) (s2 : state) (t2 : trace) (s3 : state) (H : star ge s2 E0 s2) (H0 : plus ge s2 t2 s3)","proofString":"simpl; auto."},{"statement":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : plus ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2) : plus ge s1 ((t0 ** t3) ** t2) s3.","conclusion":"plus ge s1 ((t0 ** t3) ** t2) s3","hypotheses":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : plus ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"rewrite Eapp_assoc.\neconstructor.\neauto.\neapply star_trans.\neauto.\napply plus_star.\neauto.\neauto.\nauto."},{"statement":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : plus ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2) : plus ge s1 (t0 ** t3 ** t2) s3.","conclusion":"plus ge s1 (t0 ** t3 ** t2) s3","hypotheses":"(ge : genv) (s1 s2 : state) (t2 : trace) (s3 : state) (t0 t3 : trace) (H : star ge s1 (t0 ** t3) s2) (H0 : plus ge s2 t2 s3) (s4 : state) (H2 : step ge s1 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"econstructor.\neauto.\neapply star_trans.\neauto.\napply plus_star.\neauto.\neauto.\nauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : plus ge s1 t1 s2) (H0 : plus ge s2 t2 s3) (H1 : t = t1 ** t2) : plus ge s1 t s3.","conclusion":"plus ge s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : plus ge s1 t1 s2) (H0 : plus ge s2 t2 s3) (H1 : t = t1 ** t2)","proofString":"eapply plus_star_trans.\neauto.\napply plus_star.\neauto.\nauto."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : plus ge s1 t s2) : step ge s1 t s2 \\/\n(exists (s' : state) (t1 t2 : trace),\n   step ge s1 t1 s' /\\ plus ge s' t2 s2 /\\ t = t1 ** t2).","conclusion":"step ge s1 t s2 \\/\n(exists (s' : state) (t1 t2 : trace),\n   step ge s1 t1 s' /\\ plus ge s' t2 s2 /\\ t = t1 ** t2)","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : plus ge s1 t s2)","proofString":"inversion H; subst.\ninversion H1; subst.\nleft.\nrewrite E0_right.\nauto.\nright.\nexists s3; exists t1; exists (t0 ** t3); split.\nauto.\nsplit.\neconstructor; eauto.\nauto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 t2 : trace) (H : plus ge s1 (t1 ** t2) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 t2 s2) : step ge s1 (t1 ** t2) s2 \\/\n(exists (s' : state) (t0 t3 : trace),\n   step ge s1 t0 s' /\\ plus ge s' t3 s2 /\\ t1 ** t2 = t0 ** t3).","conclusion":"step ge s1 (t1 ** t2) s2 \\/\n(exists (s' : state) (t0 t3 : trace),\n   step ge s1 t0 s' /\\ plus ge s' t3 s2 /\\ t1 ** t2 = t0 ** t3)","hypotheses":"(ge : genv) (s1 s2 : state) (t1 t2 : trace) (H : plus ge s1 (t1 ** t2) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 t2 s2)","proofString":"inversion H1; subst.\nleft.\nrewrite E0_right.\nauto.\nright.\nexists s3; exists t1; exists (t0 ** t3); split.\nauto.\nsplit.\neconstructor; eauto.\nauto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 : trace) (H : plus ge s1 (t1 ** E0) s2) (H1 : star ge s2 E0 s2) (H0 : step ge s1 t1 s2) : step ge s1 (t1 ** E0) s2 \\/\n(exists (s' : state) (t0 t2 : trace),\n   step ge s1 t0 s' /\\ plus ge s' t2 s2 /\\ t1 ** E0 = t0 ** t2).","conclusion":"step ge s1 (t1 ** E0) s2 \\/\n(exists (s' : state) (t0 t2 : trace),\n   step ge s1 t0 s' /\\ plus ge s' t2 s2 /\\ t1 ** E0 = t0 ** t2)","hypotheses":"(ge : genv) (s1 s2 : state) (t1 : trace) (H : plus ge s1 (t1 ** E0) s2) (H1 : star ge s2 E0 s2) (H0 : step ge s1 t1 s2)","proofString":"left.\nrewrite E0_right.\nauto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 : trace) (H : plus ge s1 (t1 ** E0) s2) (H1 : star ge s2 E0 s2) (H0 : step ge s1 t1 s2) : step ge s1 (t1 ** E0) s2.","conclusion":"step ge s1 (t1 ** E0) s2","hypotheses":"(ge : genv) (s1 s2 : state) (t1 : trace) (H : plus ge s1 (t1 ** E0) s2) (H1 : star ge s2 E0 s2) (H0 : step ge s1 t1 s2)","proofString":"rewrite E0_right.\nauto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 : trace) (H : plus ge s1 (t1 ** E0) s2) (H1 : star ge s2 E0 s2) (H0 : step ge s1 t1 s2) : step ge s1 t1 s2.","conclusion":"step ge s1 t1 s2","hypotheses":"(ge : genv) (s1 s2 : state) (t1 : trace) (H : plus ge s1 (t1 ** E0) s2) (H1 : star ge s2 E0 s2) (H0 : step ge s1 t1 s2)","proofString":"auto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2) : step ge s1 (t1 ** t0 ** t3) s2 \\/\n(exists (s' : state) (t2 t4 : trace),\n   step ge s1 t2 s' /\\ plus ge s' t4 s2 /\\ t1 ** t0 ** t3 = t2 ** t4).","conclusion":"step ge s1 (t1 ** t0 ** t3) s2 \\/\n(exists (s' : state) (t2 t4 : trace),\n   step ge s1 t2 s' /\\ plus ge s' t4 s2 /\\ t1 ** t0 ** t3 = t2 ** t4)","hypotheses":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"right.\nexists s3; exists t1; exists (t0 ** t3); split.\nauto.\nsplit.\neconstructor; eauto.\nauto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2) : exists (s' : state) (t2 t4 : trace),\n  step ge s1 t2 s' /\\ plus ge s' t4 s2 /\\ t1 ** t0 ** t3 = t2 ** t4.","conclusion":"exists (s' : state) (t2 t4 : trace),\n  step ge s1 t2 s' /\\ plus ge s' t4 s2 /\\ t1 ** t0 ** t3 = t2 ** t4","hypotheses":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"exists s3; exists t1; exists (t0 ** t3); split.\nauto.\nsplit.\neconstructor; eauto.\nauto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2) : step ge s1 t1 s3.","conclusion":"step ge s1 t1 s3","hypotheses":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"auto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2) : plus ge s3 (t0 ** t3) s2 /\\ t1 ** t0 ** t3 = t1 ** t0 ** t3.","conclusion":"plus ge s3 (t0 ** t3) s2 /\\ t1 ** t0 ** t3 = t1 ** t0 ** t3","hypotheses":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"split.\neconstructor; eauto.\nauto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2) : plus ge s3 (t0 ** t3) s2.","conclusion":"plus ge s3 (t0 ** t3) s2","hypotheses":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"econstructor; eauto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2) : t1 ** t0 ** t3 = t1 ** t0 ** t3.","conclusion":"t1 ** t0 ** t3 = t1 ** t0 ** t3","hypotheses":"(ge : genv) (s1 s2 : state) (t1 t0 t3 : trace) (H : plus ge s1 (t1 ** t0 ** t3) s2) (s3 : state) (H0 : step ge s1 t1 s3) (H1 : star ge s3 (t0 ** t3) s2) (s4 : state) (H2 : step ge s3 t0 s4) (H3 : star ge s4 t3 s2)","proofString":"auto."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) : s2 = s1 /\\ t = E0 \\/ plus ge s1 t s2.","conclusion":"s2 = s1 /\\ t = E0 \\/ plus ge s1 t s2","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2)","proofString":"inv H.\nleft; auto.\nright; econstructor; eauto."},{"statement":"(ge : genv) (s2 : state) : s2 = s2 /\\ E0 = E0 \\/ plus ge s2 E0 s2.","conclusion":"s2 = s2 /\\ E0 = E0 \\/ plus ge s2 E0 s2","hypotheses":"(ge : genv) (s2 : state)","proofString":"left; auto."},{"statement":"(ge : genv) (s1 s2 : state) (t1 : trace) (s3 : state) (t2 : trace) (H0 : step ge s1 t1 s3) (H1 : star ge s3 t2 s2) : s2 = s1 /\\ t1 ** t2 = E0 \\/ plus ge s1 (t1 ** t2) s2.","conclusion":"s2 = s1 /\\ t1 ** t2 = E0 \\/ plus ge s1 (t1 ** t2) s2","hypotheses":"(ge : genv) (s1 s2 : state) (t1 : trace) (s3 : state) (t2 : trace) (H0 : step ge s1 t1 s3) (H1 : star ge s3 t2 s2)","proofString":"right; econstructor; eauto."},{"statement":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3) : forall (s1 : state) (t : trace) (s2 : state), plus ge s1 t s2 -> P s1 t s2.","conclusion":"forall (s1 : state) (t : trace) (s2 : state), plus ge s1 t s2 -> P s1 t s2","hypotheses":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3)","proofString":"assert (forall s1 t s2, star ge s1 t s2 ->         forall s0 t0, step ge s0 t0 s1 ->         P s0 (t0 ** t) s2).\ninduction 1; intros.\nrewrite E0_right.\napply BASE; auto.\neapply IND.\neauto.\neconstructor; eauto.\nsubst t.\neapply IHstar; eauto.\nauto.\nintros.\ninv H0.\neauto."},{"statement":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3) : forall (s1 : state) (t : trace) (s2 : state),\nstar ge s1 t s2 ->\nforall (s0 : state) (t0 : trace), step ge s0 t0 s1 -> P s0 (t0 ** t) s2.","conclusion":"forall (s1 : state) (t : trace) (s2 : state),\nstar ge s1 t s2 ->\nforall (s0 : state) (t0 : trace), step ge s0 t0 s1 -> P s0 (t0 ** t) s2","hypotheses":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3)","proofString":"induction 1; intros.\nrewrite E0_right.\napply BASE; auto.\neapply IND.\neauto.\neconstructor; eauto.\nsubst t.\neapply IHstar; eauto.\nauto."},{"statement":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3) (s s0 : state) (t0 : trace) (H : step ge s0 t0 s) : P s0 (t0 ** E0) s.","conclusion":"P s0 (t0 ** E0) s","hypotheses":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3) (s s0 : state) (t0 : trace) (H : step ge s0 t0 s)","proofString":"rewrite E0_right.\napply BASE; auto."},{"statement":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3) (s s0 : state) (t0 : trace) (H : step ge s0 t0 s) : P s0 t0 s.","conclusion":"P s0 t0 s","hypotheses":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3) (s s0 : state) (t0 : trace) (H : step ge s0 t0 s)","proofString":"apply BASE; auto."},{"statement":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s4 : state) (t3 : trace) (s5 : state), step ge s4 t3 s5 -> P s4 t3 s5) (IND : forall (s4 : state) (t3 : trace) (s5 : state) (t4 : trace) \n  (s6 : state) (t5 : trace),\nstep ge s4 t3 s5 ->\nplus ge s5 t4 s6 -> P s5 t4 s6 -> t5 = t3 ** t4 -> P s4 t5 s6) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (s4 : state) (t3 : trace), step ge s4 t3 s2 -> P s4 (t3 ** t2) s3) (s0 : state) (t0 : trace) (H2 : step ge s0 t0 s1) : P s0 (t0 ** t) s3.","conclusion":"P s0 (t0 ** t) s3","hypotheses":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s4 : state) (t3 : trace) (s5 : state), step ge s4 t3 s5 -> P s4 t3 s5) (IND : forall (s4 : state) (t3 : trace) (s5 : state) (t4 : trace) \n  (s6 : state) (t5 : trace),\nstep ge s4 t3 s5 ->\nplus ge s5 t4 s6 -> P s5 t4 s6 -> t5 = t3 ** t4 -> P s4 t5 s6) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (s4 : state) (t3 : trace), step ge s4 t3 s2 -> P s4 (t3 ** t2) s3) (s0 : state) (t0 : trace) (H2 : step ge s0 t0 s1)","proofString":"eapply IND.\neauto.\neconstructor; eauto.\nsubst t.\neapply IHstar; eauto.\nauto."},{"statement":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s4 : state) (t : trace) (s5 : state), step ge s4 t s5 -> P s4 t s5) (IND : forall (s4 : state) (t3 : trace) (s5 : state) (t4 : trace) \n  (s6 : state) (t : trace),\nstep ge s4 t3 s5 ->\nplus ge s5 t4 s6 -> P s5 t4 s6 -> t = t3 ** t4 -> P s4 t s6) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : forall (s4 : state) (t3 : trace), step ge s4 t3 s2 -> P s4 (t3 ** t2) s3) (s0 : state) (t0 : trace) (H2 : step ge s0 t0 s1) : P s1 (t1 ** t2) s3.","conclusion":"P s1 (t1 ** t2) s3","hypotheses":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s4 : state) (t : trace) (s5 : state), step ge s4 t s5 -> P s4 t s5) (IND : forall (s4 : state) (t3 : trace) (s5 : state) (t4 : trace) \n  (s6 : state) (t : trace),\nstep ge s4 t3 s5 ->\nplus ge s5 t4 s6 -> P s5 t4 s6 -> t = t3 ** t4 -> P s4 t s6) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : forall (s4 : state) (t3 : trace), step ge s4 t3 s2 -> P s4 (t3 ** t2) s3) (s0 : state) (t0 : trace) (H2 : step ge s0 t0 s1)","proofString":"eapply IHstar; eauto."},{"statement":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3) (H : forall (s1 : state) (t : trace) (s2 : state),\nstar ge s1 t s2 ->\nforall (s0 : state) (t0 : trace), step ge s0 t0 s1 -> P s0 (t0 ** t) s2) : forall (s1 : state) (t : trace) (s2 : state), plus ge s1 t s2 -> P s1 t s2.","conclusion":"forall (s1 : state) (t : trace) (s2 : state), plus ge s1 t s2 -> P s1 t s2","hypotheses":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s1 : state) (t : trace) (s2 : state), step ge s1 t s2 -> P s1 t s2) (IND : forall (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) \n  (s3 : state) (t : trace),\nstep ge s1 t1 s2 ->\nplus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3) (H : forall (s1 : state) (t : trace) (s2 : state),\nstar ge s1 t s2 ->\nforall (s0 : state) (t0 : trace), step ge s0 t0 s1 -> P s0 (t0 ** t) s2)","proofString":"intros.\ninv H0.\neauto."},{"statement":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s0 : state) (t0 : trace) (s3 : state), step ge s0 t0 s3 -> P s0 t0 s3) (IND : forall (s0 : state) (t1 : trace) (s3 : state) (t2 : trace) \n  (s4 : state) (t0 : trace),\nstep ge s0 t1 s3 ->\nplus ge s3 t2 s4 -> P s3 t2 s4 -> t0 = t1 ** t2 -> P s0 t0 s4) (H : forall (s0 : state) (t0 : trace) (s3 : state),\nstar ge s0 t0 s3 ->\nforall (s4 : state) (t1 : trace), step ge s4 t1 s0 -> P s4 (t1 ** t0) s3) (s1 : state) (t : trace) (s2 : state) (H0 : plus ge s1 t s2) : P s1 t s2.","conclusion":"P s1 t s2","hypotheses":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s0 : state) (t0 : trace) (s3 : state), step ge s0 t0 s3 -> P s0 t0 s3) (IND : forall (s0 : state) (t1 : trace) (s3 : state) (t2 : trace) \n  (s4 : state) (t0 : trace),\nstep ge s0 t1 s3 ->\nplus ge s3 t2 s4 -> P s3 t2 s4 -> t0 = t1 ** t2 -> P s0 t0 s4) (H : forall (s0 : state) (t0 : trace) (s3 : state),\nstar ge s0 t0 s3 ->\nforall (s4 : state) (t1 : trace), step ge s4 t1 s0 -> P s4 (t1 ** t0) s3) (s1 : state) (t : trace) (s2 : state) (H0 : plus ge s1 t s2)","proofString":"inv H0.\neauto."},{"statement":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s0 : state) (t : trace) (s4 : state), step ge s0 t s4 -> P s0 t s4) (IND : forall (s0 : state) (t0 : trace) (s4 : state) (t3 : trace) \n  (s5 : state) (t : trace),\nstep ge s0 t0 s4 ->\nplus ge s4 t3 s5 -> P s4 t3 s5 -> t = t0 ** t3 -> P s0 t s5) (H : forall (s0 : state) (t : trace) (s4 : state),\nstar ge s0 t s4 ->\nforall (s5 : state) (t0 : trace), step ge s5 t0 s0 -> P s5 (t0 ** t) s4) (s1 s2 : state) (t1 : trace) (s3 : state) (t2 : trace) (H1 : step ge s1 t1 s3) (H2 : star ge s3 t2 s2) : P s1 (t1 ** t2) s2.","conclusion":"P s1 (t1 ** t2) s2","hypotheses":"(ge : genv) (P : state -> trace -> state -> Prop) (BASE : forall (s0 : state) (t : trace) (s4 : state), step ge s0 t s4 -> P s0 t s4) (IND : forall (s0 : state) (t0 : trace) (s4 : state) (t3 : trace) \n  (s5 : state) (t : trace),\nstep ge s0 t0 s4 ->\nplus ge s4 t3 s5 -> P s4 t3 s5 -> t = t0 ** t3 -> P s0 t s5) (H : forall (s0 : state) (t : trace) (s4 : state),\nstar ge s0 t s4 ->\nforall (s5 : state) (t0 : trace), step ge s5 t0 s0 -> P s5 (t0 ** t) s4) (s1 s2 : state) (t1 : trace) (s3 : state) (t2 : trace) (H1 : step ge s1 t1 s3) (H2 : star ge s3 t2 s2)","proofString":"eauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (H : forall s0 s3 s4 : state, step ge s0 E0 s3 -> star ge s3 E0 s4 -> P s0 s4) (s1 s2 : state) (H0 : plus ge s1 E0 s2) : P s1 s2.","conclusion":"P s1 s2","hypotheses":"(ge : genv) (P : state -> state -> Prop) (H : forall s0 s3 s4 : state, step ge s0 E0 s3 -> star ge s3 E0 s4 -> P s0 s4) (s1 s2 : state) (H0 : plus ge s1 E0 s2)","proofString":"inv H0.\nexploit Eapp_E0_inv; eauto.\nintros [A B]; subst.\neauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (H : forall s0 s4 s5 : state, step ge s0 E0 s4 -> star ge s4 E0 s5 -> P s0 s5) (s1 s2 : state) (t1 : trace) (s3 : state) (t2 : trace) (H1 : step ge s1 t1 s3) (H2 : star ge s3 t2 s2) (H3 : E0 = t1 ** t2) : P s1 s2.","conclusion":"P s1 s2","hypotheses":"(ge : genv) (P : state -> state -> Prop) (H : forall s0 s4 s5 : state, step ge s0 E0 s4 -> star ge s4 E0 s5 -> P s0 s5) (s1 s2 : state) (t1 : trace) (s3 : state) (t2 : trace) (H1 : step ge s1 t1 s3) (H2 : star ge s3 t2 s2) (H3 : E0 = t1 ** t2)","proofString":"exploit Eapp_E0_inv; eauto.\nintros [A B]; subst.\neauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (H : forall s0 s4 s5 : state, step ge s0 E0 s4 -> star ge s4 E0 s5 -> P s0 s5) (s1 s2 : state) (t1 : trace) (s3 : state) (t2 : trace) (H1 : step ge s1 t1 s3) (H2 : star ge s3 t2 s2) (H3 : E0 = t1 ** t2) : t1 = E0 /\\ t2 = E0 -> P s1 s2.","conclusion":"t1 = E0 /\\ t2 = E0 -> P s1 s2","hypotheses":"(ge : genv) (P : state -> state -> Prop) (H : forall s0 s4 s5 : state, step ge s0 E0 s4 -> star ge s4 E0 s5 -> P s0 s5) (s1 s2 : state) (t1 : trace) (s3 : state) (t2 : trace) (H1 : step ge s1 t1 s3) (H2 : star ge s3 t2 s2) (H3 : E0 = t1 ** t2)","proofString":"intros [A B]; subst.\neauto."},{"statement":"(ge : genv) (P : state -> state -> Prop) (H : forall s0 s4 s5 : state, step ge s0 E0 s4 -> star ge s4 E0 s5 -> P s0 s5) (s1 s2 s3 : state) (H1 : step ge s1 E0 s3) (H3 : E0 = E0 ** E0) (H2 : star ge s3 E0 s2) : P s1 s2.","conclusion":"P s1 s2","hypotheses":"(ge : genv) (P : state -> state -> Prop) (H : forall s0 s4 s5 : state, step ge s0 E0 s4 -> star ge s4 E0 s5 -> P s0 s5) (s1 s2 s3 : state) (H1 : step ge s1 E0 s3) (H3 : E0 = E0 ** E0) (H2 : star ge s3 E0 s2)","proofString":"eauto."},{"statement":"(ge : genv) (s : state) : exists n : nat, starN ge n s E0 s.","conclusion":"exists n : nat, starN ge n s E0 s","hypotheses":"(ge : genv) (s : state)","proofString":"exists O; constructor."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : exists n : nat, starN ge n s2 t2 s3) : exists n : nat, starN ge n s1 t s3.","conclusion":"exists n : nat, starN ge n s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : exists n : nat, starN ge n s2 t2 s3)","proofString":"destruct IHstar as [n P].\nexists (S n); econstructor; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (n : nat) (P : starN ge n s2 t2 s3) : exists n0 : nat, starN ge n0 s1 t s3.","conclusion":"exists n0 : nat, starN ge n0 s1 t s3","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (n : nat) (P : starN ge n s2 t2 s3)","proofString":"exists (S n); econstructor; eauto."},{"statement":"(ge : genv) (s : state) (T : traceinf) (H : forever ge s T) : forever ge s (E0 *** T).","conclusion":"forever ge s (E0 *** T)","hypotheses":"(ge : genv) (s : state) (T : traceinf) (H : forever ge s T)","proofString":"simpl.\nauto."},{"statement":"(ge : genv) (s : state) (T : traceinf) (H : forever ge s T) : forever ge s T.","conclusion":"forever ge s T","hypotheses":"(ge : genv) (s : state) (T : traceinf) (H : forever ge s T)","proofString":"auto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall T0 : traceinf, forever ge s3 T0 -> forever ge s2 (t2 *** T0)) (T : traceinf) (H2 : forever ge s3 T) : forever ge s1 (t *** T).","conclusion":"forever ge s1 (t *** T)","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (t : trace) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall T0 : traceinf, forever ge s3 T0 -> forever ge s2 (t2 *** T0)) (T : traceinf) (H2 : forever ge s3 T)","proofString":"subst t.\nrewrite Eappinf_assoc.\neconstructor; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : forall T0 : traceinf, forever ge s3 T0 -> forever ge s2 (t2 *** T0)) (T : traceinf) (H2 : forever ge s3 T) : forever ge s1 ((t1 ** t2) *** T).","conclusion":"forever ge s1 ((t1 ** t2) *** T)","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : forall T0 : traceinf, forever ge s3 T0 -> forever ge s2 (t2 *** T0)) (T : traceinf) (H2 : forever ge s3 T)","proofString":"rewrite Eappinf_assoc.\neconstructor; eauto."},{"statement":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : forall T0 : traceinf, forever ge s3 T0 -> forever ge s2 (t2 *** T0)) (T : traceinf) (H2 : forever ge s3 T) : forever ge s1 (t1 *** t2 *** T).","conclusion":"forever ge s1 (t1 *** t2 *** T)","hypotheses":"(ge : genv) (s1 : state) (t1 : trace) (s2 : state) (t2 : trace) (s3 : state) (H : step ge s1 t1 s2) (H0 : star ge s2 t2 s3) (IHstar : forall T0 : traceinf, forever ge s3 T0 -> forever ge s2 (t2 *** T0)) (T : traceinf) (H2 : forever ge s3 T)","proofString":"econstructor; eauto."},{"statement":"(ge : genv) (a0 : A) : forall (s : state) (T : traceinf),\nforever_N ge a0 s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T'.","conclusion":"forall (s : state) (T : traceinf),\nforever_N ge a0 s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T'","hypotheses":"(ge : genv) (a0 : A)","proofString":"pattern a0.\napply (well_founded_ind order_wf).\nintros.\ninv H0.\ninv H1.\nchange (E0 *** T2) with T2.\napply H with a2.\nauto.\nauto.\nexists t1; exists s0; exists x; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\neapply forever_N_star; eauto.\napply Eappinf_assoc.\ninv H1.\nexists t1; exists s0; exists a2; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\ninv H3.\nauto.\neapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 : A) : (fun a : A =>\n forall (s : state) (T : traceinf),\n forever_N ge a s T ->\n exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n   step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') a0.","conclusion":"(fun a : A =>\n forall (s : state) (T : traceinf),\n forever_N ge a s T ->\n exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n   step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') a0","hypotheses":"(ge : genv) (a0 : A)","proofString":"apply (well_founded_ind order_wf).\nintros.\ninv H0.\ninv H1.\nchange (E0 *** T2) with T2.\napply H with a2.\nauto.\nauto.\nexists t1; exists s0; exists x; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\neapply forever_N_star; eauto.\napply Eappinf_assoc.\ninv H1.\nexists t1; exists s0; exists a2; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\ninv H3.\nauto.\neapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 : A) : forall x : A,\n(forall y : A,\n order y x ->\n forall (s : state) (T : traceinf),\n forever_N ge y s T ->\n exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n   step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') ->\nforall (s : state) (T : traceinf),\nforever_N ge x s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T'.","conclusion":"forall x : A,\n(forall y : A,\n order y x ->\n forall (s : state) (T : traceinf),\n forever_N ge y s T ->\n exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n   step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') ->\nforall (s : state) (T : traceinf),\nforever_N ge x s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T'","hypotheses":"(ge : genv) (a0 : A)","proofString":"intros.\ninv H0.\ninv H1.\nchange (E0 *** T2) with T2.\napply H with a2.\nauto.\nauto.\nexists t1; exists s0; exists x; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\neapply forever_N_star; eauto.\napply Eappinf_assoc.\ninv H1.\nexists t1; exists s0; exists a2; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\ninv H3.\nauto.\neapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s0 : state) (T0 : traceinf),\nforever_N ge y s0 T0 ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s0 t s' /\\ forever_N ge a' s' T' /\\ T0 = t *** T') (s : state) (T : traceinf) (H0 : forever_N ge x s T) : exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T'.","conclusion":"exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s0 : state) (T0 : traceinf),\nforever_N ge y s0 T0 ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s0 t s' /\\ forever_N ge a' s' T' /\\ T0 = t *** T') (s : state) (T : traceinf) (H0 : forever_N ge x s T)","proofString":"inv H0.\ninv H1.\nchange (E0 *** T2) with T2.\napply H with a2.\nauto.\nauto.\nexists t1; exists s0; exists x; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\neapply forever_N_star; eauto.\napply Eappinf_assoc.\ninv H1.\nexists t1; exists s0; exists a2; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\ninv H3.\nauto.\neapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s0 : state) (T : traceinf),\nforever_N ge y s0 T ->\nexists (t0 : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s0 t0 s' /\\ forever_N ge a' s' T' /\\ T = t0 *** T') (s : state) (t : trace) (s2 : state) (a2 : A) (T2 : traceinf) (H1 : star ge s t s2) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) : exists (t0 : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t0 s' /\\ forever_N ge a' s' T' /\\ t *** T2 = t0 *** T'.","conclusion":"exists (t0 : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t0 s' /\\ forever_N ge a' s' T' /\\ t *** T2 = t0 *** T'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s0 : state) (T : traceinf),\nforever_N ge y s0 T ->\nexists (t0 : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s0 t0 s' /\\ forever_N ge a' s' T' /\\ T = t0 *** T') (s : state) (t : trace) (s2 : state) (a2 : A) (T2 : traceinf) (H1 : star ge s t s2) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2)","proofString":"inv H1.\nchange (E0 *** T2) with T2.\napply H with a2.\nauto.\nauto.\nexists t1; exists s0; exists x; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\neapply forever_N_star; eauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s : state) (T : traceinf),\nforever_N ge y s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) : exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s2 t s' /\\ forever_N ge a' s' T' /\\ E0 *** T2 = t *** T'.","conclusion":"exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s2 t s' /\\ forever_N ge a' s' T' /\\ E0 *** T2 = t *** T'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s : state) (T : traceinf),\nforever_N ge y s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2)","proofString":"change (E0 *** T2) with T2.\napply H with a2.\nauto.\nauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s : state) (T : traceinf),\nforever_N ge y s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) : exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s2 t s' /\\ forever_N ge a' s' T' /\\ T2 = t *** T'.","conclusion":"exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s2 t s' /\\ forever_N ge a' s' T' /\\ T2 = t *** T'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s : state) (T : traceinf),\nforever_N ge y s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2)","proofString":"apply H with a2.\nauto.\nauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s : state) (T : traceinf),\nforever_N ge y s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) : order a2 x.","conclusion":"order a2 x","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s : state) (T : traceinf),\nforever_N ge y s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s : state) (T : traceinf),\nforever_N ge y s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) : forever_N ge a2 s2 T2.","conclusion":"forever_N ge a2 s2 T2","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s : state) (T : traceinf),\nforever_N ge y s T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) : exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ (t1 ** t2) *** T2 = t *** T'.","conclusion":"exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ (t1 ** t2) *** T2 = t *** T'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2)","proofString":"exists t1; exists s0; exists x; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\neapply forever_N_star; eauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) : step ge s t1 s0 /\\\nforever_N ge x s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2.","conclusion":"step ge s t1 s0 /\\\nforever_N ge x s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2)","proofString":"split.\nauto.\nsplit.\neapply forever_N_star; eauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) : step ge s t1 s0.","conclusion":"step ge s t1 s0","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) : forever_N ge x s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2.","conclusion":"forever_N ge x s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2)","proofString":"split.\neapply forever_N_star; eauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) : forever_N ge x s0 (t2 *** T2).","conclusion":"forever_N ge x s0 (t2 *** T2)","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2)","proofString":"eapply forever_N_star; eauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) : (t1 ** t2) *** T2 = t1 *** t2 *** T2.","conclusion":"(t1 ** t2) *** T2 = t1 *** t2 *** T2","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : order a2 x) (H3 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2)","proofString":"apply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s0 : state) (T : traceinf),\nforever_N ge y s0 T ->\nexists (t0 : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s0 t0 s' /\\ forever_N ge a' s' T' /\\ T = t0 *** T') (s : state) (t : trace) (s2 : state) (a2 : A) (T2 : traceinf) (H1 : plus ge s t s2) (H2 : forever_N ge a2 s2 T2) : exists (t0 : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t0 s' /\\ forever_N ge a' s' T' /\\ t *** T2 = t0 *** T'.","conclusion":"exists (t0 : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t0 s' /\\ forever_N ge a' s' T' /\\ t *** T2 = t0 *** T'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s0 : state) (T : traceinf),\nforever_N ge y s0 T ->\nexists (t0 : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s0 t0 s' /\\ forever_N ge a' s' T' /\\ T = t0 *** T') (s : state) (t : trace) (s2 : state) (a2 : A) (T2 : traceinf) (H1 : plus ge s t s2) (H2 : forever_N ge a2 s2 T2)","proofString":"inv H1.\nexists t1; exists s0; exists a2; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\ninv H3.\nauto.\neapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) : exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ (t1 ** t2) *** T2 = t *** T'.","conclusion":"exists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s t s' /\\ forever_N ge a' s' T' /\\ (t1 ** t2) *** T2 = t *** T'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2)","proofString":"exists t1; exists s0; exists a2; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\ninv H3.\nauto.\neapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) : step ge s t1 s0 /\\\nforever_N ge a2 s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2.","conclusion":"step ge s t1 s0 /\\\nforever_N ge a2 s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2)","proofString":"split.\nauto.\nsplit.\ninv H3.\nauto.\neapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) : step ge s t1 s0.","conclusion":"step ge s t1 s0","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) : forever_N ge a2 s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2.","conclusion":"forever_N ge a2 s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2)","proofString":"split.\ninv H3.\nauto.\neapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto.\napply Eappinf_assoc."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) : forever_N ge a2 s0 (t2 *** T2).","conclusion":"forever_N ge a2 s0 (t2 *** T2)","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2)","proofString":"inv H3.\nauto.\neapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s0 : state) (T : traceinf),\nforever_N ge y s0 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s0 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (H0 : step ge s t1 s2) : forever_N ge a2 s2 (E0 *** T2).","conclusion":"forever_N ge a2 s2 (E0 *** T2)","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s0 : state) (T : traceinf),\nforever_N ge y s0 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s0 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (H0 : step ge s t1 s2)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (H0 : step ge s t1 s0) (t0 : trace) (s3 : state) (t3 : trace) (H1 : step ge s0 t0 s3) (H4 : star ge s3 t3 s2) : forever_N ge a2 s0 ((t0 ** t3) *** T2).","conclusion":"forever_N ge a2 s0 ((t0 ** t3) *** T2)","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (H0 : step ge s t1 s0) (t0 : trace) (s3 : state) (t3 : trace) (H1 : step ge s0 t0 s3) (H4 : star ge s3 t3 s2)","proofString":"eapply forever_N_plus.\neconstructor; eauto.\neauto.\nauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) : (t1 ** t2) *** T2 = t1 *** t2 *** T2.","conclusion":"(t1 ** t2) *** T2 = t1 *** t2 *** T2","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall (s1 : state) (T : traceinf),\nforever_N ge y s1 T ->\nexists (t : trace) (s' : state) (a' : A) (T' : traceinf),\n  step ge s1 t s' /\\ forever_N ge a' s' T' /\\ T = t *** T') (s s2 : state) (a2 : A) (T2 : traceinf) (H2 : forever_N ge a2 s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2)","proofString":"apply Eappinf_assoc."},{"statement":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T) : forever ge s T.","conclusion":"forever ge s T","hypotheses":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T)","proofString":"destruct (forever_N_inv H) as [t [s' [a' [T' [P [Q R]]]]]].\nrewrite R.\napply forever_intro with s'.\nauto.\napply COINDHYP with a'; auto."},{"statement":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T) (t : trace) (s' : state) (a' : A) (T' : traceinf) (P : step ge s t s') (Q : forever_N ge a' s' T') (R : T = t *** T') : forever ge s T.","conclusion":"forever ge s T","hypotheses":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T) (t : trace) (s' : state) (a' : A) (T' : traceinf) (P : step ge s t s') (Q : forever_N ge a' s' T') (R : T = t *** T')","proofString":"rewrite R.\napply forever_intro with s'.\nauto.\napply COINDHYP with a'; auto."},{"statement":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T) (t : trace) (s' : state) (a' : A) (T' : traceinf) (P : step ge s t s') (Q : forever_N ge a' s' T') (R : T = t *** T') : forever ge s (t *** T').","conclusion":"forever ge s (t *** T')","hypotheses":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T) (t : trace) (s' : state) (a' : A) (T' : traceinf) (P : step ge s t s') (Q : forever_N ge a' s' T') (R : T = t *** T')","proofString":"apply forever_intro with s'.\nauto.\napply COINDHYP with a'; auto."},{"statement":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T) (t : trace) (s' : state) (a' : A) (T' : traceinf) (P : step ge s t s') (Q : forever_N ge a' s' T') (R : T = t *** T') : step ge s t s'.","conclusion":"step ge s t s'","hypotheses":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T) (t : trace) (s' : state) (a' : A) (T' : traceinf) (P : step ge s t s') (Q : forever_N ge a' s' T') (R : T = t *** T')","proofString":"auto."},{"statement":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T) (t : trace) (s' : state) (a' : A) (T' : traceinf) (P : step ge s t s') (Q : forever_N ge a' s' T') (R : T = t *** T') : forever ge s' T'.","conclusion":"forever ge s' T'","hypotheses":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state) (T0 : traceinf),\nforever_N ge0 a0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (a : A) (s : state) (T : traceinf) (H : forever_N ge a s T) (t : trace) (s' : state) (a' : A) (T' : traceinf) (P : step ge s t s') (Q : forever_N ge a' s' T') (R : T = t *** T')","proofString":"apply COINDHYP with a'; auto."},{"statement":"(ge : genv) (s : state) (T : traceinf) (H : forever_plus ge s T) : exists (s' : state) (t : trace) (T' : traceinf),\n  step ge s t s' /\\ forever_plus ge s' T' /\\ T = t *** T'.","conclusion":"exists (s' : state) (t : trace) (T' : traceinf),\n  step ge s t s' /\\ forever_plus ge s' T' /\\ T = t *** T'","hypotheses":"(ge : genv) (s : state) (T : traceinf) (H : forever_plus ge s T)","proofString":"inv H.\ninv H0.\nexists s0; exists t1; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\nexploit star_inv; eauto.\nintros [[P Q] | R].\nsubst.\nsimpl.\nauto.\neconstructor; eauto.\ntraceEq."},{"statement":"(ge : genv) (s : state) (t : trace) (s2 : state) (T2 : traceinf) (H0 : plus ge s t s2) (H1 : forever_plus ge s2 T2) : exists (s' : state) (t0 : trace) (T' : traceinf),\n  step ge s t0 s' /\\ forever_plus ge s' T' /\\ t *** T2 = t0 *** T'.","conclusion":"exists (s' : state) (t0 : trace) (T' : traceinf),\n  step ge s t0 s' /\\ forever_plus ge s' T' /\\ t *** T2 = t0 *** T'","hypotheses":"(ge : genv) (s : state) (t : trace) (s2 : state) (T2 : traceinf) (H0 : plus ge s t s2) (H1 : forever_plus ge s2 T2)","proofString":"inv H0.\nexists s0; exists t1; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\nexploit star_inv; eauto.\nintros [[P Q] | R].\nsubst.\nsimpl.\nauto.\neconstructor; eauto.\ntraceEq."},{"statement":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) : exists (s' : state) (t : trace) (T' : traceinf),\n  step ge s t s' /\\ forever_plus ge s' T' /\\ (t1 ** t2) *** T2 = t *** T'.","conclusion":"exists (s' : state) (t : trace) (T' : traceinf),\n  step ge s t s' /\\ forever_plus ge s' T' /\\ (t1 ** t2) *** T2 = t *** T'","hypotheses":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2)","proofString":"exists s0; exists t1; exists (t2 *** T2).\nsplit.\nauto.\nsplit.\nexploit star_inv; eauto.\nintros [[P Q] | R].\nsubst.\nsimpl.\nauto.\neconstructor; eauto.\ntraceEq."},{"statement":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) : step ge s t1 s0 /\\\nforever_plus ge s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2.","conclusion":"step ge s t1 s0 /\\\nforever_plus ge s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2","hypotheses":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2)","proofString":"split.\nauto.\nsplit.\nexploit star_inv; eauto.\nintros [[P Q] | R].\nsubst.\nsimpl.\nauto.\neconstructor; eauto.\ntraceEq."},{"statement":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) : step ge s t1 s0.","conclusion":"step ge s t1 s0","hypotheses":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2)","proofString":"auto."},{"statement":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) : forever_plus ge s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2.","conclusion":"forever_plus ge s0 (t2 *** T2) /\\ (t1 ** t2) *** T2 = t1 *** t2 *** T2","hypotheses":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2)","proofString":"split.\nexploit star_inv; eauto.\nintros [[P Q] | R].\nsubst.\nsimpl.\nauto.\neconstructor; eauto.\ntraceEq."},{"statement":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) : forever_plus ge s0 (t2 *** T2).","conclusion":"forever_plus ge s0 (t2 *** T2)","hypotheses":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2)","proofString":"exploit star_inv; eauto.\nintros [[P Q] | R].\nsubst.\nsimpl.\nauto.\neconstructor; eauto."},{"statement":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) : s2 = s0 /\\ t2 = E0 \\/ plus ge s0 t2 s2 -> forever_plus ge s0 (t2 *** T2).","conclusion":"s2 = s0 /\\ t2 = E0 \\/ plus ge s0 t2 s2 -> forever_plus ge s0 (t2 *** T2)","hypotheses":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2)","proofString":"intros [[P Q] | R].\nsubst.\nsimpl.\nauto.\neconstructor; eauto."},{"statement":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) (P : s2 = s0) (Q : t2 = E0) : forever_plus ge s0 (t2 *** T2).","conclusion":"forever_plus ge s0 (t2 *** T2)","hypotheses":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) (P : s2 = s0) (Q : t2 = E0)","proofString":"subst.\nsimpl.\nauto."},{"statement":"(ge : genv) (s : state) (T2 : traceinf) (s0 : state) (H1 : forever_plus ge s0 T2) (t1 : trace) (H : step ge s t1 s0) (H2 : star ge s0 E0 s0) : forever_plus ge s0 (E0 *** T2).","conclusion":"forever_plus ge s0 (E0 *** T2)","hypotheses":"(ge : genv) (s : state) (T2 : traceinf) (s0 : state) (H1 : forever_plus ge s0 T2) (t1 : trace) (H : step ge s t1 s0) (H2 : star ge s0 E0 s0)","proofString":"simpl.\nauto."},{"statement":"(ge : genv) (s : state) (T2 : traceinf) (s0 : state) (H1 : forever_plus ge s0 T2) (t1 : trace) (H : step ge s t1 s0) (H2 : star ge s0 E0 s0) : forever_plus ge s0 T2.","conclusion":"forever_plus ge s0 T2","hypotheses":"(ge : genv) (s : state) (T2 : traceinf) (s0 : state) (H1 : forever_plus ge s0 T2) (t1 : trace) (H : step ge s t1 s0) (H2 : star ge s0 E0 s0)","proofString":"auto."},{"statement":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) (R : plus ge s0 t2 s2) : forever_plus ge s0 (t2 *** T2).","conclusion":"forever_plus ge s0 (t2 *** T2)","hypotheses":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) (R : plus ge s0 t2 s2)","proofString":"econstructor; eauto."},{"statement":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2) : (t1 ** t2) *** T2 = t1 *** t2 *** T2.","conclusion":"(t1 ** t2) *** T2 = t1 *** t2 *** T2","hypotheses":"(ge : genv) (s s2 : state) (T2 : traceinf) (H1 : forever_plus ge s2 T2) (t1 : trace) (s0 : state) (t2 : trace) (H : step ge s t1 s0) (H2 : star ge s0 t2 s2)","proofString":"traceEq."},{"statement":"(COINDHYP : forall (ge0 : genv) (s0 : state) (T0 : traceinf),\nforever_plus ge0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (s : state) (T : traceinf) (H : forever_plus ge s T) : forever ge s T.","conclusion":"forever ge s T","hypotheses":"(COINDHYP : forall (ge0 : genv) (s0 : state) (T0 : traceinf),\nforever_plus ge0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (s : state) (T : traceinf) (H : forever_plus ge s T)","proofString":"destruct (forever_plus_inv H) as [s' [t [T' [P [Q R]]]]].\nsubst.\neconstructor; eauto."},{"statement":"(COINDHYP : forall (ge0 : genv) (s0 : state) (T0 : traceinf),\nforever_plus ge0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (s : state) (T : traceinf) (H : forever_plus ge s T) (s' : state) (t : trace) (T' : traceinf) (P : step ge s t s') (Q : forever_plus ge s' T') (R : T = t *** T') : forever ge s T.","conclusion":"forever ge s T","hypotheses":"(COINDHYP : forall (ge0 : genv) (s0 : state) (T0 : traceinf),\nforever_plus ge0 s0 T0 -> forever ge0 s0 T0) (ge : genv) (s : state) (T : traceinf) (H : forever_plus ge s T) (s' : state) (t : trace) (T' : traceinf) (P : step ge s t s') (Q : forever_plus ge s' T') (R : T = t *** T')","proofString":"subst.\neconstructor; eauto."},{"statement":"(COINDHYP : forall (ge0 : genv) (s0 : state) (T : traceinf),\nforever_plus ge0 s0 T -> forever ge0 s0 T) (ge : genv) (s : state) (t : trace) (T' : traceinf) (H : forever_plus ge s (t *** T')) (s' : state) (P : step ge s t s') (Q : forever_plus ge s' T') : forever ge s (t *** T').","conclusion":"forever ge s (t *** T')","hypotheses":"(COINDHYP : forall (ge0 : genv) (s0 : state) (T : traceinf),\nforever_plus ge0 s0 T -> forever ge0 s0 T) (ge : genv) (s : state) (t : trace) (T' : traceinf) (H : forever_plus ge s (t *** T')) (s' : state) (P : step ge s t s') (Q : forever_plus ge s' T')","proofString":"econstructor; eauto."},{"statement":"(ge : genv) (a0 : A) : forall s : state,\nforever_silent_N ge a0 s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"forall s : state,\nforever_silent_N ge a0 s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 : A)","proofString":"pattern a0.\napply (well_founded_ind order_wf).\nintros.\ninv H0.\ninv H1.\napply H with a2.\nauto.\nauto.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists x.\nsplit.\nauto.\neapply forever_silent_N_star; eauto.\ninv H1.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists a2.\nsplit.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 : A) : (fun a : A =>\n forall s : state,\n forever_silent_N ge a s ->\n exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s')\n  a0.","conclusion":"(fun a : A =>\n forall s : state,\n forever_silent_N ge a s ->\n exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s')\n  a0","hypotheses":"(ge : genv) (a0 : A)","proofString":"apply (well_founded_ind order_wf).\nintros.\ninv H0.\ninv H1.\napply H with a2.\nauto.\nauto.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists x.\nsplit.\nauto.\neapply forever_silent_N_star; eauto.\ninv H1.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists a2.\nsplit.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 : A) : forall x : A,\n(forall y : A,\n order y x ->\n forall s : state,\n forever_silent_N ge y s ->\n exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s') ->\nforall s : state,\nforever_silent_N ge x s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"forall x : A,\n(forall y : A,\n order y x ->\n forall s : state,\n forever_silent_N ge y s ->\n exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s') ->\nforall s : state,\nforever_silent_N ge x s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 : A)","proofString":"intros.\ninv H0.\ninv H1.\napply H with a2.\nauto.\nauto.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists x.\nsplit.\nauto.\neapply forever_silent_N_star; eauto.\ninv H1.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists a2.\nsplit.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s0 : state,\nforever_silent_N ge y s0 ->\nexists (s' : state) (a' : A), step ge s0 E0 s' /\\ forever_silent_N ge a' s') (s : state) (H0 : forever_silent_N ge x s) : exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s0 : state,\nforever_silent_N ge y s0 ->\nexists (s' : state) (a' : A), step ge s0 E0 s' /\\ forever_silent_N ge a' s') (s : state) (H0 : forever_silent_N ge x s)","proofString":"inv H0.\ninv H1.\napply H with a2.\nauto.\nauto.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists x.\nsplit.\nauto.\neapply forever_silent_N_star; eauto.\ninv H1.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists a2.\nsplit.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s0 : state,\nforever_silent_N ge y s0 ->\nexists (s' : state) (a' : A), step ge s0 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H1 : star ge s E0 s2) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) : exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s0 : state,\nforever_silent_N ge y s0 ->\nexists (s' : state) (a' : A), step ge s0 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H1 : star ge s E0 s2) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2)","proofString":"inv H1.\napply H with a2.\nauto.\nauto.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists x.\nsplit.\nauto.\neapply forever_silent_N_star; eauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s : state,\nforever_silent_N ge y s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s') (s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) : exists (s' : state) (a' : A), step ge s2 E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s2 E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s : state,\nforever_silent_N ge y s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s') (s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2)","proofString":"apply H with a2.\nauto.\nauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s : state,\nforever_silent_N ge y s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s') (s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) : order a2 x.","conclusion":"order a2 x","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s : state,\nforever_silent_N ge y s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s') (s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s : state,\nforever_silent_N ge y s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s') (s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) : forever_silent_N ge a2 s2.","conclusion":"forever_silent_N ge a2 s2","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s : state,\nforever_silent_N ge y s ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s') (s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) (H5 : E0 = t1 ** t2) : exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) (H5 : E0 = t1 ** t2)","proofString":"exploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists x.\nsplit.\nauto.\neapply forever_silent_N_star; eauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) (H5 : E0 = t1 ** t2) : t1 = E0 /\\ t2 = E0 ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"t1 = E0 /\\ t2 = E0 ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) (H5 : E0 = t1 ** t2)","proofString":"intros [P Q].\nsubst.\nexists s0; exists x.\nsplit.\nauto.\neapply forever_silent_N_star; eauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) (H5 : E0 = t1 ** t2) (P : t1 = E0) (Q : t2 = E0) : exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H4 : star ge s0 t2 s2) (H5 : E0 = t1 ** t2) (P : t1 = E0) (Q : t2 = E0)","proofString":"subst.\nexists s0; exists x.\nsplit.\nauto.\neapply forever_silent_N_star; eauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H5 : E0 = E0 ** E0) (H4 : star ge s0 E0 s2) : exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H5 : E0 = E0 ** E0) (H4 : star ge s0 E0 s2)","proofString":"exists s0; exists x.\nsplit.\nauto.\neapply forever_silent_N_star; eauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H5 : E0 = E0 ** E0) (H4 : star ge s0 E0 s2) : step ge s E0 s0 /\\ forever_silent_N ge x s0.","conclusion":"step ge s E0 s0 /\\ forever_silent_N ge x s0","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H5 : E0 = E0 ** E0) (H4 : star ge s0 E0 s2)","proofString":"split.\nauto.\neapply forever_silent_N_star; eauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H5 : E0 = E0 ** E0) (H4 : star ge s0 E0 s2) : step ge s E0 s0.","conclusion":"step ge s E0 s0","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H5 : E0 = E0 ** E0) (H4 : star ge s0 E0 s2)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H5 : E0 = E0 ** E0) (H4 : star ge s0 E0 s2) : forever_silent_N ge x s0.","conclusion":"forever_silent_N ge x s0","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : order a2 x) (H3 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H5 : E0 = E0 ** E0) (H4 : star ge s0 E0 s2)","proofString":"eapply forever_silent_N_star; eauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s0 : state,\nforever_silent_N ge y s0 ->\nexists (s' : state) (a' : A), step ge s0 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H1 : plus ge s E0 s2) (H2 : forever_silent_N ge a2 s2) : exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s0 : state,\nforever_silent_N ge y s0 ->\nexists (s' : state) (a' : A), step ge s0 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H1 : plus ge s E0 s2) (H2 : forever_silent_N ge a2 s2)","proofString":"inv H1.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists a2.\nsplit.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) (H4 : E0 = t1 ** t2) : exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) (H4 : E0 = t1 ** t2)","proofString":"exploit Eapp_E0_inv; eauto.\nintros [P Q].\nsubst.\nexists s0; exists a2.\nsplit.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) (H4 : E0 = t1 ** t2) : t1 = E0 /\\ t2 = E0 ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"t1 = E0 /\\ t2 = E0 ->\nexists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) (H4 : E0 = t1 ** t2)","proofString":"intros [P Q].\nsubst.\nexists s0; exists a2.\nsplit.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) (H4 : E0 = t1 ** t2) (P : t1 = E0) (Q : t2 = E0) : exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (t1 : trace) (s0 : state) (t2 : trace) (H0 : step ge s t1 s0) (H3 : star ge s0 t2 s2) (H4 : E0 = t1 ** t2) (P : t1 = E0) (Q : t2 = E0)","proofString":"subst.\nexists s0; exists a2.\nsplit.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (H3 : star ge s0 E0 s2) : exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'.","conclusion":"exists (s' : state) (a' : A), step ge s E0 s' /\\ forever_silent_N ge a' s'","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (H3 : star ge s0 E0 s2)","proofString":"exists s0; exists a2.\nsplit.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (H3 : star ge s0 E0 s2) : step ge s E0 s0 /\\ forever_silent_N ge a2 s0.","conclusion":"step ge s E0 s0 /\\ forever_silent_N ge a2 s0","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (H3 : star ge s0 E0 s2)","proofString":"split.\nauto.\ninv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (H3 : star ge s0 E0 s2) : step ge s E0 s0.","conclusion":"step ge s E0 s0","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (H3 : star ge s0 E0 s2)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (H3 : star ge s0 E0 s2) : forever_silent_N ge a2 s0.","conclusion":"forever_silent_N ge a2 s0","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (H3 : star ge s0 E0 s2)","proofString":"inv H3.\nauto.\neapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s0 : state,\nforever_silent_N ge y s0 ->\nexists (s' : state) (a' : A), step ge s0 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (H0 : step ge s E0 s2) (H4 : E0 = E0 ** E0) : forever_silent_N ge a2 s2.","conclusion":"forever_silent_N ge a2 s2","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s0 : state,\nforever_silent_N ge y s0 ->\nexists (s' : state) (a' : A), step ge s0 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (H0 : step ge s E0 s2) (H4 : E0 = E0 ** E0)","proofString":"auto."},{"statement":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (t1 : trace) (s3 : state) (t2 : trace) (H1 : step ge s0 t1 s3) (H5 : star ge s3 t2 s2) (H6 : E0 = t1 ** t2) : forever_silent_N ge a2 s0.","conclusion":"forever_silent_N ge a2 s0","hypotheses":"(ge : genv) (a0 x : A) (H : forall y : A,\norder y x ->\nforall s1 : state,\nforever_silent_N ge y s1 ->\nexists (s' : state) (a' : A), step ge s1 E0 s' /\\ forever_silent_N ge a' s') (s s2 : state) (a2 : A) (H2 : forever_silent_N ge a2 s2) (s0 : state) (H0 : step ge s E0 s0) (H4 : E0 = E0 ** E0) (t1 : trace) (s3 : state) (t2 : trace) (H1 : step ge s0 t1 s3) (H5 : star ge s3 t2 s2) (H6 : E0 = t1 ** t2)","proofString":"eapply forever_silent_N_plus.\neconstructor; eauto.\neauto."},{"statement":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state),\nforever_silent_N ge0 a0 s0 -> forever_silent ge0 s0) (ge : genv) (a : A) (s : state) (H : forever_silent_N ge a s) : forever_silent ge s.","conclusion":"forever_silent ge s","hypotheses":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state),\nforever_silent_N ge0 a0 s0 -> forever_silent ge0 s0) (ge : genv) (a : A) (s : state) (H : forever_silent_N ge a s)","proofString":"destruct (forever_silent_N_inv H) as [s' [a' [P Q]]].\napply forever_silent_intro with s'.\nauto.\napply COINDHYP with a'; auto."},{"statement":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state),\nforever_silent_N ge0 a0 s0 -> forever_silent ge0 s0) (ge : genv) (a : A) (s : state) (H : forever_silent_N ge a s) (s' : state) (a' : A) (P : step ge s E0 s') (Q : forever_silent_N ge a' s') : forever_silent ge s.","conclusion":"forever_silent ge s","hypotheses":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state),\nforever_silent_N ge0 a0 s0 -> forever_silent ge0 s0) (ge : genv) (a : A) (s : state) (H : forever_silent_N ge a s) (s' : state) (a' : A) (P : step ge s E0 s') (Q : forever_silent_N ge a' s')","proofString":"apply forever_silent_intro with s'.\nauto.\napply COINDHYP with a'; auto."},{"statement":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state),\nforever_silent_N ge0 a0 s0 -> forever_silent ge0 s0) (ge : genv) (a : A) (s : state) (H : forever_silent_N ge a s) (s' : state) (a' : A) (P : step ge s E0 s') (Q : forever_silent_N ge a' s') : step ge s E0 s'.","conclusion":"step ge s E0 s'","hypotheses":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state),\nforever_silent_N ge0 a0 s0 -> forever_silent ge0 s0) (ge : genv) (a : A) (s : state) (H : forever_silent_N ge a s) (s' : state) (a' : A) (P : step ge s E0 s') (Q : forever_silent_N ge a' s')","proofString":"auto."},{"statement":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state),\nforever_silent_N ge0 a0 s0 -> forever_silent ge0 s0) (ge : genv) (a : A) (s : state) (H : forever_silent_N ge a s) (s' : state) (a' : A) (P : step ge s E0 s') (Q : forever_silent_N ge a' s') : forever_silent ge s'.","conclusion":"forever_silent ge s'","hypotheses":"(COINDHYP : forall (ge0 : genv) (a0 : A) (s0 : state),\nforever_silent_N ge0 a0 s0 -> forever_silent ge0 s0) (ge : genv) (a : A) (s : state) (H : forever_silent_N ge a s) (s' : state) (a' : A) (P : step ge s E0 s') (Q : forever_silent_N ge a' s')","proofString":"apply COINDHYP with a'; auto."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (T : traceinf) (H : star ge s1 t s2) (H0 : forever_reactive ge s2 T) : forever_reactive ge s1 (t *** T).","conclusion":"forever_reactive ge s1 (t *** T)","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (T : traceinf) (H : star ge s1 t s2) (H0 : forever_reactive ge s2 T)","proofString":"inv H0.\nrewrite <- Eappinf_assoc.\neconstructor.\neapply star_trans; eauto.\nred; intro.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\ncontradiction.\nauto."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0) : forever_reactive ge s1 (t *** t0 *** T0).","conclusion":"forever_reactive ge s1 (t *** t0 *** T0)","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0)","proofString":"rewrite <- Eappinf_assoc.\neconstructor.\neapply star_trans; eauto.\nred; intro.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\ncontradiction.\nauto."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0) : forever_reactive ge s1 ((t ** t0) *** T0).","conclusion":"forever_reactive ge s1 ((t ** t0) *** T0)","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0)","proofString":"econstructor.\neapply star_trans; eauto.\nred; intro.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\ncontradiction.\nauto."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0) : t ** t0 <> E0.","conclusion":"t ** t0 <> E0","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0)","proofString":"red; intro.\nexploit Eapp_E0_inv; eauto.\nintros [P Q].\ncontradiction."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0) (H0 : t ** t0 = E0) : False.","conclusion":"False","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0) (H0 : t ** t0 = E0)","proofString":"exploit Eapp_E0_inv; eauto.\nintros [P Q].\ncontradiction."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0) (H0 : t ** t0 = E0) : t = E0 /\\ t0 = E0 -> False.","conclusion":"t = E0 /\\ t0 = E0 -> False","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0) (H0 : t ** t0 = E0)","proofString":"intros [P Q].\ncontradiction."},{"statement":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0) (H0 : t ** t0 = E0) (P : t = E0) (Q : t0 = E0) : False.","conclusion":"False","hypotheses":"(ge : genv) (s1 : state) (t : trace) (s2 : state) (H : star ge s1 t s2) (s3 : state) (t0 : trace) (T0 : traceinf) (H1 : star ge s2 t0 s3) (H2 : t0 <> E0) (H3 : forever_reactive ge s3 T0) (H0 : t ** t0 = E0) (P : t = E0) (Q : t0 = E0)","proofString":"contradiction."},{"statement":"(ge : genv) (s : state) (P : state -> Prop) (H : forall r : int, ~ final_state s r) (H0 : forall (t : trace) (s' : state), step ge s t s' -> t = E0 /\\ P s') : eventually ge 1 s P.","conclusion":"eventually ge 1 s P","hypotheses":"(ge : genv) (s : state) (P : state -> Prop) (H : forall r : int, ~ final_state s r) (H0 : forall (t : trace) (s' : state), step ge s t s' -> t = E0 /\\ P s')","proofString":"apply eventually_later; auto.\nintros.\napply H0 in H1.\nintuition auto using eventually."},{"statement":"(ge : genv) (s : state) (P : state -> Prop) (H : forall r : int, ~ final_state s r) (H0 : forall (t : trace) (s' : state), step ge s t s' -> t = E0 /\\ P s') : forall (t : trace) (s' : state),\nstep ge s t s' -> t = E0 /\\ eventually ge 0 s' P.","conclusion":"forall (t : trace) (s' : state),\nstep ge s t s' -> t = E0 /\\ eventually ge 0 s' P","hypotheses":"(ge : genv) (s : state) (P : state -> Prop) (H : forall r : int, ~ final_state s r) (H0 : forall (t : trace) (s' : state), step ge s t s' -> t = E0 /\\ P s')","proofString":"intros.\napply H0 in H1.\nintuition auto using eventually."},{"statement":"(ge : genv) (s : state) (P : state -> Prop) (H : forall r : int, ~ final_state s r) (H0 : forall (t0 : trace) (s'0 : state), step ge s t0 s'0 -> t0 = E0 /\\ P s'0) (t : trace) (s' : state) (H1 : step ge s t s') : t = E0 /\\ eventually ge 0 s' P.","conclusion":"t = E0 /\\ eventually ge 0 s' P","hypotheses":"(ge : genv) (s : state) (P : state -> Prop) (H : forall r : int, ~ final_state s r) (H0 : forall (t0 : trace) (s'0 : state), step ge s t0 s'0 -> t0 = E0 /\\ P s'0) (t : trace) (s' : state) (H1 : step ge s t s')","proofString":"apply H0 in H1.\nintuition auto using eventually."},{"statement":"(ge : genv) (s : state) (P : state -> Prop) (H : forall r : int, ~ final_state s r) (H0 : forall (t0 : trace) (s'0 : state), step ge s t0 s'0 -> t0 = E0 /\\ P s'0) (t : trace) (s' : state) (H1 : t = E0 /\\ P s') : t = E0 /\\ eventually ge 0 s' P.","conclusion":"t = E0 /\\ eventually ge 0 s' P","hypotheses":"(ge : genv) (s : state) (P : state -> Prop) (H : forall r : int, ~ final_state s r) (H0 : forall (t0 : trace) (s'0 : state), step ge s t0 s'0 -> t0 = E0 /\\ P s'0) (t : trace) (s' : state) (H1 : t = E0 /\\ P s')","proofString":"intuition auto using eventually."},{"statement":"(ge : genv) (n1 : nat) (s1 : state) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H : eventually ge n1 s1 P1) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) : eventually ge (n1 + n2) s1 P2.","conclusion":"eventually ge (n1 + n2) s1 P2","hypotheses":"(ge : genv) (n1 : nat) (s1 : state) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H : eventually ge n1 s1 P1) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2)","proofString":"revert n1 s1 H.\ninduction n1; intros s1 EV; inv EV; simpl.\napply H0; assumption.\napply eventually_later; auto.\nintros t s' ST.\ndestruct (H2 t s' ST) as [U V].\nauto."},{"statement":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) : forall (n1 : nat) (s1 : state),\neventually ge n1 s1 P1 -> eventually ge (n1 + n2) s1 P2.","conclusion":"forall (n1 : nat) (s1 : state),\neventually ge n1 s1 P1 -> eventually ge (n1 + n2) s1 P2","hypotheses":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2)","proofString":"induction n1; intros s1 EV; inv EV; simpl.\napply H0; assumption.\napply eventually_later; auto.\nintros t s' ST.\ndestruct (H2 t s' ST) as [U V].\nauto."},{"statement":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (s1 : state) (H : P1 s1) : eventually ge n2 s1 P2.","conclusion":"eventually ge n2 s1 P2","hypotheses":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (s1 : state) (H : P1 s1)","proofString":"apply H0; assumption."},{"statement":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (n1 : nat) (IHn1 : forall s0 : state, eventually ge n1 s0 P1 -> eventually ge (n1 + n2) s0 P2) (s1 : state) (H1 : forall r : int, ~ final_state s1 r) (H2 : forall (t : trace) (s' : state),\nstep ge s1 t s' -> t = E0 /\\ eventually ge n1 s' P1) : eventually ge (S (n1 + n2)) s1 P2.","conclusion":"eventually ge (S (n1 + n2)) s1 P2","hypotheses":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (n1 : nat) (IHn1 : forall s0 : state, eventually ge n1 s0 P1 -> eventually ge (n1 + n2) s0 P2) (s1 : state) (H1 : forall r : int, ~ final_state s1 r) (H2 : forall (t : trace) (s' : state),\nstep ge s1 t s' -> t = E0 /\\ eventually ge n1 s' P1)","proofString":"apply eventually_later; auto.\nintros t s' ST.\ndestruct (H2 t s' ST) as [U V].\nauto."},{"statement":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (n1 : nat) (IHn1 : forall s0 : state, eventually ge n1 s0 P1 -> eventually ge (n1 + n2) s0 P2) (s1 : state) (H1 : forall r : int, ~ final_state s1 r) (H2 : forall (t : trace) (s' : state),\nstep ge s1 t s' -> t = E0 /\\ eventually ge n1 s' P1) : forall (t : trace) (s' : state),\nstep ge s1 t s' -> t = E0 /\\ eventually ge (n1 + n2) s' P2.","conclusion":"forall (t : trace) (s' : state),\nstep ge s1 t s' -> t = E0 /\\ eventually ge (n1 + n2) s' P2","hypotheses":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (n1 : nat) (IHn1 : forall s0 : state, eventually ge n1 s0 P1 -> eventually ge (n1 + n2) s0 P2) (s1 : state) (H1 : forall r : int, ~ final_state s1 r) (H2 : forall (t : trace) (s' : state),\nstep ge s1 t s' -> t = E0 /\\ eventually ge n1 s' P1)","proofString":"intros t s' ST.\ndestruct (H2 t s' ST) as [U V].\nauto."},{"statement":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (n1 : nat) (IHn1 : forall s0 : state, eventually ge n1 s0 P1 -> eventually ge (n1 + n2) s0 P2) (s1 : state) (H1 : forall r : int, ~ final_state s1 r) (H2 : forall (t0 : trace) (s'0 : state),\nstep ge s1 t0 s'0 -> t0 = E0 /\\ eventually ge n1 s'0 P1) (t : trace) (s' : state) (ST : step ge s1 t s') : t = E0 /\\ eventually ge (n1 + n2) s' P2.","conclusion":"t = E0 /\\ eventually ge (n1 + n2) s' P2","hypotheses":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (n1 : nat) (IHn1 : forall s0 : state, eventually ge n1 s0 P1 -> eventually ge (n1 + n2) s0 P2) (s1 : state) (H1 : forall r : int, ~ final_state s1 r) (H2 : forall (t0 : trace) (s'0 : state),\nstep ge s1 t0 s'0 -> t0 = E0 /\\ eventually ge n1 s'0 P1) (t : trace) (s' : state) (ST : step ge s1 t s')","proofString":"destruct (H2 t s' ST) as [U V].\nauto."},{"statement":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (n1 : nat) (IHn1 : forall s0 : state, eventually ge n1 s0 P1 -> eventually ge (n1 + n2) s0 P2) (s1 : state) (H1 : forall r : int, ~ final_state s1 r) (H2 : forall (t0 : trace) (s'0 : state),\nstep ge s1 t0 s'0 -> t0 = E0 /\\ eventually ge n1 s'0 P1) (t : trace) (s' : state) (ST : step ge s1 t s') (U : t = E0) (V : eventually ge n1 s' P1) : t = E0 /\\ eventually ge (n1 + n2) s' P2.","conclusion":"t = E0 /\\ eventually ge (n1 + n2) s' P2","hypotheses":"(ge : genv) (P1 : state -> Prop) (n2 : nat) (P2 : state -> Prop) (H0 : forall s2 : state, P1 s2 -> eventually ge n2 s2 P2) (n1 : nat) (IHn1 : forall s0 : state, eventually ge n1 s0 P1 -> eventually ge (n1 + n2) s0 P2) (s1 : state) (H1 : forall r : int, ~ final_state s1 r) (H2 : forall (t0 : trace) (s'0 : state),\nstep ge s1 t0 s'0 -> t0 = E0 /\\ eventually ge n1 s'0 P1) (t : trace) (s' : state) (ST : step ge s1 t s') (U : t = E0) (V : eventually ge n1 s' P1)","proofString":"auto."},{"statement":"(ge : genv) (n : nat) (s : state) (P1 P2 : state -> Prop) (H : eventually ge n s P1) (H0 : forall s0 : state, P1 s0 -> P2 s0) : eventually ge n s P2.","conclusion":"eventually ge n s P2","hypotheses":"(ge : genv) (n : nat) (s : state) (P1 P2 : state -> Prop) (H : eventually ge n s P1) (H0 : forall s0 : state, P1 s0 -> P2 s0)","proofString":"replace n with (n + 0)%nat by lia.\neapply eventually_trans; eauto using eventually_now."},{"statement":"(ge : genv) (n : nat) (s : state) (P1 P2 : state -> Prop) (H : eventually ge n s P1) (H0 : forall s0 : state, P1 s0 -> P2 s0) : eventually ge (n + 0) s P2.","conclusion":"eventually ge (n + 0) s P2","hypotheses":"(ge : genv) (n : nat) (s : state) (P1 P2 : state -> Prop) (H : eventually ge n s P1) (H0 : forall s0 : state, P1 s0 -> P2 s0)","proofString":"eapply eventually_trans; eauto using eventually_now."},{"statement":"(ge : genv) (Inv : state -> Prop) (n : nat) (s : state) (P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (H0 : eventually ge n s P) (H1 : Inv s) : eventually ge n s (fun s' : state => P s' /\\ Inv s').","conclusion":"eventually ge n s (fun s' : state => P s' /\\ Inv s')","hypotheses":"(ge : genv) (Inv : state -> Prop) (n : nat) (s : state) (P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (H0 : eventually ge n s P) (H1 : Inv s)","proofString":"revert n s H0 H1.\ninduction n; intros s EV IV; inv EV.\napply eventually_now.\nauto.\napply eventually_later; auto.\nintros.\nedestruct H2; eauto."},{"statement":"(ge : genv) (Inv P : state -> Prop) (H : forall (s : state) (t : trace) (s' : state),\nstep ge s t s' -> Inv s -> Inv s') : forall (n : nat) (s : state),\neventually ge n s P ->\nInv s -> eventually ge n s (fun s' : state => P s' /\\ Inv s').","conclusion":"forall (n : nat) (s : state),\neventually ge n s P ->\nInv s -> eventually ge n s (fun s' : state => P s' /\\ Inv s')","hypotheses":"(ge : genv) (Inv P : state -> Prop) (H : forall (s : state) (t : trace) (s' : state),\nstep ge s t s' -> Inv s -> Inv s')","proofString":"induction n; intros s EV IV; inv EV.\napply eventually_now.\nauto.\napply eventually_later; auto.\nintros.\nedestruct H2; eauto."},{"statement":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (s : state) (IV : Inv s) (H0 : P s) : eventually ge 0 s (fun s' : state => P s' /\\ Inv s').","conclusion":"eventually ge 0 s (fun s' : state => P s' /\\ Inv s')","hypotheses":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (s : state) (IV : Inv s) (H0 : P s)","proofString":"apply eventually_now.\nauto."},{"statement":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (s : state) (IV : Inv s) (H0 : P s) : P s /\\ Inv s.","conclusion":"P s /\\ Inv s","hypotheses":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (s : state) (IV : Inv s) (H0 : P s)","proofString":"auto."},{"statement":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (n : nat) (IHn : forall s0 : state,\neventually ge n s0 P ->\nInv s0 -> eventually ge n s0 (fun s' : state => P s' /\\ Inv s')) (s : state) (IV : Inv s) (H1 : forall r : int, ~ final_state s r) (H2 : forall (t : trace) (s' : state),\nstep ge s t s' -> t = E0 /\\ eventually ge n s' P) : eventually ge (S n) s (fun s' : state => P s' /\\ Inv s').","conclusion":"eventually ge (S n) s (fun s' : state => P s' /\\ Inv s')","hypotheses":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (n : nat) (IHn : forall s0 : state,\neventually ge n s0 P ->\nInv s0 -> eventually ge n s0 (fun s' : state => P s' /\\ Inv s')) (s : state) (IV : Inv s) (H1 : forall r : int, ~ final_state s r) (H2 : forall (t : trace) (s' : state),\nstep ge s t s' -> t = E0 /\\ eventually ge n s' P)","proofString":"apply eventually_later; auto.\nintros.\nedestruct H2; eauto."},{"statement":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (n : nat) (IHn : forall s0 : state,\neventually ge n s0 P ->\nInv s0 -> eventually ge n s0 (fun s' : state => P s' /\\ Inv s')) (s : state) (IV : Inv s) (H1 : forall r : int, ~ final_state s r) (H2 : forall (t : trace) (s' : state),\nstep ge s t s' -> t = E0 /\\ eventually ge n s' P) : forall (t : trace) (s' : state),\nstep ge s t s' ->\nt = E0 /\\ eventually ge n s' (fun s'0 : state => P s'0 /\\ Inv s'0).","conclusion":"forall (t : trace) (s' : state),\nstep ge s t s' ->\nt = E0 /\\ eventually ge n s' (fun s'0 : state => P s'0 /\\ Inv s'0)","hypotheses":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t : trace) (s' : state),\nstep ge s0 t s' -> Inv s0 -> Inv s') (n : nat) (IHn : forall s0 : state,\neventually ge n s0 P ->\nInv s0 -> eventually ge n s0 (fun s' : state => P s' /\\ Inv s')) (s : state) (IV : Inv s) (H1 : forall r : int, ~ final_state s r) (H2 : forall (t : trace) (s' : state),\nstep ge s t s' -> t = E0 /\\ eventually ge n s' P)","proofString":"intros.\nedestruct H2; eauto."},{"statement":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t0 : trace) (s'0 : state),\nstep ge s0 t0 s'0 -> Inv s0 -> Inv s'0) (n : nat) (IHn : forall s0 : state,\neventually ge n s0 P ->\nInv s0 -> eventually ge n s0 (fun s'0 : state => P s'0 /\\ Inv s'0)) (s : state) (IV : Inv s) (H1 : forall r : int, ~ final_state s r) (H2 : forall (t0 : trace) (s'0 : state),\nstep ge s t0 s'0 -> t0 = E0 /\\ eventually ge n s'0 P) (t : trace) (s' : state) (H0 : step ge s t s') : t = E0 /\\ eventually ge n s' (fun s'0 : state => P s'0 /\\ Inv s'0).","conclusion":"t = E0 /\\ eventually ge n s' (fun s'0 : state => P s'0 /\\ Inv s'0)","hypotheses":"(ge : genv) (Inv P : state -> Prop) (H : forall (s0 : state) (t0 : trace) (s'0 : state),\nstep ge s0 t0 s'0 -> Inv s0 -> Inv s'0) (n : nat) (IHn : forall s0 : state,\neventually ge n s0 P ->\nInv s0 -> eventually ge n s0 (fun s'0 : state => P s'0 /\\ Inv s'0)) (s : state) (IV : Inv s) (H1 : forall r : int, ~ final_state s r) (H2 : forall (t0 : trace) (s'0 : state),\nstep ge s t0 s'0 -> t0 = E0 /\\ eventually ge n s'0 P) (t : trace) (s' : state) (H0 : step ge s t s')","proofString":"edestruct H2; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2) : (exists (i' : index) (s2' : state L2),\n   Plus L2 s2 t s2' /\\ match_states i' s1' s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s1' s2).","conclusion":"(exists (i' : index) (s2' : state L2),\n   Plus L2 s2 t s2' /\\ match_states i' s1' s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s1' s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2)","proofString":"exploit fsim_simulation; eauto.\nintros [i' [s2' [A B]]].\nintuition.\nleft; exists i'; exists s2'; auto.\ninv H3.\nright; exists i'; auto.\nleft; exists i'; exists s2'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2) : (exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   match_states i' s1' s2') ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s2 t s2' /\\ match_states i' s1' s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s1' s2).","conclusion":"(exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   match_states i' s1' s2') ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s2 t s2' /\\ match_states i' s1' s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s1' s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2)","proofString":"intros [i' [s2' [A B]]].\nintuition.\nleft; exists i'; exists s2'; auto.\ninv H3.\nright; exists i'; auto.\nleft; exists i'; exists s2'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : match_states i' s1' s2') : (exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2 t s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1' s2).","conclusion":"(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2 t s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1' s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : match_states i' s1' s2')","proofString":"intuition.\nleft; exists i'; exists s2'; auto.\ninv H3.\nright; exists i'; auto.\nleft; exists i'; exists s2'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (B : match_states i' s1' s2') (H2 : Plus L2 s2 t s2') : (exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2 t s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1' s2).","conclusion":"(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2 t s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1' s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (B : match_states i' s1' s2') (H2 : Plus L2 s2 t s2')","proofString":"left; exists i'; exists s2'; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (B : match_states i' s1' s2') (H3 : Star L2 s2 t s2') (H4 : order i' i) : (exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2 t s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1' s2).","conclusion":"(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2 t s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1' s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 : state L1) (t : trace) (s1' : state L1) (H0 : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (B : match_states i' s1' s2') (H3 : Star L2 s2 t s2') (H4 : order i' i)","proofString":"inv H3.\nright; exists i'; auto.\nleft; exists i'; exists s2'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 s1' : state L1) (H0 : Step L1 s1 E0 s1') (s2' : state L2) (H1 : match_states i s1 s2') (i' : index) (B : match_states i' s1' s2') (H4 : order i' i) : (exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2' E0 s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ E0 = E0 /\\ match_states i'0 s1' s2').","conclusion":"(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2' E0 s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ E0 = E0 /\\ match_states i'0 s1' s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 s1' : state L1) (H0 : Step L1 s1 E0 s1') (s2' : state L2) (H1 : match_states i s1 s2') (i' : index) (B : match_states i' s1' s2') (H4 : order i' i)","proofString":"right; exists i'; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 s1' : state L1) (t1 t2 : trace) (H0 : Step L1 s1 (t1 ** t2) s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (B : match_states i' s1' s2') (H4 : order i' i) (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H5 : Star L2 s3 t2 s2') : (exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2 (t1 ** t2) s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ t1 ** t2 = E0 /\\ match_states i'0 s1' s2).","conclusion":"(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s2 (t1 ** t2) s2'0 /\\ match_states i'0 s1' s2'0) \\/\n(exists i'0 : index, order i'0 i /\\ t1 ** t2 = E0 /\\ match_states i'0 s1' s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 s1' : state L1) (t1 t2 : trace) (H0 : Step L1 s1 (t1 ** t2) s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (B : match_states i' s1' s2') (H4 : order i' i) (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H5 : Star L2 s3 t2 s2')","proofString":"left; exists i'; exists s2'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 s1' : state L1) (t1 t2 : trace) (H0 : Step L1 s1 (t1 ** t2) s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (B : match_states i' s1' s2') (H4 : order i' i) (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H5 : Star L2 s3 t2 s2') : Plus L2 s2 (t1 ** t2) s2'.","conclusion":"Plus L2 s2 (t1 ** t2) s2'","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : fsim_properties L1 L2 index order match_states) (i : index) (s1 s1' : state L1) (t1 t2 : trace) (H0 : Step L1 s1 (t1 ** t2) s1') (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (B : match_states i' s1' s2') (H4 : order i' i) (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H5 : Star L2 s3 t2 s2')","proofString":"econstructor; eauto."},{"statement":"well_founded order.","conclusion":"well_founded order","hypotheses":"","proofString":"auto."},{"statement":"forall s1 : state L1,\ninitial_state L1 s1 ->\nexists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2.","conclusion":"forall s1 : state L1,\ninitial_state L1 s1 ->\nexists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2","hypotheses":"","proofString":"intros.\nexploit match_initial_states; eauto.\nintros [s2 [A B]].\nexists s1; exists s2; auto."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : exists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2.","conclusion":"exists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"exploit match_initial_states; eauto.\nintros [s2 [A B]].\nexists s1; exists s2; auto."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : (exists s2 : state L2, initial_state L2 s2 /\\ match_states s1 s2) ->\nexists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2.","conclusion":"(exists s2 : state L2, initial_state L2 s2 /\\ match_states s1 s2) ->\nexists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"intros [s2 [A B]].\nexists s1; exists s2; auto."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) (B : match_states s1 s2) : exists (i : state L1) (s0 : state L2),\n  initial_state L2 s0 /\\ i = s1 /\\ match_states s1 s0.","conclusion":"exists (i : state L1) (s0 : state L2),\n  initial_state L2 s0 /\\ i = s1 /\\ match_states s1 s0","hypotheses":"(s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) (B : match_states s1 s2)","proofString":"exists s1; exists s2; auto."},{"statement":"forall (i s1 : state L1) (s2 : state L2) (r : int),\ni = s1 /\\ match_states s1 s2 -> final_state L1 s1 r -> final_state L2 s2 r.","conclusion":"forall (i s1 : state L1) (s2 : state L2) (r : int),\ni = s1 /\\ match_states s1 s2 -> final_state L1 s1 r -> final_state L2 s2 r","hypotheses":"","proofString":"intros.\ndestruct H.\neapply match_final_states; eauto."},{"statement":"(i s1 : state L1) (s2 : state L2) (r : int) (H : i = s1 /\\ match_states s1 s2) (H0 : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i s1 : state L1) (s2 : state L2) (r : int) (H : i = s1 /\\ match_states s1 s2) (H0 : final_state L1 s1 r)","proofString":"destruct H.\neapply match_final_states; eauto."},{"statement":"(i s1 : state L1) (s2 : state L2) (r : int) (H : i = s1) (H1 : match_states s1 s2) (H0 : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i s1 : state L1) (s2 : state L2) (r : int) (H : i = s1) (H1 : match_states s1 s2) (H0 : final_state L1 s1 r)","proofString":"eapply match_final_states; eauto."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : state L1) (s2 : state L2),\ni = s1 /\\ match_states s1 s2 ->\nexists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  i' = s1' /\\ match_states s1' s2'.","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : state L1) (s2 : state L2),\ni = s1 /\\ match_states s1 s2 ->\nexists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  i' = s1' /\\ match_states s1' s2'","hypotheses":"","proofString":"intros.\ndestruct H0.\nsubst i.\nexploit simulation; eauto.\nintros [s2' [A B]].\nexists s1'; exists s2'; intuition auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : state L1) (s2 : state L2) (H0 : i = s1 /\\ match_states s1 s2) : exists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  i' = s1' /\\ match_states s1' s2'.","conclusion":"exists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  i' = s1' /\\ match_states s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : state L1) (s2 : state L2) (H0 : i = s1 /\\ match_states s1 s2)","proofString":"destruct H0.\nsubst i.\nexploit simulation; eauto.\nintros [s2' [A B]].\nexists s1'; exists s2'; intuition auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : state L1) (s2 : state L2) (H0 : i = s1) (H1 : match_states s1 s2) : exists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  i' = s1' /\\ match_states s1' s2'.","conclusion":"exists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  i' = s1' /\\ match_states s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : state L1) (s2 : state L2) (H0 : i = s1) (H1 : match_states s1 s2)","proofString":"subst i.\nexploit simulation; eauto.\nintros [s2' [A B]].\nexists s1'; exists s2'; intuition auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) : exists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' s1) /\\\n  i' = s1' /\\ match_states s1' s2'.","conclusion":"exists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' s1) /\\\n  i' = s1' /\\ match_states s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2)","proofString":"exploit simulation; eauto.\nintros [s2' [A B]].\nexists s1'; exists s2'; intuition auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) : (exists s2' : state L2,\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) /\\\n   match_states s1' s2') ->\nexists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' s1) /\\\n  i' = s1' /\\ match_states s1' s2'.","conclusion":"(exists s2' : state L2,\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) /\\\n   match_states s1' s2') ->\nexists (i' : state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' s1) /\\\n  i' = s1' /\\ match_states s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2)","proofString":"intros [s2' [A B]].\nexists s1'; exists s2'; intuition auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) (B : match_states s1' s2') : exists (i' : state L1) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ order i' s1) /\\\n  i' = s1' /\\ match_states s1' s2'0.","conclusion":"exists (i' : state L1) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ order i' s1) /\\\n  i' = s1' /\\ match_states s1' s2'0","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) (B : match_states s1' s2')","proofString":"exists s1'; exists s2'; intuition auto."},{"statement":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"","proofString":"auto."},{"statement":"well_founded (ltof (state L1) measure).","conclusion":"well_founded (ltof (state L1) measure)","hypotheses":"","proofString":"apply well_founded_ltof."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\nexists s2' : state L2,\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'.","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\nexists s2' : state L2,\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'","hypotheses":"","proofString":"intros.\nexploit simulation; eauto.\nintros [[s2' [A B]] | [A [B C]]].\nexists s2'; auto.\nexists s2; split.\nright; split.\nrewrite B.\napply star_refl.\nauto.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : exists s2' : state L2,\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'.","conclusion":"exists s2' : state L2,\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"exploit simulation; eauto.\nintros [[s2' [A B]] | [A [B C]]].\nexists s2'; auto.\nexists s2; split.\nright; split.\nrewrite B.\napply star_refl.\nauto.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : (exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2 ->\nexists s2' : state L2,\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'.","conclusion":"(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2 ->\nexists s2' : state L2,\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"intros [[s2' [A B]] | [A [B C]]].\nexists s2'; auto.\nexists s2; split.\nright; split.\nrewrite B.\napply star_refl.\nauto.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2') (B : match_states s1' s2') : exists s2'0 : state L2,\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'0.","conclusion":"exists s2'0 : state L2,\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'0","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2') (B : match_states s1' s2')","proofString":"exists s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2) : exists s2' : state L2,\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'.","conclusion":"exists s2' : state L2,\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n  match_states s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2)","proofString":"exists s2; split.\nright; split.\nrewrite B.\napply star_refl.\nauto.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2) : Plus L2 s2 t s2 \\/ Star L2 s2 t s2 /\\ ltof (state L1) measure s1' s1.","conclusion":"Plus L2 s2 t s2 \\/ Star L2 s2 t s2 /\\ ltof (state L1) measure s1' s1","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2)","proofString":"right; split.\nrewrite B.\napply star_refl.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2) : Star L2 s2 t s2.","conclusion":"Star L2 s2 t s2","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2)","proofString":"rewrite B.\napply star_refl."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2) : Star L2 s2 E0 s2.","conclusion":"Star L2 s2 E0 s2","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2)","proofString":"apply star_refl."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2) : ltof (state L1) measure s1' s1.","conclusion":"ltof (state L1) measure s1' s1","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2)","proofString":"auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2) : match_states s1' s2.","conclusion":"match_states s1' s2","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2)","proofString":"auto."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\n(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(0 < 0)%nat /\\ t = E0 /\\ match_states s1' s2.","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\n(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(0 < 0)%nat /\\ t = E0 /\\ match_states s1' s2","hypotheses":"","proofString":"intros.\nexploit simulation; eauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : (exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(0 < 0)%nat /\\ t = E0 /\\ match_states s1' s2.","conclusion":"(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(0 < 0)%nat /\\ t = E0 /\\ match_states s1' s2","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"exploit simulation; eauto."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\nexists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2'.","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\nexists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2'","hypotheses":"","proofString":"intros.\nexploit simulation; eauto.\nintros [s2' [A B]].\nexists s2'; split; auto.\napply plus_one; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2'.","conclusion":"exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"exploit simulation; eauto.\nintros [s2' [A B]].\nexists s2'; split; auto.\napply plus_one; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : (exists s2' : state L2, Step L2 s2 t s2' /\\ match_states s1' s2') ->\nexists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2'.","conclusion":"(exists s2' : state L2, Step L2 s2 t s2' /\\ match_states s1' s2') ->\nexists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"intros [s2' [A B]].\nexists s2'; split; auto.\napply plus_one; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Step L2 s2 t s2') (B : match_states s1' s2') : exists s2'0 : state L2, Plus L2 s2 t s2'0 /\\ match_states s1' s2'0.","conclusion":"exists s2'0 : state L2, Plus L2 s2 t s2'0 /\\ match_states s1' s2'0","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Step L2 s2 t s2') (B : match_states s1' s2')","proofString":"exists s2'; split; auto.\napply plus_one; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Step L2 s2 t s2') (B : match_states s1' s2') : Plus L2 s2 t s2'.","conclusion":"Plus L2 s2 t s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Step L2 s2 t s2') (B : match_states s1' s2')","proofString":"apply plus_one; auto."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\n(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2.","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\n(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2","hypotheses":"","proofString":"intros.\nexploit simulation; eauto.\nintros [[s2' [A B]] | [A [B C]]].\nleft; exists s2'; split; auto.\napply plus_one; auto.\nright; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : (exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2.","conclusion":"(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"exploit simulation; eauto.\nintros [[s2' [A B]] | [A [B C]]].\nleft; exists s2'; split; auto.\napply plus_one; auto.\nright; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : (exists s2' : state L2, Step L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2 ->\n(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2.","conclusion":"(exists s2' : state L2, Step L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2 ->\n(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"intros [[s2' [A B]] | [A [B C]]].\nleft; exists s2'; split; auto.\napply plus_one; auto.\nright; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Step L2 s2 t s2') (B : match_states s1' s2') : (exists s2'0 : state L2, Plus L2 s2 t s2'0 /\\ match_states s1' s2'0) \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2.","conclusion":"(exists s2'0 : state L2, Plus L2 s2 t s2'0 /\\ match_states s1' s2'0) \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Step L2 s2 t s2') (B : match_states s1' s2')","proofString":"left; exists s2'; split; auto.\napply plus_one; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Step L2 s2 t s2') (B : match_states s1' s2') : Plus L2 s2 t s2'.","conclusion":"Plus L2 s2 t s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Step L2 s2 t s2') (B : match_states s1' s2')","proofString":"apply plus_one; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2) : (exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2.","conclusion":"(exists s2' : state L2, Plus L2 s2 t s2' /\\ match_states s1' s2') \\/\n(measure s1' < measure s1)%nat /\\ t = E0 /\\ match_states s1' s2","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (A : (measure s1' < measure s1)%nat) (B : t = E0) (C : match_states s1' s2)","proofString":"right; auto."},{"statement":"fsim_properties L1 L2 (index * nat) (lex_ord order Nat.lt)\n  (fun (i : index * nat) (s1 : state L1) (s2 : state L2) =>\n   Eventually L1 (snd i) s1\n     (fun s1'' : state L1 => match_states (fst i) s1'' s2)).","conclusion":"fsim_properties L1 L2 (index * nat) (lex_ord order Nat.lt)\n  (fun (i : index * nat) (s1 : state L1) (s2 : state L2) =>\n   Eventually L1 (snd i) s1\n     (fun s1'' : state L1 => match_states (fst i) s1'' s2))","hypotheses":"","proofString":"constructor.\napply wf_lex_ord; auto using lt_wf.\nintros.\nexploit initial_states; eauto.\nintros (i & s2 & A & B).\nexists (i, O), s2; auto using eventually_now.\nintros [i n] s1 s2 r EV FS; simpl in *.\ninv EV.\neapply final_states; eauto.\neelim H; eauto.\nintros s1 t s1' ST [i n] s2 EV; simpl in *.\ninv EV.\nexploit simulation; eauto.\nintros (n & i' & s2' & A & B).\nexists (i', n), s2'; split; auto.\ndestruct A as [P | [P Q]]; auto using lex_ord_left.\napply H0 in ST.\ndestruct ST as (A & B).\nsubst t.\nexists (i, n0), s2; split.\nright; split.\napply star_refl.\napply lex_ord_right; lia.\nexact B.\napply public_preserved."},{"statement":"well_founded (lex_ord order Nat.lt).","conclusion":"well_founded (lex_ord order Nat.lt)","hypotheses":"","proofString":"apply wf_lex_ord; auto using lt_wf."},{"statement":"forall s1 : state L1,\ninitial_state L1 s1 ->\nexists (i : index * nat) (s2 : state L2),\n  initial_state L2 s2 /\\\n  Eventually L1 (snd i) s1\n    (fun s1'' : state L1 => match_states (fst i) s1'' s2).","conclusion":"forall s1 : state L1,\ninitial_state L1 s1 ->\nexists (i : index * nat) (s2 : state L2),\n  initial_state L2 s2 /\\\n  Eventually L1 (snd i) s1\n    (fun s1'' : state L1 => match_states (fst i) s1'' s2)","hypotheses":"","proofString":"intros.\nexploit initial_states; eauto.\nintros (i & s2 & A & B).\nexists (i, O), s2; auto using eventually_now."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : exists (i : index * nat) (s2 : state L2),\n  initial_state L2 s2 /\\\n  Eventually L1 (snd i) s1\n    (fun s1'' : state L1 => match_states (fst i) s1'' s2).","conclusion":"exists (i : index * nat) (s2 : state L2),\n  initial_state L2 s2 /\\\n  Eventually L1 (snd i) s1\n    (fun s1'' : state L1 => match_states (fst i) s1'' s2)","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"exploit initial_states; eauto.\nintros (i & s2 & A & B).\nexists (i, O), s2; auto using eventually_now."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : (exists (i : index) (s2 : state L2),\n   initial_state L2 s2 /\\ match_states i s1 s2) ->\nexists (i : index * nat) (s2 : state L2),\n  initial_state L2 s2 /\\\n  Eventually L1 (snd i) s1\n    (fun s1'' : state L1 => match_states (fst i) s1'' s2).","conclusion":"(exists (i : index) (s2 : state L2),\n   initial_state L2 s2 /\\ match_states i s1 s2) ->\nexists (i : index * nat) (s2 : state L2),\n  initial_state L2 s2 /\\\n  Eventually L1 (snd i) s1\n    (fun s1'' : state L1 => match_states (fst i) s1'' s2)","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"intros (i & s2 & A & B).\nexists (i, O), s2; auto using eventually_now."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) (i : index) (s2 : state L2) (A : initial_state L2 s2) (B : match_states i s1 s2) : exists (i0 : index * nat) (s0 : state L2),\n  initial_state L2 s0 /\\\n  Eventually L1 (snd i0) s1\n    (fun s1'' : state L1 => match_states (fst i0) s1'' s0).","conclusion":"exists (i0 : index * nat) (s0 : state L2),\n  initial_state L2 s0 /\\\n  Eventually L1 (snd i0) s1\n    (fun s1'' : state L1 => match_states (fst i0) s1'' s0)","hypotheses":"(s1 : state L1) (H : initial_state L1 s1) (i : index) (s2 : state L2) (A : initial_state L2 s2) (B : match_states i s1 s2)","proofString":"exists (i, O), s2; auto using eventually_now."},{"statement":"forall (i : index * nat) (s1 : state L1) (s2 : state L2) (r : int),\nEventually L1 (snd i) s1\n  (fun s1'' : state L1 => match_states (fst i) s1'' s2) ->\nfinal_state L1 s1 r -> final_state L2 s2 r.","conclusion":"forall (i : index * nat) (s1 : state L1) (s2 : state L2) (r : int),\nEventually L1 (snd i) s1\n  (fun s1'' : state L1 => match_states (fst i) s1'' s2) ->\nfinal_state L1 s1 r -> final_state L2 s2 r","hypotheses":"","proofString":"intros [i n] s1 s2 r EV FS; simpl in *.\ninv EV.\neapply final_states; eauto.\neelim H; eauto."},{"statement":"(i : index) (n : nat) (s1 : state L1) (s2 : state L2) (r : int) (EV : Eventually L1 n s1 (fun s1'' : state L1 => match_states i s1'' s2)) (FS : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i : index) (n : nat) (s1 : state L1) (s2 : state L2) (r : int) (EV : Eventually L1 n s1 (fun s1'' : state L1 => match_states i s1'' s2)) (FS : final_state L1 s1 r)","proofString":"inv EV.\neapply final_states; eauto.\neelim H; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (r : int) (FS : final_state L1 s1 r) (H : match_states i s1 s2) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (r : int) (FS : final_state L1 s1 r) (H : match_states i s1 s2)","proofString":"eapply final_states; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (r : int) (FS : final_state L1 s1 r) (n0 : nat) (H : forall r0 : int, ~ final_state L1 s1 r0) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2)) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (r : int) (FS : final_state L1 s1 r) (n0 : nat) (H : forall r0 : int, ~ final_state L1 s1 r0) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"eelim H; eauto."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : index * nat) (s2 : state L2),\nEventually L1 (snd i) s1\n  (fun s1'' : state L1 => match_states (fst i) s1'' s2) ->\nexists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' i) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2').","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : index * nat) (s2 : state L2),\nEventually L1 (snd i) s1\n  (fun s1'' : state L1 => match_states (fst i) s1'' s2) ->\nexists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' i) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2')","hypotheses":"","proofString":"intros s1 t s1' ST [i n] s2 EV; simpl in *.\ninv EV.\nexploit simulation; eauto.\nintros (n & i' & s2' & A & B).\nexists (i', n), s2'; split; auto.\ndestruct A as [P | [P Q]]; auto using lex_ord_left.\napply H0 in ST.\ndestruct ST as (A & B).\nsubst t.\nexists (i, n0), s2; split.\nright; split.\napply star_refl.\napply lex_ord_right; lia.\nexact B."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (n : nat) (s2 : state L2) (EV : Eventually L1 n s1 (fun s1'' : state L1 => match_states i s1'' s2)) : exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, n)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2').","conclusion":"exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, n)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (n : nat) (s2 : state L2) (EV : Eventually L1 n s1 (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"inv EV.\nexploit simulation; eauto.\nintros (n & i' & s2' & A & B).\nexists (i', n), s2'; split; auto.\ndestruct A as [P | [P Q]]; auto using lex_ord_left.\napply H0 in ST.\ndestruct ST as (A & B).\nsubst t.\nexists (i, n0), s2; split.\nright; split.\napply star_refl.\napply lex_ord_right; lia.\nexact B."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (H : match_states i s1 s2) : exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, 0%nat)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2').","conclusion":"exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, 0%nat)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (H : match_states i s1 s2)","proofString":"exploit simulation; eauto.\nintros (n & i' & s2' & A & B).\nexists (i', n), s2'; split; auto.\ndestruct A as [P | [P Q]]; auto using lex_ord_left."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (H : match_states i s1 s2) : (exists (n : nat) (i' : index) (s2' : state L2),\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2')) ->\nexists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, 0%nat)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2').","conclusion":"(exists (n : nat) (i' : index) (s2' : state L2),\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2')) ->\nexists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, 0%nat)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (H : match_states i s1 s2)","proofString":"intros (n & i' & s2' & A & B).\nexists (i', n), s2'; split; auto.\ndestruct A as [P | [P Q]]; auto using lex_ord_left."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (H : match_states i s1 s2) (n : nat) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2')) : exists (i'0 : index * nat) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/\n   Star L2 s2 t s2'0 /\\ lex_ord order Nat.lt i'0 (i, 0%nat)) /\\\n  Eventually L1 (snd i'0) s1'\n    (fun s1'' : state L1 => match_states (fst i'0) s1'' s2'0).","conclusion":"exists (i'0 : index * nat) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/\n   Star L2 s2 t s2'0 /\\ lex_ord order Nat.lt i'0 (i, 0%nat)) /\\\n  Eventually L1 (snd i'0) s1'\n    (fun s1'' : state L1 => match_states (fst i'0) s1'' s2'0)","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (H : match_states i s1 s2) (n : nat) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2'))","proofString":"exists (i', n), s2'; split; auto.\ndestruct A as [P | [P Q]]; auto using lex_ord_left."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (H : match_states i s1 s2) (n : nat) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2')) : Plus L2 s2 t s2' \\/\nStar L2 s2 t s2' /\\ lex_ord order Nat.lt (i', n) (i, 0%nat).","conclusion":"Plus L2 s2 t s2' \\/\nStar L2 s2 t s2' /\\ lex_ord order Nat.lt (i', n) (i, 0%nat)","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (H : match_states i s1 s2) (n : nat) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2'))","proofString":"destruct A as [P | [P Q]]; auto using lex_ord_left."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (n0 : nat) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\\nEventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2)) : exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, S n0)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2').","conclusion":"exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, S n0)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (ST : Step L1 s1 t s1') (i : index) (s2 : state L2) (n0 : nat) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\\nEventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"apply H0 in ST.\ndestruct ST as (A & B).\nsubst t.\nexists (i, n0), s2; split.\nright; split.\napply star_refl.\napply lex_ord_right; lia.\nexact B."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (ST : t = E0 /\\\nEventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\\nEventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2)) : exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, S n0)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2').","conclusion":"exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, S n0)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (ST : t = E0 /\\\nEventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\\nEventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"destruct ST as (A & B).\nsubst t.\nexists (i, n0), s2; split.\nright; split.\napply star_refl.\napply lex_ord_right; lia.\nexact B."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (A : t = E0) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\\nEventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2)) : exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, S n0)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2').","conclusion":"exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord order Nat.lt i' (i, S n0)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (A : t = E0) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\\nEventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"subst t.\nexists (i, n0), s2; split.\nright; split.\napply star_refl.\napply lex_ord_right; lia.\nexact B."},{"statement":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2)) : exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/\n   Star L2 s2 E0 s2' /\\ lex_ord order Nat.lt i' (i, S n0)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2').","conclusion":"exists (i' : index * nat) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/\n   Star L2 s2 E0 s2' /\\ lex_ord order Nat.lt i' (i, S n0)) /\\\n  Eventually L1 (snd i') s1'\n    (fun s1'' : state L1 => match_states (fst i') s1'' s2')","hypotheses":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"exists (i, n0), s2; split.\nright; split.\napply star_refl.\napply lex_ord_right; lia.\nexact B."},{"statement":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2)) : Plus L2 s2 E0 s2 \\/\nStar L2 s2 E0 s2 /\\ lex_ord order Nat.lt (i, n0) (i, S n0).","conclusion":"Plus L2 s2 E0 s2 \\/\nStar L2 s2 E0 s2 /\\ lex_ord order Nat.lt (i, n0) (i, S n0)","hypotheses":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"right; split.\napply star_refl.\napply lex_ord_right; lia."},{"statement":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2)) : Star L2 s2 E0 s2.","conclusion":"Star L2 s2 E0 s2","hypotheses":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"apply star_refl."},{"statement":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2)) : lex_ord order Nat.lt (i, n0) (i, S n0).","conclusion":"lex_ord order Nat.lt (i, n0) (i, S n0)","hypotheses":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"apply lex_ord_right; lia."},{"statement":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2)) : Eventually L1 (snd (i, n0)) s1'\n  (fun s1'' : state L1 => match_states (fst (i, n0)) s1'' s2).","conclusion":"Eventually L1 (snd (i, n0)) s1'\n  (fun s1'' : state L1 => match_states (fst (i, n0)) s1'' s2)","hypotheses":"(s1 s1' : state L1) (i : index) (s2 : state L2) (n0 : nat) (B : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states i s1'' s2)) (H : forall r : int, ~ final_state L1 s1 r) (H0 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states i s1'' s2))","proofString":"exact B."},{"statement":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"","proofString":"apply public_preserved."},{"statement":"well_founded lt.","conclusion":"well_founded lt","hypotheses":"","proofString":"apply lt_wf."},{"statement":"forall s1 : state L1,\ninitial_state L1 s1 ->\nexists (_ : nat) (s2 : state L2), initial_state L2 s2 /\\ match_states s1 s2.","conclusion":"forall s1 : state L1,\ninitial_state L1 s1 ->\nexists (_ : nat) (s2 : state L2), initial_state L2 s2 /\\ match_states s1 s2","hypotheses":"","proofString":"intros.\nexploit initial_states; eauto.\nintros (s2 & A & B).\nexists O, s2; auto."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : exists (_ : nat) (s2 : state L2), initial_state L2 s2 /\\ match_states s1 s2.","conclusion":"exists (_ : nat) (s2 : state L2), initial_state L2 s2 /\\ match_states s1 s2","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"exploit initial_states; eauto.\nintros (s2 & A & B).\nexists O, s2; auto."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : (exists s2 : state L2, initial_state L2 s2 /\\ match_states s1 s2) ->\nexists (_ : nat) (s2 : state L2), initial_state L2 s2 /\\ match_states s1 s2.","conclusion":"(exists s2 : state L2, initial_state L2 s2 /\\ match_states s1 s2) ->\nexists (_ : nat) (s2 : state L2), initial_state L2 s2 /\\ match_states s1 s2","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"intros (s2 & A & B).\nexists O, s2; auto."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) (B : match_states s1 s2) : exists (_ : nat) (s0 : state L2), initial_state L2 s0 /\\ match_states s1 s0.","conclusion":"exists (_ : nat) (s0 : state L2), initial_state L2 s0 /\\ match_states s1 s0","hypotheses":"(s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) (B : match_states s1 s2)","proofString":"exists O, s2; auto."},{"statement":"nat ->\nforall (s1 : state L1) (s2 : state L2) (r : int),\nmatch_states s1 s2 -> final_state L1 s1 r -> final_state L2 s2 r.","conclusion":"nat ->\nforall (s1 : state L1) (s2 : state L2) (r : int),\nmatch_states s1 s2 -> final_state L1 s1 r -> final_state L2 s2 r","hypotheses":"","proofString":"intros.\neapply final_states; eauto."},{"statement":"(i : nat) (s1 : state L1) (s2 : state L2) (r : int) (H : match_states s1 s2) (H0 : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i : nat) (s1 : state L1) (s2 : state L2) (r : int) (H : match_states s1 s2) (H0 : final_state L1 s1 r)","proofString":"eapply final_states; eauto."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : nat) (s2 : state L2),\nmatch_states s1 s2 ->\nexists (n i' : nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (i' < i)%nat) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : nat) (s2 : state L2),\nmatch_states s1 s2 ->\nexists (n i' : nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (i' < i)%nat) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"","proofString":"intros.\nexploit simulation; eauto.\nintros (n & s2' & A & B).\nexists n, O, s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : nat) (s2 : state L2) (H0 : match_states s1 s2) : exists (n i' : nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (i' < i)%nat) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"exists (n i' : nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (i' < i)%nat) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : nat) (s2 : state L2) (H0 : match_states s1 s2)","proofString":"exploit simulation; eauto.\nintros (n & s2' & A & B).\nexists n, O, s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : nat) (s2 : state L2) (H0 : match_states s1 s2) : (exists (n : nat) (s2' : state L2),\n   Plus L2 s2 t s2' /\\\n   Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')) ->\nexists (n i' : nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (i' < i)%nat) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"(exists (n : nat) (s2' : state L2),\n   Plus L2 s2 t s2' /\\\n   Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')) ->\nexists (n i' : nat) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (i' < i)%nat) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : nat) (s2 : state L2) (H0 : match_states s1 s2)","proofString":"intros (n & s2' & A & B).\nexists n, O, s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : nat) (s2 : state L2) (H0 : match_states s1 s2) (n : nat) (s2' : state L2) (A : Plus L2 s2 t s2') (B : Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')) : exists (n0 i' : nat) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ (i' < i)%nat) /\\\n  Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2'0).","conclusion":"exists (n0 i' : nat) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ (i' < i)%nat) /\\\n  Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2'0)","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : nat) (s2 : state L2) (H0 : match_states s1 s2) (n : nat) (s2' : state L2) (A : Plus L2 s2 t s2') (B : Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2'))","proofString":"exists n, O, s2'; auto."},{"statement":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"","proofString":"auto."},{"statement":"fsim_properties L1 L2 (nat * state L1) (lex_ord Nat.lt order)\n  (fun (i : nat * state L1) (s1 : state L1) (s2 : state L2) =>\n   snd i = s1 /\\\n   Eventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2)).","conclusion":"fsim_properties L1 L2 (nat * state L1) (lex_ord Nat.lt order)\n  (fun (i : nat * state L1) (s1 : state L1) (s2 : state L2) =>\n   snd i = s1 /\\\n   Eventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2))","hypotheses":"","proofString":"constructor; intros.\napply wf_lex_ord; auto using lt_wf.\nexploit initial_states; eauto.\nintros (s2 & A & B).\nexists (O, s1), s2; auto using eventually_now.\ndestruct i as [n s11]; destruct H as [P Q]; simpl in *; subst s11.\ninv Q.\neapply final_states; eauto.\neelim H; eauto.\ndestruct i as [n s11]; destruct H0 as [P Q]; simpl in *; subst s11.\ninv Q.\nexploit simulation; eauto.\nintros [(s2' & A & B) | (n & s2' & A & B)].\nexists (O, s1'), s2'; split.\ndestruct A as [A | [A1 A2]]; auto using lex_ord_right.\nauto using eventually_now.\nexists (n, s1'), s2'; auto.\napply H1 in H.\ndestruct H.\nsubst t.\nexists (n0, s1'), s2; split.\nright; split.\napply star_refl.\napply lex_ord_left; lia.\nauto.\nauto."},{"statement":"well_founded (lex_ord Nat.lt order).","conclusion":"well_founded (lex_ord Nat.lt order)","hypotheses":"","proofString":"apply wf_lex_ord; auto using lt_wf."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : exists (i : nat * state L1) (s2 : state L2),\n  initial_state L2 s2 /\\\n  snd i = s1 /\\\n  Eventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2).","conclusion":"exists (i : nat * state L1) (s2 : state L2),\n  initial_state L2 s2 /\\\n  snd i = s1 /\\\n  Eventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2)","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"exploit initial_states; eauto.\nintros (s2 & A & B).\nexists (O, s1), s2; auto using eventually_now."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : (exists s2 : state L2, initial_state L2 s2 /\\ match_states s1 s2) ->\nexists (i : nat * state L1) (s2 : state L2),\n  initial_state L2 s2 /\\\n  snd i = s1 /\\\n  Eventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2).","conclusion":"(exists s2 : state L2, initial_state L2 s2 /\\ match_states s1 s2) ->\nexists (i : nat * state L1) (s2 : state L2),\n  initial_state L2 s2 /\\\n  snd i = s1 /\\\n  Eventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2)","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"intros (s2 & A & B).\nexists (O, s1), s2; auto using eventually_now."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) (B : match_states s1 s2) : exists (i : nat * state L1) (s0 : state L2),\n  initial_state L2 s0 /\\\n  snd i = s1 /\\\n  Eventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s0).","conclusion":"exists (i : nat * state L1) (s0 : state L2),\n  initial_state L2 s0 /\\\n  snd i = s1 /\\\n  Eventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s0)","hypotheses":"(s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) (B : match_states s1 s2)","proofString":"exists (O, s1), s2; auto using eventually_now."},{"statement":"(i : nat * state L1) (s1 : state L1) (s2 : state L2) (r : int) (H : snd i = s1 /\\\nEventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2)) (H0 : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i : nat * state L1) (s1 : state L1) (s2 : state L2) (r : int) (H : snd i = s1 /\\\nEventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2)) (H0 : final_state L1 s1 r)","proofString":"destruct i as [n s11]; destruct H as [P Q]; simpl in *; subst s11.\ninv Q.\neapply final_states; eauto.\neelim H; eauto."},{"statement":"(n : nat) (s1 : state L1) (s2 : state L2) (r : int) (Q : Eventually L1 n s1 (fun s1'' : state L1 => match_states s1'' s2)) (H0 : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(n : nat) (s1 : state L1) (s2 : state L2) (r : int) (Q : Eventually L1 n s1 (fun s1'' : state L1 => match_states s1'' s2)) (H0 : final_state L1 s1 r)","proofString":"inv Q.\neapply final_states; eauto.\neelim H; eauto."},{"statement":"(s1 : state L1) (s2 : state L2) (r : int) (H0 : final_state L1 s1 r) (H : match_states s1 s2) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(s1 : state L1) (s2 : state L2) (r : int) (H0 : final_state L1 s1 r) (H : match_states s1 s2)","proofString":"eapply final_states; eauto."},{"statement":"(s1 : state L1) (s2 : state L2) (r : int) (H0 : final_state L1 s1 r) (n0 : nat) (H : forall r0 : int, ~ final_state L1 s1 r0) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2)) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(s1 : state L1) (s2 : state L2) (r : int) (H0 : final_state L1 s1 r) (n0 : nat) (H : forall r0 : int, ~ final_state L1 s1 r0) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2))","proofString":"eelim H; eauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : nat * state L1) (s2 : state L2) (H0 : snd i = s1 /\\\nEventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2)) : exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' i) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' i) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : nat * state L1) (s2 : state L2) (H0 : snd i = s1 /\\\nEventually L1 (fst i) s1 (fun s1'' : state L1 => match_states s1'' s2))","proofString":"destruct i as [n s11]; destruct H0 as [P Q]; simpl in *; subst s11.\ninv Q.\nexploit simulation; eauto.\nintros [(s2' & A & B) | (n & s2' & A & B)].\nexists (O, s1'), s2'; split.\ndestruct A as [A | [A1 A2]]; auto using lex_ord_right.\nauto using eventually_now.\nexists (n, s1'), s2'; auto.\napply H1 in H.\ndestruct H.\nsubst t.\nexists (n0, s1'), s2; split.\nright; split.\napply star_refl.\napply lex_ord_left; lia.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (n : nat) (s2 : state L2) (Q : Eventually L1 n s1 (fun s1'' : state L1 => match_states s1'' s2)) : exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (n, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (n, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (n : nat) (s2 : state L2) (Q : Eventually L1 n s1 (fun s1'' : state L1 => match_states s1'' s2))","proofString":"inv Q.\nexploit simulation; eauto.\nintros [(s2' & A & B) | (n & s2' & A & B)].\nexists (O, s1'), s2'; split.\ndestruct A as [A | [A1 A2]]; auto using lex_ord_right.\nauto using eventually_now.\nexists (n, s1'), s2'; auto.\napply H1 in H.\ndestruct H.\nsubst t.\nexists (n0, s1'), s2; split.\nright; split.\napply star_refl.\napply lex_ord_left; lia.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/\n   Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (0%nat, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/\n   Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (0%nat, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"exploit simulation; eauto.\nintros [(s2' & A & B) | (n & s2' & A & B)].\nexists (O, s1'), s2'; split.\ndestruct A as [A | [A1 A2]]; auto using lex_ord_right.\nauto using eventually_now.\nexists (n, s1'), s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : (exists s2' : state L2,\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) /\\\n   match_states s1' s2') \\/\n(exists (n : nat) (s2' : state L2),\n   Plus L2 s2 t s2' /\\\n   Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')) ->\nexists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/\n   Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (0%nat, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"(exists s2' : state L2,\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) /\\\n   match_states s1' s2') \\/\n(exists (n : nat) (s2' : state L2),\n   Plus L2 s2 t s2' /\\\n   Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')) ->\nexists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/\n   Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (0%nat, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"intros [(s2' & A & B) | (n & s2' & A & B)].\nexists (O, s1'), s2'; split.\ndestruct A as [A | [A1 A2]]; auto using lex_ord_right.\nauto using eventually_now.\nexists (n, s1'), s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) (B : match_states s1' s2') : exists (i' : nat * state L1) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/\n   Star L2 s2 t s2'0 /\\ lex_ord Nat.lt order i' (0%nat, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2'0).","conclusion":"exists (i' : nat * state L1) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/\n   Star L2 s2 t s2'0 /\\ lex_ord Nat.lt order i' (0%nat, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2'0)","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) (B : match_states s1' s2')","proofString":"exists (O, s1'), s2'; split.\ndestruct A as [A | [A1 A2]]; auto using lex_ord_right.\nauto using eventually_now."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) (B : match_states s1' s2') : Plus L2 s2 t s2' \\/\nStar L2 s2 t s2' /\\ lex_ord Nat.lt order (0%nat, s1') (0%nat, s1).","conclusion":"Plus L2 s2 t s2' \\/\nStar L2 s2 t s2' /\\ lex_ord Nat.lt order (0%nat, s1') (0%nat, s1)","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) (B : match_states s1' s2')","proofString":"destruct A as [A | [A1 A2]]; auto using lex_ord_right."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) (B : match_states s1' s2') : snd (0%nat, s1') = s1' /\\\nEventually L1 (fst (0%nat, s1')) s1'\n  (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"snd (0%nat, s1') = s1' /\\\nEventually L1 (fst (0%nat, s1')) s1'\n  (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order s1' s1) (B : match_states s1' s2')","proofString":"auto using eventually_now."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (n : nat) (s2' : state L2) (A : Plus L2 s2 t s2') (B : Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')) : exists (i' : nat * state L1) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/\n   Star L2 s2 t s2'0 /\\ lex_ord Nat.lt order i' (0%nat, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2'0).","conclusion":"exists (i' : nat * state L1) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/\n   Star L2 s2 t s2'0 /\\ lex_ord Nat.lt order i' (0%nat, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2'0)","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (n : nat) (s2' : state L2) (A : Plus L2 s2 t s2') (B : Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2'))","proofString":"exists (n, s1'), s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (n0 : nat) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2)) : exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (S n0, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (S n0, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (n0 : nat) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2))","proofString":"apply H1 in H.\ndestruct H.\nsubst t.\nexists (n0, s1'), s2; split.\nright; split.\napply star_refl.\napply lex_ord_left; lia.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (s2 : state L2) (n0 : nat) (H : t = E0 /\\ Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2)) : exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (S n0, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (S n0, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (s2 : state L2) (n0 : nat) (H : t = E0 /\\ Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2))","proofString":"destruct H.\nsubst t.\nexists (n0, s1'), s2; split.\nright; split.\napply star_refl.\napply lex_ord_left; lia.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (s2 : state L2) (n0 : nat) (H : t = E0) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2)) : exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (S n0, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ lex_ord Nat.lt order i' (S n0, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (s2 : state L2) (n0 : nat) (H : t = E0) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t0 : trace) (s' : state L1),\nStep L1 s1 t0 s' ->\nt0 = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2))","proofString":"subst t.\nexists (n0, s1'), s2; split.\nright; split.\napply star_refl.\napply lex_ord_left; lia.\nauto."},{"statement":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2)) : exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/\n   Star L2 s2 E0 s2' /\\ lex_ord Nat.lt order i' (S n0, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2').","conclusion":"exists (i' : nat * state L1) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/\n   Star L2 s2 E0 s2' /\\ lex_ord Nat.lt order i' (S n0, s1)) /\\\n  snd i' = s1' /\\\n  Eventually L1 (fst i') s1' (fun s1'' : state L1 => match_states s1'' s2')","hypotheses":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2))","proofString":"exists (n0, s1'), s2; split.\nright; split.\napply star_refl.\napply lex_ord_left; lia.\nauto."},{"statement":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2)) : Plus L2 s2 E0 s2 \\/\nStar L2 s2 E0 s2 /\\ lex_ord Nat.lt order (n0, s1') (S n0, s1).","conclusion":"Plus L2 s2 E0 s2 \\/\nStar L2 s2 E0 s2 /\\ lex_ord Nat.lt order (n0, s1') (S n0, s1)","hypotheses":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2))","proofString":"right; split.\napply star_refl.\napply lex_ord_left; lia."},{"statement":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2)) : Star L2 s2 E0 s2.","conclusion":"Star L2 s2 E0 s2","hypotheses":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2))","proofString":"apply star_refl."},{"statement":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2)) : lex_ord Nat.lt order (n0, s1') (S n0, s1).","conclusion":"lex_ord Nat.lt order (n0, s1') (S n0, s1)","hypotheses":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2))","proofString":"apply lex_ord_left; lia."},{"statement":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2)) : snd (n0, s1') = s1' /\\\nEventually L1 (fst (n0, s1')) s1'\n  (fun s1'' : state L1 => match_states s1'' s2).","conclusion":"snd (n0, s1') = s1' /\\\nEventually L1 (fst (n0, s1')) s1'\n  (fun s1'' : state L1 => match_states s1'' s2)","hypotheses":"(s1 s1' : state L1) (s2 : state L2) (n0 : nat) (H2 : Eventually L1 n0 s1' (fun s1'' : state L1 => match_states s1'' s2)) (H0 : forall r : int, ~ final_state L1 s1 r) (H1 : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\ Eventually L1 n0 s' (fun s1'' : state L1 => match_states s1'' s2))","proofString":"auto."},{"statement":"(id : AST.ident) : Senv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"Senv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"(id : AST.ident)","proofString":"auto."},{"statement":"well_founded (ltof (state L1) measure).","conclusion":"well_founded (ltof (state L1) measure)","hypotheses":"","proofString":"apply well_founded_ltof."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\n(exists s2' : state L2,\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n   match_states s1' s2') \\/\n(exists (n : nat) (s2' : state L2),\n   Plus L2 s2 t s2' /\\\n   Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2')).","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\n(exists s2' : state L2,\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1' s1) /\\\n   match_states s1' s2') \\/\n(exists (n : nat) (s2' : state L2),\n   Plus L2 s2 t s2' /\\\n   Eventually L1 n s1' (fun s1'' : state L1 => match_states s1'' s2'))","hypotheses":"","proofString":"exact simulation."},{"statement":"(s : state L1) (i : index) (s2 : state L2) (H : match_states i s s2) : exists (i' : index) (s2' : state L2),\n  Star L2 s2 E0 s2' /\\ match_states i' s s2'.","conclusion":"exists (i' : index) (s2' : state L2),\n  Star L2 s2 E0 s2' /\\ match_states i' s s2'","hypotheses":"(s : state L1) (i : index) (s2 : state L2) (H : match_states i s s2)","proofString":"exists i; exists s2; split; auto.\napply star_refl."},{"statement":"(s : state L1) (i : index) (s2 : state L2) (H : match_states i s s2) : Star L2 s2 E0 s2.","conclusion":"Star L2 s2 E0 s2","hypotheses":"(s : state L1) (i : index) (s2 : state L2) (H : match_states i s s2)","proofString":"apply star_refl."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i' : index) (s2' : state L2),\n  Star L2 s4 t2 s2' /\\ match_states i' s3 s2') (i : index) (s0 : state L2) (H2 : match_states i s1 s0) : exists (i' : index) (s2' : state L2),\n  Star L2 s0 t s2' /\\ match_states i' s3 s2'.","conclusion":"exists (i' : index) (s2' : state L2),\n  Star L2 s0 t s2' /\\ match_states i' s3 s2'","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i' : index) (s2' : state L2),\n  Star L2 s4 t2 s2' /\\ match_states i' s3 s2') (i : index) (s0 : state L2) (H2 : match_states i s1 s0)","proofString":"exploit fsim_simulation; eauto.\nintros [i' [s2' [A B]]].\nexploit IHstar; eauto.\nintros [i'' [s2'' [C D]]].\nexists i''; exists s2''; split; auto.\neapply star_trans; eauto.\nintuition auto.\napply plus_star; auto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i' : index) (s2' : state L2),\n  Star L2 s4 t2 s2' /\\ match_states i' s3 s2') (i : index) (s0 : state L2) (H2 : match_states i s1 s0) : (exists (i' : index) (s2' : state L2),\n   (Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) /\\\n   match_states i' s2 s2') ->\nexists (i' : index) (s2' : state L2),\n  Star L2 s0 t s2' /\\ match_states i' s3 s2'.","conclusion":"(exists (i' : index) (s2' : state L2),\n   (Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) /\\\n   match_states i' s2 s2') ->\nexists (i' : index) (s2' : state L2),\n  Star L2 s0 t s2' /\\ match_states i' s3 s2'","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i' : index) (s2' : state L2),\n  Star L2 s4 t2 s2' /\\ match_states i' s3 s2') (i : index) (s0 : state L2) (H2 : match_states i s1 s0)","proofString":"intros [i' [s2' [A B]]].\nexploit IHstar; eauto.\nintros [i'' [s2'' [C D]]].\nexists i''; exists s2''; split; auto.\neapply star_trans; eauto.\nintuition auto.\napply plus_star; auto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2') : exists (i'0 : index) (s2'0 : state L2),\n  Star L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0.","conclusion":"exists (i'0 : index) (s2'0 : state L2),\n  Star L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2')","proofString":"exploit IHstar; eauto.\nintros [i'' [s2'' [C D]]].\nexists i''; exists s2''; split; auto.\neapply star_trans; eauto.\nintuition auto.\napply plus_star; auto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2') : (exists (i'0 : index) (s2'0 : state L2),\n   Star L2 s2' t2 s2'0 /\\ match_states i'0 s3 s2'0) ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0.","conclusion":"(exists (i'0 : index) (s2'0 : state L2),\n   Star L2 s2' t2 s2'0 /\\ match_states i'0 s3 s2'0) ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2')","proofString":"intros [i'' [s2'' [C D]]].\nexists i''; exists s2''; split; auto.\neapply star_trans; eauto.\nintuition auto.\napply plus_star; auto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (C : Star L2 s2' t2 s2'') (D : match_states i'' s3 s2'') : exists (i'0 : index) (s2'0 : state L2),\n  Star L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0.","conclusion":"exists (i'0 : index) (s2'0 : state L2),\n  Star L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (C : Star L2 s2' t2 s2'') (D : match_states i'' s3 s2'')","proofString":"exists i''; exists s2''; split; auto.\neapply star_trans; eauto.\nintuition auto.\napply plus_star; auto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (C : Star L2 s2' t2 s2'') (D : match_states i'' s3 s2'') : Star L2 s0 t s2''.","conclusion":"Star L2 s0 t s2''","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (C : Star L2 s2' t2 s2'') (D : match_states i'' s3 s2'')","proofString":"eapply star_trans; eauto.\nintuition auto.\napply plus_star; auto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (C : Star L2 s2' t2 s2'') (D : match_states i'' s3 s2'') : Star L2 s0 t1 s2'.","conclusion":"Star L2 s0 t1 s2'","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2' \\/ Star L2 s0 t1 s2' /\\ order i' i) (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (C : Star L2 s2' t2 s2'') (D : match_states i'' s3 s2'')","proofString":"intuition auto.\napply plus_star; auto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (C : Star L2 s2' t2 s2'') (D : match_states i'' s3 s2'') (H3 : Plus L2 s0 t1 s2') : Star L2 s0 t1 s2'.","conclusion":"Star L2 s0 t1 s2'","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Star L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\nexists (i'0 : index) (s2'0 : state L2),\n  Star L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (C : Star L2 s2' t2 s2'') (D : match_states i'' s3 s2'') (H3 : Plus L2 s0 t1 s2')","proofString":"apply plus_star; auto."},{"statement":"(s1 : state L1) (t : trace) (s2 : state L1) (H : Step L1 s1 t s2) (i : index) (s0 : state L2) (H0 : match_states i s1 s0) : (exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s2 s0).","conclusion":"(exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s2 s0)","hypotheses":"(s1 : state L1) (t : trace) (s2 : state L1) (H : Step L1 s1 t s2) (i : index) (s0 : state L2) (H0 : match_states i s1 s0)","proofString":"exploit fsim_simulation'; eauto.\nintros [A | [i' A]].\nleft; auto.\nright; exists i'; intuition auto with sets."},{"statement":"(s1 : state L1) (t : trace) (s2 : state L1) (H : Step L1 s1 t s2) (i : index) (s0 : state L2) (H0 : match_states i s1 s0) : (exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s2 s0) ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s2 s0).","conclusion":"(exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s2 s0) ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s2 s0)","hypotheses":"(s1 : state L1) (t : trace) (s2 : state L1) (H : Step L1 s1 t s2) (i : index) (s0 : state L2) (H0 : match_states i s1 s0)","proofString":"intros [A | [i' A]].\nleft; auto.\nright; exists i'; intuition auto with sets."},{"statement":"(s1 : state L1) (t : trace) (s2 : state L1) (H : Step L1 s1 t s2) (i : index) (s0 : state L2) (H0 : match_states i s1 s0) (A : exists (i' : index) (s2' : state L2),\n  Plus L2 s0 t s2' /\\ match_states i' s2 s2') : (exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s2 s0).","conclusion":"(exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s2 s0)","hypotheses":"(s1 : state L1) (t : trace) (s2 : state L1) (H : Step L1 s1 t s2) (i : index) (s0 : state L2) (H0 : match_states i s1 s0) (A : exists (i' : index) (s2' : state L2),\n  Plus L2 s0 t s2' /\\ match_states i' s2 s2')","proofString":"left; auto."},{"statement":"(s1 : state L1) (t : trace) (s2 : state L1) (H : Step L1 s1 t s2) (i : index) (s0 : state L2) (H0 : match_states i s1 s0) (i' : index) (A : order i' i /\\ t = E0 /\\ match_states i' s2 s0) : (exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s2 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s2 s0).","conclusion":"(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s2 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s2 s0)","hypotheses":"(s1 : state L1) (t : trace) (s2 : state L1) (H : Step L1 s1 t s2) (i : index) (s0 : state L2) (H0 : match_states i s1 s0) (i' : index) (A : order i' i /\\ t = E0 /\\ match_states i' s2 s0)","proofString":"right; exists i'; intuition auto with sets."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i' s3 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i0 /\\ t2 = E0 /\\ match_states i' s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) : (exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s3 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s3 s0).","conclusion":"(exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s3 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s3 s0)","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i' s3 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i0 /\\ t2 = E0 /\\ match_states i' s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0)","proofString":"exploit fsim_simulation'; eauto.\nintros [[i' [s2' [A B]]] | [i' [A [B C]]]].\nexploit simulation_star.\napply plus_star; eauto.\neauto.\nintros [i'' [s2'' [P Q]]].\nleft; exists i''; exists s2''; split; auto.\neapply plus_star_trans; eauto.\nexploit IHplus; eauto.\nintros [[i'' [s2'' [P Q]]] | [i'' [P [Q R]]]].\nsubst.\nsimpl.\nleft; exists i''; exists s2''; auto.\nsubst.\nsimpl.\nright; exists i''; intuition auto.\neapply t_trans; eauto.\neapply t_step; eauto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i' s3 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i0 /\\ t2 = E0 /\\ match_states i' s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) : (exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t1 s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index, order i' i /\\ t1 = E0 /\\ match_states i' s2 s0) ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s3 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s3 s0).","conclusion":"(exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t1 s2' /\\ match_states i' s2 s2') \\/\n(exists i' : index, order i' i /\\ t1 = E0 /\\ match_states i' s2 s0) ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i' s3 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i /\\ t = E0 /\\ match_states i' s3 s0)","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i' : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i' s3 s2') \\/\n(exists i' : index,\n   clos_trans index order i' i0 /\\ t2 = E0 /\\ match_states i' s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0)","proofString":"intros [[i' [s2' [A B]]] | [i' [A [B C]]]].\nexploit simulation_star.\napply plus_star; eauto.\neauto.\nintros [i'' [s2'' [P Q]]].\nleft; exists i''; exists s2''; split; auto.\neapply plus_star_trans; eauto.\nexploit IHplus; eauto.\nintros [[i'' [s2'' [P Q]]] | [i'' [P [Q R]]]].\nsubst.\nsimpl.\nleft; exists i''; exists s2''; auto.\nsubst.\nsimpl.\nright; exists i''; intuition auto.\neapply t_trans; eauto.\neapply t_step; eauto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2') (B : match_states i' s2 s2') : (exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2') (B : match_states i' s2 s2')","proofString":"exploit simulation_star.\napply plus_star; eauto.\neauto.\nintros [i'' [s2'' [P Q]]].\nleft; exists i''; exists s2''; split; auto.\neapply plus_star_trans; eauto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2') (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (P : Star L2 s2' t2 s2'') (Q : match_states i'' s3 s2'') : (exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s0 t s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2') (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (P : Star L2 s2' t2 s2'') (Q : match_states i'' s3 s2'')","proofString":"left; exists i''; exists s2''; split; auto.\neapply plus_star_trans; eauto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2') (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (P : Star L2 s2' t2 s2'') (Q : match_states i'' s3 s2'') : Plus L2 s0 t s2''.","conclusion":"Plus L2 s0 t s2''","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2'0 : state L2),\n   Plus L2 s4 t2 s2'0 /\\ match_states i'0 s3 s2'0) \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (s2' : state L2) (A : Plus L2 s0 t1 s2') (B : match_states i' s2 s2') (i'' : index) (s2'' : state L2) (P : Star L2 s2' t2 s2'') (Q : match_states i'' s3 s2'')","proofString":"eapply plus_star_trans; eauto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (B : t1 = E0) (C : match_states i' s2 s0) : (exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (B : t1 = E0) (C : match_states i' s2 s0)","proofString":"exploit IHplus; eauto.\nintros [[i'' [s2'' [P Q]]] | [i'' [P [Q R]]]].\nsubst.\nsimpl.\nleft; exists i''; exists s2''; auto.\nsubst.\nsimpl.\nright; exists i''; intuition auto.\neapply t_trans; eauto.\neapply t_step; eauto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (B : t1 = E0) (C : match_states i' s2 s0) : (exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i' /\\ t2 = E0 /\\ match_states i'0 s3 s0) ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i' /\\ t2 = E0 /\\ match_states i'0 s3 s0) ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (B : t1 = E0) (C : match_states i' s2 s0)","proofString":"intros [[i'' [s2'' [P Q]]] | [i'' [P [Q R]]]].\nsubst.\nsimpl.\nleft; exists i''; exists s2''; auto.\nsubst.\nsimpl.\nright; exists i''; intuition auto.\neapply t_trans; eauto.\neapply t_step; eauto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (B : t1 = E0) (C : match_states i' s2 s0) (i'' : index) (s2'' : state L2) (P : Plus L2 s0 t2 s2'') (Q : match_states i'' s3 s2'') : (exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (B : t1 = E0) (C : match_states i' s2 s0) (i'' : index) (s2'' : state L2) (P : Plus L2 s0 t2 s2'') (Q : match_states i'' s3 s2'')","proofString":"subst.\nsimpl.\nleft; exists i''; exists s2''; auto."},{"statement":"(s1 s2 : state L1) (t2 : trace) (s3 : state L1) (H : Step L1 s1 E0 s2) (H0 : Plus L1 s2 t2 s3) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (s2'' : state L2) (P : Plus L2 s0 t2 s2'') (Q : match_states i'' s3 s2'') : (exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 (E0 ** t2) s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ E0 ** t2 = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 (E0 ** t2) s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ E0 ** t2 = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 s2 : state L1) (t2 : trace) (s3 : state L1) (H : Step L1 s1 E0 s2) (H0 : Plus L1 s2 t2 s3) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (s2'' : state L2) (P : Plus L2 s0 t2 s2'') (Q : match_states i'' s3 s2'')","proofString":"simpl.\nleft; exists i''; exists s2''; auto."},{"statement":"(s1 s2 : state L1) (t2 : trace) (s3 : state L1) (H : Step L1 s1 E0 s2) (H0 : Plus L1 s2 t2 s3) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (s2'' : state L2) (P : Plus L2 s0 t2 s2'') (Q : match_states i'' s3 s2'') : (exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t2 = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t2 = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 s2 : state L1) (t2 : trace) (s3 : state L1) (H : Step L1 s1 E0 s2) (H0 : Plus L1 s2 t2 s3) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (s2'' : state L2) (P : Plus L2 s0 t2 s2'') (Q : match_states i'' s3 s2'')","proofString":"left; exists i''; exists s2''; auto."},{"statement":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (B : t1 = E0) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (Q : t2 = E0) (R : match_states i'' s3 s0) : (exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 t s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ t = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 : state L1) (t1 : trace) (s2 : state L1) (t2 : trace) (s3 : state L1) (t : trace) (H : Step L1 s1 t1 s2) (H0 : Plus L1 s2 t2 s3) (H1 : t = t1 ** t2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 t2 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ t2 = E0 /\\ match_states i'0 s3 s4)) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (B : t1 = E0) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (Q : t2 = E0) (R : match_states i'' s3 s0)","proofString":"subst.\nsimpl.\nright; exists i''; intuition auto.\neapply t_trans; eauto.\neapply t_step; eauto."},{"statement":"(s1 s2 s3 : state L1) (H : Step L1 s1 E0 s2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ E0 = E0 /\\ match_states i'0 s3 s4)) (H0 : Plus L1 s2 E0 s3) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (R : match_states i'' s3 s0) : (exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 (E0 ** E0) s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ E0 ** E0 = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 (E0 ** E0) s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ E0 ** E0 = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 s2 s3 : state L1) (H : Step L1 s1 E0 s2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ E0 = E0 /\\ match_states i'0 s3 s4)) (H0 : Plus L1 s2 E0 s3) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (R : match_states i'' s3 s0)","proofString":"simpl.\nright; exists i''; intuition auto.\neapply t_trans; eauto.\neapply t_step; eauto."},{"statement":"(s1 s2 s3 : state L1) (H : Step L1 s1 E0 s2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ E0 = E0 /\\ match_states i'0 s3 s4)) (H0 : Plus L1 s2 E0 s3) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (R : match_states i'' s3 s0) : (exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ E0 = E0 /\\ match_states i'0 s3 s0).","conclusion":"(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s0 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i /\\ E0 = E0 /\\ match_states i'0 s3 s0)","hypotheses":"(s1 s2 s3 : state L1) (H : Step L1 s1 E0 s2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ E0 = E0 /\\ match_states i'0 s3 s4)) (H0 : Plus L1 s2 E0 s3) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (R : match_states i'' s3 s0)","proofString":"right; exists i''; intuition auto.\neapply t_trans; eauto.\neapply t_step; eauto."},{"statement":"(s1 s2 s3 : state L1) (H : Step L1 s1 E0 s2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ E0 = E0 /\\ match_states i'0 s3 s4)) (H0 : Plus L1 s2 E0 s3) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (R : match_states i'' s3 s0) : clos_trans index order i'' i.","conclusion":"clos_trans index order i'' i","hypotheses":"(s1 s2 s3 : state L1) (H : Step L1 s1 E0 s2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ E0 = E0 /\\ match_states i'0 s3 s4)) (H0 : Plus L1 s2 E0 s3) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (R : match_states i'' s3 s0)","proofString":"eapply t_trans; eauto.\neapply t_step; eauto."},{"statement":"(s1 s2 s3 : state L1) (H : Step L1 s1 E0 s2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ E0 = E0 /\\ match_states i'0 s3 s4)) (H0 : Plus L1 s2 E0 s3) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (R : match_states i'' s3 s0) : clos_trans index order i' i.","conclusion":"clos_trans index order i' i","hypotheses":"(s1 s2 s3 : state L1) (H : Step L1 s1 E0 s2) (IHplus : forall (i0 : index) (s4 : state L2),\nmatch_states i0 s2 s4 ->\n(exists (i'0 : index) (s2' : state L2),\n   Plus L2 s4 E0 s2' /\\ match_states i'0 s3 s2') \\/\n(exists i'0 : index,\n   clos_trans index order i'0 i0 /\\ E0 = E0 /\\ match_states i'0 s3 s4)) (H0 : Plus L1 s2 E0 s3) (i : index) (s0 : state L2) (H2 : match_states i s1 s0) (i' : index) (A : order i' i) (C : match_states i' s2 s0) (i'' : index) (P : clos_trans index order i'' i') (R : match_states i'' s3 s0)","proofString":"eapply t_step; eauto."},{"statement":"forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L1 s1 ->\nmatch_states i s1 s2 -> forever_silent_N (step L2) order (globalenv L2) i s2.","conclusion":"forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L1 s1 ->\nmatch_states i s1 s2 -> forever_silent_N (step L2) order (globalenv L2) i s2","hypotheses":"","proofString":"cofix COINDHYP; intros.\ninv H.\ndestruct (fsim_simulation S _ _ _ H1 _ _ H0) as [i' [s2' [A B]]].\ndestruct A as [C | [C D]].\neapply forever_silent_N_plus; eauto.\neapply forever_silent_N_star; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s3 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s3) (i : index) (s1 : state L1) (s2 : state L2) (H : Forever_silent L1 s1) (H0 : match_states i s1 s2) : forever_silent_N (step L2) order (globalenv L2) i s2.","conclusion":"forever_silent_N (step L2) order (globalenv L2) i s2","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s3 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s3) (i : index) (s1 : state L1) (s2 : state L2) (H : Forever_silent L1 s1) (H0 : match_states i s1 s2)","proofString":"inv H.\ndestruct (fsim_simulation S _ _ _ H1 _ _ H0) as [i' [s2' [A B]]].\ndestruct A as [C | [C D]].\neapply forever_silent_N_plus; eauto.\neapply forever_silent_N_star; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s4 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s4) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (H1 : Step L1 s1 E0 s3) (H2 : Forever_silent L1 s3) : forever_silent_N (step L2) order (globalenv L2) i s2.","conclusion":"forever_silent_N (step L2) order (globalenv L2) i s2","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s4 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s4) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (H1 : Step L1 s1 E0 s3) (H2 : Forever_silent L1 s3)","proofString":"destruct (fsim_simulation S _ _ _ H1 _ _ H0) as [i' [s2' [A B]]].\ndestruct A as [C | [C D]].\neapply forever_silent_N_plus; eauto.\neapply forever_silent_N_star; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s4 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s4) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (H1 : Step L1 s1 E0 s3) (H2 : Forever_silent L1 s3) (i' : index) (s2' : state L2) (A : Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) (B : match_states i' s3 s2') : forever_silent_N (step L2) order (globalenv L2) i s2.","conclusion":"forever_silent_N (step L2) order (globalenv L2) i s2","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s4 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s4) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (H1 : Step L1 s1 E0 s3) (H2 : Forever_silent L1 s3) (i' : index) (s2' : state L2) (A : Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) (B : match_states i' s3 s2')","proofString":"destruct A as [C | [C D]].\neapply forever_silent_N_plus; eauto.\neapply forever_silent_N_star; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s4 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s4) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (H1 : Step L1 s1 E0 s3) (H2 : Forever_silent L1 s3) (i' : index) (s2' : state L2) (C : Plus L2 s2 E0 s2') (B : match_states i' s3 s2') : forever_silent_N (step L2) order (globalenv L2) i s2.","conclusion":"forever_silent_N (step L2) order (globalenv L2) i s2","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s4 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s4) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (H1 : Step L1 s1 E0 s3) (H2 : Forever_silent L1 s3) (i' : index) (s2' : state L2) (C : Plus L2 s2 E0 s2') (B : match_states i' s3 s2')","proofString":"eapply forever_silent_N_plus; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s4 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s4) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (H1 : Step L1 s1 E0 s3) (H2 : Forever_silent L1 s3) (i' : index) (s2' : state L2) (C : Star L2 s2 E0 s2') (D : order i' i) (B : match_states i' s3 s2') : forever_silent_N (step L2) order (globalenv L2) i s2.","conclusion":"forever_silent_N (step L2) order (globalenv L2) i s2","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s4 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s4) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (H1 : Step L1 s1 E0 s3) (H2 : Forever_silent L1 s3) (i' : index) (s2' : state L2) (C : Star L2 s2 E0 s2') (D : order i' i) (B : match_states i' s3 s2')","proofString":"eapply forever_silent_N_star; eauto."},{"statement":"(H : forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L1 s1 ->\nmatch_states i s1 s2 -> forever_silent_N (step L2) order (globalenv L2) i s2) : forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L1 s1 -> match_states i s1 s2 -> Forever_silent L2 s2.","conclusion":"forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L1 s1 -> match_states i s1 s2 -> Forever_silent L2 s2","hypotheses":"(H : forall (i : index) (s1 : state L1) (s2 : state L2),\nForever_silent L1 s1 ->\nmatch_states i s1 s2 -> forever_silent_N (step L2) order (globalenv L2) i s2)","proofString":"intros.\neapply forever_silent_N_forever; eauto.\neapply fsim_order_wf; eauto."},{"statement":"(H : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s3 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s3) (i : index) (s1 : state L1) (s2 : state L2) (H0 : Forever_silent L1 s1) (H1 : match_states i s1 s2) : Forever_silent L2 s2.","conclusion":"Forever_silent L2 s2","hypotheses":"(H : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s3 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s3) (i : index) (s1 : state L1) (s2 : state L2) (H0 : Forever_silent L1 s1) (H1 : match_states i s1 s2)","proofString":"eapply forever_silent_N_forever; eauto.\neapply fsim_order_wf; eauto."},{"statement":"(H : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s3 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s3) (i : index) (s1 : state L1) (s2 : state L2) (H0 : Forever_silent L1 s1) (H1 : match_states i s1 s2) : well_founded order.","conclusion":"well_founded order","hypotheses":"(H : forall (i0 : index) (s0 : state L1) (s3 : state L2),\nForever_silent L1 s0 ->\nmatch_states i0 s0 s3 ->\nforever_silent_N (step L2) order (globalenv L2) i0 s3) (i : index) (s1 : state L1) (s2 : state L2) (H0 : Forever_silent L1 s1) (H1 : match_states i s1 s2)","proofString":"eapply fsim_order_wf; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s3 : state L2) (T0 : traceinf),\nForever_reactive L1 s0 T0 ->\nmatch_states i0 s0 s3 -> Forever_reactive L2 s3 T0) (i : index) (s1 : state L1) (s2 : state L2) (T : traceinf) (H : Forever_reactive L1 s1 T) (H0 : match_states i s1 s2) : Forever_reactive L2 s2 T.","conclusion":"Forever_reactive L2 s2 T","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s3 : state L2) (T0 : traceinf),\nForever_reactive L1 s0 T0 ->\nmatch_states i0 s0 s3 -> Forever_reactive L2 s3 T0) (i : index) (s1 : state L1) (s2 : state L2) (T : traceinf) (H : Forever_reactive L1 s1 T) (H0 : match_states i s1 s2)","proofString":"inv H.\nedestruct simulation_star as [i' [st2' [A B]]]; eauto.\neconstructor; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L1 s0 T -> match_states i0 s0 s4 -> Forever_reactive L2 s4 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (t : trace) (T0 : traceinf) (H1 : Star L1 s1 t s3) (H2 : t <> E0) (H3 : Forever_reactive L1 s3 T0) : Forever_reactive L2 s2 (t *** T0).","conclusion":"Forever_reactive L2 s2 (t *** T0)","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L1 s0 T -> match_states i0 s0 s4 -> Forever_reactive L2 s4 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (t : trace) (T0 : traceinf) (H1 : Star L1 s1 t s3) (H2 : t <> E0) (H3 : Forever_reactive L1 s3 T0)","proofString":"edestruct simulation_star as [i' [st2' [A B]]]; eauto.\neconstructor; eauto."},{"statement":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L1 s0 T -> match_states i0 s0 s4 -> Forever_reactive L2 s4 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (t : trace) (T0 : traceinf) (H1 : Star L1 s1 t s3) (H2 : t <> E0) (H3 : Forever_reactive L1 s3 T0) (i' : index) (st2' : state L2) (A : Star L2 s2 t st2') (B : match_states i' s3 st2') : Forever_reactive L2 s2 (t *** T0).","conclusion":"Forever_reactive L2 s2 (t *** T0)","hypotheses":"(COINDHYP : forall (i0 : index) (s0 : state L1) (s4 : state L2) (T : traceinf),\nForever_reactive L1 s0 T -> match_states i0 s0 s4 -> Forever_reactive L2 s4 T) (i : index) (s1 : state L1) (s2 : state L2) (H0 : match_states i s1 s2) (s3 : state L1) (t : trace) (T0 : traceinf) (H1 : Star L1 s1 t s3) (H2 : t <> E0) (H3 : Forever_reactive L1 s3 T0) (i' : index) (st2' : state L2) (A : Star L2 s2 t st2') (B : match_states i' s3 st2')","proofString":"econstructor; eauto."},{"statement":"(L1 L2 L3 : semantics) (S12 : forward_simulation L1 L2) (S23 : forward_simulation L2 L3) : forward_simulation L1 L3.","conclusion":"forward_simulation L1 L3","hypotheses":"(L1 L2 L3 : semantics) (S12 : forward_simulation L1 L2) (S23 : forward_simulation L2 L3)","proofString":"destruct S12 as [index order match_states props].\ndestruct S23 as [index' order' match_states' props'].\nset (ff_index := (index' * index)%type).\nset (ff_order := lex_ord (clos_trans _ order') order).\nset (ff_match_states := fun (i: ff_index) (s1: state L1) (s3: state L3) =>                             exists s2, match_states (snd i) s1 s2 /\\ match_states' (fst i) s2 s3).\napply Forward_simulation with ff_order ff_match_states; constructor.\nunfold ff_order.\napply wf_lex_ord.\napply wf_clos_trans.\neapply fsim_order_wf; eauto.\neapply fsim_order_wf; eauto.\nintros.\nexploit (fsim_match_initial_states props); eauto.\nintros [i [s2 [A B]]].\nexploit (fsim_match_initial_states props'); eauto.\nintros [i' [s3 [C D]]].\nexists (i', i); exists s3; split; auto.\nexists s2; auto.\nintros.\ndestruct H as [s3 [A B]].\neapply (fsim_match_final_states props'); eauto.\neapply (fsim_match_final_states props); eauto.\nintros.\ndestruct H0 as [s3 [A B]].\ndestruct i as [i2 i1]; simpl in *.\nexploit (fsim_simulation' props); eauto.\nintros [[i1' [s3' [C D]]] | [i1' [C [D E]]]].\nexploit simulation_plus; eauto.\nintros [[i2' [s2' [P Q]]] | [i2' [P [Q R]]]].\nexists (i2', i1'); exists s2'; split.\nauto.\nexists s3'; auto.\nexists (i2', i1'); exists s2; split.\nright; split.\nsubst t; apply star_refl.\nred.\nleft.\nauto.\nexists s3'; auto.\nexists (i2, i1'); exists s2; split.\nright; split.\nsubst t; apply star_refl.\nred.\nright.\nauto.\nexists s3; auto.\nintros.\ntransitivity (Senv.public_symbol (symbolenv L2) id); eapply fsim_public_preserved; eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (S23 : forward_simulation L2 L3) : forward_simulation L1 L3.","conclusion":"forward_simulation L1 L3","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (S23 : forward_simulation L2 L3)","proofString":"destruct S23 as [index' order' match_states' props'].\nset (ff_index := (index' * index)%type).\nset (ff_order := lex_ord (clos_trans _ order') order).\nset (ff_match_states := fun (i: ff_index) (s1: state L1) (s3: state L3) =>                             exists s2, match_states (snd i) s1 s2 /\\ match_states' (fst i) s2 s3).\napply Forward_simulation with ff_order ff_match_states; constructor.\nunfold ff_order.\napply wf_lex_ord.\napply wf_clos_trans.\neapply fsim_order_wf; eauto.\neapply fsim_order_wf; eauto.\nintros.\nexploit (fsim_match_initial_states props); eauto.\nintros [i [s2 [A B]]].\nexploit (fsim_match_initial_states props'); eauto.\nintros [i' [s3 [C D]]].\nexists (i', i); exists s3; split; auto.\nexists s2; auto.\nintros.\ndestruct H as [s3 [A B]].\neapply (fsim_match_final_states props'); eauto.\neapply (fsim_match_final_states props); eauto.\nintros.\ndestruct H0 as [s3 [A B]].\ndestruct i as [i2 i1]; simpl in *.\nexploit (fsim_simulation' props); eauto.\nintros [[i1' [s3' [C D]]] | [i1' [C [D E]]]].\nexploit simulation_plus; eauto.\nintros [[i2' [s2' [P Q]]] | [i2' [P [Q R]]]].\nexists (i2', i1'); exists s2'; split.\nauto.\nexists s3'; auto.\nexists (i2', i1'); exists s2; split.\nright; split.\nsubst t; apply star_refl.\nred.\nleft.\nauto.\nexists s3'; auto.\nexists (i2, i1'); exists s2; split.\nright; split.\nsubst t; apply star_refl.\nred.\nright.\nauto.\nexists s3; auto.\nintros.\ntransitivity (Senv.public_symbol (symbolenv L2) id); eapply fsim_public_preserved; eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') : forward_simulation L1 L3.","conclusion":"forward_simulation L1 L3","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states')","proofString":"set (ff_index := (index' * index)%type).\nset (ff_order := lex_ord (clos_trans _ order') order).\nset (ff_match_states := fun (i: ff_index) (s1: state L1) (s3: state L3) =>                             exists s2, match_states (snd i) s1 s2 /\\ match_states' (fst i) s2 s3).\napply Forward_simulation with ff_order ff_match_states; constructor.\nunfold ff_order.\napply wf_lex_ord.\napply wf_clos_trans.\neapply fsim_order_wf; eauto.\neapply fsim_order_wf; eauto.\nintros.\nexploit (fsim_match_initial_states props); eauto.\nintros [i [s2 [A B]]].\nexploit (fsim_match_initial_states props'); eauto.\nintros [i' [s3 [C D]]].\nexists (i', i); exists s3; split; auto.\nexists s2; auto.\nintros.\ndestruct H as [s3 [A B]].\neapply (fsim_match_final_states props'); eauto.\neapply (fsim_match_final_states props); eauto.\nintros.\ndestruct H0 as [s3 [A B]].\ndestruct i as [i2 i1]; simpl in *.\nexploit (fsim_simulation' props); eauto.\nintros [[i1' [s3' [C D]]] | [i1' [C [D E]]]].\nexploit simulation_plus; eauto.\nintros [[i2' [s2' [P Q]]] | [i2' [P [Q R]]]].\nexists (i2', i1'); exists s2'; split.\nauto.\nexists s3'; auto.\nexists (i2', i1'); exists s2; split.\nright; split.\nsubst t; apply star_refl.\nred.\nleft.\nauto.\nexists s3'; auto.\nexists (i2, i1'); exists s2; split.\nright; split.\nsubst t; apply star_refl.\nred.\nright.\nauto.\nexists s3; auto.\nintros.\ntransitivity (Senv.public_symbol (symbolenv L2) id); eapply fsim_public_preserved; eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) : well_founded (lex_ord (clos_trans index' order') order).","conclusion":"well_founded (lex_ord (clos_trans index' order') order)","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop)","proofString":"apply wf_lex_ord.\napply wf_clos_trans.\neapply fsim_order_wf; eauto.\neapply fsim_order_wf; eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) : well_founded (clos_trans index' order').","conclusion":"well_founded (clos_trans index' order')","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop)","proofString":"apply wf_clos_trans.\neapply fsim_order_wf; eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) : well_founded order'.","conclusion":"well_founded order'","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop)","proofString":"eapply fsim_order_wf; eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) : well_founded order.","conclusion":"well_founded order","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop)","proofString":"eapply fsim_order_wf; eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (i : index' * index) (s1 : state L1) (s2 : state L3) (r : int) (s3 : state L2) (A : match_states (snd i) s1 s3) (B : match_states' (fst i) s3 s2) (H0 : final_state L1 s1 r) : final_state L3 s2 r.","conclusion":"final_state L3 s2 r","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (i : index' * index) (s1 : state L1) (s2 : state L3) (r : int) (s3 : state L2) (A : match_states (snd i) s1 s3) (B : match_states' (fst i) s3 s2) (H0 : final_state L1 s1 r)","proofString":"eapply (fsim_match_final_states props'); eauto.\neapply (fsim_match_final_states props); eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (i : index' * index) (s1 : state L1) (s2 : state L3) (r : int) (s3 : state L2) (A : match_states (snd i) s1 s3) (B : match_states' (fst i) s3 s2) (H0 : final_state L1 s1 r) : final_state L2 s3 r.","conclusion":"final_state L2 s3 r","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (i : index' * index) (s1 : state L1) (s2 : state L3) (r : int) (s3 : state L2) (A : match_states (snd i) s1 s3) (B : match_states' (fst i) s3 s2) (H0 : final_state L1 s1 r)","proofString":"eapply (fsim_match_final_states props); eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (s3' : state L2) (C : Plus L2 s3 t s3') (D : match_states i1' s1' s3') (i2' : index') (s2' : state L3) (P : Plus L3 s2 t s2') (Q : match_states' i2' s3' s2') : Plus L3 s2 t s2' \\/ Star L3 s2 t s2' /\\ ff_order (i2', i1') (i2, i1).","conclusion":"Plus L3 s2 t s2' \\/ Star L3 s2 t s2' /\\ ff_order (i2', i1') (i2, i1)","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (s3' : state L2) (C : Plus L2 s3 t s3') (D : match_states i1' s1' s3') (i2' : index') (s2' : state L3) (P : Plus L3 s2 t s2') (Q : match_states' i2' s3' s2')","proofString":"auto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (s3' : state L2) (C : Plus L2 s3 t s3') (D : match_states i1' s1' s3') (i2' : index') (P : clos_trans index' order' i2' i2) (Q : t = E0) (R : match_states' i2' s3' s2) : Star L3 s2 t s2.","conclusion":"Star L3 s2 t s2","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (s3' : state L2) (C : Plus L2 s3 t s3') (D : match_states i1' s1' s3') (i2' : index') (P : clos_trans index' order' i2' i2) (Q : t = E0) (R : match_states' i2' s3' s2)","proofString":"subst t; apply star_refl."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (s3' : state L2) (C : Plus L2 s3 t s3') (D : match_states i1' s1' s3') (i2' : index') (P : clos_trans index' order' i2' i2) (Q : t = E0) (R : match_states' i2' s3' s2) : lex_ord (clos_trans index' order') order (i2', i1') (i2, i1).","conclusion":"lex_ord (clos_trans index' order') order (i2', i1') (i2, i1)","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (s3' : state L2) (C : Plus L2 s3 t s3') (D : match_states i1' s1' s3') (i2' : index') (P : clos_trans index' order' i2' i2) (Q : t = E0) (R : match_states' i2' s3' s2)","proofString":"left.\nauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (s3' : state L2) (C : Plus L2 s3 t s3') (D : match_states i1' s1' s3') (i2' : index') (P : clos_trans index' order' i2' i2) (Q : t = E0) (R : match_states' i2' s3' s2) : clos_trans index' order' i2' i2.","conclusion":"clos_trans index' order' i2' i2","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (s3' : state L2) (C : Plus L2 s3 t s3') (D : match_states i1' s1' s3') (i2' : index') (P : clos_trans index' order' i2' i2) (Q : t = E0) (R : match_states' i2' s3' s2)","proofString":"auto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (C : order i1' i1) (D : t = E0) (E : match_states i1' s1' s3) : Star L3 s2 t s2.","conclusion":"Star L3 s2 t s2","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (C : order i1' i1) (D : t = E0) (E : match_states i1' s1' s3)","proofString":"subst t; apply star_refl."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (C : order i1' i1) (D : t = E0) (E : match_states i1' s1' s3) : lex_ord (clos_trans index' order') order (i2, i1') (i2, i1).","conclusion":"lex_ord (clos_trans index' order') order (i2, i1') (i2, i1)","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (C : order i1' i1) (D : t = E0) (E : match_states i1' s1' s3)","proofString":"right.\nauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (C : order i1' i1) (D : t = E0) (E : match_states i1' s1' s3) : order i1' i1.","conclusion":"order i1' i1","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i2 : index') (i1 : index) (s2 : state L3) (s3 : state L2) (A : match_states i1 s1 s3) (B : match_states' i2 s3 s2) (i1' : index) (C : order i1' i1) (D : t = E0) (E : match_states i1' s1' s3)","proofString":"auto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) : forall id : AST.ident,\nSenv.public_symbol (symbolenv L3) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L3) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop)","proofString":"intros.\ntransitivity (Senv.public_symbol (symbolenv L2) id); eapply fsim_public_preserved; eauto."},{"statement":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (id : AST.ident) : Senv.public_symbol (symbolenv L3) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"Senv.public_symbol (symbolenv L3) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"(L1 L2 L3 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : fsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : fsim_properties L2 L3 index' order' match_states') (ff_index : Type) (ff_order : index' * index -> index' * index -> Prop) (ff_match_states : ff_index -> state L1 -> state L3 -> Prop) (id : AST.ident)","proofString":"transitivity (Senv.public_symbol (symbolenv L2) id); eapply fsim_public_preserved; eauto."},{"statement":"(s : state L) (t1 : trace) (s1 : state L) (t2 : trace) (s2 : state L) (H : Step L s t1 s1) (H0 : Step L s t2 s2) : match_traces (symbolenv L) t1 t2.","conclusion":"match_traces (symbolenv L) t1 t2","hypotheses":"(s : state L) (t1 : trace) (s1 : state L) (t2 : trace) (s2 : state L) (H : Step L s t1 s1) (H0 : Step L s t2 s2)","proofString":"eapply sd_determ; eauto."},{"statement":"(s : state L) (t : trace) (s1 s2 : state L) (H : Step L s t s1) (H0 : Step L s t s2) : s1 = s2.","conclusion":"s1 = s2","hypotheses":"(s : state L) (t : trace) (s1 s2 : state L) (H : Step L s t s1) (H0 : Step L s t s2)","proofString":"eapply sd_determ; eauto."},{"statement":"(s : state L) (t : trace) (s1 s2 : state L) (H : Step L s t s1) (H0 : Step L s E0 s2) : t = E0 /\\ s1 = s2.","conclusion":"t = E0 /\\ s1 = s2","hypotheses":"(s : state L) (t : trace) (s1 s2 : state L) (H : Step L s t s1) (H0 : Step L s E0 s2)","proofString":"exploit (sd_determ DET).\neexact H.\neexact H0.\nintros [A B].\ninv A.\nauto."},{"statement":"(s : state L) (t : trace) (s1 s2 : state L) (H : Step L s t s1) (H0 : Step L s E0 s2) (A : match_traces (symbolenv L) t E0) (B : t = E0 -> s1 = s2) : t = E0 /\\ s1 = s2.","conclusion":"t = E0 /\\ s1 = s2","hypotheses":"(s : state L) (t : trace) (s1 s2 : state L) (H : Step L s t s1) (H0 : Step L s E0 s2) (A : match_traces (symbolenv L) t E0) (B : t = E0 -> s1 = s2)","proofString":"inv A.\nauto."},{"statement":"(s s1 s2 : state L) (H : Step L s nil s1) (H0 : Step L s E0 s2) (B : nil = E0 -> s1 = s2) : nil = E0 /\\ s1 = s2.","conclusion":"nil = E0 /\\ s1 = s2","hypotheses":"(s s1 s2 : state L) (H : Step L s nil s1) (H0 : Step L s E0 s2) (B : nil = E0 -> s1 = s2)","proofString":"auto."},{"statement":"(s s'' : state L) (H : Star L s E0 s'') : Star L s E0 s'' \\/ Star L s'' E0 s.","conclusion":"Star L s E0 s'' \\/ Star L s'' E0 s","hypotheses":"(s s'' : state L) (H : Star L s E0 s'')","proofString":"auto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (t : trace) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (H2 : Star L s1 t s'') : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (t : trace) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (H2 : Star L s1 t s'')","proofString":"inv H2.\nright.\neapply star_step; eauto.\nexploit sd_determ_1.\neexact H.\neexact H3.\nintros MT.\nexploit (sd_traces DET).\neexact H.\nintros L1.\nexploit (sd_traces DET).\neexact H3.\nintros L2.\nassert (t1 = t0 /\\ t2 = t3).\ndestruct t1.\ninv MT.\nauto.\ndestruct t1; simpl in L1; try extlia.\ndestruct t0.\ninv MT.\ndestruct t0; simpl in L2; try extlia.\nsimpl in H5.\nsplit.\ncongruence.\ncongruence.\ndestruct H1; subst.\nassert (s2 = s4) by (eapply sd_determ_2; eauto).\nsubst s4.\nauto."},{"statement":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s'' : state L) (H : Step L s'' t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H4 : E0 = t1 ** t2) : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s'' : state L) (H : Step L s'' t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H4 : E0 = t1 ** t2)","proofString":"right.\neapply star_step; eauto."},{"statement":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s'' : state L) (H : Step L s'' t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H4 : E0 = t1 ** t2) : Star L s'' E0 s3.","conclusion":"Star L s'' E0 s3","hypotheses":"(t1 : trace) (s2 : state L) (t2 : trace) (s3 s'' : state L) (H : Step L s'' t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H4 : E0 = t1 ** t2)","proofString":"eapply star_step; eauto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3)","proofString":"exploit sd_determ_1.\neexact H.\neexact H3.\nintros MT.\nexploit (sd_traces DET).\neexact H.\nintros L1.\nexploit (sd_traces DET).\neexact H3.\nintros L2.\nassert (t1 = t0 /\\ t2 = t3).\ndestruct t1.\ninv MT.\nauto.\ndestruct t1; simpl in L1; try extlia.\ndestruct t0.\ninv MT.\ndestruct t0; simpl in L2; try extlia.\nsimpl in H5.\nsplit.\ncongruence.\ncongruence.\ndestruct H1; subst.\nassert (s2 = s4) by (eapply sd_determ_2; eauto).\nsubst s4.\nauto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0) : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0)","proofString":"exploit (sd_traces DET).\neexact H.\nintros L1.\nexploit (sd_traces DET).\neexact H3.\nintros L2.\nassert (t1 = t0 /\\ t2 = t3).\ndestruct t1.\ninv MT.\nauto.\ndestruct t1; simpl in L1; try extlia.\ndestruct t0.\ninv MT.\ndestruct t0; simpl in L2; try extlia.\nsimpl in H5.\nsplit.\ncongruence.\ncongruence.\ndestruct H1; subst.\nassert (s2 = s4) by (eapply sd_determ_2; eauto).\nsubst s4.\nauto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0) (L1 : (Datatypes.length t1 <= 1)%nat) : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0) (L1 : (Datatypes.length t1 <= 1)%nat)","proofString":"exploit (sd_traces DET).\neexact H3.\nintros L2.\nassert (t1 = t0 /\\ t2 = t3).\ndestruct t1.\ninv MT.\nauto.\ndestruct t1; simpl in L1; try extlia.\ndestruct t0.\ninv MT.\ndestruct t0; simpl in L2; try extlia.\nsimpl in H5.\nsplit.\ncongruence.\ncongruence.\ndestruct H1; subst.\nassert (s2 = s4) by (eapply sd_determ_2; eauto).\nsubst s4.\nauto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0) (L1 : (Datatypes.length t1 <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat) : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0) (L1 : (Datatypes.length t1 <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat)","proofString":"assert (t1 = t0 /\\ t2 = t3).\ndestruct t1.\ninv MT.\nauto.\ndestruct t1; simpl in L1; try extlia.\ndestruct t0.\ninv MT.\ndestruct t0; simpl in L2; try extlia.\nsimpl in H5.\nsplit.\ncongruence.\ncongruence.\ndestruct H1; subst.\nassert (s2 = s4) by (eapply sd_determ_2; eauto).\nsubst s4.\nauto."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0) (L1 : (Datatypes.length t1 <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat) : t1 = t0 /\\ t2 = t3.","conclusion":"t1 = t0 /\\ t2 = t3","hypotheses":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0) (L1 : (Datatypes.length t1 <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat)","proofString":"destruct t1.\ninv MT.\nauto.\ndestruct t1; simpl in L1; try extlia.\ndestruct t0.\ninv MT.\ndestruct t0; simpl in L2; try extlia.\nsimpl in H5.\nsplit.\ncongruence.\ncongruence."},{"statement":"(s1 : state L) (e : event) (t1 : list event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: t1) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : (e :: t1) ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) (e :: t1) t0) (L1 : (Datatypes.length (e :: t1) <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat) : e :: t1 = t0 /\\ t2 = t3.","conclusion":"e :: t1 = t0 /\\ t2 = t3","hypotheses":"(s1 : state L) (e : event) (t1 : list event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: t1) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : (e :: t1) ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) (e :: t1) t0) (L1 : (Datatypes.length (e :: t1) <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat)","proofString":"destruct t1; simpl in L1; try extlia.\ndestruct t0.\ninv MT.\ndestruct t0; simpl in L2; try extlia.\nsimpl in H5.\nsplit.\ncongruence.\ncongruence."},{"statement":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : (e :: nil) ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) (e :: nil) t0) (L1 : (1 <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat) : e :: nil = t0 /\\ t2 = t3.","conclusion":"e :: nil = t0 /\\ t2 = t3","hypotheses":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : (e :: nil) ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) (e :: nil) t0) (L1 : (1 <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat)","proofString":"destruct t0.\ninv MT.\ndestruct t0; simpl in L2; try extlia.\nsimpl in H5.\nsplit.\ncongruence.\ncongruence."},{"statement":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (t0 : list event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: t0) s4) (H4 : Star L s4 t3 s'') (H5 : (e :: nil) ** t2 = (e0 :: t0) ** t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: t0)) (L1 : (1 <= 1)%nat) (L2 : (Datatypes.length (e0 :: t0) <= 1)%nat) : e :: nil = e0 :: t0 /\\ t2 = t3.","conclusion":"e :: nil = e0 :: t0 /\\ t2 = t3","hypotheses":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (t0 : list event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: t0) s4) (H4 : Star L s4 t3 s'') (H5 : (e :: nil) ** t2 = (e0 :: t0) ** t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: t0)) (L1 : (1 <= 1)%nat) (L2 : (Datatypes.length (e0 :: t0) <= 1)%nat)","proofString":"destruct t0; simpl in L2; try extlia.\nsimpl in H5.\nsplit.\ncongruence.\ncongruence."},{"statement":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: nil) s4) (H4 : Star L s4 t3 s'') (H5 : (e :: nil) ** t2 = (e0 :: nil) ** t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: nil)) (L1 L2 : (1 <= 1)%nat) : e :: nil = e0 :: nil /\\ t2 = t3.","conclusion":"e :: nil = e0 :: nil /\\ t2 = t3","hypotheses":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: nil) s4) (H4 : Star L s4 t3 s'') (H5 : (e :: nil) ** t2 = (e0 :: nil) ** t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: nil)) (L1 L2 : (1 <= 1)%nat)","proofString":"simpl in H5.\nsplit.\ncongruence.\ncongruence."},{"statement":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: nil) s4) (H4 : Star L s4 t3 s'') (H5 : e :: t2 = e0 :: t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: nil)) (L1 L2 : (1 <= 1)%nat) : e :: nil = e0 :: nil /\\ t2 = t3.","conclusion":"e :: nil = e0 :: nil /\\ t2 = t3","hypotheses":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: nil) s4) (H4 : Star L s4 t3 s'') (H5 : e :: t2 = e0 :: t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: nil)) (L1 L2 : (1 <= 1)%nat)","proofString":"split.\ncongruence.\ncongruence."},{"statement":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: nil) s4) (H4 : Star L s4 t3 s'') (H5 : e :: t2 = e0 :: t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: nil)) (L1 L2 : (1 <= 1)%nat) : e :: nil = e0 :: nil.","conclusion":"e :: nil = e0 :: nil","hypotheses":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: nil) s4) (H4 : Star L s4 t3 s'') (H5 : e :: t2 = e0 :: t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: nil)) (L1 L2 : (1 <= 1)%nat)","proofString":"congruence."},{"statement":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: nil) s4) (H4 : Star L s4 t3 s'') (H5 : e :: t2 = e0 :: t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: nil)) (L1 L2 : (1 <= 1)%nat) : t2 = t3.","conclusion":"t2 = t3","hypotheses":"(s1 : state L) (e : event) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 (e :: nil) s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (e0 : event) (s4 : state L) (t3 : trace) (H3 : Step L s1 (e0 :: nil) s4) (H4 : Star L s4 t3 s'') (H5 : e :: t2 = e0 :: t3) (MT : match_traces (symbolenv L) (e :: nil) (e0 :: nil)) (L1 L2 : (1 <= 1)%nat)","proofString":"congruence."},{"statement":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0) (L1 : (Datatypes.length t1 <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat) (H1 : t1 = t0 /\\ t2 = t3) : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(s1 : state L) (t1 : trace) (s2 : state L) (t2 : trace) (s3 : state L) (H : Step L s1 t1 s2) (H0 : Star L s2 t2 s3) (IHstar : forall s''0 : state L,\nStar L s2 t2 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (s'' : state L) (t0 : trace) (s4 : state L) (t3 : trace) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (H5 : t1 ** t2 = t0 ** t3) (MT : match_traces (symbolenv L) t1 t0) (L1 : (Datatypes.length t1 <= 1)%nat) (L2 : (Datatypes.length t0 <= 1)%nat) (H1 : t1 = t0 /\\ t2 = t3)","proofString":"destruct H1; subst.\nassert (s2 = s4) by (eapply sd_determ_2; eauto).\nsubst s4.\nauto."},{"statement":"(s1 s2 s3 : state L) (t0 : trace) (H : Step L s1 t0 s2) (t3 : trace) (IHstar : forall s''0 : state L,\nStar L s2 t3 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H0 : Star L s2 t3 s3) (s'' s4 : state L) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (L1 : (Datatypes.length t0 <= 1)%nat) (MT : match_traces (symbolenv L) t0 t0) (H5 : t0 ** t3 = t0 ** t3) (L2 : (Datatypes.length t0 <= 1)%nat) : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(s1 s2 s3 : state L) (t0 : trace) (H : Step L s1 t0 s2) (t3 : trace) (IHstar : forall s''0 : state L,\nStar L s2 t3 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H0 : Star L s2 t3 s3) (s'' s4 : state L) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (L1 : (Datatypes.length t0 <= 1)%nat) (MT : match_traces (symbolenv L) t0 t0) (H5 : t0 ** t3 = t0 ** t3) (L2 : (Datatypes.length t0 <= 1)%nat)","proofString":"assert (s2 = s4) by (eapply sd_determ_2; eauto).\nsubst s4.\nauto."},{"statement":"(s1 s2 s3 : state L) (t0 : trace) (H : Step L s1 t0 s2) (t3 : trace) (IHstar : forall s''0 : state L,\nStar L s2 t3 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H0 : Star L s2 t3 s3) (s'' s4 : state L) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (L1 : (Datatypes.length t0 <= 1)%nat) (MT : match_traces (symbolenv L) t0 t0) (H5 : t0 ** t3 = t0 ** t3) (L2 : (Datatypes.length t0 <= 1)%nat) (H1 : s2 = s4) : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(s1 s2 s3 : state L) (t0 : trace) (H : Step L s1 t0 s2) (t3 : trace) (IHstar : forall s''0 : state L,\nStar L s2 t3 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H0 : Star L s2 t3 s3) (s'' s4 : state L) (H3 : Step L s1 t0 s4) (H4 : Star L s4 t3 s'') (L1 : (Datatypes.length t0 <= 1)%nat) (MT : match_traces (symbolenv L) t0 t0) (H5 : t0 ** t3 = t0 ** t3) (L2 : (Datatypes.length t0 <= 1)%nat) (H1 : s2 = s4)","proofString":"subst s4.\nauto."},{"statement":"(s1 s2 s3 : state L) (t0 : trace) (H : Step L s1 t0 s2) (t3 : trace) (IHstar : forall s''0 : state L,\nStar L s2 t3 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H0 : Star L s2 t3 s3) (s'' : state L) (H4 : Star L s2 t3 s'') (H3 : Step L s1 t0 s2) (L1 : (Datatypes.length t0 <= 1)%nat) (MT : match_traces (symbolenv L) t0 t0) (H5 : t0 ** t3 = t0 ** t3) (L2 : (Datatypes.length t0 <= 1)%nat) : Star L s3 E0 s'' \\/ Star L s'' E0 s3.","conclusion":"Star L s3 E0 s'' \\/ Star L s'' E0 s3","hypotheses":"(s1 s2 s3 : state L) (t0 : trace) (H : Step L s1 t0 s2) (t3 : trace) (IHstar : forall s''0 : state L,\nStar L s2 t3 s''0 -> Star L s3 E0 s''0 \\/ Star L s''0 E0 s3) (H0 : Star L s2 t3 s3) (s'' : state L) (H4 : Star L s2 t3 s'') (H3 : Step L s1 t0 s2) (L1 : (Datatypes.length t0 <= 1)%nat) (MT : match_traces (symbolenv L) t0 t0) (H5 : t0 ** t3 = t0 ** t3) (L2 : (Datatypes.length t0 <= 1)%nat)","proofString":"auto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') : forall (i : index) (s2 : state L2),\nmatch_states i s10' s2 ->\nexists n : nat,\n  Eventually L1 n s10 (fun s1'' : state L1 => match_states i s1'' s2).","conclusion":"forall (i : index) (s2 : state L2),\nmatch_states i s10' s2 ->\nexists n : nat,\n  Eventually L1 n s10 (fun s1'' : state L1 => match_states i s1'' s2)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10')","proofString":"pattern s10, s10'; eapply star_E0_ind; eauto.\nintros s1 i s2 M.\nexists O; constructor; auto.\nintros s1 s1' s1'' STEP IH i s2 M.\ndestruct (IH i s2 M) as (n & MS).\nexists (S n); constructor.\nintros; red; intros.\neapply (sd_final_nostep L1det); eauto.\nintros.\nexploit (sd_determ_3 L1det).\neexact H.\neexact STEP.\nintros [A B].\nsubst t s'.\nauto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') : forall (s : state L1) (i : index) (s2 : state L2),\nmatch_states i s s2 ->\nexists n : nat,\n  Eventually L1 n s (fun s1'' : state L1 => match_states i s1'' s2).","conclusion":"forall (s : state L1) (i : index) (s2 : state L2),\nmatch_states i s s2 ->\nexists n : nat,\n  Eventually L1 n s (fun s1'' : state L1 => match_states i s1'' s2)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10')","proofString":"intros s1 i s2 M.\nexists O; constructor; auto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 : state L1) (i : index) (s2 : state L2) (M : match_states i s1 s2) : exists n : nat,\n  Eventually L1 n s1 (fun s1'' : state L1 => match_states i s1'' s2).","conclusion":"exists n : nat,\n  Eventually L1 n s1 (fun s1'' : state L1 => match_states i s1'' s2)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 : state L1) (i : index) (s2 : state L2) (M : match_states i s1 s2)","proofString":"exists O; constructor; auto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') : forall s1 s2 s3 : state L1,\nStep L1 s1 E0 s2 ->\n(forall (i : index) (s4 : state L2),\n match_states i s3 s4 ->\n exists n : nat,\n   Eventually L1 n s2 (fun s1'' : state L1 => match_states i s1'' s4)) ->\nforall (i : index) (s0 : state L2),\nmatch_states i s3 s0 ->\nexists n : nat,\n  Eventually L1 n s1 (fun s1'' : state L1 => match_states i s1'' s0).","conclusion":"forall s1 s2 s3 : state L1,\nStep L1 s1 E0 s2 ->\n(forall (i : index) (s4 : state L2),\n match_states i s3 s4 ->\n exists n : nat,\n   Eventually L1 n s2 (fun s1'' : state L1 => match_states i s1'' s4)) ->\nforall (i : index) (s0 : state L2),\nmatch_states i s3 s0 ->\nexists n : nat,\n  Eventually L1 n s1 (fun s1'' : state L1 => match_states i s1'' s0)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10')","proofString":"intros s1 s1' s1'' STEP IH i s2 M.\ndestruct (IH i s2 M) as (n & MS).\nexists (S n); constructor.\nintros; red; intros.\neapply (sd_final_nostep L1det); eauto.\nintros.\nexploit (sd_determ_3 L1det).\neexact H.\neexact STEP.\nintros [A B].\nsubst t s'.\nauto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n : nat,\n  Eventually L1 n s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) : exists n : nat,\n  Eventually L1 n s1 (fun s1''0 : state L1 => match_states i s1''0 s2).","conclusion":"exists n : nat,\n  Eventually L1 n s1 (fun s1''0 : state L1 => match_states i s1''0 s2)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n : nat,\n  Eventually L1 n s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2)","proofString":"destruct (IH i s2 M) as (n & MS).\nexists (S n); constructor.\nintros; red; intros.\neapply (sd_final_nostep L1det); eauto.\nintros.\nexploit (sd_determ_3 L1det).\neexact H.\neexact STEP.\nintros [A B].\nsubst t s'.\nauto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) : exists n0 : nat,\n  Eventually L1 n0 s1 (fun s1''0 : state L1 => match_states i s1''0 s2).","conclusion":"exists n0 : nat,\n  Eventually L1 n0 s1 (fun s1''0 : state L1 => match_states i s1''0 s2)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2))","proofString":"exists (S n); constructor.\nintros; red; intros.\neapply (sd_final_nostep L1det); eauto.\nintros.\nexploit (sd_determ_3 L1det).\neexact H.\neexact STEP.\nintros [A B].\nsubst t s'.\nauto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) : forall r : int, ~ final_state L1 s1 r.","conclusion":"forall r : int, ~ final_state L1 s1 r","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2))","proofString":"intros; red; intros.\neapply (sd_final_nostep L1det); eauto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) (r : int) (H : final_state L1 s1 r) : False.","conclusion":"False","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) (r : int) (H : final_state L1 s1 r)","proofString":"eapply (sd_final_nostep L1det); eauto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) : forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\\nEventually L1 n s' (fun s1''0 : state L1 => match_states i s1''0 s2).","conclusion":"forall (t : trace) (s' : state L1),\nStep L1 s1 t s' ->\nt = E0 /\\\nEventually L1 n s' (fun s1''0 : state L1 => match_states i s1''0 s2)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2))","proofString":"intros.\nexploit (sd_determ_3 L1det).\neexact H.\neexact STEP.\nintros [A B].\nsubst t s'.\nauto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) (t : trace) (s' : state L1) (H : Step L1 s1 t s') : t = E0 /\\\nEventually L1 n s' (fun s1''0 : state L1 => match_states i s1''0 s2).","conclusion":"t = E0 /\\\nEventually L1 n s' (fun s1''0 : state L1 => match_states i s1''0 s2)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) (t : trace) (s' : state L1) (H : Step L1 s1 t s')","proofString":"exploit (sd_determ_3 L1det).\neexact H.\neexact STEP.\nintros [A B].\nsubst t s'.\nauto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) (t : trace) (s' : state L1) (H : Step L1 s1 t s') (A : t = E0) (B : s' = s1') : t = E0 /\\\nEventually L1 n s' (fun s1''0 : state L1 => match_states i s1''0 s2).","conclusion":"t = E0 /\\\nEventually L1 n s' (fun s1''0 : state L1 => match_states i s1''0 s2)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) (t : trace) (s' : state L1) (H : Step L1 s1 t s') (A : t = E0) (B : s' = s1')","proofString":"subst t s'.\nauto."},{"statement":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) (H : Step L1 s1 E0 s1') : E0 = E0 /\\\nEventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2).","conclusion":"E0 = E0 /\\\nEventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)","hypotheses":"(s10 s10' : state L1) (STAR0 : Star L1 s10 E0 s10') (s1 s1' s1'' : state L1) (STEP : Step L1 s1 E0 s1') (IH : forall (i0 : index) (s0 : state L2),\nmatch_states i0 s1'' s0 ->\nexists n0 : nat,\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i0 s1''0 s0)) (i : index) (s2 : state L2) (M : match_states i s1'' s2) (n : nat) (MS : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i s1''0 s2)) (H : Step L1 s1 E0 s1')","proofString":"auto."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : index) (s2 : state L2),\nmatch_states i s1 s2 ->\nexists (n : nat) (i' : index) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2').","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : index) (s2 : state L2),\nmatch_states i s1 s2 ->\nexists (n : nat) (i' : index) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2')","hypotheses":"","proofString":"intros.\nexploit simulation; eauto.\nintros (s1'' & i' & s2' & A & B & C).\nexploit star_match_eventually; eauto.\nintros (n & D).\nexists n, i', s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2) : exists (n : nat) (i' : index) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2').","conclusion":"exists (n : nat) (i' : index) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2)","proofString":"exploit simulation; eauto.\nintros (s1'' & i' & s2' & A & B & C).\nexploit star_match_eventually; eauto.\nintros (n & D).\nexists n, i', s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2) : (exists (s1'' : state L1) (i' : index) (s2' : state L2),\n   Star L1 s1' E0 s1'' /\\\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   match_states i' s1'' s2') ->\nexists (n : nat) (i' : index) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2').","conclusion":"(exists (s1'' : state L1) (i' : index) (s2' : state L2),\n   Star L1 s1' E0 s1'' /\\\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   match_states i' s1'' s2') ->\nexists (n : nat) (i' : index) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  Eventually L1 n s1' (fun s1'' : state L1 => match_states i' s1'' s2')","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2)","proofString":"intros (s1'' & i' & s2' & A & B & C).\nexploit star_match_eventually; eauto.\nintros (n & D).\nexists n, i', s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2) (s1'' : state L1) (i' : index) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (C : match_states i' s1'' s2') : exists (n : nat) (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ order i'0 i) /\\\n  Eventually L1 n s1' (fun s1''0 : state L1 => match_states i'0 s1''0 s2'0).","conclusion":"exists (n : nat) (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ order i'0 i) /\\\n  Eventually L1 n s1' (fun s1''0 : state L1 => match_states i'0 s1''0 s2'0)","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2) (s1'' : state L1) (i' : index) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (C : match_states i' s1'' s2')","proofString":"exploit star_match_eventually; eauto.\nintros (n & D).\nexists n, i', s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2) (s1'' : state L1) (i' : index) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (C : match_states i' s1'' s2') : (exists n : nat,\n   Eventually L1 n s1' (fun s1''0 : state L1 => match_states i' s1''0 s2')) ->\nexists (n : nat) (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ order i'0 i) /\\\n  Eventually L1 n s1' (fun s1''0 : state L1 => match_states i'0 s1''0 s2'0).","conclusion":"(exists n : nat,\n   Eventually L1 n s1' (fun s1''0 : state L1 => match_states i' s1''0 s2')) ->\nexists (n : nat) (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ order i'0 i) /\\\n  Eventually L1 n s1' (fun s1''0 : state L1 => match_states i'0 s1''0 s2'0)","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2) (s1'' : state L1) (i' : index) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (C : match_states i' s1'' s2')","proofString":"intros (n & D).\nexists n, i', s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2) (s1'' : state L1) (i' : index) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (C : match_states i' s1'' s2') (n : nat) (D : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i' s1''0 s2')) : exists (n0 : nat) (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ order i'0 i) /\\\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i'0 s1''0 s2'0).","conclusion":"exists (n0 : nat) (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ order i'0 i) /\\\n  Eventually L1 n0 s1' (fun s1''0 : state L1 => match_states i'0 s1''0 s2'0)","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : index) (s2 : state L2) (H0 : match_states i s1 s2) (s1'' : state L1) (i' : index) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (C : match_states i' s1'' s2') (n : nat) (D : Eventually L1 n s1' (fun s1''0 : state L1 => match_states i' s1''0 s2'))","proofString":"exists n, i', s2'; auto."},{"statement":"determinate L1.","conclusion":"determinate L1","hypotheses":"","proofString":"assumption."},{"statement":"well_founded (ltof (state L1) measure).","conclusion":"well_founded (ltof (state L1) measure)","hypotheses":"","proofString":"apply well_founded_ltof."},{"statement":"forall s1 : state L1,\ninitial_state L1 s1 ->\nexists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2.","conclusion":"forall s1 : state L1,\ninitial_state L1 s1 ->\nexists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2","hypotheses":"","proofString":"intros.\nexploit match_initial_states; eauto.\nintros (s2 & A & B).\nexists s1, s2; auto."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : exists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2.","conclusion":"exists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"exploit match_initial_states; eauto.\nintros (s2 & A & B).\nexists s1, s2; auto."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) : (exists s2 : state L2, initial_state L2 s2 /\\ match_states s1 s2) ->\nexists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2.","conclusion":"(exists s2 : state L2, initial_state L2 s2 /\\ match_states s1 s2) ->\nexists (i : state L1) (s2 : state L2),\n  initial_state L2 s2 /\\ i = s1 /\\ match_states s1 s2","hypotheses":"(s1 : state L1) (H : initial_state L1 s1)","proofString":"intros (s2 & A & B).\nexists s1, s2; auto."},{"statement":"(s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) (B : match_states s1 s2) : exists (i : state L1) (s0 : state L2),\n  initial_state L2 s0 /\\ i = s1 /\\ match_states s1 s0.","conclusion":"exists (i : state L1) (s0 : state L2),\n  initial_state L2 s0 /\\ i = s1 /\\ match_states s1 s0","hypotheses":"(s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) (B : match_states s1 s2)","proofString":"exists s1, s2; auto."},{"statement":"forall (i s1 : state L1) (s2 : state L2) (r : int),\ni = s1 /\\ match_states s1 s2 -> final_state L1 s1 r -> final_state L2 s2 r.","conclusion":"forall (i s1 : state L1) (s2 : state L2) (r : int),\ni = s1 /\\ match_states s1 s2 -> final_state L1 s1 r -> final_state L2 s2 r","hypotheses":"","proofString":"intros.\ndestruct H.\neapply match_final_states; eauto."},{"statement":"(i s1 : state L1) (s2 : state L2) (r : int) (H : i = s1 /\\ match_states s1 s2) (H0 : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i s1 : state L1) (s2 : state L2) (r : int) (H : i = s1 /\\ match_states s1 s2) (H0 : final_state L1 s1 r)","proofString":"destruct H.\neapply match_final_states; eauto."},{"statement":"(i s1 : state L1) (s2 : state L2) (r : int) (H : i = s1) (H1 : match_states s1 s2) (H0 : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i s1 : state L1) (s2 : state L2) (r : int) (H : i = s1) (H1 : match_states s1 s2) (H0 : final_state L1 s1 r)","proofString":"eapply match_final_states; eauto."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : state L1) (s2 : state L2),\ni = s1 /\\ match_states s1 s2 ->\nexists (s1'' i' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure i' i) /\\\n  i' = s1'' /\\ match_states s1'' s2'.","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall (i : state L1) (s2 : state L2),\ni = s1 /\\ match_states s1 s2 ->\nexists (s1'' i' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure i' i) /\\\n  i' = s1'' /\\ match_states s1'' s2'","hypotheses":"","proofString":"intros.\ndestruct H0; subst i.\nexploit simulation; eauto.\nintros (s1'' & s2' & A & B & C).\nexists s1'', s1'', s2'.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : state L1) (s2 : state L2) (H0 : i = s1 /\\ match_states s1 s2) : exists (s1'' i' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure i' i) /\\\n  i' = s1'' /\\ match_states s1'' s2'.","conclusion":"exists (s1'' i' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure i' i) /\\\n  i' = s1'' /\\ match_states s1'' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (i : state L1) (s2 : state L2) (H0 : i = s1 /\\ match_states s1 s2)","proofString":"destruct H0; subst i.\nexploit simulation; eauto.\nintros (s1'' & s2' & A & B & C).\nexists s1'', s1'', s2'.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) : exists (s1'' i' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure i' s1) /\\\n  i' = s1'' /\\ match_states s1'' s2'.","conclusion":"exists (s1'' i' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure i' s1) /\\\n  i' = s1'' /\\ match_states s1'' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2)","proofString":"exploit simulation; eauto.\nintros (s1'' & s2' & A & B & C).\nexists s1'', s1'', s2'.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) : (exists (s1'' : state L1) (s2' : state L2),\n   Star L1 s1' E0 s1'' /\\\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (measure s1'' < measure s1)%nat) /\\\n   match_states s1'' s2') ->\nexists (s1'' i' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure i' s1) /\\\n  i' = s1'' /\\ match_states s1'' s2'.","conclusion":"(exists (s1'' : state L1) (s2' : state L2),\n   Star L1 s1' E0 s1'' /\\\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (measure s1'' < measure s1)%nat) /\\\n   match_states s1'' s2') ->\nexists (s1'' i' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure i' s1) /\\\n  i' = s1'' /\\ match_states s1'' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2)","proofString":"intros (s1'' & s2' & A & B & C).\nexists s1'', s1'', s2'.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) (s1'' : state L1) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (measure s1'' < measure s1)%nat) (C : match_states s1'' s2') : exists (s1''0 i' : state L1) (s2'0 : state L2),\n  Star L1 s1' E0 s1''0 /\\\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ ltof (state L1) measure i' s1) /\\\n  i' = s1''0 /\\ match_states s1''0 s2'0.","conclusion":"exists (s1''0 i' : state L1) (s2'0 : state L2),\n  Star L1 s1' E0 s1''0 /\\\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ ltof (state L1) measure i' s1) /\\\n  i' = s1''0 /\\ match_states s1''0 s2'0","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) (s1'' : state L1) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (measure s1'' < measure s1)%nat) (C : match_states s1'' s2')","proofString":"exists s1'', s1'', s2'.\nauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) (s1'' : state L1) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (measure s1'' < measure s1)%nat) (C : match_states s1'' s2') : Star L1 s1' E0 s1'' /\\\n(Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1'' s1) /\\\ns1'' = s1'' /\\ match_states s1'' s2'.","conclusion":"Star L1 s1' E0 s1'' /\\\n(Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ ltof (state L1) measure s1'' s1) /\\\ns1'' = s1'' /\\ match_states s1'' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H1 : match_states s1 s2) (s1'' : state L1) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (measure s1'' < measure s1)%nat) (C : match_states s1'' s2')","proofString":"auto."},{"statement":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"","proofString":"assumption."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\nexists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (0 < 0)%nat) /\\\n  match_states s1'' s2'.","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\nexists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (0 < 0)%nat) /\\\n  match_states s1'' s2'","hypotheses":"","proofString":"intros.\nexploit simulation; eauto.\nintros (s1'' & s2' & A & B & C).\nexists s1'', s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : exists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (0 < 0)%nat) /\\\n  match_states s1'' s2'.","conclusion":"exists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (0 < 0)%nat) /\\\n  match_states s1'' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"exploit simulation; eauto.\nintros (s1'' & s2' & A & B & C).\nexists s1'', s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : (exists (s1'' : state L1) (s2' : state L2),\n   Star L1 s1' E0 s1'' /\\ Plus L2 s2 t s2' /\\ match_states s1'' s2') ->\nexists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (0 < 0)%nat) /\\\n  match_states s1'' s2'.","conclusion":"(exists (s1'' : state L1) (s2' : state L2),\n   Star L1 s1' E0 s1'' /\\ Plus L2 s2 t s2' /\\ match_states s1'' s2') ->\nexists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ (0 < 0)%nat) /\\\n  match_states s1'' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"intros (s1'' & s2' & A & B & C).\nexists s1'', s2'; auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s1'' : state L1) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2') (C : match_states s1'' s2') : exists (s1''0 : state L1) (s2'0 : state L2),\n  Star L1 s1' E0 s1''0 /\\\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ (0 < 0)%nat) /\\\n  match_states s1''0 s2'0.","conclusion":"exists (s1''0 : state L1) (s2'0 : state L2),\n  Star L1 s1' E0 s1''0 /\\\n  (Plus L2 s2 t s2'0 \\/ Star L2 s2 t s2'0 /\\ (0 < 0)%nat) /\\\n  match_states s1''0 s2'0","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s1'' : state L1) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Plus L2 s2 t s2') (C : match_states s1'' s2')","proofString":"exists s1'', s2'; auto."},{"statement":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\nexists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\ Plus L2 s2 t s2' /\\ match_states s1'' s2'.","conclusion":"forall (s1 : state L1) (t : trace) (s1' : state L1),\nStep L1 s1 t s1' ->\nforall s2 : state L2,\nmatch_states s1 s2 ->\nexists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\ Plus L2 s2 t s2' /\\ match_states s1'' s2'","hypotheses":"","proofString":"intros.\nexploit simulation; eauto.\nintros (s1'' & s2' & A & B & C).\nexists s1'', s2'; auto using plus_one."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : exists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\ Plus L2 s2 t s2' /\\ match_states s1'' s2'.","conclusion":"exists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\ Plus L2 s2 t s2' /\\ match_states s1'' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"exploit simulation; eauto.\nintros (s1'' & s2' & A & B & C).\nexists s1'', s2'; auto using plus_one."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) : (exists (s1'' : state L1) (s2' : state L2),\n   Star L1 s1' E0 s1'' /\\ Step L2 s2 t s2' /\\ match_states s1'' s2') ->\nexists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\ Plus L2 s2 t s2' /\\ match_states s1'' s2'.","conclusion":"(exists (s1'' : state L1) (s2' : state L2),\n   Star L1 s1' E0 s1'' /\\ Step L2 s2 t s2' /\\ match_states s1'' s2') ->\nexists (s1'' : state L1) (s2' : state L2),\n  Star L1 s1' E0 s1'' /\\ Plus L2 s2 t s2' /\\ match_states s1'' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2)","proofString":"intros (s1'' & s2' & A & B & C).\nexists s1'', s2'; auto using plus_one."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s1'' : state L1) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Step L2 s2 t s2') (C : match_states s1'' s2') : exists (s1''0 : state L1) (s2'0 : state L2),\n  Star L1 s1' E0 s1''0 /\\ Plus L2 s2 t s2'0 /\\ match_states s1''0 s2'0.","conclusion":"exists (s1''0 : state L1) (s2'0 : state L2),\n  Star L1 s1' E0 s1''0 /\\ Plus L2 s2 t s2'0 /\\ match_states s1''0 s2'0","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (s2 : state L2) (H0 : match_states s1 s2) (s1'' : state L1) (s2' : state L2) (A : Star L1 s1' E0 s1'') (B : Step L2 s2 t s2') (C : match_states s1'' s2')","proofString":"exists s1'', s2'; auto using plus_one."},{"statement":"(L : semantics) (s s' : state L) (H : Star L s E0 s') (H0 : safe L s) (s'0 : state L) (H1 : Star L s' E0 s'0) : (exists r : int, final_state L s'0 r) \\/\n(exists (t : trace) (s'' : state L), Step L s'0 t s'').","conclusion":"(exists r : int, final_state L s'0 r) \\/\n(exists (t : trace) (s'' : state L), Step L s'0 t s'')","hypotheses":"(L : semantics) (s s' : state L) (H : Star L s E0 s') (H0 : safe L s) (s'0 : state L) (H1 : Star L s' E0 s'0)","proofString":"apply H0.\neapply star_trans; eauto."},{"statement":"(L : semantics) (s s' : state L) (H : Star L s E0 s') (H0 : safe L s) (s'0 : state L) (H1 : Star L s' E0 s'0) : Star L s E0 s'0.","conclusion":"Star L s E0 s'0","hypotheses":"(L : semantics) (s s' : state L) (H : Star L s E0 s') (H0 : safe L s) (s'0 : state L) (H1 : Star L s' E0 s'0)","proofString":"eapply star_trans; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) : (exists (i' : index) (s1' : state L1),\n   Plus L1 s1 t s1' /\\ match_states i' s1' s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s1 s2').","conclusion":"(exists (i' : index) (s1' : state L1),\n   Plus L1 s1 t s1' /\\ match_states i' s1' s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s1 s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1)","proofString":"exploit bsim_simulation; eauto.\nintros [i' [s1' [A B]]].\nintuition.\nleft; exists i'; exists s1'; auto.\ninv H4.\nright; exists i'; auto.\nleft; exists i'; exists s1'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) : (exists (i' : index) (s1' : state L1),\n   (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ order i' i) /\\\n   match_states i' s1' s2') ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s1 t s1' /\\ match_states i' s1' s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s1 s2').","conclusion":"(exists (i' : index) (s1' : state L1),\n   (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ order i' i) /\\\n   match_states i' s1' s2') ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s1 t s1' /\\ match_states i' s1' s2') \\/\n(exists i' : index, order i' i /\\ t = E0 /\\ match_states i' s1 s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1)","proofString":"intros [i' [s1' [A B]]].\nintuition.\nleft; exists i'; exists s1'; auto.\ninv H4.\nright; exists i'; auto.\nleft; exists i'; exists s1'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (A : Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ order i' i) (B : match_states i' s1' s2') : (exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1 t s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1 s2').","conclusion":"(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1 t s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1 s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (A : Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ order i' i) (B : match_states i' s1' s2')","proofString":"intuition.\nleft; exists i'; exists s1'; auto.\ninv H4.\nright; exists i'; auto.\nleft; exists i'; exists s1'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (B : match_states i' s1' s2') (H3 : Plus L1 s1 t s1') : (exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1 t s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1 s2').","conclusion":"(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1 t s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1 s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (B : match_states i' s1' s2') (H3 : Plus L1 s1 t s1')","proofString":"left; exists i'; exists s1'; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (B : match_states i' s1' s2') (H4 : Star L1 s1 t s1') (H5 : order i' i) : (exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1 t s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1 s2').","conclusion":"(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1 t s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ t = E0 /\\ match_states i'0 s1 s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 : state L2) (t : trace) (s2' : state L2) (H0 : Step L2 s2 t s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (B : match_states i' s1' s2') (H4 : Star L1 s1 t s1') (H5 : order i' i)","proofString":"inv H4.\nright; exists i'; auto.\nleft; exists i'; exists s1'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 s2' : state L2) (H0 : Step L2 s2 E0 s2') (s1' : state L1) (H2 : safe L1 s1') (H1 : match_states i s1' s2) (i' : index) (B : match_states i' s1' s2') (H5 : order i' i) : (exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1' E0 s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ E0 = E0 /\\ match_states i'0 s1' s2').","conclusion":"(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1' E0 s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ E0 = E0 /\\ match_states i'0 s1' s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 s2' : state L2) (H0 : Step L2 s2 E0 s2') (s1' : state L1) (H2 : safe L1 s1') (H1 : match_states i s1' s2) (i' : index) (B : match_states i' s1' s2') (H5 : order i' i)","proofString":"right; exists i'; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 s2' : state L2) (t1 t2 : trace) (H0 : Step L2 s2 (t1 ** t2) s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (B : match_states i' s1' s2') (H5 : order i' i) (s3 : state L1) (H3 : Step L1 s1 t1 s3) (H6 : Star L1 s3 t2 s1') : (exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1 (t1 ** t2) s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ t1 ** t2 = E0 /\\ match_states i'0 s1 s2').","conclusion":"(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s1 (t1 ** t2) s1'0 /\\ match_states i'0 s1'0 s2') \\/\n(exists i'0 : index, order i'0 i /\\ t1 ** t2 = E0 /\\ match_states i'0 s1 s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 s2' : state L2) (t1 t2 : trace) (H0 : Step L2 s2 (t1 ** t2) s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (B : match_states i' s1' s2') (H5 : order i' i) (s3 : state L1) (H3 : Step L1 s1 t1 s3) (H6 : Star L1 s3 t2 s1')","proofString":"left; exists i'; exists s1'; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 s2' : state L2) (t1 t2 : trace) (H0 : Step L2 s2 (t1 ** t2) s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (B : match_states i' s1' s2') (H5 : order i' i) (s3 : state L1) (H3 : Step L1 s1 t1 s3) (H6 : Star L1 s3 t2 s1') : Plus L1 s1 (t1 ** t2) s1'.","conclusion":"Plus L1 s1 (t1 ** t2) s1'","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (H : bsim_properties L1 L2 index order match_states) (i : index) (s2 s2' : state L2) (t1 t2 : trace) (H0 : Step L2 s2 (t1 ** t2) s2') (s1 : state L1) (H1 : match_states i s1 s2) (H2 : safe L1 s1) (i' : index) (s1' : state L1) (B : match_states i' s1' s2') (H5 : order i' i) (s3 : state L1) (H3 : Step L1 s1 t1 s3) (H6 : Star L1 s3 t2 s1')","proofString":"econstructor; eauto."},{"statement":"well_founded (fun _ _ : unit => False).","conclusion":"well_founded (fun _ _ : unit => False)","hypotheses":"","proofString":"red; intros; constructor; intros.\ncontradiction."},{"statement":"(a y : unit) (H : False) : Acc (fun _ _ : unit => False) y.","conclusion":"Acc (fun _ _ : unit => False) y","hypotheses":"(a y : unit) (H : False)","proofString":"contradiction."},{"statement":"forall (s1 : state L1) (s2 : state L2),\ninitial_state L1 s1 ->\ninitial_state L2 s2 ->\nexists (_ : unit) (s1' : state L1),\n  initial_state L1 s1' /\\ match_states s1' s2.","conclusion":"forall (s1 : state L1) (s2 : state L2),\ninitial_state L1 s1 ->\ninitial_state L2 s2 ->\nexists (_ : unit) (s1' : state L1),\n  initial_state L1 s1' /\\ match_states s1' s2","hypotheses":"","proofString":"intros.\nexists tt; eauto."},{"statement":"(s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) : exists (_ : unit) (s1' : state L1),\n  initial_state L1 s1' /\\ match_states s1' s2.","conclusion":"exists (_ : unit) (s1' : state L1),\n  initial_state L1 s1' /\\ match_states s1' s2","hypotheses":"(s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2)","proofString":"exists tt; eauto."},{"statement":"unit ->\nforall (s1 : state L1) (s2 : state L2) (r : int),\nmatch_states s1 s2 ->\nsafe L1 s1 ->\nfinal_state L2 s2 r ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"unit ->\nforall (s1 : state L1) (s2 : state L2) (r : int),\nmatch_states s1 s2 ->\nsafe L1 s1 ->\nfinal_state L2 s2 r ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"","proofString":"intros.\nexists s1; split.\napply star_refl.\neauto."},{"statement":"(i : unit) (s1 : state L1) (s2 : state L2) (r : int) (H : match_states s1 s2) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(i : unit) (s1 : state L1) (s2 : state L2) (r : int) (H : match_states s1 s2) (H0 : safe L1 s1) (H1 : final_state L2 s2 r)","proofString":"exists s1; split.\napply star_refl.\neauto."},{"statement":"(i : unit) (s1 : state L1) (s2 : state L2) (r : int) (H : match_states s1 s2) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(i : unit) (s1 : state L1) (s2 : state L2) (r : int) (H : match_states s1 s2) (H0 : safe L1 s1) (H1 : final_state L2 s2 r)","proofString":"apply star_refl."},{"statement":"(i : unit) (s1 : state L1) (s2 : state L2) (r : int) (H : match_states s1 s2) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) : final_state L1 s1 r.","conclusion":"final_state L1 s1 r","hypotheses":"(i : unit) (s1 : state L1) (s2 : state L2) (r : int) (H : match_states s1 s2) (H0 : safe L1 s1) (H1 : final_state L2 s2 r)","proofString":"eauto."},{"statement":"forall (s2 : state L2) (t : trace) (s2' : state L2),\nStep L2 s2 t s2' ->\nunit ->\nforall s1 : state L1,\nmatch_states s1 s2 ->\nsafe L1 s1 ->\nexists (_ : unit) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ False) /\\ match_states s1' s2'.","conclusion":"forall (s2 : state L2) (t : trace) (s2' : state L2),\nStep L2 s2 t s2' ->\nunit ->\nforall s1 : state L1,\nmatch_states s1 s2 ->\nsafe L1 s1 ->\nexists (_ : unit) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ False) /\\ match_states s1' s2'","hypotheses":"","proofString":"intros.\nexploit simulation; eauto.\nintros [s1' [A B]].\nexists tt; exists s1'; auto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (H : Step L2 s2 t s2') (i : unit) (s1 : state L1) (H0 : match_states s1 s2) (H1 : safe L1 s1) : exists (_ : unit) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ False) /\\ match_states s1' s2'.","conclusion":"exists (_ : unit) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ False) /\\ match_states s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (H : Step L2 s2 t s2') (i : unit) (s1 : state L1) (H0 : match_states s1 s2) (H1 : safe L1 s1)","proofString":"exploit simulation; eauto.\nintros [s1' [A B]].\nexists tt; exists s1'; auto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (H : Step L2 s2 t s2') (i : unit) (s1 : state L1) (H0 : match_states s1 s2) (H1 : safe L1 s1) : (exists s1' : state L1, Plus L1 s1 t s1' /\\ match_states s1' s2') ->\nexists (_ : unit) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ False) /\\ match_states s1' s2'.","conclusion":"(exists s1' : state L1, Plus L1 s1 t s1' /\\ match_states s1' s2') ->\nexists (_ : unit) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ False) /\\ match_states s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (H : Step L2 s2 t s2') (i : unit) (s1 : state L1) (H0 : match_states s1 s2) (H1 : safe L1 s1)","proofString":"intros [s1' [A B]].\nexists tt; exists s1'; auto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (H : Step L2 s2 t s2') (i : unit) (s1 : state L1) (H0 : match_states s1 s2) (H1 : safe L1 s1) (s1' : state L1) (A : Plus L1 s1 t s1') (B : match_states s1' s2') : exists (_ : unit) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ False) /\\ match_states s1'0 s2'.","conclusion":"exists (_ : unit) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ False) /\\ match_states s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (H : Step L2 s2 t s2') (i : unit) (s1 : state L1) (H0 : match_states s1 s2) (H1 : safe L1 s1) (s1' : state L1) (A : Plus L1 s1 t s1') (B : match_states s1' s2')","proofString":"exists tt; exists s1'; auto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') : forall (i : index) (s1 : state L1),\nmatch_states i s1 s20 ->\nsafe L1 s1 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s1 E0 s1' /\\ match_states i' s1' s20'.","conclusion":"forall (i : index) (s1 : state L1),\nmatch_states i s1 s20 ->\nsafe L1 s1 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s1 E0 s1' /\\ match_states i' s1' s20'","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20')","proofString":"pattern s20, s20'.\neapply star_E0_ind; eauto.\nintros.\nexists i; exists s1; split; auto.\napply star_refl.\nintros.\nexploit bsim_simulation; eauto.\nintros [i' [s1' [A B]]].\nassert (Star L1 s0 E0 s1').\nintuition.\napply plus_star; auto.\nexploit H0.\neauto.\neapply star_safe; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') : (fun s s0 : state L2 =>\n forall (i : index) (s1 : state L1),\n match_states i s1 s ->\n safe L1 s1 ->\n exists (i' : index) (s1' : state L1),\n   Star L1 s1 E0 s1' /\\ match_states i' s1' s0) s20 s20'.","conclusion":"(fun s s0 : state L2 =>\n forall (i : index) (s1 : state L1),\n match_states i s1 s ->\n safe L1 s1 ->\n exists (i' : index) (s1' : state L1),\n   Star L1 s1 E0 s1' /\\ match_states i' s1' s0) s20 s20'","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20')","proofString":"eapply star_E0_ind; eauto.\nintros.\nexists i; exists s1; split; auto.\napply star_refl.\nintros.\nexploit bsim_simulation; eauto.\nintros [i' [s1' [A B]]].\nassert (Star L1 s0 E0 s1').\nintuition.\napply plus_star; auto.\nexploit H0.\neauto.\neapply star_safe; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') : forall (s : state L2) (i : index) (s1 : state L1),\nmatch_states i s1 s ->\nsafe L1 s1 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s1 E0 s1' /\\ match_states i' s1' s.","conclusion":"forall (s : state L2) (i : index) (s1 : state L1),\nmatch_states i s1 s ->\nsafe L1 s1 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s1 E0 s1' /\\ match_states i' s1' s","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20')","proofString":"intros.\nexists i; exists s1; split; auto.\napply star_refl."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s : state L2) (i : index) (s1 : state L1) (H : match_states i s1 s) (H0 : safe L1 s1) : exists (i' : index) (s1' : state L1),\n  Star L1 s1 E0 s1' /\\ match_states i' s1' s.","conclusion":"exists (i' : index) (s1' : state L1),\n  Star L1 s1 E0 s1' /\\ match_states i' s1' s","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s : state L2) (i : index) (s1 : state L1) (H : match_states i s1 s) (H0 : safe L1 s1)","proofString":"exists i; exists s1; split; auto.\napply star_refl."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s : state L2) (i : index) (s1 : state L1) (H : match_states i s1 s) (H0 : safe L1 s1) : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s : state L2) (i : index) (s1 : state L1) (H : match_states i s1 s) (H0 : safe L1 s1)","proofString":"apply star_refl."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') : forall s1 s2 s3 : state L2,\nStep L2 s1 E0 s2 ->\n(forall (i : index) (s4 : state L1),\n match_states i s4 s2 ->\n safe L1 s4 ->\n exists (i' : index) (s1' : state L1),\n   Star L1 s4 E0 s1' /\\ match_states i' s1' s3) ->\nforall (i : index) (s0 : state L1),\nmatch_states i s0 s1 ->\nsafe L1 s0 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s0 E0 s1' /\\ match_states i' s1' s3.","conclusion":"forall s1 s2 s3 : state L2,\nStep L2 s1 E0 s2 ->\n(forall (i : index) (s4 : state L1),\n match_states i s4 s2 ->\n safe L1 s4 ->\n exists (i' : index) (s1' : state L1),\n   Star L1 s4 E0 s1' /\\ match_states i' s1' s3) ->\nforall (i : index) (s0 : state L1),\nmatch_states i s0 s1 ->\nsafe L1 s0 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s0 E0 s1' /\\ match_states i' s1' s3","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20')","proofString":"intros.\nexploit bsim_simulation; eauto.\nintros [i' [s1' [A B]]].\nassert (Star L1 s0 E0 s1').\nintuition.\napply plus_star; auto.\nexploit H0.\neauto.\neapply star_safe; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 E0 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) : exists (i' : index) (s1' : state L1),\n  Star L1 s0 E0 s1' /\\ match_states i' s1' s3.","conclusion":"exists (i' : index) (s1' : state L1),\n  Star L1 s0 E0 s1' /\\ match_states i' s1' s3","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 E0 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0)","proofString":"exploit bsim_simulation; eauto.\nintros [i' [s1' [A B]]].\nassert (Star L1 s0 E0 s1').\nintuition.\napply plus_star; auto.\nexploit H0.\neauto.\neapply star_safe; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 E0 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) : (exists (i' : index) (s1' : state L1),\n   (Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) /\\\n   match_states i' s1' s2) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s0 E0 s1' /\\ match_states i' s1' s3.","conclusion":"(exists (i' : index) (s1' : state L1),\n   (Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) /\\\n   match_states i' s1' s2) ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s0 E0 s1' /\\ match_states i' s1' s3","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i' : index) (s1' : state L1),\n  Star L1 s4 E0 s1' /\\ match_states i' s1' s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0)","proofString":"intros [i' [s1' [A B]]].\nassert (Star L1 s0 E0 s1').\nintuition.\napply plus_star; auto.\nexploit H0.\neauto.\neapply star_safe; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2) : exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3.","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2)","proofString":"assert (Star L1 s0 E0 s1').\nintuition.\napply plus_star; auto.\nexploit H0.\neauto.\neapply star_safe; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2) : Star L1 s0 E0 s1'.","conclusion":"Star L1 s0 E0 s1'","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2)","proofString":"intuition.\napply plus_star; auto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (B : match_states i' s1' s2) (H3 : Plus L1 s0 E0 s1') : Star L1 s0 E0 s1'.","conclusion":"Star L1 s0 E0 s1'","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (B : match_states i' s1' s2) (H3 : Plus L1 s0 E0 s1')","proofString":"apply plus_star; auto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2) (H3 : Star L1 s0 E0 s1') : exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3.","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2) (H3 : Star L1 s0 E0 s1')","proofString":"exploit H0.\neauto.\neapply star_safe; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2) (H3 : Star L1 s0 E0 s1') (i'' : index) (s1'' : state L1) (C : Star L1 s1' E0 s1'') (D : match_states i'' s1'' s3) : exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3.","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  Star L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2) (H3 : Star L1 s0 E0 s1') (i'' : index) (s1'' : state L1) (C : Star L1 s1' E0 s1'') (D : match_states i'' s1'' s3)","proofString":"exists i''; exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2) (H3 : Star L1 s0 E0 s1') (i'' : index) (s1'' : state L1) (C : Star L1 s1' E0 s1'') (D : match_states i'' s1'' s3) : Star L1 s0 E0 s1''.","conclusion":"Star L1 s0 E0 s1''","hypotheses":"(s20 s20' : state L2) (STAR0 : Star L2 s20 E0 s20') (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\nexists (i'0 : index) (s1'0 : state L1),\n  Star L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1' \\/ Star L1 s0 E0 s1' /\\ order i' i) (B : match_states i' s1' s2) (H3 : Star L1 s0 E0 s1') (i'' : index) (s1'' : state L1) (C : Star L1 s1' E0 s1'') (D : match_states i'' s1'' s3)","proofString":"eapply star_trans; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (H0 : safe L1 s1) (s' : state L2) (H1 : Star L2 s2 E0 s') : (exists r : int, final_state L2 s' r) \\/\n(exists (t : trace) (s'' : state L2), Step L2 s' t s'').","conclusion":"(exists r : int, final_state L2 s' r) \\/\n(exists (t : trace) (s'' : state L2), Step L2 s' t s'')","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (H0 : safe L1 s1) (s' : state L2) (H1 : Star L2 s2 E0 s')","proofString":"exploit bsim_E0_star; eauto.\nintros [i' [s1' [A B]]].\neapply bsim_progress; eauto.\neapply star_safe; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (H0 : safe L1 s1) (s' : state L2) (H1 : Star L2 s2 E0 s') : (exists (i' : index) (s1' : state L1),\n   Star L1 s1 E0 s1' /\\ match_states i' s1' s') ->\n(exists r : int, final_state L2 s' r) \\/\n(exists (t : trace) (s'' : state L2), Step L2 s' t s'').","conclusion":"(exists (i' : index) (s1' : state L1),\n   Star L1 s1 E0 s1' /\\ match_states i' s1' s') ->\n(exists r : int, final_state L2 s' r) \\/\n(exists (t : trace) (s'' : state L2), Step L2 s' t s'')","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (H0 : safe L1 s1) (s' : state L2) (H1 : Star L2 s2 E0 s')","proofString":"intros [i' [s1' [A B]]].\neapply bsim_progress; eauto.\neapply star_safe; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (H0 : safe L1 s1) (s' : state L2) (H1 : Star L2 s2 E0 s') (i' : index) (s1' : state L1) (A : Star L1 s1 E0 s1') (B : match_states i' s1' s') : (exists r : int, final_state L2 s' r) \\/\n(exists (t : trace) (s'' : state L2), Step L2 s' t s'').","conclusion":"(exists r : int, final_state L2 s' r) \\/\n(exists (t : trace) (s'' : state L2), Step L2 s' t s'')","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (H0 : safe L1 s1) (s' : state L2) (H1 : Star L2 s2 E0 s') (i' : index) (s1' : state L1) (A : Star L1 s1 E0 s1') (B : match_states i' s1' s')","proofString":"eapply bsim_progress; eauto.\neapply star_safe; eauto."},{"statement":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (H0 : safe L1 s1) (s' : state L2) (H1 : Star L2 s2 E0 s') (i' : index) (s1' : state L1) (A : Star L1 s1 E0 s1') (B : match_states i' s1' s') : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(i : index) (s1 : state L1) (s2 : state L2) (H : match_states i s1 s2) (H0 : safe L1 s1) (s' : state L2) (H1 : Star L2 s2 E0 s') (i' : index) (s1' : state L1) (A : Star L1 s1 E0 s1') (B : match_states i' s1' s')","proofString":"eapply star_safe; eauto."},{"statement":"(s1 s2 : state L2) (H : Step L2 s1 E0 s2) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) : (exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s2) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s2).","conclusion":"(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s2) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s2)","hypotheses":"(s1 s2 : state L2) (H : Step L2 s1 E0 s2) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0)","proofString":"exploit bsim_simulation'; eauto.\nintros [[i' [s1' [A B]]] | [i' [A [B C]]]].\nleft; exists i'; exists s1'; auto.\nright; exists i'; intuition auto with sets."},{"statement":"(s1 s2 : state L2) (H : Step L2 s1 E0 s2) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) : (exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s2) \\/\n(exists i' : index, order i' i /\\ E0 = E0 /\\ match_states i' s0 s2) ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s2) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s2).","conclusion":"(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s2) \\/\n(exists i' : index, order i' i /\\ E0 = E0 /\\ match_states i' s0 s2) ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s2) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s2)","hypotheses":"(s1 s2 : state L2) (H : Step L2 s1 E0 s2) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0)","proofString":"intros [[i' [s1' [A B]]] | [i' [A [B C]]]].\nleft; exists i'; exists s1'; auto.\nright; exists i'; intuition auto with sets."},{"statement":"(s1 s2 : state L2) (H : Step L2 s1 E0 s2) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2) : (exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s2) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s2).","conclusion":"(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s2) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s2)","hypotheses":"(s1 s2 : state L2) (H : Step L2 s1 E0 s2) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2)","proofString":"left; exists i'; exists s1'; auto."},{"statement":"(s1 s2 : state L2) (H : Step L2 s1 E0 s2) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) : (exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s2) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s2).","conclusion":"(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s2) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s2)","hypotheses":"(s1 s2 : state L2) (H : Step L2 s1 E0 s2) (i : index) (s0 : state L1) (H1 : match_states i s0 s1) (H2 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2)","proofString":"right; exists i'; intuition auto with sets."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Plus L2 s2 t2 s3) (IHplus : t2 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i0 /\\ match_states i' s4 s3)) (H2 : t1 ** t2 = E0) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) : (exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s3).","conclusion":"(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s3)","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Plus L2 s2 t2 s3) (IHplus : t2 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i0 /\\ match_states i' s4 s3)) (H2 : t1 ** t2 = E0) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0)","proofString":"exploit Eapp_E0_inv; eauto.\nintros [EQ1 EQ2]; subst.\nexploit bsim_simulation'; eauto.\nintros [[i' [s1' [A B]]] | [i' [A [B C]]]].\nexploit bsim_E0_star.\napply plus_star; eauto.\neauto.\neapply star_safe; eauto.\napply plus_star; auto.\nintros [i'' [s1'' [P Q]]].\nleft; exists i''; exists s1''; intuition.\neapply plus_star_trans; eauto.\nexploit IHplus; eauto.\nintros [P | [i'' [P Q]]].\nleft; auto.\nright; exists i''; intuition.\neapply t_trans; eauto.\napply t_step; auto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Plus L2 s2 t2 s3) (IHplus : t2 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i0 /\\ match_states i' s4 s3)) (H2 : t1 ** t2 = E0) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) : t1 = E0 /\\ t2 = E0 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s3).","conclusion":"t1 = E0 /\\ t2 = E0 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s3)","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Plus L2 s2 t2 s3) (IHplus : t2 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i0 /\\ match_states i' s4 s3)) (H2 : t1 ** t2 = E0) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0)","proofString":"intros [EQ1 EQ2]; subst.\nexploit bsim_simulation'; eauto.\nintros [[i' [s1' [A B]]] | [i' [A [B C]]]].\nexploit bsim_E0_star.\napply plus_star; eauto.\neauto.\neapply star_safe; eauto.\napply plus_star; auto.\nintros [i'' [s1'' [P Q]]].\nleft; exists i''; exists s1''; intuition.\neapply plus_star_trans; eauto.\nexploit IHplus; eauto.\nintros [P | [i'' [P Q]]].\nleft; auto.\nright; exists i''; intuition.\neapply t_trans; eauto.\napply t_step; auto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i0 /\\ match_states i' s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) : (exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s3).","conclusion":"(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s3)","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i0 /\\ match_states i' s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0)","proofString":"exploit bsim_simulation'; eauto.\nintros [[i' [s1' [A B]]] | [i' [A [B C]]]].\nexploit bsim_E0_star.\napply plus_star; eauto.\neauto.\neapply star_safe; eauto.\napply plus_star; auto.\nintros [i'' [s1'' [P Q]]].\nleft; exists i''; exists s1''; intuition.\neapply plus_star_trans; eauto.\nexploit IHplus; eauto.\nintros [P | [i'' [P Q]]].\nleft; auto.\nright; exists i''; intuition.\neapply t_trans; eauto.\napply t_step; auto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i0 /\\ match_states i' s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) : (exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s2) \\/\n(exists i' : index, order i' i /\\ E0 = E0 /\\ match_states i' s0 s2) ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s3).","conclusion":"(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s2) \\/\n(exists i' : index, order i' i /\\ E0 = E0 /\\ match_states i' s0 s2) ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i /\\ match_states i' s0 s3)","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i' : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i' s1' s3) \\/\n(exists i' : index, clos_trans index order i' i0 /\\ match_states i' s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0)","proofString":"intros [[i' [s1' [A B]]] | [i' [A [B C]]]].\nexploit bsim_E0_star.\napply plus_star; eauto.\neauto.\neapply star_safe; eauto.\napply plus_star; auto.\nintros [i'' [s1'' [P Q]]].\nleft; exists i''; exists s1''; intuition.\neapply plus_star_trans; eauto.\nexploit IHplus; eauto.\nintros [P | [i'' [P Q]]].\nleft; auto.\nright; exists i''; intuition.\neapply t_trans; eauto.\napply t_step; auto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2) : (exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3).","conclusion":"(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3)","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2)","proofString":"exploit bsim_E0_star.\napply plus_star; eauto.\neauto.\neapply star_safe; eauto.\napply plus_star; auto.\nintros [i'' [s1'' [P Q]]].\nleft; exists i''; exists s1''; intuition.\neapply plus_star_trans; eauto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2) : Star L1 s0 E0 s1'.","conclusion":"Star L1 s0 E0 s1'","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2)","proofString":"apply plus_star; auto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2) (i'' : index) (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : match_states i'' s1'' s3) : (exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3).","conclusion":"(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s0 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3)","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2) (i'' : index) (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : match_states i'' s1'' s3)","proofString":"left; exists i''; exists s1''; intuition.\neapply plus_star_trans; eauto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2) (i'' : index) (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : match_states i'' s1'' s3) (H1 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) : Plus L1 s0 E0 s1''.","conclusion":"Plus L1 s0 E0 s1''","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (s1' : state L1) (A : Plus L1 s0 E0 s1') (B : match_states i' s1' s2) (i'' : index) (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : match_states i'' s1'' s3) (H1 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1'0 : state L1),\n   Plus L1 s4 E0 s1'0 /\\ match_states i'0 s1'0 s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3))","proofString":"eapply plus_star_trans; eauto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) : (exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3).","conclusion":"(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3)","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2)","proofString":"exploit IHplus; eauto.\nintros [P | [i'' [P Q]]].\nleft; auto.\nright; exists i''; intuition.\neapply t_trans; eauto.\napply t_step; auto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) : (exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i' /\\ match_states i'0 s0 s3) ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3).","conclusion":"(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i' /\\ match_states i'0 s0 s3) ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3)","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2)","proofString":"intros [P | [i'' [P Q]]].\nleft; auto.\nright; exists i''; intuition.\neapply t_trans; eauto.\napply t_step; auto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) (P : exists (i'0 : index) (s1' : state L1),\n  Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) : (exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3).","conclusion":"(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3)","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) (P : exists (i'0 : index) (s1' : state L1),\n  Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3)","proofString":"left; auto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) (i'' : index) (P : clos_trans index order i'' i') (Q : match_states i'' s0 s3) : (exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3).","conclusion":"(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s0 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i /\\ match_states i'0 s0 s3)","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (IHplus : E0 = E0 ->\nforall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) (i'' : index) (P : clos_trans index order i'' i') (Q : match_states i'' s0 s3)","proofString":"right; exists i''; intuition.\neapply t_trans; eauto.\napply t_step; auto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) (i'' : index) (P : clos_trans index order i'' i') (Q : match_states i'' s0 s3) (H1 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) : clos_trans index order i'' i.","conclusion":"clos_trans index order i'' i","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) (i'' : index) (P : clos_trans index order i'' i') (Q : match_states i'' s0 s3) (H1 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3))","proofString":"eapply t_trans; eauto.\napply t_step; auto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) (i'' : index) (P : clos_trans index order i'' i') (Q : match_states i'' s0 s3) (H1 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3)) : clos_trans index order i' i.","conclusion":"clos_trans index order i' i","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H2 : E0 ** E0 = E0) (H0 : Plus L2 s2 E0 s3) (i : index) (s0 : state L1) (H3 : match_states i s0 s1) (H4 : safe L1 s0) (i' : index) (A : order i' i) (B : E0 = E0) (C : match_states i' s0 s2) (i'' : index) (P : clos_trans index order i'' i') (Q : match_states i'' s0 s3) (H1 : forall (i0 : index) (s4 : state L1),\nmatch_states i0 s4 s2 ->\nsafe L1 s4 ->\n(exists (i'0 : index) (s1' : state L1),\n   Plus L1 s4 E0 s1' /\\ match_states i'0 s1' s3) \\/\n(exists i'0 : index, clos_trans index order i'0 i0 /\\ match_states i'0 s4 s3))","proofString":"apply t_step; auto."},{"statement":"(s : state L2) (H : Datatypes.length E0 = 1%nat) : exists s2x s2y : state L2,\n  Star L2 s E0 s2x /\\ Step L2 s2x E0 s2y /\\ Star L2 s2y E0 s.","conclusion":"exists s2x s2y : state L2,\n  Star L2 s E0 s2x /\\ Step L2 s2x E0 s2y /\\ Star L2 s2y E0 s","hypotheses":"(s : state L2) (H : Datatypes.length E0 = 1%nat)","proofString":"simpl in H; discriminate."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length t = 1%nat) : exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x t s2y /\\ Star L2 s2y E0 s3.","conclusion":"exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x t s2y /\\ Star L2 s2y E0 s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length t = 1%nat)","proofString":"subst t.\nassert (EITHER: t1 = E0 \\/ t2 = E0).\nunfold Eapp in H2; rewrite app_length in H2.\ndestruct t1; auto.\ndestruct t2; auto.\nsimpl in H2; extlia.\ndestruct EITHER; subst.\nexploit IHstar; eauto.\nintros [s2x [s2y [A [B C]]]].\nexists s2x; exists s2y; intuition.\neapply star_left; eauto.\nrewrite E0_right.\nexists s1; exists s2; intuition.\napply star_refl."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (t1 ** t2) = 1%nat) : exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (t1 ** t2) s2y /\\ Star L2 s2y E0 s3.","conclusion":"exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (t1 ** t2) s2y /\\ Star L2 s2y E0 s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (t1 ** t2) = 1%nat)","proofString":"assert (EITHER: t1 = E0 \\/ t2 = E0).\nunfold Eapp in H2; rewrite app_length in H2.\ndestruct t1; auto.\ndestruct t2; auto.\nsimpl in H2; extlia.\ndestruct EITHER; subst.\nexploit IHstar; eauto.\nintros [s2x [s2y [A [B C]]]].\nexists s2x; exists s2y; intuition.\neapply star_left; eauto.\nrewrite E0_right.\nexists s1; exists s2; intuition.\napply star_refl."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (t1 ** t2) = 1%nat) : t1 = E0 \\/ t2 = E0.","conclusion":"t1 = E0 \\/ t2 = E0","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (t1 ** t2) = 1%nat)","proofString":"unfold Eapp in H2; rewrite app_length in H2.\ndestruct t1; auto.\ndestruct t2; auto.\nsimpl in H2; extlia."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : (Datatypes.length t1 + Datatypes.length t2)%nat = 1%nat) : t1 = E0 \\/ t2 = E0.","conclusion":"t1 = E0 \\/ t2 = E0","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : (Datatypes.length t1 + Datatypes.length t2)%nat = 1%nat)","proofString":"destruct t1; auto.\ndestruct t2; auto.\nsimpl in H2; extlia."},{"statement":"(s1 : state L2) (e : event) (t1 : list event) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 (e :: t1) s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : (Datatypes.length (e :: t1) + Datatypes.length t2)%nat = 1%nat) : e :: t1 = E0 \\/ t2 = E0.","conclusion":"e :: t1 = E0 \\/ t2 = E0","hypotheses":"(s1 : state L2) (e : event) (t1 : list event) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 (e :: t1) s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : (Datatypes.length (e :: t1) + Datatypes.length t2)%nat = 1%nat)","proofString":"destruct t2; auto.\nsimpl in H2; extlia."},{"statement":"(s1 : state L2) (e : event) (t1 : list event) (s2 : state L2) (e0 : event) (t2 : list event) (s3 : state L2) (H : Step L2 s1 (e :: t1) s2) (H0 : Star L2 s2 (e0 :: t2) s3) (IHstar : Datatypes.length (e0 :: t2) = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x (e0 :: t2) s2y /\\ Star L2 s2y E0 s3) (H2 : (Datatypes.length (e :: t1) + Datatypes.length (e0 :: t2))%nat = 1%nat) : e :: t1 = E0 \\/ e0 :: t2 = E0.","conclusion":"e :: t1 = E0 \\/ e0 :: t2 = E0","hypotheses":"(s1 : state L2) (e : event) (t1 : list event) (s2 : state L2) (e0 : event) (t2 : list event) (s3 : state L2) (H : Step L2 s1 (e :: t1) s2) (H0 : Star L2 s2 (e0 :: t2) s3) (IHstar : Datatypes.length (e0 :: t2) = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x (e0 :: t2) s2y /\\ Star L2 s2y E0 s3) (H2 : (Datatypes.length (e :: t1) + Datatypes.length (e0 :: t2))%nat = 1%nat)","proofString":"simpl in H2; extlia."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (t1 ** t2) = 1%nat) (EITHER : t1 = E0 \\/ t2 = E0) : exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (t1 ** t2) s2y /\\ Star L2 s2y E0 s3.","conclusion":"exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (t1 ** t2) s2y /\\ Star L2 s2y E0 s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (t1 ** t2) = 1%nat) (EITHER : t1 = E0 \\/ t2 = E0)","proofString":"destruct EITHER; subst.\nexploit IHstar; eauto.\nintros [s2x [s2y [A [B C]]]].\nexists s2x; exists s2y; intuition.\neapply star_left; eauto.\nrewrite E0_right.\nexists s1; exists s2; intuition.\napply star_refl."},{"statement":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (E0 ** t2) = 1%nat) : exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (E0 ** t2) s2y /\\ Star L2 s2y E0 s3.","conclusion":"exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (E0 ** t2) s2y /\\ Star L2 s2y E0 s3","hypotheses":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (E0 ** t2) = 1%nat)","proofString":"exploit IHstar; eauto.\nintros [s2x [s2y [A [B C]]]].\nexists s2x; exists s2y; intuition.\neapply star_left; eauto."},{"statement":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (E0 ** t2) = 1%nat) : (exists s2x s2y : state L2,\n   Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) ->\nexists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (E0 ** t2) s2y /\\ Star L2 s2y E0 s3.","conclusion":"(exists s2x s2y : state L2,\n   Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) ->\nexists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (E0 ** t2) s2y /\\ Star L2 s2y E0 s3","hypotheses":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x t2 s2y /\\ Star L2 s2y E0 s3) (H2 : Datatypes.length (E0 ** t2) = 1%nat)","proofString":"intros [s2x [s2y [A [B C]]]].\nexists s2x; exists s2y; intuition.\neapply star_left; eauto."},{"statement":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x0 s2y0 : state L2,\n  Star L2 s2 E0 s2x0 /\\ Step L2 s2x0 t2 s2y0 /\\ Star L2 s2y0 E0 s3) (H2 : Datatypes.length (E0 ** t2) = 1%nat) (s2x s2y : state L2) (A : Star L2 s2 E0 s2x) (B : Step L2 s2x t2 s2y) (C : Star L2 s2y E0 s3) : exists s2x0 s2y0 : state L2,\n  Star L2 s1 E0 s2x0 /\\ Step L2 s2x0 (E0 ** t2) s2y0 /\\ Star L2 s2y0 E0 s3.","conclusion":"exists s2x0 s2y0 : state L2,\n  Star L2 s1 E0 s2x0 /\\ Step L2 s2x0 (E0 ** t2) s2y0 /\\ Star L2 s2y0 E0 s3","hypotheses":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : Star L2 s2 t2 s3) (IHstar : Datatypes.length t2 = 1%nat ->\nexists s2x0 s2y0 : state L2,\n  Star L2 s2 E0 s2x0 /\\ Step L2 s2x0 t2 s2y0 /\\ Star L2 s2y0 E0 s3) (H2 : Datatypes.length (E0 ** t2) = 1%nat) (s2x s2y : state L2) (A : Star L2 s2 E0 s2x) (B : Step L2 s2x t2 s2y) (C : Star L2 s2y E0 s3)","proofString":"exists s2x; exists s2y; intuition.\neapply star_left; eauto."},{"statement":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : Star L2 s2 t2 s3) (H2 : Datatypes.length (E0 ** t2) = 1%nat) (s2x s2y : state L2) (A : Star L2 s2 E0 s2x) (B : Step L2 s2x t2 s2y) (C : Star L2 s2y E0 s3) (H1 : exists s2x0 s2y0 : state L2,\n  Star L2 s2 E0 s2x0 /\\ Step L2 s2x0 t2 s2y0 /\\ Star L2 s2y0 E0 s3) : Star L2 s1 E0 s2x.","conclusion":"Star L2 s1 E0 s2x","hypotheses":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : Star L2 s2 t2 s3) (H2 : Datatypes.length (E0 ** t2) = 1%nat) (s2x s2y : state L2) (A : Star L2 s2 E0 s2x) (B : Step L2 s2x t2 s2y) (C : Star L2 s2y E0 s3) (H1 : exists s2x0 s2y0 : state L2,\n  Star L2 s2 E0 s2x0 /\\ Step L2 s2x0 t2 s2y0 /\\ Star L2 s2y0 E0 s3)","proofString":"eapply star_left; eauto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 s3 : state L2) (H : Step L2 s1 t1 s2) (H2 : Datatypes.length (t1 ** E0) = 1%nat) (IHstar : Datatypes.length E0 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x E0 s2y /\\ Star L2 s2y E0 s3) (H0 : Star L2 s2 E0 s3) : exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (t1 ** E0) s2y /\\ Star L2 s2y E0 s3.","conclusion":"exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x (t1 ** E0) s2y /\\ Star L2 s2y E0 s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 s3 : state L2) (H : Step L2 s1 t1 s2) (H2 : Datatypes.length (t1 ** E0) = 1%nat) (IHstar : Datatypes.length E0 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x E0 s2y /\\ Star L2 s2y E0 s3) (H0 : Star L2 s2 E0 s3)","proofString":"rewrite E0_right.\nexists s1; exists s2; intuition.\napply star_refl."},{"statement":"(s1 : state L2) (t1 : trace) (s2 s3 : state L2) (H : Step L2 s1 t1 s2) (H2 : Datatypes.length (t1 ** E0) = 1%nat) (IHstar : Datatypes.length E0 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x E0 s2y /\\ Star L2 s2y E0 s3) (H0 : Star L2 s2 E0 s3) : exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x t1 s2y /\\ Star L2 s2y E0 s3.","conclusion":"exists s2x s2y : state L2,\n  Star L2 s1 E0 s2x /\\ Step L2 s2x t1 s2y /\\ Star L2 s2y E0 s3","hypotheses":"(s1 : state L2) (t1 : trace) (s2 s3 : state L2) (H : Step L2 s1 t1 s2) (H2 : Datatypes.length (t1 ** E0) = 1%nat) (IHstar : Datatypes.length E0 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x E0 s2y /\\ Star L2 s2y E0 s3) (H0 : Star L2 s2 E0 s3)","proofString":"exists s1; exists s2; intuition.\napply star_refl."},{"statement":"(s1 : state L2) (t1 : trace) (s2 s3 : state L2) (H : Step L2 s1 t1 s2) (H2 : Datatypes.length (t1 ** E0) = 1%nat) (IHstar : Datatypes.length E0 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x E0 s2y /\\ Star L2 s2y E0 s3) (H0 : Star L2 s2 E0 s3) : Star L2 s1 E0 s1.","conclusion":"Star L2 s1 E0 s1","hypotheses":"(s1 : state L2) (t1 : trace) (s2 s3 : state L2) (H : Step L2 s1 t1 s2) (H2 : Datatypes.length (t1 ** E0) = 1%nat) (IHstar : Datatypes.length E0 = 1%nat ->\nexists s2x s2y : state L2,\n  Star L2 s2 E0 s2x /\\ Step L2 s2x E0 s2y /\\ Star L2 s2y E0 s3) (H0 : Star L2 s2 E0 s3)","proofString":"apply star_refl."},{"statement":"(i1 : index) (i2 : index') (s1 : state L1) (s3 : state L3) (s2 : state L2) (H : match_states i1 s1 s2) (H0 : match_states' i2 s2 s3) : bb_match_states (i1, i2) s1 s3.","conclusion":"bb_match_states (i1, i2) s1 s3","hypotheses":"(i1 : index) (i2 : index') (s1 : state L1) (s3 : state L3) (s2 : state L2) (H : match_states i1 s1 s2) (H0 : match_states' i2 s2 s3)","proofString":"econstructor; eauto.\napply star_refl."},{"statement":"(i1 : index) (i2 : index') (s1 : state L1) (s3 : state L3) (s2 : state L2) (H : match_states i1 s1 s2) (H0 : match_states' i2 s2 s3) : Star L2 s2 E0 s2.","conclusion":"Star L2 s2 E0 s2","hypotheses":"(i1 : index) (i2 : index') (s1 : state L1) (s3 : state L3) (s2 : state L2) (H : match_states i1 s1 s2) (H0 : match_states' i2 s2 s3)","proofString":"apply star_refl."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1)","proofString":"exploit (bsim_simulation' S23); eauto.\neapply bsim_safe; eauto.\nintros [ [i2' [s2' [PLUS2 MATCH2]]] | [i2' [ORD2 [EQ MATCH2]]]].\nassert (EITHER: t = E0 \\/ (length t = 1)%nat).\nexploit L3_single_events; eauto.\ndestruct t; auto.\ndestruct t; auto.\nsimpl.\nintros.\nextlia.\ndestruct EITHER.\nsubst t.\nexploit (bsim_E0_plus S12); eauto.\nintros [ [i1' [s1' [PLUS1 MATCH1]]] | [i1' [ORD1 MATCH1]]].\nexists (i1', i2'); exists s1'; split.\nauto.\neapply bb_match_at; eauto.\nexists (i1', i2'); exists s1; split.\nright; split.\napply star_refl.\nleft; auto.\neapply bb_match_at; eauto.\nexploit star_non_E0_split.\napply plus_star; eauto.\nauto.\nintros [s2x [s2y [P [Q R]]]].\nexploit (bsim_E0_star S12).\neexact P.\neauto.\nauto.\nintros [i1' [s1x [X Y]]].\nexploit (bsim_simulation' S12).\neexact Q.\neauto.\neapply star_safe; eauto.\nintros [[i1'' [s1y [U V]]] | [i1'' [U [V W]]]]; try (subst t; discriminate).\nexists (i1'', i2'); exists s1y; split.\nleft.\neapply star_plus_trans; eauto.\neapply bb_match_later; eauto.\nsubst.\nexists (i1, i2'); exists s1; split.\nright; split.\napply star_refl.\nright; auto.\neapply bb_match_at; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) : safe L2 s2.","conclusion":"safe L2 s2","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1)","proofString":"eapply bsim_safe; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) : (exists (i' : index') (s1' : state L2),\n   Plus L2 s2 t s1' /\\ match_states' i' s1' s3') \\/\n(exists i' : index', order' i' i2 /\\ t = E0 /\\ match_states' i' s2 s3') ->\nexists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"(exists (i' : index') (s1' : state L2),\n   Plus L2 s2 t s1' /\\ match_states' i' s1' s3') \\/\n(exists i' : index', order' i' i2 /\\ t = E0 /\\ match_states' i' s2 s3') ->\nexists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1)","proofString":"intros [ [i2' [s2' [PLUS2 MATCH2]]] | [i2' [ORD2 [EQ MATCH2]]]].\nassert (EITHER: t = E0 \\/ (length t = 1)%nat).\nexploit L3_single_events; eauto.\ndestruct t; auto.\ndestruct t; auto.\nsimpl.\nintros.\nextlia.\ndestruct EITHER.\nsubst t.\nexploit (bsim_E0_plus S12); eauto.\nintros [ [i1' [s1' [PLUS1 MATCH1]]] | [i1' [ORD1 MATCH1]]].\nexists (i1', i2'); exists s1'; split.\nauto.\neapply bb_match_at; eauto.\nexists (i1', i2'); exists s1; split.\nright; split.\napply star_refl.\nleft; auto.\neapply bb_match_at; eauto.\nexploit star_non_E0_split.\napply plus_star; eauto.\nauto.\nintros [s2x [s2y [P [Q R]]]].\nexploit (bsim_E0_star S12).\neexact P.\neauto.\nauto.\nintros [i1' [s1x [X Y]]].\nexploit (bsim_simulation' S12).\neexact Q.\neauto.\neapply star_safe; eauto.\nintros [[i1'' [s1y [U V]]] | [i1'' [U [V W]]]]; try (subst t; discriminate).\nexists (i1'', i2'); exists s1y; split.\nleft.\neapply star_plus_trans; eauto.\neapply bb_match_later; eauto.\nsubst.\nexists (i1, i2'); exists s1; split.\nright; split.\napply star_refl.\nright; auto.\neapply bb_match_at; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3')","proofString":"assert (EITHER: t = E0 \\/ (length t = 1)%nat).\nexploit L3_single_events; eauto.\ndestruct t; auto.\ndestruct t; auto.\nsimpl.\nintros.\nextlia.\ndestruct EITHER.\nsubst t.\nexploit (bsim_E0_plus S12); eauto.\nintros [ [i1' [s1' [PLUS1 MATCH1]]] | [i1' [ORD1 MATCH1]]].\nexists (i1', i2'); exists s1'; split.\nauto.\neapply bb_match_at; eauto.\nexists (i1', i2'); exists s1; split.\nright; split.\napply star_refl.\nleft; auto.\neapply bb_match_at; eauto.\nexploit star_non_E0_split.\napply plus_star; eauto.\nauto.\nintros [s2x [s2y [P [Q R]]]].\nexploit (bsim_E0_star S12).\neexact P.\neauto.\nauto.\nintros [i1' [s1x [X Y]]].\nexploit (bsim_simulation' S12).\neexact Q.\neauto.\neapply star_safe; eauto.\nintros [[i1'' [s1y [U V]]] | [i1'' [U [V W]]]]; try (subst t; discriminate).\nexists (i1'', i2'); exists s1y; split.\nleft.\neapply star_plus_trans; eauto.\neapply bb_match_later; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') : t = E0 \\/ Datatypes.length t = 1%nat.","conclusion":"t = E0 \\/ Datatypes.length t = 1%nat","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3')","proofString":"exploit L3_single_events; eauto.\ndestruct t; auto.\ndestruct t; auto.\nsimpl.\nintros.\nextlia."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') : (Datatypes.length t <= 1)%nat -> t = E0 \\/ Datatypes.length t = 1%nat.","conclusion":"(Datatypes.length t <= 1)%nat -> t = E0 \\/ Datatypes.length t = 1%nat","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3')","proofString":"destruct t; auto.\ndestruct t; auto.\nsimpl.\nintros.\nextlia."},{"statement":"(s3 : state L3) (e : event) (t : list event) (s3' : state L3) (H : Step L3 s3 (e :: t) s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 (e :: t) s2') (MATCH2 : match_states' i2' s2' s3') : (Datatypes.length (e :: t) <= 1)%nat ->\ne :: t = E0 \\/ Datatypes.length (e :: t) = 1%nat.","conclusion":"(Datatypes.length (e :: t) <= 1)%nat ->\ne :: t = E0 \\/ Datatypes.length (e :: t) = 1%nat","hypotheses":"(s3 : state L3) (e : event) (t : list event) (s3' : state L3) (H : Step L3 s3 (e :: t) s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 (e :: t) s2') (MATCH2 : match_states' i2' s2' s3')","proofString":"destruct t; auto.\nsimpl.\nintros.\nextlia."},{"statement":"(s3 : state L3) (e e0 : event) (t : list event) (s3' : state L3) (H : Step L3 s3 (e :: e0 :: t) s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 (e :: e0 :: t) s2') (MATCH2 : match_states' i2' s2' s3') : (Datatypes.length (e :: e0 :: t) <= 1)%nat ->\ne :: e0 :: t = E0 \\/ Datatypes.length (e :: e0 :: t) = 1%nat.","conclusion":"(Datatypes.length (e :: e0 :: t) <= 1)%nat ->\ne :: e0 :: t = E0 \\/ Datatypes.length (e :: e0 :: t) = 1%nat","hypotheses":"(s3 : state L3) (e e0 : event) (t : list event) (s3' : state L3) (H : Step L3 s3 (e :: e0 :: t) s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 (e :: e0 :: t) s2') (MATCH2 : match_states' i2' s2' s3')","proofString":"simpl.\nintros.\nextlia."},{"statement":"(s3 : state L3) (e e0 : event) (t : list event) (s3' : state L3) (H : Step L3 s3 (e :: e0 :: t) s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 (e :: e0 :: t) s2') (MATCH2 : match_states' i2' s2' s3') : (S (S (Datatypes.length t)) <= 1)%nat ->\ne :: e0 :: t = E0 \\/ S (S (Datatypes.length t)) = 1%nat.","conclusion":"(S (S (Datatypes.length t)) <= 1)%nat ->\ne :: e0 :: t = E0 \\/ S (S (Datatypes.length t)) = 1%nat","hypotheses":"(s3 : state L3) (e e0 : event) (t : list event) (s3' : state L3) (H : Step L3 s3 (e :: e0 :: t) s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 (e :: e0 :: t) s2') (MATCH2 : match_states' i2' s2' s3')","proofString":"intros.\nextlia."},{"statement":"(s3 : state L3) (e e0 : event) (t : list event) (s3' : state L3) (H : Step L3 s3 (e :: e0 :: t) s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 (e :: e0 :: t) s2') (MATCH2 : match_states' i2' s2' s3') (H3 : (S (S (Datatypes.length t)) <= 1)%nat) : e :: e0 :: t = E0 \\/ S (S (Datatypes.length t)) = 1%nat.","conclusion":"e :: e0 :: t = E0 \\/ S (S (Datatypes.length t)) = 1%nat","hypotheses":"(s3 : state L3) (e e0 : event) (t : list event) (s3' : state L3) (H : Step L3 s3 (e :: e0 :: t) s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 (e :: e0 :: t) s2') (MATCH2 : match_states' i2' s2' s3') (H3 : (S (S (Datatypes.length t)) <= 1)%nat)","proofString":"extlia."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (EITHER : t = E0 \\/ Datatypes.length t = 1%nat) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (EITHER : t = E0 \\/ Datatypes.length t = 1%nat)","proofString":"destruct EITHER.\nsubst t.\nexploit (bsim_E0_plus S12); eauto.\nintros [ [i1' [s1' [PLUS1 MATCH1]]] | [i1' [ORD1 MATCH1]]].\nexists (i1', i2'); exists s1'; split.\nauto.\neapply bb_match_at; eauto.\nexists (i1', i2'); exists s1; split.\nright; split.\napply star_refl.\nleft; auto.\neapply bb_match_at; eauto.\nexploit star_non_E0_split.\napply plus_star; eauto.\nauto.\nintros [s2x [s2y [P [Q R]]]].\nexploit (bsim_E0_star S12).\neexact P.\neauto.\nauto.\nintros [i1' [s1x [X Y]]].\nexploit (bsim_simulation' S12).\neexact Q.\neauto.\neapply star_safe; eauto.\nintros [[i1'' [s1y [U V]]] | [i1'' [U [V W]]]]; try (subst t; discriminate).\nexists (i1'', i2'); exists s1y; split.\nleft.\neapply star_plus_trans; eauto.\neapply bb_match_later; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : t = E0) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : t = E0)","proofString":"subst t.\nexploit (bsim_E0_plus S12); eauto.\nintros [ [i1' [s1' [PLUS1 MATCH1]]] | [i1' [ORD1 MATCH1]]].\nexists (i1', i2'); exists s1'; split.\nauto.\neapply bb_match_at; eauto.\nexists (i1', i2'); exists s1; split.\nright; split.\napply star_refl.\nleft; auto.\neapply bb_match_at; eauto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3')","proofString":"exploit (bsim_E0_plus S12); eauto.\nintros [ [i1' [s1' [PLUS1 MATCH1]]] | [i1' [ORD1 MATCH1]]].\nexists (i1', i2'); exists s1'; split.\nauto.\neapply bb_match_at; eauto.\nexists (i1', i2'); exists s1; split.\nright; split.\napply star_refl.\nleft; auto.\neapply bb_match_at; eauto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') : (exists (i' : index) (s1' : state L1),\n   Plus L1 s1 E0 s1' /\\ match_states i' s1' s2') \\/\n(exists i' : index, clos_trans index order i' i1 /\\ match_states i' s1 s2') ->\nexists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"(exists (i' : index) (s1' : state L1),\n   Plus L1 s1 E0 s1' /\\ match_states i' s1' s2') \\/\n(exists i' : index, clos_trans index order i' i1 /\\ match_states i' s1 s2') ->\nexists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3')","proofString":"intros [ [i1' [s1' [PLUS1 MATCH1]]] | [i1' [ORD1 MATCH1]]].\nexists (i1', i2'); exists s1'; split.\nauto.\neapply bb_match_at; eauto.\nexists (i1', i2'); exists s1; split.\nright; split.\napply star_refl.\nleft; auto.\neapply bb_match_at; eauto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (s1' : state L1) (PLUS1 : Plus L1 s1 E0 s1') (MATCH1 : match_states i1' s1' s2') : exists (i' : bb_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1'0 s3'.","conclusion":"exists (i' : bb_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1'0 s3'","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (s1' : state L1) (PLUS1 : Plus L1 s1 E0 s1') (MATCH1 : match_states i1' s1' s2')","proofString":"exists (i1', i2'); exists s1'; split.\nauto.\neapply bb_match_at; eauto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (s1' : state L1) (PLUS1 : Plus L1 s1 E0 s1') (MATCH1 : match_states i1' s1' s2') : Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order (i1', i2') (i1, i2).","conclusion":"Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order (i1', i2') (i1, i2)","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (s1' : state L1) (PLUS1 : Plus L1 s1 E0 s1') (MATCH1 : match_states i1' s1' s2')","proofString":"auto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (s1' : state L1) (PLUS1 : Plus L1 s1 E0 s1') (MATCH1 : match_states i1' s1' s2') : bb_match_states (i1', i2') s1' s3'.","conclusion":"bb_match_states (i1', i2') s1' s3'","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (s1' : state L1) (PLUS1 : Plus L1 s1 E0 s1') (MATCH1 : match_states i1' s1' s2')","proofString":"eapply bb_match_at; eauto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2') : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2')","proofString":"exists (i1', i2'); exists s1; split.\nright; split.\napply star_refl.\nleft; auto.\neapply bb_match_at; eauto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2') : Plus L1 s1 E0 s1 \\/ Star L1 s1 E0 s1 /\\ bb_order (i1', i2') (i1, i2).","conclusion":"Plus L1 s1 E0 s1 \\/ Star L1 s1 E0 s1 /\\ bb_order (i1', i2') (i1, i2)","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2')","proofString":"right; split.\napply star_refl.\nleft; auto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2') : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2')","proofString":"apply star_refl."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2') : bb_order (i1', i2') (i1, i2).","conclusion":"bb_order (i1', i2') (i1, i2)","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2')","proofString":"left; auto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2') : bb_match_states (i1', i2') s1 s3'.","conclusion":"bb_match_states (i1', i2') s1 s3'","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 E0 s2') (MATCH2 : match_states' i2' s2' s3') (i1' : index) (ORD1 : clos_trans index order i1' i1) (MATCH1 : match_states i1' s1 s2')","proofString":"eapply bb_match_at; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat)","proofString":"exploit star_non_E0_split.\napply plus_star; eauto.\nauto.\nintros [s2x [s2y [P [Q R]]]].\nexploit (bsim_E0_star S12).\neexact P.\neauto.\nauto.\nintros [i1' [s1x [X Y]]].\nexploit (bsim_simulation' S12).\neexact Q.\neauto.\neapply star_safe; eauto.\nintros [[i1'' [s1y [U V]]] | [i1'' [U [V W]]]]; try (subst t; discriminate).\nexists (i1'', i2'); exists s1y; split.\nleft.\neapply star_plus_trans; eauto.\neapply bb_match_later; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2')","proofString":"exploit (bsim_E0_star S12).\neexact P.\neauto.\nauto.\nintros [i1' [s1x [X Y]]].\nexploit (bsim_simulation' S12).\neexact Q.\neauto.\neapply star_safe; eauto.\nintros [[i1'' [s1y [U V]]] | [i1'' [U [V W]]]]; try (subst t; discriminate).\nexists (i1'', i2'); exists s1y; split.\nleft.\neapply star_plus_trans; eauto.\neapply bb_match_later; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x)","proofString":"exploit (bsim_simulation' S12).\neexact Q.\neauto.\neapply star_safe; eauto.\nintros [[i1'' [s1y [U V]]] | [i1'' [U [V W]]]]; try (subst t; discriminate).\nexists (i1'', i2'); exists s1y; split.\nleft.\neapply star_plus_trans; eauto.\neapply bb_match_later; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x) (i1'' : index) (s1y : state L1) (U : Plus L1 s1x t s1y) (V : match_states i1'' s1y s2y) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x) (i1'' : index) (s1y : state L1) (U : Plus L1 s1x t s1y) (V : match_states i1'' s1y s2y)","proofString":"exists (i1'', i2'); exists s1y; split.\nleft.\neapply star_plus_trans; eauto.\neapply bb_match_later; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x) (i1'' : index) (s1y : state L1) (U : Plus L1 s1x t s1y) (V : match_states i1'' s1y s2y) : Plus L1 s1 t s1y \\/ Star L1 s1 t s1y /\\ bb_order (i1'', i2') (i1, i2).","conclusion":"Plus L1 s1 t s1y \\/ Star L1 s1 t s1y /\\ bb_order (i1'', i2') (i1, i2)","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x) (i1'' : index) (s1y : state L1) (U : Plus L1 s1x t s1y) (V : match_states i1'' s1y s2y)","proofString":"left.\neapply star_plus_trans; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x) (i1'' : index) (s1y : state L1) (U : Plus L1 s1x t s1y) (V : match_states i1'' s1y s2y) : Plus L1 s1 t s1y.","conclusion":"Plus L1 s1 t s1y","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x) (i1'' : index) (s1y : state L1) (U : Plus L1 s1x t s1y) (V : match_states i1'' s1y s2y)","proofString":"eapply star_plus_trans; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x) (i1'' : index) (s1y : state L1) (U : Plus L1 s1x t s1y) (V : match_states i1'' s1y s2y) : bb_match_states (i1'', i2') s1y s3'.","conclusion":"bb_match_states (i1'', i2') s1y s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (s2' : state L2) (PLUS2 : Plus L2 s2 t s2') (MATCH2 : match_states' i2' s2' s3') (H3 : Datatypes.length t = 1%nat) (s2x s2y : state L2) (P : Star L2 s2 E0 s2x) (Q : Step L2 s2x t s2y) (R : Star L2 s2y E0 s2') (i1' : index) (s1x : state L1) (X : Star L1 s1 E0 s1x) (Y : match_states i1' s1x s2x) (i1'' : index) (s1y : state L1) (U : Plus L1 s1x t s1y) (V : match_states i1'' s1y s2y)","proofString":"eapply bb_match_later; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (EQ : t = E0) (MATCH2 : match_states' i2' s2 s3') : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (EQ : t = E0) (MATCH2 : match_states' i2' s2 s3')","proofString":"subst.\nexists (i1, i2'); exists s1; split.\nright; split.\napply star_refl.\nright; auto.\neapply bb_match_at; eauto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3') : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3')","proofString":"exists (i1, i2'); exists s1; split.\nright; split.\napply star_refl.\nright; auto.\neapply bb_match_at; eauto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3') : Plus L1 s1 E0 s1 \\/ Star L1 s1 E0 s1 /\\ bb_order (i1, i2') (i1, i2).","conclusion":"Plus L1 s1 E0 s1 \\/ Star L1 s1 E0 s1 /\\ bb_order (i1, i2') (i1, i2)","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3')","proofString":"right; split.\napply star_refl.\nright; auto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3') : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3')","proofString":"apply star_refl."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3') : bb_order (i1, i2') (i1, i2).","conclusion":"bb_order (i1, i2') (i1, i2)","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3')","proofString":"right; auto."},{"statement":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3') : bb_match_states (i1, i2') s1 s3'.","conclusion":"bb_match_states (i1, i2') s1 s3'","hypotheses":"(s3 s3' : state L3) (H : Step L3 s3 E0 s3') (i1 : index) (s1 : state L1) (i2 : index') (s2 : state L2) (H0 : match_states i1 s1 s2) (H1 : match_states' i2 s2 s3) (H2 : safe L1 s1) (i2' : index') (ORD2 : order' i2' i2) (MATCH2 : match_states' i2' s2 s3')","proofString":"eapply bb_match_at; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i : bb_index) (s1 : state L1) (H0 : bb_match_states i s1 s3) (H1 : safe L1 s1) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' i) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' i) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (i : bb_index) (s1 : state L1) (H0 : bb_match_states i s1 s3) (H1 : safe L1 s1)","proofString":"inv H0.\nexploit star_inv; eauto.\nintros [[EQ1 EQ2] | PLUS].\nsubst.\neapply bb_simulation_base; eauto.\nexploit (bsim_E0_plus S12); eauto.\nintros [[i1' [s1' [A B]]] | [i1' [A B]]].\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\neapply star_safe; eauto.\neapply plus_star; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nleft.\neapply plus_star_trans; eauto.\ndestruct C as [P | [P Q]].\napply plus_star; eauto.\neauto.\ntraceEq.\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\nauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nintuition.\nright; intuition.\ninv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3)","proofString":"exploit star_inv; eauto.\nintros [[EQ1 EQ2] | PLUS].\nsubst.\neapply bb_simulation_base; eauto.\nexploit (bsim_E0_plus S12); eauto.\nintros [[i1' [s1' [A B]]] | [i1' [A B]]].\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\neapply star_safe; eauto.\neapply plus_star; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nleft.\neapply plus_star_trans; eauto.\ndestruct C as [P | [P Q]].\napply plus_star; eauto.\neauto.\ntraceEq.\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\nauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nintuition.\nright; intuition.\ninv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) : s2y = s2x /\\ E0 = E0 \\/ Plus L2 s2x E0 s2y ->\nexists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"s2y = s2x /\\ E0 = E0 \\/ Plus L2 s2x E0 s2y ->\nexists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3)","proofString":"intros [[EQ1 EQ2] | PLUS].\nsubst.\neapply bb_simulation_base; eauto.\nexploit (bsim_E0_plus S12); eauto.\nintros [[i1' [s1' [A B]]] | [i1' [A B]]].\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\neapply star_safe; eauto.\neapply plus_star; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nleft.\neapply plus_star_trans; eauto.\ndestruct C as [P | [P Q]].\napply plus_star; eauto.\neauto.\ntraceEq.\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\nauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nintuition.\nright; intuition.\ninv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (EQ1 : s2y = s2x) (EQ2 : E0 = E0) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (EQ1 : s2y = s2x) (EQ2 : E0 = E0)","proofString":"subst.\neapply bb_simulation_base; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x : state L2) (H2 : match_states i1 s1 s2x) (H4 : match_states' i2 s2x s3) (H3 : Star L2 s2x E0 s2x) (EQ2 : E0 = E0) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x : state L2) (H2 : match_states i1 s1 s2x) (H4 : match_states' i2 s2x s3) (H3 : Star L2 s2x E0 s2x) (EQ2 : E0 = E0)","proofString":"eapply bb_simulation_base; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y)","proofString":"exploit (bsim_E0_plus S12); eauto.\nintros [[i1' [s1' [A B]]] | [i1' [A B]]].\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\neapply star_safe; eauto.\neapply plus_star; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nleft.\neapply plus_star_trans; eauto.\ndestruct C as [P | [P Q]].\napply plus_star; eauto.\neauto.\ntraceEq.\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\nauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nintuition.\nright; intuition.\ninv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) : (exists (i' : index) (s1' : state L1),\n   Plus L1 s1 E0 s1' /\\ match_states i' s1' s2y) \\/\n(exists i' : index, clos_trans index order i' i1 /\\ match_states i' s1 s2y) ->\nexists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"(exists (i' : index) (s1' : state L1),\n   Plus L1 s1 E0 s1' /\\ match_states i' s1' s2y) \\/\n(exists i' : index, clos_trans index order i' i1 /\\ match_states i' s1 s2y) ->\nexists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y)","proofString":"intros [[i1' [s1' [A B]]] | [i1' [A B]]].\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\neapply star_safe; eauto.\neapply plus_star; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nleft.\neapply plus_star_trans; eauto.\ndestruct C as [P | [P Q]].\napply plus_star; eauto.\neauto.\ntraceEq.\nexploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\nauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nintuition.\nright; intuition.\ninv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y) : exists (i' : bb_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1'0 s3'.","conclusion":"exists (i' : bb_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1'0 s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y)","proofString":"exploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\neapply star_safe; eauto.\neapply plus_star; eauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nleft.\neapply plus_star_trans; eauto.\ndestruct C as [P | [P Q]].\napply plus_star; eauto.\neauto.\ntraceEq."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y) : Star L1 s1 E0 s1'.","conclusion":"Star L1 s1 E0 s1'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y)","proofString":"eapply plus_star; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1' t s1'' \\/ Star L1 s1' t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3') : exists (i' : bb_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1'0 s3'.","conclusion":"exists (i' : bb_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1'0 s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1' t s1'' \\/ Star L1 s1' t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3')","proofString":"exists i''; exists s1''; split; auto.\nleft.\neapply plus_star_trans; eauto.\ndestruct C as [P | [P Q]].\napply plus_star; eauto.\neauto.\ntraceEq."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1' t s1'' \\/ Star L1 s1' t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3') : Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1, i2).","conclusion":"Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1, i2)","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1' t s1'' \\/ Star L1 s1' t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3')","proofString":"left.\neapply plus_star_trans; eauto.\ndestruct C as [P | [P Q]].\napply plus_star; eauto.\neauto.\ntraceEq."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1' t s1'' \\/ Star L1 s1' t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3') : Plus L1 s1 t s1''.","conclusion":"Plus L1 s1 t s1''","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (s1' : state L1) (A : Plus L1 s1 E0 s1') (B : match_states i1' s1' s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1' t s1'' \\/ Star L1 s1' t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3')","proofString":"eapply plus_star_trans; eauto.\ndestruct C as [P | [P Q]].\napply plus_star; eauto.\neauto.\ntraceEq."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y)","proofString":"exploit bb_simulation_base.\neauto.\nauto.\neexact B.\neauto.\nauto.\nintros [i'' [s1'' [C D]]].\nexists i''; exists s1''; split; auto.\nintuition.\nright; intuition.\ninv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3') : exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'.","conclusion":"exists (i' : bb_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order i' (i1, i2)) /\\\n  bb_match_states i' s1' s3'","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3')","proofString":"exists i''; exists s1''; split; auto.\nintuition.\nright; intuition.\ninv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3') : Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1, i2).","conclusion":"Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1, i2)","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (i'' : bb_index) (s1'' : state L1) (C : Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1', i2)) (D : bb_match_states i'' s1'' s3')","proofString":"intuition.\nright; intuition.\ninv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (i'' : bb_index) (s1'' : state L1) (D : bb_match_states i'' s1'' s3') (H5 : Star L1 s1 t s1'') (H6 : bb_order i'' (i1', i2)) : Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1, i2).","conclusion":"Plus L1 s1 t s1'' \\/ Star L1 s1 t s1'' /\\ bb_order i'' (i1, i2)","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (i'' : bb_index) (s1'' : state L1) (D : bb_match_states i'' s1'' s3') (H5 : Star L1 s1 t s1'') (H6 : bb_order i'' (i1', i2))","proofString":"right; intuition.\ninv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (i'' : bb_index) (s1'' : state L1) (D : bb_match_states i'' s1'' s3') (H5 : Star L1 s1 t s1'') (H6 : bb_order i'' (i1', i2)) : bb_order i'' (i1, i2).","conclusion":"bb_order i'' (i1, i2)","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (i'' : bb_index) (s1'' : state L1) (D : bb_match_states i'' s1'' s3') (H5 : Star L1 s1 t s1'') (H6 : bb_order i'' (i1', i2))","proofString":"inv H6.\nleft.\neapply t_trans; eauto.\nleft; auto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (s1'' : state L1) (a1 : index) (b1 : index') (D : bb_match_states (a1, b1) s1'' s3') (H5 : Star L1 s1 t s1'') (H8 : clos_trans index order a1 i1') : bb_order (a1, b1) (i1, i2).","conclusion":"bb_order (a1, b1) (i1, i2)","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (s1'' : state L1) (a1 : index) (b1 : index') (D : bb_match_states (a1, b1) s1'' s3') (H5 : Star L1 s1 t s1'') (H8 : clos_trans index order a1 i1')","proofString":"left.\neapply t_trans; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (s1'' : state L1) (a1 : index) (b1 : index') (D : bb_match_states (a1, b1) s1'' s3') (H5 : Star L1 s1 t s1'') (H8 : clos_trans index order a1 i1') : clos_trans index order a1 i1.","conclusion":"clos_trans index order a1 i1","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (s1'' : state L1) (a1 : index) (b1 : index') (D : bb_match_states (a1, b1) s1'' s3') (H5 : Star L1 s1 t s1'') (H8 : clos_trans index order a1 i1')","proofString":"eapply t_trans; eauto."},{"statement":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (s1'' : state L1) (b1 : index') (D : bb_match_states (i1', b1) s1'' s3') (H5 : Star L1 s1 t s1'') (H8 : order' b1 i2) : bb_order (i1', b1) (i1, i2).","conclusion":"bb_order (i1', b1) (i1, i2)","hypotheses":"(s3 : state L3) (t : trace) (s3' : state L3) (H : Step L3 s3 t s3') (s1 : state L1) (H1 : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H2 : match_states i1 s1 s2x) (H3 : Star L2 s2x E0 s2y) (H4 : match_states' i2 s2y s3) (PLUS : Plus L2 s2x E0 s2y) (i1' : index) (A : clos_trans index order i1' i1) (B : match_states i1' s1 s2y) (s1'' : state L1) (b1 : index') (D : bb_match_states (i1', b1) s1'' s3') (H5 : Star L1 s1 t s1'') (H8 : order' b1 i2)","proofString":"left; auto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (S12 : backward_simulation L1 L2) (S23 : backward_simulation L2 L3) : backward_simulation L1 L3.","conclusion":"backward_simulation L1 L3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (S12 : backward_simulation L1 L2) (S23 : backward_simulation L2 L3)","proofString":"destruct S12 as [index order match_states props].\ndestruct S23 as [index' order' match_states' props'].\napply Backward_simulation with (bb_order order order') (bb_match_states L1 L2 L3 match_states match_states');  constructor.\nunfold bb_order.\napply wf_lex_ord.\napply wf_clos_trans.\neapply bsim_order_wf; eauto.\neapply bsim_order_wf; eauto.\nintros.\nexploit (bsim_initial_states_exist props); eauto.\nintros [s2 A].\neapply (bsim_initial_states_exist props'); eauto.\nintros s1 s3 INIT1 INIT3.\nexploit (bsim_initial_states_exist props); eauto.\nintros [s2 INIT2].\nexploit (bsim_match_initial_states props'); eauto.\nintros [i2 [s2' [INIT2' M2]]].\nexploit (bsim_match_initial_states props); eauto.\nintros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto.\nintros i s1 s3 r MS SAFE FIN.\ninv MS.\nexploit (bsim_match_final_states props'); eauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto.\nintros [s2' [A B]].\nexploit (bsim_E0_star props).\neapply star_trans.\neexact H0.\neexact A.\nauto.\neauto.\nauto.\nintros [i1' [s1' [C D]]].\nexploit (bsim_match_final_states props); eauto.\neapply star_safe; eauto.\nintros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto.\nintros i s1 s3 MS SAFE.\ninv MS.\neapply (bsim_progress props').\neauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto.\napply bb_simulation; auto.\nintros.\ntransitivity (Senv.public_symbol (symbolenv L2) id); eapply bsim_public_preserved; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (S23 : backward_simulation L2 L3) : backward_simulation L1 L3.","conclusion":"backward_simulation L1 L3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (S23 : backward_simulation L2 L3)","proofString":"destruct S23 as [index' order' match_states' props'].\napply Backward_simulation with (bb_order order order') (bb_match_states L1 L2 L3 match_states match_states');  constructor.\nunfold bb_order.\napply wf_lex_ord.\napply wf_clos_trans.\neapply bsim_order_wf; eauto.\neapply bsim_order_wf; eauto.\nintros.\nexploit (bsim_initial_states_exist props); eauto.\nintros [s2 A].\neapply (bsim_initial_states_exist props'); eauto.\nintros s1 s3 INIT1 INIT3.\nexploit (bsim_initial_states_exist props); eauto.\nintros [s2 INIT2].\nexploit (bsim_match_initial_states props'); eauto.\nintros [i2 [s2' [INIT2' M2]]].\nexploit (bsim_match_initial_states props); eauto.\nintros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto.\nintros i s1 s3 r MS SAFE FIN.\ninv MS.\nexploit (bsim_match_final_states props'); eauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto.\nintros [s2' [A B]].\nexploit (bsim_E0_star props).\neapply star_trans.\neexact H0.\neexact A.\nauto.\neauto.\nauto.\nintros [i1' [s1' [C D]]].\nexploit (bsim_match_final_states props); eauto.\neapply star_safe; eauto.\nintros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto.\nintros i s1 s3 MS SAFE.\ninv MS.\neapply (bsim_progress props').\neauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto.\napply bb_simulation; auto.\nintros.\ntransitivity (Senv.public_symbol (symbolenv L2) id); eapply bsim_public_preserved; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : backward_simulation L1 L3.","conclusion":"backward_simulation L1 L3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"apply Backward_simulation with (bb_order order order') (bb_match_states L1 L2 L3 match_states match_states');  constructor.\nunfold bb_order.\napply wf_lex_ord.\napply wf_clos_trans.\neapply bsim_order_wf; eauto.\neapply bsim_order_wf; eauto.\nintros.\nexploit (bsim_initial_states_exist props); eauto.\nintros [s2 A].\neapply (bsim_initial_states_exist props'); eauto.\nintros s1 s3 INIT1 INIT3.\nexploit (bsim_initial_states_exist props); eauto.\nintros [s2 INIT2].\nexploit (bsim_match_initial_states props'); eauto.\nintros [i2 [s2' [INIT2' M2]]].\nexploit (bsim_match_initial_states props); eauto.\nintros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto.\nintros i s1 s3 r MS SAFE FIN.\ninv MS.\nexploit (bsim_match_final_states props'); eauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto.\nintros [s2' [A B]].\nexploit (bsim_E0_star props).\neapply star_trans.\neexact H0.\neexact A.\nauto.\neauto.\nauto.\nintros [i1' [s1' [C D]]].\nexploit (bsim_match_final_states props); eauto.\neapply star_safe; eauto.\nintros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto.\nintros i s1 s3 MS SAFE.\ninv MS.\neapply (bsim_progress props').\neauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto.\napply bb_simulation; auto.\nintros.\ntransitivity (Senv.public_symbol (symbolenv L2) id); eapply bsim_public_preserved; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : well_founded (bb_order order order').","conclusion":"well_founded (bb_order order order')","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"unfold bb_order.\napply wf_lex_ord.\napply wf_clos_trans.\neapply bsim_order_wf; eauto.\neapply bsim_order_wf; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : well_founded (lex_ord (clos_trans index order) order').","conclusion":"well_founded (lex_ord (clos_trans index order) order')","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"apply wf_lex_ord.\napply wf_clos_trans.\neapply bsim_order_wf; eauto.\neapply bsim_order_wf; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : well_founded (clos_trans index order).","conclusion":"well_founded (clos_trans index order)","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"apply wf_clos_trans.\neapply bsim_order_wf; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : well_founded order.","conclusion":"well_founded order","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"eapply bsim_order_wf; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : well_founded order'.","conclusion":"well_founded order'","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"eapply bsim_order_wf; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : forall s1 : state L1,\ninitial_state L1 s1 -> exists s2 : state L3, initial_state L3 s2.","conclusion":"forall s1 : state L1,\ninitial_state L1 s1 -> exists s2 : state L3, initial_state L3 s2","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"intros.\nexploit (bsim_initial_states_exist props); eauto.\nintros [s2 A].\neapply (bsim_initial_states_exist props'); eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (H : initial_state L1 s1) : exists s2 : state L3, initial_state L3 s2.","conclusion":"exists s2 : state L3, initial_state L3 s2","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (H : initial_state L1 s1)","proofString":"exploit (bsim_initial_states_exist props); eauto.\nintros [s2 A].\neapply (bsim_initial_states_exist props'); eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (H : initial_state L1 s1) : (exists s2 : state L2, initial_state L2 s2) ->\nexists s2 : state L3, initial_state L3 s2.","conclusion":"(exists s2 : state L2, initial_state L2 s2) ->\nexists s2 : state L3, initial_state L3 s2","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (H : initial_state L1 s1)","proofString":"intros [s2 A].\neapply (bsim_initial_states_exist props'); eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) : exists s0 : state L3, initial_state L3 s0.","conclusion":"exists s0 : state L3, initial_state L3 s0","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2)","proofString":"eapply (bsim_initial_states_exist props'); eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : forall (s1 : state L1) (s2 : state L3),\ninitial_state L1 s1 ->\ninitial_state L3 s2 ->\nexists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s2.","conclusion":"forall (s1 : state L1) (s2 : state L3),\ninitial_state L1 s1 ->\ninitial_state L3 s2 ->\nexists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s2","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"intros s1 s3 INIT1 INIT3.\nexploit (bsim_initial_states_exist props); eauto.\nintros [s2 INIT2].\nexploit (bsim_match_initial_states props'); eauto.\nintros [i2 [s2' [INIT2' M2]]].\nexploit (bsim_match_initial_states props); eauto.\nintros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) : exists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3.","conclusion":"exists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3)","proofString":"exploit (bsim_initial_states_exist props); eauto.\nintros [s2 INIT2].\nexploit (bsim_match_initial_states props'); eauto.\nintros [i2 [s2' [INIT2' M2]]].\nexploit (bsim_match_initial_states props); eauto.\nintros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) : (exists s2 : state L2, initial_state L2 s2) ->\nexists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3.","conclusion":"(exists s2 : state L2, initial_state L2 s2) ->\nexists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3)","proofString":"intros [s2 INIT2].\nexploit (bsim_match_initial_states props'); eauto.\nintros [i2 [s2' [INIT2' M2]]].\nexploit (bsim_match_initial_states props); eauto.\nintros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) : exists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3.","conclusion":"exists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2)","proofString":"exploit (bsim_match_initial_states props'); eauto.\nintros [i2 [s2' [INIT2' M2]]].\nexploit (bsim_match_initial_states props); eauto.\nintros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) : (exists (i : index') (s1' : state L2),\n   initial_state L2 s1' /\\ match_states' i s1' s3) ->\nexists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3.","conclusion":"(exists (i : index') (s1' : state L2),\n   initial_state L2 s1' /\\ match_states' i s1' s3) ->\nexists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2)","proofString":"intros [i2 [s2' [INIT2' M2]]].\nexploit (bsim_match_initial_states props); eauto.\nintros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) (i2 : index') (s2' : state L2) (INIT2' : initial_state L2 s2') (M2 : match_states' i2 s2' s3) : exists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3.","conclusion":"exists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) (i2 : index') (s2' : state L2) (INIT2' : initial_state L2 s2') (M2 : match_states' i2 s2' s3)","proofString":"exploit (bsim_match_initial_states props); eauto.\nintros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) (i2 : index') (s2' : state L2) (INIT2' : initial_state L2 s2') (M2 : match_states' i2 s2' s3) : (exists (i : index) (s1' : state L1),\n   initial_state L1 s1' /\\ match_states i s1' s2') ->\nexists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3.","conclusion":"(exists (i : index) (s1' : state L1),\n   initial_state L1 s1' /\\ match_states i s1' s2') ->\nexists (i : index * index') (s1' : state L1),\n  initial_state L1 s1' /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1' s3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) (i2 : index') (s2' : state L2) (INIT2' : initial_state L2 s2') (M2 : match_states' i2 s2' s3)","proofString":"intros [i1 [s1' [INIT1' M1]]].\nexists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) (i2 : index') (s2' : state L2) (INIT2' : initial_state L2 s2') (M2 : match_states' i2 s2' s3) (i1 : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (M1 : match_states i1 s1' s2') : exists (i : index * index') (s1'0 : state L1),\n  initial_state L1 s1'0 /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1'0 s3.","conclusion":"exists (i : index * index') (s1'0 : state L1),\n  initial_state L1 s1'0 /\\\n  bb_match_states L1 L2 L3 match_states match_states' i s1'0 s3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) (i2 : index') (s2' : state L2) (INIT2' : initial_state L2 s2') (M2 : match_states' i2 s2' s3) (i1 : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (M1 : match_states i1 s1' s2')","proofString":"exists (i1, i2); exists s1'; intuition auto.\neapply bb_match_at; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) (i2 : index') (s2' : state L2) (INIT2' : initial_state L2 s2') (M2 : match_states' i2 s2' s3) (i1 : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (M1 : match_states i1 s1' s2') : bb_match_states L1 L2 L3 match_states match_states' (i1, i2) s1' s3.","conclusion":"bb_match_states L1 L2 L3 match_states match_states' (i1, i2) s1' s3","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (INIT1 : initial_state L1 s1) (INIT3 : initial_state L3 s3) (s2 : state L2) (INIT2 : initial_state L2 s2) (i2 : index') (s2' : state L2) (INIT2' : initial_state L2 s2') (M2 : match_states' i2 s2' s3) (i1 : index) (s1' : state L1) (INIT1' : initial_state L1 s1') (M1 : match_states i1 s1' s2')","proofString":"eapply bb_match_at; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : forall (i : index * index') (s1 : state L1) (s2 : state L3) (r : int),\nbb_match_states L1 L2 L3 match_states match_states' i s1 s2 ->\nsafe L1 s1 ->\nfinal_state L3 s2 r ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"forall (i : index * index') (s1 : state L1) (s2 : state L3) (r : int),\nbb_match_states L1 L2 L3 match_states match_states' i s1 s2 ->\nsafe L1 s1 ->\nfinal_state L3 s2 r ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"intros i s1 s3 r MS SAFE FIN.\ninv MS.\nexploit (bsim_match_final_states props'); eauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto.\nintros [s2' [A B]].\nexploit (bsim_E0_star props).\neapply star_trans.\neexact H0.\neexact A.\nauto.\neauto.\nauto.\nintros [i1' [s1' [C D]]].\nexploit (bsim_match_final_states props); eauto.\neapply star_safe; eauto.\nintros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (i : index * index') (s1 : state L1) (s3 : state L3) (r : int) (MS : bb_match_states L1 L2 L3 match_states match_states' i s1 s3) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (i : index * index') (s1 : state L1) (s3 : state L3) (r : int) (MS : bb_match_states L1 L2 L3 match_states match_states' i s1 s3) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r)","proofString":"inv MS.\nexploit (bsim_match_final_states props'); eauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto.\nintros [s2' [A B]].\nexploit (bsim_E0_star props).\neapply star_trans.\neexact H0.\neexact A.\nauto.\neauto.\nauto.\nintros [i1' [s1' [C D]]].\nexploit (bsim_match_final_states props); eauto.\neapply star_safe; eauto.\nintros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3)","proofString":"exploit (bsim_match_final_states props'); eauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto.\nintros [s2' [A B]].\nexploit (bsim_E0_star props).\neapply star_trans.\neexact H0.\neexact A.\nauto.\neauto.\nauto.\nintros [i1' [s1' [C D]]].\nexploit (bsim_match_final_states props); eauto.\neapply star_safe; eauto.\nintros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) : safe L2 s2y.","conclusion":"safe L2 s2y","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3)","proofString":"eapply star_safe; eauto.\neapply bsim_safe; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) : safe L2 s2x.","conclusion":"safe L2 s2x","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3)","proofString":"eapply bsim_safe; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) : (exists s1' : state L2, Star L2 s2y E0 s1' /\\ final_state L2 s1' r) ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"(exists s1' : state L2, Star L2 s2y E0 s1' /\\ final_state L2 s1' r) ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3)","proofString":"intros [s2' [A B]].\nexploit (bsim_E0_star props).\neapply star_trans.\neexact H0.\neexact A.\nauto.\neauto.\nauto.\nintros [i1' [s1' [C D]]].\nexploit (bsim_match_final_states props); eauto.\neapply star_safe; eauto.\nintros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r)","proofString":"exploit (bsim_E0_star props).\neapply star_trans.\neexact H0.\neexact A.\nauto.\neauto.\nauto.\nintros [i1' [s1' [C D]]].\nexploit (bsim_match_final_states props); eauto.\neapply star_safe; eauto.\nintros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2') : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2')","proofString":"exploit (bsim_match_final_states props); eauto.\neapply star_safe; eauto.\nintros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2') : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2')","proofString":"eapply star_safe; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2') : (exists s1'0 : state L1, Star L1 s1' E0 s1'0 /\\ final_state L1 s1'0 r) ->\nexists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"(exists s1'0 : state L1, Star L1 s1' E0 s1'0 /\\ final_state L1 s1'0 r) ->\nexists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2')","proofString":"intros [s1'' [P Q]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2') (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : final_state L1 s1'' r) : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2') (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : final_state L1 s1'' r)","proofString":"exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2') (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : final_state L1 s1'' r) : Star L1 s1 E0 s1''.","conclusion":"Star L1 s1 E0 s1''","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (r : int) (SAFE : safe L1 s1) (FIN : final_state L3 s3 r) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) (s2' : state L2) (A : Star L2 s2y E0 s2') (B : final_state L2 s2' r) (i1' : index) (s1' : state L1) (C : Star L1 s1 E0 s1') (D : match_states i1' s1' s2') (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : final_state L1 s1'' r)","proofString":"eapply star_trans; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : forall (i : index * index') (s1 : state L1) (s2 : state L3),\nbb_match_states L1 L2 L3 match_states match_states' i s1 s2 ->\nsafe L1 s1 ->\n(exists r : int, final_state L3 s2 r) \\/\n(exists (t : trace) (s2' : state L3), Step L3 s2 t s2').","conclusion":"forall (i : index * index') (s1 : state L1) (s2 : state L3),\nbb_match_states L1 L2 L3 match_states match_states' i s1 s2 ->\nsafe L1 s1 ->\n(exists r : int, final_state L3 s2 r) \\/\n(exists (t : trace) (s2' : state L3), Step L3 s2 t s2')","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"intros i s1 s3 MS SAFE.\ninv MS.\neapply (bsim_progress props').\neauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (i : index * index') (s1 : state L1) (s3 : state L3) (MS : bb_match_states L1 L2 L3 match_states match_states' i s1 s3) (SAFE : safe L1 s1) : (exists r : int, final_state L3 s3 r) \\/\n(exists (t : trace) (s2' : state L3), Step L3 s3 t s2').","conclusion":"(exists r : int, final_state L3 s3 r) \\/\n(exists (t : trace) (s2' : state L3), Step L3 s3 t s2')","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (i : index * index') (s1 : state L1) (s3 : state L3) (MS : bb_match_states L1 L2 L3 match_states match_states' i s1 s3) (SAFE : safe L1 s1)","proofString":"inv MS.\neapply (bsim_progress props').\neauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (SAFE : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) : (exists r : int, final_state L3 s3 r) \\/\n(exists (t : trace) (s2' : state L3), Step L3 s3 t s2').","conclusion":"(exists r : int, final_state L3 s3 r) \\/\n(exists (t : trace) (s2' : state L3), Step L3 s3 t s2')","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (SAFE : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3)","proofString":"eapply (bsim_progress props').\neauto.\neapply star_safe; eauto.\neapply bsim_safe; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (SAFE : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3) : safe L2 s2x.","conclusion":"safe L2 s2x","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (s1 : state L1) (s3 : state L3) (SAFE : safe L1 s1) (i1 : index) (i2 : index') (s2x s2y : state L2) (H : match_states i1 s1 s2x) (H0 : Star L2 s2x E0 s2y) (H1 : match_states' i2 s2y s3)","proofString":"eapply bsim_safe; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : forall (s2 : state L3) (t : trace) (s2' : state L3),\nStep L3 s2 t s2' ->\nforall (i : index * index') (s1 : state L1),\nbb_match_states L1 L2 L3 match_states match_states' i s1 s2 ->\nsafe L1 s1 ->\nexists (i' : index * index') (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order order order' i' i) /\\\n  bb_match_states L1 L2 L3 match_states match_states' i' s1' s2'.","conclusion":"forall (s2 : state L3) (t : trace) (s2' : state L3),\nStep L3 s2 t s2' ->\nforall (i : index * index') (s1 : state L1),\nbb_match_states L1 L2 L3 match_states match_states' i s1 s2 ->\nsafe L1 s1 ->\nexists (i' : index * index') (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ bb_order order order' i' i) /\\\n  bb_match_states L1 L2 L3 match_states match_states' i' s1' s2'","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"apply bb_simulation; auto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') : forall id : AST.ident,\nSenv.public_symbol (symbolenv L3) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L3) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states')","proofString":"intros.\ntransitivity (Senv.public_symbol (symbolenv L2) id); eapply bsim_public_preserved; eauto."},{"statement":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (id : AST.ident) : Senv.public_symbol (symbolenv L3) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"Senv.public_symbol (symbolenv L3) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"(L1 L2 L3 : semantics) (L3single : single_events L3) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (props : bsim_properties L1 L2 index order match_states) (index' : Type) (order' : index' -> index' -> Prop) (match_states' : index' -> state L2 -> state L3 -> Prop) (props' : bsim_properties L2 L3 index' order' match_states') (id : AST.ident)","proofString":"transitivity (Senv.public_symbol (symbolenv L2) id); eapply bsim_public_preserved; eauto."},{"statement":"(i0 : index) : (fun i : index =>\n forall (s1 : state L1) (s2 : state L2),\n match_states i s1 s2 -> safe L1 s1 -> f2b_transitions s1 s2) i0.","conclusion":"(fun i : index =>\n forall (s1 : state L1) (s2 : state L2),\n match_states i s1 s2 -> safe L1 s1 -> f2b_transitions s1 s2) i0","hypotheses":"(i0 : index)","proofString":"apply well_founded_ind with (R := order).\neapply fsim_order_wf; eauto.\nintros i REC s1 s2 MATCH SAFE.\ndestruct (SAFE s1) as [[r FINAL] | [t [s1' STEP1]]].\napply star_refl.\neapply f2b_trans_final; eauto.\napply star_refl.\neapply fsim_match_final_states; eauto.\nexploit (fsim_simulation FS); eauto.\nintros [i' [s2' [A MATCH']]].\nassert (B: Plus L2 s2 t s2' \\/ (s2' = s2 /\\ t = E0 /\\ order i' i)).\nintuition auto.\ndestruct (star_inv H0); intuition auto.\nclear A.\ndestruct B as [PLUS2 | [EQ1 [EQ2 ORDER]]].\neapply f2b_trans_step; eauto.\napply star_refl.\nsubst.\nexploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 : index) : well_founded order.","conclusion":"well_founded order","hypotheses":"(i0 : index)","proofString":"eapply fsim_order_wf; eauto."},{"statement":"(i0 : index) : forall x : index,\n(forall y : index,\n order y x ->\n forall (s1 : state L1) (s2 : state L2),\n match_states y s1 s2 -> safe L1 s1 -> f2b_transitions s1 s2) ->\nforall (s1 : state L1) (s2 : state L2),\nmatch_states x s1 s2 -> safe L1 s1 -> f2b_transitions s1 s2.","conclusion":"forall x : index,\n(forall y : index,\n order y x ->\n forall (s1 : state L1) (s2 : state L2),\n match_states y s1 s2 -> safe L1 s1 -> f2b_transitions s1 s2) ->\nforall (s1 : state L1) (s2 : state L2),\nmatch_states x s1 s2 -> safe L1 s1 -> f2b_transitions s1 s2","hypotheses":"(i0 : index)","proofString":"intros i REC s1 s2 MATCH SAFE.\ndestruct (SAFE s1) as [[r FINAL] | [t [s1' STEP1]]].\napply star_refl.\neapply f2b_trans_final; eauto.\napply star_refl.\neapply fsim_match_final_states; eauto.\nexploit (fsim_simulation FS); eauto.\nintros [i' [s2' [A MATCH']]].\nassert (B: Plus L2 s2 t s2' \\/ (s2' = s2 /\\ t = E0 /\\ order i' i)).\nintuition auto.\ndestruct (star_inv H0); intuition auto.\nclear A.\ndestruct B as [PLUS2 | [EQ1 [EQ2 ORDER]]].\neapply f2b_trans_step; eauto.\napply star_refl.\nsubst.\nexploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1)","proofString":"destruct (SAFE s1) as [[r FINAL] | [t [s1' STEP1]]].\napply star_refl.\neapply f2b_trans_final; eauto.\napply star_refl.\neapply fsim_match_final_states; eauto.\nexploit (fsim_simulation FS); eauto.\nintros [i' [s2' [A MATCH']]].\nassert (B: Plus L2 s2 t s2' \\/ (s2' = s2 /\\ t = E0 /\\ order i' i)).\nintuition auto.\ndestruct (star_inv H0); intuition auto.\nclear A.\ndestruct B as [PLUS2 | [EQ1 [EQ2 ORDER]]].\neapply f2b_trans_step; eauto.\napply star_refl.\nsubst.\nexploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1)","proofString":"apply star_refl."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (r : int) (FINAL : final_state L1 s1 r) : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (r : int) (FINAL : final_state L1 s1 r)","proofString":"eapply f2b_trans_final; eauto.\napply star_refl.\neapply fsim_match_final_states; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (r : int) (FINAL : final_state L1 s1 r) : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (r : int) (FINAL : final_state L1 s1 r)","proofString":"apply star_refl."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (r : int) (FINAL : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (r : int) (FINAL : final_state L1 s1 r)","proofString":"eapply fsim_match_final_states; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1')","proofString":"exploit (fsim_simulation FS); eauto.\nintros [i' [s2' [A MATCH']]].\nassert (B: Plus L2 s2 t s2' \\/ (s2' = s2 /\\ t = E0 /\\ order i' i)).\nintuition auto.\ndestruct (star_inv H0); intuition auto.\nclear A.\ndestruct B as [PLUS2 | [EQ1 [EQ2 ORDER]]].\neapply f2b_trans_step; eauto.\napply star_refl.\nsubst.\nexploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') : (exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   match_states i' s1' s2') -> f2b_transitions s1 s2.","conclusion":"(exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   match_states i' s1' s2') -> f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1')","proofString":"intros [i' [s2' [A MATCH']]].\nassert (B: Plus L2 s2 t s2' \\/ (s2' = s2 /\\ t = E0 /\\ order i' i)).\nintuition auto.\ndestruct (star_inv H0); intuition auto.\nclear A.\ndestruct B as [PLUS2 | [EQ1 [EQ2 ORDER]]].\neapply f2b_trans_step; eauto.\napply star_refl.\nsubst.\nexploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (MATCH' : match_states i' s1' s2') : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (MATCH' : match_states i' s1' s2')","proofString":"assert (B: Plus L2 s2 t s2' \\/ (s2' = s2 /\\ t = E0 /\\ order i' i)).\nintuition auto.\ndestruct (star_inv H0); intuition auto.\nclear A.\ndestruct B as [PLUS2 | [EQ1 [EQ2 ORDER]]].\neapply f2b_trans_step; eauto.\napply star_refl.\nsubst.\nexploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (MATCH' : match_states i' s1' s2') : Plus L2 s2 t s2' \\/ s2' = s2 /\\ t = E0 /\\ order i' i.","conclusion":"Plus L2 s2 t s2' \\/ s2' = s2 /\\ t = E0 /\\ order i' i","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (MATCH' : match_states i' s1' s2')","proofString":"intuition auto.\ndestruct (star_inv H0); intuition auto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (H0 : Star L2 s2 t s2') (H1 : order i' i) : Plus L2 s2 t s2' \\/ s2' = s2 /\\ t = E0 /\\ order i' i.","conclusion":"Plus L2 s2 t s2' \\/ s2' = s2 /\\ t = E0 /\\ order i' i","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (H0 : Star L2 s2 t s2') (H1 : order i' i)","proofString":"destruct (star_inv H0); intuition auto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (MATCH' : match_states i' s1' s2') (B : Plus L2 s2 t s2' \\/ s2' = s2 /\\ t = E0 /\\ order i' i) : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (MATCH' : match_states i' s1' s2') (B : Plus L2 s2 t s2' \\/ s2' = s2 /\\ t = E0 /\\ order i' i)","proofString":"clear A.\ndestruct B as [PLUS2 | [EQ1 [EQ2 ORDER]]].\neapply f2b_trans_step; eauto.\napply star_refl.\nsubst.\nexploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (B : Plus L2 s2 t s2' \\/ s2' = s2 /\\ t = E0 /\\ order i' i) : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (B : Plus L2 s2 t s2' \\/ s2' = s2 /\\ t = E0 /\\ order i' i)","proofString":"destruct B as [PLUS2 | [EQ1 [EQ2 ORDER]]].\neapply f2b_trans_step; eauto.\napply star_refl.\nsubst.\nexploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (PLUS2 : Plus L2 s2 t s2') : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (PLUS2 : Plus L2 s2 t s2')","proofString":"eapply f2b_trans_step; eauto.\napply star_refl."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (PLUS2 : Plus L2 s2 t s2') : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (PLUS2 : Plus L2 s2 t s2')","proofString":"apply star_refl."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (EQ1 : s2' = s2) (EQ2 : t = E0) (ORDER : order i' i) : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (t : trace) (s1' : state L1) (STEP1 : Step L1 s1 t s1') (i' : index) (s2' : state L2) (MATCH' : match_states i' s1' s2') (EQ1 : s2' = s2) (EQ2 : t = E0) (ORDER : order i' i)","proofString":"subst.\nexploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i)","proofString":"exploit REC; eauto.\neapply star_safe; eauto.\napply star_one; auto.\nintros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i)","proofString":"eapply star_safe; eauto.\napply star_one; auto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) : Star L1 s1 E0 s1'.","conclusion":"Star L1 s1 E0 s1'","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i)","proofString":"apply star_one; auto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) : f2b_transitions s1' s2 -> f2b_transitions s1 s2.","conclusion":"f2b_transitions s1' s2 -> f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i)","proofString":"intros TRANS; inv TRANS.\neapply f2b_trans_final; eauto.\neapply star_left; eauto.\neapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) (s1'0 : state L1) (r : int) (H : Star L1 s1' E0 s1'0) (H0 : final_state L1 s1'0 r) (H1 : final_state L2 s2 r) : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) (s1'0 : state L1) (r : int) (H : Star L1 s1' E0 s1'0) (H0 : final_state L1 s1'0 r) (H1 : final_state L2 s2 r)","proofString":"eapply f2b_trans_final; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) (s1'0 : state L1) (r : int) (H : Star L1 s1' E0 s1'0) (H0 : final_state L1 s1'0 r) (H1 : final_state L2 s2 r) : Star L1 s1 E0 s1'0.","conclusion":"Star L1 s1 E0 s1'0","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) (s1'0 : state L1) (r : int) (H : Star L1 s1' E0 s1'0) (H0 : final_state L1 s1'0 r) (H1 : final_state L2 s2 r)","proofString":"eapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) (s1'0 : state L1) (t : trace) (s1'' : state L1) (s2' : state L2) (i'0 i'' : index) (H : Star L1 s1' E0 s1'0) (H0 : Step L1 s1'0 t s1'') (H1 : Plus L2 s2 t s2') (H2 : match_states i'0 s1'0 s2) (H3 : match_states i'' s1'' s2') : f2b_transitions s1 s2.","conclusion":"f2b_transitions s1 s2","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) (s1'0 : state L1) (t : trace) (s1'' : state L1) (s2' : state L2) (i'0 i'' : index) (H : Star L1 s1' E0 s1'0) (H0 : Step L1 s1'0 t s1'') (H1 : Plus L2 s2 t s2') (H2 : match_states i'0 s1'0 s2) (H3 : match_states i'' s1'' s2')","proofString":"eapply f2b_trans_step; eauto.\neapply star_left; eauto."},{"statement":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) (s1'0 : state L1) (t : trace) (s1'' : state L1) (s2' : state L2) (i'0 i'' : index) (H : Star L1 s1' E0 s1'0) (H0 : Step L1 s1'0 t s1'') (H1 : Plus L2 s2 t s2') (H2 : match_states i'0 s1'0 s2) (H3 : match_states i'' s1'' s2') : Star L1 s1 E0 s1'0.","conclusion":"Star L1 s1 E0 s1'0","hypotheses":"(i0 i : index) (REC : forall y : index,\norder y i ->\nforall (s0 : state L1) (s3 : state L2),\nmatch_states y s0 s3 -> safe L1 s0 -> f2b_transitions s0 s3) (s1 : state L1) (s2 : state L2) (MATCH : match_states i s1 s2) (SAFE : safe L1 s1) (s1' : state L1) (STEP1 : Step L1 s1 E0 s1') (i' : index) (MATCH' : match_states i' s1' s2) (ORDER : order i' i) (s1'0 : state L1) (t : trace) (s1'' : state L1) (s2' : state L2) (i'0 i'' : index) (H : Star L1 s1' E0 s1'0) (H0 : Step L1 s1'0 t s1'') (H1 : Plus L2 s2 t s2') (H2 : match_states i'0 s1'0 s2) (H3 : match_states i'' s1'' s2')","proofString":"eapply star_left; eauto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) : exists (i' : index) (s2' : state L2),\n  Plus L2 s2 t s2' /\\ match_states i' s1' s2'.","conclusion":"exists (i' : index) (s2' : state L2),\n  Plus L2 s2 t s2' /\\ match_states i' s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2)","proofString":"exploit (fsim_simulation FS); eauto.\nintros [i' [s2' [A B]]].\nexists i'; exists s2'; split; auto.\ndestruct A.\nauto.\ndestruct H2.\nexploit star_inv; eauto.\nintros [[EQ1 EQ2] | P]; auto.\ncongruence."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) : (exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   match_states i' s1' s2') ->\nexists (i' : index) (s2' : state L2),\n  Plus L2 s2 t s2' /\\ match_states i' s1' s2'.","conclusion":"(exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n   match_states i' s1' s2') ->\nexists (i' : index) (s2' : state L2),\n  Plus L2 s2 t s2' /\\ match_states i' s1' s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2)","proofString":"intros [i' [s2' [A B]]].\nexists i'; exists s2'; split; auto.\ndestruct A.\nauto.\ndestruct H2.\nexploit star_inv; eauto.\nintros [[EQ1 EQ2] | P]; auto.\ncongruence."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : match_states i' s1' s2') : exists (i'0 : index) (s2'0 : state L2),\n  Plus L2 s2 t s2'0 /\\ match_states i'0 s1' s2'0.","conclusion":"exists (i'0 : index) (s2'0 : state L2),\n  Plus L2 s2 t s2'0 /\\ match_states i'0 s1' s2'0","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : match_states i' s1' s2')","proofString":"exists i'; exists s2'; split; auto.\ndestruct A.\nauto.\ndestruct H2.\nexploit star_inv; eauto.\nintros [[EQ1 EQ2] | P]; auto.\ncongruence."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : match_states i' s1' s2') : Plus L2 s2 t s2'.","conclusion":"Plus L2 s2 t s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) (B : match_states i' s1' s2')","proofString":"destruct A.\nauto.\ndestruct H2.\nexploit star_inv; eauto.\nintros [[EQ1 EQ2] | P]; auto.\ncongruence."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Plus L2 s2 t s2') (B : match_states i' s1' s2') : Plus L2 s2 t s2'.","conclusion":"Plus L2 s2 t s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Plus L2 s2 t s2') (B : match_states i' s1' s2')","proofString":"auto."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Star L2 s2 t s2' /\\ order i' i) (B : match_states i' s1' s2') : Plus L2 s2 t s2'.","conclusion":"Plus L2 s2 t s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Star L2 s2 t s2' /\\ order i' i) (B : match_states i' s1' s2')","proofString":"destruct H2.\nexploit star_inv; eauto.\nintros [[EQ1 EQ2] | P]; auto.\ncongruence."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Star L2 s2 t s2') (H3 : order i' i) (B : match_states i' s1' s2') : Plus L2 s2 t s2'.","conclusion":"Plus L2 s2 t s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Star L2 s2 t s2') (H3 : order i' i) (B : match_states i' s1' s2')","proofString":"exploit star_inv; eauto.\nintros [[EQ1 EQ2] | P]; auto.\ncongruence."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Star L2 s2 t s2') (H3 : order i' i) (B : match_states i' s1' s2') : s2' = s2 /\\ t = E0 \\/ Plus L2 s2 t s2' -> Plus L2 s2 t s2'.","conclusion":"s2' = s2 /\\ t = E0 \\/ Plus L2 s2 t s2' -> Plus L2 s2 t s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Star L2 s2 t s2') (H3 : order i' i) (B : match_states i' s1' s2')","proofString":"intros [[EQ1 EQ2] | P]; auto.\ncongruence."},{"statement":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Star L2 s2 t s2') (H3 : order i' i) (B : match_states i' s1' s2') (EQ1 : s2' = s2) (EQ2 : t = E0) : Plus L2 s2 t s2'.","conclusion":"Plus L2 s2 t s2'","hypotheses":"(s1 : state L1) (t : trace) (s1' : state L1) (H : Step L1 s1 t s1') (H0 : t <> E0) (i : index) (s2 : state L2) (H1 : match_states i s1 s2) (i' : index) (s2' : state L2) (H2 : Star L2 s2 t s2') (H3 : order i' i) (B : match_states i' s1' s2') (EQ1 : s2' = s2) (EQ2 : t = E0)","proofString":"congruence."},{"statement":"(t1 t2 : trace) (H : (Datatypes.length (t1 ++ t2) <= 1)%nat) : t1 = nil \\/ t2 = nil.","conclusion":"t1 = nil \\/ t2 = nil","hypotheses":"(t1 t2 : trace) (H : (Datatypes.length (t1 ++ t2) <= 1)%nat)","proofString":"rewrite app_length in H.\ndestruct t1; destruct t2; auto.\nsimpl in H.\nextlia."},{"statement":"(t1 t2 : trace) (H : (Datatypes.length t1 + Datatypes.length t2 <= 1)%nat) : t1 = nil \\/ t2 = nil.","conclusion":"t1 = nil \\/ t2 = nil","hypotheses":"(t1 t2 : trace) (H : (Datatypes.length t1 + Datatypes.length t2 <= 1)%nat)","proofString":"destruct t1; destruct t2; auto.\nsimpl in H.\nextlia."},{"statement":"(e : event) (t1 : list event) (e0 : event) (t2 : list event) (H : (Datatypes.length (e :: t1) + Datatypes.length (e0 :: t2) <= 1)%nat) : e :: t1 = nil \\/ e0 :: t2 = nil.","conclusion":"e :: t1 = nil \\/ e0 :: t2 = nil","hypotheses":"(e : event) (t1 : list event) (e0 : event) (t2 : list event) (H : (Datatypes.length (e :: t1) + Datatypes.length (e0 :: t2) <= 1)%nat)","proofString":"simpl in H.\nextlia."},{"statement":"(e : event) (t1 : list event) (e0 : event) (t2 : list event) (H : (S (Datatypes.length t1 + S (Datatypes.length t2)) <= 1)%nat) : e :: t1 = nil \\/ e0 :: t2 = nil.","conclusion":"e :: t1 = nil \\/ e0 :: t2 = nil","hypotheses":"(e : event) (t1 : list event) (e0 : event) (t2 : list event) (H : (S (Datatypes.length t1 + S (Datatypes.length t2)) <= 1)%nat)","proofString":"extlia."},{"statement":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') : t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''.","conclusion":"t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''","hypotheses":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'')","proofString":"assert (match_traces (symbolenv L2) t' t'').\neapply sd_determ_1; eauto.\ndestruct (silent_or_not_silent t').\nsubst.\ninv H1.\nleft; intuition.\neapply sd_determ_2; eauto.\ndestruct (silent_or_not_silent t'').\nsubst.\ninv H1.\nelim H2; auto.\nright; intuition.\neapply match_traces_preserved with (ge1 := (symbolenv L2)); auto.\nintros; symmetry; apply (fsim_public_preserved FS)."},{"statement":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') : match_traces (symbolenv L2) t' t''.","conclusion":"match_traces (symbolenv L2) t' t''","hypotheses":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'')","proofString":"eapply sd_determ_1; eauto."},{"statement":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') : t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''.","conclusion":"t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''","hypotheses":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'')","proofString":"destruct (silent_or_not_silent t').\nsubst.\ninv H1.\nleft; intuition.\neapply sd_determ_2; eauto.\ndestruct (silent_or_not_silent t'').\nsubst.\ninv H1.\nelim H2; auto.\nright; intuition.\neapply match_traces_preserved with (ge1 := (symbolenv L2)); auto.\nintros; symmetry; apply (fsim_public_preserved FS)."},{"statement":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' = E0) : t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''.","conclusion":"t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''","hypotheses":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' = E0)","proofString":"subst.\ninv H1.\nleft; intuition.\neapply sd_determ_2; eauto."},{"statement":"(s2 s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 E0 s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) E0 t'') : E0 = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nE0 <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) E0 t''.","conclusion":"E0 = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nE0 <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) E0 t''","hypotheses":"(s2 s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 E0 s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) E0 t'')","proofString":"inv H1.\nleft; intuition.\neapply sd_determ_2; eauto."},{"statement":"(s2 s2' s2'' : state L2) (H : Step L2 s2 E0 s2') (H0 : Step L2 s2 nil s2'') : E0 = E0 /\\ nil = E0 /\\ s2' = s2'' \\/\nE0 <> E0 /\\ nil <> E0 /\\ match_traces (symbolenv L1) E0 nil.","conclusion":"E0 = E0 /\\ nil = E0 /\\ s2' = s2'' \\/\nE0 <> E0 /\\ nil <> E0 /\\ match_traces (symbolenv L1) E0 nil","hypotheses":"(s2 s2' s2'' : state L2) (H : Step L2 s2 E0 s2') (H0 : Step L2 s2 nil s2'')","proofString":"left; intuition.\neapply sd_determ_2; eauto."},{"statement":"(s2 s2' s2'' : state L2) (H : Step L2 s2 E0 s2') (H0 : Step L2 s2 nil s2'') : s2' = s2''.","conclusion":"s2' = s2''","hypotheses":"(s2 s2' s2'' : state L2) (H : Step L2 s2 E0 s2') (H0 : Step L2 s2 nil s2'')","proofString":"eapply sd_determ_2; eauto."},{"statement":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' <> E0) : t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''.","conclusion":"t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''","hypotheses":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' <> E0)","proofString":"destruct (silent_or_not_silent t'').\nsubst.\ninv H1.\nelim H2; auto.\nright; intuition.\neapply match_traces_preserved with (ge1 := (symbolenv L2)); auto.\nintros; symmetry; apply (fsim_public_preserved FS)."},{"statement":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' <> E0) (H3 : t'' = E0) : t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''.","conclusion":"t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''","hypotheses":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' <> E0) (H3 : t'' = E0)","proofString":"subst.\ninv H1.\nelim H2; auto."},{"statement":"(s2 : state L2) (t' : trace) (s2' s2'' : state L2) (H : Step L2 s2 t' s2') (H1 : match_traces (symbolenv L2) t' E0) (H0 : Step L2 s2 E0 s2'') (H2 : t' <> E0) : t' = E0 /\\ E0 = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ E0 <> E0 /\\ match_traces (symbolenv L1) t' E0.","conclusion":"t' = E0 /\\ E0 = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ E0 <> E0 /\\ match_traces (symbolenv L1) t' E0","hypotheses":"(s2 : state L2) (t' : trace) (s2' s2'' : state L2) (H : Step L2 s2 t' s2') (H1 : match_traces (symbolenv L2) t' E0) (H0 : Step L2 s2 E0 s2'') (H2 : t' <> E0)","proofString":"inv H1.\nelim H2; auto."},{"statement":"(s2 s2' s2'' : state L2) (H : Step L2 s2 nil s2') (H0 : Step L2 s2 E0 s2'') (H2 : nil <> E0) : nil = E0 /\\ E0 = E0 /\\ s2' = s2'' \\/\nnil <> E0 /\\ E0 <> E0 /\\ match_traces (symbolenv L1) nil E0.","conclusion":"nil = E0 /\\ E0 = E0 /\\ s2' = s2'' \\/\nnil <> E0 /\\ E0 <> E0 /\\ match_traces (symbolenv L1) nil E0","hypotheses":"(s2 s2' s2'' : state L2) (H : Step L2 s2 nil s2') (H0 : Step L2 s2 E0 s2'') (H2 : nil <> E0)","proofString":"elim H2; auto."},{"statement":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' <> E0) (H3 : t'' <> E0) : t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''.","conclusion":"t' = E0 /\\ t'' = E0 /\\ s2' = s2'' \\/\nt' <> E0 /\\ t'' <> E0 /\\ match_traces (symbolenv L1) t' t''","hypotheses":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' <> E0) (H3 : t'' <> E0)","proofString":"right; intuition.\neapply match_traces_preserved with (ge1 := (symbolenv L2)); auto.\nintros; symmetry; apply (fsim_public_preserved FS)."},{"statement":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' = E0 -> False) (H3 : t'' = E0 -> False) : match_traces (symbolenv L1) t' t''.","conclusion":"match_traces (symbolenv L1) t' t''","hypotheses":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' = E0 -> False) (H3 : t'' = E0 -> False)","proofString":"eapply match_traces_preserved with (ge1 := (symbolenv L2)); auto.\nintros; symmetry; apply (fsim_public_preserved FS)."},{"statement":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' = E0 -> False) (H3 : t'' = E0 -> False) : forall id : AST.ident,\nSenv.public_symbol (symbolenv L1) id = Senv.public_symbol (symbolenv L2) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L1) id = Senv.public_symbol (symbolenv L2) id","hypotheses":"(s2 : state L2) (t' : trace) (s2' : state L2) (t'' : trace) (s2'' : state L2) (H : Step L2 s2 t' s2') (H0 : Step L2 s2 t'' s2'') (H1 : match_traces (symbolenv L2) t' t'') (H2 : t' = E0 -> False) (H3 : t'' = E0 -> False)","proofString":"intros; symmetry; apply (fsim_public_preserved FS)."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) : forall (t : trace) (s2 s3 : state L2),\nStep L2 s01 t s2 -> t <> E0 -> Star L2 s0 t s3 -> Star L2 s01 t s3.","conclusion":"forall (t : trace) (s2 s3 : state L2),\nStep L2 s01 t s2 -> t <> E0 -> Star L2 s0 t s3 -> Star L2 s01 t s3","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01)","proofString":"pattern s0, s01.\neapply star_E0_ind; eauto.\nintros.\ninv H3.\ncongruence.\nexploit f2b_determinacy_inv.\neexact H.\neexact H4.\nintros [[EQ1 [EQ2 EQ3]] | [NEQ1 [NEQ2 MT]]].\nsubst.\nsimpl in *.\neauto.\ncongruence."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) : (fun s s1 : state L2 =>\n forall (t : trace) (s2 s3 : state L2),\n Step L2 s1 t s2 -> t <> E0 -> Star L2 s t s3 -> Star L2 s1 t s3) s0 s01.","conclusion":"(fun s s1 : state L2 =>\n forall (t : trace) (s2 s3 : state L2),\n Step L2 s1 t s2 -> t <> E0 -> Star L2 s t s3 -> Star L2 s1 t s3) s0 s01","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01)","proofString":"eapply star_E0_ind; eauto.\nintros.\ninv H3.\ncongruence.\nexploit f2b_determinacy_inv.\neexact H.\neexact H4.\nintros [[EQ1 [EQ2 EQ3]] | [NEQ1 [NEQ2 MT]]].\nsubst.\nsimpl in *.\neauto.\ncongruence."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) : forall s1 s2 s3 : state L2,\nStep L2 s1 E0 s2 ->\n(forall (t : trace) (s4 s5 : state L2),\n Step L2 s3 t s4 -> t <> E0 -> Star L2 s2 t s5 -> Star L2 s3 t s5) ->\nforall (t : trace) (s4 s5 : state L2),\nStep L2 s3 t s4 -> t <> E0 -> Star L2 s1 t s5 -> Star L2 s3 t s5.","conclusion":"forall s1 s2 s3 : state L2,\nStep L2 s1 E0 s2 ->\n(forall (t : trace) (s4 s5 : state L2),\n Step L2 s3 t s4 -> t <> E0 -> Star L2 s2 t s5 -> Star L2 s3 t s5) ->\nforall (t : trace) (s4 s5 : state L2),\nStep L2 s3 t s4 -> t <> E0 -> Star L2 s1 t s5 -> Star L2 s3 t s5","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01)","proofString":"intros.\ninv H3.\ncongruence.\nexploit f2b_determinacy_inv.\neexact H.\neexact H4.\nintros [[EQ1 [EQ2 EQ3]] | [NEQ1 [NEQ2 MT]]].\nsubst.\nsimpl in *.\neauto.\ncongruence."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (t0 : trace) (s6 s7 : state L2),\nStep L2 s3 t0 s6 -> t0 <> E0 -> Star L2 s2 t0 s7 -> Star L2 s3 t0 s7) (t : trace) (s4 s5 : state L2) (H1 : Step L2 s3 t s4) (H2 : t <> E0) (H3 : Star L2 s1 t s5) : Star L2 s3 t s5.","conclusion":"Star L2 s3 t s5","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (t0 : trace) (s6 s7 : state L2),\nStep L2 s3 t0 s6 -> t0 <> E0 -> Star L2 s2 t0 s7 -> Star L2 s3 t0 s7) (t : trace) (s4 s5 : state L2) (H1 : Step L2 s3 t s4) (H2 : t <> E0) (H3 : Star L2 s1 t s5)","proofString":"inv H3.\ncongruence.\nexploit f2b_determinacy_inv.\neexact H.\neexact H4.\nintros [[EQ1 [EQ2 EQ3]] | [NEQ1 [NEQ2 MT]]].\nsubst.\nsimpl in *.\neauto.\ncongruence."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s2 s3 s5 : state L2) (H : Step L2 s5 E0 s2) (H0 : forall (t : trace) (s1 s6 : state L2),\nStep L2 s3 t s1 -> t <> E0 -> Star L2 s2 t s6 -> Star L2 s3 t s6) (s4 : state L2) (H2 : E0 <> E0) (H1 : Step L2 s3 E0 s4) : Star L2 s3 E0 s5.","conclusion":"Star L2 s3 E0 s5","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s2 s3 s5 : state L2) (H : Step L2 s5 E0 s2) (H0 : forall (t : trace) (s1 s6 : state L2),\nStep L2 s3 t s1 -> t <> E0 -> Star L2 s2 t s6 -> Star L2 s3 t s6) (s4 : state L2) (H2 : E0 <> E0) (H1 : Step L2 s3 E0 s4)","proofString":"congruence."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (t : trace) (s6 s8 : state L2),\nStep L2 s3 t s6 -> t <> E0 -> Star L2 s2 t s8 -> Star L2 s3 t s8) (s4 s5 : state L2) (t1 t2 : trace) (H2 : t1 ** t2 <> E0) (H1 : Step L2 s3 (t1 ** t2) s4) (s7 : state L2) (H4 : Step L2 s1 t1 s7) (H5 : Star L2 s7 t2 s5) : Star L2 s3 (t1 ** t2) s5.","conclusion":"Star L2 s3 (t1 ** t2) s5","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (t : trace) (s6 s8 : state L2),\nStep L2 s3 t s6 -> t <> E0 -> Star L2 s2 t s8 -> Star L2 s3 t s8) (s4 s5 : state L2) (t1 t2 : trace) (H2 : t1 ** t2 <> E0) (H1 : Step L2 s3 (t1 ** t2) s4) (s7 : state L2) (H4 : Step L2 s1 t1 s7) (H5 : Star L2 s7 t2 s5)","proofString":"exploit f2b_determinacy_inv.\neexact H.\neexact H4.\nintros [[EQ1 [EQ2 EQ3]] | [NEQ1 [NEQ2 MT]]].\nsubst.\nsimpl in *.\neauto.\ncongruence."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (t : trace) (s6 s8 : state L2),\nStep L2 s3 t s6 -> t <> E0 -> Star L2 s2 t s8 -> Star L2 s3 t s8) (s4 s5 : state L2) (t1 t2 : trace) (H2 : t1 ** t2 <> E0) (H1 : Step L2 s3 (t1 ** t2) s4) (s7 : state L2) (H4 : Step L2 s1 t1 s7) (H5 : Star L2 s7 t2 s5) (EQ1 : E0 = E0) (EQ2 : t1 = E0) (EQ3 : s2 = s7) : Star L2 s3 (t1 ** t2) s5.","conclusion":"Star L2 s3 (t1 ** t2) s5","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (t : trace) (s6 s8 : state L2),\nStep L2 s3 t s6 -> t <> E0 -> Star L2 s2 t s8 -> Star L2 s3 t s8) (s4 s5 : state L2) (t1 t2 : trace) (H2 : t1 ** t2 <> E0) (H1 : Step L2 s3 (t1 ** t2) s4) (s7 : state L2) (H4 : Step L2 s1 t1 s7) (H5 : Star L2 s7 t2 s5) (EQ1 : E0 = E0) (EQ2 : t1 = E0) (EQ3 : s2 = s7)","proofString":"subst.\nsimpl in *.\neauto."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s3 s7 : state L2) (H0 : forall (t : trace) (s2 s6 : state L2),\nStep L2 s3 t s2 -> t <> E0 -> Star L2 s7 t s6 -> Star L2 s3 t s6) (H : Step L2 s1 E0 s7) (s4 s5 : state L2) (t2 : trace) (H1 : Step L2 s3 (E0 ** t2) s4) (H2 : E0 ** t2 <> E0) (H4 : Step L2 s1 E0 s7) (H5 : Star L2 s7 t2 s5) (EQ1 : E0 = E0) : Star L2 s3 (E0 ** t2) s5.","conclusion":"Star L2 s3 (E0 ** t2) s5","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s3 s7 : state L2) (H0 : forall (t : trace) (s2 s6 : state L2),\nStep L2 s3 t s2 -> t <> E0 -> Star L2 s7 t s6 -> Star L2 s3 t s6) (H : Step L2 s1 E0 s7) (s4 s5 : state L2) (t2 : trace) (H1 : Step L2 s3 (E0 ** t2) s4) (H2 : E0 ** t2 <> E0) (H4 : Step L2 s1 E0 s7) (H5 : Star L2 s7 t2 s5) (EQ1 : E0 = E0)","proofString":"simpl in *.\neauto."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s3 s7 : state L2) (H0 : forall (t : trace) (s2 s6 : state L2),\nStep L2 s3 t s2 -> t <> E0 -> Star L2 s7 t s6 -> Star L2 s3 t s6) (H : Step L2 s1 E0 s7) (s4 s5 : state L2) (t2 : trace) (H1 : Step L2 s3 t2 s4) (H2 : t2 <> E0) (H4 : Step L2 s1 E0 s7) (H5 : Star L2 s7 t2 s5) (EQ1 : E0 = E0) : Star L2 s3 t2 s5.","conclusion":"Star L2 s3 t2 s5","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s3 s7 : state L2) (H0 : forall (t : trace) (s2 s6 : state L2),\nStep L2 s3 t s2 -> t <> E0 -> Star L2 s7 t s6 -> Star L2 s3 t s6) (H : Step L2 s1 E0 s7) (s4 s5 : state L2) (t2 : trace) (H1 : Step L2 s3 t2 s4) (H2 : t2 <> E0) (H4 : Step L2 s1 E0 s7) (H5 : Star L2 s7 t2 s5) (EQ1 : E0 = E0)","proofString":"eauto."},{"statement":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (t : trace) (s6 s8 : state L2),\nStep L2 s3 t s6 -> t <> E0 -> Star L2 s2 t s8 -> Star L2 s3 t s8) (s4 s5 : state L2) (t1 t2 : trace) (H2 : t1 ** t2 <> E0) (H1 : Step L2 s3 (t1 ** t2) s4) (s7 : state L2) (H4 : Step L2 s1 t1 s7) (H5 : Star L2 s7 t2 s5) (NEQ1 : E0 <> E0) (NEQ2 : t1 <> E0) (MT : match_traces (symbolenv L1) E0 t1) : Star L2 s3 (t1 ** t2) s5.","conclusion":"Star L2 s3 (t1 ** t2) s5","hypotheses":"(s0 s01 : state L2) (ST0 : Star L2 s0 E0 s01) (s1 s2 s3 : state L2) (H : Step L2 s1 E0 s2) (H0 : forall (t : trace) (s6 s8 : state L2),\nStep L2 s3 t s6 -> t <> E0 -> Star L2 s2 t s8 -> Star L2 s3 t s8) (s4 s5 : state L2) (t1 t2 : trace) (H2 : t1 ** t2 <> E0) (H1 : Step L2 s3 (t1 ** t2) s4) (s7 : state L2) (H4 : Step L2 s1 t1 s7) (H5 : Star L2 s7 t2 s5) (NEQ1 : E0 <> E0) (NEQ2 : t1 <> E0) (MT : match_traces (symbolenv L1) E0 t1)","proofString":"congruence."},{"statement":"forall n : nat, Acc f2b_order (F2BI_before n).","conclusion":"forall n : nat, Acc f2b_order (F2BI_before n)","hypotheses":"","proofString":"intros n0; pattern n0; apply lt_wf_ind; intros.\nconstructor; intros.\ninv H0.\nauto."},{"statement":"(n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_before m)) : Acc f2b_order (F2BI_before n).","conclusion":"Acc f2b_order (F2BI_before n)","hypotheses":"(n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_before m))","proofString":"constructor; intros.\ninv H0.\nauto."},{"statement":"(n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_before m)) (y : f2b_index) (H0 : f2b_order y (F2BI_before n)) : Acc f2b_order y.","conclusion":"Acc f2b_order y","hypotheses":"(n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_before m)) (y : f2b_index) (H0 : f2b_order y (F2BI_before n))","proofString":"inv H0.\nauto."},{"statement":"(n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_before m)) (n' : nat) (H3 : (n' < n)%nat) : Acc f2b_order (F2BI_before n').","conclusion":"Acc f2b_order (F2BI_before n')","hypotheses":"(n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_before m)) (n' : nat) (H3 : (n' < n)%nat)","proofString":"auto."},{"statement":"(ACC1 : forall n : nat, Acc f2b_order (F2BI_before n)) : well_founded f2b_order.","conclusion":"well_founded f2b_order","hypotheses":"(ACC1 : forall n : nat, Acc f2b_order (F2BI_before n))","proofString":"assert (ACC2: forall n, Acc f2b_order (F2BI_after n)).\nintros n0; pattern n0; apply lt_wf_ind; intros.\nconstructor; intros.\ninv H0.\nauto.\nauto.\nred; intros.\ndestruct a; auto."},{"statement":"(ACC1 : forall n : nat, Acc f2b_order (F2BI_before n)) : forall n : nat, Acc f2b_order (F2BI_after n).","conclusion":"forall n : nat, Acc f2b_order (F2BI_after n)","hypotheses":"(ACC1 : forall n : nat, Acc f2b_order (F2BI_before n))","proofString":"intros n0; pattern n0; apply lt_wf_ind; intros.\nconstructor; intros.\ninv H0.\nauto.\nauto."},{"statement":"(ACC1 : forall n1 : nat, Acc f2b_order (F2BI_before n1)) (n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_after m)) : Acc f2b_order (F2BI_after n).","conclusion":"Acc f2b_order (F2BI_after n)","hypotheses":"(ACC1 : forall n1 : nat, Acc f2b_order (F2BI_before n1)) (n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_after m))","proofString":"constructor; intros.\ninv H0.\nauto.\nauto."},{"statement":"(ACC1 : forall n1 : nat, Acc f2b_order (F2BI_before n1)) (n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_after m)) (y : f2b_index) (H0 : f2b_order y (F2BI_after n)) : Acc f2b_order y.","conclusion":"Acc f2b_order y","hypotheses":"(ACC1 : forall n1 : nat, Acc f2b_order (F2BI_before n1)) (n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_after m)) (y : f2b_index) (H0 : f2b_order y (F2BI_after n))","proofString":"inv H0.\nauto.\nauto."},{"statement":"(ACC1 : forall n1 : nat, Acc f2b_order (F2BI_before n1)) (n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_after m)) (n' : nat) (H3 : (n' < n)%nat) : Acc f2b_order (F2BI_after n').","conclusion":"Acc f2b_order (F2BI_after n')","hypotheses":"(ACC1 : forall n1 : nat, Acc f2b_order (F2BI_before n1)) (n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_after m)) (n' : nat) (H3 : (n' < n)%nat)","proofString":"auto."},{"statement":"(ACC1 : forall n1 : nat, Acc f2b_order (F2BI_before n1)) (n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_after m)) (n' : nat) : Acc f2b_order (F2BI_before n').","conclusion":"Acc f2b_order (F2BI_before n')","hypotheses":"(ACC1 : forall n1 : nat, Acc f2b_order (F2BI_before n1)) (n0 n : nat) (H : forall m : nat, (m < n)%nat -> Acc f2b_order (F2BI_after m)) (n' : nat)","proofString":"auto."},{"statement":"(ACC1 : forall n : nat, Acc f2b_order (F2BI_before n)) (ACC2 : forall n : nat, Acc f2b_order (F2BI_after n)) : well_founded f2b_order.","conclusion":"well_founded f2b_order","hypotheses":"(ACC1 : forall n : nat, Acc f2b_order (F2BI_before n)) (ACC2 : forall n : nat, Acc f2b_order (F2BI_after n))","proofString":"red; intros.\ndestruct a; auto."},{"statement":"(ACC1 : forall n : nat, Acc f2b_order (F2BI_before n)) (ACC2 : forall n : nat, Acc f2b_order (F2BI_after n)) (a : f2b_index) : Acc f2b_order a.","conclusion":"Acc f2b_order a","hypotheses":"(ACC1 : forall n : nat, Acc f2b_order (F2BI_before n)) (ACC2 : forall n : nat, Acc f2b_order (F2BI_after n)) (a : f2b_index)","proofString":"destruct a; auto."},{"statement":"(n : nat) (s2 s2a : state L2) (s1 : state L1) (i : index) (H : starN (step L2) (globalenv L2) n s2 E0 s2a) (H0 : match_states i s1 s2a) : f2b_match_states (F2BI_after n) s1 s2.","conclusion":"f2b_match_states (F2BI_after n) s1 s2","hypotheses":"(n : nat) (s2 s2a : state L2) (s1 : state L1) (i : index) (H : starN (step L2) (globalenv L2) n s2 E0 s2a) (H0 : match_states i s1 s2a)","proofString":"inv H.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(s2a : state L2) (s1 : state L1) (i : index) (H0 : match_states i s1 s2a) : f2b_match_states (F2BI_after 0) s1 s2a.","conclusion":"f2b_match_states (F2BI_after 0) s1 s2a","hypotheses":"(s2a : state L2) (s1 : state L1) (i : index) (H0 : match_states i s1 s2a)","proofString":"econstructor; eauto."},{"statement":"(s2 s2a : state L2) (s1 : state L1) (i : index) (H0 : match_states i s1 s2a) (n0 : nat) (t1 : trace) (s' : state L2) (t2 : trace) (H1 : Step L2 s2 t1 s') (H2 : starN (step L2) (globalenv L2) n0 s' t2 s2a) (H3 : E0 = t1 ** t2) : f2b_match_states (F2BI_after (S n0)) s1 s2.","conclusion":"f2b_match_states (F2BI_after (S n0)) s1 s2","hypotheses":"(s2 s2a : state L2) (s1 : state L1) (i : index) (H0 : match_states i s1 s2a) (n0 : nat) (t1 : trace) (s' : state L2) (t2 : trace) (H1 : Step L2 s2 t1 s') (H2 : starN (step L2) (globalenv L2) n0 s' t2 s2a) (H3 : E0 = t1 ** t2)","proofString":"econstructor; eauto.\neconstructor; eauto."},{"statement":"(s2 s2a : state L2) (s1 : state L1) (i : index) (H0 : match_states i s1 s2a) (n0 : nat) (t1 : trace) (s' : state L2) (t2 : trace) (H1 : Step L2 s2 t1 s') (H2 : starN (step L2) (globalenv L2) n0 s' t2 s2a) (H3 : E0 = t1 ** t2) : starN (step L2) (globalenv L2) (S n0) s2 E0 s2a.","conclusion":"starN (step L2) (globalenv L2) (S n0) s2 E0 s2a","hypotheses":"(s2 s2a : state L2) (s1 : state L1) (i : index) (H0 : match_states i s1 s2a) (n0 : nat) (t1 : trace) (s' : state L2) (t2 : trace) (H1 : Step L2 s2 t1 s') (H2 : starN (step L2) (globalenv L2) n0 s' t2 s2a) (H3 : E0 = t1 ** t2)","proofString":"econstructor; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (i : f2b_index) (s1 : state L1) (MATCH : f2b_match_states i s1 s2) (SAFE : safe L1 s1) : exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' i) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' i) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (i : f2b_index) (s1 : state L1) (MATCH : f2b_match_states i s1 s2) (SAFE : safe L1 s1)","proofString":"inv MATCH.\nexploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H2.\nexploit f2b_determinacy_inv.\neexact H5.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\ndestruct (silent_or_not_silent t2).\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto.\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst t2.\nrewrite E0_right in H1.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto.\ninv H2.\ncongruence.\nexploit f2b_determinacy_inv.\neexact H4.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\nsubst.\nsimpl in *.\nexists (F2BI_before n0); exists s1; split.\nright; split.\napply star_refl.\nconstructor.\nlia.\neconstructor; eauto.\neapply star_right; eauto.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst.\nrewrite E0_right in *.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\nexploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto.\ninv H.\nexploit Eapp_E0_inv; eauto.\nintros [EQ1 EQ2]; subst.\nexploit f2b_determinacy_inv.\neexact H2.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\nsubst.\nexists (F2BI_after n); exists s1; split.\nright; split.\napply star_refl.\nconstructor; lia.\neapply f2b_match_after'; eauto.\ncongruence."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) : exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after 0)) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after 0)) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2)","proofString":"exploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H2.\nexploit f2b_determinacy_inv.\neexact H5.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\ndestruct (silent_or_not_silent t2).\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto.\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst t2.\nrewrite E0_right in H1.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) : f2b_transitions s1 s2 ->\nexists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after 0)) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"f2b_transitions s1 s2 ->\nexists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after 0)) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2)","proofString":"intros TRANS; inv TRANS.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H2.\nexploit f2b_determinacy_inv.\neexact H5.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\ndestruct (silent_or_not_silent t2).\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto.\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst t2.\nrewrite E0_right in H1.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' : state L1) (r : int) (H0 : Star L1 s1 E0 s1') (H1 : final_state L1 s1' r) (H2 : final_state L2 s2 r) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_after 0)) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_after 0)) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' : state L1) (r : int) (H0 : Star L1 s1 E0 s1') (H1 : final_state L1 s1' r) (H2 : final_state L2 s2 r)","proofString":"exploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' : state L1) (r : int) (H0 : Star L1 s1 E0 s1') (H1 : final_state L1 s1' r) (H2 : final_state L2 s2 r) : False ->\nexists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_after 0)) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"False ->\nexists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_after 0)) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' : state L1) (r : int) (H0 : Star L1 s1 E0 s1') (H1 : final_state L1 s1' r) (H2 : final_state L2 s2 r)","proofString":"contradiction."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' : state L1) (t0 : trace) (s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' t0 s1'') (H2 : Plus L2 s2 t0 s2'0) (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' : state L1) (t0 : trace) (s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' t0 s1'') (H2 : Plus L2 s2 t0 s2'0) (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0)","proofString":"inv H2.\nexploit f2b_determinacy_inv.\neexact H5.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\ndestruct (silent_or_not_silent t2).\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto.\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst t2.\nrewrite E0_right in H1.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0)","proofString":"exploit f2b_determinacy_inv.\neexact H5.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\ndestruct (silent_or_not_silent t2).\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto.\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst t2.\nrewrite E0_right in H1.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (EQ1 : t1 = E0) (EQ2 : t = E0) (EQ3 : s3 = s2') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (EQ1 : t1 = E0) (EQ2 : t = E0) (EQ3 : s3 = s2')","proofString":"destruct (silent_or_not_silent t2).\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto.\nsubst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (EQ1 : t1 = E0) (EQ2 : t = E0) (EQ3 : s3 = s2') (H2 : t2 = E0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (EQ1 : t1 = E0) (EQ2 : t = E0) (EQ3 : s3 = s2') (H2 : t2 = E0)","proofString":"subst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' (E0 ** E0) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' (E0 ** E0) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2')","proofString":"simpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2')","proofString":"destruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2'0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2'0)","proofString":"exists (F2BI_after n); exists s1''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2'0) : Plus L1 s1 E0 s1'' \\/\nStar L1 s1 E0 s1'' /\\ f2b_order (F2BI_after n) (F2BI_after 0).","conclusion":"Plus L1 s1 E0 s1'' \\/\nStar L1 s1 E0 s1'' /\\ f2b_order (F2BI_after n) (F2BI_after 0)","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2'0)","proofString":"left.\neapply plus_right; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2'0) : Plus L1 s1 E0 s1''.","conclusion":"Plus L1 s1 E0 s1''","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2'0)","proofString":"eapply plus_right; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2'0) : f2b_match_states (F2BI_after n) s1'' s2'.","conclusion":"f2b_match_states (F2BI_after n) s1'' s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (H1 : Step L1 s1' E0 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' E0 s2'0) (H5 : Step L2 s2 E0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2'0)","proofString":"eapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (EQ1 : t1 = E0) (EQ2 : t = E0) (EQ3 : s3 = s2') (H2 : t2 <> E0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (EQ1 : t1 = E0) (EQ2 : t = E0) (EQ3 : s3 = s2') (H2 : t2 <> E0)","proofString":"subst.\nsimpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' (E0 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' (E0 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0)","proofString":"simpl in *.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0)","proofString":"destruct (star_starN H6) as [n STEPS2].\nexists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0)","proofString":"exists (F2BI_before n); exists s1'; split.\nright; split.\nauto.\nconstructor.\neconstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0) : Plus L1 s1 E0 s1' \\/\nStar L1 s1 E0 s1' /\\ f2b_order (F2BI_before n) (F2BI_after 0).","conclusion":"Plus L1 s1 E0 s1' \\/\nStar L1 s1 E0 s1' /\\ f2b_order (F2BI_before n) (F2BI_after 0)","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0)","proofString":"right; split.\nauto.\nconstructor."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0) : Star L1 s1 E0 s1'.","conclusion":"Star L1 s1 E0 s1'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0)","proofString":"auto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0) : f2b_order (F2BI_before n) (F2BI_after 0).","conclusion":"f2b_order (F2BI_before n) (F2BI_after 0)","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0)","proofString":"constructor."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0) : f2b_match_states (F2BI_before n) s1' s2'.","conclusion":"f2b_match_states (F2BI_before n) s1' s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t2 : trace) (H1 : Step L1 s1' t2 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (H6 : Star L2 s2' t2 s2'0) (H5 : Step L2 s2 E0 s2') (H2 : t2 <> E0) (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' t2 s2'0)","proofString":"econstructor.\neauto.\nauto.\napply star_one; eauto.\neauto.\neauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t)","proofString":"exploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst t2.\nrewrite E0_right in H1.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) (EQ : t1 = E0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) (EQ : t1 = E0)","proofString":"congruence."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) (EQ : t2 = E0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 t2 : trace) (H1 : Step L1 s1' (t1 ** t2) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t2 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) (EQ : t2 = E0)","proofString":"subst t2.\nrewrite E0_right in H1.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' (t1 ** E0) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' (t1 ** E0) s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t)","proofString":"rewrite E0_right in H1.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t)","proofString":"exploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) : (exists s4 : state L1, Step L1 s1' t s4) ->\nexists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"(exists s4 : state L1, Step L1 s1' t s4) ->\nexists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t)","proofString":"intros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) (s1''' : state L1) (STEP1 : Step L1 s1' t s1''') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) (s1''' : state L1) (STEP1 : Step L1 s1' t s1''')","proofString":"exploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\ninv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) (s1''' : state L1) (STEP1 : Step L1 s1' t s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2 t s2''') (Q : match_states i''' s1''' s2''') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t1 t) (s1''' : state L1) (STEP1 : Step L1 s1' t s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2 t s2''') (Q : match_states i''' s1''' s2''')","proofString":"inv P.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t0 t2 : trace) (STEP2 : Step L2 s2 (t0 ** t2) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (MT : match_traces (symbolenv L1) t1 (t0 ** t2)) (NOT2 : t0 ** t2 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1' (t0 ** t2) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 t2 s2''') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t0 ** t2) s1'0 \\/\n   Star L1 s1 (t0 ** t2) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t0 ** t2) s1'0 \\/\n   Star L1 s1 (t0 ** t2) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 t2 : trace) (STEP2 : Step L2 s2 (t0 ** t2) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (MT : match_traces (symbolenv L1) t1 (t0 ** t2)) (NOT2 : t0 ** t2 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1' (t0 ** t2) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 t2 s2''')","proofString":"exploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto.\nsubst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t0 t2 : trace) (STEP2 : Step L2 s2 (t0 ** t2) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (MT : match_traces (symbolenv L1) t1 (t0 ** t2)) (NOT2 : t0 ** t2 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1' (t0 ** t2) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 t2 s2''') (EQ : t0 = E0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t0 ** t2) s1'0 \\/\n   Star L1 s1 (t0 ** t2) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t0 ** t2) s1'0 \\/\n   Star L1 s1 (t0 ** t2) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 t2 : trace) (STEP2 : Step L2 s2 (t0 ** t2) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (MT : match_traces (symbolenv L1) t1 (t0 ** t2)) (NOT2 : t0 ** t2 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1' (t0 ** t2) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 t2 s2''') (EQ : t0 = E0)","proofString":"subst t0.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto."},{"statement":"(s2 s2' : state L2) (t2 : trace) (STEP2 : Step L2 s2 (E0 ** t2) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : E0 ** t2 <> E0) (MT : match_traces (symbolenv L1) t1 (E0 ** t2)) (s1''' : state L1) (STEP1 : Step L1 s1' (E0 ** t2) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 t2 s2''') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (E0 ** t2) s1'0 \\/\n   Star L1 s1 (E0 ** t2) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (E0 ** t2) s1'0 \\/\n   Star L1 s1 (E0 ** t2) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t2 : trace) (STEP2 : Step L2 s2 (E0 ** t2) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : E0 ** t2 <> E0) (MT : match_traces (symbolenv L1) t1 (E0 ** t2)) (s1''' : state L1) (STEP1 : Step L1 s1' (E0 ** t2) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 t2 s2''')","proofString":"simpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto."},{"statement":"(s2 s2' : state L2) (t2 : trace) (STEP2 : Step L2 s2 t2 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t2 <> E0) (MT : match_traces (symbolenv L1) t1 t2) (s1''' : state L1) (STEP1 : Step L1 s1' t2 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 t2 s2''') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t2 s1'0 \\/ Star L1 s1 t2 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t2 s1'0 \\/ Star L1 s1 t2 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t2 : trace) (STEP2 : Step L2 s2 t2 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t2 <> E0) (MT : match_traces (symbolenv L1) t1 t2) (s1''' : state L1) (STEP1 : Step L1 s1' t2 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 t2 s2''')","proofString":"exploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H8.\nauto."},{"statement":"(s2 s2' : state L2) (t2 : trace) (STEP2 : Step L2 s2 t2 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t2 <> E0) (MT : match_traces (symbolenv L1) t1 t2) (s1''' : state L1) (STEP1 : Step L1 s1' t2 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 t2 s2''') (H8 : match_traces (symbolenv L2) t2 E0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t2 s1'0 \\/ Star L1 s1 t2 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t2 s1'0 \\/ Star L1 s1 t2 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t2 : trace) (STEP2 : Step L2 s2 t2 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t2 <> E0) (MT : match_traces (symbolenv L1) t1 t2) (s1''' : state L1) (STEP1 : Step L1 s1' t2 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 t2 s2''') (H8 : match_traces (symbolenv L2) t2 E0)","proofString":"elim NOT2.\ninv H8.\nauto."},{"statement":"(s2 s2' : state L2) (t2 : trace) (STEP2 : Step L2 s2 t2 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t2 <> E0) (MT : match_traces (symbolenv L1) t1 t2) (s1''' : state L1) (STEP1 : Step L1 s1' t2 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 t2 s2''') (H8 : match_traces (symbolenv L2) t2 E0) : t2 = E0.","conclusion":"t2 = E0","hypotheses":"(s2 s2' : state L2) (t2 : trace) (STEP2 : Step L2 s2 t2 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t2 <> E0) (MT : match_traces (symbolenv L1) t1 t2) (s1''' : state L1) (STEP1 : Step L1 s1' t2 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 t2 s2''') (H8 : match_traces (symbolenv L2) t2 E0)","proofString":"inv H8.\nauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 nil s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (MT : match_traces (symbolenv L1) t1 nil) (NOT2 : nil <> E0) (s1''' : state L1) (STEP1 : Step L1 s1' nil s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 nil s2''') : nil = E0.","conclusion":"nil = E0","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 nil s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (MT : match_traces (symbolenv L1) t1 nil) (NOT2 : nil <> E0) (s1''' : state L1) (STEP1 : Step L1 s1' nil s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 E0 s4) (H7 : Star L2 s4 nil s2''')","proofString":"auto."},{"statement":"(s2 s2' : state L2) (t0 t2 : trace) (STEP2 : Step L2 s2 (t0 ** t2) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (MT : match_traces (symbolenv L1) t1 (t0 ** t2)) (NOT2 : t0 ** t2 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1' (t0 ** t2) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 t2 s2''') (EQ : t2 = E0) : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t0 ** t2) s1'0 \\/\n   Star L1 s1 (t0 ** t2) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t0 ** t2) s1'0 \\/\n   Star L1 s1 (t0 ** t2) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 t2 : trace) (STEP2 : Step L2 s2 (t0 ** t2) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (MT : match_traces (symbolenv L1) t1 (t0 ** t2)) (NOT2 : t0 ** t2 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1' (t0 ** t2) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 t2 s2''') (EQ : t2 = E0)","proofString":"subst t2.\nrewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 (t0 ** E0) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 ** E0 <> E0) (MT : match_traces (symbolenv L1) t1 (t0 ** E0)) (s1''' : state L1) (STEP1 : Step L1 s1' (t0 ** E0) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 E0 s2''') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t0 ** E0) s1'0 \\/\n   Star L1 s1 (t0 ** E0) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t0 ** E0) s1'0 \\/\n   Star L1 s1 (t0 ** E0) s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 (t0 ** E0) s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 ** E0 <> E0) (MT : match_traces (symbolenv L1) t1 (t0 ** E0)) (s1''' : state L1) (STEP1 : Step L1 s1' (t0 ** E0) s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 E0 s2''')","proofString":"rewrite E0_right in *.\nassert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 E0 s2''') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/ Star L1 s1 t0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/ Star L1 s1 t0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 E0 s2''')","proofString":"assert (s4 = s2').\neapply sd_determ_2; eauto.\nsubst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 E0 s2''') : s4 = s2'.","conclusion":"s4 = s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 E0 s2''')","proofString":"eapply sd_determ_2; eauto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 E0 s2''') (H8 : s4 = s2') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/ Star L1 s1 t0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/ Star L1 s1 t0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (s4 : state L2) (H2 : Step L2 s2 t0 s4) (H7 : Star L2 s4 E0 s2''') (H8 : s4 = s2')","proofString":"subst s4.\ndestruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/ Star L1 s1 t0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/ Star L1 s1 t0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2')","proofString":"destruct (star_starN H7) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''') : exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/ Star L1 s1 t0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'.","conclusion":"exists (i'0 : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/ Star L1 s1 t0 s1'0 /\\ f2b_order i'0 (F2BI_after 0)) /\\\n  f2b_match_states i'0 s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''')","proofString":"exists (F2BI_after n); exists s1'''; split.\nleft.\neapply plus_right; eauto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''') : Plus L1 s1 t0 s1''' \\/\nStar L1 s1 t0 s1''' /\\ f2b_order (F2BI_after n) (F2BI_after 0).","conclusion":"Plus L1 s1 t0 s1''' \\/\nStar L1 s1 t0 s1''' /\\ f2b_order (F2BI_after n) (F2BI_after 0)","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''')","proofString":"left.\neapply plus_right; eauto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''') : Plus L1 s1 t0 s1'''.","conclusion":"Plus L1 s1 t0 s1'''","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''')","proofString":"eapply plus_right; eauto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''') : f2b_match_states (F2BI_after n) s1''' s2'.","conclusion":"f2b_match_states (F2BI_after n) s1''' s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (i0 : index) (H : match_states i0 s1 s2) (s1' s1'' : state L1) (s2'0 : state L2) (i' i'' : index) (H0 : Star L1 s1 E0 s1') (t1 : trace) (H1 : Step L1 s1' t1 s1'') (H3 : match_states i' s1' s2) (H4 : match_states i'' s1'' s2'0) (s3 : state L2) (H5 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2'0) (NOT1 : t1 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t1 t0) (s1''' : state L1) (STEP1 : Step L1 s1' t0 s1''') (i''' : index) (s2''' : state L2) (Q : match_states i''' s1''' s2''') (H7 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t0 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''')","proofString":"eapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (t0 : trace) (s1' : state L1) (s2b : state L2) (n : nat) (s2a : state L2) (i0 : index) (H : Step L1 s1 t0 s1') (H0 : t0 <> E0) (H1 : Star L2 s2b E0 s2) (H2 : starN (step L2) (globalenv L2) n s2 t0 s2a) (H3 : match_states i0 s1 s2b) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before n)) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before n)) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (t0 : trace) (s1' : state L1) (s2b : state L2) (n : nat) (s2a : state L2) (i0 : index) (H : Step L1 s1 t0 s1') (H0 : t0 <> E0) (H1 : Star L2 s2b E0 s2) (H2 : starN (step L2) (globalenv L2) n s2 t0 s2a) (H3 : match_states i0 s1 s2b)","proofString":"inv H2.\ncongruence.\nexploit f2b_determinacy_inv.\neexact H4.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\nsubst.\nsimpl in *.\nexists (F2BI_before n0); exists s1; split.\nright; split.\napply star_refl.\nconstructor.\nlia.\neconstructor; eauto.\neapply star_right; eauto.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst.\nrewrite E0_right in *.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\nexploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(t : trace) (s2' s2a : state L2) (STEP2 : Step L2 s2a t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b : state L2) (i0 : index) (H0 : E0 <> E0) (H : Step L1 s1 E0 s1') (H1 : Star L2 s2b E0 s2a) (H3 : match_states i0 s1 s2b) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before 0)) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/ Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before 0)) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(t : trace) (s2' s2a : state L2) (STEP2 : Step L2 s2a t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b : state L2) (i0 : index) (H0 : E0 <> E0) (H : Step L1 s1 E0 s1') (H1 : Star L2 s2b E0 s2a) (H3 : match_states i0 s1 s2b)","proofString":"congruence."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a)","proofString":"exploit f2b_determinacy_inv.\neexact H4.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\nsubst.\nsimpl in *.\nexists (F2BI_before n0); exists s1; split.\nright; split.\napply star_refl.\nconstructor.\nlia.\neconstructor; eauto.\neapply star_right; eauto.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst.\nrewrite E0_right in *.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\nexploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a) (EQ1 : t2 = E0) (EQ2 : t = E0) (EQ3 : s' = s2') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a) (EQ1 : t2 = E0) (EQ2 : t = E0) (EQ3 : s' = s2')","proofString":"subst.\nsimpl in *.\nexists (F2BI_before n0); exists s1; split.\nright; split.\napply star_refl.\nconstructor.\nlia.\neconstructor; eauto.\neapply star_right; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 (E0 ** t3) s1') (H0 : E0 ** t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/\n   Star L1 s1 E0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/\n   Star L1 s1 E0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 (E0 ** t3) s1') (H0 : E0 ** t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2')","proofString":"simpl in *.\nexists (F2BI_before n0); exists s1; split.\nright; split.\napply star_refl.\nconstructor.\nlia.\neconstructor; eauto.\neapply star_right; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/\n   Star L1 s1 E0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/\n   Star L1 s1 E0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2')","proofString":"exists (F2BI_before n0); exists s1; split.\nright; split.\napply star_refl.\nconstructor.\nlia.\neconstructor; eauto.\neapply star_right; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2') : Plus L1 s1 E0 s1 \\/\nStar L1 s1 E0 s1 /\\ f2b_order (F2BI_before n0) (F2BI_before (S n0)).","conclusion":"Plus L1 s1 E0 s1 \\/\nStar L1 s1 E0 s1 /\\ f2b_order (F2BI_before n0) (F2BI_before (S n0))","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2')","proofString":"right; split.\napply star_refl.\nconstructor.\nlia."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2') : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2')","proofString":"apply star_refl."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2') : f2b_order (F2BI_before n0) (F2BI_before (S n0)).","conclusion":"f2b_order (F2BI_before n0) (F2BI_before (S n0))","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2')","proofString":"constructor.\nlia."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2') : (n0 < S n0)%nat.","conclusion":"(n0 < S n0)%nat","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2')","proofString":"lia."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2') : f2b_match_states (F2BI_before n0) s1 s2'.","conclusion":"f2b_match_states (F2BI_before n0) s1 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2')","proofString":"econstructor; eauto.\neapply star_right; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2') : Star L2 s2b E0 s2'.","conclusion":"Star L2 s2b E0 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t3 : trace) (H : Step L1 s1 t3 s1') (H0 : t3 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (H5 : starN (step L2) (globalenv L2) n0 s2' t3 s2a) (H4 : Step L2 s2 E0 s2')","proofString":"eapply star_right; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t)","proofString":"exploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\ncongruence.\nsubst.\nrewrite E0_right in *.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\nexploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (EQ : t2 = E0) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (EQ : t2 = E0)","proofString":"congruence."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (EQ : t3 = E0) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 t3 : trace) (H0 : t2 ** t3 <> E0) (H : Step L1 s1 (t2 ** t3) s1') (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' t3 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (EQ : t3 = E0)","proofString":"subst.\nrewrite E0_right in *.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\nexploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 (t2 ** E0) s1') (H0 : t2 ** E0 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 (t2 ** E0) s1') (H0 : t2 ** E0 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t)","proofString":"rewrite E0_right in *.\nexploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\nexploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t)","proofString":"exploit (sr_receptive L1_receptive); eauto.\nintros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\nexploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) : (exists s3 : state L1, Step L1 s1 t s3) ->\nexists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"(exists s3 : state L1, Step L1 s1 t s3) ->\nexists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t)","proofString":"intros [s1''' STEP1].\nexploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\nexploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (s1''' : state L1) (STEP1 : Step L1 s1 t s1''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (s1''' : state L1) (STEP1 : Step L1 s1 t s1''')","proofString":"exploit fsim_simulation_not_E0.\neexact STEP1.\nauto.\neauto.\nintros [i''' [s2''' [P Q]]].\nexploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (s1''' : state L1) (STEP1 : Step L1 s1 t s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t s2''') (Q : match_states i''' s1''' s2''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (s1''' : state L1) (STEP1 : Step L1 s1 t s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t s2''') (Q : match_states i''' s1''' s2''')","proofString":"exploit f2b_determinacy_star.\neauto.\neexact STEP2.\nauto.\napply plus_star; eauto.\nintro R.\ninv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (s1''' : state L1) (STEP1 : Step L1 s1 t s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t s2''') (Q : match_states i''' s1''' s2''') (R : Star L2 s2 t s2''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t s1'0 \\/\n   Star L1 s1 t s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) t2 t) (s1''' : state L1) (STEP1 : Step L1 s1 t s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t s2''') (Q : match_states i''' s1''' s2''') (R : Star L2 s2 t s2''')","proofString":"inv R.\ncongruence.\nexploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2' s2''' : state L2) (STEP2 : Step L2 s2''' E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2''') (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2''' t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (MT : match_traces (symbolenv L1) t2 E0) (NOT2 : E0 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1 E0 s1''') (i''' : index) (P : Plus L2 s2b E0 s2''') (Q : match_states i''' s1''' s2''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/\n   Star L1 s1 E0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/\n   Star L1 s1 E0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2' s2''' : state L2) (STEP2 : Step L2 s2''' E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2''') (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2''' t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (MT : match_traces (symbolenv L1) t2 E0) (NOT2 : E0 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1 E0 s1''') (i''' : index) (P : Plus L2 s2b E0 s2''') (Q : match_states i''' s1''' s2''')","proofString":"congruence."},{"statement":"(s2 s2' : state L2) (t1 t0 : trace) (STEP2 : Step L2 s2 (t1 ** t0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (MT : match_traces (symbolenv L1) t2 (t1 ** t0)) (NOT2 : t1 ** t0 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1 (t1 ** t0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (t1 ** t0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t0 s2''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t1 ** t0) s1'0 \\/\n   Star L1 s1 (t1 ** t0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t1 ** t0) s1'0 \\/\n   Star L1 s1 (t1 ** t0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t1 t0 : trace) (STEP2 : Step L2 s2 (t1 ** t0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (MT : match_traces (symbolenv L1) t2 (t1 ** t0)) (NOT2 : t1 ** t0 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1 (t1 ** t0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (t1 ** t0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t0 s2''')","proofString":"exploit not_silent_length.\neapply (sr_traces L1_receptive); eauto.\nintros [EQ | EQ].\nsubst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto.\nsubst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t1 t0 : trace) (STEP2 : Step L2 s2 (t1 ** t0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (MT : match_traces (symbolenv L1) t2 (t1 ** t0)) (NOT2 : t1 ** t0 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1 (t1 ** t0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (t1 ** t0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t0 s2''') (EQ : t1 = E0) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t1 ** t0) s1'0 \\/\n   Star L1 s1 (t1 ** t0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t1 ** t0) s1'0 \\/\n   Star L1 s1 (t1 ** t0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t1 t0 : trace) (STEP2 : Step L2 s2 (t1 ** t0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (MT : match_traces (symbolenv L1) t2 (t1 ** t0)) (NOT2 : t1 ** t0 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1 (t1 ** t0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (t1 ** t0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t0 s2''') (EQ : t1 = E0)","proofString":"subst.\nsimpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 (E0 ** t0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : E0 ** t0 <> E0) (MT : match_traces (symbolenv L1) t2 (E0 ** t0)) (s1''' : state L1) (STEP1 : Step L1 s1 (E0 ** t0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (E0 ** t0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H6 : Star L2 s3 t0 s2''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (E0 ** t0) s1'0 \\/\n   Star L1 s1 (E0 ** t0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (E0 ** t0) s1'0 \\/\n   Star L1 s1 (E0 ** t0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 (E0 ** t0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : E0 ** t0 <> E0) (MT : match_traces (symbolenv L1) t2 (E0 ** t0)) (s1''' : state L1) (STEP1 : Step L1 s1 (E0 ** t0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (E0 ** t0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H6 : Star L2 s3 t0 s2''')","proofString":"simpl in *.\nexploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t2 t0) (s1''' : state L1) (STEP1 : Step L1 s1 t0 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t0 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H6 : Star L2 s3 t0 s2''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/\n   Star L1 s1 t0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/\n   Star L1 s1 t0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t2 t0) (s1''' : state L1) (STEP1 : Step L1 s1 t0 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t0 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H6 : Star L2 s3 t0 s2''')","proofString":"exploit sd_determ_1.\neauto.\neexact STEP2.\neexact H2.\nintros.\nelim NOT2.\ninv H7; auto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t2 t0) (s1''' : state L1) (STEP1 : Step L1 s1 t0 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t0 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H6 : Star L2 s3 t0 s2''') (H7 : match_traces (symbolenv L2) t0 E0) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/\n   Star L1 s1 t0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t0 s1'0 \\/\n   Star L1 s1 t0 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t2 t0) (s1''' : state L1) (STEP1 : Step L1 s1 t0 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t0 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H6 : Star L2 s3 t0 s2''') (H7 : match_traces (symbolenv L2) t0 E0)","proofString":"elim NOT2.\ninv H7; auto."},{"statement":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t2 t0) (s1''' : state L1) (STEP1 : Step L1 s1 t0 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t0 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H6 : Star L2 s3 t0 s2''') (H7 : match_traces (symbolenv L2) t0 E0) : t0 = E0.","conclusion":"t0 = E0","hypotheses":"(s2 s2' : state L2) (t0 : trace) (STEP2 : Step L2 s2 t0 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t0 <> E0) (MT : match_traces (symbolenv L1) t2 t0) (s1''' : state L1) (STEP1 : Step L1 s1 t0 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t0 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 E0 s3) (H6 : Star L2 s3 t0 s2''') (H7 : match_traces (symbolenv L2) t0 E0)","proofString":"inv H7; auto."},{"statement":"(s2 s2' : state L2) (t1 t0 : trace) (STEP2 : Step L2 s2 (t1 ** t0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (MT : match_traces (symbolenv L1) t2 (t1 ** t0)) (NOT2 : t1 ** t0 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1 (t1 ** t0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (t1 ** t0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t0 s2''') (EQ : t0 = E0) : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t1 ** t0) s1'0 \\/\n   Star L1 s1 (t1 ** t0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t1 ** t0) s1'0 \\/\n   Star L1 s1 (t1 ** t0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t1 t0 : trace) (STEP2 : Step L2 s2 (t1 ** t0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (MT : match_traces (symbolenv L1) t2 (t1 ** t0)) (NOT2 : t1 ** t0 <> E0) (s1''' : state L1) (STEP1 : Step L1 s1 (t1 ** t0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (t1 ** t0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 t0 s2''') (EQ : t0 = E0)","proofString":"subst.\nrewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 (t1 ** E0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 ** E0 <> E0) (MT : match_traces (symbolenv L1) t2 (t1 ** E0)) (s1''' : state L1) (STEP1 : Step L1 s1 (t1 ** E0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (t1 ** E0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t1 ** E0) s1'0 \\/\n   Star L1 s1 (t1 ** E0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 (t1 ** E0) s1'0 \\/\n   Star L1 s1 (t1 ** E0) s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 (t1 ** E0) s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 ** E0 <> E0) (MT : match_traces (symbolenv L1) t2 (t1 ** E0)) (s1''' : state L1) (STEP1 : Step L1 s1 (t1 ** E0) s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b (t1 ** E0) s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2''')","proofString":"rewrite E0_right in *.\nassert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t1 s1'0 \\/\n   Star L1 s1 t1 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t1 s1'0 \\/\n   Star L1 s1 t1 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2''')","proofString":"assert (s3 = s2').\neapply sd_determ_2; eauto.\nsubst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2''') : s3 = s2'.","conclusion":"s3 = s2'","hypotheses":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2''')","proofString":"eapply sd_determ_2; eauto."},{"statement":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2''') (H7 : s3 = s2') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t1 s1'0 \\/\n   Star L1 s1 t1 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t1 s1'0 \\/\n   Star L1 s1 t1 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (s3 : state L2) (H2 : Step L2 s2 t1 s3) (H6 : Star L2 s3 E0 s2''') (H7 : s3 = s2')","proofString":"subst s3.\ndestruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t1 s1'0 \\/\n   Star L1 s1 t1 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t1 s1'0 \\/\n   Star L1 s1 t1 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2')","proofString":"destruct (star_starN H6) as [n STEPS2].\nexists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''') : exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t1 s1'0 \\/\n   Star L1 s1 t1 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'.","conclusion":"exists (i' : f2b_index) (s1'0 : state L1),\n  (Plus L1 s1 t1 s1'0 \\/\n   Star L1 s1 t1 s1'0 /\\ f2b_order i' (F2BI_before (S n0))) /\\\n  f2b_match_states i' s1'0 s2'","hypotheses":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''')","proofString":"exists (F2BI_after n); exists s1'''; split.\nleft.\napply plus_one; auto.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''') : Plus L1 s1 t1 s1''' \\/\nStar L1 s1 t1 s1''' /\\ f2b_order (F2BI_after n) (F2BI_before (S n0)).","conclusion":"Plus L1 s1 t1 s1''' \\/\nStar L1 s1 t1 s1''' /\\ f2b_order (F2BI_after n) (F2BI_before (S n0))","hypotheses":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''')","proofString":"left.\napply plus_one; auto."},{"statement":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''') : Plus L1 s1 t1 s1'''.","conclusion":"Plus L1 s1 t1 s1'''","hypotheses":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''')","proofString":"apply plus_one; auto."},{"statement":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''') : f2b_match_states (F2BI_after n) s1''' s2'.","conclusion":"f2b_match_states (F2BI_after n) s1''' s2'","hypotheses":"(s2 s2' : state L2) (t1 : trace) (STEP2 : Step L2 s2 t1 s2') (s1 : state L1) (SAFE : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t2 : trace) (H : Step L1 s1 t2 s1') (H0 : t2 <> E0) (H1 : Star L2 s2b E0 s2) (H3 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H4 : Step L2 s2 t2 s') (H5 : starN (step L2) (globalenv L2) n0 s' E0 s2a) (NOT1 : t2 <> E0) (NOT2 : t1 <> E0) (MT : match_traces (symbolenv L1) t2 t1) (s1''' : state L1) (STEP1 : Step L1 s1 t1 s1''') (i''' : index) (s2''' : state L2) (P : Plus L2 s2b t1 s2''') (Q : match_states i''' s1''' s2''') (H6 : Star L2 s2' E0 s2''') (H2 : Step L2 s2 t1 s2') (n : nat) (STEPS2 : starN (step L2) (globalenv L2) n s2' E0 s2''')","proofString":"eapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H : starN (step L2) (globalenv L2) (S n) s2 E0 s2a) (H0 : match_states i0 s1 s2a) : exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H : starN (step L2) (globalenv L2) (S n) s2 E0 s2a) (H0 : match_states i0 s1 s2a)","proofString":"inv H.\nexploit Eapp_E0_inv; eauto.\nintros [EQ1 EQ2]; subst.\nexploit f2b_determinacy_inv.\neexact H2.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\nsubst.\nexists (F2BI_after n); exists s1; split.\nright; split.\napply star_refl.\nconstructor; lia.\neapply f2b_match_after'; eauto.\ncongruence."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H2 : Step L2 s2 t1 s') (H3 : starN (step L2) (globalenv L2) n s' t2 s2a) (H4 : E0 = t1 ** t2) : exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H2 : Step L2 s2 t1 s') (H3 : starN (step L2) (globalenv L2) n s' t2 s2a) (H4 : E0 = t1 ** t2)","proofString":"exploit Eapp_E0_inv; eauto.\nintros [EQ1 EQ2]; subst.\nexploit f2b_determinacy_inv.\neexact H2.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\nsubst.\nexists (F2BI_after n); exists s1; split.\nright; split.\napply star_refl.\nconstructor; lia.\neapply f2b_match_after'; eauto.\ncongruence."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H2 : Step L2 s2 t1 s') (H3 : starN (step L2) (globalenv L2) n s' t2 s2a) (H4 : E0 = t1 ** t2) : t1 = E0 /\\ t2 = E0 ->\nexists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"t1 = E0 /\\ t2 = E0 ->\nexists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H2 : Step L2 s2 t1 s') (H3 : starN (step L2) (globalenv L2) n s' t2 s2a) (H4 : E0 = t1 ** t2)","proofString":"intros [EQ1 EQ2]; subst.\nexploit f2b_determinacy_inv.\neexact H2.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\nsubst.\nexists (F2BI_after n); exists s1; split.\nright; split.\napply star_refl.\nconstructor; lia.\neapply f2b_match_after'; eauto.\ncongruence."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (s' : state L2) (H2 : Step L2 s2 E0 s') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s' E0 s2a) : exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (s' : state L2) (H2 : Step L2 s2 E0 s') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s' E0 s2a)","proofString":"exploit f2b_determinacy_inv.\neexact H2.\neexact STEP2.\nintros [[EQ1 [EQ2 EQ3]] | [NOT1 [NOT2 MT]]].\nsubst.\nexists (F2BI_after n); exists s1; split.\nright; split.\napply star_refl.\nconstructor; lia.\neapply f2b_match_after'; eauto.\ncongruence."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (s' : state L2) (H2 : Step L2 s2 E0 s') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s' E0 s2a) (EQ1 : E0 = E0) (EQ2 : t = E0) (EQ3 : s' = s2') : exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (s' : state L2) (H2 : Step L2 s2 E0 s') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s' E0 s2a) (EQ1 : E0 = E0) (EQ2 : t = E0) (EQ3 : s' = s2')","proofString":"subst.\nexists (F2BI_after n); exists s1; split.\nright; split.\napply star_refl.\nconstructor; lia.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0) : exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0)","proofString":"exists (F2BI_after n); exists s1; split.\nright; split.\napply star_refl.\nconstructor; lia.\neapply f2b_match_after'; eauto."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0) : Plus L1 s1 E0 s1 \\/\nStar L1 s1 E0 s1 /\\ f2b_order (F2BI_after n) (F2BI_after (S n)).","conclusion":"Plus L1 s1 E0 s1 \\/\nStar L1 s1 E0 s1 /\\ f2b_order (F2BI_after n) (F2BI_after (S n))","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0)","proofString":"right; split.\napply star_refl.\nconstructor; lia."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0) : Star L1 s1 E0 s1.","conclusion":"Star L1 s1 E0 s1","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0)","proofString":"apply star_refl."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0) : f2b_order (F2BI_after n) (F2BI_after (S n)).","conclusion":"f2b_order (F2BI_after n) (F2BI_after (S n))","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0)","proofString":"constructor; lia."},{"statement":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0) : f2b_match_states (F2BI_after n) s1 s2'.","conclusion":"f2b_match_states (F2BI_after n) s1 s2'","hypotheses":"(s2 s2' : state L2) (STEP2 : Step L2 s2 E0 s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (H2 : Step L2 s2 E0 s2') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s2' E0 s2a) (EQ1 : E0 = E0)","proofString":"eapply f2b_match_after'; eauto."},{"statement":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (s' : state L2) (H2 : Step L2 s2 E0 s') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s' E0 s2a) (NOT1 : E0 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) E0 t) : exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'.","conclusion":"exists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' (F2BI_after (S n))) /\\\n  f2b_match_states i' s1' s2'","hypotheses":"(s2 : state L2) (t : trace) (s2' : state L2) (STEP2 : Step L2 s2 t s2') (s1 : state L1) (SAFE : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H0 : match_states i0 s1 s2a) (s' : state L2) (H2 : Step L2 s2 E0 s') (H4 : E0 = E0 ** E0) (H3 : starN (step L2) (globalenv L2) n s' E0 s2a) (NOT1 : E0 <> E0) (NOT2 : t <> E0) (MT : match_traces (symbolenv L1) E0 t)","proofString":"congruence."},{"statement":"(L1 L2 : semantics) (FS : forward_simulation L1 L2) (L1_receptive : receptive L1) (L2_determinate : determinate L2) : backward_simulation L1 L2.","conclusion":"backward_simulation L1 L2","hypotheses":"(L1 L2 : semantics) (FS : forward_simulation L1 L2) (L1_receptive : receptive L1) (L2_determinate : determinate L2)","proofString":"destruct FS as [index order match_states FS].\napply Backward_simulation with f2b_order (f2b_match_states L1 L2 match_states); constructor.\napply wf_f2b_order.\nintros.\nexploit (fsim_match_initial_states FS); eauto.\nintros [i [s2 [A B]]].\nexists s2; auto.\nintros.\nexploit (fsim_match_initial_states FS); eauto.\nintros [i [s2' [A B]]].\nassert (s2 = s2') by (eapply sd_initial_determ; eauto).\nsubst s2'.\nexists (F2BI_after O); exists s1; split; auto.\neconstructor; eauto.\nintros.\ninv H.\nexploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nassert (r0 = r) by (eapply (sd_final_determ L2_determinate); eauto).\nsubst r0.\nexists s1'; auto.\ninv H4.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H5.\ncongruence.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H2.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\nintros.\ninv H.\nexploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nleft; exists r; auto.\ninv H3.\nright; econstructor; econstructor; eauto.\ninv H4.\ncongruence.\nright; econstructor; econstructor; eauto.\ninv H1.\nright; econstructor; econstructor; eauto.\neapply f2b_simulation_step; eauto.\nexact (fsim_public_preserved FS)."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) : backward_simulation L1 L2.","conclusion":"backward_simulation L1 L2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2)","proofString":"apply Backward_simulation with f2b_order (f2b_match_states L1 L2 match_states); constructor.\napply wf_f2b_order.\nintros.\nexploit (fsim_match_initial_states FS); eauto.\nintros [i [s2 [A B]]].\nexists s2; auto.\nintros.\nexploit (fsim_match_initial_states FS); eauto.\nintros [i [s2' [A B]]].\nassert (s2 = s2') by (eapply sd_initial_determ; eauto).\nsubst s2'.\nexists (F2BI_after O); exists s1; split; auto.\neconstructor; eauto.\nintros.\ninv H.\nexploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nassert (r0 = r) by (eapply (sd_final_determ L2_determinate); eauto).\nsubst r0.\nexists s1'; auto.\ninv H4.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H5.\ncongruence.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H2.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\nintros.\ninv H.\nexploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nleft; exists r; auto.\ninv H3.\nright; econstructor; econstructor; eauto.\ninv H4.\ncongruence.\nright; econstructor; econstructor; eauto.\ninv H1.\nright; econstructor; econstructor; eauto.\neapply f2b_simulation_step; eauto.\nexact (fsim_public_preserved FS)."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) : well_founded f2b_order.","conclusion":"well_founded f2b_order","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2)","proofString":"apply wf_f2b_order."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) : forall s1 : state L1,\ninitial_state L1 s1 -> exists s2 : state L2, initial_state L2 s2.","conclusion":"forall s1 : state L1,\ninitial_state L1 s1 -> exists s2 : state L2, initial_state L2 s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2)","proofString":"intros.\nexploit (fsim_match_initial_states FS); eauto.\nintros [i [s2 [A B]]].\nexists s2; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (H : initial_state L1 s1) : exists s2 : state L2, initial_state L2 s2.","conclusion":"exists s2 : state L2, initial_state L2 s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (H : initial_state L1 s1)","proofString":"exploit (fsim_match_initial_states FS); eauto.\nintros [i [s2 [A B]]].\nexists s2; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (H : initial_state L1 s1) : (exists (i : index) (s2 : state L2),\n   initial_state L2 s2 /\\ match_states i s1 s2) ->\nexists s2 : state L2, initial_state L2 s2.","conclusion":"(exists (i : index) (s2 : state L2),\n   initial_state L2 s2 /\\ match_states i s1 s2) ->\nexists s2 : state L2, initial_state L2 s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (H : initial_state L1 s1)","proofString":"intros [i [s2 [A B]]].\nexists s2; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (H : initial_state L1 s1) (i : index) (s2 : state L2) (A : initial_state L2 s2) (B : match_states i s1 s2) : exists s0 : state L2, initial_state L2 s0.","conclusion":"exists s0 : state L2, initial_state L2 s0","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (H : initial_state L1 s1) (i : index) (s2 : state L2) (A : initial_state L2 s2) (B : match_states i s1 s2)","proofString":"exists s2; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) : forall (s1 : state L1) (s2 : state L2),\ninitial_state L1 s1 ->\ninitial_state L2 s2 ->\nexists (i : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i s1' s2.","conclusion":"forall (s1 : state L1) (s2 : state L2),\ninitial_state L1 s1 ->\ninitial_state L2 s2 ->\nexists (i : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i s1' s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2)","proofString":"intros.\nexploit (fsim_match_initial_states FS); eauto.\nintros [i [s2' [A B]]].\nassert (s2 = s2') by (eapply sd_initial_determ; eauto).\nsubst s2'.\nexists (F2BI_after O); exists s1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) : exists (i : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i s1' s2.","conclusion":"exists (i : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i s1' s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2)","proofString":"exploit (fsim_match_initial_states FS); eauto.\nintros [i [s2' [A B]]].\nassert (s2 = s2') by (eapply sd_initial_determ; eauto).\nsubst s2'.\nexists (F2BI_after O); exists s1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) : (exists (i : index) (s3 : state L2),\n   initial_state L2 s3 /\\ match_states i s1 s3) ->\nexists (i : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i s1' s2.","conclusion":"(exists (i : index) (s3 : state L2),\n   initial_state L2 s3 /\\ match_states i s1 s3) ->\nexists (i : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i s1' s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2)","proofString":"intros [i [s2' [A B]]].\nassert (s2 = s2') by (eapply sd_initial_determ; eauto).\nsubst s2'.\nexists (F2BI_after O); exists s1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s2' : state L2) (A : initial_state L2 s2') (B : match_states i s1 s2') : exists (i0 : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i0 s1' s2.","conclusion":"exists (i0 : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i0 s1' s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s2' : state L2) (A : initial_state L2 s2') (B : match_states i s1 s2')","proofString":"assert (s2 = s2') by (eapply sd_initial_determ; eauto).\nsubst s2'.\nexists (F2BI_after O); exists s1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s2' : state L2) (A : initial_state L2 s2') (B : match_states i s1 s2') (H1 : s2 = s2') : exists (i0 : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i0 s1' s2.","conclusion":"exists (i0 : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i0 s1' s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s2' : state L2) (A : initial_state L2 s2') (B : match_states i s1 s2') (H1 : s2 = s2')","proofString":"subst s2'.\nexists (F2BI_after O); exists s1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (B : match_states i s1 s2) (A : initial_state L2 s2) : exists (i0 : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i0 s1' s2.","conclusion":"exists (i0 : f2b_index) (s1' : state L1),\n  initial_state L1 s1' /\\ f2b_match_states L1 L2 match_states i0 s1' s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (B : match_states i s1 s2) (A : initial_state L2 s2)","proofString":"exists (F2BI_after O); exists s1; split; auto.\neconstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (B : match_states i s1 s2) (A : initial_state L2 s2) : f2b_match_states L1 L2 match_states (F2BI_after 0) s1 s2.","conclusion":"f2b_match_states L1 L2 match_states (F2BI_after 0) s1 s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (B : match_states i s1 s2) (A : initial_state L2 s2)","proofString":"econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) : forall (i : f2b_index) (s1 : state L1) (s2 : state L2) (r : int),\nf2b_match_states L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\nfinal_state L2 s2 r ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"forall (i : f2b_index) (s1 : state L1) (s2 : state L2) (r : int),\nf2b_match_states L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\nfinal_state L2 s2 r ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2)","proofString":"intros.\ninv H.\nexploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nassert (r0 = r) by (eapply (sd_final_determ L2_determinate); eauto).\nsubst r0.\nexists s1'; auto.\ninv H4.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H5.\ncongruence.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H2.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (i : f2b_index) (s1 : state L1) (s2 : state L2) (r : int) (H : f2b_match_states L1 L2 match_states i s1 s2) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (i : f2b_index) (s1 : state L1) (s2 : state L2) (r : int) (H : f2b_match_states L1 L2 match_states i s1 s2) (H0 : safe L1 s1) (H1 : final_state L2 s2 r)","proofString":"inv H.\nexploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nassert (r0 = r) by (eapply (sd_final_determ L2_determinate); eauto).\nsubst r0.\nexists s1'; auto.\ninv H4.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H5.\ncongruence.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction.\ninv H2.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2)","proofString":"exploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nassert (r0 = r) by (eapply (sd_final_determ L2_determinate); eauto).\nsubst r0.\nexists s1'; auto.\ninv H4.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) : f2b_transitions L1 L2 match_states s1 s2 ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"f2b_transitions L1 L2 match_states s1 s2 ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2)","proofString":"intros TRANS; inv TRANS.\nassert (r0 = r) by (eapply (sd_final_determ L2_determinate); eauto).\nsubst r0.\nexists s1'; auto.\ninv H4.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' : state L1) (r0 : int) (H : Star L1 s1 E0 s1') (H3 : final_state L1 s1' r0) (H4 : final_state L2 s2 r0) : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' : state L1) (r0 : int) (H : Star L1 s1 E0 s1') (H3 : final_state L1 s1' r0) (H4 : final_state L2 s2 r0)","proofString":"assert (r0 = r) by (eapply (sd_final_determ L2_determinate); eauto).\nsubst r0.\nexists s1'; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' : state L1) (r0 : int) (H : Star L1 s1 E0 s1') (H3 : final_state L1 s1' r0) (H4 : final_state L2 s2 r0) (H5 : r0 = r) : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' : state L1) (r0 : int) (H : Star L1 s1 E0 s1') (H3 : final_state L1 s1' r0) (H4 : final_state L2 s2 r0) (H5 : r0 = r)","proofString":"subst r0.\nexists s1'; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' : state L1) (H : Star L1 s1 E0 s1') (H4 : final_state L2 s2 r) (H3 : final_state L1 s1' r) : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' : state L1) (H : Star L1 s1 E0 s1') (H4 : final_state L2 s2 r) (H3 : final_state L1 s1' r)","proofString":"exists s1'; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' : state L1) (t : trace) (s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (H3 : Step L1 s1' t s1'') (H4 : Plus L2 s2 t s2') (H5 : match_states i' s1' s2) (H6 : match_states i'' s1'' s2') : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' : state L1) (t : trace) (s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (H3 : Step L1 s1' t s1'') (H4 : Plus L2 s2 t s2') (H5 : match_states i' s1' s2) (H6 : match_states i'' s1'' s2')","proofString":"inv H4.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (t1 t2 : trace) (H3 : Step L1 s1' (t1 ** t2) s1'') (H5 : match_states i' s1' s2) (H6 : match_states i'' s1'' s2') (s3 : state L2) (H7 : Step L2 s2 t1 s3) (H8 : Star L2 s3 t2 s2') : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (t1 t2 : trace) (H3 : Step L1 s1' (t1 ** t2) s1'') (H5 : match_states i' s1' s2) (H6 : match_states i'' s1'' s2') (s3 : state L2) (H7 : Step L2 s2 t1 s3) (H8 : Star L2 s3 t2 s2')","proofString":"exploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (t1 t2 : trace) (H3 : Step L1 s1' (t1 ** t2) s1'') (H5 : match_states i' s1' s2) (H6 : match_states i'' s1'' s2') (s3 : state L2) (H7 : Step L2 s2 t1 s3) (H8 : Star L2 s3 t2 s2') : False -> exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"False -> exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (i0 : index) (H2 : match_states i0 s1 s2) (s1' s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (t1 t2 : trace) (H3 : Step L1 s1' (t1 ** t2) s1'') (H5 : match_states i' s1' s2) (H6 : match_states i'' s1'' s2') (s3 : state L2) (H7 : Step L2 s2 t1 s3) (H8 : Star L2 s3 t2 s2')","proofString":"contradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (t : trace) (s1' : state L1) (s2b : state L2) (n : nat) (s2a : state L2) (i0 : index) (H2 : Step L1 s1 t s1') (H3 : t <> E0) (H4 : Star L2 s2b E0 s2) (H5 : starN (step L2) (globalenv L2) n s2 t s2a) (H6 : match_states i0 s1 s2b) : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (t : trace) (s1' : state L1) (s2b : state L2) (n : nat) (s2a : state L2) (i0 : index) (H2 : Step L1 s1 t s1') (H3 : t <> E0) (H4 : Star L2 s2b E0 s2) (H5 : starN (step L2) (globalenv L2) n s2 t s2a) (H6 : match_states i0 s1 s2b)","proofString":"inv H5.\ncongruence.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (r : int) (H0 : safe L1 s1) (s2a : state L2) (H1 : final_state L2 s2a r) (s1' : state L1) (s2b : state L2) (i0 : index) (H3 : E0 <> E0) (H2 : Step L1 s1 E0 s1') (H4 : Star L2 s2b E0 s2a) (H6 : match_states i0 s1 s2b) : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (r : int) (H0 : safe L1 s1) (s2a : state L2) (H1 : final_state L2 s2a r) (s1' : state L1) (s2b : state L2) (i0 : index) (H3 : E0 <> E0) (H2 : Step L1 s1 E0 s1') (H4 : Star L2 s2b E0 s2a) (H6 : match_states i0 s1 s2b)","proofString":"congruence."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t1 t2 : trace) (H3 : t1 ** t2 <> E0) (H2 : Step L1 s1 (t1 ** t2) s1') (H4 : Star L2 s2b E0 s2) (H6 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H : Step L2 s2 t1 s') (H7 : starN (step L2) (globalenv L2) n0 s' t2 s2a) : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t1 t2 : trace) (H3 : t1 ** t2 <> E0) (H2 : Step L1 s1 (t1 ** t2) s1') (H4 : Star L2 s2b E0 s2) (H6 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H : Step L2 s2 t1 s') (H7 : starN (step L2) (globalenv L2) n0 s' t2 s2a)","proofString":"exploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t1 t2 : trace) (H3 : t1 ** t2 <> E0) (H2 : Step L1 s1 (t1 ** t2) s1') (H4 : Star L2 s2b E0 s2) (H6 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H : Step L2 s2 t1 s') (H7 : starN (step L2) (globalenv L2) n0 s' t2 s2a) : False -> exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"False -> exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t1 t2 : trace) (H3 : t1 ** t2 <> E0) (H2 : Step L1 s1 (t1 ** t2) s1') (H4 : Star L2 s2b E0 s2) (H6 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H : Step L2 s2 t1 s') (H7 : starN (step L2) (globalenv L2) n0 s' t2 s2a)","proofString":"contradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (n : nat) (s2a : state L2) (i0 : index) (H2 : starN (step L2) (globalenv L2) (S n) s2 E0 s2a) (H3 : match_states i0 s1 s2a) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (n : nat) (s2a : state L2) (i0 : index) (H2 : starN (step L2) (globalenv L2) (S n) s2 E0 s2a) (H3 : match_states i0 s1 s2a)","proofString":"inv H2.\nexploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (n : nat) (s2a : state L2) (i0 : index) (H3 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H4 : Step L2 s2 t1 s') (H5 : starN (step L2) (globalenv L2) n s' t2 s2a) (H6 : E0 = t1 ** t2) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (n : nat) (s2a : state L2) (i0 : index) (H3 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H4 : Step L2 s2 t1 s') (H5 : starN (step L2) (globalenv L2) n s' t2 s2a) (H6 : E0 = t1 ** t2)","proofString":"exploit (sd_final_nostep L2_determinate); eauto.\ncontradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (n : nat) (s2a : state L2) (i0 : index) (H3 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H4 : Step L2 s2 t1 s') (H5 : starN (step L2) (globalenv L2) n s' t2 s2a) (H6 : E0 = t1 ** t2) : False -> exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"False -> exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (n : nat) (s2a : state L2) (i0 : index) (H3 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H4 : Step L2 s2 t1 s') (H5 : starN (step L2) (globalenv L2) n s' t2 s2a) (H6 : E0 = t1 ** t2)","proofString":"contradiction."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) : forall (i : f2b_index) (s1 : state L1) (s2 : state L2),\nf2b_match_states L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\n(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2').","conclusion":"forall (i : f2b_index) (s1 : state L1) (s2 : state L2),\nf2b_match_states L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\n(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2)","proofString":"intros.\ninv H.\nexploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nleft; exists r; auto.\ninv H3.\nright; econstructor; econstructor; eauto.\ninv H4.\ncongruence.\nright; econstructor; econstructor; eauto.\ninv H1.\nright; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (i : f2b_index) (s1 : state L1) (s2 : state L2) (H : f2b_match_states L1 L2 match_states i s1 s2) (H0 : safe L1 s1) : (exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2').","conclusion":"(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (i : f2b_index) (s1 : state L1) (s2 : state L2) (H : f2b_match_states L1 L2 match_states i s1 s2) (H0 : safe L1 s1)","proofString":"inv H.\nexploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nleft; exists r; auto.\ninv H3.\nright; econstructor; econstructor; eauto.\ninv H4.\ncongruence.\nright; econstructor; econstructor; eauto.\ninv H1.\nright; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2) : (exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2').","conclusion":"(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2)","proofString":"exploit f2b_progress; eauto.\nintros TRANS; inv TRANS.\nleft; exists r; auto.\ninv H3.\nright; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2) : f2b_transitions L1 L2 match_states s1 s2 ->\n(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2').","conclusion":"f2b_transitions L1 L2 match_states s1 s2 ->\n(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2)","proofString":"intros TRANS; inv TRANS.\nleft; exists r; auto.\ninv H3.\nright; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2) (s1' : state L1) (r : int) (H : Star L1 s1 E0 s1') (H2 : final_state L1 s1' r) (H3 : final_state L2 s2 r) : (exists r0 : int, final_state L2 s2 r0) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2').","conclusion":"(exists r0 : int, final_state L2 s2 r0) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2) (s1' : state L1) (r : int) (H : Star L1 s1 E0 s1') (H2 : final_state L1 s1' r) (H3 : final_state L2 s2 r)","proofString":"left; exists r; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2) (s1' : state L1) (t : trace) (s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (H2 : Step L1 s1' t s1'') (H3 : Plus L2 s2 t s2') (H4 : match_states i' s1' s2) (H5 : match_states i'' s1'' s2') : (exists r : int, final_state L2 s2 r) \\/\n(exists (t0 : trace) (s2'0 : state L2), Step L2 s2 t0 s2'0).","conclusion":"(exists r : int, final_state L2 s2 r) \\/\n(exists (t0 : trace) (s2'0 : state L2), Step L2 s2 t0 s2'0)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2) (s1' : state L1) (t : trace) (s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (H2 : Step L1 s1' t s1'') (H3 : Plus L2 s2 t s2') (H4 : match_states i' s1' s2) (H5 : match_states i'' s1'' s2')","proofString":"inv H3.\nright; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2) (s1' s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (t1 t2 : trace) (H2 : Step L1 s1' (t1 ** t2) s1'') (H4 : match_states i' s1' s2) (H5 : match_states i'' s1'' s2') (s3 : state L2) (H6 : Step L2 s2 t1 s3) (H7 : Star L2 s3 t2 s2') : (exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2'0 : state L2), Step L2 s2 t s2'0).","conclusion":"(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2'0 : state L2), Step L2 s2 t s2'0)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (i0 : index) (H1 : match_states i0 s1 s2) (s1' s1'' : state L1) (s2' : state L2) (i' i'' : index) (H : Star L1 s1 E0 s1') (t1 t2 : trace) (H2 : Step L1 s1' (t1 ** t2) s1'') (H4 : match_states i' s1' s2) (H5 : match_states i'' s1'' s2') (s3 : state L2) (H6 : Step L2 s2 t1 s3) (H7 : Star L2 s3 t2 s2')","proofString":"right; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (t : trace) (s1' : state L1) (s2b : state L2) (n : nat) (s2a : state L2) (i0 : index) (H1 : Step L1 s1 t s1') (H2 : t <> E0) (H3 : Star L2 s2b E0 s2) (H4 : starN (step L2) (globalenv L2) n s2 t s2a) (H5 : match_states i0 s1 s2b) : (exists r : int, final_state L2 s2 r) \\/\n(exists (t0 : trace) (s2' : state L2), Step L2 s2 t0 s2').","conclusion":"(exists r : int, final_state L2 s2 r) \\/\n(exists (t0 : trace) (s2' : state L2), Step L2 s2 t0 s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (t : trace) (s1' : state L1) (s2b : state L2) (n : nat) (s2a : state L2) (i0 : index) (H1 : Step L1 s1 t s1') (H2 : t <> E0) (H3 : Star L2 s2b E0 s2) (H4 : starN (step L2) (globalenv L2) n s2 t s2a) (H5 : match_states i0 s1 s2b)","proofString":"inv H4.\ncongruence.\nright; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (H0 : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (H2 : E0 <> E0) (H1 : Step L1 s1 E0 s1') (H3 : Star L2 s2b E0 s2a) (H5 : match_states i0 s1 s2b) : (exists r : int, final_state L2 s2a r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2a t s2').","conclusion":"(exists r : int, final_state L2 s2a r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2a t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (H0 : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (H2 : E0 <> E0) (H1 : Step L1 s1 E0 s1') (H3 : Star L2 s2b E0 s2a) (H5 : match_states i0 s1 s2b)","proofString":"congruence."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t1 t2 : trace) (H2 : t1 ** t2 <> E0) (H1 : Step L1 s1 (t1 ** t2) s1') (H3 : Star L2 s2b E0 s2) (H5 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H : Step L2 s2 t1 s') (H6 : starN (step L2) (globalenv L2) n0 s' t2 s2a) : (exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2').","conclusion":"(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (s1' : state L1) (s2b s2a : state L2) (i0 : index) (t1 t2 : trace) (H2 : t1 ** t2 <> E0) (H1 : Step L1 s1 (t1 ** t2) s1') (H3 : Star L2 s2b E0 s2) (H5 : match_states i0 s1 s2b) (n0 : nat) (s' : state L2) (H : Step L2 s2 t1 s') (H6 : starN (step L2) (globalenv L2) n0 s' t2 s2a)","proofString":"right; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H1 : starN (step L2) (globalenv L2) (S n) s2 E0 s2a) (H2 : match_states i0 s1 s2a) : (exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2').","conclusion":"(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H1 : starN (step L2) (globalenv L2) (S n) s2 E0 s2a) (H2 : match_states i0 s1 s2a)","proofString":"inv H1.\nright; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H2 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H3 : Step L2 s2 t1 s') (H4 : starN (step L2) (globalenv L2) n s' t2 s2a) (H5 : E0 = t1 ** t2) : (exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2').","conclusion":"(exists r : int, final_state L2 s2 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s2 t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) (s1 : state L1) (s2 : state L2) (H0 : safe L1 s1) (n : nat) (s2a : state L2) (i0 : index) (H2 : match_states i0 s1 s2a) (t1 : trace) (s' : state L2) (t2 : trace) (H3 : Step L2 s2 t1 s') (H4 : starN (step L2) (globalenv L2) n s' t2 s2a) (H5 : E0 = t1 ** t2)","proofString":"right; econstructor; econstructor; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) : forall (s2 : state L2) (t : trace) (s2' : state L2),\nStep L2 s2 t s2' ->\nforall (i : f2b_index) (s1 : state L1),\nf2b_match_states L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\nexists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' i) /\\\n  f2b_match_states L1 L2 match_states i' s1' s2'.","conclusion":"forall (s2 : state L2) (t : trace) (s2' : state L2),\nStep L2 s2 t s2' ->\nforall (i : f2b_index) (s1 : state L1),\nf2b_match_states L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\nexists (i' : f2b_index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ f2b_order i' i) /\\\n  f2b_match_states L1 L2 match_states i' s1' s2'","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2)","proofString":"eapply f2b_simulation_step; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2) : forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (FS : fsim_properties L1 L2 index order match_states) (L1_receptive : receptive L1) (L2_determinate : determinate L2)","proofString":"exact (fsim_public_preserved FS)."},{"statement":"(s : state L2) : match E0 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s (ev :: nil) s2x /\\ Star L2 s2x t' s\nend.","conclusion":"match E0 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s (ev :: nil) s2x /\\ Star L2 s2x t' s\nend","hypotheses":"(s : state L2)","proofString":"simpl.\nauto."},{"statement":"(s : state L2) : True.","conclusion":"True","hypotheses":"(s : state L2)","proofString":"auto."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) : match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend)","proofString":"exploit L2single; eauto.\nintros LEN.\ndestruct t1.\nsimpl in *.\nsubst.\ndestruct t2.\nauto.\ndestruct IHstar as [s2x [A B]].\nexists s2x; split; auto.\neapply plus_left.\neauto.\napply plus_star; eauto.\nauto.\ndestruct t1.\nsimpl in *.\nsubst t.\nexists s2; split; auto.\napply plus_one; auto.\nsimpl in LEN.\nextlia."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) : (Datatypes.length t1 <= 1)%nat ->\nmatch t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"(Datatypes.length t1 <= 1)%nat ->\nmatch t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend)","proofString":"intros LEN.\ndestruct t1.\nsimpl in *.\nsubst.\ndestruct t2.\nauto.\ndestruct IHstar as [s2x [A B]].\nexists s2x; split; auto.\neapply plus_left.\neauto.\napply plus_star; eauto.\nauto.\ndestruct t1.\nsimpl in *.\nsubst t.\nexists s2; split; auto.\napply plus_one; auto.\nsimpl in LEN.\nextlia."},{"statement":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (Datatypes.length t1 <= 1)%nat) : match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 : state L2) (t1 : trace) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 t1 s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t1 ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (Datatypes.length t1 <= 1)%nat)","proofString":"destruct t1.\nsimpl in *.\nsubst.\ndestruct t2.\nauto.\ndestruct IHstar as [s2x [A B]].\nexists s2x; split; auto.\neapply plus_left.\neauto.\napply plus_star; eauto.\nauto.\ndestruct t1.\nsimpl in *.\nsubst t.\nexists s2; split; auto.\napply plus_one; auto.\nsimpl in LEN.\nextlia."},{"statement":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (0 <= 1)%nat) : match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 t2 s3) (H1 : t = t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (0 <= 1)%nat)","proofString":"subst.\ndestruct t2.\nauto.\ndestruct IHstar as [s2x [A B]].\nexists s2x; split; auto.\neapply plus_left.\neauto.\napply plus_star; eauto.\nauto."},{"statement":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 t2 s3) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (0 <= 1)%nat) : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 t2 s3) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (0 <= 1)%nat)","proofString":"destruct t2.\nauto.\ndestruct IHstar as [s2x [A B]].\nexists s2x; split; auto.\neapply plus_left.\neauto.\napply plus_star; eauto.\nauto."},{"statement":"(s1 s2 s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 nil s3) (IHstar : True) (LEN : (0 <= 1)%nat) : True.","conclusion":"True","hypotheses":"(s1 s2 s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 nil s3) (IHstar : True) (LEN : (0 <= 1)%nat)","proofString":"auto."},{"statement":"(s1 s2 : state L2) (e : event) (t2 : list event) (s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 (e :: t2) s3) (IHstar : exists s2x : state L2, Plus L2 s2 (e :: nil) s2x /\\ Star L2 s2x t2 s3) (LEN : (0 <= 1)%nat) : exists s2x : state L2, Plus L2 s1 (e :: nil) s2x /\\ Star L2 s2x t2 s3.","conclusion":"exists s2x : state L2, Plus L2 s1 (e :: nil) s2x /\\ Star L2 s2x t2 s3","hypotheses":"(s1 s2 : state L2) (e : event) (t2 : list event) (s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 (e :: t2) s3) (IHstar : exists s2x : state L2, Plus L2 s2 (e :: nil) s2x /\\ Star L2 s2x t2 s3) (LEN : (0 <= 1)%nat)","proofString":"destruct IHstar as [s2x [A B]].\nexists s2x; split; auto.\neapply plus_left.\neauto.\napply plus_star; eauto.\nauto."},{"statement":"(s1 s2 : state L2) (e : event) (t2 : list event) (s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 (e :: t2) s3) (s2x : state L2) (A : Plus L2 s2 (e :: nil) s2x) (B : Star L2 s2x t2 s3) (LEN : (0 <= 1)%nat) : exists s2x0 : state L2, Plus L2 s1 (e :: nil) s2x0 /\\ Star L2 s2x0 t2 s3.","conclusion":"exists s2x0 : state L2, Plus L2 s1 (e :: nil) s2x0 /\\ Star L2 s2x0 t2 s3","hypotheses":"(s1 s2 : state L2) (e : event) (t2 : list event) (s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 (e :: t2) s3) (s2x : state L2) (A : Plus L2 s2 (e :: nil) s2x) (B : Star L2 s2x t2 s3) (LEN : (0 <= 1)%nat)","proofString":"exists s2x; split; auto.\neapply plus_left.\neauto.\napply plus_star; eauto.\nauto."},{"statement":"(s1 s2 : state L2) (e : event) (t2 : list event) (s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 (e :: t2) s3) (s2x : state L2) (A : Plus L2 s2 (e :: nil) s2x) (B : Star L2 s2x t2 s3) (LEN : (0 <= 1)%nat) : Plus L2 s1 (e :: nil) s2x.","conclusion":"Plus L2 s1 (e :: nil) s2x","hypotheses":"(s1 s2 : state L2) (e : event) (t2 : list event) (s3 : state L2) (H : Step L2 s1 nil s2) (H0 : Star L2 s2 (e :: t2) s3) (s2x : state L2) (A : Plus L2 s2 (e :: nil) s2x) (B : Star L2 s2x t2 s3) (LEN : (0 <= 1)%nat)","proofString":"eapply plus_left.\neauto.\napply plus_star; eauto.\nauto."},{"statement":"(s1 : state L2) (e : event) (t1 : list event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: t1) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = (e :: t1) ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (Datatypes.length (e :: t1) <= 1)%nat) : match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 : state L2) (e : event) (t1 : list event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: t1) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = (e :: t1) ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (Datatypes.length (e :: t1) <= 1)%nat)","proofString":"destruct t1.\nsimpl in *.\nsubst t.\nexists s2; split; auto.\napply plus_one; auto.\nsimpl in LEN.\nextlia."},{"statement":"(s1 : state L2) (e : event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: nil) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = (e :: nil) ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (Datatypes.length (e :: nil) <= 1)%nat) : match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 : state L2) (e : event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: nil) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = (e :: nil) ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (Datatypes.length (e :: nil) <= 1)%nat)","proofString":"simpl in *.\nsubst t.\nexists s2; split; auto.\napply plus_one; auto."},{"statement":"(s1 : state L2) (e : event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: nil) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = e :: t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (1 <= 1)%nat) : match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 : state L2) (e : event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: nil) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = e :: t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (1 <= 1)%nat)","proofString":"subst t.\nexists s2; split; auto.\napply plus_one; auto."},{"statement":"(s1 : state L2) (e : event) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 (e :: nil) s2) (H0 : Star L2 s2 t2 s3) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (1 <= 1)%nat) : exists s2x : state L2, Plus L2 s1 (e :: nil) s2x /\\ Star L2 s2x t2 s3.","conclusion":"exists s2x : state L2, Plus L2 s1 (e :: nil) s2x /\\ Star L2 s2x t2 s3","hypotheses":"(s1 : state L2) (e : event) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 (e :: nil) s2) (H0 : Star L2 s2 t2 s3) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (1 <= 1)%nat)","proofString":"exists s2; split; auto.\napply plus_one; auto."},{"statement":"(s1 : state L2) (e : event) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 (e :: nil) s2) (H0 : Star L2 s2 t2 s3) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (1 <= 1)%nat) : Plus L2 s1 (e :: nil) s2.","conclusion":"Plus L2 s1 (e :: nil) s2","hypotheses":"(s1 : state L2) (e : event) (s2 : state L2) (t2 : trace) (s3 : state L2) (H : Step L2 s1 (e :: nil) s2) (H0 : Star L2 s2 t2 s3) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (1 <= 1)%nat)","proofString":"apply plus_one; auto."},{"statement":"(s1 : state L2) (e e0 : event) (t1 : list event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: e0 :: t1) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = (e :: e0 :: t1) ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (Datatypes.length (e :: e0 :: t1) <= 1)%nat) : match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 : state L2) (e e0 : event) (t1 : list event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: e0 :: t1) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = (e :: e0 :: t1) ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (Datatypes.length (e :: e0 :: t1) <= 1)%nat)","proofString":"simpl in LEN.\nextlia."},{"statement":"(s1 : state L2) (e e0 : event) (t1 : list event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: e0 :: t1) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = (e :: e0 :: t1) ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (S (S (Datatypes.length t1)) <= 1)%nat) : match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend.","conclusion":"match t with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s1 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend","hypotheses":"(s1 : state L2) (e e0 : event) (t1 : list event) (s2 : state L2) (t2 : trace) (s3 : state L2) (t : trace) (H : Step L2 s1 (e :: e0 :: t1) s2) (H0 : Star L2 s2 t2 s3) (H1 : t = (e :: e0 :: t1) ** t2) (IHstar : match t2 with\n| nil => True\n| ev :: t' =>\n    exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t' s3\nend) (LEN : (S (S (Datatypes.length t1)) <= 1)%nat)","proofString":"extlia."},{"statement":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H0 : ffs_match i (E0, s) s2) : exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) /\\\n  ffs_match i' (E0, s') s2'.","conclusion":"exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) /\\\n  ffs_match i' (E0, s') s2'","hypotheses":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H0 : ffs_match i (E0, s) s2)","proofString":"inv H0.\nexploit (fsim_simulation sim); eauto.\nintros [i' [s2' [A B]]].\nexists i'; exists s2'; split.\nauto.\nconstructor; auto."},{"statement":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2) : exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) /\\\n  ffs_match i' (E0, s') s2'.","conclusion":"exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) /\\\n  ffs_match i' (E0, s') s2'","hypotheses":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2)","proofString":"exploit (fsim_simulation sim); eauto.\nintros [i' [s2' [A B]]].\nexists i'; exists s2'; split.\nauto.\nconstructor; auto."},{"statement":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2) : (exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) /\\\n   match_states i' s' s2') ->\nexists (i' : index) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) /\\\n  ffs_match i' (E0, s') s2'.","conclusion":"(exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) /\\\n   match_states i' s' s2') ->\nexists (i' : index) (s2' : state L2),\n  (Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) /\\\n  ffs_match i' (E0, s') s2'","hypotheses":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2)","proofString":"intros [i' [s2' [A B]]].\nexists i'; exists s2'; split.\nauto.\nconstructor; auto."},{"statement":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) (B : match_states i' s' s2') : exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 E0 s2'0 \\/ Star L2 s2 E0 s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (E0, s') s2'0.","conclusion":"exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 E0 s2'0 \\/ Star L2 s2 E0 s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (E0, s') s2'0","hypotheses":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) (B : match_states i' s' s2')","proofString":"exists i'; exists s2'; split.\nauto.\nconstructor; auto."},{"statement":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) (B : match_states i' s' s2') : Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i.","conclusion":"Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i","hypotheses":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) (B : match_states i' s' s2')","proofString":"auto."},{"statement":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) (B : match_states i' s' s2') : ffs_match i' (E0, s') s2'.","conclusion":"ffs_match i' (E0, s') s2'","hypotheses":"(s s' : state L1) (H : Step L1 s E0 s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 E0 s2' \\/ Star L2 s2 E0 s2' /\\ order i' i) (B : match_states i' s' s2')","proofString":"constructor; auto."},{"statement":"(s : state L1) (ev : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: t) s') (i : index) (s2 : state L2) (H0 : ffs_match i (E0, s) s2) : exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) /\\\n  ffs_match i' (t, s') s2'.","conclusion":"exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) /\\\n  ffs_match i' (t, s') s2'","hypotheses":"(s : state L1) (ev : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: t) s') (i : index) (s2 : state L2) (H0 : ffs_match i (E0, s) s2)","proofString":"inv H0.\nexploit (fsim_simulation sim); eauto.\nintros [i' [s2' [A B]]].\ndestruct t as [ | ev' t].\nexists i'; exists s2'; split.\nauto.\nconstructor; auto.\nassert (C: Star L2 s2 (ev :: ev' :: t) s2').\nintuition.\napply plus_star; auto.\nexploit star_non_E0_split'.\neauto.\nsimpl.\nintros [s2x [P Q]].\nexists i'; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(s : state L1) (ev : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) : exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) /\\\n  ffs_match i' (t, s') s2'.","conclusion":"exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) /\\\n  ffs_match i' (t, s') s2'","hypotheses":"(s : state L1) (ev : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2)","proofString":"exploit (fsim_simulation sim); eauto.\nintros [i' [s2' [A B]]].\ndestruct t as [ | ev' t].\nexists i'; exists s2'; split.\nauto.\nconstructor; auto.\nassert (C: Star L2 s2 (ev :: ev' :: t) s2').\nintuition.\napply plus_star; auto.\nexploit star_non_E0_split'.\neauto.\nsimpl.\nintros [s2x [P Q]].\nexists i'; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(s : state L1) (ev : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) : (exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 (ev :: t) s2' \\/ Star L2 s2 (ev :: t) s2' /\\ order i' i) /\\\n   match_states i' s' s2') ->\nexists (i' : index) (s2' : state L2),\n  (Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) /\\\n  ffs_match i' (t, s') s2'.","conclusion":"(exists (i' : index) (s2' : state L2),\n   (Plus L2 s2 (ev :: t) s2' \\/ Star L2 s2 (ev :: t) s2' /\\ order i' i) /\\\n   match_states i' s' s2') ->\nexists (i' : index) (s2' : state L2),\n  (Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) /\\\n  ffs_match i' (t, s') s2'","hypotheses":"(s : state L1) (ev : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2)","proofString":"intros [i' [s2' [A B]]].\ndestruct t as [ | ev' t].\nexists i'; exists s2'; split.\nauto.\nconstructor; auto.\nassert (C: Star L2 s2 (ev :: ev' :: t) s2').\nintuition.\napply plus_star; auto.\nexploit star_non_E0_split'.\neauto.\nsimpl.\nintros [s2x [P Q]].\nexists i'; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(s : state L1) (ev : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: t) s2' \\/ Star L2 s2 (ev :: t) s2' /\\ order i' i) (B : match_states i' s' s2') : exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (t, s') s2'0.","conclusion":"exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (t, s') s2'0","hypotheses":"(s : state L1) (ev : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: t) s2' \\/ Star L2 s2 (ev :: t) s2' /\\ order i' i) (B : match_states i' s' s2')","proofString":"destruct t as [ | ev' t].\nexists i'; exists s2'; split.\nauto.\nconstructor; auto.\nassert (C: Star L2 s2 (ev :: ev' :: t) s2').\nintuition.\napply plus_star; auto.\nexploit star_non_E0_split'.\neauto.\nsimpl.\nintros [s2x [P Q]].\nexists i'; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(s : state L1) (ev : event) (s' : state L1) (H : Step L1 s (ev :: nil) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) (B : match_states i' s' s2') : exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (nil, s') s2'0.","conclusion":"exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (nil, s') s2'0","hypotheses":"(s : state L1) (ev : event) (s' : state L1) (H : Step L1 s (ev :: nil) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) (B : match_states i' s' s2')","proofString":"exists i'; exists s2'; split.\nauto.\nconstructor; auto."},{"statement":"(s : state L1) (ev : event) (s' : state L1) (H : Step L1 s (ev :: nil) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) (B : match_states i' s' s2') : Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i.","conclusion":"Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i","hypotheses":"(s : state L1) (ev : event) (s' : state L1) (H : Step L1 s (ev :: nil) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) (B : match_states i' s' s2')","proofString":"auto."},{"statement":"(s : state L1) (ev : event) (s' : state L1) (H : Step L1 s (ev :: nil) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) (B : match_states i' s' s2') : ffs_match i' (nil, s') s2'.","conclusion":"ffs_match i' (nil, s') s2'","hypotheses":"(s : state L1) (ev : event) (s' : state L1) (H : Step L1 s (ev :: nil) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) (B : match_states i' s' s2')","proofString":"constructor; auto."},{"statement":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') : exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (ev' :: t, s') s2'0.","conclusion":"exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (ev' :: t, s') s2'0","hypotheses":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2')","proofString":"assert (C: Star L2 s2 (ev :: ev' :: t) s2').\nintuition.\napply plus_star; auto.\nexploit star_non_E0_split'.\neauto.\nsimpl.\nintros [s2x [P Q]].\nexists i'; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') : Star L2 s2 (ev :: ev' :: t) s2'.","conclusion":"Star L2 s2 (ev :: ev' :: t) s2'","hypotheses":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2')","proofString":"intuition.\napply plus_star; auto."},{"statement":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (B : match_states i' s' s2') (H0 : Plus L2 s2 (ev :: ev' :: t) s2') : Star L2 s2 (ev :: ev' :: t) s2'.","conclusion":"Star L2 s2 (ev :: ev' :: t) s2'","hypotheses":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (B : match_states i' s' s2') (H0 : Plus L2 s2 (ev :: ev' :: t) s2')","proofString":"apply plus_star; auto."},{"statement":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2') : exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (ev' :: t, s') s2'0.","conclusion":"exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (ev' :: t, s') s2'0","hypotheses":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2')","proofString":"exploit star_non_E0_split'.\neauto.\nsimpl.\nintros [s2x [P Q]].\nexists i'; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2') : (exists s2x : state L2,\n   Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x (ev' :: t) s2') ->\nexists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (ev' :: t, s') s2'0.","conclusion":"(exists s2x : state L2,\n   Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x (ev' :: t) s2') ->\nexists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (ev' :: t, s') s2'0","hypotheses":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2')","proofString":"intros [s2x [P Q]].\nexists i'; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (ev' :: t) s2') : exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (ev' :: t, s') s2'0.","conclusion":"exists (i'0 : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i'0 i) /\\\n  ffs_match i'0 (ev' :: t, s') s2'0","hypotheses":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (ev' :: t) s2')","proofString":"exists i'; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (ev' :: t) s2') : Plus L2 s2 (ev :: nil) s2x \\/ Star L2 s2 (ev :: nil) s2x /\\ order i' i.","conclusion":"Plus L2 s2 (ev :: nil) s2x \\/ Star L2 s2 (ev :: nil) s2x /\\ order i' i","hypotheses":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (ev' :: t) s2')","proofString":"auto."},{"statement":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (ev' :: t) s2') : ffs_match i' (ev' :: t, s') s2x.","conclusion":"ffs_match i' (ev' :: t, s') s2x","hypotheses":"(s : state L1) (ev ev' : event) (t : list event) (s' : state L1) (H : Step L1 s (ev :: ev' :: t) s') (i : index) (s2 : state L2) (H3 : match_states i s s2) (i' : index) (s2' : state L2) (A : Plus L2 s2 (ev :: ev' :: t) s2' \\/\nStar L2 s2 (ev :: ev' :: t) s2' /\\ order i' i) (B : match_states i' s' s2') (C : Star L2 s2 (ev :: ev' :: t) s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (ev' :: t) s2')","proofString":"econstructor; eauto."},{"statement":"(ev : event) (t : list event) (s : state L1) (H : output_trace (ev :: t)) (i : index) (s2 : state L2) (H0 : ffs_match i (ev :: t, s) s2) : exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) /\\\n  ffs_match i' (t, s) s2'.","conclusion":"exists (i' : index) (s2' : state L2),\n  (Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i' i) /\\\n  ffs_match i' (t, s) s2'","hypotheses":"(ev : event) (t : list event) (s : state L1) (H : output_trace (ev :: t)) (i : index) (s2 : state L2) (H0 : ffs_match i (ev :: t, s) s2)","proofString":"inv H0.\nexploit star_non_E0_split'.\neauto.\nsimpl.\nintros [s2x [P Q]].\ndestruct t.\nexists i; exists s2'; split.\nleft.\neapply plus_star_trans; eauto.\nconstructor; auto.\nexists i; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(ev : event) (t : list event) (s : state L1) (H : output_trace (ev :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: t) s2') (H7 : match_states i s s2') : exists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (t, s) s2'0.","conclusion":"exists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (t, s) s2'0","hypotheses":"(ev : event) (t : list event) (s : state L1) (H : output_trace (ev :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: t) s2') (H7 : match_states i s s2')","proofString":"exploit star_non_E0_split'.\neauto.\nsimpl.\nintros [s2x [P Q]].\ndestruct t.\nexists i; exists s2'; split.\nleft.\neapply plus_star_trans; eauto.\nconstructor; auto.\nexists i; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(ev : event) (t : list event) (s : state L1) (H : output_trace (ev :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: t) s2') (H7 : match_states i s s2') : (exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t s2') ->\nexists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (t, s) s2'0.","conclusion":"(exists s2x : state L2, Plus L2 s2 (ev :: nil) s2x /\\ Star L2 s2x t s2') ->\nexists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (t, s) s2'0","hypotheses":"(ev : event) (t : list event) (s : state L1) (H : output_trace (ev :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: t) s2') (H7 : match_states i s s2')","proofString":"intros [s2x [P Q]].\ndestruct t.\nexists i; exists s2'; split.\nleft.\neapply plus_star_trans; eauto.\nconstructor; auto.\nexists i; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(ev : event) (t : list event) (s : state L1) (H : output_trace (ev :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: t) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x t s2') : exists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (t, s) s2'0.","conclusion":"exists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (t, s) s2'0","hypotheses":"(ev : event) (t : list event) (s : state L1) (H : output_trace (ev :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: t) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x t s2')","proofString":"destruct t.\nexists i; exists s2'; split.\nleft.\neapply plus_star_trans; eauto.\nconstructor; auto.\nexists i; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(ev : event) (s : state L1) (H : output_trace (ev :: nil)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: nil) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x nil s2') : exists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (nil, s) s2'0.","conclusion":"exists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (nil, s) s2'0","hypotheses":"(ev : event) (s : state L1) (H : output_trace (ev :: nil)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: nil) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x nil s2')","proofString":"exists i; exists s2'; split.\nleft.\neapply plus_star_trans; eauto.\nconstructor; auto."},{"statement":"(ev : event) (s : state L1) (H : output_trace (ev :: nil)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: nil) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x nil s2') : Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i i.","conclusion":"Plus L2 s2 (ev :: nil) s2' \\/ Star L2 s2 (ev :: nil) s2' /\\ order i i","hypotheses":"(ev : event) (s : state L1) (H : output_trace (ev :: nil)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: nil) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x nil s2')","proofString":"left.\neapply plus_star_trans; eauto."},{"statement":"(ev : event) (s : state L1) (H : output_trace (ev :: nil)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: nil) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x nil s2') : Plus L2 s2 (ev :: nil) s2'.","conclusion":"Plus L2 s2 (ev :: nil) s2'","hypotheses":"(ev : event) (s : state L1) (H : output_trace (ev :: nil)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: nil) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x nil s2')","proofString":"eapply plus_star_trans; eauto."},{"statement":"(ev : event) (s : state L1) (H : output_trace (ev :: nil)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: nil) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x nil s2') : ffs_match i (nil, s) s2'.","conclusion":"ffs_match i (nil, s) s2'","hypotheses":"(ev : event) (s : state L1) (H : output_trace (ev :: nil)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: nil) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x nil s2')","proofString":"constructor; auto."},{"statement":"(ev e : event) (t : list event) (s : state L1) (H : output_trace (ev :: e :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: e :: t) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (e :: t) s2') : exists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (e :: t, s) s2'0.","conclusion":"exists (i' : index) (s2'0 : state L2),\n  (Plus L2 s2 (ev :: nil) s2'0 \\/ Star L2 s2 (ev :: nil) s2'0 /\\ order i' i) /\\\n  ffs_match i' (e :: t, s) s2'0","hypotheses":"(ev e : event) (t : list event) (s : state L1) (H : output_trace (ev :: e :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: e :: t) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (e :: t) s2')","proofString":"exists i; exists s2x; split.\nauto.\neconstructor; eauto."},{"statement":"(ev e : event) (t : list event) (s : state L1) (H : output_trace (ev :: e :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: e :: t) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (e :: t) s2') : Plus L2 s2 (ev :: nil) s2x \\/ Star L2 s2 (ev :: nil) s2x /\\ order i i.","conclusion":"Plus L2 s2 (ev :: nil) s2x \\/ Star L2 s2 (ev :: nil) s2x /\\ order i i","hypotheses":"(ev e : event) (t : list event) (s : state L1) (H : output_trace (ev :: e :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: e :: t) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (e :: t) s2')","proofString":"auto."},{"statement":"(ev e : event) (t : list event) (s : state L1) (H : output_trace (ev :: e :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: e :: t) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (e :: t) s2') : ffs_match i (e :: t, s) s2x.","conclusion":"ffs_match i (e :: t, s) s2x","hypotheses":"(ev e : event) (t : list event) (s : state L1) (H : output_trace (ev :: e :: t)) (i : index) (s2 s2' : state L2) (H6 : Star L2 s2 (ev :: e :: t) s2') (H7 : match_states i s s2') (s2x : state L2) (P : Plus L2 s2 (ev :: nil) s2x) (Q : Star L2 s2x (e :: t) s2')","proofString":"econstructor; eauto."},{"statement":"(L1 L2 : semantics) (FS : forward_simulation L1 L2) (L2single : single_events L2) : forward_simulation (atomic L1) L2.","conclusion":"forward_simulation (atomic L1) L2","hypotheses":"(L1 L2 : semantics) (FS : forward_simulation L1 L2) (L2single : single_events L2)","proofString":"destruct FS as [index order match_states sim].\napply Forward_simulation with order (ffs_match L1 L2 match_states); constructor.\neapply fsim_order_wf; eauto.\nintros.\ndestruct s1 as [t1 s1].\nsimpl in H.\ndestruct H.\nsubst.\nexploit (fsim_match_initial_states sim); eauto.\nintros [i [s2 [A B]]].\nexists i; exists s2; split; auto.\nconstructor; auto.\nintros.\ndestruct s1 as [t1 s1].\nsimpl in H0; destruct H0; subst.\ninv H.\neapply (fsim_match_final_states sim); eauto.\neapply ffs_simulation; eauto.\nsimpl.\nexact (fsim_public_preserved sim)."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) : forward_simulation (atomic L1) L2.","conclusion":"forward_simulation (atomic L1) L2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2)","proofString":"apply Forward_simulation with order (ffs_match L1 L2 match_states); constructor.\neapply fsim_order_wf; eauto.\nintros.\ndestruct s1 as [t1 s1].\nsimpl in H.\ndestruct H.\nsubst.\nexploit (fsim_match_initial_states sim); eauto.\nintros [i [s2 [A B]]].\nexists i; exists s2; split; auto.\nconstructor; auto.\nintros.\ndestruct s1 as [t1 s1].\nsimpl in H0; destruct H0; subst.\ninv H.\neapply (fsim_match_final_states sim); eauto.\neapply ffs_simulation; eauto.\nsimpl.\nexact (fsim_public_preserved sim)."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) : well_founded order.","conclusion":"well_founded order","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2)","proofString":"eapply fsim_order_wf; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) : forall s1 : state (atomic L1),\ninitial_state (atomic L1) s1 ->\nexists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i s1 s2.","conclusion":"forall s1 : state (atomic L1),\ninitial_state (atomic L1) s1 ->\nexists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i s1 s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2)","proofString":"intros.\ndestruct s1 as [t1 s1].\nsimpl in H.\ndestruct H.\nsubst.\nexploit (fsim_match_initial_states sim); eauto.\nintros [i [s2 [A B]]].\nexists i; exists s2; split; auto.\nconstructor; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state (atomic L1)) (H : initial_state (atomic L1) s1) : exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i s1 s2.","conclusion":"exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i s1 s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state (atomic L1)) (H : initial_state (atomic L1) s1)","proofString":"destruct s1 as [t1 s1].\nsimpl in H.\ndestruct H.\nsubst.\nexploit (fsim_match_initial_states sim); eauto.\nintros [i [s2 [A B]]].\nexists i; exists s2; split; auto.\nconstructor; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (t1 : trace) (s1 : state L1) (H : initial_state (atomic L1) (t1, s1)) : exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (t1, s1) s2.","conclusion":"exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (t1, s1) s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (t1 : trace) (s1 : state L1) (H : initial_state (atomic L1) (t1, s1))","proofString":"simpl in H.\ndestruct H.\nsubst.\nexploit (fsim_match_initial_states sim); eauto.\nintros [i [s2 [A B]]].\nexists i; exists s2; split; auto.\nconstructor; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (t1 : trace) (s1 : state L1) (H : initial_state L1 s1 /\\ t1 = E0) : exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (t1, s1) s2.","conclusion":"exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (t1, s1) s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (t1 : trace) (s1 : state L1) (H : initial_state L1 s1 /\\ t1 = E0)","proofString":"destruct H.\nsubst.\nexploit (fsim_match_initial_states sim); eauto.\nintros [i [s2 [A B]]].\nexists i; exists s2; split; auto.\nconstructor; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (t1 : trace) (s1 : state L1) (H : initial_state L1 s1) (H0 : t1 = E0) : exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (t1, s1) s2.","conclusion":"exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (t1, s1) s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (t1 : trace) (s1 : state L1) (H : initial_state L1 s1) (H0 : t1 = E0)","proofString":"subst.\nexploit (fsim_match_initial_states sim); eauto.\nintros [i [s2 [A B]]].\nexists i; exists s2; split; auto.\nconstructor; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state L1) (H : initial_state L1 s1) : exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (E0, s1) s2.","conclusion":"exists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (E0, s1) s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state L1) (H : initial_state L1 s1)","proofString":"exploit (fsim_match_initial_states sim); eauto.\nintros [i [s2 [A B]]].\nexists i; exists s2; split; auto.\nconstructor; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state L1) (H : initial_state L1 s1) : (exists (i : index) (s2 : state L2),\n   initial_state L2 s2 /\\ match_states i s1 s2) ->\nexists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (E0, s1) s2.","conclusion":"(exists (i : index) (s2 : state L2),\n   initial_state L2 s2 /\\ match_states i s1 s2) ->\nexists (i : index) (s2 : state L2),\n  initial_state L2 s2 /\\ ffs_match L1 L2 match_states i (E0, s1) s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state L1) (H : initial_state L1 s1)","proofString":"intros [i [s2 [A B]]].\nexists i; exists s2; split; auto.\nconstructor; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state L1) (H : initial_state L1 s1) (i : index) (s2 : state L2) (A : initial_state L2 s2) (B : match_states i s1 s2) : exists (i0 : index) (s0 : state L2),\n  initial_state L2 s0 /\\ ffs_match L1 L2 match_states i0 (E0, s1) s0.","conclusion":"exists (i0 : index) (s0 : state L2),\n  initial_state L2 s0 /\\ ffs_match L1 L2 match_states i0 (E0, s1) s0","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state L1) (H : initial_state L1 s1) (i : index) (s2 : state L2) (A : initial_state L2 s2) (B : match_states i s1 s2)","proofString":"exists i; exists s2; split; auto.\nconstructor; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state L1) (H : initial_state L1 s1) (i : index) (s2 : state L2) (A : initial_state L2 s2) (B : match_states i s1 s2) : ffs_match L1 L2 match_states i (E0, s1) s2.","conclusion":"ffs_match L1 L2 match_states i (E0, s1) s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (s1 : state L1) (H : initial_state L1 s1) (i : index) (s2 : state L2) (A : initial_state L2 s2) (B : match_states i s1 s2)","proofString":"constructor; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) : forall (i : index) (s1 : state (atomic L1)) (s2 : state L2) (r : int),\nffs_match L1 L2 match_states i s1 s2 ->\nfinal_state (atomic L1) s1 r -> final_state L2 s2 r.","conclusion":"forall (i : index) (s1 : state (atomic L1)) (s2 : state L2) (r : int),\nffs_match L1 L2 match_states i s1 s2 ->\nfinal_state (atomic L1) s1 r -> final_state L2 s2 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2)","proofString":"intros.\ndestruct s1 as [t1 s1].\nsimpl in H0; destruct H0; subst.\ninv H.\neapply (fsim_match_final_states sim); eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (i : index) (s1 : state (atomic L1)) (s2 : state L2) (r : int) (H : ffs_match L1 L2 match_states i s1 s2) (H0 : final_state (atomic L1) s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (i : index) (s1 : state (atomic L1)) (s2 : state L2) (r : int) (H : ffs_match L1 L2 match_states i s1 s2) (H0 : final_state (atomic L1) s1 r)","proofString":"destruct s1 as [t1 s1].\nsimpl in H0; destruct H0; subst.\ninv H.\neapply (fsim_match_final_states sim); eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (i : index) (t1 : trace) (s1 : state L1) (s2 : state L2) (r : int) (H : ffs_match L1 L2 match_states i (t1, s1) s2) (H0 : final_state (atomic L1) (t1, s1) r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (i : index) (t1 : trace) (s1 : state L1) (s2 : state L2) (r : int) (H : ffs_match L1 L2 match_states i (t1, s1) s2) (H0 : final_state (atomic L1) (t1, s1) r)","proofString":"simpl in H0; destruct H0; subst.\ninv H.\neapply (fsim_match_final_states sim); eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H : ffs_match L1 L2 match_states i (E0, s1) s2) (H0 : final_state L1 s1 r) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H : ffs_match L1 L2 match_states i (E0, s1) s2) (H0 : final_state L1 s1 r)","proofString":"inv H.\neapply (fsim_match_final_states sim); eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : final_state L1 s1 r) (H3 : match_states i s1 s2) : final_state L2 s2 r.","conclusion":"final_state L2 s2 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : final_state L1 s1 r) (H3 : match_states i s1 s2)","proofString":"eapply (fsim_match_final_states sim); eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) : forall (s1 : state (atomic L1)) (t : trace) (s1' : state (atomic L1)),\nStep (atomic L1) s1 t s1' ->\nforall (i : index) (s2 : state L2),\nffs_match L1 L2 match_states i s1 s2 ->\nexists (i' : index) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  ffs_match L1 L2 match_states i' s1' s2'.","conclusion":"forall (s1 : state (atomic L1)) (t : trace) (s1' : state (atomic L1)),\nStep (atomic L1) s1 t s1' ->\nforall (i : index) (s2 : state L2),\nffs_match L1 L2 match_states i s1 s2 ->\nexists (i' : index) (s2' : state L2),\n  (Plus L2 s2 t s2' \\/ Star L2 s2 t s2' /\\ order i' i) /\\\n  ffs_match L1 L2 match_states i' s1' s2'","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2)","proofString":"eapply ffs_simulation; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) : forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id =\nSenv.public_symbol (symbolenv (atomic L1)) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id =\nSenv.public_symbol (symbolenv (atomic L1)) id","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2)","proofString":"simpl.\nexact (fsim_public_preserved sim)."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2) : forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : fsim_properties L1 L2 index order match_states) (L2single : single_events L2)","proofString":"exact (fsim_public_preserved sim)."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H0 : fbs_match i s1 (E0, s)) (H1 : safe L1 s1) : exists (i' : index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ order i' i) /\\\n  fbs_match i' s1' (E0, s').","conclusion":"exists (i' : index) (s1' : state L1),\n  (Plus L1 s1 E0 s1' \\/ Star L1 s1 E0 s1' /\\ order i' i) /\\\n  fbs_match i' s1' (E0, s')","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H0 : fbs_match i s1 (E0, s)) (H1 : safe L1 s1)","proofString":"inv H0.\nexploit (bsim_simulation sim); eauto.\neapply star_safe; eauto.\nintros [i' [s1'' [A B]]].\nexists i'; exists s1''; split.\ndestruct A as [P | [P Q]].\nleft.\neapply star_plus_trans; eauto.\nright; split; auto.\neapply star_trans; eauto.\neconstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) : exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (E0, s').","conclusion":"exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (E0, s')","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0)","proofString":"exploit (bsim_simulation sim); eauto.\neapply star_safe; eauto.\nintros [i' [s1'' [A B]]].\nexists i'; exists s1''; split.\ndestruct A as [P | [P Q]].\nleft.\neapply star_plus_trans; eauto.\nright; split; auto.\neapply star_trans; eauto.\neconstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0)","proofString":"eapply star_safe; eauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) : (exists (i' : index) (s1'0 : state L1),\n   (Plus L1 s1' E0 s1'0 \\/ Star L1 s1' E0 s1'0 /\\ order i' i) /\\\n   match_states i' s1'0 s') ->\nexists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (E0, s').","conclusion":"(exists (i' : index) (s1'0 : state L1),\n   (Plus L1 s1' E0 s1'0 \\/ Star L1 s1' E0 s1'0 /\\ order i' i) /\\\n   match_states i' s1'0 s') ->\nexists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (E0, s')","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0)","proofString":"intros [i' [s1'' [A B]]].\nexists i'; exists s1''; split.\ndestruct A as [P | [P Q]].\nleft.\neapply star_plus_trans; eauto.\nright; split; auto.\neapply star_trans; eauto.\neconstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' E0 s1'' \\/ Star L1 s1' E0 s1'' /\\ order i' i) (B : match_states i' s1'' s') : exists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (E0, s').","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 E0 s1'0 \\/ Star L1 s1 E0 s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (E0, s')","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' E0 s1'' \\/ Star L1 s1' E0 s1'' /\\ order i' i) (B : match_states i' s1'' s')","proofString":"exists i'; exists s1''; split.\ndestruct A as [P | [P Q]].\nleft.\neapply star_plus_trans; eauto.\nright; split; auto.\neapply star_trans; eauto.\neconstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' E0 s1'' \\/ Star L1 s1' E0 s1'' /\\ order i' i) (B : match_states i' s1'' s') : Plus L1 s1 E0 s1'' \\/ Star L1 s1 E0 s1'' /\\ order i' i.","conclusion":"Plus L1 s1 E0 s1'' \\/ Star L1 s1 E0 s1'' /\\ order i' i","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' E0 s1'' \\/ Star L1 s1' E0 s1'' /\\ order i' i) (B : match_states i' s1'' s')","proofString":"destruct A as [P | [P Q]].\nleft.\neapply star_plus_trans; eauto.\nright; split; auto.\neapply star_trans; eauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (P : Plus L1 s1' E0 s1'') (B : match_states i' s1'' s') : Plus L1 s1 E0 s1'' \\/ Star L1 s1 E0 s1'' /\\ order i' i.","conclusion":"Plus L1 s1 E0 s1'' \\/ Star L1 s1 E0 s1'' /\\ order i' i","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (P : Plus L1 s1' E0 s1'') (B : match_states i' s1'' s')","proofString":"left.\neapply star_plus_trans; eauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (P : Plus L1 s1' E0 s1'') (B : match_states i' s1'' s') : Plus L1 s1 E0 s1''.","conclusion":"Plus L1 s1 E0 s1''","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (P : Plus L1 s1' E0 s1'') (B : match_states i' s1'' s')","proofString":"eapply star_plus_trans; eauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : order i' i) (B : match_states i' s1'' s') : Plus L1 s1 E0 s1'' \\/ Star L1 s1 E0 s1'' /\\ order i' i.","conclusion":"Plus L1 s1 E0 s1'' \\/ Star L1 s1 E0 s1'' /\\ order i' i","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : order i' i) (B : match_states i' s1'' s')","proofString":"right; split; auto.\neapply star_trans; eauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : order i' i) (B : match_states i' s1'' s') : Star L1 s1 E0 s1''.","conclusion":"Star L1 s1 E0 s1''","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (P : Star L1 s1' E0 s1'') (Q : order i' i) (B : match_states i' s1'' s')","proofString":"eapply star_trans; eauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' E0 s1'' \\/ Star L1 s1' E0 s1'' /\\ order i' i) (B : match_states i' s1'' s') : fbs_match i' s1'' (E0, s').","conclusion":"fbs_match i' s1'' (E0, s')","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' E0 s1'' \\/ Star L1 s1' E0 s1'' /\\ order i' i) (B : match_states i' s1'' s')","proofString":"econstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' E0 s1'' \\/ Star L1 s1' E0 s1'' /\\ order i' i) (B : match_states i' s1'' s') : E0 = E0 \\/ output_trace E0.","conclusion":"E0 = E0 \\/ output_trace E0","hypotheses":"(s s' : state L2) (H : Step L2 s E0 s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' E0 s1'' \\/ Star L1 s1' E0 s1'' /\\ order i' i) (B : match_states i' s1'' s')","proofString":"auto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H0 : fbs_match i s1 (E0, s)) (H1 : safe L1 s1) : exists (i' : index) (s1' : state L1),\n  (Plus L1 s1 (ev :: nil) s1' \\/ Star L1 s1 (ev :: nil) s1' /\\ order i' i) /\\\n  fbs_match i' s1' (t, s').","conclusion":"exists (i' : index) (s1' : state L1),\n  (Plus L1 s1 (ev :: nil) s1' \\/ Star L1 s1 (ev :: nil) s1' /\\ order i' i) /\\\n  fbs_match i' s1' (t, s')","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H0 : fbs_match i s1 (E0, s)) (H1 : safe L1 s1)","proofString":"inv H0.\nexploit (bsim_simulation sim); eauto.\neapply star_safe; eauto.\nintros [i' [s1'' [A B]]].\nassert (C: Star L1 s1 (ev :: t) s1'').\neapply star_trans.\neauto.\ndestruct A as [P | [P Q]].\napply plus_star; eauto.\neauto.\nauto.\nexploit star_non_E0_split'; eauto.\nsimpl.\nintros [s1x [P Q]].\nexists i'; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nexploit L2wb; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) : exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s').","conclusion":"exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s')","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0)","proofString":"exploit (bsim_simulation sim); eauto.\neapply star_safe; eauto.\nintros [i' [s1'' [A B]]].\nassert (C: Star L1 s1 (ev :: t) s1'').\neapply star_trans.\neauto.\ndestruct A as [P | [P Q]].\napply plus_star; eauto.\neauto.\nauto.\nexploit star_non_E0_split'; eauto.\nsimpl.\nintros [s1x [P Q]].\nexists i'; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nexploit L2wb; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0)","proofString":"eapply star_safe; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) : (exists (i' : index) (s1'0 : state L1),\n   (Plus L1 s1' (ev :: t) s1'0 \\/ Star L1 s1' (ev :: t) s1'0 /\\ order i' i) /\\\n   match_states i' s1'0 s') ->\nexists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s').","conclusion":"(exists (i' : index) (s1'0 : state L1),\n   (Plus L1 s1' (ev :: t) s1'0 \\/ Star L1 s1' (ev :: t) s1'0 /\\ order i' i) /\\\n   match_states i' s1'0 s') ->\nexists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s')","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0)","proofString":"intros [i' [s1'' [A B]]].\nassert (C: Star L1 s1 (ev :: t) s1'').\neapply star_trans.\neauto.\ndestruct A as [P | [P Q]].\napply plus_star; eauto.\neauto.\nauto.\nexploit star_non_E0_split'; eauto.\nsimpl.\nintros [s1x [P Q]].\nexists i'; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nexploit L2wb; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') : exists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s').","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s')","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s')","proofString":"assert (C: Star L1 s1 (ev :: t) s1'').\neapply star_trans.\neauto.\ndestruct A as [P | [P Q]].\napply plus_star; eauto.\neauto.\nauto.\nexploit star_non_E0_split'; eauto.\nsimpl.\nintros [s1x [P Q]].\nexists i'; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nexploit L2wb; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') : Star L1 s1 (ev :: t) s1''.","conclusion":"Star L1 s1 (ev :: t) s1''","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s')","proofString":"eapply star_trans.\neauto.\ndestruct A as [P | [P Q]].\napply plus_star; eauto.\neauto.\nauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') : exists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s').","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s')","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'')","proofString":"exploit star_non_E0_split'; eauto.\nsimpl.\nintros [s1x [P Q]].\nexists i'; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nexploit L2wb; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') : match ev :: t with\n| nil => True\n| ev0 :: t' =>\n    exists s2x : state L1, Plus L1 s1 (ev0 :: nil) s2x /\\ Star L1 s2x t' s1''\nend ->\nexists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s').","conclusion":"match ev :: t with\n| nil => True\n| ev0 :: t' =>\n    exists s2x : state L1, Plus L1 s1 (ev0 :: nil) s2x /\\ Star L1 s2x t' s1''\nend ->\nexists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s')","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'')","proofString":"simpl.\nintros [s1x [P Q]].\nexists i'; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nexploit L2wb; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') : (exists s2x : state L1, Plus L1 s1 (ev :: nil) s2x /\\ Star L1 s2x t s1'') ->\nexists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s').","conclusion":"(exists s2x : state L1, Plus L1 s1 (ev :: nil) s2x /\\ Star L1 s2x t s1'') ->\nexists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s')","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'')","proofString":"intros [s1x [P Q]].\nexists i'; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nexploit L2wb; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1'') : exists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s').","conclusion":"exists (i'0 : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i'0 i) /\\\n  fbs_match i'0 s1'0 (t, s')","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1'')","proofString":"exists i'; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nexploit L2wb; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1'') : Plus L1 s1 (ev :: nil) s1x \\/ Star L1 s1 (ev :: nil) s1x /\\ order i' i.","conclusion":"Plus L1 s1 (ev :: nil) s1x \\/ Star L1 s1 (ev :: nil) s1x /\\ order i' i","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1'')","proofString":"left; auto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1'') : fbs_match i' s1x (t, s').","conclusion":"fbs_match i' s1x (t, s')","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1'')","proofString":"econstructor; eauto.\nexploit L2wb; eauto."},{"statement":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1'') : t = E0 \\/ output_trace t.","conclusion":"t = E0 \\/ output_trace t","hypotheses":"(s : state L2) (ev : event) (t : list event) (s' : state L2) (H : Step L2 s (ev :: t) s') (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s) (H8 : E0 = E0 \\/ output_trace E0) (i' : index) (s1'' : state L1) (A : Plus L1 s1' (ev :: t) s1'' \\/ Star L1 s1' (ev :: t) s1'' /\\ order i' i) (B : match_states i' s1'' s') (C : Star L1 s1 (ev :: t) s1'') (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1'')","proofString":"exploit L2wb; eauto."},{"statement":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H0 : fbs_match i s1 (ev :: t, s)) (H1 : safe L1 s1) : exists (i' : index) (s1' : state L1),\n  (Plus L1 s1 (ev :: nil) s1' \\/ Star L1 s1 (ev :: nil) s1' /\\ order i' i) /\\\n  fbs_match i' s1' (t, s).","conclusion":"exists (i' : index) (s1' : state L1),\n  (Plus L1 s1 (ev :: nil) s1' \\/ Star L1 s1 (ev :: nil) s1' /\\ order i' i) /\\\n  fbs_match i' s1' (t, s)","hypotheses":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H0 : fbs_match i s1 (ev :: t, s)) (H1 : safe L1 s1)","proofString":"inv H0.\nunfold E0 in H8; destruct H8; try congruence.\nexploit star_non_E0_split'; eauto.\nsimpl.\nintros [s1x [P Q]].\nexists i; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nsimpl in H0; tauto."},{"statement":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H8 : ev :: t = E0 \\/ output_trace (ev :: t)) : exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s).","conclusion":"exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s)","hypotheses":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H8 : ev :: t = E0 \\/ output_trace (ev :: t))","proofString":"unfold E0 in H8; destruct H8; try congruence.\nexploit star_non_E0_split'; eauto.\nsimpl.\nintros [s1x [P Q]].\nexists i; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nsimpl in H0; tauto."},{"statement":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) : exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s).","conclusion":"exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s)","hypotheses":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t))","proofString":"exploit star_non_E0_split'; eauto.\nsimpl.\nintros [s1x [P Q]].\nexists i; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nsimpl in H0; tauto."},{"statement":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) : match ev :: t with\n| nil => True\n| ev0 :: t' =>\n    exists s2x : state L1, Plus L1 s1 (ev0 :: nil) s2x /\\ Star L1 s2x t' s1'\nend ->\nexists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s).","conclusion":"match ev :: t with\n| nil => True\n| ev0 :: t' =>\n    exists s2x : state L1, Plus L1 s1 (ev0 :: nil) s2x /\\ Star L1 s2x t' s1'\nend ->\nexists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s)","hypotheses":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t))","proofString":"simpl.\nintros [s1x [P Q]].\nexists i; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nsimpl in H0; tauto."},{"statement":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) : (exists s2x : state L1, Plus L1 s1 (ev :: nil) s2x /\\ Star L1 s2x t s1') ->\nexists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s).","conclusion":"(exists s2x : state L1, Plus L1 s1 (ev :: nil) s2x /\\ Star L1 s2x t s1') ->\nexists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s)","hypotheses":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t))","proofString":"intros [s1x [P Q]].\nexists i; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nsimpl in H0; tauto."},{"statement":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1') : exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s).","conclusion":"exists (i' : index) (s1'0 : state L1),\n  (Plus L1 s1 (ev :: nil) s1'0 \\/ Star L1 s1 (ev :: nil) s1'0 /\\ order i' i) /\\\n  fbs_match i' s1'0 (t, s)","hypotheses":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1')","proofString":"exists i; exists s1x; split.\nleft; auto.\neconstructor; eauto.\nsimpl in H0; tauto."},{"statement":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1') : Plus L1 s1 (ev :: nil) s1x \\/ Star L1 s1 (ev :: nil) s1x /\\ order i i.","conclusion":"Plus L1 s1 (ev :: nil) s1x \\/ Star L1 s1 (ev :: nil) s1x /\\ order i i","hypotheses":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1')","proofString":"left; auto."},{"statement":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1') : fbs_match i s1x (t, s).","conclusion":"fbs_match i s1x (t, s)","hypotheses":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1')","proofString":"econstructor; eauto.\nsimpl in H0; tauto."},{"statement":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1') : t = E0 \\/ output_trace t.","conclusion":"t = E0 \\/ output_trace t","hypotheses":"(ev : event) (t : list event) (s : state L2) (H : output_trace (ev :: t)) (i : index) (s1 : state L1) (H1 : safe L1 s1) (s1' : state L1) (H4 : Star L1 s1 (ev :: t) s1') (H7 : match_states i s1' s) (H0 : output_trace (ev :: t)) (s1x : state L1) (P : Plus L1 s1 (ev :: nil) s1x) (Q : Star L1 s1x t s1')","proofString":"simpl in H0; tauto."},{"statement":"(i : index) (s1 : state L1) (s2 : trace * state L2) (H : fbs_match i s1 s2) (H0 : safe L1 s1) : (exists r : int, final_state (atomic L2) s2 r) \\/\n(exists (t : trace) (s2' : state (atomic L2)), Step (atomic L2) s2 t s2').","conclusion":"(exists r : int, final_state (atomic L2) s2 r) \\/\n(exists (t : trace) (s2' : state (atomic L2)), Step (atomic L2) s2 t s2')","hypotheses":"(i : index) (s1 : state L1) (s2 : trace * state L2) (H : fbs_match i s1 s2) (H0 : safe L1 s1)","proofString":"inv H.\ndestruct t.\nexploit (bsim_progress sim); eauto.\neapply star_safe; eauto.\nintros [[r A] | [t [s2' A]]].\nleft; exists r; simpl; auto.\ndestruct t.\nright; exists E0; exists (nil, s2').\nconstructor.\nauto.\nright; exists (e :: nil); exists (t, s2').\nconstructor.\nauto.\nunfold E0 in H3; destruct H3.\ncongruence.\nright; exists (e :: nil); exists (t, s3).\nconstructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (t : trace) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 t s1') (H2 : match_states i s1' s3) (H3 : t = E0 \\/ output_trace t) : (exists r : int, final_state (atomic L2) (t, s3) r) \\/\n(exists (t0 : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (t, s3) t0 s2').","conclusion":"(exists r : int, final_state (atomic L2) (t, s3) r) \\/\n(exists (t0 : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (t, s3) t0 s2')","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (t : trace) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 t s1') (H2 : match_states i s1' s3) (H3 : t = E0 \\/ output_trace t)","proofString":"destruct t.\nexploit (bsim_progress sim); eauto.\neapply star_safe; eauto.\nintros [[r A] | [t [s2' A]]].\nleft; exists r; simpl; auto.\ndestruct t.\nright; exists E0; exists (nil, s2').\nconstructor.\nauto.\nright; exists (e :: nil); exists (t, s2').\nconstructor.\nauto.\nunfold E0 in H3; destruct H3.\ncongruence.\nright; exists (e :: nil); exists (t, s3).\nconstructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) : (exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t s2').","conclusion":"(exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t s2')","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil)","proofString":"exploit (bsim_progress sim); eauto.\neapply star_safe; eauto.\nintros [[r A] | [t [s2' A]]].\nleft; exists r; simpl; auto.\ndestruct t.\nright; exists E0; exists (nil, s2').\nconstructor.\nauto.\nright; exists (e :: nil); exists (t, s2').\nconstructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil)","proofString":"eapply star_safe; eauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) : (exists r : int, final_state L2 s3 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s3 t s2') ->\n(exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t s2').","conclusion":"(exists r : int, final_state L2 s3 r) \\/\n(exists (t : trace) (s2' : state L2), Step L2 s3 t s2') ->\n(exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t s2')","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil)","proofString":"intros [[r A] | [t [s2' A]]].\nleft; exists r; simpl; auto.\ndestruct t.\nright; exists E0; exists (nil, s2').\nconstructor.\nauto.\nright; exists (e :: nil); exists (t, s2').\nconstructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (r : int) (A : final_state L2 s3 r) : (exists r0 : int, final_state (atomic L2) (nil, s3) r0) \\/\n(exists (t : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t s2').","conclusion":"(exists r0 : int, final_state (atomic L2) (nil, s3) r0) \\/\n(exists (t : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t s2')","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (r : int) (A : final_state L2 s3 r)","proofString":"left; exists r; simpl; auto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (t : trace) (s2' : state L2) (A : Step L2 s3 t s2') : (exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t0 : trace) (s2'0 : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t0 s2'0).","conclusion":"(exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t0 : trace) (s2'0 : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t0 s2'0)","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (t : trace) (s2' : state L2) (A : Step L2 s3 t s2')","proofString":"destruct t.\nright; exists E0; exists (nil, s2').\nconstructor.\nauto.\nright; exists (e :: nil); exists (t, s2').\nconstructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (s2' : state L2) (A : Step L2 s3 nil s2') : (exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t : trace) (s2'0 : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t s2'0).","conclusion":"(exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t : trace) (s2'0 : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t s2'0)","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (s2' : state L2) (A : Step L2 s3 nil s2')","proofString":"right; exists E0; exists (nil, s2').\nconstructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (s2' : state L2) (A : Step L2 s3 nil s2') : Step (atomic L2) (nil, s3) E0 (nil, s2').","conclusion":"Step (atomic L2) (nil, s3) E0 (nil, s2')","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (s2' : state L2) (A : Step L2 s3 nil s2')","proofString":"constructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (s2' : state L2) (A : Step L2 s3 nil s2') : Step L2 s3 E0 s2'.","conclusion":"Step L2 s3 E0 s2'","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (s2' : state L2) (A : Step L2 s3 nil s2')","proofString":"auto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (e : event) (t : list event) (s2' : state L2) (A : Step L2 s3 (e :: t) s2') : (exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t0 : trace) (s2'0 : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t0 s2'0).","conclusion":"(exists r : int, final_state (atomic L2) (nil, s3) r) \\/\n(exists (t0 : trace) (s2'0 : state (atomic L2)),\n   Step (atomic L2) (nil, s3) t0 s2'0)","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (e : event) (t : list event) (s2' : state L2) (A : Step L2 s3 (e :: t) s2')","proofString":"right; exists (e :: nil); exists (t, s2').\nconstructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (e : event) (t : list event) (s2' : state L2) (A : Step L2 s3 (e :: t) s2') : Step (atomic L2) (nil, s3) (e :: nil) (t, s2').","conclusion":"Step (atomic L2) (nil, s3) (e :: nil) (t, s2')","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (e : event) (t : list event) (s2' : state L2) (A : Step L2 s3 (e :: t) s2')","proofString":"constructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (e : event) (t : list event) (s2' : state L2) (A : Step L2 s3 (e :: t) s2') : Step L2 s3 (e :: t) s2'.","conclusion":"Step L2 s3 (e :: t) s2'","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 nil s1') (H2 : match_states i s1' s3) (H3 : nil = E0 \\/ output_trace nil) (e : event) (t : list event) (s2' : state L2) (A : Step L2 s3 (e :: t) s2')","proofString":"auto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H3 : e :: t = E0 \\/ output_trace (e :: t)) : (exists r : int, final_state (atomic L2) (e :: t, s3) r) \\/\n(exists (t0 : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (e :: t, s3) t0 s2').","conclusion":"(exists r : int, final_state (atomic L2) (e :: t, s3) r) \\/\n(exists (t0 : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (e :: t, s3) t0 s2')","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H3 : e :: t = E0 \\/ output_trace (e :: t))","proofString":"unfold E0 in H3; destruct H3.\ncongruence.\nright; exists (e :: nil); exists (t, s3).\nconstructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H : e :: t = nil) : (exists r : int, final_state (atomic L2) (e :: t, s3) r) \\/\n(exists (t0 : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (e :: t, s3) t0 s2').","conclusion":"(exists r : int, final_state (atomic L2) (e :: t, s3) r) \\/\n(exists (t0 : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (e :: t, s3) t0 s2')","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H : e :: t = nil)","proofString":"congruence."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H : output_trace (e :: t)) : (exists r : int, final_state (atomic L2) (e :: t, s3) r) \\/\n(exists (t0 : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (e :: t, s3) t0 s2').","conclusion":"(exists r : int, final_state (atomic L2) (e :: t, s3) r) \\/\n(exists (t0 : trace) (s2' : state (atomic L2)),\n   Step (atomic L2) (e :: t, s3) t0 s2')","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H : output_trace (e :: t))","proofString":"right; exists (e :: nil); exists (t, s3).\nconstructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H : output_trace (e :: t)) : Step (atomic L2) (e :: t, s3) (e :: nil) (t, s3).","conclusion":"Step (atomic L2) (e :: t, s3) (e :: nil) (t, s3)","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H : output_trace (e :: t))","proofString":"constructor.\nauto."},{"statement":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H : output_trace (e :: t)) : output_trace (e :: t).","conclusion":"output_trace (e :: t)","hypotheses":"(i : index) (s1 : state L1) (H0 : safe L1 s1) (e : event) (t : list event) (s3 : state L2) (s1' : state L1) (H1 : Star L1 s1 (e :: t) s1') (H2 : match_states i s1' s3) (H : output_trace (e :: t))","proofString":"auto."},{"statement":"(L1 L2 : semantics) (BS : backward_simulation L1 L2) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : backward_simulation L1 (atomic L2).","conclusion":"backward_simulation L1 (atomic L2)","hypotheses":"(L1 L2 : semantics) (BS : backward_simulation L1 L2) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"destruct BS as [index order match_states sim].\napply Backward_simulation with order (fbs_match L1 L2 match_states); constructor.\neapply bsim_order_wf; eauto.\nintros.\nexploit (bsim_initial_states_exist sim); eauto.\nintros [s2 A].\nexists (E0, s2).\nsimpl; auto.\nintros.\ndestruct s2 as [t s2]; simpl in H0; destruct H0; subst.\nexploit (bsim_match_initial_states sim); eauto.\nintros [i [s1' [A B]]].\nexists i; exists s1'; split.\nauto.\neconstructor.\napply star_refl.\nauto.\nauto.\nintros.\ndestruct s2 as [t s2]; simpl in H1; destruct H1; subst.\ninv H.\nexploit (bsim_match_final_states sim); eauto.\neapply star_safe; eauto.\nintros [s1'' [A B]].\nexists s1''; split; auto.\neapply star_trans; eauto.\neapply fbs_progress; eauto.\neapply fbs_simulation; eauto.\nsimpl.\nexact (bsim_public_preserved sim)."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : backward_simulation L1 (atomic L2).","conclusion":"backward_simulation L1 (atomic L2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"apply Backward_simulation with order (fbs_match L1 L2 match_states); constructor.\neapply bsim_order_wf; eauto.\nintros.\nexploit (bsim_initial_states_exist sim); eauto.\nintros [s2 A].\nexists (E0, s2).\nsimpl; auto.\nintros.\ndestruct s2 as [t s2]; simpl in H0; destruct H0; subst.\nexploit (bsim_match_initial_states sim); eauto.\nintros [i [s1' [A B]]].\nexists i; exists s1'; split.\nauto.\neconstructor.\napply star_refl.\nauto.\nauto.\nintros.\ndestruct s2 as [t s2]; simpl in H1; destruct H1; subst.\ninv H.\nexploit (bsim_match_final_states sim); eauto.\neapply star_safe; eauto.\nintros [s1'' [A B]].\nexists s1''; split; auto.\neapply star_trans; eauto.\neapply fbs_progress; eauto.\neapply fbs_simulation; eauto.\nsimpl.\nexact (bsim_public_preserved sim)."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : well_founded order.","conclusion":"well_founded order","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"eapply bsim_order_wf; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : forall s1 : state L1,\ninitial_state L1 s1 ->\nexists s2 : state (atomic L2), initial_state (atomic L2) s2.","conclusion":"forall s1 : state L1,\ninitial_state L1 s1 ->\nexists s2 : state (atomic L2), initial_state (atomic L2) s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"intros.\nexploit (bsim_initial_states_exist sim); eauto.\nintros [s2 A].\nexists (E0, s2).\nsimpl; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (H : initial_state L1 s1) : exists s2 : state (atomic L2), initial_state (atomic L2) s2.","conclusion":"exists s2 : state (atomic L2), initial_state (atomic L2) s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (H : initial_state L1 s1)","proofString":"exploit (bsim_initial_states_exist sim); eauto.\nintros [s2 A].\nexists (E0, s2).\nsimpl; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (H : initial_state L1 s1) : (exists s2 : state L2, initial_state L2 s2) ->\nexists s2 : state (atomic L2), initial_state (atomic L2) s2.","conclusion":"(exists s2 : state L2, initial_state L2 s2) ->\nexists s2 : state (atomic L2), initial_state (atomic L2) s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (H : initial_state L1 s1)","proofString":"intros [s2 A].\nexists (E0, s2).\nsimpl; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) : exists s0 : state (atomic L2), initial_state (atomic L2) s0.","conclusion":"exists s0 : state (atomic L2), initial_state (atomic L2) s0","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2)","proofString":"exists (E0, s2).\nsimpl; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2) : initial_state (atomic L2) (E0, s2).","conclusion":"initial_state (atomic L2) (E0, s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (H : initial_state L1 s1) (s2 : state L2) (A : initial_state L2 s2)","proofString":"simpl; auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : forall (s1 : state L1) (s2 : state (atomic L2)),\ninitial_state L1 s1 ->\ninitial_state (atomic L2) s2 ->\nexists (i : index) (s1' : state L1),\n  initial_state L1 s1' /\\ fbs_match L1 L2 match_states i s1' s2.","conclusion":"forall (s1 : state L1) (s2 : state (atomic L2)),\ninitial_state L1 s1 ->\ninitial_state (atomic L2) s2 ->\nexists (i : index) (s1' : state L1),\n  initial_state L1 s1' /\\ fbs_match L1 L2 match_states i s1' s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"intros.\ndestruct s2 as [t s2]; simpl in H0; destruct H0; subst.\nexploit (bsim_match_initial_states sim); eauto.\nintros [i [s1' [A B]]].\nexists i; exists s1'; split.\nauto.\neconstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state (atomic L2)) (H : initial_state L1 s1) (H0 : initial_state (atomic L2) s2) : exists (i : index) (s1' : state L1),\n  initial_state L1 s1' /\\ fbs_match L1 L2 match_states i s1' s2.","conclusion":"exists (i : index) (s1' : state L1),\n  initial_state L1 s1' /\\ fbs_match L1 L2 match_states i s1' s2","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state (atomic L2)) (H : initial_state L1 s1) (H0 : initial_state (atomic L2) s2)","proofString":"destruct s2 as [t s2]; simpl in H0; destruct H0; subst.\nexploit (bsim_match_initial_states sim); eauto.\nintros [i [s1' [A B]]].\nexists i; exists s1'; split.\nauto.\neconstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) : exists (i : index) (s1' : state L1),\n  initial_state L1 s1' /\\ fbs_match L1 L2 match_states i s1' (E0, s2).","conclusion":"exists (i : index) (s1' : state L1),\n  initial_state L1 s1' /\\ fbs_match L1 L2 match_states i s1' (E0, s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2)","proofString":"exploit (bsim_match_initial_states sim); eauto.\nintros [i [s1' [A B]]].\nexists i; exists s1'; split.\nauto.\neconstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) : (exists (i : index) (s1' : state L1),\n   initial_state L1 s1' /\\ match_states i s1' s2) ->\nexists (i : index) (s1' : state L1),\n  initial_state L1 s1' /\\ fbs_match L1 L2 match_states i s1' (E0, s2).","conclusion":"(exists (i : index) (s1' : state L1),\n   initial_state L1 s1' /\\ match_states i s1' s2) ->\nexists (i : index) (s1' : state L1),\n  initial_state L1 s1' /\\ fbs_match L1 L2 match_states i s1' (E0, s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2)","proofString":"intros [i [s1' [A B]]].\nexists i; exists s1'; split.\nauto.\neconstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s1' : state L1) (A : initial_state L1 s1') (B : match_states i s1' s2) : exists (i0 : index) (s1'0 : state L1),\n  initial_state L1 s1'0 /\\ fbs_match L1 L2 match_states i0 s1'0 (E0, s2).","conclusion":"exists (i0 : index) (s1'0 : state L1),\n  initial_state L1 s1'0 /\\ fbs_match L1 L2 match_states i0 s1'0 (E0, s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s1' : state L1) (A : initial_state L1 s1') (B : match_states i s1' s2)","proofString":"exists i; exists s1'; split.\nauto.\neconstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s1' : state L1) (A : initial_state L1 s1') (B : match_states i s1' s2) : initial_state L1 s1'.","conclusion":"initial_state L1 s1'","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s1' : state L1) (A : initial_state L1 s1') (B : match_states i s1' s2)","proofString":"auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s1' : state L1) (A : initial_state L1 s1') (B : match_states i s1' s2) : fbs_match L1 L2 match_states i s1' (E0, s2).","conclusion":"fbs_match L1 L2 match_states i s1' (E0, s2)","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s1' : state L1) (A : initial_state L1 s1') (B : match_states i s1' s2)","proofString":"econstructor.\napply star_refl.\nauto.\nauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s1' : state L1) (A : initial_state L1 s1') (B : match_states i s1' s2) : E0 = E0 \\/ output_trace E0.","conclusion":"E0 = E0 \\/ output_trace E0","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (s1 : state L1) (s2 : state L2) (H : initial_state L1 s1) (H0 : initial_state L2 s2) (i : index) (s1' : state L1) (A : initial_state L1 s1') (B : match_states i s1' s2)","proofString":"auto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : forall (i : index) (s1 : state L1) (s2 : state (atomic L2)) (r : int),\nfbs_match L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\nfinal_state (atomic L2) s2 r ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"forall (i : index) (s1 : state L1) (s2 : state (atomic L2)) (r : int),\nfbs_match L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\nfinal_state (atomic L2) s2 r ->\nexists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"intros.\ndestruct s2 as [t s2]; simpl in H1; destruct H1; subst.\ninv H.\nexploit (bsim_match_final_states sim); eauto.\neapply star_safe; eauto.\nintros [s1'' [A B]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state (atomic L2)) (r : int) (H : fbs_match L1 L2 match_states i s1 s2) (H0 : safe L1 s1) (H1 : final_state (atomic L2) s2 r) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state (atomic L2)) (r : int) (H : fbs_match L1 L2 match_states i s1 s2) (H0 : safe L1 s1) (H1 : final_state (atomic L2) s2 r)","proofString":"destruct s2 as [t s2]; simpl in H1; destruct H1; subst.\ninv H.\nexploit (bsim_match_final_states sim); eauto.\neapply star_safe; eauto.\nintros [s1'' [A B]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H : fbs_match L1 L2 match_states i s1 (E0, s2)) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) : exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r.","conclusion":"exists s1' : state L1, Star L1 s1 E0 s1' /\\ final_state L1 s1' r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H : fbs_match L1 L2 match_states i s1 (E0, s2)) (H0 : safe L1 s1) (H1 : final_state L2 s2 r)","proofString":"inv H.\nexploit (bsim_match_final_states sim); eauto.\neapply star_safe; eauto.\nintros [s1'' [A B]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0) : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0)","proofString":"exploit (bsim_match_final_states sim); eauto.\neapply star_safe; eauto.\nintros [s1'' [A B]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0) : safe L1 s1'.","conclusion":"safe L1 s1'","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0)","proofString":"eapply star_safe; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0) : (exists s1'0 : state L1, Star L1 s1' E0 s1'0 /\\ final_state L1 s1'0 r) ->\nexists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"(exists s1'0 : state L1, Star L1 s1' E0 s1'0 /\\ final_state L1 s1'0 r) ->\nexists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0)","proofString":"intros [s1'' [A B]].\nexists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0) (s1'' : state L1) (A : Star L1 s1' E0 s1'') (B : final_state L1 s1'' r) : exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r.","conclusion":"exists s1'0 : state L1, Star L1 s1 E0 s1'0 /\\ final_state L1 s1'0 r","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0) (s1'' : state L1) (A : Star L1 s1' E0 s1'') (B : final_state L1 s1'' r)","proofString":"exists s1''; split; auto.\neapply star_trans; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0) (s1'' : state L1) (A : Star L1 s1' E0 s1'') (B : final_state L1 s1'' r) : Star L1 s1 E0 s1''.","conclusion":"Star L1 s1 E0 s1''","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) (i : index) (s1 : state L1) (s2 : state L2) (r : int) (H0 : safe L1 s1) (H1 : final_state L2 s2 r) (s1' : state L1) (H4 : Star L1 s1 E0 s1') (H7 : match_states i s1' s2) (H8 : E0 = E0 \\/ output_trace E0) (s1'' : state L1) (A : Star L1 s1' E0 s1'') (B : final_state L1 s1'' r)","proofString":"eapply star_trans; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : forall (i : index) (s1 : state L1) (s2 : state (atomic L2)),\nfbs_match L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\n(exists r : int, final_state (atomic L2) s2 r) \\/\n(exists (t : trace) (s2' : state (atomic L2)), Step (atomic L2) s2 t s2').","conclusion":"forall (i : index) (s1 : state L1) (s2 : state (atomic L2)),\nfbs_match L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\n(exists r : int, final_state (atomic L2) s2 r) \\/\n(exists (t : trace) (s2' : state (atomic L2)), Step (atomic L2) s2 t s2')","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"eapply fbs_progress; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : forall (s2 : state (atomic L2)) (t : trace) (s2' : state (atomic L2)),\nStep (atomic L2) s2 t s2' ->\nforall (i : index) (s1 : state L1),\nfbs_match L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\nexists (i' : index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ order i' i) /\\\n  fbs_match L1 L2 match_states i' s1' s2'.","conclusion":"forall (s2 : state (atomic L2)) (t : trace) (s2' : state (atomic L2)),\nStep (atomic L2) s2 t s2' ->\nforall (i : index) (s1 : state L1),\nfbs_match L1 L2 match_states i s1 s2 ->\nsafe L1 s1 ->\nexists (i' : index) (s1' : state L1),\n  (Plus L1 s1 t s1' \\/ Star L1 s1 t s1' /\\ order i' i) /\\\n  fbs_match L1 L2 match_states i' s1' s2'","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"eapply fbs_simulation; eauto."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : forall id : AST.ident,\nSenv.public_symbol (symbolenv (atomic L2)) id =\nSenv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv (atomic L2)) id =\nSenv.public_symbol (symbolenv L1) id","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"simpl.\nexact (bsim_public_preserved sim)."},{"statement":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2) : forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id.","conclusion":"forall id : AST.ident,\nSenv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id","hypotheses":"(L1 L2 : semantics) (index : Type) (order : index -> index -> Prop) (match_states : index -> state L1 -> state L2 -> Prop) (sim : bsim_properties L1 L2 index order match_states) (L1single : single_events L1) (L2wb : well_behaved_traces L2)","proofString":"exact (bsim_public_preserved sim)."},{"statement":"(L : semantics) (H : strongly_receptive L) : receptive (atomic L).","conclusion":"receptive (atomic L)","hypotheses":"(L : semantics) (H : strongly_receptive L)","proofString":"constructor; intros.\ninv H0.\ninv H1.\nexists (E0, s').\nconstructor; auto.\nassert (exists ev2, t2 = ev2 :: nil).\ninv H1; econstructor; eauto.\ndestruct H0 as [ev2 EQ]; subst t2.\nexploit ssr_receptive; eauto.\nintros [s2 [t2 P]].\nexploit ssr_well_behaved.\neauto.\neexact P.\nsimpl; intros Q.\nexists (t2, s2).\nconstructor; auto.\nsimpl in H2; destruct H2.\nassert (t2 = ev :: nil).\ninv H1; simpl in H0; tauto.\nsubst t2.\nexists (t, s0).\nconstructor; auto.\nsimpl; auto.\nred.\nintros.\ninv H0; simpl; lia."},{"statement":"(L : semantics) (H : strongly_receptive L) (s : state (atomic L)) (t1 : trace) (s1 : state (atomic L)) (t2 : trace) (H0 : Step (atomic L) s t1 s1) (H1 : match_traces (symbolenv (atomic L)) t1 t2) : exists s2 : state (atomic L), Step (atomic L) s t2 s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) s t2 s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (s : state (atomic L)) (t1 : trace) (s1 : state (atomic L)) (t2 : trace) (H0 : Step (atomic L) s t1 s1) (H1 : match_traces (symbolenv (atomic L)) t1 t2)","proofString":"inv H0.\ninv H1.\nexists (E0, s').\nconstructor; auto.\nassert (exists ev2, t2 = ev2 :: nil).\ninv H1; econstructor; eauto.\ndestruct H0 as [ev2 EQ]; subst t2.\nexploit ssr_receptive; eauto.\nintros [s2 [t2 P]].\nexploit ssr_well_behaved.\neauto.\neexact P.\nsimpl; intros Q.\nexists (t2, s2).\nconstructor; auto.\nsimpl in H2; destruct H2.\nassert (t2 = ev :: nil).\ninv H1; simpl in H0; tauto.\nsubst t2.\nexists (t, s0).\nconstructor; auto.\nsimpl; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (H1 : match_traces (symbolenv (atomic L)) E0 t2) (s0 s' : state L) (H2 : Step L s0 E0 s') : exists s2 : state (atomic L), Step (atomic L) (E0, s0) t2 s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) (E0, s0) t2 s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (H1 : match_traces (symbolenv (atomic L)) E0 t2) (s0 s' : state L) (H2 : Step L s0 E0 s')","proofString":"inv H1.\nexists (E0, s').\nconstructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (s0 s' : state L) (H2 : Step L s0 E0 s') : exists s2 : state (atomic L), Step (atomic L) (E0, s0) nil s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) (E0, s0) nil s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (s0 s' : state L) (H2 : Step L s0 E0 s')","proofString":"exists (E0, s').\nconstructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (s0 s' : state L) (H2 : Step L s0 E0 s') : Step (atomic L) (E0, s0) nil (E0, s').","conclusion":"Step (atomic L) (E0, s0) nil (E0, s')","hypotheses":"(L : semantics) (H : strongly_receptive L) (s0 s' : state L) (H2 : Step L s0 E0 s')","proofString":"constructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') : exists s2 : state (atomic L), Step (atomic L) (E0, s0) t2 s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) (E0, s0) t2 s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s')","proofString":"assert (exists ev2, t2 = ev2 :: nil).\ninv H1; econstructor; eauto.\ndestruct H0 as [ev2 EQ]; subst t2.\nexploit ssr_receptive; eauto.\nintros [s2 [t2 P]].\nexploit ssr_well_behaved.\neauto.\neexact P.\nsimpl; intros Q.\nexists (t2, s2).\nconstructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') : exists ev2 : event, t2 = ev2 :: nil.","conclusion":"exists ev2 : event, t2 = ev2 :: nil","hypotheses":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s')","proofString":"inv H1; econstructor; eauto."},{"statement":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') (H0 : exists ev2 : event, t2 = ev2 :: nil) : exists s2 : state (atomic L), Step (atomic L) (E0, s0) t2 s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) (E0, s0) t2 s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') (H0 : exists ev2 : event, t2 = ev2 :: nil)","proofString":"destruct H0 as [ev2 EQ]; subst t2.\nexploit ssr_receptive; eauto.\nintros [s2 [t2 P]].\nexploit ssr_well_behaved.\neauto.\neexact P.\nsimpl; intros Q.\nexists (t2, s2).\nconstructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') : exists s2 : state (atomic L), Step (atomic L) (E0, s0) (ev2 :: nil) s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) (E0, s0) (ev2 :: nil) s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s')","proofString":"exploit ssr_receptive; eauto.\nintros [s2 [t2 P]].\nexploit ssr_well_behaved.\neauto.\neexact P.\nsimpl; intros Q.\nexists (t2, s2).\nconstructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') : (exists (s2 : state L) (t2 : list event), Step L s0 (ev2 :: t2) s2) ->\nexists s2 : state (atomic L), Step (atomic L) (E0, s0) (ev2 :: nil) s2.","conclusion":"(exists (s2 : state L) (t2 : list event), Step L s0 (ev2 :: t2) s2) ->\nexists s2 : state (atomic L), Step (atomic L) (E0, s0) (ev2 :: nil) s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s')","proofString":"intros [s2 [t2 P]].\nexploit ssr_well_behaved.\neauto.\neexact P.\nsimpl; intros Q.\nexists (t2, s2).\nconstructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') (s2 : state L) (t2 : list event) (P : Step L s0 (ev2 :: t2) s2) : exists s1 : state (atomic L), Step (atomic L) (E0, s0) (ev2 :: nil) s1.","conclusion":"exists s1 : state (atomic L), Step (atomic L) (E0, s0) (ev2 :: nil) s1","hypotheses":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') (s2 : state L) (t2 : list event) (P : Step L s0 (ev2 :: t2) s2)","proofString":"exploit ssr_well_behaved.\neauto.\neexact P.\nsimpl; intros Q.\nexists (t2, s2).\nconstructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') (s2 : state L) (t2 : list event) (P : Step L s0 (ev2 :: t2) s2) (Q : output_trace t2) : exists s1 : trace * state L,\n  atomic_step L (globalenv L) (E0, s0) (ev2 :: nil) s1.","conclusion":"exists s1 : trace * state L,\n  atomic_step L (globalenv L) (E0, s0) (ev2 :: nil) s1","hypotheses":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') (s2 : state L) (t2 : list event) (P : Step L s0 (ev2 :: t2) s2) (Q : output_trace t2)","proofString":"exists (t2, s2).\nconstructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') (s2 : state L) (t2 : list event) (P : Step L s0 (ev2 :: t2) s2) (Q : output_trace t2) : atomic_step L (globalenv L) (E0, s0) (ev2 :: nil) (t2, s2).","conclusion":"atomic_step L (globalenv L) (E0, s0) (ev2 :: nil) (t2, s2)","hypotheses":"(L : semantics) (H : strongly_receptive L) (ev ev2 : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev2 :: nil)) (s0 : state L) (t : list event) (s' : state L) (H2 : Step L s0 (ev :: t) s') (s2 : state L) (t2 : list event) (P : Step L s0 (ev2 :: t2) s2) (Q : output_trace t2)","proofString":"constructor; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (t : list event) (s0 : state L) (H2 : output_trace (ev :: t)) : exists s2 : state (atomic L), Step (atomic L) (ev :: t, s0) t2 s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) (ev :: t, s0) t2 s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (t : list event) (s0 : state L) (H2 : output_trace (ev :: t))","proofString":"simpl in H2; destruct H2.\nassert (t2 = ev :: nil).\ninv H1; simpl in H0; tauto.\nsubst t2.\nexists (t, s0).\nconstructor; auto.\nsimpl; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t) : exists s2 : state (atomic L), Step (atomic L) (ev :: t, s0) t2 s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) (ev :: t, s0) t2 s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t)","proofString":"assert (t2 = ev :: nil).\ninv H1; simpl in H0; tauto.\nsubst t2.\nexists (t, s0).\nconstructor; auto.\nsimpl; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t) : t2 = ev :: nil.","conclusion":"t2 = ev :: nil","hypotheses":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t)","proofString":"inv H1; simpl in H0; tauto."},{"statement":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t) (H3 : t2 = ev :: nil) : exists s2 : state (atomic L), Step (atomic L) (ev :: t, s0) t2 s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) (ev :: t, s0) t2 s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (t2 : trace) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) t2) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t) (H3 : t2 = ev :: nil)","proofString":"subst t2.\nexists (t, s0).\nconstructor; auto.\nsimpl; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev :: nil)) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t) : exists s2 : state (atomic L), Step (atomic L) (ev :: t, s0) (ev :: nil) s2.","conclusion":"exists s2 : state (atomic L), Step (atomic L) (ev :: t, s0) (ev :: nil) s2","hypotheses":"(L : semantics) (H : strongly_receptive L) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev :: nil)) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t)","proofString":"exists (t, s0).\nconstructor; auto.\nsimpl; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev :: nil)) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t) : Step (atomic L) (ev :: t, s0) (ev :: nil) (t, s0).","conclusion":"Step (atomic L) (ev :: t, s0) (ev :: nil) (t, s0)","hypotheses":"(L : semantics) (H : strongly_receptive L) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev :: nil)) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t)","proofString":"constructor; auto.\nsimpl; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev :: nil)) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t) : output_trace (ev :: t).","conclusion":"output_trace (ev :: t)","hypotheses":"(L : semantics) (H : strongly_receptive L) (ev : event) (H1 : match_traces (symbolenv (atomic L)) (ev :: nil) (ev :: nil)) (t : list event) (s0 : state L) (H0 : output_event ev) (H2 : output_trace t)","proofString":"simpl; auto."},{"statement":"(L : semantics) (H : strongly_receptive L) : single_events (atomic L).","conclusion":"single_events (atomic L)","hypotheses":"(L : semantics) (H : strongly_receptive L)","proofString":"red.\nintros.\ninv H0; simpl; lia."},{"statement":"(L : semantics) (H : strongly_receptive L) : forall (s : state (atomic L)) (t : trace) (s' : state (atomic L)),\nStep (atomic L) s t s' -> (Datatypes.length t <= 1)%nat.","conclusion":"forall (s : state (atomic L)) (t : trace) (s' : state (atomic L)),\nStep (atomic L) s t s' -> (Datatypes.length t <= 1)%nat","hypotheses":"(L : semantics) (H : strongly_receptive L)","proofString":"intros.\ninv H0; simpl; lia."},{"statement":"(L : semantics) (H : strongly_receptive L) (s : state (atomic L)) (t : trace) (s' : state (atomic L)) (H0 : Step (atomic L) s t s') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(L : semantics) (H : strongly_receptive L) (s : state (atomic L)) (t : trace) (s' : state (atomic L)) (H0 : Step (atomic L) s t s')","proofString":"inv H0; simpl; lia."}]}