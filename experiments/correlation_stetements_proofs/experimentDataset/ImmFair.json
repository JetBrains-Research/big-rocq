[{"statement":"Lemma fsupp_rf_sb_loc: fsupp (rf G ⨾ sb G ∩ same_loc (lab G)).","proof":"apply fsupp_seq; auto using fsupp_rf, fsupp_sb_loc.\n"},{"statement":"Lemma fsupp_rf_sb_loc_ct (SCpL: sc_per_loc G):\n    fsupp (rf G ⨾ sb G ∩ same_loc (lab G))⁺.","proof":"eapply fsupp_mori with (x := (co G)^* ⨾ rf G ⨾ sb G ∩ same_loc (lab G)).\n2: {\napply fsupp_seq; [| by apply fsupp_rf_sb_loc].\napply fsupp_ct_rt.\nrewrite ct_of_trans; [| by apply WF].\napply FAIR.\n}\nred.\nrewrite ctEE.\napply inclusion_bunion_l.\nintros i _.\ninduction i.\n{\nsimpl.\napply seq_mori; basic_solver.\n}\nrewrite pow_S_end.\nrewrite IHi.\narewrite (rf G ≡ ⦗W⦘ ⨾ rf G) at 2.\n{\nrewrite wf_rfD; basic_solver.\n}\nhahn_frame.\netransitivity; [| apply inclusion_t_rt].\nrewrite ct_end.\nhahn_frame_l.\napply rf_sb_loc_w_in_co; auto.\n"},{"statement":"Lemma clos_trans_domb_begin {A: Type} (r: relation A) (s: A -> Prop)\n        (DOMB_S: domb r s):\n    ⦗s⦘ ⨾ r⁺ ≡ (⦗s⦘ ⨾ r)⁺.","proof":"split; [| by apply inclusion_ct_seq_eqv_l].\nerewrite domb_rewrite with (r := r) at 1; eauto.\nrewrite ct_rotl.\nrewrite <- seqA.\nseq_rewrite <- ct_begin.\nrewrite inclusion_seq_eqv_r.\nbasic_solver.\n"},{"statement":"Lemma wf_ar_rf_ppo_loc_ct_inf_helper (r_ar r_ppo: relation actid)\n        (R_RFPPO_AC: acyclic (r_ar ∪ rf G ⨾ r_ppo ∩ same_loc (lab G)))\n        (R_RFPPO_NI: (r_ar ∪ rf G ⨾ r_ppo ∩ same_loc (lab G)) ⨾ ⦗is_init⦘ ≡ ∅₂)\n        (FSUPPr: fsupp (⦗set_compl is_init⦘ ⨾ r_ar⁺))\n        (R_PPO_SB: r_ppo ⊆ sb G)\n        (R_RFPPO_CLOS: r_ar ⨾ (rf G ⨾ r_ppo ∩ same_loc (lab G))⁺ ⊆ r_ar⁺)\n        (SCpL: sc_per_loc G):\n    well_founded (⦗set_compl is_init⦘ ⨾ (r_ar ∪ rf G ;; r_ppo ∩ same_loc (lab G))⁺).","proof":"apply fsupp_well_founded.\n3: {\ngeneralize transitive_ct.\nbasic_solver.\n}\n2: {\neapply irreflexive_mori; [| by apply R_RFPPO_AC]; eauto.\nred.\nbasic_solver.\n}\nrewrite clos_trans_domb_begin.\n2: {\ngeneralize R_RFPPO_NI.\nbasic_solver 10.\nUnshelve.\nall: by eauto.\n}\nrewrite seq_union_r.\neapply fsupp_mori.\n{\nred.\neapply clos_trans_mori, union_mori; [reflexivity| ].\napply inclusion_seq_eqv_l.\n}\nrewrite ct_unionE.\napply fsupp_union.\n{\nrewrite R_PPO_SB.\nby apply fsupp_rf_sb_loc_ct.\n}\napply fsupp_seq.\n{\napply fsupp_ct_rt.\nrewrite R_PPO_SB.\nby apply fsupp_rf_sb_loc_ct.\n}\neapply fsupp_mori; [| by apply FSUPPr].\nred.\nrewrite rtE, seq_union_r, seq_id_r.\nrewrite seqA, R_RFPPO_CLOS; auto.\netransitivity.\n2: {\nrewrite <- ct_of_ct.\nreflexivity.\n}\netransitivity.\n2: {\napply inclusion_ct_seq_eqv_l.\n}\napply clos_trans_mori.\nunionL; hahn_frame_l; try reflexivity.\nrewrite <- ct_step.\nreflexivity.\n"},{"statement":"Lemma imm_s_fair_fsupp_sc (IMM_FAIR: imm_s_fair G sc):\n    fsupp sc.","proof":"eapply fsupp_mori; [| by apply IMM_FAIR].\nred.\nrewrite <- ct_step.\nunfold ar.\ndo 2 rewrite <- inclusion_union_r1.\napply doma_helper.\ninversion WFSC.\nrewrite wf_scD.\nred.\nintros ? ? ?%seq_eqv_lr.\neapply read_or_fence_is_not_init; eauto.\ntype_solver.\n"},{"statement":"Lemma fin_exec_imm_s_fair G sc (WF: Wf G) (WFSC: wf_sc G sc)\n      (FIN: fin_exec G):\n  imm_s_fair G sc.","proof":"red.\nred in FIN.\neapply fsupp_mori.\n2: {\neapply fsupp_cross with (s' := set_full); eauto.\n}\nred.\nrewrite ct_begin, wf_arE; auto.\nbasic_solver.\n"},{"statement":"Lemma fin_exec_imm_fair G (WF: Wf G)\n      (FIN: fin_exec G):\n  imm_fair G.","proof":"red.\nred in FIN.\neapply fsupp_mori.\n2: {\neapply fsupp_cross with (s' := set_full); eauto.\n}\nred.\nrewrite ct_begin, imm.wf_arE; auto.\nbasic_solver.\n"}]