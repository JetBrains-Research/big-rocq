[{"statement":"Lemma urr_n_f_alt_union_eqv l A r thread\n  (SB : dom_rel (sb ⨾ ⦗ eq r ⦘) ⊆₁ A)\n  (NF : ~ F r)\n  (TID : tid r = thread):\n  c_cur G sc thread l (A ∪₁ eq r)\n      ≡\n  urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗ Tid_ thread ∪₁ Init ⦘ ∪\n  ⦗ W_ l ⦘ ⨾ ⦗eq r⦘ ∪\n  ⦗ Loc_ l ⦘ ⨾ rf ⨾ ⦗eq r⦘ ∪\n  (msg_rel G sc l ∪ ⦗ Loc_ l ⦘) ⨾\n    rf ⨾ ⦗ Acq ⦘ ⨾ ⦗eq r⦘.","proof":"rewrite c_cur_union.\nunfold c_cur; split.\n- unionL; [basic_solver 21|].\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗ set_compl F ⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘).\nby basic_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\n* arewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ⊆ ⦗eq r⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘) by basic_solver.\nunionR left -> left -> left.\nhahn_frame; revert SB; basic_solver.\n* basic_solver 21.\n* basic_solver 21.\n* done.\n- unionL.\n* case_refl (sb ⨾ ⦗eq r⦘).\nby basic_solver 21.\narewrite_id ⦗A⦘; rels.\narewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver 12.\n* by unfold urr; basic_solver 21.\n* by unfold urr; rewrite (dom_l (wf_rfD WF)) at 1; basic_solver 21.\n* relsf; unionL.\nby sin_rewrite (msg_rel_urr WF); basic_solver 12.\nunfold urr; rewrite (dom_l (wf_rfD WF)) at 1; basic_solver 21.\n"},{"statement":"Lemma urr_w_alt_union_eqv l A w thread\n  (SB : dom_rel (sb ⨾ ⦗ eq w ⦘) ⊆₁ A)\n  (WW : W w)\n  (TID : tid w = thread):\n  c_cur G sc thread l (A ∪₁ eq w)\n      ≡\n  urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq w⦘)^? ⨾ ⦗ Tid_ thread ∪₁ Init ⦘ ∪\n  ⦗ W_ l ⦘ ⨾ ⦗eq w⦘.","proof":"rewrite urr_n_f_alt_union_eqv; auto.\nrewrite (dom_r (wf_rfD WF)); type_solver 21.\ntype_solver 21.\n"},{"statement":"Lemma urr_acq_n_f_alt_union_eqv l A r thread\n  (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A)\n  (NF : ~ F r)\n  (TID : tid r = thread) :\n  c_acq G sc thread l (A ∪₁ eq r)\n      ≡\n  (urr G sc l ⨾ ⦗A⦘ ⨾ (sb ⨾ ⦗eq r⦘)^? ⨾ ⦗ Tid_ thread ∪₁ Init ⦘ ∪\n   (msg_rel G sc l ⨾ rf ⨾ ⦗ Tid_ thread ∪₁ Init ⦘ ⨾ ⦗A⦘)) ∪\n  ⦗ W_ l ⦘ ⨾ ⦗eq r⦘ ∪\n  ⦗ Loc_ l ⦘ ⨾ rf ⨾ ⦗eq r⦘ ∪\n  (msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘.","proof":"unfold c_acq; rewrite crE at 1.\nrewrite seq_union_l; rewrite seq_union_r; rewrite seq_id_l.\narewrite (urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗A ∪₁ eq r⦘ ≡            c_cur G sc thread l (A ∪₁ eq r)).\nrewrite (id_union A); rewrite (unionC ⦗A⦘).\nrewrite !seq_union_r.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ⦗eq r⦘) by basic_solver.\nrewrite urr_n_f_alt_union_eqv; eauto.\nunfold msg_rel.\nbasic_solver 21.\n"},{"statement":"Lemma urr_rel_n_f_alt_union_eqv l l' A w thread\n  (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A)\n  (WW : W w)\n  (TID : tid w = thread):\n  c_rel G sc thread l l' (A ∪₁ eq w) ≡\n  c_rel G sc thread l l' A ∪ ⦗Rel⦘ ⨾ ⦗Loc_ l⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘ ∪\n  urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘.","proof":"unfold c_rel.\nsplit.\n- rewrite (id_union A) at 1; relsf.\nunionL.\n* basic_solver 21.\n* arewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘ ⊆ ⦗ set_compl F ⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq w⦘).\nby type_solver 21.\narewrite (⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘  ⨾ ⦗Rel⦘ ⨾ ⦗W ∩₁ Loc_ l' ∪₁ F⦘).\nby type_solver 21.\nsin_rewrite (urr_non_f WF).\nrelsf; unionL.\n+ unionR right; revert SB; type_solver 21.\n+ unionR left -> right; rewrite (dom_r (wf_rfD WF)); type_solver 21.\n+ rewrite (dom_r (wf_rfD WF)); type_solver 21.\n+ done.\n- unionL.\n* basic_solver.\n* unfold urr; basic_solver 21.\n* arewrite_id ⦗A⦘; rels.\narewrite (sb ⊆ hb^?).\nsin_rewrite urr_hb; basic_solver.\n"},{"statement":"Lemma dom_rel_r l locr thread w r\n  (LOC : loc lab r = Some locr)\n  (RF : rf w r)\n  (TID : tid r = thread) :\n    (dom_rel\n       (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘) ≡₁\n       if LocSet.Facts.eq_dec l locr then eq w else ∅).","proof":"split.\n- unfolder; ins; desf.\ngeneralize (wf_rff WF); basic_solver.\napply n; eauto.\ngeneralize (((wf_rfl WF) x y) H0); unfold same_loc; ins; congruence.\n- assert (loc lab w = Some locr).\nby generalize (((wf_rfl WF) w r) RF); unfold same_loc; ins; congruence.\ndesf; basic_solver 21.\n"},{"statement":"Lemma t_cur_urr_union_eqv l A thread r\n  (SB : dom_rel (sb ⨾ ⦗eq r⦘) ⊆₁ A)\n  (NF : ~ F r)\n  (TID : tid r = thread) :\n  t_cur G sc thread l (A ∪₁ eq r) ≡₁\n  dom_rel (urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init ⦘⨾ ⦗A⦘) ∪₁\n  (W_ l ∩₁ eq r ∪₁\n   dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘) ∪₁\n   dom_rel\n     ((msg_rel G sc l ∪ ⦗Loc_ l⦘)\n      ⨾ rf ⨾ ⦗fun a : actid => Acq a⦘ ⨾ ⦗eq r⦘)).","proof":"unfold t_cur.\nrewrite urr_n_f_alt_union_eqv; auto.\nrewrite (@no_sb_to_init G); generalize (@sb_tid_init G); basic_solver 20.\n"},{"statement":"Lemma t_cur_urr_union_eqv_w l A thread w\n  (SB : dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ A)\n  (WW : W w)\n  (TID : tid w = thread) :\n  t_cur G sc thread l (A ∪₁ eq w) ≡₁\n  dom_rel (urr G sc l ⨾ ⦗Tid_ thread ∪₁ Init ⦘⨾ ⦗A⦘) ∪₁\n  Loc_ l ∩₁ eq w.","proof":"rewrite t_cur_urr_union_eqv; auto.\n2: by intros H; type_solver.\nsplit; [|basic_solver 10].\narewrite_id ⦗ Acq ⦘; rewrite seq_id_l.\narewrite (rf ⨾ ⦗ eq w ⦘ ⊆ ∅₂).\n2: basic_solver 10.\nrewrite (dom_r (wf_rfD WF)).\ntype_solver.\n"},{"statement":"Lemma t_acq_urr_union_eqv l A thread r\n  (SB : dom_rel (sb ⨾ ⦗ eq r ⦘) ⊆₁ A)\n  (NF : ~ F r)\n  (TID : tid r = thread) :\n  t_acq G sc thread l (A ∪₁ eq r) ≡₁\n  t_acq G sc thread l A ∪₁\n  (W_ l ∩₁ eq r ∪₁\n   dom_rel (⦗Loc_ l⦘ ⨾ rf ⨾ ⦗eq r⦘) ∪₁\n   dom_rel ((msg_rel G sc l ∪ ⦗Loc_ l⦘) ⨾ rf ⨾ ⦗eq r⦘)).","proof":"unfold t_acq.\nrewrite urr_acq_n_f_alt_union_eqv; eauto.\nunfold c_acq.\nunfold msg_rel.\nrewrite (@no_sb_to_init G); generalize (@sb_tid_init G); basic_solver 20.\n"},{"statement":"Lemma t_rel_union_eqv l l' A thread r\n  (SB : dom_rel (sb ⨾ ⦗ eq r ⦘) ⊆₁ A)\n  (RR : R r)\n  (TID : tid r = thread) :\n  t_rel G sc thread l l' (A ∪₁ eq r) ≡₁ t_rel G sc thread l l' A.","proof":"unfold t_rel, c_rel.\nrewrite (id_union A); rewrite !seq_union_r.\narewrite (⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗eq r⦘ ≡ ∅₂); rels.\ntype_solver 21.\n"},{"statement":"Lemma t_rel_w_union_eqv l l0 A thread w locw\n  (NINIT : ~ is_init w)\n  (CCLOS : doma (sb ⨾ ⦗ A ⦘) A)\n  (AACTS : A ⊆₁ E)\n  (NINA  : ~ A w)\n  (SB : doma (sb ⨾ ⦗eq w⦘) A)\n  (ACTS: E w)\n  (WW : W w)\n  (LOC : loc lab w = Some locw)\n  (TID : tid w = thread)\n  (FREFL : forall l y (Ws : W y) (LOC : loc lab y = Some l), urr G sc l y y)\n  (CREL : forall l l',\n    c_rel G sc thread l l' (A ∪₁ eq w)\n        ≡\n    c_rel G sc thread l l' A ∪\n    ⦗fun _ => l' = l⦘ ⨾\n    ⦗Rel⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘ ∪\n    urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗ Rel ⦘ ⨾ ⦗Loc_ l'⦘ ⨾ ⦗eq w⦘)\n  :\n  t_rel G sc thread l0 l (A ∪₁ eq w) ∪₁\n  (if Loc.eq_dec l0 l\n   then W ∩₁ Loc_ l ∩₁ Tid_ thread ∩₁ (A ∪₁ eq w)\n   else ∅)\n    ≡₁\n  if Loc.eq_dec l locw\n  then (if (is_rel lab w)\n        then t_cur G sc thread l0 A \n        else t_rel G sc thread l0 l A ∪₁\n             (if Loc.eq_dec l0 l\n              then W ∩₁ Loc_ l ∩₁ Tid_ thread ∩₁ A\n              else ∅)) ∪₁\n       (if Loc.eq_dec l0 locw then eq w else ∅)\n  else\n    t_rel G sc thread l0 l A ∪₁\n    (if Loc.eq_dec l0 l\n     then W ∩₁ Loc_ l ∩₁ Tid_ thread ∩₁ A\n     else ∅).","proof":"rewrite !ite_alt; rewrite !iteb_alt; rewrite !ite_alt.\nrewrite !set_inter_union_r.\nrewrite ite_union_t.\nunfold t_rel at 1; rewrite CREL; auto.\narewrite (W ∩₁ Loc_ l ∩₁ Tid_ thread ∩₁ eq w ≡₁ Loc_ l ∩₁ eq w) by basic_solver 12.\nassert (forall l,          dom_rel (urr G sc l ⨾ ⦗A⦘ ⨾ sb ⨾ ⦗eq w⦘) ≡₁          dom_rel (c_cur G sc (tid w) l A)) as CSB.\n{\nintros; unfold c_cur.\nsplit; intros x H; destruct H as [y H].\nall: hahn_rewrite <- seqA in H.\nhahn_rewrite <- seqA in H.\nall: apply seq_eqv_r in H; destruct H as [H X]; subst.\n{\ndestruct H as [z [H PSB]].\napply seq_eqv_r in H; desf.\nexists z; hahn_rewrite <- seqA; apply seq_eqv_r; split; auto.\napply seq_eqv_r; split; auto.\neapply sb_tid_init; eauto.\n}\napply seq_eqv_r in H; desc.\nexists w; hahn_rewrite <- seqA; hahn_rewrite <- seqA.\napply seq_eqv_r; split; auto.\nexists y; split.\nby basic_solver.\ndestruct (classic (is_init y)) as [IN|NIN].\n{\napply init_ninit_sb; auto.\n}\ndestruct (same_thread G y w) as [[ST|ST]|ST]; desf.\n{\nby apply AACTS.\n}\nrevert H0; basic_solver.\nexfalso; revert CCLOS; basic_solver.\n}\nassert (forall l' l'',          dom_rel (c_rel G sc (tid w) l' l'' A) ∪₁          dom_rel (c_cur G sc (tid w) l' A) ≡₁          dom_rel (c_cur G sc (tid w) l' A)) as CURREL.\nby unfold c_rel, c_cur; basic_solver 12.\ndestruct (classic (l = locw)) eqn:LL1; subst.\n{\nrewrite <- !ite_alt; rewrite !Loc.eq_dec_eq.\nrename locw into l.\nrewrite !ite_alt.\narewrite (⦗Loc_ l⦘ ⨾ ⦗eq w⦘ ≡ ⦗eq w⦘) by basic_solver.\nrewrite !dom_union.\ndestruct (classic (l0 = l)) eqn:LL2; subst.\n{\nrewrite <- !ite_alt; rewrite !Loc.eq_dec_eq.\narewrite (⦗fun _ : actid => l = l⦘ ≡ ⦗fun _ : actid => True⦘).\n{\nsplit; intros x y H; red; red in H; split; desf.\n}\nrewrite seq_id_l.\nrewrite (fun x => set_unionC x (dom_rel (⦗Rel⦘ ⨾ ⦗eq w⦘))).\nrewrite !set_unionA; rewrite set_unionC.\nrewrite !set_unionA.\narewrite (Loc_ l ∩₁ eq w ≡₁ eq w) by basic_solver.\narewrite (eq w ∪₁ dom_rel (⦗fun a : actid => Rel a⦘ ⨾ ⦗eq w⦘) ≡₁ eq w) by basic_solver.\nrewrite <- !set_unionA.\nrepeat (apply set_equiv_union; [|done]).\nrewrite <- iteb_alt.\ndestruct (is_rel lab w) eqn:RELEQ.\n{\narewrite (⦗Rel⦘ ⨾ ⦗eq w⦘ ≡ ⦗eq w⦘).\n{\nby apply seq_eqvK_l; ins; subst.\n}\nunfold t_cur.\nrewrite CSB; rewrite CURREL.\nsplit; intros x H; [|by left]; destruct H; desf.\nunfold c_cur.\nrevert H; basic_solver 21.\n}\narewrite (⦗fun a : actid => Rel a⦘ ⨾ ⦗eq w⦘ ≡ ∅₂) by basic_solver.\nby rels.\n}\nrewrite <- !ite_alt.\nrewrite !Loc.eq_dec_neq; auto.\narewrite (⦗fun _ : actid => l = l0⦘ ≡ ∅₂).\n{\nsplit; rels; intros x y H; inv H.\n}\nrels.\nrewrite <- iteb_alt; destruct (is_rel lab w) eqn: REL.\n{\narewrite (⦗Rel⦘ ⨾ ⦗eq w⦘ ≡ ⦗eq w⦘).\n{\nby apply seq_eqvK_l; ins; subst.\n}\nby rewrite CSB; rewrite CURREL.\n}\narewrite (⦗Rel⦘ ⨾ ⦗eq w⦘ ≡ ∅₂).\n{\nsplit; rels; intros x y H; apply seq_eqv_r in H; desf; red in H; desf.\n}\nby rels.\n}\nrewrite <- !ite_alt; rewrite (@Loc.eq_dec_neq _ l locw); auto.\nrewrite !ite_alt.\nrewrite <- !id_inter.\narewrite (Loc_ l ∩₁ eq w ≡₁ ∅) by basic_solver.\nunfold ifthenelse, t_rel; basic_solver 21.\n"},{"statement":"Lemma t_cur_urr_init\n      wi (C : actid -> Prop) l thread\n      (INC : C wi) (INIT : is_init wi) (LOC : Loc_ l wi):\n  t_cur G sc thread l C wi.","proof":"unfold t_cur, c_cur, urr.\ngeneralize (init_w WF); unfold seq; basic_solver 42.\n"},{"statement":"Lemma urr_refl l y (YW : W y) (LOC : loc lab y = Some l):\n  urr G sc l y y.","proof":"unfold urr.\nbasic_solver 21.\n"},{"statement":"Lemma t_rel_if_other_thread\n      C C' thread l l'\n      (CINIT : Init ∩₁ E ⊆₁ C)\n      (CINCL : C ⊆₁ C')\n      (CE : C' ⊆₁ E)\n      (COVSTEP : forall a, tid a = thread -> C' a -> C a) :\n  (t_rel G sc thread l l' C' ∪₁\n   (if LocSet.Facts.eq_dec l l'\n    then\n      W ∩₁ Loc_ l' ∩₁ Tid_ thread ∩₁ C'\n    else ∅)) ≡₁\n  (t_rel G sc thread l l' C ∪₁\n   (if LocSet.Facts.eq_dec l l'\n    then\n      W ∩₁ Loc_ l' ∩₁ Tid_ thread ∩₁ C\n    else ∅)).","proof":"apply set_equiv_union; [by symmetry; apply t_rel_other_thread|].\ndesf; basic_solver 21.\n"},{"statement":"Lemma s_tm_n_f_steps\n      C C' l \n      (CINIT : Init ∩₁ E ⊆₁ C)\n      (CINCL : C ⊆₁ C')\n      (COVSTEP : forall a, C' a -> ~ C a -> ~ (F∩₁Sc) a) :\n  S_tm G l C' ≡₁ S_tm G l C.","proof":"unfold S_tm, S_tmr.\narewrite (⦗F∩₁Sc⦘ ⨾ ⦗C'⦘ ≡ ⦗F∩₁Sc⦘ ⨾ ⦗C⦘); [|done].\nsplit; [|by rewrite CINCL].\nunfolder; ins; desf.\ndestruct (classic (C y)) as [H|H]; auto.\nexfalso; eapply COVSTEP; basic_solver.\n"}]